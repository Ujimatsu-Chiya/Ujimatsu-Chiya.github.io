[{"title":"使用GMP库生成随机数","url":"/gmp/random/","content":"\r\n使用GMP库生成随机数\r\n本文讲解使用GMP库生成随机数的方法，主要讲解gmp_randclass的使用方法。\r\n算法初始化\r\nGMP库提供状态初始化一共有三种方式，底层的函数分别如下：\r\n\r\ngmp_randinit_mt (gmp_randstate_t state)\r\nvoid gmp_randinit_lc_2exp (gmp_randstate_t state, const mpz_t a, unsigned long c, mp_bitcnt_t m2exp)\r\nint gmp_randinit_lc_2exp_size (gmp_randstate_t state, mp_bitcnt_t size)\r\n\r\n第一种方法使用的是梅森旋转算法。使用gmp_randclass初始化则可以写成如下代码：\r\ngmp_randclass st(gmp_randinit_mt);\r\n第二种方法使用的是线性同余算法，每次从旧状态\\(X\\)迭代出来的新状态\\(X&#39;\\)满足\\(X&#39;=(aX+c) \\bmod\r\n2^{\\texttt{m2exp}}\\)。使用gmp_randclass初始化则可以写成如下代码：\r\n// mpz_class a=13;// unsigned long int c = 133;// mp_bitcnt_t m2exp = 66;gmp_randclass st(gmp_randinit_lc_2exp,a,c,m2exp);\r\n第三种方法则是由第二种方法改进而来。同样使用线性同余算法，给定\\(\\mathtt{size}\\)，那么\\(a,c,\\texttt{m2exp}\\)从固定的表中选择，满足\\(\\mathtt{m2exp\\ge\r\nsize}\\)。使用gmp_randclass初始化则可以写成如下代码：\r\n// mp_bitcnt_t size = 64;gmp_randclass st(gmp_randinit_lc_2exp_size,size);\r\n需要注意的是，这种方法下参数size不能大于\\(128\\)。\r\n此外还有一个方法gmp_randinit_default，这是GMP库中采用的默认初始化方法，也就是梅森旋转算法。也就是说，这个方法和gmp_randinit_mt是完全一样的。使用gmp_randclass初始化则可以写成如下代码：\r\ngmp_randclass st(gmp_randinit_default);// 与gmp_randclass st(gmp_randinit_mt);完全一样。\r\n随机数种子\r\ngmp_randclass中有一个方法gmp_randclass::seed()用来给当前状态赋予随机数种子。分别接受以下两种不同类型的种子输入：\r\nvoid gmp_randclass::seed (unsigned long int s)void gmp_randclass::seed (mpz_class s)\r\n类似的，和使用srand(time(NULL))时一样，以time(NULL)传入随机数参数时，也可以写成：\r\ngmp_randclass st(gmp_randinit_mt);st.seed(time(NULL));\r\n产生随机数\r\ngmp_randclass中有三种产生整数的方法：\r\n\r\nmpz_class gmp_randclass::get_z_bits (mp_bitcnt_t l)\r\nmpz_class gmp_randclass::get_z_range (mpz_class n)\r\nmpf_class gmp_randclass::get_f (mp_bitcnt_t prec)\r\n\r\n第一种方法用于均匀产生\\([0,2^{l}-1]\\)中的所有\\(l\\)比特整数。其中入参还可以是mpz_class类型。\r\n第二种方法用于均匀产生\\([0,n-1]\\)中的所有整数。\r\n第三种方法用于均匀产生\\([0,1)\\)中的所有精确到前prec比特的小数。如果没有prec入参，那么生成的浮点数默认精度。\r\n示例程序\r\n为了保证程序能够复现，这里不引入时间作为随机数种子。\r\n# include &lt;bits/stdc++.h&gt;# include &quot;gmpxx.h&quot;using namespace std;int main()&#123;    gmp_randclass st(gmp_randinit_mt);    // st.seed(time(NULL));    const int N=20;    mpz_class n = 1000;    for(int i=0;i&lt;N;i++)&#123;        mpz_class r = st.get_z_range(n);        gmp_printf(&quot;%Zd &quot;,r);    &#125;&#125;//Output: 116 331 303 963 456 225 827 381 99 649 395 975 566 213 694 254 629 303 597 980 \r\n# include &lt;bits/stdc++.h&gt;# include &quot;gmpxx.h&quot;using namespace std;int main()&#123;    gmp_randclass st(gmp_randinit_mt);    //st.seed(time(NULL));    const int N=20;    mpz_class l = 4;    for(int i=0;i&lt;N;i++)&#123;        mpz_class r = st.get_z_bits(l);        gmp_printf(&quot;%Zd &quot;,r);    &#125;&#125;//Output: 4 11 15 3 8 1 11 13 3 9 11 15 6 5 6 14 5 15 5 4 \r\n# include &lt;bits/stdc++.h&gt;# include &quot;gmpxx.h&quot;using namespace std;int main()&#123;    gmp_randclass st(gmp_randinit_mt);    //st.seed(time(NULL));    const int N=20;    mp_bitcnt_t prec = 20;    for(int i=0;i&lt;N;i++)&#123;        mpf_class f = st.get_f(prec);        gmp_printf(&quot;%.22Ff\\n&quot;,f);    &#125;&#125;/*Output:0.79112625122070312500000.15363597869873046875000.01103115081787109375000.49701213836669921875000.73383331298828125000000.60958957672119140625000.65801525115966796875000.05114459991455078125000.40439128875732421875000.96839237213134765625000.85975170135498046875000.85151576995849609375000.21538352966308593750000.09102344512939453125000.41765403747558593750000.12621879577636718750000.30040454864501953125000.46122646331787109375000.70271778106689453125000.9579658508300781250000 */\r\n","categories":["GMP"]},{"title":"使用MSYS2在Windows编译GMP64位动态库","url":"/gmp/msys2-Windows-gmp64-shared/","content":"\r\n下载并安装MSYS2\r\n在MSYS2官网下载msys2-x86_64-20220603.exe，打开并直接完成安装。\r\n如果官网太慢，可以在清华源下载msys2-x86_64-20220603.exe。\r\n我将它安装在了D:\\msys64下。\r\n安装完成后会自动打开一个窗口，不用管它。\r\n接下来需要将D:\\msys64\\mingw64\\bin这个目录添加到系统变量Path中，如图：\r\n\r\n下载GMP库\r\n在GMP官网下载gmp-6.2.1.tar.xz，文件解压后存放在D:\\msys64\\home\\admin\\gmp-6.2.1中，其中admin是用户名。\r\n正式安装\r\n打开msys2根目录下的mingw64.exe，打开后窗口如下：\r\n\r\n注意红框是MINGW64.\r\n如果执行命令时下载速度太慢，可以先参考这里将镜像源改成优先使用清华源。也就是直接执行如下代码：\r\nsed -i &quot;s#mirror.msys2.org/#mirrors.tuna.tsinghua.edu.cn/msys2/#g&quot; /etc/pacman.d/mirrorlist*\r\n\r\n先更新软件源和软件\r\n\r\npacman -Syu\r\n\r\n安装如下内容\r\n\r\npacman -S mingw-w64-x86_64-gccpacman -S mingw-w64-x86_64-makepacman -S mingw-w64-x86_64-libtoolpacman -S autoconfpacman -S automakepacman -S mingw-w64-x86_64-python3pacman -S makepacman -S mingw-w64-x86_64-gdb\r\n\r\n跳转到解压后的GMP库的根目录，并进行动态库编译。\r\n\r\n这一部分的命令需要执行相当长的时间，电脑约运行了约\\(6\\)个小时。\r\n（\\(2022\\)年\\(11\\)月\\(19\\)日更新，在新电脑上编译用了不到半小时就完成了，取决于配置）\r\n cd gmp-6.2.1/ ./configure --disable-static --enable-sharedmakemake checkmake install\r\n执行完这些命令看到这个就可以了。\r\n\r\n正式使用GMP库\r\n如果直接使用命令行进行编译，那么编译命令需要添加多一个参数，如下：\r\ng++ main.cpp -lgmp\r\nCodeBlocks使用\r\n在Codeblocks中的设置——编译器——全局编译器设置——可执行工具链切换成msys2中的MinGW，如图\r\n\r\n然后再在连接器设置这里添加一个参数-lgmp即可。\r\n\r\nClion使用\r\n同样也需要先在Clion切换成MSYS2中的MinGW，如图\r\n\r\n如果发现这个红色警告Not\r\nFound，那么将\\msys64\\mingw64下的include\r\n文件夹整个复制到\\msys64\\mingw64\\x86_64-w64-mingw32下。\r\n创建一个新的项目后，需要在CMakeLists.txt中添加如下代码。\r\ntarget_link_libraries([Project-Name] D:\\\\\\\\msys64\\\\\\\\mingw64\\\\\\\\bin\\\\\\\\libgmp-10.dll)\r\n其中[Project-Name]是项目的名称。\r\nVscode使用\r\n新建一个文件夹，并且写好示例代码A.cpp。\r\n使用快捷键Ctrl+F5，显示该窗口后点击C++ (GDB/LLDB)，并点击安装好的MSYS2的g++.exe。\r\n\r\n\r\n运行后发现报错。打开/.vscode/task.json，在这个地方添加编译参数-lgmp。\r\n\r\n再一次使用Ctrl+F5运行即可。\r\n示例代码执行\r\n# include &lt;gmpxx.h&gt;int main()&#123;    mpz_t a,b;    mpz_init_set_str(a,&quot;1000000007&quot;,10);    printf(&quot;1000000007 is prime? %d\\n&quot;,mpz_probab_prime_p(a,50) &gt; 0);    mpz_set_str(a,&quot;10000000007&quot;,10);    printf(&quot;10000000007 is prime? %d\\n&quot;,mpz_probab_prime_p(a,50) &gt; 0);    int n=199,m=200;    //计算并输出199!和200!,199!+200!。    mpz_set_si(a,1);    mpz_init_set_si(b,1);    for(int i=1;i&lt;=n;i++)        mpz_mul_si(a,a,i);    for(int i=1;i&lt;=m;i++)        mpz_mul_si(b,b,i);    gmp_printf(&quot;%d!= %Zd\\n&quot;,n,a);    gmp_printf(&quot;%d!= %Zd\\n&quot;,m,b);    mpz_add(a,a,b);    gmp_printf(&quot;199!+200!= %Zd\\n&quot;,a);&#125;\r\n\r\n直接使用命令行来编译\r\n\r\n\r\n\r\nCodeBlocks执行结果\r\n\r\n\r\n\r\nClion执行结果\r\n\r\n\r\n\r\nVscode运行结果\r\n\r\n 另附：GMP库的文档。\r\n相关参考：[1]\r\n","categories":["GMP"]},{"title":"Mathematica 使用1","url":"/mathematica/mathematica1/","content":"\r\n本文记录部分Mathematica求解命令的使用方法。主要以实例展示。\r\nRSolve\r\nRSolve命令用于求解递推式。\r\n\r\n求递推式\\(f_1=1,f_n=2f_{n-1}+3\\)的通项公式：\r\n\r\nRSolve[&#123;f[n] == 2 f[n - 1] + 3, f[1] == 1&#125;, f[n], n](* Out: &#123;&#123;f[n] -&gt; -3 + 2^(1 + n)&#125;&#125; *)\r\n\r\n求解递推式如下递推式组合的通项公式\\(a_n,b_n\\)：\r\n\r\n\\[\\left\\{\\begin{aligned}\r\n&amp;a_{n+1}=b_n+2\\\\\r\n&amp;3b_{n+1}=a_n-5\\\\\r\n&amp;a_0=3\\\\\r\n&amp;b_0=1\r\n\\end{aligned}\\right.\\]\r\nRSolve[&#123;a[n + 1] == b[n] + 2, 3 b[n + 1] == a[n] - 5, a[0] == 3,   b[0] == 1&#125;, &#123;a, b&#125;, n](* &#123;&#123;a -&gt; Function[&#123;n&#125;,     1/4 3^(-n/      2) (5 + 5 (-1)^n + 5 Sqrt[3] - 5 (-1)^n Sqrt[3] + 2 3^(n/2))],   b -&gt; Function[&#123;n&#125;, -(1/4) 3^(-(1/2) - n/      2) (-5 + 5 (-1)^n - 5 Sqrt[3] - 5 (-1)^n Sqrt[3] +        2 3^(3/2 + n/2))]&#125;&#125;*)\r\nSum\r\nSum命令通常用于求解级数，或者是求和式的通项公式。\r\n\r\n计算巴塞尔问题\\(\\displaystyle{\\sum_{n=1}^{\\infty}}\r\n\\dfrac{1}{n^2}\\).\r\n\r\nSum[1/n^2, &#123;n, 1, Infinity&#125;](*Out: Pi^2/6*)\r\n\r\n计算\\(\\displaystyle{\\sum_{i=1}^{\\infty}}\r\n\\sum_{j=1}^i \\dfrac{1}{(i+1)^2j^2}\\).\r\n\r\nSum[1/(j^2 (i + 1)^2), &#123;i, 1, Infinity&#125;, &#123;j, 1, i&#125;](*Out: Pi^4/120*)\r\n\r\n令\\(a_n=(4n + 1)\\cdot3^n\\)，求\\(\\displaystyle{S_n=\\sum_{i=1}^n}\r\na_i\\)的通项公式。\r\n\r\nSum[(4 i + 1)*3^i, &#123;i, 1, n&#125;](*Out: 3/2 (1 - 3^n + 4 3^n n)*)\r\nIntegrate, NIntegrate\r\nIntegrate命令用于计算积分。\r\nNIntegrate命令用于计算定积分的数值值。一般难以解出解析解时使用。\r\n\r\n计算反常积分\\(\\displaystyle{\\int_{-\\infty}^{\\infty}\r\ne^{-x^2}dx}\\).\r\n\r\nIntegrate[E^&#123;-x^2&#125;, &#123;x, -Infinity, Infinity&#125;](*Out: &#123;Sqrt[Pi]&#125;*)NIntegrate[E^&#123;-x^2&#125;, &#123;x, -Infinity, Infinity&#125;](*Out: &#123;1.77245&#125;*)\r\n\r\n计算二重积分\\(\\displaystyle{\\iint_{D}\r\ne^{-x^2}dxdy}\\)，其中区域\\(D\\)是：\\((0\\le\r\nx\\le 1,0\\le y\\le x^2)\\)\r\n\r\nIntegrate[x y, &#123;x, 0, 1&#125;, &#123;y, 0, x^2&#125;](*Out: 1/12*)\r\n\r\n求解不定积分\\(\\displaystyle{\\int x\\cdot\r\n\\arctan xdx}\\)\r\n\r\nIntegrate[x*ArcTan[x], x](*Out: -(x/2) + ArcTan[x]/2 + 1/2 x^2 ArcTan[x]*)\r\nD, '\r\nD命令用于求解偏导。\r\n一个函数\\(f\\)后面加上一个'就用于求出它的一阶导函数\\(f&#39;\\)。\r\n\r\n计算\\(\\dfrac{d (x^n)}{dx}\\)。\r\n\r\nD[x^n, x](*Out: n x^(-1 + n)*)f[x_] = x^n(*Out: x^n *)f&#x27;[x](*Out: n x^(-1 + n) *)\r\n\r\n计算\\(\\dfrac{d^4 (e^x\\cdot\r\nx^4)}{dx^4}\\)。\r\n\r\nD[E^x*x^4, &#123;x, 4&#125;](*Out: 24 E^x + 96 E^x x + 72 E^x x^2 + 16 E^x x^3 + E^x x^4 *)f[x_] = E^x*x^4(*Out: E^x x^4 *)f&#x27;&#x27;&#x27;&#x27;[x](*Out: 24 E^x + 96 E^x x + 72 E^x x^2 + 16 E^x x^3 + E^x x^4 *)\r\n\r\n计算\\(\\dfrac{\\partial^2}{\\partial\r\nx\\partial y}\\dfrac{e^x}{\\sin y}\\)。\r\n\r\nD[E^x/Sin [y], x, y](*Out: -E^x Cot[y] Csc[y] *)\r\n\r\n计算\\(\\dfrac{\\partial^3}{\\partial\r\nx\\partial^2 y}\\dfrac{e^x}{\\sin y}\\)。\r\n\r\nD[E^x/Sin [y], &#123;x,1&#125;, &#123;y,2&#125;](*Out: E^x (Cot[y]^2 Csc[y] + Csc[y]^3) *)\r\n"},{"title":"MathJax实例","url":"/others/mathjax2/","content":"\r\n本篇文章基于MathJax编写了\\(15\\)个实例，尽量涵盖了各种常用符号，以熟悉各种符号的用法。\r\n扩展欧几里得算法（Python）\r\n$\\begin&#123;aligned&#125;&amp; \\texttt&#123;def ex_gcd(a, b):&#125;\\\\&amp; \\qquad \\texttt&#123;if b == 0: &#125;\\\\&amp; \\qquad \\qquad \\texttt&#123;return 1, 0, a&#125;\\\\&amp; \\qquad \\texttt&#123;else: &#125;\\\\&amp; \\qquad \\qquad \\texttt&#123;x, y, g = ex_gcd(b, a % b)&#125;\\\\&amp; \\qquad \\qquad \\texttt&#123;return y, x - (a // b) * y, g&#125;\\\\\\\\\\\\&amp; \\texttt&#123;N = 5&#125;\\\\&amp; \\texttt&#123;for n in range(1, N + 1):&#125;\\\\&amp; \\qquad \\texttt&#123;for m in range(1, N + 1):&#125;\\\\&amp; \\qquad \\qquad \\texttt&#123;print(ex_gcd(n, m))&#125;\\end&#123;aligned&#125;$\r\n\\(\\begin{aligned}\r\n&amp; \\texttt{def ex_gcd(a, b):}\\\\\r\n&amp; \\qquad \\texttt{if b == 0: }\\\\\r\n&amp; \\qquad \\qquad \\texttt{return 1, 0, a}\\\\\r\n&amp; \\qquad \\texttt{else: }\\\\\r\n&amp; \\qquad \\qquad \\texttt{x, y, g = ex_gcd(b, a % b)}\\\\\r\n&amp; \\qquad \\qquad \\texttt{return y, x - (a // b) * y, g}\\\\\r\n\\\\\r\n\\\\\r\n&amp; \\texttt{N = 5}\\\\\r\n&amp; \\texttt{for n in range(1, N + 1):}\\\\\r\n&amp; \\qquad \\texttt{for m in range(1, N + 1):}\\\\\r\n&amp; \\qquad \\qquad \\texttt{print(ex_gcd(n, m))}\r\n\\end{aligned}\\)\r\n范德蒙德行列式\r\n$$\\begin&#123;vmatrix&#125;1   &amp; 1   &amp; \\dots &amp; 1\\\\x_1 &amp; x_2 &amp; \\dots &amp; x_n\\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots\\\\x_1^&#123;n-1&#125; &amp; x_2^&#123;n-2&#125; &amp; \\dots &amp; x_n^&#123;n-1&#125;\\end&#123;vmatrix&#125; = \\prod_&#123;1\\le j\\le i\\le n&#125; (x_i-x_j)$$\r\n\\[\\det \\begin{bmatrix}\r\n1   &amp; 1   &amp; \\dots &amp; 1\\\\\r\nx_1 &amp; x_2 &amp; \\dots &amp; x_n\\\\\r\n\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots\\\\\r\nx_1^{n-1} &amp; x_2^{n-2} &amp; \\dots &amp; x_n^{n-1}\r\n\\end{bmatrix} = \\prod_{1\\le j\\le i\\le n} (x_i-x_j)\\]\r\n碳酸氢钙溶液加热\r\n$$\\mathrm&#123;Ca(HCO_3)_2\\xrightarrow&#123;\\triangle&#125;CaCO_3\\downarrow+CO_2\\uparrow+H_2O&#125;$$\r\n\\[\\mathrm{Ca(HCO_3)_2\\xrightarrow{\\triangle}CaCO_3\\downarrow+CO_2\\uparrow+H_2O}\\]\r\n薛定谔方程\r\n$$i\\hbar\\dfrac&#123;\\partial&#125;&#123;\\partial t&#125;|\\psi (t)\\rangle = \\hat&#123;H&#125;|\\psi(t)\\rangle$$$$i\\hbar\\dfrac&#123;\\partial&#125;&#123;\\partial t&#125;\\Psi (x,t) = \\left[-\\dfrac&#123;\\hbar^2&#125;&#123;2m&#125;\\dfrac&#123;\\partial^2&#125;&#123;\\partial x^2&#125;+V(x,t)\\right]\\Psi(x,t)$$\r\n\\[i\\hbar\\dfrac{\\partial}{\\partial t}|\\psi\r\n(t)\\rangle = \\hat{H}|\\psi(t)\\rangle\\]\r\n\\[i\\hbar\\dfrac{\\partial}{\\partial t}\\Psi\r\n(x,t) = \\left[-\\dfrac{\\hbar^2}{2m}\\dfrac{\\partial^2}{\\partial\r\nx^2}+V(x,t)\\right]\\Psi(x,t)\\]\r\n麦克斯韦方程组\r\n$$\\begin&#123;cases&#125;\\nabla \\cdot \\mathbf&#123;E&#125; = \\dfrac&#123;\\rho&#125;&#123;\\varepsilon_0&#125; &amp; \\text&#123;Gauss&#x27;s law&#125;\\\\\\nabla \\cdot \\mathbf&#123;B&#125;=0 &amp; \\text&#123;Gauss&#x27;s law for magnetism&#125;\\\\\\nabla \\times \\mathbf&#123;E&#125; = -\\dfrac&#123;\\partial\\mathbf&#123;B&#125;&#125;&#123;\\partial t&#125; &amp; \\text&#123;Maxwell–Faraday equation&#125;\\\\\\nabla \\times \\mathbf&#123;B&#125; =  \\mu_0 \\left(\\mathbf&#123;J&#125; + \\varepsilon_0\\dfrac&#123;\\partial \\mathbf&#123;E&#125;&#125;&#123;\\partial t&#125;\\right) &amp; \\text&#123;Ampère&#x27;s circuital law&#125;\\end&#123;cases&#125;$$\r\n\\[\\begin{cases}\r\n\\nabla \\cdot \\mathbf{E} = \\dfrac{\\rho}{\\varepsilon_0} &amp;\r\n\\text{Gauss&#39;s law}\\\\\r\n\\nabla \\cdot \\mathbf{B}=0 &amp; \\text{Gauss&#39;s law for magnetism}\\\\\r\n\\nabla \\times \\mathbf{E} = -\\dfrac{\\partial\\mathbf{B}}{\\partial t} &amp;\r\n\\text{Maxwell–Faraday equation}\\\\\r\n\\nabla \\times \\mathbf{B} =  \\mu_0 \\left(\\mathbf{J} +\r\n\\varepsilon_0\\dfrac{\\partial \\mathbf{E}}{\\partial t}\\right) &amp;\r\n\\text{Ampère&#39;s circuital law}\r\n\\end{cases}\\]\r\n异或运算\\(S=x \\oplus y\\)的真值表\r\n$$\\begin&#123;array&#125;&#123;|l|l|l|&#125;\\hlinex &amp; y &amp; S\\\\\\hdashline0 &amp; 0 &amp; 0\\\\\\hline0 &amp; 1 &amp; 1\\\\\\hline1 &amp; 0 &amp; 1\\\\\\hline1 &amp; 0 &amp; 0\\\\\\hline\\end&#123;array&#125;$$\r\n\\[\\begin{array}{|l|l|l|}\r\n\\hline\r\nx &amp; y &amp; S\\\\\r\n\\hdashline\r\n0 &amp; 0 &amp; 0\\\\\r\n\\hline\r\n0 &amp; 1 &amp; 1\\\\\r\n\\hline\r\n1 &amp; 0 &amp; 1\\\\\r\n\\hline\r\n1 &amp; 0 &amp; 0\\\\\r\n\\hline\r\n\\end{array}\\]\r\n狄利克雷函数\r\n$$ \\mathbf&#123;1&#125;_&#123;\\mathbb&#123;Q&#125;&#125;(x)=&#123;\\begin&#123;cases&#125;1&amp;x\\in \\mathbb &#123;Q&#125; \\\\0&amp;x\\notin \\mathbb &#123;Q&#125;\\end&#123;cases&#125;&#125;$$\r\n\\[ \\mathbf{1}_{\\mathbb{Q}}(x)=\r\n{\\begin{cases}\r\n1&amp;x\\in \\mathbb {Q} \\\\\r\n0&amp;x\\notin \\mathbb {Q}\r\n\\end{cases}}\\]\r\n雅可比符号\r\n$$\\left(\\dfrac&#123;a&#125;&#123;p&#125;\\right) =\\begin&#123;cases&#125;0 &amp; \\text&#123;if $a\\equiv 0\\pmod&#123;p&#125;$&#125;\\\\1 &amp; \\text&#123;if &#125;a\\not\\equiv 0\\pmod p \\wedge \\exists  x: x^2\\equiv a\\pmod p \\\\-1 &amp; \\text&#123;if &#125;a\\not\\equiv 0\\pmod p \\wedge \\nexists  x: x^2\\equiv a\\pmod p\\end&#123;cases&#125;$$\r\n\\[\\left(\\dfrac{a}{p}\\right) =\r\n\\begin{cases}\r\n0 &amp; \\text{if $a\\equiv 0\\pmod{p}$}\\\\\r\n1 &amp; \\text{if }a\\not\\equiv 0\\pmod p \\wedge \\exists  x: x^2\\equiv\r\na\\pmod p \\\\\r\n-1 &amp; \\text{if }a\\not\\equiv 0\\pmod p \\wedge \\nexists  x: x^2\\equiv\r\na\\pmod p\r\n\\end{cases}\\]\r\n斯托克斯公式\r\n$$\\oint_&#123;\\Gamma&#125;Pdx+Qdy+Rdz=\\iint_&#123;\\Sigma&#125;\\left(\\dfrac&#123;\\partial R&#125;&#123;\\partial y&#125;-\\dfrac&#123;\\partial Q&#125;&#123;\\partial z&#125;\\right) dydz+\\left(\\dfrac&#123;\\partial P&#125;&#123;\\partial z&#125;-\\dfrac&#123;\\partial R&#125;&#123;\\partial x&#125;\\right) dzdx+\\left(\\dfrac&#123;\\partial Q&#125;&#123;\\partial x&#125;-\\dfrac&#123;\\partial P&#125;&#123;\\partial y&#125;\\right) dxdy$$\r\n\\[\\oint_{\\Gamma}Pdx+Qdy+Rdz=\\iint_{\\Sigma}\\left(\\dfrac{\\partial\r\nR}{\\partial y}-\\dfrac{\\partial Q}{\\partial z}\\right)\r\ndydz+\\left(\\dfrac{\\partial P}{\\partial z}-\\dfrac{\\partial R}{\\partial\r\nx}\\right) dzdx+\\left(\\dfrac{\\partial Q}{\\partial x}-\\dfrac{\\partial\r\nP}{\\partial y}\\right) dxdy\\]\r\n\\(\\Gamma\\)函数与黎曼\\(\\zeta\\)函数\r\n$$\\begin&#123;aligned&#125;\\Gamma(z)=&amp;\\int_&#123;0&#125;^&#123;\\infty&#125; t^&#123;z-1&#125; \\mathrm&#123;e&#125;^&#123;-t&#125;dt &amp;\\\\\\zeta(s)=&amp;\\sum_&#123;n=1&#125;^&#123;\\infty&#125; \\dfrac&#123;1&#125;&#123;n^s&#125;\\end&#123;aligned&#125;$$\r\n\\[\\begin{aligned}\r\n\\Gamma(z)=&amp;\\int_{0}^{\\infty} t^{z-1} \\mathrm{e}^{-t}dt &amp;\\\\\r\n\\zeta(s)=&amp;\\sum_{n=1}^{\\infty} \\dfrac{1}{n^s}\r\n\\end{aligned}\\]\r\n德摩根律\r\n$$\\begin&#123;align&#125;&amp; \\neg (P\\lor Q)\\Longleftrightarrow \\neg P\\land\\neg Q \\tag&#123;propositional logic&#125;\\\\&amp; \\neg (P\\land Q)\\Longleftrightarrow \\neg P\\lor\\neg Q \\\\&amp; (A \\cup B)^&#123;\\complement&#125;=A^&#123;\\complement&#125;\\cap B^&#123;\\complement&#125; \\tag&#123;set theory&#125;\\\\&amp; (A \\cap B)^&#123;\\complement&#125;=A^&#123;\\complement&#125;\\cup B^&#123;\\complement&#125; \\\\&amp; \\overline&#123;A\\cup B&#125;=\\overline&#123;A&#125;\\cap\\overline&#123;B&#125; \\tag&#123;probability theory&#125;\\\\&amp; \\overline&#123;A\\cap B&#125;=\\overline&#123;A&#125;\\cup\\overline&#123;B&#125;\\end&#123;align&#125;$$\r\n\\[\\begin{align}\r\n&amp; \\neg (P\\lor Q)\\Longleftrightarrow \\neg P\\land\\neg Q\r\n\\tag{propositional logic}\\\\\r\n&amp; \\neg (P\\land Q)\\Longleftrightarrow \\neg P\\lor\\neg Q \\\\\r\n&amp; (A \\cup B)^{\\complement}=A^{\\complement}\\cap B^{\\complement}\r\n\\tag{set theory}\\\\\r\n&amp; (A \\cap B)^{\\complement}=A^{\\complement}\\cup B^{\\complement} \\\\\r\n&amp; \\overline{A\\cup B}=\\overline{A}\\cap\\overline{B} \\tag{probability\r\ntheory}\\\\\r\n&amp; \\overline{A\\cap B}=\\overline{A}\\cup\\overline{B}\r\n\\end{align}\\]\r\n贝叶斯公式\r\n$$P(A_i|B)=\\dfrac&#123;P(B|A_i)\\cdot P(A_i)&#125;&#123;\\sum_&#123;j=1&#125;^n P(B|A_j)\\cdot P(A_j)&#125;$$\r\n\\[P(A_i|B)=\\dfrac{P(B|A_i)\\cdot\r\nP(A_i)}{\\sum_{j=1}^n P(B|A_j)\\cdot P(A_j)}\\]\r\n麦克劳林级数\r\n$$\\begin&#123;align&#125;&amp;e^x=\\sum_&#123;n=0&#125;^&#123;\\infty&#125; \\dfrac&#123;x^n&#125;&#123;n!&#125;\\\\&amp;\\sin x = \\sum_&#123;n=0&#125;^&#123;\\infty&#125; (-1)^n\\dfrac&#123;x^&#123;2n+1&#125;&#125;&#123;(2n+1)!&#125;\\\\&amp;\\cos x = \\sum_&#123;n=0&#125;^&#123;\\infty&#125; (-1)^n\\dfrac&#123;x^&#123;2n&#125;&#125;&#123;(2n)!&#125;\\\\&amp;\\ln(x+1) = \\sum_&#123;n=0&#125;^&#123;\\infty&#125; (-1)^n\\dfrac&#123;x^&#123;n+1&#125;&#125;&#123;(n+1)!&#125;\\\\\\end&#123;align&#125;$$\r\n\\[\\begin{align}\r\n&amp;e^x=\\sum_{n=0}^{\\infty} \\dfrac{x^n}{n!}\\\\\r\n&amp;\\sin x = \\sum_{n=0}^{\\infty} (-1)^n\\dfrac{x^{2n+1}}{(2n+1)!}\\\\\r\n&amp;\\cos x = \\sum_{n=0}^{\\infty} (-1)^n\\dfrac{x^{2n}}{(2n)!}\\\\\r\n&amp;\\ln(x+1) = \\sum_{n=0}^{\\infty} (-1)^n\\dfrac{x^{n+1}}{(n+1)!}\\\\\r\n\\end{align}\\]\r\n自然对数\\(e\\)的定义\r\n$$e=\\lim_&#123;x\\rightarrow\\infty&#125;\\left(1+\\dfrac&#123;1&#125;&#123;x&#125;\\right)^x$$\r\n\\[e=\\lim_{x\\rightarrow\\infty}\\left(1+\\dfrac{1}{x}\\right)^x\\]\r\n二项式定理\r\n$$(x+y)^n=\\sum_&#123;k=0&#125;^n \\dbinom&#123;n&#125;&#123;k&#125; x^ky^&#123;n-k&#125;$$\r\n\\[(x+y)^n=\\sum_{k=0}^n \\dbinom{n}{k}\r\nx^ky^{n-k}\\]\r\n","categories":["MathJax"]},{"title":"Win11 部分配置优化","url":"/others/win11-init/","content":"\r\n此处记录一些用于优化Win11系统体验的代码。\r\n# https://www.bilibili.com/video/BV1q34y1974q# 右键菜单默认折叠，修改成不折叠。reg add &quot;HKCU\\Software\\Classes\\CLSID\\&#123;86ca1aa0-34aa-4e8b-a509-50c905bae2a2&#125;\\InprocServer32&quot; /f /ve\r\n"},{"title":"使用Win11自带的winget安装软件包","url":"/others/winget/","content":"\r\n我之前是Win7用户，现在买了新电脑后，直接就变成了Win11用户。我对Win11这个系统一言难尽。不过我习惯了使用命令行后，就想着能不能在Windows上使用命令行安装软件包。经过探索，发现自带的winget能够满足我的要求。以下简要总结一下winget。\r\n官网\r\nhttps://winget.run/\r\n这个网站左上角可以下载winget自行安装。中间的搜索框可以查找任何软件。以微信为例（这里使用的是微信的英文wechat，避免找不到的可能）：\r\n\r\n点进去就能看到代码，直接复制到Powershell并执行就能安装微信：\r\nwinget install -e --id Tencent.WeChat\r\n一些小众对工具也能够在这里找到命令进行安装，比如pandoc：\r\nwinget install -e --id JohnMacFarlane.Pandoc\r\nwinget\r\nwinget本身不存储任何软件包，并且每一个包都有自己独特的ID。当输入安装命令后，它将会跳转到存好的的第三方链接，将整个软件包下载下来并自动安装（有些软件可能会弹窗出来要求手动安装）。\r\n以Python3.10为例，输入如下命令：\r\nwinget show Python.Python.3.10\r\n它就会展现这个软件包对第三方URL：\r\n\r\nwinget命令\r\n以下是winget的命令和选项：\r\n\r\n\r\n\r\ninstall\r\n安装给定的程序包\r\n\r\n\r\nshow\r\n显示包的相关信息\r\n\r\n\r\nsource\r\n管理程序包的来源\r\n\r\n\r\nsearch\r\n查找并显示程序包的基本信息\r\n\r\n\r\nlist\r\n显示已安装的程序包\r\n\r\n\r\nupgrade\r\n显示并执行可用升级\r\n\r\n\r\nuninstall\r\n卸载给定的程序包\r\n\r\n\r\nhash\r\n哈希安装程序的帮助程序\r\n\r\n\r\nvalidate\r\n验证清单文件\r\n\r\n\r\nsettings\r\n打开设置或设置管理员设置\r\n\r\n\r\nfeatures\r\n显示实验性功能的状态\r\n\r\n\r\nexport\r\n导出已安装程序包的列表\r\n\r\n\r\nimport\r\n安装文件中的所有程序包\r\n\r\n\r\n\r\n\r\n\r\n\r\n-v,--version\r\n显示工具的版本\r\n\r\n\r\n--info\r\n显示工具的常规信息\r\n\r\n\r\n\r\n以下讲解几个我常用对命令：\r\ninstall\r\n顾名思义，直接安装软件包。\r\n它先将软件包下载到C:\\Users\\Chiya\\AppData\\Local\\Temp\\WinGet目录下再进行安装。安装成功后会删除。\r\n主要是注意参数-l，附加这个参数可以将软件安装到指定目录（如果支持的话）。如下命令将会自动将git安装到这个文件夹下：\r\nwinget install -e --id Git.Git -l &quot;D:\\git&quot;\r\n不加这个参数会默认装到C盘，但是我不喜欢什么东西都往C盘塞，此时就会用到这个参数。\r\nshow\r\n如winget处的展示，用于展现这个软件包的一些元数据信息。\r\nsearch\r\n根据输入的关键词搜索相关软件包的信息（如绑定的ID）。如果官网命令中给出的ID在winget安装不成功，那么可以通过search查找到正确的ID。以msys2为例：\r\nwinget search msys2.msys2\r\n\r\nlist\r\n列出当前已经安装的所有软件的一些信息。\r\n\r\nupgrade\r\n用于展示目前所有软件包是否有新版。命令的后面添加软件包的ID后，会对软件执行升级。\r\n\r\n如果对Typora进行升级，那么执行：\r\nwinget upgrade appmakes.Typora\r\nuninstall\r\n顾名思义，直接卸载软件。为了准确描述卸载哪个软件包，建议使用命令winget list列出的ID进行定位。\r\n彩蛋\r\n如果执行的命令都有一个选项--rainbow，那么命令运行时进度条都将会变成彩色。\r\n新系统安装软件命令\r\n为了能够减轻寻找软件的负担，提前写好这些命令进行软件安装，那么以后就不用再去各个网站上搜集软件了！\r\n# 安装QQwinget install -e --id Tencent.QQ -l &quot;D:\\QQ&quot;# 安装微信winget install -e --id Tencent.WeChat -l &quot;D:\\Wechat&quot;# 安装Google Chromewinget install -e --id Google.Chrome -l &quot;D:\\Chrome&quot;# 安装Notepad++winget install -e --id Notepad++.Notepad++ -l &quot;D:\\Notepad++&quot;# 安装Visual Studio Code（不过这里不建议使用winget下载，速度非常慢，网上有改cdn的攻略）winget install -e --id Microsoft.VisualStudioCode -l &quot;D:\\VScode&quot;# 安装Pycharm社区版winget install -e --id JetBrains.PyCharm.Community -l &quot;D:\\Pycharm&quot;# 安装CLionwinget install -e --id JetBrains.CLion -l &quot;D:\\CLion&quot;# 安装CodeBlockswinget install -e --id Codeblocks.Codeblocks &quot;D:\\Codeblocks&quot;# 安装MSYS2winget install -e --id MSYS2.MSYS2 -l &quot;D:\\msys2&quot;# 安装Python 3.10winget install -e --id Python.Python.3.10 -l &quot;D:\\Python\\Python310&quot;# 安装Nodejs (LTS)winget install -e --id OpenJS.NodeJS.LTS -l &quot;D:\\nodejs&quot;# 安装pandocwinget install -e --id JohnMacFarlane.Pandoc# 安装gitwinget install -e --id Git.Git -l &quot;D:\\git&quot;\r\n"},{"title":"MathJax数学符号","url":"/others/mathjax1/","content":"\r\n本篇文章简要地列出了MathJax中的所有符号（可能不全），并按照形状进行分类。\r\n区间形状\r\n\r\n\r\n\r\n区间类型\r\n代码\r\n\r\n\r\n\r\n\r\n\\(\\langle\\rangle\\)\r\n\\langle\\rangle\r\n\r\n\r\n\\(\\lfloor\\rfloor\\)\r\n\\lfloor\\rfloor\r\n\r\n\r\n\\(\\lceil\\rceil\\)\r\n\\lceil\\rceil\r\n\r\n\r\n\\(()\\)\r\n()\r\n\r\n\r\n\\([]\\)\r\n[]\r\n\r\n\r\n\\(\\{\\}\\)\r\n\\{\\}\r\n\r\n\r\n\\(\\lmoustache\\rmoustache\\)\r\n\\lmoustache\\rmoustache\r\n\r\n\r\n\\(\\lvert\\rvert\\)\r\n\\lvert\\rvert\r\n\r\n\r\n\\(\\lVert\\rVert\\)\r\n\\lVert\\rVert\r\n\r\n\r\n\\(\\lgroup\\rgroup\\)\r\n\\lgroup\\rgroup\r\n\r\n\r\n\r\n希腊字母\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n大写\r\n\r\n小写\r\n\r\n\r\n\r\n\r\n\r\n\\(A\\)\r\nA\r\n\\(\\alpha\\)\r\n\\alpha\r\n\r\n\r\n\\(B\\)\r\nB\r\n\\(\\beta\\)\r\n\\beta\r\n\r\n\r\n\\(\\Gamma,\\varGamma\\)\r\n\\Gamma,\\varGamma\r\n\\(\\gamma\\)\r\n\\gamma\r\n\r\n\r\n\\(\\Delta,\\varDelta\\)\r\n\\Delta,\\varDelta\r\n\\(\\delta\\)\r\n\\delta\r\n\r\n\r\n\\(E\\)\r\nE\r\n\\(\\epsilon,\\varepsilon\\)\r\n\\epsilon,\\varepsilon\r\n\r\n\r\n\\(Z\\)\r\nZ\r\n\\(\\zeta\\)\r\n\\zeta\r\n\r\n\r\n\\(H\\)\r\nH\r\n\\(\\eta\\)\r\n\\eta\r\n\r\n\r\n\\(\\Theta,\\varTheta\\)\r\n\\Theta,\\varTheta\r\n\\(\\theta,\\vartheta\\)\r\n\\theta,\\vartheta\r\n\r\n\r\n\\(I\\)\r\nI\r\n\\(\\iota\\)\r\n\\iota\r\n\r\n\r\n\\(K\\)\r\nK\r\n\\(\\kappa,\\varkappa\\)\r\n\\kappa,\\varkappa\r\n\r\n\r\n\\(\\Lambda,\\varLambda\\)\r\n\\Lambda,\\varLambda\r\n\\(\\lambda\\)\r\n\\lambda\r\n\r\n\r\n\\(M\\)\r\nM\r\n\\(\\mu\\)\r\n\\mu\r\n\r\n\r\n\\(N\\)\r\nN\r\n\\(\\nu\\)\r\n\\nu\r\n\r\n\r\n\\(\\Xi,\\varXi\\)\r\n\\Xi,\\varXi\r\n\\(\\xi\\)\r\n\\xi\r\n\r\n\r\n\\(O\\)\r\nO\r\n\\(\\omicron\\)\r\n\\omicron\r\n\r\n\r\n\\(\\Pi,\\varPi\\)\r\n\\Pi,\\varPi\r\n\\(\\pi,\\varpi\\)\r\n\\pi,\\varpi\r\n\r\n\r\n\\(P\\)\r\nP\r\n\\(\\rho,\\varrho\\)\r\n\\rho,\\varrho\r\n\r\n\r\n\\(\\Sigma,\\varSigma\\)\r\n\\Sigma,\\varSigma\r\n\\(\\sigma,\\varsigma\\)\r\n\\sigma,\\varsigma\r\n\r\n\r\n\\(T\\)\r\nT\r\n\\(\\tau\\)\r\n\\tau\r\n\r\n\r\n\\(\\Upsilon,\\varUpsilon\\)\r\n\\Upsilon,\\varUpsilon\r\n\\(\\upsilon\\)\r\n\\upsilon\r\n\r\n\r\n\\(\\Phi,\\varPhi\\)\r\n\\Phi,\\varPhi\r\n\\(\\phi,\\varphi\\)\r\n\\phi,\\varphi\r\n\r\n\r\n\\(X\\)\r\nX\r\n\\(\\chi\\)\r\n\\chi\r\n\r\n\r\n\\(\\Psi,\\varPsi\\)\r\n\\Psi,\\varPsi\r\n\\(\\psi\\)\r\n\\psi\r\n\r\n\r\n\\(\\Omega,\\varOmega\\)\r\n\\Omega,\\varOmega\r\n\\(\\omega\\)\r\n\\omega\r\n\r\n\r\n\r\n希伯来字母\r\n\r\n\r\n\r\n\\(\\aleph\\)\r\n\\aleph\r\n\r\n\r\n\\(\\beth\\)\r\n\\beth\r\n\r\n\r\n\\(\\daleth\\)\r\n\\daleth\r\n\r\n\r\n\\(\\gimel\\)\r\n\\gimel\r\n\r\n\r\n\r\n字体与注释\r\n使用\\mathxx{}时，公式中的所有字母将会转换成对应字体。而使用\\textxx{}时，里面的特殊字符也不会被转义。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\\(ABCDEFGHIJKLMNOPQRSTUVWXYZ\\)\r\n\\(abcdefghijklmnopqrstuvwxyz\\)\r\n\\(0123456789\\)\r\n原始字体\r\n\r\n\r\n\\(\\mathrm{ABCDEFGHIJKLMNOPQRSTUVWXYZ}\\)\r\n\\(\\mathrm{abcdefghijklmnopqrstuvwxyz}\\)\r\n\\(\\mathrm{0123456789}\\)\r\n\\mathrm{}\r\n\r\n\r\n\\(\\mathbf{ABCDEFGHIJKLMNOPQRSTUVWXYZ}\\)\r\n\\(\\mathbf{abcdefghijklmnopqrstuvwxyz}\\)\r\n\\(\\mathbf{0123456789}\\)\r\n\\mathbf{}\r\n\r\n\r\n\\(\\mathbb{ABCDEFGHIJKLMNOPQRSTUVWXYZ}\\)\r\n\\(\\mathbb{abcdefghijklmnopqrstuvwxyz}\\)\r\n\\(\\mathbb{0123456789}\\)\r\n\\mathrm{}\r\n\r\n\r\n\\(\\mathcal{ABCDEFGHIJKLMNOPQRSTUVWXYZ}\\)\r\n\\(\\mathcal{abcdefghijklmnopqrstuvwxyz}\\)\r\n\\(\\mathcal{0123456789}\\)\r\n\\mathcal{}\r\n\r\n\r\n\\(\\mathit{ABCDEFGHIJKLMNOPQRSTUVWXYZ}\\)\r\n\\(\\mathit{abcdefghijklmnopqrstuvwxyz}\\)\r\n\\(\\mathit{0123456789}\\)\r\n\\mathit{}\r\n\r\n\r\n\\(\\mathscr{ABCDEFGHIJKLMNOPQRSTUVWXYZ}\\)\r\n\\(\\mathscr{abcdefghijklmnopqrstuvwxyz}\\)\r\n\\(\\mathscr{0123456789}\\)\r\n\\mathscr{}\r\n\r\n\r\n\\(\\mathfrak{ABCDEFGHIJKLMNOPQRSTUVWXYZ}\\)\r\n\\(\\mathfrak{abcdefghijklmnopqrstuvwxyz}\\)\r\n\\(\\mathfrak{0123456789}\\)\r\n\\mathfrak{}\r\n\r\n\r\n\\(\\mathsf{ABCDEFGHIJKLMNOPQRSTUVWXYZ}\\)\r\n\\(\\mathsf{abcdefghijklmnopqrstuvwxyz}\\)\r\n\\(\\mathsf{0123456789}\\)\r\n\\mathsf{}\r\n\r\n\r\n\\(\\mathtt{ABCDEFGHIJKLMNOPQRSTUVWXYZ}\\)\r\n\\(\\mathtt{abcdefghijklmnopqrstuvwxyz}\\)\r\n\\(\\mathtt{0123456789}\\)\r\n\\mathtt{}\r\n\r\n\r\n\\(\\text{\\alpha in text mode\r\n}\\alpha\\)\r\n\\text{}\r\n\r\n\r\n\r\n\r\n\\(\\textrm{\\alpha in textrm mode\r\n}\\alpha\\)\r\n\\textrm{}\r\n\r\n\r\n\r\n\r\n\\(\\textbf{\\alpha in textbf mode\r\n}\\alpha\\)\r\n\\textbf{}\r\n\r\n\r\n\r\n\r\n\\(\\textit{\\alpha in textit mode\r\n}\\alpha\\)\r\n\\textit{}\r\n\r\n\r\n\r\n\r\n\\(\\textsf{\\alpha in textsf mode\r\n}\\alpha\\)\r\n\\textsf{}\r\n\r\n\r\n\r\n\r\n\\(\\texttt{\\alpha in texttt mode\r\n}\\alpha\\)\r\n\\texttt{}\r\n\r\n\r\n\r\n\r\n\\(\\boldsymbol{\\alpha}\\mathbf{\\alpha}\\)\r\n\\boldsymbol{\\alpha}\\mathbf{\\alpha}\r\n\r\n\r\n\r\n\r\n\r\n颜色\r\n命令\\color{}{}中的第一个参数可以是颜色名称，也可以是RGB参数。第二个参数则是正式染色的文字。\r\n\r\n\r\n\r\n展示\r\n代码\r\n\r\n\r\n\r\n\r\n\\(\\color{black}{ABCDabcd1234}\\)\r\n\\color{black}{ABCDabcd1234}\r\n\r\n\r\n\\(\\color{grey}{ABCDabcd1234}\\)\r\n\\color{grey}{ABCDabcd1234}\r\n\r\n\r\n\\(\\color{silver}{ABCDabcd1234}\\)\r\n\\color{silver}{ABCDabcd1234}\r\n\r\n\r\n\\(\\color{white}{ABCDabcd1234}\\)\r\n\\color{white}{ABCDabcd1234}\r\n\r\n\r\n\\(\\color{maroon}{ABCDabcd1234}\\)\r\n\\color{maroon}{ABCDabcd1234}\r\n\r\n\r\n\\(\\color{red}{ABCDabcd1234}\\)\r\n\\color{red}{ABCDabcd1234}\r\n\r\n\r\n\\(\\color{yellow}{ABCDabcd1234}\\)\r\n\\color{yellow}{ABCDabcd1234}\r\n\r\n\r\n\\(\\color{lime}{ABCDabcd1234}\\)\r\n\\color{lime}{ABCDabcd1234}\r\n\r\n\r\n\\(\\color{olive}{ABCDabcd1234}\\)\r\n\\color{olive}{ABCDabcd1234}\r\n\r\n\r\n\\(\\color{green}{ABCDabcd1234}\\)\r\n\\color{green}{ABCDabcd1234}\r\n\r\n\r\n\\(\\color{teal}{ABCDabcd1234}\\)\r\n\\color{teal}{ABCDabcd1234}\r\n\r\n\r\n\\(\\color{auqa}{ABCDabcd1234}\\)\r\n\\color{auqa}{ABCDabcd1234}\r\n\r\n\r\n\\(\\color{blue}{ABCDabcd1234}\\)\r\n\\color{blue}{ABCDabcd1234}\r\n\r\n\r\n\\(\\color{navy}{ABCDabcd1234}\\)\r\n\\color{navy}{ABCDabcd1234}\r\n\r\n\r\n\\(\\color{purple}{ABCDabcd1234}\\)\r\n\\color{purple}{ABCDabcd1234}\r\n\r\n\r\n\\(\\color{fuchsia}{ABCDabcd1234}\\)\r\n\\color{fuchsia}{ABCDabcd1234}\r\n\r\n\r\n\r\n模算术\\mod的用法和比较\r\n\r\n\r\n\r\n展示\r\n代码\r\n\r\n\r\n\r\n\r\n\\(x^2\\equiv 1(\\mod 5)\\)\r\nx^2\\equiv 1(\\mod 5)\r\n\r\n\r\n\\(x^2\\equiv 1(\\bmod 5)\\)\r\nx^2\\equiv 1(\\bmod 5)\r\n\r\n\r\n\\(x^2\\equiv 1\\pmod{5}\\)\r\nx^2\\equiv 1\\pmod{5}\r\n\r\n\r\n\r\n分数\\frac的用法和比较\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n行内\r\n行间\r\n代码\r\n\r\n\r\n\r\n\r\n\\(\\frac{a-1}{b-1}\\)\r\n\\(\\displaystyle{\\frac{a-1}{b-1}}\\)\r\n\\frac{a-1}{b-1}\r\n\r\n\r\n\\(\\cfrac{2}{1+\\cfrac{2}{1+\\cfrac{2}{1}}}\\)\r\n\\(\\displaystyle{\\cfrac{2}{1+\\cfrac{2}{1+\\cfrac{2}{1}}}}\\)\r\n\\cfrac{2}{1+\\cfrac{2}{1+\\cfrac{2}{1}}}\r\n\r\n\r\n\\(\\dfrac{a-1}{b-1}\\)\r\n\\(\\displaystyle{\\dfrac{a-1}{b-1}}\\)\r\n\\dfrac{a-1}{b-1}\r\n\r\n\r\n\\(\\tfrac{a-1}{b-1}\\)\r\n\\(\\displaystyle{\\tfrac{a-1}{b-1}}\\)\r\n\\tfrac{a-1}{b-1}\r\n\r\n\r\n\\({a-1 \\over b-1}\\)\r\n\\(\\displaystyle{ {a-1 \\over b-1}\r\n}\\)\r\n{a-1 \\over b-1}\r\n\r\n\r\n\r\n组合数\\binom的用法和比较（附上\\brace和\\brack）\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n行内\r\n行间\r\n代码\r\n\r\n\r\n\r\n\r\n\\(\\binom{n+1}{m+1}\\)\r\n\\(\\displaystyle{\\binom{n+1}{m+1}}\\)\r\n\\binom{n+1}{m+1}\r\n\r\n\r\n\\({n+1\\choose m+1}\\)\r\n\\(\\displaystyle{ {n+1\\choose m+1}\r\n}\\)\r\n{n+1\\choose m+1}\r\n\r\n\r\n\\(\\dbinom{n+1}{m+1}\\)\r\n\\(\\displaystyle{\\dbinom{n+1}{m+1}}\\)\r\n\\dbinom{n+1}{m+1}\r\n\r\n\r\n\\(\\tbinom{n+1}{m+1}\\)\r\n\\(\\displaystyle{\\tbinom{n+1}{m+1}}\\)\r\n\\tbinom{n+1}{m+1}\r\n\r\n\r\n\\({n+1\\brack m+1}\\)\r\n\\(\\displaystyle{ {n+1\\brack m+1}\r\n}\\)\r\n{n+1\\brack m+1}\r\n\r\n\r\n\\({n+1\\brace m+1}\\)\r\n\\(\\displaystyle{ {n+1\\brace m+1}\r\n}\\)\r\n{n+1\\brace m+1}\r\n\r\n\r\n\r\n方框的用法和比较\r\n\r\n\r\n\r\n展示\r\n代码\r\n\r\n\r\n\r\n\r\n\\(\\boxed{x^3+y^3=z^3}\\)\r\n\\boxed{x^3+y^3=z^3}\r\n\r\n\r\n\\(\\boxed{abcd 1234}\\)\r\n\\boxed{abcd 1234}\r\n\r\n\r\n\\(\\fbox{abcd 1234}\\)\r\n\\fbox{abcd 1234}\r\n\r\n\r\n\r\n占位符\\phantom的用法和比较\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n展示\r\n代码\r\n\r\n\r\n\r\n\r\n\\(\\begin{array}{l}\\text{Side Angle\r\nSide}\\\\\\text{S}\\hphantom{\\text{ ide}}\\text{A}\\hphantom{\\text{ngle\r\n}}\\text{S}\\end{array}\\)\r\n\\begin{array}{l} \\text{Side Angle Side} \\\\ \\text{S} \\hphantom {\\text{ ide}} \\text{A} \\hphantom{\\text{ngle }} \\text{S}\\end{array}\r\n\r\n\r\n\\(\\begin{matrix}1&amp;-1\\\\\r\n\\phantom{}\\\\1&amp;\\phantom{-}1\\end{matrix}\\)\r\n\\begin{matrix}1&amp;-1\\\\ \\phantom{}\\\\1&amp;\\phantom{-}1\\end{matrix}\r\n\r\n\r\n\\(\\dbinom{\\dfrac ab}c\r\n\\dbinom{\\vphantom{\\dfrac ab}}c\\)\r\n\\dbinom{\\dfrac ab}c \\dbinom{\\vphantom{\\dfrac ab}}c\r\n\r\n\r\n\r\n公式大小\r\n\r\n\r\n\r\n展示\r\n代码\r\n\r\n\r\n\r\n\r\n\\({\\tiny AB}\\)\r\n{\\tiny AB}\r\n\r\n\r\n\\({\\Tiny AB}\\)\r\n{\\Tiny AB}\r\n\r\n\r\n\\(AB\\)\r\nAB\r\n\r\n\r\n\\(\\large AB\\)\r\n\\large AB\r\n\r\n\r\n\\(\\Large AB\\)\r\n\\Large AB\r\n\r\n\r\n\\(\\LARGE AB\\)\r\n\\LARGE AB\r\n\r\n\r\n\\({\\huge AB}\\)\r\n{\\huge AB}\r\n\r\n\r\n\\({\\Huge AB}\\)\r\n{\\Huge AB}\r\n\r\n\r\n\r\n其它基本符号\r\n\\#,\\$,\\%,\\&amp;,\\_,\\|\r\n\\(\\#,\\$,\\%,\\&amp;,\\_,\\|\\)\r\n公式上下层符号\r\n\r\n\r\n\r\n展示\r\n代码\r\n\r\n\r\n\r\n\r\n\\(\\acute{123}\\)\r\n\\acute{123}\r\n\r\n\r\n\\(\\bar{123}\\)\r\n\\bar{123}\r\n\r\n\r\n\\(\\breve{123}\\)\r\n\\breve{123}\r\n\r\n\r\n\\(\\check{123}\\)\r\n\\check{123}\r\n\r\n\r\n\\(\\dot{123}\\)\r\n\\dot{123}\r\n\r\n\r\n\\(\\ddot{123}\\)\r\n\\ddot{123}\r\n\r\n\r\n\\(\\dddot{123}\\)\r\n\\dddot{123}\r\n\r\n\r\n\\(\\ddddot{123}\\)\r\n\\ddddot{123}\r\n\r\n\r\n\\(\\grave{123}\\)\r\n\\grave{123}\r\n\r\n\r\n\\(\\hat{123}\\)\r\n\\hat{123}\r\n\r\n\r\n\\(\\mathring{123}\\)\r\n\\mathring{123}\r\n\r\n\r\n\\(\\tilde{123}\\)\r\n\\tilde{123}\r\n\r\n\r\n\\(\\vec{123}\\)\r\n\\vec{123}\r\n\r\n\r\n\\(\\overleftarrow{123}\\)\r\n\\overleftarrow{123}\r\n\r\n\r\n\\(\\overrightarrow{123}\\)\r\n\\overrightarrow{123}\r\n\r\n\r\n\\(\\overleftrightarrow{123}\\)\r\n\\overleftrightarrow{123}\r\n\r\n\r\n\\(\\overline{123}\\)\r\n\\overline{123}\r\n\r\n\r\n\\(\\widehat{123}\\)\r\n\\widehat{123}\r\n\r\n\r\n\\(\\widetilde{123}\\)\r\n\\widetilde{123}\r\n\r\n\r\n\\(\\underline{123}\\)\r\n\\underline{123}\r\n\r\n\r\n\\(\\underset{123}{abc}\\)\r\n\\underset{123}{abc}\r\n\r\n\r\n\\(\\overset{123}{abc}\\)\r\n\\overset{123}{abc}\r\n\r\n\r\n\\(\\underbrace{123}_{abc}\\)\r\n\\underbrace{123}_{abc}\r\n\r\n\r\n\\(\\xleftarrow[123]{abc}\\)\r\n\\xleftarrow[123]{abc}\r\n\r\n\r\n\\(\\xrightarrow[123]{abc}\\)\r\n\\xrightarrow[123]{abc}\r\n\r\n\r\n\r\n箭头\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n箭头\r\n代码\r\n\r\n\r\n\r\n\r\n\\(\\uparrow,\\downarrow,\\leftarrow,\\rightarrow\\)\r\n\\uparrow,\\downarrow,\\leftarrow,\\rightarrow\r\n\r\n\r\n\\(\\Uparrow,\\Downarrow,\\Leftarrow,\\Rightarrow\\)\r\n\\Uparrow,\\Downarrow,\\Leftarrow,\\Rightarrow\r\n\r\n\r\n\\(\\upuparrows,\\downdownarrows,\\leftleftarrows,\\rightrightarrows\\)\r\n\\upuparrows,\\downdownarrows,\\leftleftarrows,\\rightrightarrows\r\n\r\n\r\n\\(\\nwarrow,\\nearrow,\\swarrow,\\searrow\\)\r\n\\nwarrow,\\nearrow,\\swarrow,\\searrow\r\n\r\n\r\n\\(\\upharpoonleft,\\upharpoonright,\\downharpoonleft,\\downharpoonright\\)\r\n\\upharpoonleft,\\upharpoonright,\\downharpoonleft,\\downharpoonright\r\n\r\n\r\n\\(\\leftharpoondown,\\leftharpoonup,\\rightharpoondown,\\rightharpoonup\\)\r\n\\leftharpoondown,\\leftharpoonup,\\rightharpoondown,\\rightharpoonup\r\n\r\n\r\n\\(\\longleftarrow,\\longrightarrow,\\longleftrightarrow\\)\r\n\\longleftarrow,\\longrightarrow,\\longleftrightarrow\r\n\r\n\r\n\\(\\Longleftarrow,\\Longrightarrow,\\Longleftrightarrow\\)\r\n\\Longleftarrow,\\Longrightarrow,\\Longleftrightarrow\r\n\r\n\r\n\\(\\nleftarrow,\\nrightarrow,\\nleftrightarrow\\)\r\n\\nleftarrow,\\nrightarrow,\\nleftrightarrow\r\n\r\n\r\n\\(\\nLeftarrow,\\nRightarrow,\\nLeftrightarrow\\)\r\n\\nLeftarrow,\\nRightarrow,\\nLeftrightarrow\r\n\r\n\r\n\\(\\leftrightarrow,\\updownarrow\\)\r\n\\leftrightarrow,\\updownarrow\r\n\r\n\r\n\\(\\Leftrightarrow,\\Updownarrow\\)\r\n\\Leftrightarrow,\\Updownarrow\r\n\r\n\r\n\\(\\twoheadleftarrow,\\twoheadrightarrow\\)\r\n\\twoheadleftarrow,\\twoheadrightarrow\r\n\r\n\r\n\\(\\hookleftarrow,\\hookrightarrow\\)\r\n\\hookleftarrow,\\hookrightarrow\r\n\r\n\r\n\\(\\Lleftarrow,\\Rrightarrow\\)\r\n\\Lleftarrow,\\Rrightarrow\r\n\r\n\r\n\\(\\Lsh,\\Rsh\\)\r\n\\Lsh,\\Rsh\r\n\r\n\r\n\\(\\dashleftarrow,\\dashrightarrow\\)\r\n\\dashleftarrow,\\dashrightarrow\r\n\r\n\r\n\\(\\looparrowleft,\\looparrowright\\)\r\n\\looparrowleft,\\looparrowright\r\n\r\n\r\n\\(\\leftarrowtail,\\rightarrowtail\\)\r\n\\leftarrowtail,\\rightarrowtail\r\n\r\n\r\n\\(\\circlearrowleft,\\circlearrowright\\)\r\n\\circlearrowleft,\\circlearrowright\r\n\r\n\r\n\\(\\curvearrowleft,\\curvearrowright\\)\r\n\\curvearrowleft,\\curvearrowright\r\n\r\n\r\n\\(\\leftrightarrows,\\rightleftarrows\\)\r\n\\leftrightarrows,\\rightleftarrows\r\n\r\n\r\n\\(\\rightleftharpoons,\\leftrightharpoons\\)\r\n\\rightleftharpoons,\\leftrightharpoons\r\n\r\n\r\n\\(\\longmapsto\\)\r\n\\longmapsto\r\n\r\n\r\n\\(\\mapsto\\)\r\n\\mapsto\r\n\r\n\r\n\\(\\leftrightsquigarrow,\\rightsquigarrow\\)\r\n\\leftrightsquigarrow,\\rightsquigarrow\r\n\r\n\r\n\r\n点和省略号\r\n\r\n\r\n\r\n展示\r\n代码\r\n\r\n\r\n\r\n\r\n\\(a\\cdot b\\)\r\na\\cdot b\r\n\r\n\r\n\\(a\\cdotp b\\)\r\na\\cdotp b\r\n\r\n\r\n\\(a\\centerdot b\\)\r\na\\centerdot b\r\n\r\n\r\n\\(\\cdots\\)\r\n\\cdots\r\n\r\n\r\n\\(\\ddots\\)\r\n\\ddots\r\n\r\n\r\n\\(\\dots\\)\r\n\\dots\r\n\r\n\r\n\\(\\ldotp\\)\r\n\\ldotp\r\n\r\n\r\n\\(\\ldots\\)\r\n\\ldots\r\n\r\n\r\n\\(\\vdots\\)\r\n\\vdots\r\n\r\n\r\n\r\n函数\r\n\r\n\r\n\r\n展示\r\n代码\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\\(\\sin\\)\r\n\\sin\r\n\\(\\cos\\)\r\n\\cos\r\n\\(\\tan\\)\r\n\\tan\r\n\r\n\r\n\\(\\cot\\)\r\n\\cot\r\n\\(\\csc\\)\r\n\\csc\r\n\\(\\sec\\)\r\n\\sec\r\n\r\n\r\n\\(\\arccos\\)\r\n\\arccos\r\n\\(\\arcsin\\)\r\n\\arcsin\r\n\\(\\arctan\\)\r\n\\arctan\r\n\r\n\r\n\\(\\sinh\\)\r\n\\sinh\r\n\\(\\cosh\\)\r\n\\cosh\r\n\\(\\tanh\\)\r\n\\tanh\r\n\r\n\r\n\\(\\coth\\)\r\n\\coth\r\n\\(\\exp\\)\r\n\\exp\r\n\\(\\log\\)\r\n\\log\r\n\r\n\r\n\\(\\lg\\)\r\n\\lg\r\n\\(\\ln\\)\r\n\\ln\r\n\\(\\max\\)\r\n\\max\r\n\r\n\r\n\\(\\min\\)\r\n\\min\r\n\\(\\gcd\\)\r\n\\gcd\r\n\r\n\r\n\r\n\r\n\r\n微积分与极限\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n展示\r\n代码\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\\(\\nabla\\)\r\n\\nabla\r\n\\(\\partial\\)\r\n\\partial\r\n\\(\\prime,&#39;\\)\r\n\\prime,'\r\n\r\n\r\n\\(\\inf\\)\r\n\\inf\r\n\\(\\int,\\iint,\\iiint,\\iiiint\\)\r\n\\int,\\iint,\\iiint,\\iiiint\r\n\\(\\oint\\)\r\n\\oint\r\n\r\n\r\n\\(\\lim\\)\r\n\\lim\r\n\\(\\liminf\\)\r\n\\liminf\r\n\\(\\limsup\\)\r\n\\limsup\r\n\r\n\r\n\\(\\injlim\\)\r\n\\injlim\r\n\\(\\projlim\\)\r\n\\projlim\r\n\\(\\varinjlim\\)\r\n\\varinjlim\r\n\r\n\r\n\\(\\varlimsup\\)\r\n\\varlimsup\r\n\\(\\varliminf\\)\r\n\\varliminf\r\n\\(\\varprojlim\\)\r\n\\varprojlim\r\n\r\n\r\n\\(\\infty\\)\r\n\\infty\r\n\\(\\idotsint\\)\r\n\\idotsint\r\n\r\n\r\n\r\n\r\n\r\n类字母符号\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n展示\r\n代码\r\n\r\n\r\n\r\n\r\n\\(\\Bbbk,\\complement,\\backepsilon,\\Game,\\digamma,\\hbar,\\hslash\\)\r\n\\Bbbk,\\complement,\\backepsilon,\\Game,\\digamma,\\hbar,\\hslash\r\n\r\n\r\n\\(\\Im,\\imath,\\jmath,\\ell,\\mho,\\Re,\\S,\\top,\\wp\\)\r\n\\Im,\\imath,\\jmath,\\ell,\\mho,\\Re,\\S,\\top,\\wp\r\n\r\n\r\n\r\n集合\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n展示\r\n代码\r\n\r\n\r\n\r\n\r\n\\(\\in,\\notin,\\ni,\\owns\\)\r\n\\in,\\notin,\\ni,\\owns\r\n\r\n\r\n\\(\\subset,\\Subset,\\subseteq,\\subsetneq,\\nsubseteq,\\nsubseteqq\\)\r\n\\subset,\\Subset,\\subseteq,\\subsetneq,\\nsubseteq,\\nsubseteqq\r\n\r\n\r\n\\(\\supset,\\Supset,\\supseteq,\\supsetneq,\\nsupseteq,\\nsupseteqq\\)\r\n\\supset,\\Supset,\\supseteq,\\supsetneq,\\nsupseteq,\\nsupseteqq\r\n\r\n\r\n\\(\\subseteqq,\\subsetneqq,\\varsubsetneq,\\varsubsetneqq\\)\r\n\\subseteqq,\\subsetneqq,\\varsubsetneq,\\varsubsetneqq\r\n\r\n\r\n\\(\\supseteqq,\\supsetneqq,\\varsupsetneq,\\varsupsetneqq\\)\r\n\\supseteqq,\\supsetneqq,\\varsupsetneq,\\varsupsetneqq\r\n\r\n\r\n\\(\\emptyset,\\varnothing\\)\r\n\\emptyset,\\varnothing\r\n\r\n\r\n\r\n关系运算符\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n展示\r\n代码\r\n\r\n\r\n\r\n\r\n\\(&gt;,\\ge,\\geqq,\\geqslant,\\gg,\\ggg,\\gt,\\gtrdot,\\eqslantgtr\\)\r\n&gt;,\\ge,\\geqq,\\geqslant,\\gg,\\ggg,\\gt,\\gtrdot,\\eqslantgtr\r\n\r\n\r\n\\(&lt;,\\le,\\leqq,\\leqslant,\\ll,\\lll,\\lt,\\lessdot,\\eqslantless\\)\r\n&lt;,\\le,\\leqq,\\leqslant,\\ll,\\lll,\\lt,\\lessdot,\\eqslantless\r\n\r\n\r\n\\(\\gtrapprox,\\gnapprox,\\gneq,\\gneqq,\\gvertneqq,\\gtrsim,\\gnsim\\)\r\n\\gtrapprox,\\gnapprox,\\gneq,\\gneqq,\\gvertneqq,\\gtrsim,\\gnsim\r\n\r\n\r\n\\(\\lessapprox,\\lnapprox,\\lneq,\\lneqq,\\lvertneqq,\\lesssim,\\lnsim\\)\r\n\\lessapprox,\\lnapprox,\\lneq,\\lneqq,\\lvertneqq,\\lesssim,\\lnsim\r\n\r\n\r\n\\(\\gtreqless,\\gtreqqless,\\gtrless,\\lesseqgtr,\\lesseqqgtr,\\lessgtr\\)\r\n\\gtreqless,\\gtreqqless,\\gtrless,\\lesseqgtr,\\lesseqqgtr,\\lessgtr\r\n\r\n\r\n\\(\\ngeq,\\ngeqq,\\ngeqslant,\\ngtr,\\nleq,\\nleqq,\\nleqslant,\\nless\\)\r\n\\ngeq,\\ngeqq,\\ngeqslant,\\ngtr,\\nleq,\\nleqq,\\nleqslant,\\nless\r\n\r\n\r\n\\(\\sqsubset,\\sqsupset,\\sqsubseteq,\\sqsupseteq\\)\r\n\\sqsubset,\\sqsupset,\\sqsubseteq,\\sqsupseteq\r\n\r\n\r\n\\(\\prec,\\preccurlyeq,\\curlyeqprec,\\preceq,\\precsim,\\precapprox\\)\r\n\\prec,\\preccurlyeq,\\curlyeqprec,\\preceq,\\precsim,\\precapprox\r\n\r\n\r\n\\(\\precnapprox,\\precneqq,\\precnsim,\\nprec,\\npreceq\\)\r\n\\precnapprox,\\precneqq,\\precnsim,\\nprec,\\npreceq\r\n\r\n\r\n\\(\\succ,\\curlyeqsucc,\\succcurlyeq,\\succeq,\\succsim,\\succapprox\\)\r\n\\succ,\\curlyeqsucc,\\succcurlyeq,\\succeq,\\succsim,\\succapprox\r\n\r\n\r\n\\(\\succnapprox,\\succneqq,\\succnsim,\\nsucc,\\nsucceq\\)\r\n\\succnapprox,\\succneqq,\\succnsim,\\nsucc,\\nsucceq\r\n\r\n\r\n\\(\\sim,\\nsim,\\thicksim,\\backsim,\\simeq,\\backsimeq,\\eqsim\\)\r\n\\sim,\\nsim,\\thicksim,\\backsim,\\simeq,\\backsimeq,\\eqsim\r\n\r\n\r\n\\(\\approx,\\thickapprox,\\approxeq\\)\r\n\\approx,\\thickapprox,\\approxeq\r\n\r\n\r\n\\(\\vdash,\\dashv,\\Vdash,\\vDash,\\Vvdash,\\models\\)\r\n\\vdash,\\dashv,\\Vdash,\\vDash,\\Vvdash,\\models\r\n\r\n\r\n\\(\\nvdash,\\nVdash,\\nVDash,\\nvDash\\)\r\n\\nvdash,\\nVdash,\\nVDash,\\nvDash\r\n\r\n\r\n\\(\\ntriangleleft,\\ntriangleright\\)\r\n\\ntriangleleft,\\ntriangleright\r\n\r\n\r\n\\(\\trianglelefteq,\\trianglerighteq,\\ntrianglelefteq,\\ntrianglerighteq\\)\r\n\\trianglelefteq,\\trianglerighteq,\\ntrianglelefteq,\\ntrianglerighteq\r\n\r\n\r\n\\(=,\\eqcirc,\\equiv,\\ne,\\cong,\\ncong\\)\r\n=,\\eqcirc,\\equiv,\\ne,\\cong,\\ncong\r\n\r\n\r\n\\(\\Doteq,\\doteq,\\triangleq\\)\r\n\\Doteq,\\doteq,\\triangleq\r\n\r\n\r\n\\(\\Bumpeq,\\bumpeq,\\circeq\\)\r\n\\Bumpeq,\\bumpeq,\\circeq\r\n\r\n\r\n\\(\\propto,\\varpropto\\)\r\n\\propto,\\varpropto\r\n\r\n\r\n\r\n算术与逻辑运算符\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n展示\r\n代码\r\n\r\n\r\n\r\n\r\n\\(\\circ,\\bullet,\\bigcirc\\)\r\n\\circ,\\bullet,\\bigcirc\r\n\r\n\r\n\\(\\cap,\\Cap,\\bigcap,\\doublecap,\\sqcap\\)\r\n\\cap,\\Cap,\\bigcap,\\doublecap,\\sqcap\r\n\r\n\r\n\\(\\cup,\\Cup,\\bigcup,\\doublecup,\\sqcup,\\bigsqcup\\)\r\n\\cup,\\Cup,\\bigcup,\\doublecup,\\sqcup,\\bigsqcup\r\n\r\n\r\n\\(+,-,\\pm,\\mp,\\dotplus,\\uplus,\\biguplus,\\sum\\)\r\n+,-,\\pm,\\mp,\\dotplus,\\uplus,\\biguplus,\\sum\r\n\r\n\r\n\\(\\ast,\\times,\\div,\\divideontimes,\\prod\\)\r\n\\ast,\\times,\\div,\\divideontimes,\\prod\r\n\r\n\r\n\\(\\boxplus,\\boxminus,\\boxtimes\\)\r\n\\boxplus,\\boxminus,\\boxtimes\r\n\r\n\r\n\\(\\odot,\\bigodot,\\ominus,\\oplus,\\bigoplus,\\oslash,\\otimes\\)\r\n\\odot,\\bigodot,\\ominus,\\oplus,\\bigoplus,\\oslash,\\otimes\r\n\r\n\r\n\\(\\sqrt{16}=\\sqrt[3]{64}\\)\r\n\\sqrt{16}=\\sqrt[3]{64}\r\n\r\n\r\n\\(\\lor,\\vee,\\bigvee,\\veebar,\\curlyvee\\)\r\n\\lor,\\vee,\\bigvee,\\veebar,\\curlyvee\r\n\r\n\r\n\\(\\land,\\wedge,\\barwedge,\\bigwedge,\\doublebarwedge,\\curlywedge\\)\r\n\\land,\\wedge,\\barwedge,\\bigwedge,\\doublebarwedge,\\curlywedge\r\n\r\n\r\n\\(\\lnot,\\neg\\)\r\n\\lnot,\\neg\r\n\r\n\r\n\\(\\because,\\therefore\\)\r\n\\because,\\therefore\r\n\r\n\r\n\\(\\forall,\\exists,\\nexists\\)\r\n\\forall,\\exists,\\nexists\r\n\r\n\r\n\r\n几何符号\r\n部分几何符号可能归入了特殊符号中。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n展示\r\n代码\r\n\r\n\r\n\r\n\r\n\\(\\angle,\\measuredangle,\\sphericalangle\\)\r\n\\angle,\\measuredangle,\\sphericalangle\r\n\r\n\r\n\\(\\perp,\\bot\\)\r\n\\perp,\\bot\r\n\r\n\r\n\\(\\mid,\\nmid,\\parallel,\\nparallel\\)\r\n\\mid,\\nmid,\\parallel,\\nparallel\r\n\r\n\r\n\\(\\shortmid,\\shortparallel,\\nshortmid,\\nshortparallel\\)\r\n\\shortmid,\\shortparallel,\\nshortmid,\\nshortparallel\r\n\r\n\r\n\r\n特殊符号\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n展示\r\n代码\r\n\r\n\r\n\r\n\r\n\\(\\bigtriangleup,\\triangle,\\vartriangle\\)\r\n\\bigtriangleup,\\triangle,\\vartriangle\r\n\r\n\r\n\\(\\bigtriangledown,\\triangledown\\)\r\n\\bigtriangledown,\\triangledown\r\n\r\n\r\n\\(\\triangleleft,\\vartriangleleft,\\lhd\\)\r\n\\triangleleft,\\vartriangleleft,\\lhd\r\n\r\n\r\n\\(\\triangleright,\\vartriangleright,\\rhd\\)\r\n\\triangleright,\\vartriangleright,\\rhd\r\n\r\n\r\n\\(\\bigstar,\\blacklozenge,\\blacksquare\\)\r\n\\bigstar,\\blacklozenge,\\blacksquare\r\n\r\n\r\n\\(\\blacktriangle,\\blacktriangledown,\\blacktriangleleft,\\blacktriangleright\\)\r\n\\blacktriangle,\\blacktriangledown,\\blacktriangleleft,\\blacktriangleright\r\n\r\n\r\n\\(\\Box,\\square,\\boxdot\\)\r\n\\Box,\\square,\\boxdot\r\n\r\n\r\n\\(\\circledast,\\circledcirc,\\circleddash,\\circledR,\\circledS\\)\r\n\\circledast,\\circledcirc,\\circleddash,\\circledR,\\circledS\r\n\r\n\r\n\\(\\dagger,\\ddagger\\)\r\n\\dagger,\\ddagger\r\n\r\n\r\n\\(\\diagdown,\\diagup\\)\r\n\\diagdown,\\diagup\r\n\r\n\r\n\\(\\diamond,\\Diamond,\\lozenge\\)\r\n\\diamond,\\Diamond,\\lozenge\r\n\r\n\r\n\\(\\heartsuit,\\diamondsuit,\\clubsuit,\\spadesuit\\)\r\n\\heartsuit,\\diamondsuit,\\clubsuit,\\spadesuit\r\n\r\n\r\n\\(\\flat,\\natural,\\sharp\\)\r\n\\flat,\\natural,\\sharp\r\n\r\n\r\n\\(\\checkmark,\\surd\\)\r\n\\checkmark,\\surd\r\n\r\n\r\n\\(\\smile,\\frown,\\asymp\\)\r\n\\smile,\\frown,\\asymp\r\n\r\n\r\n\\(\\ulcorner\\urcorner\\)\r\n\\ulcorner\\urcorner\r\n\r\n\r\n\\(\\llcorner\\lrcorner\\)\r\n\\llcorner\\lrcorner\r\n\r\n\r\n\\(\\LaTeX,\\TeX\\)\r\n\\LaTeX,\\TeX\r\n\r\n\r\n\\(\\Finv\\)\r\n\\Finv\r\n\r\n\r\n\\(\\maltese\\)\r\n\\maltese\r\n\r\n\r\n\\(\\backprime\\)\r\n\\backprime\r\n\r\n\r\n\\(\\between\\)\r\n\\between\r\n\r\n\r\n\\(\\multimap\\)\r\n\\multimap\r\n\r\n\r\n\\(\\pitchfork\\)\r\n\\pitchfork\r\n\r\n\r\n\\(\\star\\)\r\n\\star\r\n\r\n\r\n\\(\\yen\\)\r\n\\yen\r\n\r\n\r\n\\(\\intercal\\)\r\n\\intercal\r\n\r\n\r\n\\(\\wr\\)\r\n\\wr\r\n\r\n\r\n\\(\\backslash\\)\r\n\\backslash\r\n\r\n\r\n\r\n其它未分类符号\r\n\r\n\r\n\r\n展示\r\n代码\r\n\r\n\r\n\r\n\r\n\\(\\leftthreetimes,\\rightthreetimes\\)\r\n\\leftthreetimes,\\rightthreetimes\r\n\r\n\r\n\\(\\coprod,\\amalg\\)\r\n\\coprod,\\amalg\r\n\r\n\r\n\\(\\sup\\)\r\n\\sup\r\n\r\n\r\n\\(\\arg\\)\r\n\\arg\r\n\r\n\r\n\\(\\deg\\)\r\n\\deg\r\n\r\n\r\n\\(\\dim\\)\r\n\\dim\r\n\r\n\r\n\\(\\hom\\)\r\n\\hom\r\n\r\n\r\n\\(\\ker\\)\r\n\\ker\r\n\r\n\r\n\\(\\Pr\\)\r\n\\Pr\r\n\r\n\r\n\\(\\det\\)\r\n\\det\r\n\r\n\r\n\\(\\ltimes\\rtimes,\\bowtie,\\Join\\)\r\n\\ltimes\\rtimes,\\bowtie,\\Join\r\n\r\n\r\n\r\n用\\DeclareMathOperator定义运算符\r\n$\\DeclareMathOperator&#123;\\lcm&#125;&#123;lcm&#125; \\lcm(4,6)=2$$\\lcm(12,18)=24$\r\n\\(\\DeclareMathOperator{\\lcm}{lcm}\r\n\\lcm(4,6)=2\\) \\(\\lcm(12,18)=24\\)\r\n\\buildrel{} \\over{}\r\n用于自创运算符，这个运算符拥有两行。\r\n\\buildrel&#123;\\rm def&#125; \\over&#123;:=&#125;\r\n\\[\\buildrel{\\rm def}\r\n\\over{:=}\\]\r\n\\substack\r\n用于编写大型运算符的条件时分行。\r\n\\sum_&#123;\\substack&#123;1\\lt i\\lt 3 \\\\1\\le j\\lt 5&#125;&#125;a_&#123;ij&#125;\r\n\\[\\sum_{\\substack{1\\lt i\\lt 3 \\\\1\\le j\\lt\r\n5}}a_{ij}\\]\r\n\\begin ... \\end\r\naligned\r\n\\begin&#123;aligned&#125;3x - 4y &amp;= 5 \\\\x + 7 &amp;= -2y\\end&#123;aligned&#125;\\tag&#123;3.1c&#125;\r\n\\[\\begin{aligned}\r\n3x - 4y &amp;= 5 \\\\\r\nx + 7 &amp;= -2y\r\n\\end{aligned}\r\n\\tag{3.1c}\\]\r\nalign\r\n\\begin&#123;align&#125;(a+b)^2 &amp;= (a+b)(a+b)          \\tag&#123;1&#125;  \\\\        &amp;= a^2 + ab + ba + b^2 \\tag&#123;2&#125;  \\\\        &amp;= a^2 + 2ab + b^2     \\tag&#123;3&#125;\\end&#123;align&#125;\r\n\\[\\begin{align}\r\n(a+b)^2 &amp;= (a+b)(a+b)          \\tag{1}  \\\\\r\n        &amp;= a^2 + ab + ba + b^2 \\tag{2}  \\\\\r\n        &amp;= a^2 + 2ab + b^2     \\tag{3}\r\n\\end{align}\\]\r\narray\r\nl,c,r分别表示当前一列是居左，居中，还是居右。如果有|，那么就代表隔开。\r\n\\begin&#123;array&#125;&#123;lc|r&#125;aaa &amp; bbb &amp; ccc\\\\d &amp; e &amp; f\\end&#123;array&#125;\r\n\\[\\begin{array}{l|c|r}\r\naaa &amp; bbb &amp; ccc\\\\\r\nd &amp; e &amp; f\r\n\\end{array}\\]\r\ncases\r\n|x| =\\begin&#123;cases&#125;x  &amp; \\text&#123; if &#125; x\\ge 0 \\\\-x &amp; \\text&#123; if &#125; x \\lt 0\\end&#123;cases&#125;$$\r\n\\[|x| =\r\n\\begin{cases}\r\nx  &amp; \\text{ if } x\\ge 0 \\\\\r\n-x &amp; \\text{ if } x \\lt 0\r\n\\end{cases}\\]\r\nBmatrix\r\n\\begin&#123;Bmatrix&#125; a &amp; b\\\\ c &amp; d\\end&#123;Bmatrix&#125;\r\n\\[\\begin{Bmatrix} a &amp; b\\\\ c &amp;\r\nd\\end{Bmatrix}\\]\r\nbmatrix\r\n\\begin&#123;bmatrix&#125; a &amp; b\\\\ c &amp; d\\end&#123;bmatrix&#125;\r\n\\[\\begin{bmatrix} a &amp; b\\\\ c &amp;\r\nd\\end{bmatrix}\\]\r\nmatrix\r\n\\begin&#123;matrix&#125; a &amp; b\\\\ c &amp; d\\end&#123;matrix&#125;\r\n\\[\\begin{matrix} a &amp; b\\\\ c &amp;\r\nd\\end{matrix}\\]\r\npmatrix\r\n\\begin&#123;pmatrix&#125; a &amp; b\\\\ c &amp; d\\end&#123;pmatrix&#125;\r\n\\[\\begin{pmatrix} a &amp; b\\\\ c &amp;\r\nd\\end{pmatrix}\\]\r\nvmatrix\r\n\\begin&#123;vmatrix&#125; a &amp; b\\\\ c &amp; d\\end&#123;vmatrix&#125;\r\n\\[\\begin{vmatrix} a &amp; b\\\\ c &amp;\r\nd\\end{vmatrix}\\]\r\nVmatrix\r\n\\begin&#123;Vmatrix&#125; a &amp; b\\\\ c &amp; d\\end&#123;Vmatrix&#125;\r\n\\[\\begin{Vmatrix} a &amp; b\\\\ c &amp;\r\nd\\end{Vmatrix}\\]\r\neqnarray\r\n\\begin&#123;eqnarray&#125;(x-1)^2 &amp;=&amp; (x-1)(x-1)      &amp;=&amp;  x^2-2x + 1 \\\\(x-1)^3 &amp;=&amp; (x-1)(x-1)(x-1) &amp;=&amp;  (x-1)^2(x-1) \\end&#123;eqnarray&#125;\r\n\\[\\begin{eqnarray}\r\n(x-1)^2 &amp;=&amp; (x-1)(x-1)      &amp;=&amp;  x^2-2x + 1 \\\\\r\n(x-1)^3 &amp;=&amp; (x-1)(x-1)(x-1) &amp;=&amp;  (x-1)^2(x-1)\r\n\\end{eqnarray}\\]\r\n其它\r\n\\tag\r\n注意\\tag只有某些情况下才可以使用，如\\aligned不可以，\\align可以。\r\n\\begin&#123;align&#125;(a+b)^2 &amp;= (a+b)(a+b)          \\tag&#123;1&#125;  \\\\        &amp;= a^2 + ab + ba + b^2 \\tag&#123;2&#125;  \\\\        &amp;= a^2 + 2ab + b^2     \\tag&#123;3&#125;\\end&#123;align&#125;\r\n\\[\\begin{align}\r\n(a+b)^2 &amp;= (a+b)(a+b)          \\tag{1}  \\\\\r\n        &amp;= a^2 + ab + ba + b^2 \\tag{2}  \\\\\r\n        &amp;= a^2 + 2ab + b^2     \\tag{3}\r\n\\end{align}\\]\r\n\\hline, \\hdashline\r\n用于在矩阵中画横线，\\hline前者为实线，\\hdashline为虚线。\r\n\\hlinex_&#123;11&#125; &amp; x_&#123;12&#125; \\\\x_&#123;21&#125; &amp; x_&#123;22&#125; \\\\\\hdashlinex_&#123;31&#125; &amp; x_&#123;32&#125; \\end&#123;matrix&#125;\r\n\\[\\begin{matrix}\r\n\\hline\r\nx_{11} &amp; x_{12} \\\\\r\nx_{21} &amp; x_{22} \\\\\r\n\\hdashline\r\nx_{31} &amp; x_{32}\r\n\\end{matrix}\\]\r\n\\left,\r\n\\right和\\big\r\n根据括号内的公式高度，智能调整两侧括号的高度，一个\\left必须和一个\\right匹配。如果只想要其中一个，那么用\\right.来代替。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n展示\r\n代码\r\n\r\n\r\n\r\n\r\n\\(\\left(1+2\\right)=\\left(\\dfrac{1}{2}\\right)\\)\r\n\\left(1+2\\right)=\\left(\\dfrac{1}{2}\\right)\r\n\r\n\r\n\\(\\left\\lgroup\r\n1+2\\right\\rgroup=\\left\\lgroup\\dfrac{1}{2}\\right\\rgroup\\)\r\n\\left\\lgroup 1+2\\right\\rgroup=\\left\\lgroup\\dfrac{1}{2}\\right\\rgroup\r\n\r\n\r\n\\(\\left[1+2\\right]=\\left[\\dfrac{1}{2}\\right]\\)\r\n\\left[1+2\\right]=\\left[\\dfrac{1}{2}\\right]\r\n\r\n\r\n\\(\\left\\{1+2\\right\\}=\\left\\{\\dfrac{1}{2}\\right\\}\\)\r\n\\left\\{1+2\\right\\}=\\left\\{\\dfrac{1}{2}\\right\\}\r\n\r\n\r\n\\(\\left\\uparrow\r\n1+2\\right\\downarrow=\\left\\downarrow\\dfrac{1}{2}\\right\\uparrow\\)\r\n\\left\\uparrow 1+2\\right\\downarrow=\\left\\downarrow\\dfrac{1}{2}\\right\\uparrow\r\n\r\n\r\n\\(\\left\\Uparrow\r\n1+2\\right\\Downarrow=\\left\\Downarrow\\dfrac{1}{2}\\right\\Uparrow\\)\r\n\\left\\Uparrow 1+2\\right\\Downarrow=\\left\\Downarrow\\dfrac{1}{2}\\right\\Uparrow\r\n\r\n\r\n\\(\\left\\updownarrow\r\n1+2\\right\\Updownarrow=\\left\\Updownarrow\\dfrac{1}{2}\\right\\updownarrow\\)\r\n\\left\\updownarrow 1+2\\right\\Updownarrow=\\left\\Updownarrow\\dfrac{1}{2}\\right\\updownarrow\r\n\r\n\r\n\\(\\left\\vert\r\n1+2\\right\\vert=\\left\\vert\\dfrac{1}{2}\\right\\vert\\)\r\n\\left\\vert 1+2\\right\\vert=\\left\\vert\\dfrac{1}{2}\\right\\vert\r\n\r\n\r\n\\(\\left\\Vert\r\n1+2\\right\\Vert=\\left\\Vert\\dfrac{1}{2}\\right\\Vert\\)\r\n\\left\\Vert 1+2\\right\\Vert=\\left\\Vert\\dfrac{1}{2}\\right\\Vert\r\n\r\n\r\n\\(\\left\\bracevert\r\n1+2\\right\\bracevert=\\left\\bracevert\\dfrac{1}{2}\\right\\bracevert\\)\r\n\\left\\bracevert 1+2\\right\\bracevert=\\left\\bracevert\\dfrac{1}{2}\\right\\bracevert\r\n\r\n\r\n\\(\\left\\lceil\r\n1+2\\right\\rceil=\\left\\lceil\\dfrac{1}{2}\\right\\rceil\\)\r\n\\left\\lceil 1+2\\right\\rceil=\\left\\lceil\\dfrac{1}{2}\\right\\rceil\r\n\r\n\r\n\\(\\left\\lfloor\r\n1+2\\right\\rfloor=\\left\\lfloor\\dfrac{1}{2}\\right\\rfloor\\)\r\n\\left\\lfloor 1+2\\right\\rfloor=\\left\\lfloor\\dfrac{1}{2}\\right\\rfloor\r\n\r\n\r\n\\(\\left/\r\n1+2\\right\\backslash=\\left/\\dfrac{1}{2}\\right\\backslash\\)\r\n\\left/ 1+2\\right\\backslash=\\left/\\dfrac{1}{2}\\right\\backslash\r\n\r\n\r\n\\(\\left\\lmoustache\r\n1+2\\right\\rmoustache=\\left\\lmoustache\\dfrac{1}{2}\\right\\rmoustache\\)\r\n\\left\\lmoustache 1+2\\right\\rmoustache=\\left\\lmoustache\\dfrac{1}{2}\\right\\rmoustache\r\n\r\n\r\n\r\n也可以自行直接指定大小：\r\n\\Bigg[\\bigg[\\Big[\\big[ [\r\n\\[\\Bigg[\\bigg[\\Big[\\big[ [\\]\r\n\\not\r\n在任何一个关系运算符前面添加一个\\not，即可得到划斜线的运算符，如：\r\n\r\n\r\n\r\n展示\r\n代码\r\n\r\n\r\n\r\n\r\n\\(\\not\\equiv\\)\r\n\\not\\equiv\r\n\r\n\r\n\\(\\not=\\)\r\n\\not=\r\n\r\n\r\n\\(\\not\\in\\)\r\n\\not\\in\r\n\r\n\r\n\r\n","categories":["MathJax"]},{"title":"Ubuntu22安装所有必要软件脚本","url":"/linux/ubuntu22-apt-init/","content":"\r\n以下脚本用于刚刚完成安装的Ubuntu22.04 LTS系统。\r\ninit.sh\r\n装完系统后，本脚本用于刷新apt。\r\necho &#x27;配置成清华源&#x27;sudo sed -i &quot;s@http://.*archive.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g&quot; /etc/apt/sources.listsudo sed -i &quot;s@http://.*security.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g&quot; /etc/apt/sources.listecho &#x27;更新所有软件包&#x27;sudo apt updatesudo apt upgrade\r\nexp.sh\r\n正式安装必要的软件（有一些软件可能不是最新版）。\r\nsudo apt updateRED=&#x27;\\E[1;31m&#x27;      # 红RES=&#x27;\\E[0m&#x27;         # 清除颜色echo &#x27;安装微信（参考https://blog.csdn.net/yunlin2000/article/details/125424695）&#x27;wget http://archive.ubuntukylin.com/software/pool/partner/ukylin-wine_70.6.3.25_amd64.debwget http://archive.ubuntukylin.com/software/pool/partner/ukylin-wechat_3.0.0_amd64.debsudo dpkg -i ukylin-wine_70.6.3.25_amd64.debsudo dpkg -i ukylin-wechat_3.0.0_amd64.debecho -e &quot;$&#123;RED&#125;该版微信截图可能无法使用，需要结合PrintScreen快捷键使用。$&#123;RES&#125;&quot;echo &#x27;安装并默认配置gcc, g++10&#x27;sudo apt-get install gcc-10sudo apt-get install g++-10cd /usr/bin&amp;&amp;sudo rm -rf gcc&amp;&amp;sudo ln -s gcc-10 gcc&amp;&amp;sudo rm -rf g++&amp;&amp;sudo ln -s g++-10 g++echo &#x27;安装Clion&#x27;sudo snap install clion --classicecho &#x27;安装Python3.11&#x27;sudo apt install python3.11echo &#x27;安装Pycharm社区版&#x27;sudo snap install pycharm-community --classicecho &#x27;安装VScode&#x27;sudo wget https://az764295.vo.msecnd.net/stable/30d9c6cd9483b2cc586687151bcbcd635f373630/code_1.68.1-1655263094_amd64.debsudo dpkg -i code_1.68.1-1655263094_amd64.debecho &#x27;安装Google Chrome&#x27;sudo wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.debsudo dpkg -i google-chrome-stable_current_amd64.deb echo &#x27;安装git, vim等&#x27;sudo apt install git vimecho &#x27;安装向日葵&#x27;sudo wget https://down.oray.com/sunlogin/linux/SunloginClient_11.0.1.44968_amd64.debsudo dpkg -i SunloginClient_11.0.1.44968_amd64.deb echo &#x27;Hexo博客环境相关&#x27;sudo apt install nodejs npm pandocsudo npm install -g hexo-cliecho &#x27;SSH设置相关&#x27;sudo apt install net-tools ssh openssh-serverecho &#x27;安装并自动配置搜狗输入法（参考https://blog.csdn.net/weixin_64684404/article/details/125461860）&#x27;sudo apt install fcitxsudo cp /usr/share/applications/fcitx.desktop /etc/xdg/autostart/sudo apt purge ibussudo wget https://ime.sogouimecdn.com/202210311553/55aeadc888f29444268beefacb62c811/dl/gzindex/1656597217/sogoupinyin_4.0.1.2800_x86_64.debsudo dpkg -i sogoupinyin_4.0.1.2800_x86_64.deb sudo apt install libqt5qml5 libqt5quick5 libqt5quickwidgets5 qml-module-qtquick2 libgsettings-qt1\r\n"},{"title":"Project Euler 1","url":"/project-euler/1/","content":"\r\nProject Euler 1\r\n题目\r\nMultiples of \\(3\\) or \\(5\\)\r\nIf we list all the natural numbers below \\(10\\) that are multiples of \\(3\\) or \\(5\\), we get \\(3,\r\n5, 6\\) and \\(9\\). The sum of\r\nthese multiples is \\(23\\).\r\nFind the sum of all the multiples of \\(3\\) or \\(5\\) below \\(1000\\).\r\n解决方案\r\n用容斥原理，先把\\(3\\)的倍数进行求和，再把\\(5\\)的倍数进行求和。加起来后，将\\(15\\)的倍数的总和减去即可。\r\n代码\r\nN = 1000N -= 1ans = 0c3 = N // 3c5 = N // 5c15 = N // 15ans = 3 * (c3 + 1) * c3 // 2 + 5 * (c5 + 1) * c5 // 2 - 15 * (c15 + 1) * c15 // 2print(ans)\r\n","categories":["Project Euler"],"tags":["容斥原理"]},{"title":"Project Euler 10","url":"/project-euler/10/","content":"\r\nProject Euler 10\r\n题目\r\nSummation of primes\r\nThe sum of the primes below \\(10\\)\r\nis \\(2 + 3 + 5 + 7 = 17\\).\r\nFind the sum of all the primes below two million.\r\n解决方案\r\n解法与第7题相同。不过此处使用的是sympy中sieve对象的方法primerange(l,r=None)，只有一个参数\\(l\\)时，用于生成小于\\(l\\)的所有素数；有两个参数\\(l,r\\)时，生成的是\\([l,r)\\)内的素数。\r\n该方法将会被封装在自定义的tools工具类中，方法名为get_prime。\r\n代码\r\nfrom sympy.ntheory.generate import sieveN = 2 * 10 ** 6ans = sum(list(sieve.primerange(N)))print(ans)\r\n埃氏筛：\r\npr = []N = 2000000f = [0 for _ in range(N)]f[0] = f[1] = 1for i in range(2, N):    if f[i] == 0:        pr.append(i)        for j in range(i * i, N, i):            f[j] = 1ans = sum(pr)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 101","url":"/project-euler/101/","content":"\r\nProject Euler 101\r\n题目\r\nOptimum polynomial\r\nIf we are presented with the first \\(k\\) terms of a sequence it is impossible to\r\nsay with certainty the value of the next term, as there are infinitely\r\nmany polynomial functions that can model the sequence.\r\nAs an example, let us consider the sequence of cube numbers. This is\r\ndefined by the generating function, \\(u_n =\r\nn^3: 1, 8, 27, 64, 125, 216, \\dots\\)\r\nSuppose we were only given the first two terms of this sequence.\r\nWorking on the principle that “simple is best” we should assume a linear\r\nrelationship and predict the next term to be \\(15\\) (common difference \\(7\\)). Even if we were presented with the\r\nfirst three terms, by the same principle of simplicity, a quadratic\r\nrelationship should be assumed.\r\nWe shall define \\(OP(k, n)\\) to be\r\nthe \\(n^{\\text{th}}\\) term of the\r\noptimum polynomial generating function for the first \\(k\\) terms of a sequence. It should be clear\r\nthat \\(OP(k, n)\\) will accurately\r\ngenerate the terms of the sequence for \\(n\r\n\\leq k\\), and potentially the first incorrect term (FIT)\r\nwill be \\(OP(k, k+1)\\); in which case\r\nwe shall call it a bad OP (BOP).\r\nAs a basis, if we were only given the first term of sequence, it\r\nwould be most sensible to assume constancy; that is, for \\(n \\ge 2\\), \\(OP(1, n) = u_1\\). Hence we obtain the\r\nfollowing OPs for the cubic sequence:\r\n\r\n\r\n\r\n\\(OP(1, n) = 1\\)\r\n\\(1, \\mathbf{1}, 1, 1, \\dots\\)\r\n\r\n\r\n\\(OP(2, n) = 7n−6\\)\r\n\\(1, 8, \\mathbf{15}, \\dots\\)\r\n\r\n\r\n\\(OP(3, n) = 6n^2−11n+6\\)\r\n\\(1, 8, 27,\\mathbf{58},\r\n\\dots\\)\r\n\r\n\r\n\\(OP(4, n) = n^3\\)\r\n\\(1, 8, 27, 64, 125, \\dots\\)\r\n\r\n\r\n\r\nClearly no BOPs exist for \\(k \\ge\r\n4\\).\r\nBy considering the sum of FITs generated by the BOPs (indicated in\r\nred above), we obtain \\(1 +\r\n15 + 58 = 74\\). Consider the following tenth degree polynomial\r\ngenerating function:\r\n\\[u_n = 1 − n + n^2 − n^3 + n^4 − n^5 +\r\nn^6 − n^7 + n^8 − n^9 + n^{10}\\]\r\nFind the sum of FITs for the BOPs.\r\n解决方案\r\n对于一元函数上任意\\(n\\)个不同的点，可以用唯一一个\\(n-1\\)次多项式确定。求出这个\\(n-1\\)次的多项式\\(p(x)\\)最简单的办法是使用待定系数法，设\\(p(x)=c_0+c_1x+c_2x^2+\\dots+c_{n-1}x^{n-1}\\)。\r\n设已知的\\(n\\)个点的坐标为\\((x_1,y_1),(x_2,y_2),\\dots,(x_n,y_n)\\)。由于已经知道的是数列的前\\(n\\)项，因此\\(x_k=k\\)。每一个\\(n-1\\)次多项式都有\\(n\\)个系数，所以代入\\((1,u_1),(2,u_2),\\dots,(n,u_n)\\)，列出一个有\\(n\\)条方程的\\(n\\)元一次方程组：\r\n\\[\r\n\\begin{bmatrix}\r\n1^0 &amp; 1^1 &amp; 1^2 &amp;\\cdots  &amp; 1^{n-1} \\\\\r\n2^0 &amp; 2^1 &amp; 2^2 &amp; \\cdots &amp; 2^{n-1} \\\\\r\n3^0 &amp; 3^1 &amp; 3^2 &amp; \\cdots &amp; 3^{n-1} \\\\\r\n\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots  &amp; \\vdots \\\\\r\nn^0 &amp; n^1 &amp; n^2 &amp;\\cdots  &amp; n^{n-1}\r\n\\end{bmatrix}\r\n\\begin{bmatrix}\r\nc_0 \\\\\r\nc_1 \\\\\r\nc_2 \\\\\r\n\\vdots \\\\\r\nc_{n-1}\r\n\\end{bmatrix}\r\n=\r\n\\begin{bmatrix}\r\nu_1 \\\\\r\nu_2 \\\\\r\nu_3 \\\\\r\n\\vdots \\\\\r\nu_n\r\n\\end{bmatrix}\r\n\\]\r\n使用高斯消元方法，解得系数\\([c_0,c_1,c_2,\\dots,c_{n-1}]^T\\)后，即可确定\\(p(x)\\)本身，那么，第\\(n\\)个多项式对应的FIT为\\(p(n+1)\\)。当\\(p\\)的次数等于多项式\\(u\\)的次数时，就不存在FIT了。\r\n因此将各个FIT相加即可。\r\n另外一种做法则是使用多项式插值。本代码使用的是sympy库的interpolating_poly函数，它是基于拉格朗日插值实现的。给定\\(n\\)个点\\((x_1,y_1),(x_2,y_2),\\dots,(x_n,y_n)\\)，那么这个函数就会返回一个\\(n-1\\)次多项式。拉格朗日插值的公式如下：\r\n\\[p(x)=\\sum_{j=1}^n y_j\\prod_{k=1,k\\neq\r\nj}^n \\dfrac{x-x_k}{x_j-x_k}\\]\r\n代码\r\nfrom sympy import interpolating_polyfrom sympy.abc import xN = 10x_list = list(range(1, N + 1))y_list = list(    map(lambda n: 1 - n + n ** 2 - n ** 3 + n ** 4 - n ** 5 + n ** 6 - n ** 7 + n ** 8 - n ** 9 + n ** 10, x_list))ans = 0for i in range(1, N + 1):    poly = interpolating_poly(i, x, x_list, y_list)    if poly.is_Number:        ans += poly    else:        ans += poly.as_poly()(i + 1)print(ans)\r\nfrom fractions import Fractiondef fun(n: int):    return 1 - n + n ** 2 - n ** 3 + n ** 4 - n ** 5 + n ** 6 - n ** 7 + n ** 8 - n ** 9 + n ** 10def solve(mat: list):    n = len(mat)    for j in range(n):        for i in range(j, n):            if mat[i][j]:                mat[i], mat[j] = mat[j], mat[i]                break        if mat[j][j] == 0:            continue        for i in range(n):            if i == j or mat[i][j] == 0:                continue            val = -mat[i][j] / mat[j][j]            for k in range(j, n + 1):                mat[i][k] += mat[j][k] * val    b = []    for j in range(n):        b.append(mat[j][n] / mat[j][j])    return bans = 0for m in range(1, 11):    mat = []    for i in range(1, m + 1):        ls = []        for j in range(m):            ls.append(Fraction(i ** j))        ls.append(Fraction(fun(i)))        mat.append(ls)    b = [int(x) for x in solve(mat)]    val = 0    for i in range(m):        val += b[i] * ((m + 1) ** i)    ans += valprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 100","url":"/project-euler/100/","content":"\r\nProject Euler 100\r\n题目\r\nArranged probability\r\nIf a box contains twenty-one coloured discs, composed of fifteen blue\r\ndiscs and six red discs, and two discs were taken at random, it can be\r\nseen that the probability of taking two blue discs, \\(P(BB) = \\dfrac{15}{21}×\\dfrac{14}{20} =\r\n\\dfrac{1}{2}\\).\r\nThe next such arrangement, for which there is exactly \\(50\\%\\) chance of taking two blue discs at\r\nrandom, is a box containing eighty-five blue discs and thirty-five red\r\ndiscs.\r\nBy finding the first arrangement to contain over \\(10^{12} = 1,000,000,000,000\\) discs in\r\ntotal, determine the number of blue discs that the box would\r\ncontain.\r\n解决方案\r\n假设盒子中有\\(n\\)个彩色碟子，其中\\(m\\)个为蓝色，那么得到\\(P(BB)=\\dfrac{\\binom{m}{2}}{\\binom{n}{2}}=\\dfrac{m(m-1)}{n(n-1)}\\)。\r\n令\\(P(BB)=\\dfrac{1}{2}\\)，得到方程\\(2m(m-1)=n(n-1)\\)，\r\n最终化成：\\((2n-1)^2-2(2m-1)^2=1\\)\r\n令\\(x=2n-1,y=2m-1\\)，那么就化成了\\(x^2-2y^2=-1\\)，该类方程为负佩尔方程\\(x^2-Dy^2=-1\\)。\r\n假设\\(x^2-Dy^2=-1\\)存在最小特解为\\((x_1,y_1)\\)。那么，负佩尔方程的通解\\((x_k,y_k)\\)由以下式子导出。\r\n\\[x_k+y_k\\sqrt{D}=(x_{k-1}+y_{k-1}\\sqrt{D})(x_1+y_1\\sqrt{D})^2\\]\r\n容易发现，\\(x^2-2y^2=-1\\)的最小特解为\\((1,1)\\)，代入上面的导出递推公式，得到通解递推公式：\r\n\\[\\left \\{\\begin{aligned}\r\n  &amp; x_{k+1}=3x_k+4y_k\\\\\r\n  &amp; y_{k+1}=2x_k+3y_k\r\n\\end{aligned}\\right.\r\n\\]\r\n将\\(x_k=2n_k-1,y_k=2m_k-1\\)代入上面的两个递推式，有：\r\n\\[\\left \\{\\begin{aligned}\r\n  &amp; n_{k+1}=3n_k+4m_k-3 \\\\\r\n  &amp; m_{k+1}=2n_k+3m_k-2\r\n\\end{aligned}\\right.\r\n\\]\r\n容易发现，\\(n_1=4,m_1=3\\)是原方程中的最小特解，因此按照该式子直接递推求解。\r\n代码\r\nN = 10 ** 12n, m = 4, 3while n &lt;= N:    n, m = 3 * n + 4 * m - 3, 2 * n + 3 * m - 2ans = mprint(ans)\r\n","categories":["Project Euler"],"tags":["佩尔方程"]},{"title":"Project Euler 102","url":"/project-euler/102/","content":"\r\nProject Euler 102\r\n题目\r\nTriangle containment\r\nThree distinct points are plotted at random on a Cartesian plane, for\r\nwhich \\(-1000 \\leq x,y\\leq  1000\\),\r\nsuch that a triangle is formed.\r\nConsider the following two triangles:\r\n\\[\\begin{aligned}\r\n&amp;A(-340,495), B(-153,-910), C(835,-947)\\\\\r\n&amp;X(-175,41), Y(-421,-714), Z(574,-645)\r\n\\end{aligned}\\]\r\nIt can be verified that triangle \\(ABC\\) contains the origin, whereas triangle\r\n\\(XYZ\\) does not.\r\nUsing triangles.txt\r\n(right click and ‘Save Link/Target As’), a 27K text file containing the\r\nco-ordinates of one thousand “random” triangles, find the number of\r\ntriangles for which the interior contains the origin.\r\nNOTE: The first two examples in the file represent the triangles in\r\nthe example given above.\r\n解决方案\r\n设向量\\(\\overrightarrow{a}=(x_1,y_1),\\overrightarrow{b}=(x_2,y_2)\\)。那么向量的叉积为\r\n\\[\\overrightarrow{a}\\times\r\n\\overrightarrow{b}=x_1y_2-x_2y_1=|\\overrightarrow{a}||\\overrightarrow{b}|\\sin\\theta\\]\r\n其中\\(\\theta\\)为\\(\\overrightarrow{a}\\)逆时针旋转到\\(\\overrightarrow{b}\\)的角度。\r\n如果向量\\(\\overrightarrow{b}\\)的方向为向量\\(\\overrightarrow{a}\\)逆时针旋转\\(180°\\)内，那么\\(\\overrightarrow{a}\\times\\overrightarrow{b}&gt;0\\)。\r\n因此，对于\\(\\triangle\r\nABC\\)任意内一点\\(P\\)，如果\\(\\overrightarrow{PA}\\times\r\n\\overrightarrow{PB},\\overrightarrow{PB}\\times\r\n\\overrightarrow{PC},\\overrightarrow{PC}\\times\r\n\\overrightarrow{PA}\\)有一个值为\\(0\\)，那么\\(P\\)在\\(\\triangle\r\nABC\\)边上。如果三个值的正负性都相同，那么\\(P\\)在\\(\\triangle\r\nABC\\)内部。否则P在\\(\\triangle\r\nABC\\)外部。\r\n代码\r\nls = open(&#x27;p102_triangles.txt&#x27;, &#x27;r&#x27;).readlines()def cross(va: tuple, vb: tuple):    return va[0] * vb[1] - va[1] * vb[0]def ok(vec_list: list):    u, v, w = cross(vec_list[0], vec_list[1]), cross(vec_list[1], vec_list[2]), cross(vec_list[2], vec_list[0])    if u &gt; 0 and v &gt; 0 and w &gt; 0 or u &lt; 0 and v &lt; 0 and w &lt; 0:        return True    return Falseans = 0for s in ls:    t = [int(x) for x in s.split(&#x27;,&#x27;)]    if ok([(t[0], t[1]), (t[2], t[3]), (t[4], t[5])]):        ans += 1print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 104","url":"/project-euler/104/","content":"\r\nProject Euler 104\r\n题目\r\nPandigital Fibonacci ends\r\nThe Fibonacci sequence is defined by the recurrence relation:\r\n\\(F_n = F_n−1 + F_n−2\\), where \\(F_1 = 1\\) and \\(F_2 = 1\\).\r\nIt turns out that \\(F_{541}\\), which\r\ncontains \\(113\\) digits, is the first\r\nFibonacci number for which the last nine digits are \\(1-9\\) pandigital (contain all the digits\r\n\\(1\\) to \\(9\\), but not necessarily in order). And\r\n\\(F_{2749}\\), which contains \\(575\\) digits, is the first Fibonacci number\r\nfor which the first nine digits are \\(1-9\\) pandigital.\r\nGiven that \\(F_k\\) is the first\r\nFibonacci number for which the first nine digits AND the last nine\r\ndigits are \\(1-9\\) pandigital, find\r\n\\(k\\).\r\n解决方案\r\n从小到大枚举斐波那契数的项数。由于本题只关心高\\(9\\)位和低\\(9\\)位，因此可以这么做：\r\n\r\n将整个数直接对\\(10^9\\)取模，那么所得到的值是精确的低\\(9\\)位。\r\n浮点数的特点是只保留前几位的有效数字，那么就用浮点数来存储整个值，只要前\\(9\\)位准确就行。\r\n\r\n因此，计算低位时，只需要全程对\\(10^9\\)取模即可。\r\n计算高位时，如果高位的数到达了一个阈值（这里设定为\\(10^{12}\\)），那么就对这个数除\\(10\\)。这不仅影响高位的准确性，还能在转字符串判断时，防止产生的浮点数字符串太长，加速判断。\r\n代码\r\nfrom itertools import counts = &quot;123456789&quot;m = 10 ** len(s)a = b = 1u = v = 1.0for i in count(1, 1):    l = str(a)    r = str(u)[:len(s)]    l = &quot;&quot;.join((lambda x: (x.sort(), x)[1])(list(l)))    r = &quot;&quot;.join((lambda x: (x.sort(), x)[1])(list(r)))    if l == r == s:        ans = i        break    a, b = b, (a + b) % m    u, v = v, u + v    if v &gt; 1e12:        u /= 10        v /= 10print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 103","url":"/project-euler/103/","content":"\r\nProject Euler 103\r\n题目\r\nSpecial subset sums: optimum\r\nLet \\(S(A)\\) represent the sum of\r\nelements in set \\(A\\) of size \\(n\\). We shall call it a special sum set if\r\nfor any two non-empty disjoint subsets, \\(B\\) and \\(C\\), the following properties are true:\r\n\r\n\\(S(B) \\neq S(C)\\); that is, sums\r\nof subsets cannot be equal.\r\nIf \\(B\\) contains more elements\r\nthan \\(C\\) then \\(S(B) &gt; S(C)\\).\r\n\r\nIf \\(S(A)\\) is minimised for a given\r\n\\(n\\), we shall call it an optimum\r\nspecial sum set. The first five optimum special sum sets are given\r\nbelow.\r\n\\(\\begin{aligned}\r\nn = 1&amp;: \\{1\\} \\\\\r\nn = 2&amp;: \\{1, 2\\} \\\\\r\nn = 3&amp;: \\{2, 3, 4\\} \\\\\r\nn = 4&amp;: \\{3, 5, 6, 7\\} \\\\\r\nn = 5&amp;: \\{6, 9, 11, 12, 13\\} \\\\\r\n\\end{aligned}\\)\r\nIt seems that for a given optimum set, \\(A = {a_1, a_2, \\dots , a_n}\\), the next\r\noptimum set is of the form \\(B = {b, a_1+b,\r\na_2+b, \\dots ,a_n+b}\\), where \\(b\\) is the “middle” element on the previous\r\nrow.\r\nBy applying this “rule” we would expect the optimum set for \\(n=6\\) to be \\(A =\r\n\\{11, 17, 20, 22, 23, 24\\}\\), with \\(S(A) = 117\\). However, this is not the\r\noptimum set, as we have merely applied an algorithm to provide a near\r\noptimum set. The optimum set for \\(n=6\\) is \\(A =\r\n\\{11, 18, 19, 20, 22, 25\\}\\), with \\(S(A) = 115\\) and corresponding set string:\r\n\\(111819202225\\).\r\nGiven that \\(A\\) is an optimum\r\nspecial sum set for \\(n=7\\), find its\r\nset string.\r\nNOTE: This problem is related to Problem\r\n105 and Problem 106.\r\n解决方案\r\n一个推论：如果一个集合满足题目中的第一个条件，那么它们的所有\\(2^n\\)个子集\\(I\\)的\\(S(I)\\)都不相同。\r\n使用反证法：设一个集合\\(A\\)，对于\\(A\\)中的两个子集\\(I,J\\)，满足\\(S(I)=S(J)\\)，有以下两种情况\r\n\r\n\\(I \\cap J =\r\n\\varnothing\\)：那么明显\\(A\\)集合不符合要求。\r\n\\(I \\cap J \\ne\r\n\\varnothing\\)：此时取\\(I&#39;=I-J,J&#39;=J-I\\)，根据集合差运算的定义，有\\(S(I&#39;)=S(I)-S(I \\cap J),S(J&#39;)=S(J)-S(I \\cap\r\nJ)\\)。可以知道，此时\\(I&#39; \\cap\r\nJ&#39; = \\varnothing\\)，但有\\(S(I&#39;)=S(J&#39;)\\)，不符合要求。\r\n\r\n因此原推论成立，判断集合是否为特殊不需要直接枚举一对不相交子集。而是产生所有子集，先判断元素和是否重复，然后根据和的大小进行排序比较集合大小即可（判断第二个条件是否满足）。\r\n题目中介绍了一个生成特殊集合的方法，但不保证元素和是最小的。\r\n因此，个人思路如下：\r\n\r\n利用题目中给定的方法暂时生成一个\\(n=7\\)的特殊集合\\(A\\)。\r\n对集合中的每个元素施加一定的“扰动”（每个元素都先让它们加一或减一或不动），由此尝试找到元素和更小的特殊集合。\r\n\r\n代码\r\nfrom itertools import producta = [11, 18, 19, 20, 22, 25]b = [a[len(a) // 2]]for x in a:    b.append(20 + x)n = len(b)ans = list(b)def ok(z: list):    mp = &#123;&#125;    for st in range(1 &lt;&lt; n):        cnt, s = 0, 0        for i in range(n):            if st &gt;&gt; i &amp; 1:                cnt += 1                s += z[i]        if s in mp.keys():            return False        mp[s] = cnt    ls = list(mp.items())    ls.sort()    for i in range((1 &lt;&lt; n) - 1):        if ls[i][1] &gt; ls[i + 1][1]:            return False    return Truefor w in product([-1, 0, 1], repeat=n):    z = [w[i] + b[i] for i in range(n)]    if sum(z) &lt; sum(ans) and ok(z):        ans = zprint(&quot;&quot;.join([str(x) for x in ans]))\r\n","categories":["Project Euler"]},{"title":"Project Euler 107","url":"/project-euler/107/","content":"\r\nProject Euler 107\r\n题目\r\nMinimal network\r\nThe following undirected network consists of seven vertices and\r\ntwelve edges with a total weight of 243.\r\n\r\nThe same network can be represented by the matrix below.\r\n\r\n\r\n\r\n\r\nA\r\nB\r\nC\r\nD\r\nE\r\nF\r\nG\r\n\r\n\r\n\r\n\r\nA\r\n-\r\n\\(16\\)\r\n\\(12\\)\r\n\\(21\\)\r\n-\r\n-\r\n-\r\n\r\n\r\nB\r\n\\(16\\)\r\n-\r\n-\r\n\\(17\\)\r\n\\(20\\)\r\n-\r\n-\r\n\r\n\r\nC\r\n\\(12\\)\r\n-\r\n-\r\n\\(28\\)\r\n-\r\n\\(31\\)\r\n-\r\n\r\n\r\nD\r\n\\(21\\)\r\n\\(17\\)\r\n\\(28\\)\r\n-\r\n\\(18\\)\r\n\\(19\\)\r\n\\(23\\)\r\n\r\n\r\nE\r\n-\r\n\\(20\\)\r\n-\r\n\\(18\\)\r\n-\r\n-\r\n\\(11\\)\r\n\r\n\r\nF\r\n-\r\n-\r\n\\(31\\)\r\n\\(19\\)\r\n-\r\n-\r\n\\(27\\)\r\n\r\n\r\nG\r\n-\r\n-\r\n-\r\n\\(23\\)\r\n\\(11\\)\r\n\\(27\\)\r\n-\r\n\r\n\r\n\r\nHowever, it is possible to optimise the network by removing some\r\nedges and still ensure that all points on the network remain connected.\r\nThe network which achieves the maximum saving is shown below. It has a\r\nweight of 93, representing a saving of 243 ? 93 = 150 from the original\r\nnetwork.\r\n\r\nUsing network.txt (right\r\nclick and ‘Save Link/Target As’), a 6K text file containing a network\r\nwith forty vertices, and given in matrix form, find the maximum saving\r\nwhich can be achieved by removing redundant edges whilst ensuring that\r\nthe network remains connected.\r\n解决方案\r\n这是图论中最小生成树(Minimum\r\nspanning tree)中的问题。常见的使用算法有Kruskal和Prim算法。\r\nKruskal算法主要是基于贪心思想，使用并查集实现的，维基百科上的伪代码如下：\r\nalgorithm Kruskal(G) is    F:= ∅    for each v ∈ G.V do        MAKE-SET(v)    for each (u, v) in G.E ordered by weight(u, v), increasing do        if FIND-SET(u) ≠ FIND-SET(v) then            F:= F ∪ &#123;(u, v)&#125; ∪ &#123;(v, u)&#125;            UNION(FIND-SET(u), FIND-SET(v))    return F\r\n根据边权大小的顺序，从小到大遍历每条边。如果边两侧的点不在一个集合中，那么这条边是需要的，并将这两个集合合并；否则跳过这条边。\r\n本代码使用networkx的minimum_spanning_tree函数，直接给出一个最小生成树方案。\r\n代码\r\nimport networkx as nxG = nx.Graph()ls = open(&#x27;p107_network.txt&#x27;, &#x27;r&#x27;).readlines()n = len(ls)ans = 0for i in range(n):    lt = ls[i].split(&#x27;,&#x27;)    for j in range(i):        if lt[j][0] == &#x27;-&#x27;:            continue        w = int(lt[j])        ans += w        G.add_edge(i, j, weight=w)T = nx.minimum_spanning_tree(G)for u, v in T.edges:    ans -= T.get_edge_data(u, v)[&#x27;weight&#x27;]print(ans)\r\nls = open(&#x27;p107_network.txt&#x27;, &#x27;r&#x27;).readlines()n = len(ls)fa = [i for i in range(n)]def find(x: int):    if x == fa[x]:        return x    else:        fa[x] = find(fa[x])        return fa[x]def merge(x: int, y: int):    fa[find(x)] = find(y)e = []ans = 0for i in range(n):    lt = ls[i].split(&#x27;,&#x27;)    for j in range(i):        if lt[j][0] == &#x27;-&#x27;:            continue        w = int(lt[j])        e.append((w, i, j))        ans += we.sort()for z, x, y in e:    if find(x) != find(y):        merge(x, y)        ans -= zprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 105","url":"/project-euler/105/","content":"\r\nProject Euler 105\r\n题目\r\nSpecial subset sums: testing\r\nLet \\(S(A)\\) represent the sum of\r\nelements in set \\(A\\) of size \\(n\\). We shall call it a special sum set if\r\nfor any two non-empty disjoint subsets, \\(B\\) and \\(C\\), the following properties are true:\r\n\r\n\\(S(B) \\neq S(C)\\); that is, sums\r\nof subsets cannot be equal.\r\nIf \\(B\\) contains more elements\r\nthan \\(C\\) then \\(S(B) &gt; S(C)\\).\r\n\r\nFor example, \\(\\{81, 88, 75, 42, 87, 84,\r\n86, 65\\}\\) is not a special sum set because \\(65 + 87 + 88 = 75 + 81 + 84\\), whereas\r\n\\(\\{157, 150, 164, 119, 79, 159, 161, 139,\r\n158\\}\\) satisfies both rules for all possible subset pair\r\ncombinations and \\(S(A) = 1286\\).\r\nUsing sets.txt (right click\r\nand “Save Link/Target As”), a 4K text file with one-hundred sets\r\ncontaining seven to twelve elements (the two examples given above are\r\nthe first two sets in the file), identify all the special sum sets,\\(A_1, A_2, \\ldots , A_k\\), and find the\r\nvalue of \\(S(A_1) + S(A_2) +\\ldots +\r\nS(A_k)\\).\r\nNOTE: This problem is related to Problem 103 and\r\nProblem 106.\r\n解决方案\r\n本题判断特殊子集的方法和第103题一样：\r\n如果一个集合满足题目中的第一个条件，那么它们的所有\\(2^n\\)个子集\\(I\\)的\\(S(I)\\)都不相同。\r\n使用反证法：设一个集合\\(A\\)，对于\\(A\\)中的两个子集\\(I,J\\)，满足\\(S(I)=S(J)\\)，有以下两种情况\r\n\r\n\\(I \\cap J =\r\n\\varnothing\\)：那么明显\\(A\\)集合不符合要求。\r\n\\(I \\cap J \\neq\r\n\\varnothing\\)：此时取\\(I&#39;=I-J,J&#39;=J-I\\)，根据集合差运算的定义，有\\(S(I&#39;)=S(I)-S(I \\cap J),S(J&#39;)=S(J)-S(I \\cap\r\nJ)\\)。可以知道，此时\\(I&#39; \\cap\r\nJ&#39; = \\varnothing\\)，但有\\(S(I&#39;)=S(J&#39;)\\)，不符合要求。\r\n\r\n因此原推论成立，判断集合是否为特殊不需要直接枚举一对不相交子集。而是产生所有子集，先判断元素和是否重复，然后根据和的大小进行排序比较集合大小即可（判断第二个条件是否满足）。\r\n代码\r\ndef ok(z: list):    n = len(z)    mp = &#123;&#125;    for st in range(1 &lt;&lt; n):        cnt, s = 0, 0        for i in range(n):            if st &gt;&gt; i &amp; 1:                cnt += 1                s += z[i]        if s in mp.keys():            return False        mp[s] = cnt    ls = list(mp.items())    ls.sort()    for i in range((1 &lt;&lt; n) - 1):        if ls[i][1] &gt; ls[i + 1][1]:            return False    return Truels = open(&#x27;p105_sets.txt&#x27;, &#x27;r&#x27;).readlines()ans = 0for s in ls:    a = [int(x) for x in s.split(&#x27;,&#x27;)]    if ok(a):        ans += sum(a)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 106","url":"/project-euler/106/","content":"\r\nProject Euler 106\r\n题目\r\nSpecial subset sums:\r\nmeta-testing\r\nLet \\(S(A)\\) represent the sum of\r\nelements in set \\(A\\) of size \\(n\\). We shall call it a special sum set if\r\nfor any two non-empty disjoint subsets, \\(B\\) and \\(C\\), the following properties are true:\r\n\r\n\\(S(B) \\neq S(C)\\); that is, sums\r\nof subsets cannot be equal.\r\nIf \\(B\\) contains more elements\r\nthan \\(C\\) then \\(S(B) &gt; S(C)\\).\r\n\r\nFor this problem we shall assume that a given set contains n strictly\r\nincreasing elements and it already satisfies the second rule.\r\nSurprisingly, out of the \\(25\\)\r\npossible subset pairs that can be obtained from a set for which \\(n = 4\\), only \\(1\\) of these pairs need to be tested for\r\nequality (first rule). Similarly, when \\(n =\r\n7\\), only \\(70\\) out of the\r\n\\(966\\) subset pairs need to be\r\ntested.\r\nFor \\(n = 12\\), how many of the\r\n\\(261625\\) subset pairs that can be\r\nobtained need to be tested for equality?\r\nNOTE: This problem is related to Problem 103 and\r\nProblem 105.\r\n解决方案\r\n由于已经假定了集合\\(A\\)已经满足了第二个条件，因此，只需要考虑两个集合\\(B,C\\)大小相同（\\(|B|=|C|=k\\)）时的情形。\r\n容易发现，不需要求和的情形是：对于 \\(\\forall i:1\\leq i\\leq k\\)，\\(B\\)中的第\\(i\\)小元素都小于（或大于）\\(C\\)中的第\\(i\\)小元素。在最后得出需要求和的时候，需要将这部分情形减去，留下的则计入答案。\r\n因此，首先需要从\\(A\\)中选取\\(2k\\)个元素，其中\\(k\\)个分给\\(B\\)集合，另外\\(k\\)个分给\\(C\\)。由于\\(B,C\\)的先后不需要关心，因此一共有\\(\\dfrac{\\binom{2k}{k}}{2}\\)种分法。\r\n下一个问题的正式描述：已知集合中有\\(2k\\)个不同的元素，其中\\(k\\)个分给\\(B\\)集合，另外\\(k\\)个分给\\(C\\)。（不失一般性，）对于 \\(\\forall i:1\\leq i\\leq k\\)，\\(B\\)中的第\\(i\\)小元素都小于\\(C\\)中的第\\(i\\)小元素，有多少种划分方法？\r\n为解决这个问题，先以一个例子说明：\r\n设\\(k=3\\)，那么就将\\(1\\sim 6\\)这\\(6\\)个数进行放入集合\\(B\\)和\\(C\\)中。\r\n如果第\\(i\\)个数放入\\(B\\)中，那么字符串第\\(i\\)位记为左圆括号’(‘，否则记为右圆括号’)’。\r\n那么有\\(5\\)种方法：\r\n\r\n\r\n\r\n括号字符串\r\n\\(B\\)\r\n\\(C\\)\r\n\r\n\r\n\r\n\r\n()()()\r\n\\(\\{1,3,5\\}\\)\r\n\\(\\{2,4,6\\}\\)\r\n\r\n\r\n()(())\r\n\\(\\{1,3,4\\}\\)\r\n\\(\\{2,5,6\\}\\)\r\n\r\n\r\n(())()\r\n\\(\\{1,2,5\\}\\)\r\n\\(\\{3,4,6\\}\\)\r\n\r\n\r\n((()))\r\n\\(\\{1,2,3\\}\\)\r\n\\(\\{4,5,6\\}\\)\r\n\r\n\r\n(()())\r\n\\(\\{1,2,4\\}\\)\r\n\\(\\{3,5,6\\}\\)\r\n\r\n\r\n\r\n每个括号字符串对应着一种分配方法。可以发现这个括号字符串有一下特点：\r\n\r\n左圆括号和右圆括号的数量相等\r\n每个字符串的前缀中，左圆括号的数量不会少于右圆括号。这也就说明了，\\(B\\)中的每一个数，\\(C\\)中总有更大的数和它们一一对应。\r\n\r\n符合这种特征的字符串的个数，称为卡特兰数，在OEIS中为A000108。第\\(n\\)项为\\(C(n)=\\dfrac{\\binom{2n}{n}}{n+1}\\)。\r\n综上所述，答案为：\r\n\\[\\sum_{k=1}^{\\lfloor\\frac{n}{2}\\rfloor}\\binom{n}{2k}\\left(\\dfrac{\\binom{2k}{k}}{2}-\\dfrac{\\binom{2k}{k}}{k+1}\\right)\\]\r\n代码\r\nfrom tools import CN = 12ans = sum(C(N, 2 * k) * (C(2 * k, k) // 2 - C(2 * k, k) // (k + 1)) for k in range(1, N // 2 + 1))print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 108","url":"/project-euler/108/","content":"\r\nProject Euler 108\r\n题目\r\nDiophantine reciprocals I\r\nIn the following equation \\(x, y\\),\r\nand \\(n\\) are positive integers.\r\n\\[\\dfrac{1}{x} + \\dfrac{1}{y} =\r\n\\dfrac{1}{n}\\]\r\nFor \\(n = 4\\) there are exactly\r\nthree distinct solutions:\r\n\\[\\begin{aligned}\r\n\\dfrac{1}{5} + \\dfrac{1}{20} &amp;= \\dfrac{1}{4}\\\\\r\n\\dfrac{1}{6} + \\dfrac{1}{12} &amp;= \\dfrac{1}{4}\\\\\r\n\\dfrac{1}{8} + \\dfrac{1}{8} &amp;= \\dfrac{1}{4}\r\n\\end{aligned}\r\n\\]\r\nWhat is the least value of \\(n\\) for\r\nwhich the number of distinct solutions exceeds one-thousand?\r\n\r\nNOTE: This problem is an easier version of\r\nProblem 110; it is strongly advised that you\r\nsolve this one first.\r\n解决方案\r\n先暴力枚举出前几项的解的个数，然后查询OEIS，发现结果为数列A018892。\r\n在FORMULA一栏中可以发现：\r\nIf n = (p1^a1)(p2^a2)...(pt^at), a(n) = ((2*a1 + 1)(2*a2 + 1) ... (2*at + 1) + 1)/2.\r\n这说明，如果正整数\\(n\\)分解为\\(n=\\prod_{i=1}^k\r\np_i^{e_i}\\)，那么本题解的个数为\\(f(n)=\\dfrac{\\prod_{i=1}^k(2e_i+1)+1}{2}\\)。\r\n因此，通过\\(n\\)的分解质因数枚举\\(n\\)即可，枚举时，为使\\(n\\)取到的最小，注意当\\(e_i&gt;e_j\\)时，那么\\(p_i&lt;p_j\\)。\r\n关于上面的式子得出过程：\r\n将式子\\(\\dfrac{1}{x}+\\dfrac{1}{y}=\\dfrac{1}{n}\\)进行去除分母，再进行移项后得到：\\(x=\\dfrac{ny}{y-n}\\).\r\n令\\(t=y-n\\)，那么\\(y=n+t\\)，代入原式子，得到：\\(x=\\dfrac{n(n+t)}{t}=\\dfrac{n^2}{t}+n\\).\r\n如果\\(x\\)是一个整数，那么\\(t \\mid n^2\\)。\r\n那么，\\(t\\)取遍\\(n^2\\)的各个因数，根据因数个数定理，\\(x\\)有\\(d(n^2)=\\prod_{i=1}^k(2e_i+1)\\)种取值。\r\n为不失解的一般性，方程\\(\\dfrac{1}{x} +\r\n\\dfrac{1}{y} = \\dfrac{1}{n}\\)中的每个解都需要满足\\(x\\leq y\\)。\r\n而当\\(x=y=2n\\)时，满足该等于号。\r\n故方程\\(\\dfrac{1}{x}+\\dfrac{1}{y}=\\dfrac{1}{n}\\)解的总个数为\\(f(n)=\\dfrac{\\prod_{i=1}^k\r\n(2e_i+1)+1}{2}\\)。\r\n代码\r\nfrom tools import get_primeN = 1000pr = get_prime(len(bin(N)) * 50)ans = N ** 10def dfs(n: int, mul: int, f: int, lm: int):    global ans    if (mul + 1) &gt;&gt; 1 &gt;= N:        ans = n        return    for i in range(1, lm + 1):        n *= pr[f]        if n &gt; ans:            break        dfs(n, mul * (2 * i + 1), f + 1, i)dfs(1, 1, 0, N)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 109","url":"/project-euler/109/","content":"\r\nProject Euler 109\r\n题目\r\nDarts\r\nIn the game of darts a player throws three darts at a target board\r\nwhich is split into twenty equal sized sections numbered one to\r\ntwenty.\r\n\r\nThe score of a dart is determined by the number of the region that\r\nthe dart lands in. A dart landing outside the red/green outer ring\r\nscores zero. The black and cream regions inside this ring represent\r\nsingle scores. However, the red/green outer ring and middle ring score\r\ndouble and treble scores respectively.\r\nAt the centre of the board are two concentric circles called the bull\r\nregion, or bulls-eye. The outer bull is worth \\(25\\) points and the inner bull is a double,\r\nworth \\(50\\) points.\r\nThere are many variations of rules but in the most popular game the\r\nplayers will begin with a score \\(301\\)\r\nor \\(501\\) and the first player to\r\nreduce their running total to zero is a winner. However, it is normal to\r\nplay a “doubles out” system, which means that the player must land a\r\ndouble (including the double bulls-eye at the centre of the board) on\r\ntheir final dart to win; any other dart that would reduce their running\r\ntotal to one or lower means the score for that set of three darts is\r\n“bust”.\r\nWhen a player is able to finish on their current score it is called a\r\n“checkout” and the highest checkout is \\(170\\): T20 T20 D25 (two treble 20s and\r\ndouble bull).\r\nThere are exactly eleven distinct ways to checkout on a score of\r\n\\(6\\):\r\n\r\n\r\n\r\nD3\r\n\r\n\r\n\r\n\r\nD1\r\nD2\r\n\r\n\r\n\r\nS2\r\nD2\r\n\r\n\r\n\r\nD2\r\nD1\r\n\r\n\r\n\r\nS4\r\nD1\r\n\r\n\r\n\r\nS1\r\nS1\r\nD2\r\n\r\n\r\nS1\r\nT1\r\nD1\r\n\r\n\r\nS1\r\nS3\r\nD1\r\n\r\n\r\nD1\r\nD1\r\nD1\r\n\r\n\r\nD1\r\nS2\r\nD1\r\n\r\n\r\nS2\r\nS2\r\nD1\r\n\r\n\r\n\r\nNote that D1 D2 is considered different to D2 D1 as\r\nthey finish on different doubles. However, the combination S1 T1 D1 is\r\nconsidered the same as T1 S1 D1.\r\nIn addition we shall not include misses in considering combinations;\r\nfor example, D3 is the same as 0 D3 and 0 0 D3.\r\nIncredibly there are \\(42336\\)\r\ndistinct ways of checking out in total.\r\nHow many distinct ways can a player checkout with a score less than\r\n\\(100\\)?\r\n解决方案\r\n将所有得分情况全部存在一个列表中。其中前\\(m\\)个是双倍得分，其余是三倍得分。\r\n多重循环遍历所有情况即可。需要注意的地方只有判断是不是相同的结分。\r\n代码\r\nN = 100M = 20a = list(range(2, M * 2 + 2, 2)) + [50]m = len(a)a += [25] + list(range(1, M + 1)) + list(range(3, M * 3 + 3, 3))n = len(a)ans = 0for i in range(m):    if a[i] &lt; N:        ans += 1for i in range(n):    for j in range(m):        if a[i] + a[j] &lt; N:            ans += 1for i in range(n):    for j in range(i, n):        for k in range(m):            if a[i] + a[j] + a[k] &lt; N:                ans += 1print(ans)\r\n","categories":["Project Euler"],"tags":["模拟"]},{"title":"Project Euler 111","url":"/project-euler/111/","content":"\r\nProject Euler 111\r\n题目\r\nPrimes with runs\r\nConsidering \\(4\\)-digit primes\r\ncontaining repeated digits it is clear that they cannot all be the same:\r\n\\(1111\\) is divisible by \\(11\\), \\(2222\\) is divisible by \\(22\\), and so on. But there are nine \\(4\\)-digit primes containing three ones:\r\n\\[1117, 1151, 1171, 1181, 1511, 1811,\r\n2111, 4111, 8111\\]\r\nWe shall say that \\(M(n, d)\\)\r\nrepresents the maximum number of repeated digits for an \\(n\\)-digit prime where \\(d\\) is the repeated digit, \\(N(n, d)\\) represents the number of such\r\nprimes, and \\(S(n, d)\\) represents the\r\nsum of these primes.\r\nSo \\(M(4, 1) = 3\\) is the maximum\r\nnumber of repeated digits for a \\(4\\)-digit prime where one is the repeated\r\ndigit, there are \\(N(4, 1) = 9\\) such\r\nprimes, and the sum of these primes is \\(S(4,\r\n1) = 22275\\). It turns out that for \\(d\r\n= 0\\), it is only possible to have \\(M(4, 0) = 2\\) repeated digits, but there\r\nare \\(N(4, 0) = 13\\) such cases.\r\nIn the same way we obtain the following results for \\(4\\)-digit primes.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\\(\\mathbf{Digit, d}\\)\r\n\\(\\mathbf{M(4, d)}\\)\r\n\\(\\mathbf{N(4, d)}\\)\r\n\\(\\mathbf{S(4, d)}\\)\r\n\r\n\r\n\r\n\r\n\\(0\\)\r\n\\(2\\)\r\n\\(13\\)\r\n\\(67061\\)\r\n\r\n\r\n\\(1\\)\r\n\\(3\\)\r\n\\(9\\)\r\n\\(22275\\)\r\n\r\n\r\n\\(2\\)\r\n\\(3\\)\r\n\\(1\\)\r\n\\(2221\\)\r\n\r\n\r\n\\(3\\)\r\n\\(3\\)\r\n\\(12\\)\r\n\\(46214\\)\r\n\r\n\r\n\\(4\\)\r\n\\(3\\)\r\n\\(2\\)\r\n\\(8888\\)\r\n\r\n\r\n\\(5\\)\r\n\\(3\\)\r\n\\(1\\)\r\n\\(5557\\)\r\n\r\n\r\n\\(6\\)\r\n\\(3\\)\r\n\\(1\\)\r\n\\(6661\\)\r\n\r\n\r\n\\(7\\)\r\n\\(3\\)\r\n\\(9\\)\r\n\\(57863\\)\r\n\r\n\r\n\\(8\\)\r\n\\(3\\)\r\n\\(1\\)\r\n\\(8887\\)\r\n\r\n\r\n\\(9\\)\r\n\\(3\\)\r\n\\(7\\)\r\n\\(48073\\)\r\n\r\n\r\n\r\nFor \\(d = 0\\) to \\(9\\), the sum of all \\(S(4, d)\\) is \\(273700\\).\r\nFind the sum of all \\(S(10,\r\nd)\\).\r\n解决方案\r\n本题主要通过位运算的手段来枚举。\r\n这里用一个\\(N\\)比特数\\(mask\\)表示一个\\(N\\)位数的状态。对于某个数位\\(d(0\\leq d\\leq 9)\\)，如果任意一个\\(N\\)位数，第\\(i\\)位为\\(d\\)，那么状态\\(mask\\)的第\\(i\\)位为\\(1\\)，否则为\\(0\\)。\r\n以题目中的数字为例，如\\(d=1,N=4\\)时，\\(1117\\)表示成状态\\((1110)_2\\)，\\(2111\\)为状态\\((0111)_2\\)。\r\n将所有的\\(N\\)比特状态值枚举出来，将状态按其中比特为\\(1\\)的数量\\(b\\)进行分类。\r\n按照比特为\\(1\\)的数量\\(b\\)，从大到小枚举每个分类，遍历分类中所有的状态，然后通过递归生成对应状态\\(mask\\)下的所有数。在这些拥有\\(b\\)个某数位\\(d\\)的数中，如果存在一个数是质数，那么就有\\(M(N,d)=b\\)，第一次找到的结果就是最优的。找完其它有\\(b\\)个\\(d\\)的质数后，那么循环就可以停下来，不用再往后判断\\(b-1\\)个\\(d\\)的那些数了。\r\n另外，还需要注意最高位不能填\\(0\\)这种情况。\r\n代码\r\nfrom tools import is_primeN = 10ls = [[] for i in range(N)]for s in range(1, (1 &lt;&lt; N) - 1):    ls[bin(s).count(&#x27;1&#x27;)].append(s)def gen(msk: int, f: int, digit: int, num: int, a: list):    if f == -1:        if isprime(num):            a.append(num)        return    if msk &gt;&gt; f &amp; 1:        if digit == 0 and f == N - 1:            return        else:            gen(msk, f - 1, digit, num * 10 + digit, a)    else:        # 如果是在最高位任意填，那么必须从1开始填，否则从0开始填。        for k in range(int(f == N - 1), 10):            if k != digit:                gen(msk, f - 1, digit, num * 10 + k, a)ans = 0for digit in range(10):    for bits in range(N - 1, 0, -1):        a = []        for v in ls[bits]:            gen(v, N - 1, digit, 0, a)        s = sum(a)        if s:            ans += s            breakprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 11","url":"/project-euler/11/","content":"\r\nProject Euler 11\r\n题目\r\nLargest product in a grid\r\nIn the \\(20\\times20\\) grid below,\r\nfour numbers along a diagonal line have been marked in red.\r\n\r\n08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08 49 49\r\n99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00 81 49 31 73\r\n55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65 52 70 95 23 04 60\r\n11 42 69 24 68 56 01 32 56 71 37 02 36 91 22 31 16 71 51 67 63 89\r\n41 92 36 54 22 40 40 28 66 33 13 80 24 47 32 60 99 03 45 02 44 75\r\n33 53 78 36 84 20 35 17 12 50 32 98 81 28 64 23 67 10\r\n26 38 40 67 59 54 70 66 18 38 64 70 67 26\r\n20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49\r\n94 21 24 55 58 05 66 73 99 26 97 17 78 78\r\n96 83 14 88 34 89 63 72 21 36 23 09 75 00 76 44 20 45 35\r\n14 00 61 33 97 34 31 33 95 78 17 53 28 22\r\n75 31 67 15 94 03 80 04 62 16 14 09 53 56 92 16 39 05 42 96 35 31\r\n47 55 58 88 24 00 17 54 24 36 29 85 57 86 56 00 48 35 71 89 07 05\r\n44 44 37 44 60 21 58 51 54 17 58 19 80 81 68 05 94 47 69 28 73 92\r\n13 86 52 17 77 04 89 55 40 04 52 08 83 97 35 99 16 07 97 57 32 16\r\n26 26 79 33 27 98 66 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12\r\n32 63 93 53 69 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40\r\n62 76 36 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36\r\n16 20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05\r\n54 01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67\r\n48\r\n\r\nThe product of these numbers is \\(26 \\times\r\n63 \\times 78 \\times 14 = 1788696\\).\r\nWhat is the greatest product of four adjacent numbers in the same\r\ndirection (up, down, left, right, or diagonally) in the \\(20\\times20\\) grid?\r\n解决方案\r\n将整个矩阵复制成字符串，转化成一个\\(20\\times\r\n20\\)的二维数组，然后遍历每个元素，朝\\(4\\)个方向（上下、左右、主对角线和副对角线）。\r\n在本代码中，是将其视为一个个\\(4\\times\r\n4\\)矩阵再进行下一步比较。\r\n代码\r\ns = &#x27;&#x27;&#x27;08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 0849 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 0081 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 6552 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 9122 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 8024 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 5032 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 7067 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 2124 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 7221 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 9578 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 9216 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 5786 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 5819 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 4004 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 6688 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 6904 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 3620 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 1620 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 5401 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48&#x27;&#x27;&#x27;ls = s.split(&#x27;\\n&#x27;)a = []for s in ls:    s = s[:-1]    a.append([int(x) for x in s.split(&#x27; &#x27;)])n = m = 20ans = 0for i in range(n - 3):    for j in range(m - 3):        x = a[i][j] * a[i][j + 1] * a[i][j + 2] * a[i][j + 3]        y = a[i][j] * a[i + 1][j] * a[i + 2][j] * a[i + 3][j]        z = a[i][j] * a[i + 1][j + 1] * a[i + 2][j + 2] * a[i + 3][j + 3]        w = a[i][m - j - 1] * a[i + 1][m - j - 2] * a[i + 2][m - j - 3] * a[i + 3][m - j - 4]        ans = max(ans, x, y, z, w)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 112","url":"/project-euler/112/","content":"\r\nProject Euler 112\r\n题目\r\nBouncy numbers\r\nWorking from left-to-right if no digit is exceeded by the digit to\r\nits left it is called an increasing number; for example, \\(134468\\).\r\nSimilarly if no digit is exceeded by the digit to its right it is\r\ncalled a decreasing number; for example, \\(66420\\).\r\nWe shall call a positive integer that is neither increasing nor\r\ndecreasing a “bouncy” number; for example, \\(155349\\).\r\nClearly there cannot be any bouncy numbers below one-hundred, but\r\njust over half of the numbers below one-thousand (\\(525\\)) are bouncy. In fact, the least\r\nnumber for which the proportion of bouncy numbers first reaches \\(50\\%\\) is \\(538\\).\r\nSurprisingly, bouncy numbers become more and more common and by the\r\ntime we reach \\(21780\\) the proportion\r\nof bouncy numbers is equal to \\(90\\%\\).\r\nFind the least number for which the proportion of bouncy numbers is\r\nexactly \\(99\\%\\).\r\n解决方案\r\n可以发现，随着\\(n\\)的增大，弹跳数的数量会占绝大多数。\r\n因此，直接从\\(1\\)开始暴力枚举，并直接判断是否为弹跳数。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;const int M=99;int main()&#123;    int ans,cnt=0;    for(int i=1;;i++)&#123;        string s=to_string(i);        bool u=0,d=0;        for(int i=0;i+1&lt;s.size()&amp;&amp;!(u&amp;&amp;d);i++)&#123;            if(s[i]&lt;s[i+1]) u=1;            if(s[i]&gt;s[i+1]) d=1;        &#125;        if(u&amp;&amp;d) ++cnt;        if(cnt*100==M*i)&#123;            ans=i;            break;        &#125;    &#125;    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["模拟"]},{"title":"Project Euler 110","url":"/project-euler/110/","content":"\r\nProject Euler 110\r\n题目\r\nDiophantine reciprocals II\r\nIn the following equation \\(x, y\\),\r\nand \\(n\\) are positive integers.\r\n\\[\\dfrac{1}{x} + \\dfrac{1}{y} =\r\n\\dfrac{1}{n}\\]\r\nIt can be verified that when \\(n =\r\n1260\\) there are \\(113\\)\r\ndistinct solutions and this is the least value of \\(n\\) for which the total number of distinct\r\nsolutions exceeds one hundred.\r\nWhat is the least value of \\(n\\) for\r\nwhich the number of distinct solutions exceeds four million?\r\n\r\nNOTE: This problem is a much more difficult version of\r\nProblem 108 and as it is well beyond the\r\nlimitations of a brute force approach it requires a clever\r\nimplementation.\r\n解决方案\r\n使用的方案和第108题完全相同，此处不赘述。\r\n代码\r\nfrom tools import get_primeN = 4000000pr = get_prime(len(bin(N)) * 50)ans = N ** 10def dfs(n: int, mul: int, f: int, lm: int):    global ans    if (mul + 1) &gt;&gt; 1 &gt;= N:        ans = n        return    for i in range(1, lm + 1):        n *= pr[f]        if n &gt; ans:            break        dfs(n, mul * (2 * i + 1), f + 1, i)dfs(1, 1, 0, N)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 113","url":"/project-euler/113/","content":"\r\nProject Euler 113\r\n题目\r\nNon-bouncy numbers\r\nWorking from left-to-right if no digit is exceeded by the digit to\r\nits left it is called an increasing number; for example, \\(134468\\).\r\nSimilarly if no digit is exceeded by the digit to its right it is\r\ncalled a decreasing number; for example, \\(66420\\).\r\nWe shall call a positive integer that is neither increasing nor\r\ndecreasing a “bouncy” number; for example, \\(155349\\).\r\nAs \\(n\\) increases, the proportion\r\nof bouncy numbers below n increases such that there are only \\(12951\\) numbers below one-million that are\r\nnot bouncy and only \\(277032\\)\r\nnon-bouncy numbers below \\(10^{10}\\).\r\nHow many numbers below a googol (\\(10^{100}\\)) are not bouncy?\r\n解决方案\r\n所谓的上升数和下降数，下一位的值只能都大于等于上一位或者小于等于上一位。因此可以用动态规划的方法统计\\(n\\)位数的上升数和下降数。\r\n分别设两个状态\\(f(i,d),g(i,d)(1\\le i\\le\r\nn,0\\le d\\le 9)\\)表示\\(i\\)位数中，个位为\\(d\\)的上升数/下降数分别有多少个。\r\n注意到上升数的每一位中，下一位的值只能都大于等于上一位，可以列出\\(f(i,j)\\)的状态转移方程：\r\n\\[\r\nf(i,d)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0  &amp; &amp; \\text{if}\\quad i=1\\land d=0 \\\\\r\n  &amp;1  &amp; &amp; \\text{else if}\\quad i=1 \\\\\r\n  &amp;\\sum_{j=0}^d f(i-1,j) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n类似的，可以列出\\(g(i,j)\\)的状态转移方程：\r\n\\[\r\ng(i,d)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0  &amp; &amp; \\text{if}\\quad i=1\\land d=0 \\\\\r\n  &amp;1  &amp; &amp; \\text{else if}\\quad i=1 \\\\\r\n  &amp;\\sum_{j=d}^9 g(i-1,j) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n注意到，\\(111\\dots111,222\\dots222\\)这种\\(n\\)位都是一样的数都算进了上升数和下降数中，因此最终答案需要减去这两种数多算的一次。\r\n最终答案为：\r\n\\[\\sum_{i=1}^n\\sum_{d=0}^9(f(i,d)+g(i,d)-1)\\]\r\n代码\r\nN = 100f = [1 for _ in range(10)]f[0] = 0g = f.copy()ans = 9for i in range(N - 1):    f = [sum(f[:i + 1]) for i in range(10)]    g = [sum(g[i:]) for i in range(10)]    ans += sum(f) + sum(g) - 9print(ans)\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 116","url":"/project-euler/116/","content":"\r\nProject Euler 116\r\n题目\r\nRed, green or blue tiles\r\nA row of five black square tiles is to have a number of its tiles\r\nreplaced with coloured oblong tiles chosen from red (length two), green\r\n(length three), or blue (length four).\r\nIf red tiles are chosen there are exactly seven ways this can be\r\ndone.\r\n\r\nIf green tiles are chosen there are three ways.\r\n\r\nAnd if blue tiles are chosen there are two ways.\r\n\r\nAssuming that colours cannot be mixed there are \\(7 + 3 + 2 = 12\\) ways of replacing the\r\nblack tiles in a row measuring five units in length.\r\nHow many different ways can the black tiles in a row measuring fifty\r\nunits in length be replaced if colours cannot be mixed and at least one\r\ncoloured tile must be used?\r\nNOTE: This is related to\r\nProblem 117.\r\n解决方案\r\n和第115题不一样，这里铺设的方块，不再考虑相邻的时候的问题。\r\n另外，由于不同颜色不能混合使用，因此使用某种单个彩色（红、绿、蓝）的砖块和黑色的砖块一起铺设是独立的问题，应当分开考虑。把分开考虑的结果相加即可。\r\n假设铺成的长度为\\(n=50\\)。设\\(f_m(i)(0\\leq i\\leq\r\nn)\\)为使用某种长度为\\(m\\)的彩色方块和黑色方块一起铺设成长度为\\(i\\)的方案数量，可以列出\\(f_m(i)\\)的状态转移方程：\r\n\\[\r\nf_m(i)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i&lt;m \\\\\r\n  &amp;f_m(i-m)+f_m(i-1) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n方程的最后一行表示：所有\\(f_m(i-1)\\)的方案后面多拼接一个黑色方块；同理，所有\\(f_m(i-m)\\)的方案后面都添加一个长度为\\(m\\)的彩色方块。\r\n由于题目中规定彩色方块必须使用一次，因此最终答案需要减去全使用黑色方块的方案数。\r\n最终答案为：\r\n\\[\\sum_{k=2}^4(f_k(n)-1)\\]\r\n代码\r\nN = 50M = [2, 3, 4]def fm(m, n):    f = [1] * m    for i in range(m, n+1):        f.append(f[i - 1] + f[i - m])    return f[n] - 1ans = sum(fm(k, N) for k in M)print(ans)\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 115","url":"/project-euler/115/","content":"\r\nProject Euler 115\r\n题目\r\nCounting block combinations\r\nII\r\nNOTE: This is a more difficult version of\r\nProblem 114.\r\nA row measuring \\(n\\) units in\r\nlength has red blocks with a minimum length of \\(m\\) units placed on it, such that any two\r\nred blocks (which are allowed to be different lengths) are separated by\r\nat least one black square.\r\nLet the fill-count function, \\(F(m,\r\nn)\\), represent the number of ways that a row can be filled.\r\nFor example, \\(F(3, 29) = 673135\\)\r\nand \\(F(3, 30) = 1089155\\). That is,\r\nfor \\(m = 3\\), it can be seen that\r\n\\(n = 30\\) is the smallest value for\r\nwhich the fill-count function first exceeds one million.\r\nIn the same way, for \\(m = 10\\), it\r\ncan be verified that \\(F(10, 56) =\r\n880711\\) and \\(F(10, 57) =\r\n1148904\\), so \\(n = 57\\) is the\r\nleast value for which the fill-count function first exceeds one\r\nmillion.\r\nFor \\(m = 50\\), find the least value\r\nof \\(n\\) for which the fill-count\r\nfunction first exceeds one million.\r\n解决方案\r\n使用的方案和第114题完全相同，此处不赘述。\r\n代码\r\nfrom itertools import countQ = 10 ** 6M = 50f = [1]g = [0]s = [1]for i in count(1, 1):    f.append(f[i - 1] + g[i - 1])    g.append(0 if i &lt; M else s[i - M])    s.append(s[i - 1] + f[i])    if f[i] + g[i] &gt; Q:        ans = i        breakprint(ans)\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 114","url":"/project-euler/114/","content":"\r\nProject Euler 114\r\n题目\r\nCounting block combinations\r\nI\r\nA row measuring seven units in length has red blocks with a minimum\r\nlength of three units placed on it, such that any two red blocks (which\r\nare allowed to be different lengths) are separated by at least one grey\r\nsquare. There are exactly seventeen ways of doing this.\r\n\r\nHow many ways can a row measuring fifty units in length be\r\nfilled?\r\nNOTE: Although the example above does not lend itself to the\r\npossibility, in general it is permitted to mix block sizes. For example,\r\non a row measuring eight units in length you could use red (\\(3\\)), black (\\(1\\)), and red (\\(4\\)).\r\n解决方案\r\n本问题的阶段性都很明确，使用动态规划来做。\r\n假设铺成的长度为\\(n\\)，红色方块的长度至少为\\(m(m=3)\\)，那么分别设状态\\(f(i),g(i)(0\\le i\\le n)\\)为长度\\(i\\)的铺设方案中，最后一格为黑色方块/红色方块的铺设方法数量。可以列出\\(f(i)\\)和\\(g(i)\\)的状态转移方程：\r\n\\[\r\nf(i)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i=0 \\\\\r\n  &amp;f(i-1)+g(i-1) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n\\[\r\ng(i)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0  &amp; &amp; \\text{if}\\quad i&lt;m \\\\\r\n  &amp;\\sum_{i=0}^{i-m}f(i) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n黑色方块长度固定为\\(1\\)，放置不受限制，因此直接由两种状态的上一步直接转移。\r\n而红色方块长度至少为\\(m\\)，只能放置在黑色方格之后，因此只能从黑色方格处转移过来。另外，红色方格可以有不同的长度，因此，第\\(i\\)格可以是长度为\\(m,m+1,m+2,\\dots,i-1,i\\)的红色方格末尾。\r\n另外需要注意到两个初值：\\(f(0)=1\\)，但\\(g(0)=0\\)。长度为\\(0\\)的情况下起始就只有\\(1\\)种方案，因此要么\\(f(0)=1,g(0)=0\\)，要么\\(f(0)=0,g(0)=1\\)。选择前者的原因：一开始放的方格不受限制，可以是红色，也可以是黑色，而这是“假定”上一个格子为黑色时的特点。\r\n最终答案为\\(f(n)+g(n)\\)。\r\n代码\r\nN = 50M = 3f = [0 for _ in range(N + 1)]g, s = f.copy(), f.copy()f[0] = s[0] = 1for i in range(1, N + 1):    f[i] = f[i - 1] + g[i - 1]    if i &gt;= M:        g[i] = s[i - M]    s[i] = s[i - 1] + f[i]ans = f[N] + g[N]print(ans)\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 118","url":"/project-euler/118/","content":"\r\nProject Euler 118\r\n题目\r\nPandigital prime sets\r\nUsing all of the digits \\(1\\)\r\nthrough \\(9\\) and concatenating them\r\nfreely to form decimal integers, different sets can be formed.\r\nInterestingly with the set \\(\\{2,5,47,89,631\\}\\), all of the elements\r\nbelonging to it are prime.\r\nHow many distinct sets containing each of the digits one through nine\r\nexactly once contain only prime elements?\r\n解决方案\r\n本题的第一个目标：找出所有数字使用最多一次的质数，并对使用完全相同数位的质数进行统计，统计结果记录在列表\\(cnt\\)中。\r\n在这里，用一个\\(9\\)比特的\\(mask\\)（下标从\\(0\\)开始）来表示数位使用情况，如果数字\\(i\\)被使用了，那么\\(mask\\)的第\\(i-1\\)位为\\(1\\)，否则为\\(0\\)。\r\n一个例子：\\(13\\)和\\(31\\)都是质数，因此\\(mask=2^0+2^2=5，cnt[5]=2\\)。\r\n因此，通过一些枚举技巧，可以将一些不可能是质数的情况排除，从而能够加速快速枚举完质数。\r\n得到了\\(cnt\\)数组后，进行第二步：动态规划。\r\n需要注意到问题所要求的集合是无序的，因此可以使用动态规划来求出满足的集合数很方便。\r\n这里使用的是状态压缩动态规划。设\\(f(i,st)\\)为：使用了\\([0,i]\\)中所有的\\(mask\\)下对应的数后，当前有多少个集合的数位使用情况为\\(st\\)？也就是说，有多少集合，已经使用了\\(1,2,\\dots,9\\)里面的一些数了。如上面提到，\\(st\\)是一个\\(9\\)比特数。\r\n可以列出如下状态转移方程：\r\n\\[\r\nf(i,st)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i=0\\land st=0 \\\\\r\n  &amp;0  &amp; &amp; \\text{else if}\\quad i=0 \\\\\r\n  &amp;f(i-1,st)  &amp; &amp; \\text{else if}\\quad st\\land i\\neq i \\\\\r\n  &amp;f(i-1,st)+f(i-1,st \\oplus i) \\times cnt[i] &amp; &amp;\r\n\\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n其中，运算符\\(\\land ,\r\n\\oplus\\)分别表示位运算中的与运算和异或运算。\r\n方程最后一行表示，如果不取\\(i\\)，那么直接从\\(f(i-1,st)\\)转移过来保存；如果取\\(i\\)，那么就需要将没有用到\\(i\\)的前驱状态再添加一个\\(mask\\)属于\\(i\\)类中的数，而这类数有\\(cnt[i]\\)个。\r\n最终答案为\\(f(2^9-1,2^9-1)\\)。\r\n代码中的实现则为另一种方式，它是以“我为人人”的方式实现的，即将当前状态转移到所有的后继可能的状态，这种写法会比较方便和好想。\r\n代码\r\nfrom itertools import permutations, combinationsfrom tools import is_primea = [1, 2, 3, 4, 5, 6, 7, 8, 9]n = len(a)cnt = [0 for i in range(1 &lt;&lt; n)]cnt[1 &lt;&lt; (2 - 1)] = cnt[1 &lt;&lt; (3 - 1)] = cnt[1 &lt;&lt; (5 - 1)] = 1for r in range(1, n + 1):    for st in combinations(a, r):        if sum(st) % 3 == 0:            continue        mask = 0        for x in st:            mask |= 1 &lt;&lt; (x - 1)        for per in permutations(st):            if (per[-1] &amp; 1) == 0 or per[-1] == 5:                continue            w = int(&quot;&quot;.join(str(x) for x in per))            if is_prime(w):                cnt[mask] += 1f = [0 for i in range(1 &lt;&lt; n)]f[0] = 1for i in range(1 &lt;&lt; n):    if cnt[i] &gt; 0:        for j in range(1 &lt;&lt; n):            if (j &amp; i) == 0:                f[i | j] += f[j] * cnt[i]ans = f[(1 &lt;&lt; n) - 1]print(ans)\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 117","url":"/project-euler/117/","content":"\r\nProject Euler 117\r\n题目\r\nRed, green, and blue tiles\r\nUsing a combination of grey square tiles and oblong tiles chosen\r\nfrom: red tiles (measuring two units), green tiles (measuring three\r\nunits), and blue tiles (measuring four units), it is possible to tile a\r\nrow measuring five units in length in exactly fifteen different\r\nways.\r\n\r\nHow many ways can a row measuring fifty units in length be tiled?\r\nNOTE: This is related to\r\nProblem 116.\r\n解决方案\r\n与第116题不同，这里的砖块是可以随便使用的，没有任何限制。\r\n假设铺成的长度为\\(n=50\\)。设\\(f(i)(0\\leq i\\leq n)\\)为铺设成长度为\\(i\\)的方案数量，那么可以列出以下状态转移方程：\r\n\\[\r\nf(i)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i=0, 1 \\\\\r\n  &amp;2  &amp; &amp; \\text{else if}\\quad i=2\\\\\r\n  &amp;4  &amp; &amp; \\text{else if}\\quad i=3 \\\\\r\n  &amp;f(i-1)+f(i-2)+f(i-3)+f(1-4) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n方程的最后一行表示：所有\\(f(i-1)\\)的方案后面多拼接一个黑色方块；同理，\\(f(i-2),f(i-3),f(i-4)\\)则对应后面接一个红色，绿色，蓝色。\r\n初值\\(f(1),f(2),f(3)\\)的产生：在这些长度下，如果套用第四条式子，会发生\\(f\\)自变量小于\\(0\\)的情况，这里我们就选择忽略掉这些小于\\(0\\)的转移情况。也就是说，当\\(i&lt;0\\)时，可以认为\\(f(i)=0\\)。\r\n代码\r\n本代码适用于填充的方块为任意种类任意长度的情况。\r\nN = 50M = [1, 2, 3, 4]f = [1]for i in range(1, N + 1):    f.append(sum((0 if i &lt; k else f[i - k]) for k in M))ans = f[N]print(ans)\r\n本代码则仅适用于本题。\r\nN = 50f = [1, 1, 2, 4]for i in range(4, N + 1):    f.append(f[-1] + f[-2] + f[-3] + f[-4])ans = f[N]print(ans)\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 119","url":"/project-euler/119/","content":"\r\nProject Euler 119\r\n题目\r\nDigit power sum\r\nThe number \\(512\\) is interesting\r\nbecause it is equal to the sum of its digits raised to some power: \\(5 + 1 + 2 = 8\\), and \\(8^3 = 512\\). Another example of a number\r\nwith this property is \\(614656 =\r\n28^4\\).\r\nWe shall define \\(a_n\\) to be the\r\n\\(n^\\text{th}\\) term of this sequence\r\nand insist that a number must contain at least two digits to have a\r\nsum.\r\nYou are given that \\(a_2 = 512\\) and\r\n\\(a_{10} = 614656\\).\r\nFind \\(a_{30}\\).\r\n解决方案\r\n本题所需要求的数，必定是形如\\(a^b(a,b&gt;1)\\)的数。因此，先枚举\\(a\\)到足够大（本代码设定为\\(5N\\)）时，再枚举\\(b\\)，之后计算\\(a^b\\)的数位和。当数位和远远大于\\(a\\)时（因为这里有\\(0\\)的存在，在计算\\(a^b\\)的数位和时，有可能虽然数\\(a^b\\)很大，但是因为\\(0\\)很多数位和很小），才停止循环。\r\n最终排序，导出结果即可。\r\n代码\r\nfrom itertools import countN = 30ls = []for a in range(2, N * 5 + 1):    for b in count(2, 1):        y = sum(int(w) for w in str(a ** b))        if y == 1 or y &gt; 10 * a:            break        if y == a:            ls.append(a ** b)ls.sort()ans = ls[N - 1]print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 120","url":"/project-euler/120/","content":"\r\nProject Euler 120\r\n题目\r\nSquare remainders\r\nLet \\(r\\) be the remainder when\r\n\\((a-1)^n + (a+1)^n\\) is divided by\r\n\\(a^2\\).\r\nFor example, if \\(a = 7\\) and \\(n = 3\\), then \\(r\r\n= 42: 6^3 + 8^3 = 728 \\equiv 42 \\bmod 49\\). And as \\(n\\) varies, so too will \\(r\\), but for \\(a\r\n= 7\\) it turns out that \\(r_{\\max} =\r\n42\\).\r\nFor \\(3 \\le a \\le 1000\\), find \\(\\sum r_{\\max}\\).\r\n二项式定理\r\n二项式定理，即\\(n\\)次方二项式\\((a+b)^n\\)的展开式：\r\n\\[(a+b)^n=\\sum_{i=0}^n\\dbinom{n}{i}a^ib^{n-i}\\]\r\n解决方案\r\n设\\(r(a,n)=((a-1)^n+(a+1)^n) \\%\r\na^2\\)。\r\n根据二项式定理，对\\(a^2\\)取模后，二项式展开式中\\(a\\)的次数为\\(2\\)及以上的项不考虑，只考虑\\(a\\)的次数为\\(0\\)或\\(1\\)的项。\r\n因此，满足下式：\r\n\\(r(a,n) \\equiv\r\n\\dbinom{n}{1}a\\cdot(-1)^{n-1}+\\dbinom{n}{0}(-1)^n+\\dbinom{n}{1}a\\cdot\r\n1^{n-1}+\\dbinom{n}{0}1^n\\equiv\r\nan+1+an\\cdot(n-1)^n+(-1)^n\\pmod{a^2}\\)\r\n可以写成：\r\n\\[\r\nr(a,n)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;2  &amp; &amp; \\text{if}\\quad n \\equiv 0 \\pmod 2 \\\\\r\n  &amp;2an \\%a^2 &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n为使得\\(r(a,n)\\)最大，故不考虑\\(n\\)为偶数的情况。那么此时可以写成\\(r(a,n)=a\\cdot (2n \\% a)\\)。\r\n值\\(2n\\%a\\)需要尽可能接近\\(a\\)。由于\\(2n\\)为偶数，因此当\\(a\\)为偶数时，\\(\\gcd(a,2)=2\\)，因此\\(2n\\%a\\)最大能只能取到\\(2\\)的倍数\\(a-2\\)，而当\\(a\\)为奇数时，\\(\\gcd(a,2)=1\\)，\\(2n\\%a\\)最大可以取到\\(1\\)的倍数\\(a-1\\)。\r\n因此有：\r\n\\[\r\nr_{\\max}(a)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;a(a-2)  &amp; &amp; \\text{if}\\quad a \\equiv 0 \\pmod 2 \\\\\r\n  &amp;a(a-1) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n代码\r\nN = 1000ans = 0for a in range(3, N + 1):    if a &amp; 1:        ans += a * (a - 1)    else:        ans += a * (a - 2)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 12","url":"/project-euler/12/","content":"\r\nProject Euler 12\r\n题目\r\nHighly divisible triangular\r\nnumber\r\nThe sequence of triangle numbers is generated by adding the natural\r\nnumbers. So the \\(7^{\\text{th}}\\)\r\ntriangle number would be \\(1 + 2 + 3 + 4 + 5 +\r\n6 + 7 = 28\\). The first ten terms would be: \\[1, 3, 6, 10, 15, 21, 28, 36, 45, 55,\r\n\\dots\\] Let us list the factors of the first seven triangle\r\nnumbers:\r\n\\(\\begin{aligned}\r\n\\mathbf{1}: &amp; 1\\\\\r\n\\mathbf{3}: &amp; 1,3 \\\\\r\n\\mathbf{6}: &amp; 1,2,3,6\\\\\r\n\\mathbf{10}: &amp; 1,2,5,10\\\\\r\n\\mathbf{15}: &amp; 1,3,5,15\\\\\r\n\\mathbf{21}: &amp; 1,3,7,21\\\\\r\n\\mathbf{28}: &amp; 1,2,4,7,14,28\r\n\\end{aligned}\\)\r\nWe can see that \\(28\\) is the first\r\ntriangle number to have over five divisors. What is the value of the\r\nfirst triangle number to have over five hundred divisors?\r\n因数个数定理\r\n如果一个正整数\\(n\\)分解后成为：\r\n\\[n=\\prod_{i=1}^k p_i^{e_i}\\]\r\n那么\\(n\\)的因数个数为： \\[\\prod_{i=1}^k (e_i+1)\\]\r\n解决方案\r\n直接遍历所有的三角形数，用工具分解后，直接通过因数个数定理判断其因数个数是否超过\\(500\\).\r\n代码\r\nfrom tools import factorizationfrom itertools import countQ = 500for i in count(1, 1):    x = i * (i + 1) // 2    res = factorization(x)    m = 1    for p, e in res:        m *= e + 1    if m &gt;= Q:        ans = x        breakprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 121","url":"/project-euler/121/","content":"\r\nProject Euler 121\r\n题目\r\nDisc game prize fund\r\nA bag contains one red disc and one blue disc. In a game of chance a\r\nplayer takes a disc at random and its colour is noted. After each turn\r\nthe disc is returned to the bag, an extra red disc is added, and another\r\ndisc is taken at random.\r\nThe player pays \\(£1\\) to play and\r\nwins if they have taken more blue discs than red discs at the end of the\r\ngame.\r\nIf the game is played for four turns, the probability of a player\r\nwinning is exactly \\(\\dfrac{11}{120}\\),\r\nand so the maximum prize fund the banker should allocate for winning in\r\nthis game would be \\(£10\\) before they\r\nwould expect to incur a loss. Note that any payout will be a whole\r\nnumber of pounds and also includes the original \\(£1\\) paid to play the game, so in the\r\nexample given the player actually wins \\(£9\\).\r\nFind the maximum prize fund that should be allocated to a single game\r\nin which fifteen turns are played.\r\n解决方案\r\n第一个问题：赢的概率有多大。\r\n本题状态转移比较明显，可以使用基于概率的动态规划解决问题。\r\n令游戏轮数\\(n=15\\)，那么设状态\\(f(i,j)(0\\le j\\le i\\le n)\\)为：完成了\\(i\\)轮的游戏后，得到\\(j\\)个蓝色碟子的概率。可以列出以下状态转移方程：\r\n\\[\r\nf(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i=0\\land j=0 \\\\\r\n  &amp;f(i-1,j) \\cdot \\dfrac{i}{i+1}  &amp; &amp; \\text{else if}\\quad\r\nj=0\\\\\r\n  &amp;f(i-1,j-1) \\cdot \\dfrac{1}{i+1}  &amp; &amp; \\text{else if}\\quad\r\nj=i\\\\\r\n  &amp;f(i-1,j) \\cdot \\dfrac{i}{i+1} + f(i-1,j-1) \\cdot \\dfrac{1}{i+1}\r\n&amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n对于最后一行，要么从上一轮的状态\\(f(i-1,j)\\)以\\(\\dfrac{i}{i+1}\\)抽到一个红色碟子转移而来，或者是从\\(f(i-1,j-1)\\)以\\(\\dfrac{1}{i+1}\\)的概率抽到一个蓝色碟子。\r\n因此，胜利的情况概率为\\(\\sum_{i=\\left\\lfloor\\frac{n}{2}+1\\right\\rfloor}^n\r\nf(n,i)\\).\r\n第二个问题：为防止游戏亏损，至多设立的钱数是多少。\r\n假设\\(X\\)为玩家进行一次游戏所获得的钱数的随机变量，那么\\(X\\)满足以下两点分布：\r\n\r\n\r\n\r\n\\(X\\)\r\n\\(P(X)\\)\r\n\r\n\r\n\r\n\r\n\\(x-1\\)\r\n\\(\\sum_{i=\\left\\lfloor\\frac{n}{2}+1\\right\\rfloor}^n\r\nf(n,i)\\)\r\n\r\n\r\n\\(-1\\)\r\n\\(1-\\sum_{i=\\left\\lfloor\\frac{n}{2}+1\\right\\rfloor}^n\r\nf(n,i)\\)\r\n\r\n\r\n\r\n为了防止游戏亏损，那么\\(X\\)的数学期望\\(E[X]\\)必须满足\\(E[X]&lt;0\\)。\r\n由于\\(x\\)必须是整数，因此可以解得最高奖金数\\(x=\\left\\lfloor\\dfrac{1}{\\sum_{i=\\left\\lfloor\\frac{n}{2}+1\\right\\rfloor}^n\r\nf(n,i)}\\right\\rfloor\\)\r\n代码\r\nN = 15f = [[1]]for i in range(1, N + 1):    ls = [0 for j in range(i + 1)]    f.append(ls)    for j in range(i + 1):        if j &gt; 0:            f[i][j] += f[i - 1][j - 1] * 1 / (i + 1)        if j &lt; i:            f[i][j] += f[i - 1][j] * i / (i + 1)ans = 0for j in range(N + 1):    if j &gt; N - j:        ans += f[N][j]ans = int(1 / ans)print(ans)\r\n","categories":["Project Euler"],"tags":["动态规划","概率"]},{"title":"Project Euler 122","url":"/project-euler/122/","content":"\r\nProject Euler 122\r\n题目\r\nEfficient exponentiation\r\nThe most naive way of computing \\(n^{15}\\) requires fourteen\r\nmultiplications:\r\n\\(n \\times n \\times \\dots \\times n =\r\nn^{15}\\)\r\nBut using a “binary” method you can compute it in six\r\nmultiplications:\r\n\\(\\begin{aligned}\r\nn \\times n &amp;= n^2\\\\\r\nn^2 \\times n^2 &amp;= n^4\\\\\r\nn^4 \\times n^4 &amp;= n^8\\\\\r\nn^8 \\times n^4 &amp;= n^{12}\\\\\r\nn^{12} \\times n^2 &amp;= n^{14}\\\\\r\nn^{14} \\times n &amp;= n^{15}\r\n\\end{aligned}\\)\r\nHowever it is yet possible to compute it in only five\r\nmultiplications:\r\n\\(\\begin{aligned}\r\nn \\times n &amp;= n^2\\\\\r\nn^2 \\times n &amp;= n^3\\\\\r\nn^3 \\times n^3 &amp;= n^6\\\\\r\nn^6 \\times n^6 &amp;= n^{12}\\\\\r\nn^{12} \\times n^3 &amp;= n^{15}\r\n\\end{aligned}\\)\r\nWe shall define \\(m(k)\\) to be the\r\nminimum number of multiplications to compute \\(n^k\\); for example \\(m(15) = 5\\).\r\nFor \\(1 \\le k \\le 200\\), find \\(\\sum m(k)\\).\r\n解决方案\r\n本题基于深度优先搜索的剪枝。\r\n为了尽快使结果收敛，可以为每个数的答案先拟定一个上限，而这个上限就是但使用题目所提供的“二进制”的算法（也就是快速幂）。\r\n求出前几项后，在OEIS找到了该数列A003313。在FORMULA一栏中，找到了以下信息:\r\nFor all n &gt;= 2, a(n) &lt;= (4/3)*floor(log_2 n) + 2. - Jonathan Vos Post, Oct 08 2008From Achim Flammenkamp, Oct 26 2016: (Start)a(n) &lt;= 9/log_2(71) log_2(n), for all n.It is conjectured by D. E. Knuth, K. Stolarsky et al. that for all n: floor(log_2(n)) + ceiling(log_2(v(n))) &lt;= a(n). (End)\r\n这说明，值的上限还可以用这两条不等式继续压缩。\r\n在进行搜索的时候，把整个加法链路径进行保存，然后将路径中的每一个值都和当前节点值相加，判断是否可以是后继。如果可以，则继续搜索。\r\n需要注意的是，在这里的搜索，要求的是小于等于，而非是平常写的小于。这是因为，路径上的其他值也会对下一次产生的节点造成影响。\r\n本题的相关维基百科页面：加法链\r\n代码\r\nfrom math import log2N = 200log2_71 = log2(71)f = [len(bin(k)) - 2 + bin(k).count(&#x27;1&#x27;) - 2 for k in range(N + 1)]for i in range(2, N + 1):    f[i] = min(f[i], int(4 * (len(bin(i)) - 3) / 3) + 2, int(9 / log2_71 * log2(i)))a = [0 for _ in range(N + 1)]def dfs(d):    k = a[d]    for i in range(d + 1):        w = k + a[i]        if w &lt;= N:            if d + 1 &lt;= f[w]:                a[d + 1] = w                f[w] = d + 1                dfs(d + 1)        else:            breaka[0] = 1dfs(0)ans = sum(f[1:])print(ans)\r\n","categories":["Project Euler"],"tags":["OEIS"]},{"title":"Project Euler 124","url":"/project-euler/124/","content":"\r\nProject Euler 124\r\n题目\r\nOrdered radicals\r\nThe radical of \\(n\\), \\(\\text{rad}(n)\\), is the product of the\r\ndistinct prime factors of \\(n\\). For\r\nexample, \\(504 = 2^3 × 3^2 × 7\\), so\r\n\\(\\text{rad}(504) = 2 × 3 × 7 =\r\n42\\).\r\nIf we calculate \\(\\text{rad}(n)\\)\r\nfor \\(1 \\le n \\le 10\\), then sort them\r\non \\(\\text{rad}(n)\\), and sorting on\r\n\\(n\\) if the radical values are equal,\r\nwe get:\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nUnsorted\r\n\r\n\r\nSorted\r\n\r\n\r\n\r\n\r\n\r\n\\(\\mathbf{n}\\)\r\n\\(\\mathbf{rad}(n)\\)\r\n\r\n\\(\\mathbf{n}\\)\r\n\\(\\mathbf{rad}(n)\\)\r\n\\(\\mathbf{k}\\)\r\n\r\n\r\n\\(1\\)\r\n\\(1\\)\r\n\r\n\\(1\\)\r\n\\(1\\)\r\n\\(1\\)\r\n\r\n\r\n\\(2\\)\r\n\\(2\\)\r\n\r\n\\(2\\)\r\n\\(2\\)\r\n\\(2\\)\r\n\r\n\r\n\\(3\\)\r\n\\(3\\)\r\n\r\n\\(4\\)\r\n\\(2\\)\r\n\\(3\\)\r\n\r\n\r\n\\(4\\)\r\n\\(2\\)\r\n\r\n\\(8\\)\r\n\\(2\\)\r\n\\(4\\)\r\n\r\n\r\n\\(5\\)\r\n\\(5\\)\r\n\r\n\\(3\\)\r\n\\(3\\)\r\n\\(5\\)\r\n\r\n\r\n\\(6\\)\r\n\\(6\\)\r\n\r\n\\(9\\)\r\n\\(3\\)\r\n\\(6\\)\r\n\r\n\r\n\\(7\\)\r\n\\(7\\)\r\n\r\n\\(5\\)\r\n\\(5\\)\r\n\\(7\\)\r\n\r\n\r\n\\(8\\)\r\n\\(2\\)\r\n\r\n\\(6\\)\r\n\\(6\\)\r\n\\(8\\)\r\n\r\n\r\n\\(9\\)\r\n\\(3\\)\r\n\r\n\\(7\\)\r\n\\(7\\)\r\n\\(9\\)\r\n\r\n\r\n\\(10\\)\r\n\\(10\\)\r\n\r\n\\(10\\)\r\n\\(10\\)\r\n\\(10\\)\r\n\r\n\r\n\r\nLet \\(E(k)\\) be the \\(k\\text{th}\\) element in the sorted n\r\ncolumn; for example, \\(E(4) = 8\\) and\r\n\\(E(6) = 9\\).\r\nIf \\(\\text{rad}(n)\\) is sorted for\r\n\\(1 \\le n \\le 100000\\), find \\(E(10000)\\).\r\n解决方案\r\n使用埃氏筛，可以标记出所有质数，并对质数的倍数进行标记。而在标记的过程中，则将对应的\\(\\text{rad}\\)函数值数组乘上这个质数。整个埃氏筛结束后，\\(\\text{rad}\\)数组里面的所有函数值就计算可以完成。\r\n同样，线性筛也可以完成这个工作。\r\n排序后即可得到答案。\r\n代码\r\nN = 10 ** 5Q = 10 ** 4rad = [1 for _ in range(N + 1)]rank = [i for i in range(1, N + 1)]for i in range(2, N + 1):    if rad[i] == 1:        for j in range(i, N + 1, i):            rad[j] *= irank.sort(key=lambda x: (rad[x], x))ans = rank[Q - 1]print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 125","url":"/project-euler/125/","content":"\r\nProject Euler 125\r\n题目\r\nPalindromic sums\r\nThe palindromic number \\(595\\) is\r\ninteresting because it can be written as the sum of consecutive squares:\r\n\\(6^2 + 7^2 + 8^2 + 9^2 + 10^2 + 11^2 +\r\n12^2\\).\r\nThere are exactly eleven palindromes below one-thousand that can be\r\nwritten as consecutive square sums, and the sum of these palindromes is\r\n\\(4164\\). Note that \\(1 = 0^2 + 1^2\\) has not been included as\r\nthis problem is concerned with the squares of positive integers.\r\nFind the sum of all the numbers less than \\(10^8\\) that are both palindromic and can be\r\nwritten as the sum of consecutive squares.\r\n解决方案\r\n先找出所有小于\\(N\\)的平方数，然后再找出一段段小于\\(N\\)的连续平方数之和。\r\n由于每次枚举右端点时，连续平方数之和的是以立方级别增长。因此枚举一次左端点时，很快就结束了。\r\n最终则把所有的回文连续平方数和插入集合中记录。\r\n代码\r\nfrom tools import int_sqrtN = 10 ** 8a = [i * i for i in range(1, int_sqrt(N) + 1)]st = set()for i in range(len(a)):    if i + 1 &lt; len(a) and a[i] + a[i + 1] &gt;= N:        break    s = a[i]    for j in range(i + 1, len(a)):        s += a[j]        if s &gt;= N:            break        t = str(s)        if t == t[::-1]:            st.add(s)ans = sum(st)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 127","url":"/project-euler/127/","content":"\r\nProject Euler 127\r\n题目\r\nabc-hits\r\nThe radical of \\(n\\), \\(\\text{rad}(n)\\), is the product of the\r\ndistinct prime factors of \\(n\\). For\r\nexample, \\(504 = 2^3 × 3^2 × 7\\), so\r\n\\(\\text{rad}(504) = 2 × 3 × 7 =\r\n42\\).\r\nWe shall define the triplet of positive integers \\((a, b, c)\\) to be an \\(abc\\)-hit if:\r\n\r\n\\(\\gcd(a, b) = \\gcd(a, c) = \\gcd(b, c) =\r\n1\\)\r\n\\(a &lt; b\\)\r\n\\(a + b = c\\)\r\n$(abc) &lt; c $;\r\n\r\nFor example, \\((5, 27, 32)\\) is an\r\nabc-hit, because:\r\n\r\n\\(\\gcd(5, 27) = \\gcd(5, 32) = \\gcd(27, 32)\r\n= 1\\)\r\n\\(5 &lt; 27\\)\r\n\\(5 + 27 = 32\\)\r\n\\(\\text{rad}(4320) = 30 &lt;\r\n32\\)\r\n\r\nIt turns out that abc-hits are quite rare and there are only\r\nthirty-one abc-hits for \\(c &lt;\r\n1000\\), with \\(\\sum c =\r\n12523\\).\r\nFind \\(\\sum c\\) for \\(c &lt; 120000\\).\r\n解决方案\r\n按照第124题的方式计算出所有\\(\\text{rad}\\)的值。\r\n由于第三条\\(a+b=c\\)，因此判断\\(a,b,c\\)的两两互质性，只需要判断其中的某一对。因为由求其中一对的最大公因数时，可以通过辗转相除法，转成另外两对。\r\n根据\\(\\text{rad}(n)\\)的定义，是由\\(n\\)的不同的质因数相乘得出的值。那么由于\\(a,b,c\\)两两互质，它们之间没有相同的质因数，因此\\(\\text{rad}(abc)=\\text{rad}(a)\\cdot\r\n\\text{rad}(b)\\cdot \\text{rad}(c)\\)。\r\n这给我们提供了一个思路，首先将\\(1\\sim\r\nN\\)中的所有值按照函数值\\(\\text{rad}\\)从小到大排序。先从小到大枚举\\(c\\)的值，然后再按照\\(\\text{rad}\\)的大小从小到大枚举\\(a\\)的值。当\\(\\text{rad}(a)\\cdot \\text{rad}(c)\\ge\r\nc\\)时，就可以停止枚举\\(a\\)了。剩下的就是判断其它答案是否符合条件。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=120000-1;int rad[N+4],rk[N+4];int main()&#123;    for(int i=1;i&lt;=N;i++)        rk[i]=i,rad[i]=1;    for(int i=2;i&lt;=N;i++)&#123;        if(rad[i]==1)&#123;            for(int j=i;j&lt;=N;j+=i)                rad[j]*=i;        &#125;    &#125;    sort(rk+1,rk+N+1,[&amp;](int &amp;x,int &amp;y)&#123;         return rad[x]&lt;rad[y]||rad[x]==rad[y]&amp;&amp;x&lt;y;         &#125;);    ll ans=0;    for(int c=1;c&lt;=N;c++)&#123;        for(int i=1;i&lt;=N;i++)&#123;            int a=rk[i];            if(rad[a]*rad[c]&gt;=c)                break;            if(__gcd(a,c)!=1) continue;            int b=c-a;            if(a&lt;b &amp;&amp; 1ll*rad[a]*rad[b]*rad[c]&lt;c)                ans+=c;        &#125;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 126","url":"/project-euler/126/","content":"\r\nProject Euler 126\r\n题目\r\nCuboid layers\r\nThe minimum number of cubes to cover every visible face on a cuboid\r\nmeasuring $ 3$ is twenty-two.\r\n\r\nIf we then add a second layer to this solid it would require\r\nforty-six cubes to cover every visible face, the third layer would\r\nrequire seventy-eight cubes, and the fourth layer would require\r\none-hundred and eighteen cubes to cover every visible face.\r\nHowever, the first layer on a cuboid measuring \\(5\\times1\\times1\\) also requires twenty-two\r\ncubes; similarly the first layer on cuboids measuring \\(5\\times3\\times1\\), \\(7\\times2\\times1\\), and \\(11\\times1\\times1\\) all contain forty-six\r\ncubes.\r\nWe shall define \\(C(n)\\) to\r\nrepresent the number of cuboids that contain \\(n\\) cubes in one of its layers. So \\(C(22) = 2\\), \\(C(46) = 4\\), \\(C(78) = 5\\), and \\(C(118) = 8\\).\r\nIt turns out that \\(154\\) is the\r\nleast value of \\(n\\) for which \\(C(n) = 10\\).\r\nFind the least value of \\(n\\) for\r\nwhich \\(C(n) = 1000\\).\r\n解决方案\r\n笔者空间想象能力不太行，因此在这里使用基于广度优先搜索的方式，首先求出每一层所需要的正方体块数。\r\n# include &lt;bits/stdc++.h&gt;using namespace std;const int X=3,Y=2,Z=1,Q=5;int d[X*3+Q*3+1][Y*3+Q*3+1][Z*3+Q*3+1];struct P&#123;    int x,y,z;&#125;;int dx[6]=&#123;-1,1,0,0,0,0&#125;,dy[6]=&#123;0,0,-1,1,0,0&#125;,dz[6]=&#123;0,0,0,0,-1,1&#125;;int main()&#123;    memset(d,-1,sizeof(d));    queue&lt;P&gt;q;    for(int i=Q+1;i&lt;=Q+X;i++)        for(int j=Q+1;j&lt;=Q+Y;j++)            for(int k=Q+1;k&lt;=Q+Z;k++)&#123;                q.push(P&#123;i,j,k&#125;);                d[i][j][k]=0;            &#125;    map&lt;int,int&gt;mp;    while(!q.empty())&#123;        P p=q.front();q.pop();        if(d[p.x][p.y][p.z]==Q) break;        for(int i=0;i&lt;6;i++)&#123;            int x=p.x+dx[i],y=p.y+dy[i],z=p.z+dz[i];            if(d[x][y][z]!=-1) continue;            d[x][y][z]=d[p.x][p.y][p.z]+1;            q.push(P&#123;x,y,z&#125;);            ++mp[d[x][y][z]];        &#125;    &#125;    for(auto &amp;[k,v]:mp)        printf(&quot;%d %d\\n&quot;,k,v);&#125;\r\n假设函数\\(f(x,y,z,n)\\)是包裹\\(x\\times y\\times z\\)长方体的第\\(n\\)层所需要的方块。\r\n通过对上面的代码调整参数\\(X,Y,Z,Q\\)，可以发现以下事实：\r\n\r\n\\(f(x,y,z,1)=xy+yz+xz\\)，也就是长方体原本的表面积。\r\n对\\(f(x,y,z,n)\\)的参数\\(n\\)相邻两项作差，发现：数列\\(\\{f(x,y,z,n+1)-f(x,y,z,n)\\}\\)是一个等差数列，其公差为\\(8\\)，首项为\\(4(x+y+z)\\)。\r\n\r\n由第以上事实可以得到\\(f(x,y,z,n)\\)基于参数\\(n\\)的递推式：\r\n\\[\r\nf(x,y,z,n)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;xy+yz+xz  &amp; &amp; \\text{if}\\quad n=1 \\\\\r\n  &amp;f(x,y,z,n-1)+8(n-2)+4(x+y+z)&amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n可以发现，上面的递推式中，\\(n\\)最高次数只有一次。因此可以将递推式直接转化为通项公式：\r\n\\[\r\nf(x,y,z,n)=2(xy + yz + xz) + 4(x + y + z + n - 2)(n - 1)\r\n\\]\r\n剩下的工作，只需要枚举这\\(4\\)个参数即可。\r\n不过，由于这里是反过来求的：求一个最小\\(m\\)满足\\(f(x,y,z,n)=m,x\\le y\\le z\\)的不同四元组\\((x,y,z,n)\\)个数为\\(1000\\)。因此，\\(m\\)的上限难以确定，在这里拟定\\(m\\)的上限为\\(1000\\times 20\\)。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;const int N=1000;const int M=N*20;int c[M+4];int f(int x,int y,int z,int n)&#123;    return 2*(x*y+y*z+z*x)+4*(x+y+z+n-2)*(n-1);&#125;int main()&#123;    for(int x=1;f(x,x,x,1)&lt;=M;x++)        for(int y=x;f(x,y,y,1)&lt;=M;y++)            for(int z=y;f(x,y,z,1)&lt;=M;z++)                for(int n=1;f(x,y,z,n)&lt;=M;n++)                    ++c[f(x,y,z,n)];    int ans=0;    for(int i=1;i&lt;=M;i++)        if(c[i]==N)&#123;            ans=i;            break;        &#125;    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 123","url":"/project-euler/123/","content":"\r\nProject Euler 123\r\n题目\r\nPrime square remainders\r\nLet \\(p_n\\) be the \\(n^{\\text{th}}\\) prime: \\(2, 3, 5, 7, 11, \\dots\\), and let \\(r\\) be the remainder when \\((p_n-1)^n + (p_n+1)^n\\) is divided by \\(p_n^2\\).\r\nFor example, when \\(n = 3, p_3 =\r\n5\\), and \\(4^3 + 6^3 = 280 \\equiv 5\r\n\\bmod 25\\).\r\nThe least value of \\(n\\) for which\r\nthe remainder first exceeds \\(10^9\\) is\r\n\\(7037\\).\r\nFind the least value of \\(n\\) for\r\nwhich the remainder first exceeds \\(10^{10}\\).\r\n解决方案\r\n设\\(r(n)=((p_n-1)^n + (p_n+1)^n) \\%\r\np_n^2\\)\r\n利用在第120题推导出的一部分结论，可以发现：\r\n\\[\r\nr(n)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;2  &amp; &amp; \\text{if}\\quad n \\equiv 0\\pmod 2 \\\\\r\n  &amp;2np_n \\%p_n^2 &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n因此，直接从第\\(1\\)个质数开始进行枚举即可，容易发现这种\\(\\sqrt{10^{10}}\\)级别的枚举将会很快找到答案。\r\n代码\r\nfrom itertools import countfrom sympy import nextprimeM = 10 ** 10pr = 2for i in count(1, 2):    w = 2 * i * pr % (pr * pr)    if w &gt;= M:        ans = i        break    pr = nextprime(pr, 2)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 128","url":"/project-euler/128/","content":"\r\nProject Euler 128\r\n题目\r\nHexagonal tile differences\r\nA hexagonal tile with number \\(1\\)\r\nis surrounded by a ring of six hexagonal tiles, starting at “\\(12\\) o’clock” and numbering the tiles \\(2\\) to \\(7\\) in an anti-clockwise direction.\r\nNew rings are added in the same fashion, with the next rings being\r\nnumbered \\(8\\) to \\(19\\), \\(20\\) to \\(37\\), \\(38\\) to \\(61\\), and so on. The diagram below shows\r\nthe first three rings.\r\n\r\nBy finding the difference between tile \\(n\\) and each of its six neighbours we shall\r\ndefine \\(PD(n)\\) to be the number of\r\nthose differences which are prime.\r\nFor example, working clockwise around tile \\(8\\) the differences are \\(12, 29, 11, 6, 1\\), and \\(13\\). So \\(PD(8)\r\n= 3\\).\r\nIn the same way, the differences around tile \\(17\\) are \\(1, 17,\r\n16, 1, 11\\), and \\(10\\), hence\r\n\\(PD(17) = 2\\).\r\nIt can be shown that the maximum value of \\(PD(n)\\) is \\(3\\).\r\nIf all of the tiles for which \\(PD(n) =\r\n3\\) are listed in ascending order to form a sequence, the \\(10\\text{th}\\) tile would be \\(271\\).\r\nFind the \\(2000\\text{th}\\) tile in\r\nthis sequence.\r\n解决方案\r\n首先需要通过一些证明，跳过完全不需要检查的数。\r\n我们在这里先将每个六边形圈里面的数分成以下几类：\r\n\r\n圈的起点（\\(12\\)点方向），如\\(2,8,20\\)等\r\n圈的终点，如\\(7,9,37\\)等\r\n圈的边节点（不包括终点），如\\(9,11,13,15,17,33,34\\)等\r\n圈的\\(4,8\\)点方向的两个角节点，如\\(6,16,32,4,12,26\\)等。\r\n圈的\\(2,6,10\\)点方向的三个角节点，如\\(7,18,35,5,14,29,3,10,23\\)等。\r\n\r\n可以发现，随着圈数的上升，起点数和终点数以及角节点是线性增长的，而圈的边节点是平方增长的。\r\n说明圈第三类节点不可能是我们需要的（以\\(13\\)为例）：这些边节点和内圈相邻\\(2\\)个节点（\\(4,5\\)），外圈相邻\\(2\\)个节点（\\(27,28\\)），前后相接一个节点（\\(12,14\\)）。前后相接的节点差值为\\(1\\)，不是质数；和内圈相邻的两个节点，它们也是相邻的，故肯定存在一个节点和本节点同奇偶；外圈同理。因此，第三类节点至少有\\(4\\)个相邻差不是质数，故排除。\r\n说明第四类节点不可能是我们需要的（以\\(16\\)为例）：这些角节点和内圈相邻\\(1\\)个节点（\\(6\\)），外圈相邻\\(3\\)个节点（\\(31,32,33\\)），前后相接一个节点（\\(15,17\\)）。前后相接的节点差值为\\(1\\)，不是质数；从内向外（除了\\(1\\)），这两个方向的节点，从内向外把数列出来，都是偶数。因此，它和相邻的两个同方向角节点(\\(6,32\\))是同奇偶的。因此，第五类节点至少有\\(4\\)个相邻差不是质数，故排除。\r\n说明第五类节点不可能是我们需要的（以\\(18\\)为例）：这些角节点和内圈相邻\\(1\\)个节点（\\(7\\)），外圈相邻\\(3\\)个节点（\\(34,35,36\\)），前后相接一个节点（\\(17,19\\)）。前后相接的节点差值为\\(1\\)，不是质数；从内向外（除了\\(1\\)），这两个方向的节点，从内向外把数列出来，都是奇偶相间的。因此，它和外圈的另外两个边节点(\\(34,36\\))一定是同奇偶的。因此，第五类节点至少有\\(4\\)个相邻差不是质数，故排除。\r\n因此，只需要枚举每个圈的起点和终点即可。\r\n枚举起点时需要注意的地方：不需要枚举\\(8\\)点钟方向的节点（差值肯定为\\(1\\)），以及\\(6,12\\)点钟方向的数（差值肯定是\\(6\\)的倍数）。\r\n枚举终点时需要注意的地方：不需要枚举\\(4\\)点钟方向的节点（差值肯定为\\(1\\)），以及\\(6,12\\)点钟方向的数（差值肯定是\\(6\\)的倍数）\r\n代码\r\nfrom itertools import countfrom tools import is_primeQ = 2000ls = [1, 2]for n in count(2, 1):    # 起点    a = 6 * n + 1  # 10    b = 12 * n + 5  # 2    c = 6 * n - 1  # 4    st = 3 * n * n - 3 * n + 2    if is_prime(a) and is_prime(b) and is_prime(c):        ls.append(st)    # 终点    a = 6 * n - 1  # 10    b = 12 * n - 7  # 8    c = 6 * n + 5  # 2    ed = 3 * n * n + 3 * n + 1    if is_prime(a) and is_prime(b) and is_prime(c):        ls.append(ed)    if len(ls) &gt;= Q:        breakans = ls[Q - 1]print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 13","url":"/project-euler/13/","content":"\r\nProject Euler 13\r\n题目\r\nLarge sum\r\nWork out the first ten digits of the sum of the following one-hundred\r\n\\(50\\)-digit numbers.\r\n\r\n37107287533902102798797998220837590246510135740250\r\n46376937677490009712648124896970078050417018260538\r\n74324986199524741059474233309513058123726617309629\r\n91942213363574161572522430563301811072406154908250\r\n23067588207539346171171980310421047513778063246676\r\n89261670696623633820136378418383684178734361726757\r\n28112879812849979408065481931592621691275889832738\r\n44274228917432520321923589422876796487670272189318\r\n47451445736001306439091167216856844588711603153276\r\n70386486105843025439939619828917593665686757934951\r\n62176457141856560629502157223196586755079324193331\r\n64906352462741904929101432445813822663347944758178\r\n92575867718337217661963751590579239728245598838407\r\n58203565325359399008402633568948830189458628227828\r\n80181199384826282014278194139940567587151170094390\r\n35398664372827112653829987240784473053190104293586\r\n86515506006295864861532075273371959191420517255829\r\n71693888707715466499115593487603532921714970056938\r\n54370070576826684624621495650076471787294438377604\r\n53282654108756828443191190634694037855217779295145\r\n36123272525000296071075082563815656710885258350721\r\n45876576172410976447339110607218265236877223636045\r\n17423706905851860660448207621209813287860733969412\r\n81142660418086830619328460811191061556940512689692\r\n51934325451728388641918047049293215058642563049483\r\n62467221648435076201727918039944693004732956340691\r\n15732444386908125794514089057706229429197107928209\r\n55037687525678773091862540744969844508330393682126\r\n18336384825330154686196124348767681297534375946515\r\n80386287592878490201521685554828717201219257766954\r\n78182833757993103614740356856449095527097864797581\r\n16726320100436897842553539920931837441497806860984\r\n48403098129077791799088218795327364475675590848030\r\n87086987551392711854517078544161852424320693150332\r\n59959406895756536782107074926966537676326235447210\r\n69793950679652694742597709739166693763042633987085\r\n41052684708299085211399427365734116182760315001271\r\n65378607361501080857009149939512557028198746004375\r\n35829035317434717326932123578154982629742552737307\r\n94953759765105305946966067683156574377167401875275\r\n88902802571733229619176668713819931811048770190271\r\n25267680276078003013678680992525463401061632866526\r\n36270218540497705585629946580636237993140746255962\r\n24074486908231174977792365466257246923322810917141\r\n91430288197103288597806669760892938638285025333403\r\n34413065578016127815921815005561868836468420090470\r\n23053081172816430487623791969842487255036638784583\r\n11487696932154902810424020138335124462181441773470\r\n63783299490636259666498587618221225225512486764533\r\n67720186971698544312419572409913959008952310058822\r\n95548255300263520781532296796249481641953868218774\r\n76085327132285723110424803456124867697064507995236\r\n37774242535411291684276865538926205024910326572967\r\n23701913275725675285653248258265463092207058596522\r\n29798860272258331913126375147341994889534765745501\r\n18495701454879288984856827726077713721403798879715\r\n38298203783031473527721580348144513491373226651381\r\n34829543829199918180278916522431027392251122869539\r\n40957953066405232632538044100059654939159879593635\r\n29746152185502371307642255121183693803580388584903\r\n41698116222072977186158236678424689157993532961922\r\n62467957194401269043877107275048102390895523597457\r\n23189706772547915061505504953922979530901129967519\r\n86188088225875314529584099251203829009407770775672\r\n11306739708304724483816533873502340845647058077308\r\n82959174767140363198008187129011875491310547126581\r\n97623331044818386269515456334926366572897563400500\r\n42846280183517070527831839425882145521227251250327\r\n55121603546981200581762165212827652751691296897789\r\n32238195734329339946437501907836945765883352399886\r\n75506164965184775180738168837861091527357929701337\r\n62177842752192623401942399639168044983993173312731\r\n32924185707147349566916674687634660915035914677504\r\n99518671430235219628894890102423325116913619626622\r\n73267460800591547471830798392868535206946944540724\r\n76841822524674417161514036427982273348055556214818\r\n97142617910342598647204516893989422179826088076852\r\n87783646182799346313767754307809363333018982642090\r\n10848802521674670883215120185883543223812876952786\r\n71329612474782464538636993009049310363619763878039\r\n62184073572399794223406235393808339651327408011116\r\n66627891981488087797941876876144230030984490851411\r\n60661826293682836764744779239180335110989069790714\r\n85786944089552990653640447425576083659976645795096\r\n66024396409905389607120198219976047599490197230297\r\n64913982680032973156037120041377903785566085089252\r\n16730939319872750275468906903707539413042652315011\r\n94809377245048795150954100921645863754710598436791\r\n78639167021187492431995700641917969777599028300699\r\n15368713711936614952811305876380278410754449733078\r\n40789923115535562561142322423255033685442488917353\r\n44889911501440648020369068063960672322193204149535\r\n41503128880339536053299340368006977710650566631954\r\n81234880673210146739058568557934581403627822703280\r\n82616570773948327592232845941706525094512325230608\r\n22918802058777319719839450180888072429661980811197\r\n77158542502016545090413245809786882778948721859617\r\n72107838435069186155435662884062257473692284509516\r\n20849603980134001723930671666823555245252804609722\r\n53503534226472524250874054075591789781264330331690\r\n\r\n解决方案\r\n利用Python能够计算大数的特性，直接计算完成后取前\\(10\\)位即可。\r\n代码\r\ns = &#x27;&#x27;&#x27;37107287533902102798797998220837590246510135740250463769376774900097126481248969700780504170182605387432498619952474105947423330951305812372661730962991942213363574161572522430563301811072406154908250230675882075393461711719803104210475137780632466768926167069662363382013637841838368417873436172675728112879812849979408065481931592621691275889832738442742289174325203219235894228767964876702721893184745144573600130643909116721685684458871160315327670386486105843025439939619828917593665686757934951621764571418565606295021572231965867550793241933316490635246274190492910143244581382266334794475817892575867718337217661963751590579239728245598838407582035653253593990084026335689488301894586282278288018119938482628201427819413994056758715117009439035398664372827112653829987240784473053190104293586865155060062958648615320752733719591914205172558297169388870771546649911559348760353292171497005693854370070576826684624621495650076471787294438377604532826541087568284431911906346940378552177792951453612327252500029607107508256381565671088525835072145876576172410976447339110607218265236877223636045174237069058518606604482076212098132878607339694128114266041808683061932846081119106155694051268969251934325451728388641918047049293215058642563049483624672216484350762017279180399446930047329563406911573244438690812579451408905770622942919710792820955037687525678773091862540744969844508330393682126183363848253301546861961243487676812975343759465158038628759287849020152168555482871720121925776695478182833757993103614740356856449095527097864797581167263201004368978425535399209318374414978068609844840309812907779179908821879532736447567559084803087086987551392711854517078544161852424320693150332599594068957565367821070749269665376763262354472106979395067965269474259770973916669376304263398708541052684708299085211399427365734116182760315001271653786073615010808570091499395125570281987460043753582903531743471732693212357815498262974255273730794953759765105305946966067683156574377167401875275889028025717332296191766687138199318110487701902712526768027607800301367868099252546340106163286652636270218540497705585629946580636237993140746255962240744869082311749777923654662572469233228109171419143028819710328859780666976089293863828502533340334413065578016127815921815005561868836468420090470230530811728164304876237919698424872550366387845831148769693215490281042402013833512446218144177347063783299490636259666498587618221225225512486764533677201869716985443124195724099139590089523100588229554825530026352078153229679624948164195386821877476085327132285723110424803456124867697064507995236377742425354112916842768655389262050249103265729672370191327572567528565324825826546309220705859652229798860272258331913126375147341994889534765745501184957014548792889848568277260777137214037988797153829820378303147352772158034814451349137322665138134829543829199918180278916522431027392251122869539409579530664052326325380441000596549391598795936352974615218550237130764225512118369380358038858490341698116222072977186158236678424689157993532961922624679571944012690438771072750481023908955235974572318970677254791506150550495392297953090112996751986188088225875314529584099251203829009407770775672113067397083047244838165338735023408456470580773088295917476714036319800818712901187549131054712658197623331044818386269515456334926366572897563400500428462801835170705278318394258821455212272512503275512160354698120058176216521282765275169129689778932238195734329339946437501907836945765883352399886755061649651847751807381688378610915273579297013376217784275219262340194239963916804498399317331273132924185707147349566916674687634660915035914677504995186714302352196288948901024233251169136196266227326746080059154747183079839286853520694694454072476841822524674417161514036427982273348055556214818971426179103425986472045168939894221798260880768528778364618279934631376775430780936333301898264209010848802521674670883215120185883543223812876952786713296124747824645386369930090493103636197638780396218407357239979422340623539380833965132740801111666627891981488087797941876876144230030984490851411606618262936828367647447792391803351109890697907148578694408955299065364044742557608365997664579509666024396409905389607120198219976047599490197230297649139826800329731560371200413779037855660850892521673093931987275027546890690370753941304265231501194809377245048795150954100921645863754710598436791786391670211874924319957006419179697775990283006991536871371193661495281130587638027841075444973307840789923115535562561142322423255033685442488917353448899115014406480203690680639606723221932041495354150312888033953605329934036800697771065056663195481234880673210146739058568557934581403627822703280826165707739483275922328459417065250945123252306082291880205877731971983945018088807242966198081119777158542502016545090413245809786882778948721859617721078384350691861554356628840622574736922845095162084960398013400172393067166682355524525280460972253503534226472524250874054075591789781264330331690&#x27;&#x27;&#x27;ls = s.split(&#x27;\\n&#x27;)a = []for s in ls:    a.append(int(s))ans = str(sum(a))[:10]print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 131","url":"/project-euler/131/","content":"\r\nProject Euler 131\r\n题目\r\nPrime cube partnership\r\nThere are some prime values, \\(p\\),\r\nfor which there exists a positive integer, \\(n\\), such that the expression \\(n^3 + n^2p\\) is a perfect cube.\r\nFor example, when \\(p = 19, 8^3 + 8^2×19 =\r\n12^3\\).\r\nWhat is perhaps most surprising is that for each prime with this\r\nproperty the value of \\(n\\) is unique,\r\nand there are only four such primes below one-hundred.\r\nHow many primes below one million have this remarkable property?\r\n解决方案\r\n假设这个立方数为\\(m^3=n^3+n^2p\\)，\r\n那么有\\(m^3=n^3\\cdot\r\n\\dfrac{n+p}{n}\\)\r\n两边开立方，有\\(m=n\\cdot\r\n\\sqrt[3]{\\dfrac{n+p}{n}}\\)\r\n由于\\(m,n\\)都是正整数，为满足原来的式子，整个立方根表达的数必须是个有理数。\r\n接下来证明\\(\\gcd(n+p,n)=1\\)：\r\n因为\\(p\\)是质数，如果\\(\\gcd(n+p,n)&gt;1\\)，即\\(\\gcd(n,p)&gt;1\\)，那么\\(n\\)是\\(p\\)的倍数，有\\(n=kp\\)，其中\\(n\\)是一个正整数。\r\n回代到上面的立方数式子，得到：\\(m^3=(k^3+k^2)p^3\\)。那么，如果\\((k^3+k^2)p^3\\)是一个立方数，那么\\(k^3+k^2\\)是一个立方数。但是，\\(k^3\\)的下一个立方数\\((k+1)^3=k^3+3k^2+3k+1&gt;k^3+k^2\\)。因此有：\r\n\\(k^3&lt;k^3+k^2&lt;(k+1)^3\\)\r\n这说明\\(k^3+k^2\\)夹在两个相邻立方数之间，它自己肯定不是一个立方数。因此有刚刚的结论：\\(\\gcd(n+p,n)=1\\)。\r\n因此，可以令\\(n+p=a^3,n=b^3\\)（立方根里面不需要约分），得到\\(p=a^3-b^3=(a-b)(a^2+ab+b^2)\\)。\r\n但是，\\(p\\)是质数，但\\(p\\)却有两个因式：\\(a-b\\)和\\(a^2+ab+b^2\\)\r\n明显观察到\\(a-b&lt;a^2+ab+b^2\\)，所以有：\\(a-b=1,p=a^2+ab+b^2\\)。\r\n将\\(b=a-1\\)重新代入\\(p=a^3-b^3\\)，得到\\(p=a^3-(a-1)^3\\)。因此，判断这一类数是否为质数即可。\r\n代码\r\nfrom itertools import countfrom tools import is_primeN = 1000000ans = 0for i in count(1, 1):    w = (i + 1) ** 3 - i ** 3    if w &gt; N:        break    if is_prime(w):        ans += 1print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 129","url":"/project-euler/129/","content":"\r\nProject Euler 129\r\n题目\r\nRepunit divisibility\r\nA number consisting entirely of ones is called a repunit. We shall\r\ndefine \\(R(k)\\) to be a repunit of\r\nlength \\(k\\); for example, \\(R(6) = 111111\\).\r\nGiven that \\(n\\) is a positive\r\ninteger and \\(\\gcd(n, 10) = 1\\), it can\r\nbe shown that there always exists a value, \\(k\\), for which \\(R(k)\\) is divisible by \\(n\\), and let \\(A(n)\\) be the least such value of \\(k\\); for example, \\(A(7) = 6\\) and \\(A(41) = 5\\).\r\nThe least value of \\(n\\) for which\r\n\\(A(n)\\) first exceeds ten is \\(17\\).\r\nFind the least value of \\(n\\) for\r\nwhich \\(A(n)\\) first exceeds\r\none-million.\r\n乘法群\r\n设\\(\\mathbb{Z}_{m}^*\\)为模数为\\(m\\)的乘法群。容易知道，乘法群是个循环群，而且其大小为\\(\\varphi(m)\\)，其中\\(\\varphi\\)为欧拉函数。\r\n元素\\(a\\)在群\\(\\mathbb{Z}_{m}^{\\ast}\\)上的阶\\(\\lambda_m(a)\\)：使得\\(a^k \\equiv 1\\pmod m\\)的最小正整数\\(k\\)。\r\n需要注意，一个元素的阶是群的大小的因数，也就是有\\(\\forall a \\in\r\n\\mathbb{Z}_m^{\\ast},\\lambda_m(a)\\mid\\varphi(m)\\)。\r\n解决方案\r\n可以通过用等比数列数列求和将\\(R(k)\\)表示出来：\r\n\\[R(k)=\\dfrac{10^k-1}{9}\\]\r\n如果\\(n\\mid R(k)\\)，即\\(9n\\mid (10^k-1)\\)，那么有\\(10^k-1\\equiv 0 \\pmod {9n}\\)，也就是\\(10^k\\equiv 1 \\pmod {9}\\)。那么，\\(A(n)\\)就是求最小的正整数\\(k\\)，以使得\\(k\\)满足以下方程：\r\n\\[10^k\\equiv 1 \\pmod {9n}\\]\r\n可以发现该问题为离散对数问题，主要常见的算法为BSGS算法。不过，如果不限制\\(k\\)是正整数，BSGS算法将显而易见地给出\\(k=0\\)这个解。\r\n根据\\(k\\)正整数的定义，可以发现，所求的\\(k\\)，其实是元素\\(10\\)在模乘法群\\(\\mathbb{Z}_{9n}^{\\ast}\\)中的阶\\(\\lambda_{9n}(10)\\)，即\\(A(n)=\\lambda_{9n}(10)\\)。\r\n另外，容易观察到，\\(A(n)\\leq\r\nn\\)。因此从\\(N=10^6\\)开始搜索。\r\n本代码使用sympy库中的n_order(a,m)函数计算元素阶\\(\\lambda_m(a)\\)的值。\r\n代码\r\nfrom itertools import countfrom sympy import n_orderN = 10 ** 6for n in count(N | 1, 2):    if n % 5 == 0:        continue    order = n_order(10, n * 9)    if order &gt;= N:        ans = n        breakprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 130","url":"/project-euler/130/","content":"\r\nProject Euler 130\r\n题目\r\nComposites with prime\r\nrepunit property\r\nA number consisting entirely of ones is called a repunit. We shall\r\ndefine \\(R(k)\\) to be a repunit of\r\nlength \\(k\\); for example, \\(R(6) = 111111\\).\r\nGiven that \\(n\\) is a positive\r\ninteger and \\(\\gcd(n, 10) = 1\\), it can\r\nbe shown that there always exists a value, \\(k\\), for which \\(R(k)\\) is divisible by \\(n\\), and let \\(A(n)\\) be the least such value of \\(k\\); for example, \\(A(7) = 6\\) and \\(A(41) = 5\\).\r\nYou are given that for all primes, \\(p &gt;\r\n5\\), that \\(p − 1\\) is divisible\r\nby \\(A(p)\\). For example, when \\(p = 41\\), \\(A(41)\r\n= 5\\), and \\(40\\) is divisible\r\nby \\(5\\).\r\nHowever, there are rare composite values for which this is also true;\r\nthe first five examples being \\(91\\),\r\n\\(259\\), \\(451\\), \\(481\\), and \\(703\\).\r\nFind the sum of the first twenty-five composite values of \\(n\\) for which \\(\\gcd(n, 10) = 1\\) and \\(n − 1\\) is divisible by \\(A(n)\\).\r\n解决方案\r\n明显注意到对于正整数\\(k\\)，\\(3\\mid k\\Leftrightarrow3\\mid R(k)\\)。\r\n因此，如果\\(k\\)是\\(3\\)的倍数，那么\\(A(k)\\)也必须是\\(3\\)的倍数，但是此时\\(k-1\\)不是\\(3\\)的倍数，它不能被\\(A(k)\\)整除。\r\n本代码将枚举所有正整数\\(m\\)满足于\\(m\\equiv 5 \\pmod 6\\)。然后再判断\\(m\\)是否为合数。如果是合数，再判断\\(A(n)\\)是否为\\(n-1\\)的因子。\r\n计算\\(A(m)\\)的方式和129题相同，使用sympy库中的n_order(a,m)函数计算元素阶\\(\\lambda_m(a)\\)的值。\r\n代码\r\nfrom itertools import countfrom sympy import n_orderfrom tools import is_primeQ = 25ls = []for n in count(7, 2):    if n % 5 == 0 or n % 3 == 0 or is_prime(n):        continue    order = n_order(10, n * 9)    if (n - 1) % order == 0:        ls.append(n)    if len(ls) == Q:        breakans = sum(ls)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 133","url":"/project-euler/133/","content":"\r\nProject Euler 133\r\n题目\r\nRepunit nonfactors\r\nA number consisting entirely of ones is called a repunit. We shall\r\ndefine \\(R(k)\\) to be a repunit of\r\nlength \\(k\\); for example, \\(R(6) = 111111\\).\r\nLet us consider repunits of the form \\(R(10^n)\\).\r\nAlthough \\(R(10)\\), \\(R(100)\\), or \\(R(1000)\\) are not divisible by \\(17\\), \\(R(10000)\\) is divisible by \\(17\\). Yet there is no value of \\(n\\) for which \\(R(10^n)\\) will divide by \\(19\\). In fact, it is remarkable that \\(11, 17, 41\\), and \\(73\\) are the only four primes below\r\none-hundred that can be a factor of \\(R(10^n)\\).\r\nFind the sum of all the primes below one-hundred thousand that will\r\nnever be a factor of \\(R(10^n)\\).\r\n乘法群\r\n设\\(\\mathbb{Z}_{m}^{\\ast}\\)为模数为\\(m\\)的乘法群。容易知道，乘法群是个循环群，而且其大小为\\(\\varphi(m)\\)，其中\\(\\varphi\\)为欧拉函数。\r\n元素\\(a\\)在群\\(\\mathbb{Z}_{m}^{\\ast}\\)上的阶\\(\\lambda_m(a)\\)：使得\\(a^k \\equiv 1\\pmod m\\)的最小正整数\\(k\\)。\r\n需要注意，一个元素的阶是群的大小的因数，也就是有\\(\\forall a \\in\r\n\\mathbb{Z}_m^{\\ast},\\lambda_m(a)\\mid\\varphi(m)\\)。\r\n解决方案\r\n对于所有非\\(2\\)和\\(5\\)的质数\\(p\\)，容易知道\\(\\gcd(10,9p)=1\\)，因此\\(10\\in \\mathbb{Z}_{9m}^{\\ast}\\)。\r\n因此，如果一个质因数\\(p\\)永远不可能为\\(R(10^n)\\)的阶，也就是永远不会存在\\(n\\)满足以下等式：\r\n\\[10^{10^n}\\equiv 1 \\pmod\r\n{9p}\\]\r\n那么，就说明不存在\\(n\\)，使得\\(\\lambda_{9p}(10)\\mid 10^n\\)。\r\n因此，找出\\(\\varphi(9p)\\)的所有因数，然后从小到大判断这个因数是不是\\(10\\)在群\\(\\mathbb{Z}_{9m}^*\\)中的阶，最终计算出\\(\\lambda_{9p}(10)\\)。\r\n由于\\(10^n\\)只有质因数\\(2,5\\)。因此，如果\\(\\lambda_{9p}(10)\\mid 10^n\\)，那么\\(\\lambda_{9p}(10)\\)就必须只有质因数\\(2,5\\)。\r\n本代码使用sympy库中的n_order(a,m)函数计算\\(\\lambda_m(a)\\)的值。\r\n代码\r\nfrom tools import get_prime, divisorsN = 10 ** 5pr = get_prime(N)ans = 0N = 100000for x in pr:    if x &lt;= 5:        ans += x        continue    # phi(9x) = 6(x-1)    phi = 6 * (x - 1)    ls = divisors(phi)    for k in ls:        if pow(10, k, 9 * x) == 1:            order = k            break    while order % 5 == 0:        order //= 5    while order &amp; 1 == 0:        order &gt;&gt;= 1    if order != 1:        ans += xprint(ans)\r\nfrom sympy import n_orderfrom tools import get_primeN = 10 ** 5pr = get_prime(N)ans = 0N = 100000for x in pr:    if x &lt;= 5:        ans += x        continue    order = n_order(10, 9 * x)    while order % 5 == 0:        order //= 5    while order &amp; 1 == 0:        order &gt;&gt;= 1    if order != 1:        ans += xprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 132","url":"/project-euler/132/","content":"\r\nProject Euler 132\r\n题目\r\nLarge repunit factors\r\nA number consisting entirely of ones is called a repunit. We shall\r\ndefine \\(R(k)\\) to be a repunit of\r\nlength \\(k\\).\r\nFor example, \\(R(10) = 1111111111 =\r\n11×41×271×9091\\), and the sum of these prime factors is \\(9414\\).\r\nFind the sum of the first forty prime factors of \\(R(10^9)\\).\r\n解决方案\r\n可以通过用等比数列数列求和将\\(R(k)\\)表示出来：\r\n\\[R(k)=\\dfrac{10^k-1}{9}\\]\r\n如果质数\\(p\\)满足\\(p\\mid R(k)\\)，即\\(9p\\mid(10^k-1)\\)，那么有\\(10^k-1\\equiv 0 \\pmod {9p}\\)，也就是\\(10^k\\equiv 1 \\pmod {9p}\\)。\r\n质数\\(3\\)则进行特判。对于大于\\(5\\)的质数，如果\\(p\\mid R(k)\\)，那么\\(p\\mid 10^k-1\\)。因此，可以通过费马小定理加速判断\\(10^k\\equiv 1\\pmod p\\)是否满足。\r\n直接从小到大判断所有质数是否可行。\r\n当质数\\(p\\)大于\\(5\\)时，还有另外一种判断方式：元素\\(10\\)在乘法群\\(Z_p^{\\ast}\\)的阶\\(\\lambda_{p}(10)\\)是否为\\(10^9\\)的因数。\r\n代码\r\nfrom sympy import nextprimeN = 10 ** 9Q = 40a = []if N % 3 == 0:    a.append(3)pr = 5while len(a) &lt; Q:    pr = nextprime(pr)    if pow(10, N % (pr - 1), pr) == 1:        a.append(pr)ans = sum(a)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 135","url":"/project-euler/135/","content":"\r\nProject Euler 135\r\n题目\r\nSame differences\r\nGiven the positive integers, \\(x,\r\ny\\), and \\(z\\), are consecutive\r\nterms of an arithmetic progression, the least value of the positive\r\ninteger, \\(n\\), for which the equation,\r\n\\(x^2 − y^2 − z^2 = n\\), has exactly\r\ntwo solutions is \\(n = 27\\):\r\n\\[34^2 − 27^2 − 20^2 = 12^2 − 9^2 − 6^2 =\r\n27\\]\r\nIt turns out that \\(n = 1155\\) is\r\nthe least value which has exactly ten solutions.\r\nHow many values of \\(n\\) less than\r\none million have exactly ten distinct solutions?\r\n解决方案\r\n\\(x,y,z\\)是一个等差数列，并且由于\\(n&gt;0\\)，因此只有当\\(x&gt;y&gt;z\\)时，才会有\\(x^2-y^2-z^2&gt;0\\)。\r\n因此设公差为\\(d\\)，那么有\\((z+2d)^2-(z+d)^2-z^2=n\\)。\r\n将方程左边化简，并分解因式，有\\((3d-z)(d+z)=n\\)。\r\n故在枚举方程的解过程中，先枚举\\(z\\)的值，再枚举\\(d\\)的值，注意\\(d\\)的值要从\\(\\left\\lfloor\\dfrac{z}{3}\\right\\rfloor+1\\)开始枚起来，这样才能保证一开始的\\(n\\)的正数。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e6,Q=10;int c[N+4];int main()&#123;    for(int z=1;z&lt;=N;z++)&#123;        for(int d=z/3+1;;d++)&#123;            int w=(3*d-z)*(d+z);            if(w&gt;=N) break;            c[w]+=1;        &#125;    &#125;    int ans=0;    for(int i=1;i&lt;=N;i++)        if(c[i]==Q) ++ans;    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 134","url":"/project-euler/134/","content":"\r\nProject Euler 134\r\n题目\r\nPrime pair connection\r\nConsider the consecutive primes \\(p_1 =\r\n19\\) and \\(p_2 = 23\\). It can be\r\nverified that \\(1219\\) is the smallest\r\nnumber such that the last digits are formed by \\(p_1\\) whilst also being divisible by \\(p_2\\).\r\nIn fact, with the exception of \\(p_1 =\r\n3\\) and \\(p_2 = 5\\), for every\r\npair of consecutive primes, \\(p_2 &gt;\r\np_1\\), there exist values of \\(n\\) for which the last digits are formed by\r\n\\(p_1\\) and \\(n\\) is divisible by \\(p_2\\). Let \\(S\\) be the smallest of these values of\r\n\\(n\\).\r\nFind \\(\\sum S\\) for every pair of\r\nconsecutive primes with \\(5 \\leq p_1 \\leq\r\n1000000\\).\r\n解决方案\r\n设\\(m\\)为\\(p_1\\)十进制下表示的长度（也就是\\(m=\\lfloor\\log_{10}n\\rfloor+1\\)）\r\n题目中的问题，可以转化为以下标准形式：求一个最小的非负整数\\(x\\)，使得\\(p_2\\mid (p_1+10^mx)\\)\r\n那么就转化成求线性同余方程\\(10^mx\\equiv\r\n-p_1 \\pmod {p_2}\\)。\r\n这是一个线性同余方程\\(ax\\equiv b \\pmod\r\nm\\)的典型。解这类线性同余方程需要使用扩展欧几里得算法辅助解决。\r\n另外，如果\\(m\\)是一个质数，可以用费马小定理直接求解得\\(x\\equiv a^{m-2}\\cdot b \\pmod m\\)。\r\n最终求出\\(x\\)后，\\(S=10^mx+p_1\\)，对答案相加即可。\r\n代码\r\nfrom tools import get_primeN = 1000000M = N + len(bin(N)) * 2 + 4pr = get_prime(4, M)ans = 0for i in range(1, len(pr)):    u, v = pr[i - 1], pr[i]    if u &gt; N:        break    pw = 10 ** len(str(u))    x = (v - u) * pow(pw,v-2,v) % v    s = pw * x + u    ans += sprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 137","url":"/project-euler/137/","content":"\r\nProject Euler 137\r\n题目\r\nFibonacci golden nuggets\r\nConsider the infinite polynomial series \\(A_F(x) = x F_1 + x^2 F_2 + x^3 F_3 +\r\n\\dots\\), where \\(F_k\\) is the\r\n\\(k\\)th term in the Fibonacci sequence:\r\n\\(1, 1, 2, 3, 5, 8, \\dots\\); that is,\r\n\\(F_k = F_{k-1} + F_{k-2}\\), \\(F_1 = 1\\) and \\(F_2 = 1\\).\r\nFor this problem we shall be interested in values of \\(x\\) for which \\(A_F(x)\\) is a positive integer.\r\nSurprisingly \\(\\begin{aligned}\r\nA_F(\\tfrac{1}{2})\r\n&amp; = (\\tfrac{1}{2})\\times 1 + (\\tfrac{1}{2})^2\\times 1 +\r\n(\\tfrac{1}{2})^3\\times 2 + (\\tfrac{1}{2})^4\\times 3 +\r\n(\\tfrac{1}{2})^5\\times 5 + \\cdots \\\\\r\n&amp; = \\tfrac{1}{2} + \\tfrac{1}{4} + \\tfrac{2}{8} + \\tfrac{3}{16} +\r\n\\tfrac{5}{32} + \\cdots \\\\\r\n&amp; = 2\r\n\\end{aligned}\\)\r\nThe corresponding values of \\(x\\)\r\nfor the first five natural numbers are shown below.\r\n\r\n\r\n\r\n\\(x\\)\r\n\\(A_F(x)\\)\r\n\r\n\r\n\r\n\r\n\\(\\sqrt{2}-1\\)\r\n\\(1\\)\r\n\r\n\r\n\\(\\dfrac{1}{2}\\)\r\n\\(2\\)\r\n\r\n\r\n\\(\\dfrac{\\sqrt{13}-2}{3}\\)\r\n\\(3\\)\r\n\r\n\r\n\\(\\dfrac{\\sqrt{89}-5}{8}\\)\r\n\\(4\\)\r\n\r\n\r\n\\(\\dfrac{\\sqrt{34}-3}{5}\\)\r\n\\(5\\)\r\n\r\n\r\n\r\nWe shall call \\(A_F(x)\\) a golden\r\nnugget if \\(x\\) is rational, because\r\nthey become increasingly rarer; for example, the \\(10\\text{th}\\) golden nugget is \\(74049690\\).\r\nFind the \\(15\\text{th}\\) golden\r\nnugget.\r\n解决方案\r\n对\\(A_F(x)\\)的等号两边乘以一个\\(x\\)，再和原式相乘，有 \\[\r\n\\begin{aligned}\r\nA_F(x)      &amp; =xF_1+    &amp; x^2F_2+x^3F_3+\\dots \\\\\r\nxA_F(x)     &amp; =         &amp; x^2F_1+x^3F_2+\\dots\\\\\r\n(1+x)A_F(x) &amp;=xF_1+ &amp;x^2F_3+x^3F_4+\\dots\\\\\r\n\\end{aligned}\r\n\\]\r\n可以发现，第三条式子用了斐波那契数的定义：\\(F_n=F_n-1+F_n-2\\)。\r\n将\\(A_F(x)\\)代入第三条式子右侧，有：\r\n\\[(1+x)A_F(x)=xF_1+\\dfrac{A_F(x)}{x}-F_1-xF_2\\]\r\n代入\\(F_1=F_2=1\\)，化简后，有：\r\n\\[A_F(x)=\\dfrac{x}{1-x-x^2}\\]\r\n\\(A_F(x)\\)又称为数列\\(F\\)的生成函数(母函数)。\r\n令\\(A_F(x)=n\\)，\\(n\\)是一个正整数，有\\(x=n(1-x-x^2)\\)\r\n化成关于\\(x\\)的一元二次方程，有\\(nx^2+(n+1)x-n=0\\)\r\n如果方程的解\\(x\\)是一个有理数，那么其判别式\\(\\Delta\\)必须是有理数。也就是\\((n+1)^2+4n^2=5n^2+2n+1\\)必须是一个平方数。\r\n因此，令正整数\\(y\\)满足\\(y^2=5n^2+2n+1\\)。\r\n两边乘以\\(5\\)，并配方，得\\(25n^2+10n+1+4=5y^2\\)\r\n移项，得：\\((5n+1)^2-5y^2=-4\\)\r\n令\\(x=5n+1\\)，那么得到\\(x^2-5y^2=-4\\)，该类方程为广义佩尔方程：\\(x^2-Dy^2=N\\)。\r\n如果广义佩尔方程存在解，那么广义佩尔方程就存在无数个解。\r\n但是，广义佩尔方程的基础解有多个，不像\\(N=1,-1\\)时的情形。\r\n求解广义佩尔方程的解一般是PQA算法和Lagrange-Matthews-Mollin(LMM)算法，鉴于我能力有限，我无法详细描述怎么不重不漏地求基础解。\r\n接下来介绍怎么产生通解：\r\n我们使用一个办法来根据基础解\\(x^2-Dy^2=N\\)的一个解\\((x_1,y_1)\\)，产生对应的通解：\r\n假设\\((a_k,b_k)\\)为佩尔方程\\(x^2-Dy^2=1\\)的一组解，那么，将两个式子\\(x_1^2-Dy_1^2=N,a_k^2-Db_k^2=1\\)左右两边相乘，有：\r\n\\((x_1^2-Dy_1^2)(a_k^2-Db_k^2)=N\\)\r\n可以将上式子转化成\\((x_1a_k+Dy_1b_k)^2-D(x_1b_k+y_1a_k)^2=N\\)\r\n那么就构造出了方程\\(x^2-Dy^2=N\\)的一组新解\\((x_1a_k+Dy_1b_k,x_1b_k+y_1a_k)\\)。\r\n因此根据一组基础解，可以构造出一组通解：\r\n\\[\\left \\{\\begin{aligned}\r\n  &amp; x_{k+1}=x_1a_k+Dy_1b_k\\\\\r\n  &amp; y_{k+1}=y_1a_k+x_1b_k\r\n\\end{aligned}\\right.\r\n\\]\r\n回到题目本身，可以发现，\\(x^2-5y=-4\\)有三组基础解\\((-1,1),(1,1),(4,2)\\)。分别将这三组基础解代入到上面的公式，分别有\r\n\\[\\left \\{\\begin{aligned}\r\n  &amp; x_{k+1}=-a_k+5b_k\\\\\r\n  &amp; y_{k+1}=a_k-b_k\r\n\\end{aligned}\\right.\r\n\\]\r\n\\[\\left \\{\\begin{aligned}\r\n  &amp; x_{k+1}=a_k+5b_k\\\\\r\n  &amp; y_{k+1}=a_k+b_k\r\n\\end{aligned}\\right.\r\n\\]\r\n\\[\\left \\{\\begin{aligned}\r\n  &amp; x_{k+1}=4a_k+10b_k\\\\\r\n  &amp; y_{k+1}=2a_k+4b_k\r\n\\end{aligned}\\right.\r\n\\]\r\n再根据第66题的算法，可以得到\\(x^2-5y^2=1\\)的通解： \\[a_1=9,b_1=4\\] \\[\\left \\{\\begin{aligned}\r\n  &amp; a_{k+1}=9a_k+20b_k\\\\\r\n  &amp; b_{k+1}=4a_k+9b_k\r\n\\end{aligned}\\right.\r\n\\]\r\n将求出的\\(x\\)回代\\(n=\\dfrac{x-1}{5}\\)。第\\(15\\)小的正整数\\(n\\)为所求。\r\n如果将该数列前几项用来查询OEIS，结果为A081018。\r\n以下标题信息，说明第\\(n\\)个斐波那契金块是第\\(2n\\)和\\(2n+1\\)项的斐波那契数的乘积。\r\nFibonacci(2n)*Fibonacci(2n+1)\r\n代码\r\nN = 15def gen_solution():    x1, y1, x2, y2, x3, y3 = -1, 1, 1, 1, 4, 2    a, b = 9, 4    while True:        for x in (x1, x2, x3):            yield x        x1, y1 = -a + 5 * b, a - b        x2, y2 = a + 5 * b, a + b        x3, y3 = 4 * a + 10 * b, 2 * a + 4 * b        a, b = 9 * a + 20 * b, 4 * a + 9 * bls = []for x in gen_solution():    if (x - 1) % 5 == 0:        w = (x - 1) // 5        if w &gt; 0:            ls.append((x-1)//5)    if len(ls) == N:        breakans = ls[-1]print(ans)\r\nN = 15a, b = 1, 1for i in range(2 * N - 1):    a, b = b, a + bans = a * bprint(ans)\r\n","categories":["Project Euler"],"tags":["佩尔方程","OEIS"]},{"title":"Project Euler 138","url":"/project-euler/138/","content":"\r\nProject Euler 138\r\n题目\r\nSpecial isosceles triangles\r\nConsider the isosceles triangle with base length, \\(b = 16\\), and legs, \\(L = 17\\).\r\n\r\nBy using the Pythagorean theorem it can be seen that the height of\r\nthe triangle, \\(h = \\sqrt{17^2 - 8^2} =\r\n15\\), which is one less than the base length.\r\nWith \\(b = 272\\) and \\(L = 305\\), we get \\(h = 273\\), which is one more than the base\r\nlength, and this is the second smallest isosceles triangle with the\r\nproperty that \\(h = b \\pm 1\\).\r\nFind \\(\\sum L\\) for the twelve\r\nsmallest isosceles triangles for which \\(h = b\r\n\\pm 1\\) and \\(b, L\\) are\r\npositive integers.\r\n解决方案\r\n根据勾股定理，可以列出以下式子：\r\n\\[\\left(\\dfrac{b}{2}\\right)^2+h^2=L^2\\]\r\n代入\\(h=b\\pm 1\\)，有\\(b^2+4(b\\pm 1)^2=4L^2\\)\r\n展开，得\\(5b^2\\pm 8b+4=4L^2\\)\r\n两边同乘以\\(5\\)，再配方，得\\(25b^2\\pm 40b+16+4=20L^2\\)\r\n移项，得\\((5b\\pm 4)^2-20L^2=-4\\)\r\n两边同除\\(4\\)，有\\(\\left(\\dfrac{5b\\pm4}{2}\\right)^2\\pm5L^2=-1\\)。\r\n令\\(x=\\dfrac{5b\\pm4}{2},y=L^2\\)，得到\\(x^2-5y^2=-1\\)，该类方程为负佩尔方程\\(x^2-Dy^2=-1\\)。\r\n假设\\(x^2-Dy^2=-1\\)存在最小特解为\\((x_1,y_1)\\)。那么，负佩尔方程的通解\\((x_k,y_k)\\)由以下式子导出。\r\n\\[x_{k+1}+y_{k+1}\\sqrt{D}=(x_{k}+y_{k}\\sqrt{D})(x_1+y_1\\sqrt{D})^2\\]\r\n容易发现，\\(x^2-5y^2=-1\\)的最小特解为\\((2,1)\\)，代入上面的导出递推公式，得到通解递推公式：\r\n\\[\\left \\{\\begin{aligned}\r\n  &amp; x_{k+1}=9x_k+20y_k\\\\\r\n  &amp; y_{k+1}=4x_k+9y_k\r\n\\end{aligned}\\right.\r\n\\]\r\n对于每个解，回代\\(b=\\dfrac{2x\\mp\r\n4}{5}\\)，并判断\\(b\\)是否为一个正整数。\r\n代码\r\nQ = 12cnt = 0x, y = 2, 1ans = 0while True:    b05, b15 = 2 * x - 4, 2 * x + 4    if b05 % 5 == 0 and b05 &gt; 0 or b15 % 5 == 0:        ans += y        cnt += 1        if cnt == Q:            break    x, y = 9 * x + 20 * y, 4 * x + 9 * yprint(ans)\r\n","categories":["Project Euler"],"tags":["佩尔方程"]},{"title":"Project Euler 140","url":"/project-euler/140/","content":"\r\nProject Euler 140\r\n题目\r\nModified Fibonacci golden\r\nnuggets\r\nConsider the infinite polynomial series \\(A_G(x) = x G_1 + x^2 G_2 + x^3 G_3 +\r\n\\cdots\\), where \\(G_k\\) is the\r\n\\(k\\)th term of the second order\r\nrecurrence relation \\(G_k = G_{k-1} +\r\nG_{k-2}\\), \\(G_1 = 1\\) and \\(G_2 = 4\\); that is, \\(1, 4, 5, 9, 14, 23, \\dots\\) .\r\nFor this problem we shall be concerned with values of \\(x\\) for which \\(A_G(x)\\) is a positive integer.\r\nThe corresponding values of \\(x\\)\r\nfor the first five natural numbers are shown below.\r\n\r\n\r\n\r\n\\(x\\)\r\n\\(A_G(x)\\)\r\n\r\n\r\n\r\n\r\n\\(\\dfrac{\\sqrt{5}-1}{4}\\)\r\n\\(1\\)\r\n\r\n\r\n\\(\\dfrac{2}{5}\\)\r\n\\(2\\)\r\n\r\n\r\n\\(\\dfrac{\\sqrt{22}-2}{6}\\)\r\n\\(3\\)\r\n\r\n\r\n\\(\\dfrac{\\sqrt{137}-5}{14}\\)\r\n\\(4\\)\r\n\r\n\r\n\\(\\dfrac{1}{2}\\)\r\n\\(5\\)\r\n\r\n\r\n\r\nWe shall call \\(A_G(x)\\) a golden\r\nnugget if \\(x\\) is rational, because\r\nthey become increasingly rarer; for example, the 20th golden nugget is\r\n\\(211345365\\).\r\nFind the sum of the first thirty golden nuggets.\r\n解决方案\r\n和137题一样，有\r\n\\[\r\n\\begin{aligned}\r\nA_G(x)      &amp; =xG_1+    &amp; x^2G_2+x^3G_3+\\dots \\\\\r\nxA_G(x)     &amp; =         &amp; x^2G_1+x^3G_2+\\dots\\\\\r\n(1+x)A_G(x) &amp;=xG_1+ &amp;x^2G_3+x^3G_4+\\dots\\\\\r\n\\end{aligned}\r\n\\]\r\n可以发现，第三条式子用了定义：\\(G_n=G_n-1+G_n-2\\)。\r\n将\\(A_F(x)\\)代入第三条式子右侧，有：\r\n\\[\r\n(1+x)A_G(x)=xG_1+\\dfrac{A_G(x)}{x}-G_1-xG_2\r\n\\]\r\n代入\\(G_1=1,G_2=4\\)，化简后，有：\r\n\\[A_G(x)=\\dfrac{3x^2+x}{1-x-x^2}\\]\r\n令\\(A_F(x)=n\\)，\\(n\\)是一个正整数，有：\\(3x^2+x=n(1-x-x^2)\\)\r\n化成关于\\(x\\)的一元二次方程，有\\((n+3)x^2+(n+1)x-n=0\\)\r\n如果\\(x\\)是一个有理数，那么其判别式\\(\\Delta\\)必须是有理数。也就是\\((n+1)^2-4n^2=5n^2+2n+1\\)必须是一个平方数。\r\n如果方程的解\\(x\\)是一个有理数，那么其判别式\\(\\Delta\\)必须是有理数。也就是\\((n+1)^2+4n(n+3)=5n^2+14n+1\\)必须是一个平方数。\r\n因此，令正整数\\(y\\)满足\\(y^2=5n^2+14n+1\\)。\r\n两边同乘\\(5\\)，并配方，得\\(25n^2+70n+49-44=m^2\\)\r\n移项，得：\\((5n+7)^2-5y^2=44\\)\r\n令\\(x=5n+7\\)，那么得到\\(x^2-5y^2=44\\)。这种广义佩尔方程和137题不同的是，后面的\\(N\\)变成\\(44\\)了。\r\n经过一定范围的搜索，发现这个方程有\\(6\\)个基本解：\r\n\\((7,1),(8,2),(13,5),(17,7),(32,14),(43,19)\\)\r\n使用与第137题类似的方法，每一组\\(x^2-5y^2=44\\)的通解由它的一个基础解\\((x_1,y_1)\\)和\\(x^2-5y^2=1\\)的通解\\((a_k,b_k)\\)得到。\r\n\\[\\left \\{\\begin{aligned}\r\n  &amp; x_{k+1}=x_1a_k+Dy_1b_k\\\\\r\n  &amp; y_{k+1}=y_1a_k+x_1b_k\r\n\\end{aligned}\\right.\r\n\\]\r\n将求出的\\(x\\)回代\\(n=\\dfrac{x-7}{5}\\)。第\\(15\\)小的正整数\\(n\\)为所求。\r\n代码\r\nN = 30def gen_solution():    D = 5    base_sol = [(7, 1), (8, 2), (13, 5), (17, 7), (32, 14), (43, 19)]    a, b = 9, 4    for x, y in base_sol:        yield x    while True:        for i in range(len(base_sol)):            x, y = base_sol[i]            x, y = x * a + D * y * b, x * b + y * a            yield x        a, b = 9 * a + 20 * b, 4 * a + 9 * bls = []for x in gen_solution():    if (x - 7) % 5 == 0:        w = (x - 7) // 5        if w &gt; 0:            ls.append((x - 7) // 5)    if len(ls) == N:        breakans = sum(ls)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 136","url":"/project-euler/136/","content":"\r\nProject Euler 136\r\n题目\r\nSingleton difference\r\nThe positive integers, \\(x, y\\), and\r\n\\(z\\), are consecutive terms of an\r\narithmetic progression. Given that \\(n\\) is a positive integer, the equation,\r\n\\(x^2 − y^2 − z^2 = n\\), has exactly\r\none solution when \\(n = 20\\):\r\n\\[13^2 − 10^2 − 7^2 = 20\\]\r\nIn fact there are twenty-five values of \\(n\\) below one hundred for which the\r\nequation has a unique solution.\r\nHow many values of \\(n\\) less than\r\nfifty million have exactly one solution?\r\n解决方案\r\n本题的解决方案和第135题完全一样，在这里不再赘述。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;const int N=5e7,Q=1;int c[N+4];int main()&#123;    for(int z=1;z&lt;=N;z++)&#123;        for(int d=z/3+1;;d++)&#123;            int w=(3*d-z)*(d+z);            if(w&gt;=N) break;            c[w]+=1;        &#125;    &#125;    int ans=0;    for(int i=1;i&lt;=N;i++)        if(c[i]==Q) ++ans;    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 139","url":"/project-euler/139/","content":"\r\nProject Euler 139\r\n题目\r\nPythagorean tiles\r\nLet \\((a, b, c)\\) represent the\r\nthree sides of a right angle triangle with integral length sides. It is\r\npossible to place four such triangles together to form a square with\r\nlength \\(c\\).\r\nFor example, \\((3, 4, 5)\\) triangles\r\ncan be placed together to form a \\(5\\)\r\nby \\(5\\) square with a \\(1\\) by \\(1\\) hole in the middle and it can be seen\r\nthat the \\(5\\) by \\(5\\) square can be tiled with twenty-five\r\n\\(1\\) by \\(1\\) squares.\r\n\r\nHowever, if \\((5, 12, 13)\\)\r\ntriangles were used then the hole would measure \\(7\\) by \\(7\\) and these could not be used to tile the\r\n\\(13\\) by \\(13\\) square.\r\nGiven that the perimeter of the right triangle is less than\r\none-hundred million, how many Pythagorean triangles would allow such a\r\ntiling to take place?\r\n本原勾股数组\r\n本原勾股数组，即一个正整数三元组\\((a,b,c)\\)，满足\\(a^2+b^2+c^2\\land\\gcd(a,b,c)=1\\)。\r\n通过枚举一系列的二元组\\((s,t)\\)，其中\\(s&gt;t\\geq\r\n1\\land\\gcd(s,t)=1,s,t\\)为奇数，可以不重不漏地产生本原勾股数组\\(\\left(st,\\dfrac{s^2-t^2}{2},\\dfrac{s^2+t^2}{2}\\right)\\)。\r\n解决方案\r\n枚举产生出所有本原勾股数组\\((a,b,c)\\)。可以知道，大正方形的边长为\\(c\\)，小正方形的边长为\\(b-a\\)。因此，只需判断\\(b-a\\)是否整除\\(c\\)。在此过程中也将非本原勾股数组进行统计。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=100000000;int main()&#123;    ll ans=0;    for(int s=1;s*s+s&lt;=N;s+=2)&#123;        for(int t=1;t&lt;s&amp;&amp;s*s+s*t&lt;=N;t+=2)&#123;            if(__gcd(s,t)==1)&#123;                int a=s*t,b=(s*s-t*t)&gt;&gt;1,c=(s*s+t*t)&gt;&gt;1;                if(c%(b-a)==0)                    ans+=N/(a+b+c);            &#125;        &#125;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 14","url":"/project-euler/14/","content":"\r\nProject Euler 14\r\n题目\r\nLongest Collatz sequence\r\nThe following iterative sequence is defined for the set of positive\r\nintegers:\r\n\\(n \\rightarrow n/2\\) (\\(n\\) is even)\r\n\\(n \\rightarrow 3n + 1\\) (\\(n\\) is odd)\r\nUsing the rule above and starting with \\(13\\), we generate the following sequence:\r\n\\[13 \\rightarrow 40 \\rightarrow 20\r\n\\rightarrow 10 \\rightarrow 5 \\rightarrow 16 \\rightarrow 8 \\rightarrow 4\r\n\\rightarrow 2 \\rightarrow 1\\] It can be seen that this sequence\r\n(starting at \\(13\\) and finishing at\r\n\\(1\\)) contains \\(10\\) terms. Although it has not been proved\r\nyet (Collatz Problem), it is thought that all starting numbers finish at\r\n\\(1\\).\r\nWhich starting number, under one million, produces the longest\r\nchain?\r\nNOTE: Once the chain starts the terms are allowed to\r\ngo above one million.\r\n解决方案\r\n直接将所有数的Collatz序列长度计算出来即可。\r\n这里使用的一个技巧就是，可以把以前的计算结果记录下来。以后再次询问到相同的值可以直接进行返回，不需要再递归进行计算。\r\n代码\r\nN = 10 ** 6mp = &#123;1: 1&#125;def dfs(u: int):    if u in mp.keys():        return mp[u]    elif u &amp; 1:        mp[u] = dfs(u * 3 + 1) + 1    else:        mp[u] = dfs(u &gt;&gt; 1) + 1    return mp[u]ans, mx = 0, 0for i in range(1, N):    if dfs(i) &gt; mx:        mx = dfs(i)        ans = iprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 143","url":"/project-euler/143/","content":"\r\nProject Euler 143\r\n题目\r\nInvestigating\r\nthe Torricelli point of a triangle\r\nLet \\(ABC\\) be a triangle with all\r\ninterior angles being less than \\(120\\)\r\ndegrees. Let \\(X\\) be any point inside\r\nthe triangle and let \\(XA = p, XC =\r\nq\\), and \\(XB = r\\).\r\nFermat challenged Torricelli to find the position of \\(X\\) such that \\(p\r\n+ q + r\\) was minimised.\r\nTorricelli was able to prove that if equilateral triangles \\(AOB, BNC\\) and \\(AMC\\) are constructed on each side of\r\ntriangle \\(ABC\\), the circumscribed\r\ncircles of \\(AOB, BNC\\), and \\(AMC\\) will intersect at a single point,\r\n\\(T\\), inside the triangle. Moreover he\r\nproved that \\(T\\), called the\r\nTorricelli/Fermat point, minimises \\(p + q +\r\nr\\). Even more remarkable, it can be shown that when the sum is\r\nminimised, \\(AN = BM = CO = p + q + r\\)\r\nand that \\(AN, BM\\) and \\(CO\\) also intersect at \\(T\\).\r\n\r\nIf the sum is minimised and \\(a, b, c, p,\r\nq\\) and \\(r\\) are all positive\r\nintegers we shall call triangle \\(ABC\\)\r\na Torricelli triangle. For example, \\(a = 399,\r\nb = 455, c = 511\\) is an example of a Torricelli triangle, with\r\n\\(p + q + r = 784\\).\r\nFind the sum of all distinct values of \\(p\r\n+ q + r \\leq 120000\\) for Torricelli triangles.\r\n解决方案\r\n在本页面中找到了关于费马点的性质（其实也可以由四点共圆推出）：\r\n\\[\\angle ATB=\\angle BTC=\\angle\r\nCTA=120°\\]\r\n因此，根据余弦定理，可以列出如下式子：\r\n\\(\\begin{aligned}\r\nq^2+r^2+qr = a^2\\\\\r\np^2+q^2+pq = b^2\\\\\r\np^2+r^2+pr = c^2\r\n\\end{aligned}\\)\r\n这篇文章提到了一种构造出一组本原三元组\\((a,b,c)\\)（即\\(\\gcd(a,b,c)=1\\)）满足\\(a^2+b^2+ab=c^2\\)的方法：如果\\(m&gt;n,\\gcd(n,m)=1,3 \\nmid\r\n(m-n)\\),那么有：\r\n\\[a=m^2-n^2,b=2mn+n^2,c=m^2+n^2+mn\\]\r\n不过，本题是需要寻找同时满足上面的式子的\\((p,q),(q,r),(p,r)\\)。这意味着，就算\\(\\gcd(p,q,r)=1\\)，也不能保证\\(p,q,r\\)两两之间是互质的。因此，非本原的三元组\\((a,b,c)\\)也需要枚举出来。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 120000;unordered_set&lt;int&gt;g[N+4];int main()&#123;    for(int m=1;m*m&lt;=N;m++)&#123;        for(int n=1;n&lt;m;n++)&#123;            if((n-m)%3!=0&amp;&amp;__gcd(n,m)==1)&#123;                int p=2*n*m+n*n,q=m*m-n*n;                if(p&gt;q) swap(p,q);                for(int k=1;k*(p+q)&lt;=N;k++)                    g[k*p].insert(k*q);            &#125;        &#125;    &#125;    unordered_set&lt;int&gt;st;    for(int i=1;i&lt;=N;i++)&#123;        if(g[i].size()&lt;2) continue;        vector&lt;int&gt;a(g[i].begin(),g[i].end());        sort(a.begin(),a.end());        for(int j=0;j&lt;a.size();j++)            for(int k=j+1;k&lt;a.size()&amp;&amp;i+a[j]+a[k]&lt;=N;k++)&#123;                int u=a[j],v=a[k];                if(g[u].count(v))&#123;                    st.insert(i+a[j]+a[k]);                &#125;            &#125;    &#125;    int ans=0;    for(int x:st)        ans+=x;    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 144","url":"/project-euler/144/","content":"\r\nProject Euler 144\r\n题目\r\nInvestigating\r\nmultiple reflections of a laser beam\r\nIn laser physics, a “white cell” is a mirror system that acts as a\r\ndelay line for the laser beam. The beam enters the cell, bounces around\r\non the mirrors, and eventually works its way back out.\r\nThe specific white cell we will be considering is an ellipse with the\r\nequation \\(4x^2 + y^2 = 100\\) The\r\nsection corresponding to \\(-0.01 \\leq x \\leq\r\n+0.01\\) at the top is missing, allowing the light to enter and\r\nexit through the hole.\r\n \r\nThe light beam in this problem starts at the point \\((0.0,10.1)\\) just outside the white cell,\r\nand the beam first impacts the mirror at \\((1.4,-9.6)\\).\r\nEach time the laser beam hits the surface of the ellipse, it follows\r\nthe usual law of reflection “angle of incidence equals angle of\r\nreflection.” That is, both the incident and reflected beams make the\r\nsame angle with the normal line at the point of incidence.\r\nIn the figure on the left, the red line shows the first two points of\r\ncontact between the laser beam and the wall of the white cell; the blue\r\nline shows the line tangent to the ellipse at the point of incidence of\r\nthe first bounce.\r\nThe slope \\(m\\) of the tangent line\r\nat any point \\((x,y)\\) of the given\r\nellipse is: \\(m = -4x/y\\)\r\nThe normal line is perpendicular to this tangent line at the point of\r\nincidence.\r\nThe animation on the right shows the first \\(10\\) reflections of the beam.\r\nHow many times does the beam hit the internal surface of the white\r\ncell before exiting?\r\n解决方案\r\n本问题分成两个子问题解决。\r\n第一个是已知两条直线\\(l_1:y=ax+b_1,l_2:y=mx+b_2\\)，求\\(l_1\\)关于\\(l_2\\)对称的直线。其中，已知它们的交点\\(l_1\\cap l_2=(x_0,y_0)\\).\r\n那么现在只剩下求斜率的问题，可以参考下图。\r\n\r\n假设需要求的那条线\\(l_3\\)的斜率为\\(k\\)。根据对称的定义，明显\\(\\theta_1\\)和\\(\\theta_2\\)这两个角的大小是相等的。那么使用\\(\\tan\\)的差角公式，可以得到以下式子：\r\n\\[\\dfrac{m-k}{1+mk}=\\dfrac{a-m}{1+am}\\]\r\n解得\\(k=\\dfrac{am^2+2m-a}{1+2am-m^2}\\)\r\n明显的是，\\((x_0,y_0)\\)也在\\(l_3\\)上，故\\(l_3\\)的方程可以确定为\\(y=k(x-x_0)+y_0\\).\r\n回到本题，入射的光线明显属于\\(l_1\\)，而\\((x_0,y_0)\\)在椭圆上的切线就是\\(l_2\\)。所求反射光线即为\\(l_3\\)。\r\n第二个问题是求反射直线到达的椭圆上的点。\r\n设求出来的\\(l_3:y=kx+b\\)，联立两个方程：\r\n\\[\\left \\{\\begin{aligned}\r\n  &amp; y=kx+b\\\\\r\n  &amp; 4x^2+y^2=100\r\n\\end{aligned}\\right.\r\n\\]\r\n消去\\(y\\)，得到关于\\(x\\)的一元二次方程：\r\n\\[(k^2+4)x^2+2bkx+b^2-100=0\\]\r\n因此，计算出判别式\\(\\Delta=16(25k^2+100-b^2)\\)，直接套用求根公式可以求出两个解\\(x_0,x&#39;\\)。\r\n需要注意的是，由于\\((x_0,y_0)\\)是属于\\(l_3\\)中的点，因此解一定会出现\\(x_0\\)。取另外一个解\\(x&#39;\\)，计算出\\(y&#39;=kx&#39;+b&#39;\\)，那么\\((x&#39;,y&#39;)\\)就是反射光线射中的点。\r\n因此，解决了上面两个问题之后，每一次迭代都找出反射光射中的点。如果射中的是缺口，那么跳出循环。\r\n代码\r\nx1, y1, x2, y2 = 0.0, 10.1, 1.4, -9.6def solve(x1, y1, x2, y2):    cnt = 1    x, y = x2, y2    k = (y2 - y1) / (x2 - x1)    while True:        m = y / (4 * x)        # 第一个问题        k = (2 * m - k * (1 - m ** 2)) / (1 - m ** 2 + 2 * m * k)        b = y - k * x        # 第二个问题        x1 = (-2 * k * b + 4 * (25 * k ** 2 + 100 - b ** 2) ** 0.5) / (2 * (4 + k ** 2))        x2 = (-2 * k * b - 4 * (25 * k ** 2 + 100 - b ** 2) ** 0.5) / (2 * (4 + k ** 2))        if abs(x1 - x) &lt; 1e-7:            x, y = x2, k * x2 + b        else:            x, y = x1, k * x1 + b        if abs(x) &lt; 1e-2 and y &gt;= 0:            break        cnt += 1    return cntans = solve(0.0, 10.1, 1.4, -9.6)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 141","url":"/project-euler/141/","content":"\r\nProject Euler 141\r\n题目\r\nInvestigating\r\nprogressive numbers, n, which are also square\r\nA positive integer, \\(n\\), is\r\ndivided by \\(d\\) and the quotient and\r\nremainder are \\(q\\) and \\(r\\) respectively. In addition \\(d, q\\), and \\(r\\) are consecutive positive integer terms\r\nin a geometric sequence, but not necessarily in that order.\r\nFor example, \\(58\\) divided by \\(6\\) has quotient \\(9\\) and remainder \\(4\\). It can also be seen that \\(4, 6, 9\\) are consecutive terms in a\r\ngeometric sequence (common ratio \\(\\dfrac{3}{2}\\)).\r\nWe will call such numbers, \\(n\\),\r\nprogressive.\r\nSome progressive numbers, such as \\(9\\) and \\(10404 =\r\n102^2\\), happen to also be perfect squares.\r\nThe sum of all progressive perfect squares below one hundred thousand\r\nis \\(124657\\).\r\nFind the sum of all progressive perfect squares below one trillion\r\n(\\(10^{12}\\)).\r\n解决方案\r\n按照题意，有等式\\(n=qd+r\\)，其中\\(r&lt; q\\)是可以确定的.\r\n那么假设\\(d&lt; q\\)（因为无论\\(q&lt;d\\)还是\\(q&gt;d\\)，对上面\\(n\\)的结果不会有任何改变。），并且这个公比是一个有理数，由最简分数\\(\\dfrac{a}{b}\\)表示，那么有\r\n\\(d=\\dfrac{a}{b} \\cdot\r\nr,q=\\dfrac{a^2}{b^2}\\cdot r\\)\r\n如果\\(q\\)是一个正整数，那么\\(b^2\\mid r\\)。因此就存在一个\\(c\\)，使得\\(r=cb^2\\)。\r\n此时\\(d=abc,q=a^2c\\)。\r\n那么\\(n=qd+r=a^3bc^2+b^2c\\)。\r\n枚举这三个数\\(a,b,c\\)即可，要保证\\(\\gcd(a,b)=1,a&gt;b\\)。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll N=1e12;unordered_set&lt;ll&gt;st1,st;int main()&#123;    for(ll i=1;i*i&lt;N;i++)        st1.insert(i*i);    for(ll a=2,a3;(a3=a*a*a)&lt;N;a++)&#123;        ll d=2-a%2;        for(ll b=1;b&lt;a&amp;&amp;b*(a3+b)&lt;N;b+=d)&#123;            if(__gcd(a,b)==1)&#123;                for(ll c=1,w;(w=b*c*(b+a3*c))&lt;N;c++)&#123;                    if(st1.count(w))                        st.insert(w);                &#125;            &#125;        &#125;    &#125;    ll ans=0;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 145","url":"/project-euler/145/","content":"\r\nProject Euler 145\r\n题目\r\nHow\r\nmany reversible numbers are there below one-billion?\r\nSome positive integers n have the property that the sum \\([ n + \\text{reverse}(n) ]\\) consists\r\nentirely of odd (decimal) digits. For instance, \\(36 + 63 = 99\\) and \\(409 + 904 = 1313\\). We will call such\r\nnumbers reversible; so \\(36, 63,\r\n409\\), and \\(904\\) are\r\nreversible. Leading zeroes are not allowed in either n or\r\nreverse(n).\r\nThere are \\(120\\) reversible numbers\r\nbelow one-thousand.\r\nHow many reversible numbers are there below one-billion \\((10^9)\\)?\r\n解决方案\r\n首先假设\\(g(n)=[n+\\text{reverse}(n)\r\n]\\)\r\n假设\\(f_1(i)(i&gt;0)\\)满足以下条件的\\(i\\)位数\\(n\\)的个数：无前导\\(0\\)；\\(g(n)\\)是一个\\(i\\)位数；\\(g(n)\\)每一个数位都是奇数。\r\n类似的，\\(f_2(i)(i&gt;0)\\)：可能有前导\\(0\\)；\\(g(n)\\)是一个\\(i\\)位数；\\(g(n)\\)每一个数位都是奇数。\r\n\\(f_3(i)(i&gt;0)\\)：无前导\\(0\\)；\\(g(n)\\)是一个\\(i+1\\)位数；\\(g(n)\\)每一个数位都是奇数（明显加法产生进位的第\\(i+1\\)位肯定是\\(1\\)）。\r\n\\(f_4(i)(i&gt;0)\\)：可能有前导0；\\(g(n)\\)是一个\\(i\\)位数；\\(g(n)\\)中高\\(i-1\\)位都是奇数，最低位则是偶数。\r\n本题通过将为一个\\(i-2\\)位数高位前面添加一个数位\\(l\\)，低位后面添加一个数位\\(r\\)进行考虑。\r\n如果对\\(f_2(i-2)\\)中的所有数的添加方案为：\\(0&lt;l+r\\le9\\)，\\(l+r\\)为奇数，\\(l,r&gt;0\\)，那么就变成了\\(f_1(i)\\)中的数，每个数有\\(20\\)种添加方案；而如果是\\(0\\le l+r\\le9\\)，\\(l+r\\)为奇数，那么就变成了\\(f_2(i)\\)中的数，每一个数有\\(30\\)种添加方案。\r\n如果对\\(f_4(i-2)\\)中的所有数的添加方案为：\\(l+r&gt;9\\)，\\(l+r\\)为奇数 ，那么每个数就变成了\\(f_3(i)\\)中的数，每个数有\\(20\\)种添加方案。注意到，由于\\(l+r\\)有一个进位，那么添加后相比添加前的数有：前面的进位导致\\(g(n)\\)从\\(i-2\\)位数变成\\(i+1\\)位数，后面的进位将\\(g(n)\\)最后一位偶数\\(+1\\)变成奇数。\r\n如果对\\(f_3(i-2)\\)中的所有数的添加方案为：\\(0\\leq l+r&lt;9\\)，\\(l+r\\)为偶数\r\n，那么每个数就变成了\\(f_3(i)\\)中的数，每个数有\\(25\\)种添加方案。由于\\(f_3(i-2)\\)中的\\(g(n)\\)是\\(i-1\\)位数（最高位为\\(1\\)），因此添加的\\(l\\)就直接影响\\(g(n)\\)第\\(i-1\\)位；并且，\\(l+r\\)是一个偶数，因此添加后\\(g(n)\\)的最高位\\(l+r+1\\)是一个奇数。而\\(g(n)\\)最低位则是直接被添加了一个偶数\\(l+r\\)。\r\n将\\(f_1,f_2,f_3,f_4\\)写成状态转移方程，有：\r\n\\[\r\nf_1(i)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0  &amp; &amp; \\text{if}\\quad i=1 \\\\\r\n  &amp;20  &amp; &amp; \\text{else if}\\quad i=2 \\\\\r\n  &amp;20f_2(i-2) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\] \\[\r\nf_2(i)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0  &amp; &amp; \\text{if}\\quad i=1 \\\\\r\n  &amp;30  &amp; &amp; \\text{else if}\\quad i=2 \\\\\r\n  &amp;30f_2(i-2) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\] \\[\r\nf_3(i)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0  &amp; &amp; \\text{if}\\quad i=1,2 \\\\\r\n  &amp;20f_4(i-2) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\] \\[\r\nf_4(i)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;5  &amp; &amp; \\text{if}\\quad i=1 \\\\\r\n  &amp;0  &amp; &amp; \\text{else if}\\quad i=2 \\\\\r\n  &amp;25f_3(i-2) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\] 这里的每一个初值都是直接暴力计算出来。\r\n令\\(N=9\\)，那么答案就是\\(\\sum_{i=1}^Nf_1(i)+f_3(i)\\)。\r\n代码\r\nN = 9f1, f2, f3, f4 = [0, 0, 20], [0, 0, 30], [0, 0, 0], [0, 5, 0]for i in range(3, N + 1):    f1.append(20 * f2[i - 2])    f2.append(30 * f2[i - 2])    f3.append(20 * f4[i - 2])    f4.append(25 * f3[i - 2])ans = sum(f1[1:] + f3[1:])print(ans)\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 146","url":"/project-euler/146/","content":"\r\nProject Euler 146\r\n题目\r\nInvestigating a Prime\r\nPattern\r\nThe smallest positive integer \\(n\\)\r\nfor which the numbers \\(n^2+1, n^2+3, n^2+7,\r\nn^2+9, n^2+13\\), and \\(n^2+27\\)\r\nare consecutive primes is \\(10\\). The\r\nsum of all such integers n below one-million is \\(1242490\\).\r\nWhat is the sum of all such integers n below \\(150\\) million?\r\n解决方案\r\n第一步预处理：\r\n假设质数\\(p\\)和非负整数\\(r(0\\le r&lt;\r\np)\\)，如果对于以及任意非负整数\\(k\\)，存在\\(b\\in\\{1,3,7,9,13,27\\}\\)，有\\(p\\mid(kp+r)^2+b\\)，也就是\\(p\\mid r^2+b\\)。那么所有满足\\(n\\equiv r \\pmod p\\)的\\(n\\)都可以排除。\r\n根据这个规律，代入\\(p=2,3,5,7\\)，可以排除许多\\(n\\)，留下来的\\(n\\)一定满足以下所有条件：\r\n\\(\\begin{aligned}\r\n&amp; n\\equiv 0\\pmod 2\\\\\r\n&amp; n\\equiv 1, 2 \\pmod 3\\\\\r\n&amp; n\\equiv 0 \\pmod 5\\\\\r\n&amp; n\\equiv 3, 4 \\pmod 7\r\n\\end{aligned}\\)\r\n那么可以留下大约\\(\\dfrac{2}{105}\\)个\\(n\\)。根据中国剩余定理，可以认为只有以下\\(n\\)才满足条件：\r\n\\(n\\equiv 10, 80, 130, 200\\pmod\r\n{210}\\)\r\n第二部预处理：由于sympy库中的素性测试算法isprime对于小数的效率非常低，但是对于大数很高，因此这里利用一些小质数对以上这些\\(n^2+b\\)的数进行试除，筛选掉一些合数，减低后面使用isprime的次数。\r\n筛选完成后，正式对这些\\(n^2+b\\)使用素性测试算法，统计所有素性测试都能通过的\\(n\\)。\r\n还需要注意的一点是，题目要求这六个质数是连续的。\r\n代码\r\nfrom itertools import countfrom tools import get_prime, is_primeN = 150000000pr = get_prime(11, 33)s = [1, 3, 7, 9, 13, 27]# residues = []# for i in range(210):#     if i % 2 == 0 and i % 3 != 0 and i % 5 == 0 and i % 7 in [3, 4]:#         residues.append(i)residues = [10, 80, 130, 200]candidate = []for n in count(0, 210):    if n &gt; N:        break    for res in residues:        w = n + res        flag = True        for q in pr:            for x in s:                if (w * w + x) % q == 0:                    flag = False                    break            if not flag:                break        if flag:            candidate.append(w)ans = 0for n in candidate:    if n &gt; N:        break    flag = True    for x in s:        if not is_prime(n * n + x):            flag = False            break    if flag:        cnt = 0        for i in range(1, 28, 2):            if is_prime(n * n + i):                cnt += 1        if cnt != len(s):            flag = False    if flag:        ans += nprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 147","url":"/project-euler/147/","content":"\r\nProject Euler 147\r\n题目\r\nRectangles in cross-hatched\r\ngrids\r\nIn a \\(3\\times2\\) cross-hatched\r\ngrid, a total of \\(37\\) different\r\nrectangles could be situated within that grid as indicated in the\r\nsketch.\r\n\r\nThere are \\(5\\) grids smaller than\r\n\\(3\\times2\\), vertical and horizontal\r\ndimensions being important, i.e. \\(1\\times1\\), \\(2\\times1\\), \\(3\\times1\\), \\(1\\times2\\) and \\(2\\times2\\). If each of them is\r\ncross-hatched, the following number of different rectangles could be\r\nsituated within those smaller grids:\r\n\\(\\begin{aligned}\r\n1\\times1&amp;: 1 \\\\\r\n2\\times1&amp;: 4 \\\\\r\n3\\times1&amp;: 8 \\\\\r\n1\\times2&amp;: 4 \\\\\r\n2\\times2&amp;: 18\r\n\\end{aligned}\\)\r\nAdding those to the \\(37\\) of the\r\n\\(3\\times2\\) grid, a total of \\(72\\) different rectangles could be situated\r\nwithin \\(3\\times2\\) and smaller\r\ngrids.\r\nHow many different rectangles could be situated within \\(47\\times43\\) and smaller grids?\r\n解决方案\r\n假设该矩形大小为\\(n\\times m(n\\le\r\nm)\\)。\r\n首先，和矩形边上平行的小矩形个数为\\(T(n,m)=\\dfrac{n(n+1)m(m+1)}{4}\\)。\r\n接下来考虑倾斜矩形的个数，使用了一些和多项式相关的小技巧。\r\n合理猜测：这一类的矩形个数可以用多项式来表示，并且项的最高次数和上面一样，也是\\(4\\)。这种猜测个人认为比较合理，因为随着\\(n,m\\)的增长，两种方式矩形的增长速度感知上是相同的。\r\n因此，假设这个公式为\\(p(n,m)=\\sum_{i=0}^4\\sum_{j=0}^{4-i}a_{i,j}\r\nn^im^j\\).其中，多项式\\(a_{i,j}\\)是未知的，用待定系数求出来。\r\n我首先写了一份比较暴力并且不美观的代码，用来计算小范围内的\\(p(n,m)\\)值：\r\n# include &lt;bits/stdc++.h&gt;using namespace std;int solve(int n,int m)&#123;    int o=max(n,m)*2;    int ans=0;    n&lt;&lt;=1;m&lt;&lt;=1;    for(int i=0;i&lt;=n;i++)    for(int j=0;j&lt;=m;j++)&#123;        if((i+j)&amp;1) continue;        for(int d=1;d&lt;=o;d++)&#123;            int x=i-d,y=j+d;            if(x&lt;0||y&gt;m) break;            for(int k=1;k&lt;=o;k++)&#123;                if(max(k+i,k+x)&lt;=n&amp;&amp;max(k+j,k+y)&lt;=m) ++ans;                else break;            &#125;        &#125;    &#125;    return ans;&#125;int main()&#123;    int M=7;    for(int n=1;n&lt;=M;n++)        for(int m=n;m&lt;=M;m++)            printf(&quot;%d %d %d\\n&quot;,n,m,solve(n,m));&#125;\r\n用统计出来的\\(n,m,p(n,m)\\)，全部代入到公式\\(p(n,m)\\)中。由此构造出一个方程组。\r\n使用sympy库的linsolve函数最终解出方程组，回代到公式，整合，也就是：\r\n\\(\\dfrac{n((2m-n)(4n^2-1)-3)}{6}\\)\r\n最终把上面的第一种情况加起来即可。\r\n不失一般性，如果\\(n&gt;m\\)，那么将上面的式子的\\(n,m\\)两个变量进行交换。\r\n本题甚至可以进一步整理公式直接导出答案\\(\\sum_{i=1}^N\\sum_{j=1}^M{T(i,j)+p(i,j)}\\)的通式，此处不赘述。\r\n代码\r\nN, M = 47, 43def solve(n, m):    if n &gt; m:        n, m = m, n    return n * (n + 1) * m * (m + 1) // 4 + n * ((2 * m - n) * (4 * n * n - 1) - 3) // 6ans = 0for i in range(1, N + 1):    for j in range(1, M + 1):        ans += solve(i, j)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 148","url":"/project-euler/148/","content":"\r\nProject Euler 148\r\n题目\r\nExploring Pascal’s triangle\r\nWe can easily verify that none of the entries in the first seven rows\r\nof Pascal’s triangle are divisible by \\(7\\):\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n1\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n1\r\n\r\n1\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n1\r\n\r\n2\r\n\r\n1\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n1\r\n\r\n3\r\n\r\n3\r\n\r\n1\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n1\r\n\r\n4\r\n\r\n6\r\n\r\n4\r\n\r\n1\r\n\r\n\r\n\r\n\r\n\r\n1\r\n\r\n5\r\n\r\n10\r\n\r\n10\r\n\r\n5\r\n\r\n1\r\n\r\n\r\n\r\n1\r\n\r\n6\r\n\r\n15\r\n\r\n20\r\n\r\n15\r\n\r\n6\r\n\r\n1\r\n\r\n\r\n\r\nHowever, if we check the first one hundred rows, we will find that\r\nonly \\(2361\\) of the \\(5050\\) entries are not divisible by \\(7\\).\r\nFind the number of entries which are not divisible by \\(7\\) in the first one billion (\\(10^9\\)) rows of Pascal’s triangle.\r\n卢卡斯定理\r\n卢卡斯定理：如果\\(p\\)是一个质数，那么计算组合数\\(\\dbinom{n}{m}\\% p\\)时可用以下公式。\r\n\\[\\dbinom{n}{m} \\equiv \\dbinom{n\\%p}{m\\%p}\r\n\\cdot\r\n\\dbinom{\\left\\lfloor\\frac{n}{p}\\right\\rfloor}{\\left\\lfloor\\frac{m}{p}\\right\\rfloor}\r\n\\pmod p\\]\r\n其中，在计算过程中，如果发生了\\(m&gt;n\\)，那么\\(\\dbinom{n}{m}\\%p=0\\)。\r\n可以看成是假设有两个等长的\\(p\\)进制数（可以有前导\\(0\\)）：\\(a=a_{k-1}\\dots a_2a_1a_0,b= b_{k-1}\\dots\r\nb_2b_1b_0\\)。那么\r\n\\[\\dbinom{a}{b}\\equiv  \\dbinom{a_{k-1}}{b_{k-1}}\\dots\r\n\\dbinom{a_{2}}{b_{2}}\\dbinom{a_{1}}{b_{1}}\\dbinom{a_{0}}{b_{0}}\\pmod\r\np\\]\r\n解决方案\r\n根据卢卡斯定理，上面的问题可以转化成另一种形式。有多少对\\((i,j)(0\\leq j \\le i &lt;n\r\n)\\)，满足以下条件：\r\n将\\(i\\)和\\(j\\)写成两个长度为\\(k\\)的\\(p\\)进制数：\\(i=i_{k-1}\\dots i_2i_1i_0,j=j_{k-1}\\dots\r\nj_2j_1j_0\\)。那么$q:0q&lt;k ,j_qi_q $.\r\n根据卢卡斯定理的描述，如果有一个\\(j_q&gt;i_q\\)，那么整个式子模\\(p\\)的值为\\(0\\)，也就是能被\\(p\\)整除。\r\n设\\(p\\)进制数\\(n=n_{k-1}\\dots\r\nn_2n_1n_0\\)，那么对于每一个\\(q\\in[0,k-1]\\)，如果\\(n_{k-1}=i_{k-1},n_{k-2}=i_{k-2},\\dots,i_{q+1}=n_{q+1},i_q&lt;n_q\\)，可以将这一些数位的下标划分成独立的三个部分：\r\n\r\n\\(q-1,q-2,\\dots 0\\)这一部分。\r\n\\(i_{q-1},i_{q-2},\\dots,i_0\\)都可以随便填\\(0,1,\\dots,p-1\\)这\\(p\\)个数，而每个\\(j_{k-1}\\le i_{k-1},j_{k-2}\\le i_{k-2},\\dots,j_0\\le\r\ni_0\\)都要得到保证，因此后面这些数一共有\\(\\left(\\dfrac{p(p+1)}{2}\\right)^{k+1}\\)种填法。\r\n\\(q\\)自己的一部分。\\(0\\le j_q\\le\r\ni_q&lt;n_q\\)，满足这个条件的\\((j_q,i_q)\\)对数为\\(\\dfrac{n_q(n_q+1)}{2}\\)。\r\n\\(k-1,k-2,\\dots,q+1\\)这一部分。这一部分的\\(n\\)和\\(i\\)的数位相等，\\(i\\)的部分是固定的，\\(j\\)是变动的，都有\\(0\\le j_m\\le\r\ni_m=n_m\\)。因此每个独立数位都有\\(n_m+1\\)种填法。\r\n\r\n三种情况独立考虑，因此最终答案为\\[\\sum_{q=0}^{k-1}\r\n\\left(\\dfrac{p(p+1)}{2}\\right)^{k+1}\\cdot \\dfrac{n_q(n_q+1)}{2}\\cdot\r\n\\prod_{m=q+1}^{k-1}n_m\\]\r\n代码\r\nN, p = 10 ** 9, 7def fun(n: int):    return n * (n + 1) // 2ls = []while N:    ls.append(N % p)    N //= pans, mul = 0, 1for k in range(len(ls) - 1, -1, -1):    ans += mul * (fun(p) ** k) * fun(ls[k])    mul *= (ls[k] + 1)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 15","url":"/project-euler/15/","content":"\r\nProject Euler 15\r\n题目\r\nLattice paths\r\nStarting in the top left corner of a \\(2×2\\) grid, and only being able to move to\r\nthe right and down, there are exactly \\(6\\) routes to the bottom right corner.\r\n\r\nHow many such routes are there through a \\(20\\times20\\) grid?\r\n解决方案\r\n假设这个方格一共有\\(n\\times\r\nm\\)格，在这里，\\(n=m=20\\).\r\n假设往下走一步，得到一个字母D，往右走一步，得到一个字母R。那么一共可以得到\\(n\\)个D和\\(m\\)个R。\r\n但是，走的过程是可以随时变化的，这也对应了每个D和R的序列顺序不一样（但仍然保持有\\(n\\)个D和\\(m\\)个R）。\r\n问题就转化成了组合数，因此，答案是\\(\\dbinom{n+m}{m}\\)。\r\n这里使用了sympy的binomial方法求组合数，之后将封装在tools自定义工具类中，以C(n,m)的方式调用。\r\n代码\r\nfrom sympy import binomialn = m = 20ans = binomial(n + m, m)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 149","url":"/project-euler/149/","content":"\r\nProject Euler 149\r\n题目\r\nSearching for a\r\nmaximum-sum subsequence\r\nLooking at the table below, it is easy to verify that the maximum\r\npossible sum of adjacent numbers in any direction (horizontal, vertical,\r\ndiagonal or anti-diagonal) is \\(16 (= 8 + 7 +\r\n1)\\).\r\n\r\n\r\n\r\n\\(-2\\)\r\n\\(5\\)\r\n\\(3\\)\r\n\\(2\\)\r\n\r\n\r\n\\(9\\)\r\n\\(-6\\)\r\n\\(5\\)\r\n\\(1\\)\r\n\r\n\r\n\\(3\\)\r\n\\(2\\)\r\n\\(7\\)\r\n\\(3\\)\r\n\r\n\r\n\\(-1\\)\r\n\\(8\\)\r\n\\(-4\\)\r\n\\(8\\)\r\n\r\n\r\n\r\nNow, let us repeat the search, but on a much larger scale:\r\nFirst, generate four million pseudo-random numbers using a specific\r\nform of what is known as a “Lagged Fibonacci Generator”:\r\nFor \\(1 \\leq k \\leq 55, s_k = [100003 -\r\n200003k + 300007k^3] (\\text{modulo\\ } 1000000) - 500000\\)\r\nFor \\(56 \\leq k \\leq 4000000\\),\r\n\\(s_k = [s_{k-24} + s_{k-55} + 1000000]\r\n(\\text{modulo\\ } 1000000) - 500000\\).\r\nThus, \\(s_{10} = -393027\\) and \\(s_{100} = 86613\\).\r\nThe terms of \\(s\\) are then arranged\r\nin a \\(2000\\times2000\\) table, using\r\nthe first \\(2000\\) numbers to fill the\r\nfirst row (sequentially), the next \\(2000\\) numbers to fill the second row, and\r\nso on.\r\nFinally, find the greatest sum of (any number of) adjacent entries in\r\nany direction (horizontal, vertical, diagonal or anti-diagonal).\r\n解决方案\r\n需要将表格按照同行，同列，同主副对角线下，预处理一个个数组，方便求相邻之和。\r\n对于每一个数组\\(a\\)（其中设\\(m\\)为其长度），视为整个问题中的一个个独立的子问题。用动态规划求这些子问题的最大子段和。\r\n设\\(f(i)(1\\le i\\le\r\nm)\\)为以数组第\\(i\\)个元素为结尾的所有子段的最大和，那么可以列出如下状态转移方程：\r\n\\[\r\nf(i)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;a[i]  &amp; &amp; \\text{if}\\quad i=1 \\\\\r\n  &amp;\\max(a[i],f(i-1)+a[i]) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n其中，最后一行两种决策分别是：要么将这个元素拼接到前面\\(f(i-1)\\)的子段末尾，要么独立自乘一个子段。\r\n答案为\\(\\max_{i=1}^m\r\n\\{f(i)\\}\\)。\r\n所有子问题的答案的最大值即为问题答案。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;const int N=2000;const int m=500000;int s[N*N+4];vector&lt;int&gt;a[N],b[N],g[N+N],h[N+N];int solve(vector&lt;int&gt;&amp;v)&#123;    int mx=0,s=0;    for(int x:v)&#123;        if(s&lt;0) s=x;        else s+=x;        mx=max(mx,s);    &#125;    return mx;&#125;int main()&#123;    for(int k=1;k&lt;=N*N;k++)&#123;        if(k&lt;=55) s[k]=(300007ll*k*k*k-200003*k+100003)%(m*2)-m;        else s[k]=(s[k-24]+s[k-55]+m*2)%(m*2)-m;    &#125;    for(int i=0,p=1;i&lt;N;i++)&#123;        for(int j=0;j&lt;N;j++,p++)&#123;            a[i].push_back(s[p]);            b[j].push_back(s[p]);            g[i+j].push_back(s[p]);            h[i-j+N-1].push_back(s[p]);        &#125;    &#125;    int ans=0;    for(int i=0;i&lt;N;i++)        ans=max(ans,max(solve(a[i]),solve(b[i])));    for(int i=0;i&lt;2*N-1;i++)        ans=max(ans,max(solve(g[i]),solve(h[i])));    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 142","url":"/project-euler/142/","content":"\r\nProject Euler 142\r\n题目\r\nPerfect Square Collection\r\nFind the smallest \\(x + y + z\\) with\r\nintegers \\(x &gt; y &gt; z &gt; 0\\)\r\nsuch that \\(x + y, x - y, x + z, x - z, y + z,\r\ny - z\\) are all perfect squares.\r\n解决方案\r\n令这六个数分别为六个平方数：\r\n\\(\\begin{aligned}\r\n&amp;x+y=a^2\\\\\r\n&amp;x-y=b^2\\\\\r\n&amp;x+z=c^2\\\\\r\n&amp;x-z=d^2\\\\\r\n&amp;y+z=e^2\\\\\r\n&amp;y-z=f^2\r\n\\end{aligned}\\)\r\n将其中的一些式子相减，代入，可以得到以下式子：\r\n\\(\\begin{aligned}\r\n&amp;e^2=a^2-d^2\\\\\r\n&amp;f^2=a^2-c^2\\\\\r\n&amp;b^2=c^2-e^2\\\\\r\n\\end{aligned}\\)\r\n我们最终枚举\\(a,c,e\\)三个值寻找答案，另外不难发现\\(a&gt;c&gt;e\\)。\r\n由于本题的每个平方数的上限难以确定，故拟定为\\(10^6\\)。\r\n另外，在枚举过程中，需要保证\\(a&gt;b,c&gt;d,e&gt;f\\)。以及最终算出来的\\(x,y,z\\)必须是个正整数。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1000000;int solve()&#123;    unordered_set&lt;int&gt;st;    for(int i=1;i*i&lt;=N;i++)        st.insert(i*i);    for(int a=1,a2;(a2=a*a)&lt;=N;a++)&#123;        for(int c=1;c&lt;a;c++)&#123;            int c2=c*c;            int f2=a2-c2;            if(!st.count(f2)) continue;            for(int e=1;e&lt;c;e++)&#123;                int e2=e*e;                int b2=c*c-e*e;                if(!st.count(b2)) continue;                int d2=a2-e2;                if(st.count(d2))&#123;                    if(a2&gt;b2&amp;&amp;c2&gt;d2&amp;&amp;e2&gt;f2&amp;&amp;(a2+b2)%2==0&amp;&amp;(e2+f2)%2==0)&#123;                        return (a2+c2+e2)&gt;&gt;1;                    &#125;                &#125;            &#125;        &#125;    &#125;    return -1;&#125;int main()&#123;    int ans=solve();    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 150","url":"/project-euler/150/","content":"\r\nProject Euler 150\r\n题目\r\nSearching\r\na triangular array for a sub-triangle having minimum-sum\r\nIn a triangular array of positive and negative integers, we wish to\r\nfind a sub-triangle such that the sum of the numbers it contains is the\r\nsmallest possible.\r\nIn the example below, it can be easily verified that the marked\r\ntriangle satisfies this condition having a sum of \\(-42\\).\r\n\r\nWe wish to make such a triangular array with one thousand rows, so we\r\ngenerate 500500 pseudo-random numbers s_k in the range ±2^19, using a\r\ntype of random number generator (known as a Linear Congruential\r\nGenerator) as follows:\r\n\\(\\begin{aligned}\r\n&amp;t := 0 \\\\\r\n&amp;\\text{for }k = 1 \\text{ up to } k = 500500: \\\\\r\n&amp;\\quad t := (615949*t + 797807) \\text{ modulo } 2^{20} \\\\\r\n&amp;\\quad s_k := t-2^{19} \\\\\r\n\\end{aligned}\\)\r\nThus: \\(s_1 = 273519, s_2 = -153582, s_3 =\r\n450905\\) etc\r\nOur triangular array is then formed using the pseudo-random numbers\r\nthus:\r\n\\[s_1\\] \\[s_2\\ s_3\\] \\[s_4\\ s_5\\ s_6 \\] \\[s_7\\ s_8\\ s_9\\ s_{10}\\] \\[\\dots\\]\r\nSub-triangles can start at any element of the array and extend down\r\nas far as we like (taking-in the two elements directly below it from the\r\nnext row, the three elements directly below from the row after that, and\r\nso on).\r\nThe “sum of a sub-triangle” is defined as the sum of all the elements\r\nit contains.\r\nFind the smallest possible sub-triangle sum.\r\n解决方案\r\n将数字三角形直接转化成一个以左下角为顶点的直角三角形，方便存储。如下：\r\n\\[\\begin{aligned}\r\n&amp; s_1 \\\\\r\n&amp; s_2\\ s_3\\\\\r\n&amp; s_4\\ s_5\\ s_6 \\\\\r\n&amp; s_7\\ s_8\\ s_9\\ s_{10}\\\\\r\n&amp; \\dots\r\n\\end{aligned}\\]\r\n那么令三角形的行数为\\(n\\)，设\\(a[i][j](1\\le j\\le i\\le n)\\)表示第\\(i\\)行第\\(j\\)列的数。\r\n假设\\(s(i,j)=\\sum_{k=1}^ja[i][k]\\)，也就是求出每一行的前缀和。其中，\\(s(i,0)=0\\)。\r\n那么，对于最上面的点\\((i,j)\\)，直角边长为\\(d(i+d-1\\le  n)\\)的三角形的和为：\\(f(i,j,d)=\\sum_{k=0}^{d-1}\r\ns(i+k,j+k)-s(i+k,j-1)\\)。\r\n可以看出，当\\(d\\ge 2\\)时，\\(f(i,j,d)=f(i,j,d-1)+s(i+d-1,j+d-1)-s(i+d,j-1)\\).\r\n由上式可以提供一种做法：先枚举最上面的点\\((i,j)\\)，然后从小到大枚举三角形的边长\\(d\\)，枚举到第\\(d\\)次时，就将第\\(i+d-1\\)行第\\(j\\)列之后的\\(d\\)个数直接加起来。\r\n这种做法需要枚举\\(\\Theta(n^3)\\)个小三角形。但本人能力有限，还没想到\\(O(n^2)\\)的算法。（如果想到了就补上）\r\n代码\r\n# include &lt;bits/stdc++.h&gt;# define mem(a,b) memset(a,b,sizeof(a))using namespace std;typedef long long ll;const int N=1000;ll s[N+4][N+4];ll ans=0;int main()&#123;    ll b=1&lt;&lt;19,t=0;    for(int i=1;i&lt;=N;i++)    for(int j=1;j&lt;=i;j++)&#123;        t=(615949ll*t+797807)%(b*2);        s[i][j]=s[i][j-1]+(t-b);    &#125;    for(int i=1;i&lt;=N;i++)&#123;        for(int j=1;j&lt;=i;j++)&#123;            ll sum=0;            for(int d=0;i+d&lt;=N;d++)&#123;                sum+=s[i+d][j+d]-s[i+d][j-1];                ans=min(ans,sum);            &#125;        &#125;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 151","url":"/project-euler/151/","content":"\r\nProject Euler 151\r\n题目\r\nPaper\r\nsheets of standard sizes: an expected-value problem\r\nA printing shop runs \\(16\\) batches\r\n(jobs) every week and each batch requires a sheet of special\r\ncolour-proofing paper of size A5.\r\nEvery Monday morning, the foreman opens a new envelope, containing a\r\nlarge sheet of the special paper with size A1.\r\nHe proceeds to cut it in half, thus getting two sheets of size A2.\r\nThen he cuts one of them in half to get two sheets of size A3 and so on\r\nuntil he obtains the A5-size sheet needed for the first batch of the\r\nweek.\r\nAll the unused sheets are placed back in the envelope.\r\n\r\nAt the beginning of each subsequent batch, he takes from the envelope\r\none sheet of paper at random. If it is of size A5, he uses it. If it is\r\nlarger, he repeats the ‘cut-in-half’ procedure until he has what he\r\nneeds and any remaining sheets are always placed back in the\r\nenvelope.\r\nExcluding the first and last batch of the week, find the expected\r\nnumber of times (during each week) that the foreman finds a single sheet\r\nof paper in the envelope.\r\nGive your answer rounded to six decimal places using the format\r\nx.xxxxxx.\r\n解决方案\r\n本题是一道比较明显的期望动态规划题，状态比较明显。\r\n每个状态用一个五元组\\((i_1,i_2,i_3,i_4,i_5)\\)为袋子里目前剩下纸张的情况，其中\\(i_j\\)就代表着剩下\\(i_j\\)张大小为Aj的纸。\r\n令\\(f(i_1,i_2,i_3,i_4,i_5)\\)为在这种剩余纸张情况下，未来会遇见一张纸的期望次数。\r\n题目中要求等概率地随机抽取一张纸：\r\n\r\n如果是A5直接用掉，相当于从\\((i_1,i_2,i_3,i_4,i_5-1)\\)中转移过来。\r\n否则，他会一直裁纸，直到见到一张A5，并且使用它。那么这种情况下如果是遇到Aj大小的纸，那么就是从\\((i_1,i_2,\\dots,i_{j-1},\\mathbf{i_j-1,i_{j+1}+1},\\dots,i_5+1)\\)转移过来。注意加粗的地方，使用的纸被消耗了，比它更小的纸都增加了一张。\r\n\r\n因此，状态转移方程如下：\r\n\\[\r\nf(i_1,i_2,i_3,i_4,i_5)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0  &amp; &amp; \\text{if}\\quad \\sum_{k=1}^5 i_k=0 \\\\\r\n  &amp;\\sum_{1\\le j\\le\r\n5,i_j&gt;0}f(\\dots,i_{j-1},i_{j}-1,i_{j+1}+1,\\dots)\\dfrac{i_k}{\\sum_{k=1}^5i_k}+\\left[\\sum_{k=1}^5i_k=1\\right]\r\n&amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n其中，\\([]\\)表示示性函数，表示\\([]\\)里面的值是否为真，如果为真，那么值为\\(1\\)，否则值为\\(0\\).\r\n整个递归的边界是纸被用完了，故值为\\(0\\).\r\n最终答案为\\(f(1,0,0,0,0)-2\\)，因为题目要求减去第一次和最后一次见到一张纸的情况。\r\n代码\r\nmp = &#123;(0, 0, 0, 0, 0): 0&#125;def dfs(tp: tuple):    if tp in mp.keys():        return mp[tp]    s = sum(tp)    val = (s == 1)    for i in range(5):        if tp[i] == 0:            continue        ls = list(tp)        ls[i] -= 1        for j in range(i + 1, 5):            ls[j] += 1        val += dfs(tuple(ls)) * tp[i] / s    mp[tp] = val    return valans = dfs((1, 0, 0, 0, 0)) - 2print(&quot;&#123;:.6f&#125;&quot;.format(ans))\r\n","categories":["Project Euler"],"tags":["动态规划","概率"]},{"title":"Project Euler 152","url":"/project-euler/152/","content":"\r\nProject Euler 152\r\n题目\r\nWriting \\(\\dfrac{1}{2}\\) as a sum of inverse\r\nsquares\r\nThere are several ways to write the number \\(\\dfrac{1}{2}\\) as a sum of inverse squares\r\nusing distinct integers.\r\nFor instance, the numbers \\(\\{2,3,4,5,7,12,15,20,28,35\\}\\) can be used:\r\n\\[\\dfrac{1}{2} = \\dfrac{1}{2^2} +\r\n\\dfrac{1}{3^2} + \\dfrac{1}{4^2} + \\dfrac{1}{5^2}+\r\n\\dfrac{1}{7^2} + \\dfrac{1}{12^2} + \\dfrac{1}{15^2} + \\dfrac{1}{20^2} +\r\n\\dfrac{1}{28^2} + \\dfrac{1}{35^2}\\]\r\nIn fact, only using integers between \\(2\\) and \\(45\\) inclusive, there are exactly three\r\nways to do it, the remaining two being: \\(\\{2,3,4,6,7,9,10,20,28,35,36,45\\}\\) and\r\n\\(\\{2,3,4,6,7,9,12,15,28,30,35,36,45\\}\\).\r\nHow many ways are there to write the number \\(\\dfrac{1}{2}\\) as a sum of inverse squares\r\nusing distinct integers between \\(2\\)\r\nand \\(80\\) inclusive?\r\n解决方案\r\n本解决方案参考了Thread中的一些内容。\r\n为减少枚举量，进行以下排除：\r\n\r\n考虑所有质数\\(p\\)，令\\(q=p^r\\)，其中\\(r\\)是使\\(p^r\\)不超过\\(N=80\\)的最大值。\r\n\r\n在这种情况下，考虑所有满足\\(kq\\le\r\nN\\)的分数\\(\\dfrac{1}{q^2},\\dfrac{1}{(2q)^2},\\dots,\\dfrac{1}{(kq)^2}\\)\r\n考虑计算\\(\\dfrac{1}{(i_1q)^2}+\\dfrac{1}{(i_2q)^2}+\\dots+\\dfrac{1}{(i_mq)^2}\\)，其中\\(i_j&lt;p\\)，不同的\\(i_j\\)之间两两不同。\r\n那么有\\(\\dfrac{1}{q^2}(\\dfrac{1}{i_1^2}+\\dfrac{1}{i_2^2}+\\dots+\\dfrac{1}{i_m^2})\\)\r\n如果在计算分数和的过程中，分母混进了一个非\\(2\\)的质数\\(p\\)，那么在以后求和的过程中必须消除分母\\(p\\)。因此\\(\\sum_{j=1}^m i_j^{-2}\\)在模\\(q^2\\)上与\\(0\\)同余。\r\n\r\n对于大于\\(\\dfrac{N}{2}\\)的质数而言，只有一个\\(m=1,i_1=1\\)，也就是\\(\\{1\\}\\)，不可能存在一个非空集合使得其子集和为\\(0\\)。故排除这一类情况。\r\n对于质数\\(p=11\\)，那么\\(i_j\\in[1,7]\\)，也就是说，\\(i_j^{-2}\\% p^2 \\in\\{1, 91, 27, 53, 92, 37,\r\n42\\}\\)，容易经过验证，没有一个非空子集的和为\\(p^2\\)，故排除\\(11\\)的所有倍数。\r\n对于质数\\(p=13\\)，那么\\(i_j\\in[1,6]\\)，也就是说，\\(i_j^{-2}\\% p^2 \\in\\{1, 127, 94, 74, 142,\r\n108\\}\\)，容易经过验证，只有\\(1+94+74=169\\)才是\\(p^2\\)的倍数，因此除了\\(13,39,52\\)，其它都可以排除。而且，这三个数只有一起用才能消除掉分母\\(13\\)。经计算得\\(\\dfrac{1}{13^2}+\\dfrac{1}{39^2}+\\dfrac{1}{52^2}=\\dfrac{1}{12^2}\\)，所以可以在候选集中多添加一个\\(12\\)。然后忽略这\\(3\\)个数。\r\n\r\n可以用类似的方法，排除掉以下这些数：\\(\\{17,34,51,68,19,38,57,76,23,46,69,27,54,29,58,49,64,...\\}\\)\r\n更进一步，如果\\(q=p^r\\)中的\\(r\\)不一定是满足最大值，上述\\(i_j\\)也只是满足\\(\\gcd(i_j,q)=1\\)，那么用类似的方法，可以将\\(\\{16,32,48,80\\}\\)排除。\r\n\r\n根据上面的排除结果，剩下的数中，\\(\\dfrac{1}{2^2},\\dfrac{1}{3^2}\\)一定是在集合中的，因为缺少了这两个数之一，剩下的分数的和小于\\(\\dfrac{1}{2}\\)。因此不需要对这两个数枚举，只要在最终和值\\(\\dfrac{1}{2}\\)中减去即可。\r\n\r\n按照上面的方法，最终只需要枚举\\(27\\)个数的组合情况。\r\n这里则使用meet-in-the-middle思想：先将分数分成尽量相同大小的两部分，然后子集枚举第一部分，并按子集和\\(s\\)将结果存储起来，然后子集枚举第二部分，求出\\(s&#39;\\)后，在第一部分的枚举结果中查找有没有那缺失的\\(s\\)，使得\\(s+s&#39;\\)是原来的问题的解。如果有，那就找到了解。\r\n代码\r\nfrom fractions import Fractionls = [4, 5, 6, 7, 8, 9, 10, 12, 12, 14, 15, 18, 20, 21, 24, 28, 30, 35, 36, 40, 42, 45, 56, 60, 63, 70, 72]ans = 0n = len(ls)the_sum = Fraction(1, 2) - Fraction(1, 4) - Fraction(1, 9)l, r = ls[:n // 2], ls[n // 2:]mp = &#123;&#125;for i in range(1 &lt;&lt; len(l)):    s = Fraction(0)    for j in range(len(l)):        if i &gt;&gt; j &amp; 1:            s += Fraction(1, l[j] * l[j])    if s &lt;= the_sum:        if s not in mp.keys():            mp[s] = 0        mp[s] += 1for i in range(1 &lt;&lt; len(r)):    s = Fraction(0)    for j in range(len(r)):        if i &gt;&gt; j &amp; 1:            s += Fraction(1, r[j] * r[j])    t = the_sum - s    if t in mp.keys():        ans += mp[t]print(ans)\r\n","categories":["Project Euler"],"tags":["meet-in-the-middle"]},{"title":"Project Euler 153","url":"/project-euler/153/","content":"\r\nProject Euler 153\r\n题目\r\nInvestigating Gaussian\r\nIntegers\r\nAs we all know the equation \\(x^2=-1\\) has no solutions for real \\(x\\).\r\nIf we however introduce the imaginary number \\(i\\) this equation has two solutions: \\(x=i\\) and \\(x=-i\\).\r\nIf we go a step further the equation \\((x-3)^2=-4\\) has two complex solutions:\r\n\\(x=3+2i\\) and \\(x=3-2i\\).\r\n\\(x=3+2i\\) and \\(x=3-2i\\) are called each others’ complex\r\nconjugate.\r\nNumbers of the form a+bi are called complex numbers.\r\nIn general a+bi and a−bi are each other’s complex conjugate.\r\nA Gaussian Integer is a complex number a+bi such that both a and b\r\nare integers.\r\nThe regular integers are also Gaussian integers (with \\(b=0\\)).\r\nTo distinguish them from Gaussian integers with \\(b \\neq 0\\) we call such integers “rational\r\nintegers.”\r\nA Gaussian integer is called a divisor of a rational integer \\(n\\) if the result is also a Gaussian\r\ninteger.\r\nIf for example we divide \\(5\\) by\r\n\\(1+2i\\) we can simplify \\(\\dfrac{5}{1+2i}\\) in the following\r\nmanner:\r\nMultiply numerator and denominator by the complex conjugate of \\(1+2i\\): \\(1−2i\\).\r\nThe result is \\(\\dfrac{5}{1 + 2i} =\r\n\\dfrac{5}{1 + 2i}\\dfrac{1 - 2i}{1 - 2i} = \\dfrac{5(1 - 2i)}{1 - (2i)^2}\r\n= \\dfrac{5(1 - 2i)}{1 - (-4)} = \\dfrac{5(1 - 2i)}{5} = 1 -\r\n2i\\).\r\nSo \\(1+2i\\) is a divisor of \\(5\\).\r\nNote that \\(1+i\\) is not a divisor\r\nof \\(5\\) because \\(\\dfrac{5}{1 + i} = \\dfrac{5}{2} -\r\n\\dfrac{5}{2}i\\).\r\nNote also that if the Gaussian Integer (\\(a+bi\\)) is a divisor of a rational integer\r\n\\(n\\), then its complex conjugate\r\n(\\(a−bi\\)) is also a divisor of \\(n\\). In fact, \\(5\\) has six divisors such that the real\r\npart is positive: \\(\\{1, 1 + 2i, 1 − 2i, 2 +\r\ni, 2 − i, 5\\}\\).\r\nThe following is a table of all of the divisors for the first five\r\npositive rational integers:\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nn\r\nGaussian integer divisors with positive real part\r\nSum \\(s(n)\\) of these divisors\r\n\r\n\r\n\r\n\r\n\\(1\\)\r\n\\(1\\)\r\n\\(1\\)\r\n\r\n\r\n\\(2\\)\r\n\\(1, 1+i, 1-i, 2\\)\r\n\\(5\\)\r\n\r\n\r\n\\(3\\)\r\n\\(1, 3\\)\r\n\\(4\\)\r\n\r\n\r\n\\(4\\)\r\n\\(1, 1+i, 1-i, 2, 2+2i,\r\n2-2i,4\\)\r\n\\(13\\)\r\n\r\n\r\n\\(5\\)\r\n\\(1, 1+2i, 1-2i, 2+i, 2-i, 5\\)\r\n\\(12\\)\r\n\r\n\r\n\r\nFor divisors with positive real parts, then, we have: \\(\\sum \\limits_{n = 1}^{5} {s(n)} = 35\\). For\r\n\\(\\sum \\limits_{n = 1}^{10^5} {s(n)} =\r\n17924657155\\). What is \\(\\sum\r\n\\limits_{n = 1}^{10^8} {s(n)}\\)?\r\n解决方案\r\n假设\\(N=10^8\\)。\r\n对于一个高斯整数\\(z=a+bi\\)，令\\(g=\\gcd(a,b)\\)，那么\\(z=g(a&#39;+b&#39;i),\\gcd(a&#39;,b&#39;)=1\\)。不难发现，如果\\(z\\)是某个整数的因子，当且仅当\\(z\\)是\\(z(a&#39;-b&#39;i)=g(a^2+b^2)\\)的因子。问题可以转化为：一个高斯整数\\(a+bi\\)将会对答案做出多少次贡献？\r\n枚举所有满足以下条件的高斯整数\\(a&#39;-b&#39;i\\)，数组\\(s[m]\\)归类并记录以下高斯整数的实部之和：\r\n\r\n\\(\\gcd(a&#39;,b&#39;)=1\\)\r\n\\(a&#39;&gt;0,b&#39;\\ge 0\\)\r\n\\(m=a&#39;^2+b&#39;^2\\)\r\n\r\n从小到大遍历\\(m\\)时，它里面是所有不同的\\(a&#39;-b&#39;i\\)的和的实数部分。那么再枚举此时的\\(g\\)，那么\\(s[m]\\cdot g\\)就是所有因子\\(g(a&#39;+b&#39;i)=a+bi\\)的实部之和，它们都是\\(g(a&#39;^2+b&#39;^2)=mg\\)的因子，而在\\(1\\sim N\\)中，有\\(\\left\\lfloor\\dfrac{N}{mg}\\right\\rfloor\\)个数是\\(mg\\)的倍数，这些因子都会出现\\(\\left\\lfloor\\dfrac{N}{mg}\\right\\rfloor\\)次。\r\n因此，最终答案为\r\n\\[\\sum_{m=1}^N\\sum_{g=1}^{\\left\\lfloor\\frac{N}{m}\\right\\rfloor}s[m]\\cdot\r\ng\\cdot \\dfrac{N}{mg}\\]\r\n为了能够尽快计算出\\(s\\)数组，需要做以下事情：\r\n\r\n三个特殊高斯整数\\(1+0i,1+1i,1-1i\\)要预处先记录在\\(s\\)中，它们的实部和虚部的最大公因数都是\\(1\\)。\r\n本质上，每一对数\\((x,y)(x&gt;y&gt;0)\\)都可以做出\\(2(x+y)\\)的贡献，这是因为它可以提供四个高斯整数：\\(x+yi,x-yi,y+xi,y-xi\\)。这将枚举量减少到了原来的\\(\\dfrac{1}{4}\\).\r\n\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 100000000;// s[m]记录所有复数a+bi满足|a+bi|=m,gcd(a,b)=1,a&gt;0的实部和。ll s[N+4];int main() &#123;    ll ans = 0;    s[1] = 1;s[2] = 2;    for (int i = 1; i * i &lt;= N; i++) &#123;        for (int j = i + 1; i * i + j * j &lt;= N; j++) &#123;            if (__gcd(i, j) == 1) &#123;                s[i * i + j * j] += 2 * i + 2 * j;            &#125;        &#125;    &#125;    for (int i = 1; i &lt;= N; i++)        if (s[i] &gt; 0)            for (int g = 1; g * i &lt;= N; g++)                ans += g * s[i] * (N / (g * i));    printf(&quot;%lld\\n&quot;, ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 154","url":"/project-euler/154/","content":"\r\nProject Euler 154\r\n题目\r\nExploring Pascal’s pyramid\r\nA triangular pyramid is constructed using spherical balls so that\r\neach ball rests on exactly three balls of the next lower level.\r\n\r\nThen, we calculate the number of paths leading from the apex to each\r\nposition:\r\nA path starts at the apex and progresses downwards to any of the\r\nthree spheres directly below the current position.\r\nConsequently, the number of paths to reach a certain position is the\r\nsum of the numbers immediately above it (depending on the position,\r\nthere are up to three numbers above it).\r\nThe result is Pascal’s pyramid and the numbers at each level\r\nn are the coefficients of the trinomial expansion \\((x + y + z)^n\\).\r\nHow many coefficients in the expansion of \\((x + y + z)^{200000}\\) are multiples of\r\n\\(10^{12}\\)?\r\n解决方案\r\n多项式定理是二项式定理的扩展。这里我们使用其三项式的形式。\r\n因此，将\\((x+y+z)^n\\)展开后，有：\r\n\\[(x+y+z)^n=\\sum_{i=0}^n\\sum_{j=0}^{n-i}\\dbinom{n}{i}\\dbinom{n-i}{j}x^iy^jz^{n-i-j}\\]\r\n其中，明显可以看出，\\(\\dbinom{n}{i}\\dbinom{n-i}{j}=\\dfrac{n!}{i!j!(n-i-j)!}\\)。\r\n预先计算\\(i!(0\\le i\\le\r\nn)\\)中分别有多少个质因数\\(2,5\\)。然后直接枚举每个项的系数，根据这个三项式系数的定义式判断是否有\\(12\\)个质因子\\(2\\)和\\(12\\)个质因子\\(5\\)。\r\n不过，由于多项式中的项\\(x,y,z\\)是无序的，因此可以通过假定\\(x,y,z\\)的次数\\(i,j,n-i-j\\)满足\\(i\\le j\\le n-i-j\\)，减少枚举量。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=200000;const int B=12;int f2[N+4],f5[N+4];int c2=B,c5=B;void solve(int w,int &amp;c2,int &amp;c5)&#123;    c2=c5=0;    for(;w%2==0;w/=2,++c2);    for(;w%5==0;w/=5,++c5);&#125;int main()&#123;    for(int i=2,c2,c5;i&lt;=N;i++)&#123;        solve(i,c2,c5);        f2[i]=f2[i-1]+c2;        f5[i]=f5[i-1]+c5;    &#125;    ll ans=0;    for(int i=0;i*3&lt;=N;i++)&#123;        for(int j=i;j+j&lt;=N-i;j++)&#123;            int k=N-i-j;            int cnt2=f2[N]-f2[i]-f2[j]-f2[k],cnt5=f5[N]-f5[i]-f5[j]-f5[k];            if(cnt2&gt;=c2&amp;&amp;cnt5&gt;=c5)&#123;                if(i==j&amp;&amp;j==k) ++ans;                else if(i==j||j==k) ans+=3;                else ans+=6;            &#125;        &#125;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 155","url":"/project-euler/155/","content":"\r\nProject Euler 155\r\n题目\r\nCounting Capacitor Circuits\r\nAn electric circuit uses exclusively identical capacitors of the same\r\nvalue \\(C\\).\r\nThe capacitors can be connected in series or in parallel to form\r\nsub-units, which can then be connected in series or in parallel with\r\nother capacitors or other sub-units to form larger sub-units, and so on\r\nup to a final circuit.\r\nUsing this simple procedure and up to n identical capacitors, we can\r\nmake circuits having a range of different total capacitances. For\r\nexample, using up to \\(n=3\\) capacitors\r\nof \\(60\\mu F\\) each, we can obtain the\r\nfollowing \\(7\\) distinct total\r\ncapacitance values:\r\n\r\nIf we denote by \\(D(n)\\) the number\r\nof distinct total capacitance values we can obtain when using up to n\r\nequal-valued capacitors and the simple procedure described above, we\r\nhave: \\(D(1)=1, D(2)=3, D(3)=7\r\n\\dots\\)\r\nFind \\(D(18)\\).\r\nReminder : When connecting capacitors \\(C_1, C_2\\) etc in parallel, the total\r\ncapacitance is \\(C_T=C_1+C_2+\\dots\\),\r\nwhereas when connecting them in series, the overall capacitance is given\r\nby:\\(\\dfrac{1}{C_T}=\\dfrac{1}{C_1}+\\dfrac{1}{C_2}+\\dots\\).\r\n解决方案\r\n目前的办法应该只有暴力枚举，剩下的只是优化：\r\n\r\n为减少枚举量，如果全局集合已经有的值，那就不需要继续添加到当前集合了。\r\n实现一个简易的分数类，避免用浮点数产生误差，同时避免进行除法操作。\r\n\r\n枚举的思想：如果已经有一对整体的电容值分别是\\(u,v\\)，那么分别把这两“块”进行串联或者并联，得到新值\\(\\dfrac{1}{\\dfrac{1}{u}+\\dfrac{1}{v}},u+v\\)。\r\n这个数列在OEIS上的查询结果为A153588。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 18;struct Fraction&#123;    ll num,den;    Fraction operator + (Fraction f)&#123;        ll a = num*f.den+den*f.num;        ll b = den*f.den;        ll g=__gcd(a,b);        return &#123;a/g,b/g&#125;;    &#125;    Fraction inv()&#123;        return &#123;den,num&#125;;    &#125;    //这里的小于只是为了用于区分分数的不同，而并非是分数的值大小本身。    bool operator &lt; (const Fraction &amp;f) const&#123;        return num&lt;f.num||num==f.num&amp;&amp;den&lt;f.den;    &#125;&#125;;set&lt;Fraction&gt;st,now[N+2];int main()&#123;    st.insert(Fraction&#123;1,1&#125;);    now[1].insert(Fraction&#123;1,1&#125;);    for(int i=2;i&lt;=N;i++)&#123;        for(int j=1;j&lt;=i/2;j++)&#123;            for(Fraction u:now[j])&#123;                for(Fraction v:now[i-j])&#123;                    Fraction x=u+v,y=(u.inv()+v.inv()).inv();                    if(!st.count(x))&#123;                        st.insert(x);                        now[i].insert(x);                    &#125;                    if(!st.count(y))&#123;                        st.insert(y);                        now[i].insert(y);                    &#125;                &#125;            &#125;        &#125;    &#125;    int ans=st.size();    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["OEIS"]},{"title":"Project Euler 156","url":"/project-euler/156/","content":"\r\nProject Euler 156\r\n题目\r\nCounting Digits\r\nStarting from zero the natural numbers are written down in base 10\r\nlike this: \\(0\\ 1\\ 2\\ 3\\ 4\\ 5\\ 6\\ 7\\ 8\\ 9\\ 10\\\r\n11\\ 12\\ \\dots.\\)\r\nConsider the digit d=1. After we write down each number n, we will\r\nupdate the number of ones that have occurred and call this number\r\nf(n,1). The first values for f(n,1), then, are as follows:\r\n\r\n\r\n\r\n\\(n\\)\r\n\\(f(n,1)\\)\r\n\r\n\r\n\r\n\r\n\\(0\\)\r\n\\(0\\)\r\n\r\n\r\n\\(1\\)\r\n\\(1\\)\r\n\r\n\r\n\\(2\\)\r\n\\(1\\)\r\n\r\n\r\n\\(3\\)\r\n\\(1\\)\r\n\r\n\r\n\\(4\\)\r\n\\(1\\)\r\n\r\n\r\n\\(5\\)\r\n\\(1\\)\r\n\r\n\r\n\\(6\\)\r\n\\(1\\)\r\n\r\n\r\n\\(7\\)\r\n\\(1\\)\r\n\r\n\r\n\\(8\\)\r\n\\(1\\)\r\n\r\n\r\n\\(9\\)\r\n\\(1\\)\r\n\r\n\r\n\\(10\\)\r\n\\(2\\)\r\n\r\n\r\n\\(11\\)\r\n\\(4\\)\r\n\r\n\r\n\\(12\\)\r\n\\(5\\)\r\n\r\n\r\n\r\nNote that \\(f(n,1)\\) never equals\r\n\\(3\\).\r\nSo the first two solutions of the equation \\(f(n,1)=n\\) are \\(n=0\\) and \\(n=1\\). The next solution is \\(n=199981\\).\r\nIn the same manner the function \\(f(n,d)\\) gives the total number of digits d\r\nthat have been written down after the number \\(n\\) has been written.\r\nIn fact, for every digit \\(d \\neq\r\n0\\), \\(0\\) is the first solution\r\nof the equation \\(f(n,d)=n\\).\r\nLet \\(s(d)\\) be the sum of all the\r\nsolutions for which \\(f(n,d)=n\\).\r\nYou are given that \\(s(1)=22786974071\\).\r\nFind \\(\\sum s(d)\\) for \\(1 \\leq d \\leq 9\\).\r\nNote: if, for some \\(n\\), \\(f(n,d)=n\\) for more than one value of \\(d\\) this value of \\(n\\) is counted again for every value of\r\n\\(d\\) for which \\(f(n,d)=n\\).\r\n解决方案\r\n\\(f(n,d)\\)可以以\\(O(\\log\r\nn)\\)的时间复杂度被计算出来。具体计算方法是计算每个数位下\\(d\\)的贡献，不过这里需要一些实现细节。\r\n可以发现，方程\\(f(n,d)=n\\)的解明显不超过\\(10^{12}\\)。因为在此之后的数，当\\(n\\)增加\\(1\\)，\\(f(n,d)\\)增加的期望超过\\(1\\)（为\\(\\dfrac{n}{10}\\)，可以假设每个数位被选中某个数的概率是相等的)，\\(f(n,d)\\)和\\(n\\)的差距只会越来越大。(\\(10^{10}\\sim10^{12}\\)这一部分数用于保证边缘值被找到。)\r\n枚举\\(n\\)，如果\\(n\\)和\\(f(n,d)\\)相等，那么找到了一个解。否则为了尽快弥补差距，可以假设接下来的数的所有数位都是（不是）\\(d\\)，那么可以对\\(n\\)增加\\(\\left\\lfloor\\dfrac{|n-f(n,d)|}{\\left\\lfloor\\log_{10}n\\right\\rfloor+1}\\right\\rfloor\\)。\r\n需要注意的是，每到达一个\\(10^m\\)（\\(10\\)的幂），\\(n\\)的数位就多\\(1\\)。因此，为了避免\\(10^m\\)附近的数被跳过忽略，每次都从\\(10^m\\)开始枚举，到达\\(10^{m+1}\\)时结束枚举。\r\n容易发现这种枚举方式效率较高，很快得出答案。\r\n代码\r\nN = 12def f(n: int, d: int):    ans = 0    i = 1    while n // i:        j = n // i        high = j // 10        if d == 0:            if high:                high -= 1            else:                break        ans += high * i        tp = j % 10        if tp &gt; d:            ans += i        elif tp == d:            ans += n - j * i + 1        i *= 10    return anspw = [1]for i in range(N):    pw.append(pw[-1] * 10)ans = 0for j in range(1, 9 + 1):    i = 1    lg = 0    while i &lt;= pw[-2]:        v = abs(i - f(i, j))        if v == 0:            ans += i            i += 1        else:            i += (v + lg) // (lg + 1)            if i &gt;= pw[lg + 1]:                lg += 1                i = pw[lg]print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 157","url":"/project-euler/157/","content":"\r\nProject Euler 157\r\n题目\r\nSolving\r\nthe diophantine equation \\(\\dfrac{1}{a}+\\dfrac{1}{b}=\\dfrac{p}{10^n}\\)\r\nConsider the diophantine equation \\(\\dfrac{1}{a}+\\dfrac{1}{b}=\\dfrac{p}{10^n}\\)\r\nwith \\(a, b, p, n\\) positive integers\r\nand \\(a \\leq b\\).\r\nFor \\(n=1\\) this equation has \\(20\\) solutions that are listed below:\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\\(\\dfrac{1}{1}+\\dfrac{1}{1}=\\dfrac{20}{10}\\)\r\n\\(\\dfrac{1}{1}+\\dfrac{1}{2}=\\dfrac{15}{10}\\)\r\n\\(\\dfrac{1}{1}+\\dfrac{1}{5}=\\dfrac{12}{10}\\)\r\n\\(\\dfrac{1}{1}+\\dfrac{1}{10}=\\dfrac{11}{10}\\)\r\n\\(\\dfrac{1}{2}+\\dfrac{1}{2}=\\dfrac{10}{10}\\)\r\n\r\n\r\n\\(\\dfrac{1}{2}+\\dfrac{1}{5}=\\dfrac{7}{10}\\)\r\n\\(\\dfrac{1}{2}+\\dfrac{1}{10}=\\dfrac{6}{10}\\)\r\n\\(\\dfrac{1}{3}+\\dfrac{1}{6}=\\dfrac{5}{10}\\)\r\n\\(\\dfrac{1}{3}+\\dfrac{1}{15}=\\dfrac{4}{10}\\)\r\n\\(\\dfrac{1}{4}+\\dfrac{1}{4}=\\dfrac{5}{10}\\)\r\n\r\n\r\n\\(\\dfrac{1}{4}+\\dfrac{1}{20}=\\dfrac{3}{10}\\)\r\n\\(\\dfrac{1}{5}+\\dfrac{1}{5}=\\dfrac{4}{10}\\)\r\n\\(\\dfrac{1}{5}+\\dfrac{1}{10}=\\dfrac{3}{10}\\)\r\n\\(\\dfrac{1}{6}+\\dfrac{1}{30}=\\dfrac{2}{10}\\)\r\n\\(\\dfrac{1}{10}+\\dfrac{1}{10}=\\dfrac{2}{10}\\)\r\n\r\n\r\n\\(\\dfrac{1}{11}+\\dfrac{1}{110}=\\dfrac{1}{10}\\)\r\n\\(\\dfrac{1}{12}+\\dfrac{1}{60}=\\dfrac{1}{10}\\)\r\n\\(\\dfrac{1}{14}+\\dfrac{1}{35}=\\dfrac{1}{10}\\)\r\n\\(\\dfrac{1}{15}+\\dfrac{1}{30}=\\dfrac{1}{10}\\)\r\n\\(\\dfrac{1}{20}+\\dfrac{1}{20}=\\dfrac{1}{10}\\)\r\n\r\n\r\n\r\nHow many solutions has this equation for \\(1 \\leq n \\leq 9\\)?\r\n解决方案\r\n将\\(p\\)移项，得到\\(\\dfrac{1}{pa}+\\dfrac{1}{pb}=\\dfrac{1}{10^n}\\)，这是方程\\(\\dfrac{1}{x}+\\dfrac{1}{y}=\\dfrac{1}{n}\\)的一个具体例子。\r\n解该方程的方法在108题中提到：\r\n\r\n将式子\\(\\dfrac{1}{x}+\\dfrac{1}{y}=\\dfrac{1}{n}\\)进行去除分母，再进行移项后得到：\\(x=\\dfrac{ny}{y-n}\\).\r\n令\\(t=y-n\\)，那么\\(y=n+t\\)，代入原式子，得到：\\(x=\\dfrac{n(n+t)}{t}=\\dfrac{n^2}{t}+n\\).\r\n如果\\(x\\)是一个整数，那么\\(t \\mid n^2\\)。\r\n那么，\\(t\\)取遍\\(n^2\\)的各个因数，\\(x\\)也取遍不同的值。\r\n\r\n回到本题，我们可以枚举出\\(10^n\\)的所有因子，从而解得\\(x\\)和\\(y\\)（也就是\\(pa\\)和\\(pb\\)）的值。令\\(g=\\gcd(x,y)\\)，那么\\(g\\)中的每一个因数\\(p\\)，都会对答案做出一次贡献。所有贡献相加即可。\r\n代码\r\nfrom tools import divisors, divisors_sigma, gcdN = 9ans = 0for n in [10 ** i for i in range(1, N + 1)]:    for t in divisors(n * n):        if t &lt;= n:            # divisors_sigma(n,0) 返回n的因子个数。            ans += divisors_sigma(gcd(n * n // t + n, n + t),0)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 16","url":"/project-euler/16/","content":"\r\nProject Euler 16\r\n题目\r\nPower digit sum\r\n\\(2^{16} = 32768\\) and the sum of\r\nits digits is \\(3 + 2 + 7 + 6 + 8 =\r\n26\\). What is the sum of the digits of the number \\(2^{1000}\\)?\r\n解决方案\r\n利用Python可以计算大数的性质，可以直接将\\(2^{1000}\\)本身计算出来。\r\n然后通过一些方法将数位提取出来相加。\r\n代码\r\nN = 2 ** 1000ans = sum(list(map(int, str(N))))print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 159","url":"/project-euler/159/","content":"\r\nProject Euler 159\r\n题目\r\nDigital root sums of\r\nfactorisations\r\nA composite number can be factored many different ways. For instance,\r\nnot including multiplication by one, \\(24\\) can be factored in \\(7\\) distinct ways:\r\n\\(\\begin{aligned}\r\n24 &amp;= 2\\times2\\times2\\times3 \\\\\r\n24 &amp;= 2\\times3\\times4 \\\\\r\n24 &amp;= 2\\times2\\times6 \\\\\r\n24 &amp;= 4\\times6 \\\\\r\n24 &amp;= 3\\times8\\\\\r\n24 &amp;= 2\\times12\\\\\r\n24 &amp;= 24\r\n\\end{aligned}\\)\r\nRecall that the digital root of a number, in base \\(10\\), is found by adding together the\r\ndigits of that number, and repeating that process until a number is\r\narrived at that is less than \\(10\\).\r\nThus the digital root of \\(467\\) is\r\n\\(8\\).\r\nWe shall call a Digital Root Sum (DRS) the sum of the digital roots\r\nof the individual factors of our number.\r\nThe chart below demonstrates all of the DRS values for \\(24\\).\r\n\r\n\r\n\r\nFactorisation\r\nDigital Root Sum\r\n\r\n\r\n\r\n\r\n\\(2 \\times2 \\times2 \\times3\\)\r\n\\(9\\)\r\n\r\n\r\n\\(2 \\times3 \\times4\\)\r\n\\(9\\)\r\n\r\n\r\n\\(2 \\times2 \\times6\\)\r\n\\(10\\)\r\n\r\n\r\n\\(4 \\times6\\)\r\n\\(10\\)\r\n\r\n\r\n\\(3 \\times8\\)\r\n\\(11\\)\r\n\r\n\r\n\\(2 \\times12\\)\r\n\\(5\\)\r\n\r\n\r\n\\(24\\)\r\n\\(6\\)\r\n\r\n\r\n\r\nThe maximum Digital Root Sum of \\(24\\) is \\(11\\).\r\nThe function \\(\\text{mdrs}(n)\\)\r\ngives the maximum Digital Root Sum of \\(n\\). So \\(\\text{mdrs}(24)=11\\).\r\nFind \\(\\sum \\text{mdrs}(n)\\) for\r\n\\(1 &lt; n &lt; 1,000,000\\).\r\n解决方案\r\n可以证明，数根的值\\(r(x)=(x-1)\\%9+1\\)，也就是当\\(x\\)为\\(9\\)的倍数时，\\(r(x)=9\\)，否则\\(r(x)=x\\%9\\)。特别的，\\(r(0)=0\\)。\r\n由于任意一个\\(k\\)位十进制数\\(d=d_{k-1}...d_2d_1d_0\\)都可以写成如下形式的多项式：\r\n\\[d=\\sum_{i=0}^{k=1}d_i 10^i\\]\r\n因此，假设\\(s(d)\\)为\\(d\\)的数位和，那么有：\r\n\\[s(d)=\\sum_{i=0}^{k-1}d_i\\equiv\r\n\\sum_{i=0}^{k-1}d_i10^i \\pmod {10}\\]\r\n这说明，数位和的值\\(s(d)\\)和数本身的值\\(d\\)关于\\(9\\)同余。因此进行有限次操作后，最终得到的一位数的数字根一定和原来的数关于同余。由于正数的数位和一定大于\\(0\\)，因此有\\(r(x)=(x-1)\\%9+1\\)。\r\n回到本题，通过类似埃氏筛法的思想，对于每个数\\(n\\)，用一个集合\\(D_n\\)存储\\(n\\)的除了\\(1\\)和\\(n\\)以外的所有不大于\\(\\sqrt{n}\\)的因子。\r\n基于动态规划的思想，可以想到，将每个数\\(i\\)拆成两个非平凡因子（即不为\\(1\\)或\\(n\\)）\\(d\\)和\\(\\dfrac{i}{d}\\)的乘积。那么，\\(\\text{mdrs}(d)+\\text{mdrs}\\left(\\dfrac{i}{d}\\right)\\)有可能成为\\(\\text{mdrs}(i)\\)。\r\n设\\(f(i)=\\text{mdrs(i)}(i\\ge\r\n1)\\)。因此，可以列出如下状态转移方程：\r\n\\[\r\nf(i)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i=1 \\\\\r\n  &amp;\\max\\left(r(i),\\max_{d\\in\r\nD_i}\\left\\{f(d)+f\\left(\\dfrac{i}{d}\\right)\\right\\}\\right)  &amp; &amp;\r\n\\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n最终答案为\\(\\sum_{i=2}^{N-1}f(i)\\)。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;const int N=1000000;typedef long long ll;vector&lt;int&gt;g[N+4];int f[N+4];int fun(int x)&#123;    return x%9?x%9:9;&#125;int main()&#123;    for(int i=2;i&lt;N;i++)&#123;        for(ll j=1ll*i*i;j&lt;N;j+=i)            g[j].push_back(i);    &#125;    int ans=0;    for(int i=2;i&lt;N;i++)&#123;        f[i]=fun(i);        for(int x:g[i])            f[i]=max(f[i],f[x]+f[i/x]);        ans+=f[i];    &#125;    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 160","url":"/project-euler/160/","content":"\r\nProject Euler 160\r\n题目\r\nFactorial trailing digits\r\nFor any \\(N\\), let \\(f(N)\\) be the last five digits before the\r\ntrailing zeroes in \\(N!\\).\r\nFor example, \\(9! = 362880\\) so\r\n\\(f(9)=36288\\) \\(10! = 3628800\\) so \\(f(10)=36288\\) \\(20! = 2432902008176640000\\) so \\(f(20)=17664\\)\r\nFind \\(f(1,000,000,000,000)\\)\r\n解决方案\r\n令函数\\(c(n)=\\sum_{r\\ge 1,5^r\\le n}\r\n\\left\\lfloor\\dfrac{n}{5^r}\\right\\rfloor\\)，即\\(n!\\)的后置\\(0\\)个数。容易知道，\\(c(n)\\)能够以\\(O(\\log n)\\)的时间复杂度被计算出来。\r\n令函数\\(g(n)=\\prod_{i=1,5\\nmid\r\ni}^ni\\)，那么可得\\(f(n)=g(n)f(\\left\\lfloor\\dfrac{n}{5}\\right\\rfloor)\\%10^5\\)\r\n令函数\\(f_5(n)=f(n)\\%5^5\\)，那么\\(f_5(n)=g(5^5)^{\\lfloor\r\nn/5^5\\rfloor}g(n\\%5^5)f_5(\\left\\lfloor\\dfrac{n}{5}\\right\\rfloor)\\%5^5\\)。\r\n容易计算得\\(g(5^5)\\%5^5=-1\\)，那么上式变成\\(f_5(n)=(-1)^{\\lfloor\r\nn/5^5\\rfloor}g(n\\%5^5)f_5(\\left\\lfloor\\dfrac{n}{5}\\right\\rfloor)\\%5^5\\)\r\n\\(f_5(n)\\)的值将能够迅速计算出。容易知道，只要\\(n\\)足够大，\\(\\dfrac{n!}{10^{c(n)}}\\)的\\(2\\)的质因数个数将会很多。因此，可以直接假设\\(\\dfrac{n!}{10^{c(n)}}\\equiv 0 \\pmod\r\n{2^5}\\)。\r\n根据中国剩余定理，直接解以下方程即可得到答案：\r\n\\(\\left\\{\\begin{aligned}\r\n  &amp; x \\equiv 0 \\pmod {2^5} \\\\\r\n  &amp; x \\equiv f_5(n) \\pmod {5^5}\r\n\\end{aligned}\\right.\\)\r\n但是，在\\(n\\)比较小时，需要通过暴力来规避默认\\(2^5\\)。\r\n代码\r\nfrom tools import facN = 10 ** 12M = 5g = [1]pw5 = 5 ** Mdef f5(n):    inv2 = (pw5 + 1) &gt;&gt; 1    ans = pow(inv2, count0(N), pw5) % pw5    while n:        ans = ans * (-1) ** (n // pw5) * g[n % pw5] % pw5        n //= 5    return ansdef count0(n: int):    ans = 0    while n:        ans += n // 5        n //= 5    return ansif N &lt;= M * 2 + 20 + M:    w = str(fac(N)).rstrip(&#x27;0&#x27;)[-5:]    ans = int(w)else:    for i in range(1, pw5):        if i % 5 == 0:            g.append(g[-1])        else:            g.append(g[-1] * i % pw5)    r5 = f5(N)    # 293为2^5在5^5上的逆元，29为5^5在2^5上的逆元。    ans = (r5 * (2 ** M) * 293 + 0 * (5 ** M) * 29) % 10 ** 5print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 161","url":"/project-euler/161/","content":"\r\nProject Euler 161\r\n题目\r\nTriominoes\r\nA triomino is a shape consisting of three squares joined via the\r\nedges. There are two basic forms:\r\n\r\nIf all possible orientations are taken into account there are\r\nsix:\r\n\r\nAny \\(n\\) by \\(m\\) grid for which \\(n\\times m\\) is divisible by \\(3\\) can be tiled with triominoes.\r\nIf we consider tilings that can be obtained by reflection or rotation\r\nfrom another tiling as different there are \\(41\\) ways a \\(2\\) by \\(9\\) grid can be tiled with triominoes:\r\n\r\nIn how many ways can a \\(9\\) by\r\n\\(12\\) grid be tiled in this way by\r\ntriominoes?\r\n解决方案\r\n一个明显的优化：如果列的长度比行大，那么可以行列互换。为了加速，明显应该用位运算来表示列的状态（因为它的长度短）。\r\n使用动态规划的思想进行计数。为了使得计数不重合，那么使用以下方法：每次选定填充的格子，必定是行下标最下的格子（如果有多个，那么就选列下标最小的）。在这个选定的格子中，依次尝试填入\\(6\\)个种类的方块。\r\n由于每次填入的方块最多\\(3\\)行，因此本代码记录状态时，每次都要表示\\(3\\)行的状态。\r\n如果发现第一行被填完了，那么就可以忽略掉这一行，直接从下一行开始填。\r\n本题还使用记忆化搜索，避免再度搜索已经检查过的状态。\r\n下面的py代码是解答时写的，C++代码是解答后看了一些优化方案然后再写的。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;# define Y secondtypedef long long ll;using namespace std;const int H = 9, W = 12;const int N = max(H, W), M = min(H, W);const int msk = (1 &lt;&lt; M) - 1;int low_zero[1&lt;&lt;M];unordered_map&lt;ll, ll&gt; mp[N + 2];ll dfs(int f, int r1, int r2, int r3) &#123;    if (f == 0)        return 1;    if (r1 == msk)        return dfs(f - 1, r2, r3, 0);    ll h = (r1 &lt;&lt; M | r2) &lt;&lt; M | r3;    auto it = mp[f].find(h);    if (it != mp[f].end())        return it-&gt;Y;    int pos = low_zero[r1];    ll ans = 0;    // 1    if (f &gt;= 2 &amp;&amp; pos &lt; M - 1 &amp;&amp; !(r1 &gt;&gt; pos &amp; 3) &amp;&amp; !(r2 &gt;&gt; pos &amp; 1))        ans += dfs(f, r1|3&lt;&lt;pos, r2|1&lt;&lt;pos, r3);    // 2    if (f &gt;= 2 &amp;&amp; pos &lt; M - 1 &amp;&amp; !(r1 &gt;&gt; pos &amp; 3) &amp;&amp; !(r2 &gt;&gt; pos &amp; 2))        ans += dfs(f, r1|3&lt;&lt;pos, r2|2&lt;&lt;pos, r3);    // 3    if (f &gt;= 2 &amp;&amp; pos &lt; M - 1 &amp;&amp; !(r1 &gt;&gt; pos &amp; 1) &amp;&amp; !(r2 &gt;&gt; pos &amp; 3))        ans += dfs(f, r1|1&lt;&lt;pos, r2|3&lt;&lt;pos, r3);    // 4    if (f &gt;= 2 &amp;&amp; pos &gt; 0 &amp;&amp; pos &lt; M &amp;&amp; !(r1 &gt;&gt; pos &amp; 1) &amp;&amp; !(r2 &gt;&gt; (pos - 1) &amp; 3))        ans += dfs(f, r1|1&lt;&lt;pos, r2|3&lt;&lt;(pos-1), r3);    // 5    if (f &gt;= 3 &amp;&amp; !((r1 | r2 | r3) &gt;&gt; pos &amp; 1))        ans += dfs(f, r1 | 1 &lt;&lt; pos, r2 | 1 &lt;&lt; pos, r3 | 1 &lt;&lt; pos);    // 6    if (f &gt;= 1 &amp;&amp; pos &lt; M - 2 &amp;&amp; !(r1 &gt;&gt; pos &amp; 7))        ans += dfs(f, r1 | 7 &lt;&lt; pos, r2, r3);    return mp[f][h] = ans;&#125;int main() &#123;    for (int s = 0; s &lt; (1 &lt;&lt; M); s++)        for (low_zero[s] = 0; low_zero[s] &lt; M &amp;&amp; (s &gt;&gt; low_zero[s] &amp; 1); low_zero[s]++);    ll ans = dfs(N, 0, 0, 0);    printf(&quot;%lld\\n&quot;, ans);    return 0;&#125;\r\nN, M = 9, 12triomino_ls = [    [(0, 0), (1, 0), (0, 1)],    [(0, 0), (1, 0), (1, 1)],    [(0, 0), (0, 1), (1, 1)],    [(0, 0), (1, 0), (1, -1)],    [(0, 0), (0, 1), (0, 2)],    [(0, 0), (1, 0), (2, 0)],]if M &gt; N:    N, M = M, Ndef get_empty(grid: tuple):    for i in range(len(grid)):        if grid[i] != (1 &lt;&lt; M) - 1:            for j in range(M):                if (grid[i] &gt;&gt; j &amp; 1) == 0:                    return i, j    return Nonedef place_triomino(grid: tuple, x: int, y: int, id: int):    tp = list(grid)    for dx, dy in triomino_ls[id]:        nx, ny = x + dx, y + dy        if nx &lt; 0 or ny &lt; 0 or nx &gt;= len(grid) or ny &gt;= M or tp[nx] &gt;&gt; ny &amp; 1:            return None        tp[nx] |= 1 &lt;&lt; ny    while len(tp) &gt; 0 and tp[0] == (1 &lt;&lt; M) - 1:        del tp[0]    return tuple(tp)cnt = M * N // 3st = tuple(0 for i in range(N))f = [&#123;&#125; for i in range(cnt + 1)]f[0][st] = 1for i in range(cnt):    for grid, val in f[i].items():        x, y = get_empty(grid)        for k in range(6):            next = place_triomino(grid, x, y, k)            if next is None:                continue            if next not in f[i + 1].keys():                f[i + 1][next] = 0            f[i + 1][next] += valans = list(f[cnt].values())[0]print(ans)\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 162","url":"/project-euler/162/","content":"\r\nProject Euler 162\r\n题目\r\nHexadecimal numbers\r\nIn the hexadecimal number system numbers are represented using \\(16\\) different digits:\r\n\\[0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F\\]\r\nThe hexadecimal number \\(AF\\) when\r\nwritten in the decimal number system equals \\(10\\times 16+15=175\\).\r\nIn the \\(3\\)-digit hexadecimal\r\nnumbers \\(10A\\), \\(1A0\\), \\(A10\\), and \\(A01\\) the digits \\(0,1\\) and \\(A\\) are all present.\r\nLike numbers written in base ten we write hexadecimal numbers without\r\nleading zeroes.\r\nHow many hexadecimal numbers containing at most sixteen hexadecimal\r\ndigits exist with all of the digits \\(0,1\\), and \\(A\\) present at least once?\r\nGive your answer as a hexadecimal number.\r\n(\\(A,B,C,D,E\\) and \\(F\\) in upper case, without any leading or\r\ntrailing code that marks the number as hexadecimal and without leading\r\nzeroes , e.g. 1A3F and not: 1a3f and not 0x1a3f and not $1A3F and not\r\n#1A3F and not 0000001A3F)\r\n解决方案\r\n一道明显的数位动态规划。每次都可以在一个数后面添加\\(16\\)种位。\r\n因此，令\\(N=16\\)，假设\\(f(i,j)(i\\ge 1,0\\le j\\le3)\\)为\\(i\\)位十六进制数中，已经使用了\\(0,1,A\\)中的\\(j\\)个数位的数有多少个。那么可以列出如下状态转移方程：\r\n\\[\r\nf(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;2  &amp; &amp; \\text{if}\\quad i=1\\land j=1 \\\\\r\n  &amp;13 &amp; &amp; \\text{else if}\\quad i=1\\land j=0\\\\\r\n  &amp;13f(i-1,j) &amp; &amp; \\text{else if}\\quad j=0\\\\\r\n  &amp;(13+j)f(i-1,j)+(4-j)f(i-1,j-1) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n在最后一行有两个方法：要么在一个\\(i-1\\)使用并且已经用过的\\(j\\)种数位，有\\((13+j)f(i-j,1)\\)种添加方法；要么添加一个要求使用却未使用的数位，有\\((4-j)f(i-1,j-1)\\)种添加方法。\r\n最终答案为\\(\\sum_{i=1}^nf(i,3)\\)。\r\n代码\r\nN = 16f = [[0, 0, 0, 0] for i in range(N + 1)]f[1][0] = 13f[1][1] = 2for i in range(2, N + 1):    for j in range(4):        f[i][j] = f[i - 1][j] * (13 + j) + (0 if j == 0 else (4 - j) * f[i - 1][j - 1])ans = sum(f[i][3] for i in range(1, N + 1))print(&quot;&#123;:X&#125;&quot;.format(ans))\r\n","categories":["Project Euler"]},{"title":"Project Euler 158","url":"/project-euler/158/","content":"\r\nProject Euler 158\r\n题目\r\nExploring\r\nstrings for which only one character comes lexicographically after its\r\nneighbour to the left\r\nTaking three different letters from the \\(26\\) letters of the alphabet, character\r\nstrings of length three can be formed.\r\nExamples are ‘abc’, ‘hat’ and ‘zyx’.\r\nWhen we study these three examples we see that for ‘abc’ two\r\ncharacters come lexicographically after its neighbour to the left.\r\nFor ‘hat’ there is exactly one character that comes lexicographically\r\nafter its neighbour to the left. For ‘zyx’ there are zero characters\r\nthat come lexicographically after its neighbour to the left.\r\nIn all there are \\(10400\\) strings\r\nof length \\(3\\) for which exactly one\r\ncharacter comes lexicographically after its neighbour to the left.\r\nWe now consider strings of \\(n \\leq\r\n26\\) different characters from the alphabet.\r\nFor every \\(n, p(n)\\) is the number\r\nof strings of length \\(n\\) for which\r\nexactly one character comes lexicographically after its neighbour to the\r\nleft.\r\nWhat is the maximum value of \\(p(n)\\)?\r\n解决方案\r\n可以把满足题意的长度为\\(n\\)的单词抽象成一个\\(n\\)阶置换。而且，这个置换，由两个下降子数组拼接而成。其中第二个子数组的起点值大于第一个子序列的终点。如图中黑色字符表示的数所示：\r\n\r\n设状态\\(f(i)(i\\ge\r\n1)\\)为：考虑有多少个\\(i\\)阶置换\\(p\\)，使得仅存在一个\\(j(2\\le j \\le i)\\)，满足\\(p[j-1]&lt;p[j]\\)。\r\n可以得到状态转移方程：\r\n\\[\r\nf(i)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0  &amp; &amp; \\text{if}\\quad i=1 \\\\\r\n  &amp;2f(i-1)+i-1  &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n对于最后一行，我们可以考虑成将一个最大的数\\(i\\)插入一个已经构造好的\\(i-1\\)阶置换中。因此，对于\\(2f(i-1)\\)，\\(i\\)可以有两个选择：分别插在两个子数组的顶端（如上图两个红色的O）。\r\n对于\\(i-1\\)，则是对于一个逆序的\\(i-1\\)阶置换而言，\\(i\\)可以分别选择放在这\\(i-1\\)个数后面，从而构成两个下降子序列，有\\(i-1\\)种方法。\r\n因此，最终答案只需要将\\(f(n)\\)乘一个组合数进行比较即可。\r\n代码\r\nfrom tools import get_pascals_triangleN = 26C = get_pascals_triangle(N)f = [0 for i in range(N+1)]ans = 0for i in range(1, N):    f[i] = f[i - 1] * 2 + i - 1    ans = max(ans, f[i] * C[N][i])print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 166","url":"/project-euler/166/","content":"\r\nProject Euler 166\r\n题目\r\nCriss Cross\r\nA \\(4\\times 4\\) grid is filled with\r\ndigits \\(d\\), \\(0 \\le d \\le 9\\).\r\nIt can be seen that in the grid\r\n\\[\\begin{matrix}\r\n6 &amp; 3 &amp; 3 &amp; 0 \\\\\r\n5 &amp; 0 &amp; 4 &amp; 3 \\\\\r\n0 &amp; 7 &amp; 1 &amp; 4 \\\\\r\n1 &amp; 2 &amp; 4 &amp; 5\r\n\\end{matrix}\\] the sum of each row and each column has the value\r\n\\(12\\). Moreover the sum of each\r\ndiagonal is also \\(12\\).\r\nIn how many ways can you fill a \\(4\\times\r\n4\\) grid with the digits \\(d\\),\r\n\\(0 \\le d \\le 9\\) so that each row,\r\neach column, and both diagonals have the same sum?\r\n解决方案\r\n本题基于meet-in-the-middle的思想完成。\r\n首先枚举幻方一行中所有的可能性填法，按照行的和分别存储，共\\(10000\\)种可能的填法。\r\n接下来，枚举前两行的填法。\r\n第二行元素的和\\(s\\)必须和第一行相同（这就是按和分类存储的原因）。这时就枚举了整个幻方的一半数字。用一个六元组\\((a,b,c,d,e,f)\\)分别统计这一半的填法分别有多少，其中，\\(a,b,c,d\\)分别表示幻方\\(4\\)列上的两个数的和，\\(e,f\\)则表示主副对角线上两个数的和。\r\n不失一般性，幻方的下两行和上两行的枚举方式是完全一样的。下面两行如果存在一种填法\\((a,b,c,d,e,f)\\)，那么上面两行的填法一定是\\((s-a,s-b,s-c,s-d,s-e,s-f)\\)。\r\n直接统计这种做法个数之和。\r\n代码\r\nmp = &#123;&#125;ans = 0for i in range(10):    for j in range(10):        for k in range(10):            for l in range(10):                w = i + j + k + l                if w not in mp.keys():                    mp[w] = []                mp[w].append((i, j, k, l))for s, vec in mp.items():    mq = &#123;&#125;    for u in vec:        for v in vec:            t = (u[0] + v[0], u[1] + v[1], u[2] + v[2], u[3] + v[3], u[0] + v[1], u[3] + v[2])            if t not in mq:                mq[t] = 0            mq[t] += 1    for u in vec:        for v in vec:            t = (s - u[0] - v[0], s - u[1] - v[1], s - u[2] - v[2], s - u[3] - v[3], s - u[2] - v[3], s - u[1] - v[0])            if t in mq:                ans += mq[t]print(ans)\r\n","categories":["Project Euler"],"tags":["meet-in-the-middle"]},{"title":"Project Euler 165","url":"/project-euler/165/","content":"\r\nProject Euler 165\r\n题目\r\nIntersections\r\nA segment is uniquely defined by its two endpoints.\r\nBy considering two line segments in plane geometry there are three\r\npossibilities: the segments have zero points, one point, or infinitely\r\nmany points in common.\r\nMoreover when two segments have exactly one point in common it might\r\nbe the case that that common point is an endpoint of either one of the\r\nsegments or of both. If a common point of two segments is not an\r\nendpoint of either of the segments it is an interior point of both\r\nsegments.\r\nWe will call a common point \\(T\\) of\r\ntwo segments \\(L_1\\) and \\(L_2\\) a true intersection point of \\(L_1\\) and \\(L_2\\) if \\(T\\) is the only common point of \\(L_1\\) and \\(L_2\\) and \\(T\\) is an interior point of both\r\nsegments.\r\nConsider the three segments \\(L_1,\r\nL_2\\), and \\(L_3\\):\r\n\\(L_1: (27, 44)\\) to \\((12, 32)\\) \\(L_2: (46, 53)\\) to \\((17, 62)\\) \\(L_3: (46, 70)\\) to \\((22, 40)\\)\r\nIt can be verified that line segments \\(L_2\\) and \\(L_3\\) have a true intersection point. We\r\nnote that as the one of the end points of \\(L_3\\): \\((22,40)\\) lies on \\(L_1\\) this is not considered to be a true\r\npoint of intersection. \\(L_1\\) and\r\n\\(L_2\\) have no common point. So among\r\nthe three line segments, we find one true intersection point.\r\nNow let us do the same for \\(5000\\)\r\nline segments. To this end, we generate \\(20000\\) numbers using the so-called “Blum\r\nBlum Shub” pseudo-random number generator.\r\n\\(\\begin{aligned}\r\ns_0 &amp;= 290797 \\\\\r\ns_{n+1} &amp;= s_n\\times s_n (\\text{modulo\\ } 50515093) \\\\\r\nt_n &amp;= s_n (\\text{modulo\\ } 500) \\\\\r\n\\end{aligned}\\)\r\nTo create each line segment, we use four consecutive numbers \\(t_n\\). That is, the first line segment is\r\ngiven by:\r\n\\((t_1, t_2)\\) to \\((t_3, t_4)\\)\r\nThe first four numbers computed according to the above generator\r\nshould be: \\(27, 144, 12\\) and \\(232\\). The first segment would thus be\r\n\\((27,144)\\) to \\((12,232)\\).\r\nHow many distinct true intersection points are found among the \\(5000\\) line segments?\r\n解决方案\r\n这个问题包含了两个子问题。\r\n第一个子问题：给定线段\\(AB\\)和\\(CD\\)，判断它们是否存在真交点。\r\n如果线段\\(AB\\)和线段\\(CD\\)存在真交点，那么必须满足：点\\(A\\)和点\\(B\\)严格地分别处在直线\\(CD\\)两侧，并且点\\(C\\)和点\\(D\\)严格地分别处在直线\\(AB\\)两侧（如下图），这启发我们使用叉积来解决。\r\n\r\n用数学语言描述来说：如果\\((\\overrightarrow{BC}\\times \\overrightarrow{BA})\r\n\\cdot(\\overrightarrow{BD}\\times\r\n\\overrightarrow{BA})&lt;0\\)并且有\\((\\overrightarrow{DA}\\times\\overrightarrow{DC})\\cdot(\\overrightarrow{DB}\\times\r\n\\overrightarrow{DC})&lt;0\\)，那么线段\\(AB\\)和\\(CD\\)是有真交点的。\r\n第二个子问题：求线段\\(AB\\)和\\(CD\\)的真交点坐标，因为题目要求交点需要去重。\r\n如果已知两点\\((x_0,y_0),(x_1,y_1)\\)，那么可以直接确定两点式方程\\(Ax+By=C\\)。其中： \\[A=y_1-y_2,B=x_2-x_1,C=x_1(y_1-y_2)-y_1(x_1-x_2)\\]\r\n确定了两条直线\\(l_1,l_2\\)的方程\\(A_1x+B_1y=C_1,A_2x+B_2y=C_2\\)后，直接解出真交点即可。\r\n这里自定义了一个分数类，用于规避浮点数的误差，所以代码效率可能会比较低。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 5000;int t[N*4+4];struct Fraction &#123;    ll num, den;    bool operator&lt;(const Fraction &amp;f) const &#123;        return num &lt; f.num || num == f.num &amp;&amp; den &lt; f.den;    &#125;    Fraction() &#123;&#125;    Fraction(ll x, ll y) &#123;        ll g = __gcd(x, y);        num = x / g;        den = y / g;        if (den &lt; 0) num = -num, den = -den;    &#125;&#125;;struct P &#123;    ll x, y;    // 向量减法    P operator-(P p) const &#123;        return &#123;x - p.x, y - p.y&#125;;    &#125;    // 向量叉积    ll operator^(P p) const &#123;        return x * p.y - y * p.x;    &#125;&#125;;struct L &#123;    P p1, p2;    // ax+by=c;    ll a, b, c;    L()&#123;&#125;    L(P p1, P p2) &#123;        this-&gt;p1 = p1;        this-&gt;p2 = p2;        a = p1.y - p2.y;        b = p2.x - p1.x;        c = p1.x * (p1.y - p2.y) - p1.y * (p1.x - p2.x);    &#125;&#125;l[N+4];bool intersect(L &amp;l1,L &amp;l2)&#123;    P vb1 = l2.p1 - l1.p1,vb2 = l2.p2 - l1.p1,va = l1.p2 - l1.p1;    if ((vb1 ^ va) * (vb2 ^ va) &gt;=0)        return false;    vb1 = l1.p1 - l2.p1,vb2 = l1.p2 - l2.p1,va = l2.p2 - l2.p1;    return (vb1 ^ va) * (vb2 ^ va) &lt; 0;&#125;bool solve(L &amp;l1,L &amp;l2,pair&lt;Fraction,Fraction&gt;&amp;sol) &#123;    ll fm = l1.a * l2.b - l1.b * l2.a;    if (fm == 0)        return false;    ll fx = l1.c * l2.b - l1.b * l2.c;    ll fy = l1.a * l2.c - l1.c * l2.a;    sol = make_pair(Fraction(fx, fm), Fraction(fy, fm));    return true;&#125;int main() &#123;    ll s=290797;    for(int i=1;i&lt;=N*4;i++)&#123;        s=s*s%50515093;        t[i]=s%500;    &#125;    for(int i=1;i&lt;=N;i++)        l[i]=L(P&#123;t[4*i-3],t[4*i-2]&#125;,P&#123;t[4*i-1],t[4*i]&#125;);    // 真交点存放集合。    set&lt;pair&lt;Fraction,Fraction&gt;&gt;st;    pair&lt;Fraction,Fraction&gt;sol;    for(int i=1;i&lt;=N;i++)        for(int j=i+1;j&lt;=N;j++)            if(intersect(l[i],l[j]) &amp;&amp; solve(l[i],l[j],sol))                st.insert(sol);    int ans=st.size();    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 163","url":"/project-euler/163/","content":"\r\nProject Euler 163\r\n题目\r\nCross-hatched triangles\r\nConsider an equilateral triangle in which straight lines are drawn\r\nfrom each vertex to the middle of the opposite side, such as in the size\r\n\\(1\\) triangle in the sketch below.\r\n\r\nSixteen triangles of either different shape or size or orientation or\r\nlocation can now be observed in that triangle. Using size \\(1\\) triangles as building blocks, larger\r\ntriangles can be formed, such as the size \\(2\\) triangle in the above sketch.\r\nOne-hundred and four triangles of either different shape or size or\r\norientation or location can now be observed in that size \\(2\\) triangle.\r\nIt can be observed that the size \\(2\\) triangle contains \\(4\\) size \\(1\\) triangle building blocks. A size \\(3\\) triangle would contain \\(9\\) size \\(1\\) triangle building blocks and a size\r\n\\(n\\) triangle would thus contain \\(n^2\\) size \\(1\\) triangle building blocks.\r\nIf we denote \\(T(n)\\) as the number\r\nof triangles present in a triangle of size \\(n\\), then\r\n\\(T(1) = 16\\) \\(T(2) = 104\\)\r\nFind \\(T(36)\\).\r\n解决方案\r\n为了避免答案因小数出现精度问题，我们决定将整个三角形进行拉伸变换，这将不会影响原来三角形的所有点、线相对位置。如下图所示，如果原来的单独一个等边三角形的边长为\\(2\\)，那么边长将拉伸到原来的\\(2\\)倍数；其高为\\(\\sqrt{3}\\)，拉伸到原来的\\(2\\sqrt{3}\\)倍长度。可以发现，这些点的坐标都已经变成了整数。\r\n\r\n为了将三角形的数量数出来，我们可以每次枚举三条斜率不相同、不交于同一点的一组的线段，然后判断它们的交点是否在大三角形内部或边上即可。\r\n将前\\(4\\)项暴力枚举出来后，查询OEIS，发现结果为A210687。\r\n在FORMULA一栏中，发现如下信息：\r\na(n) = (1678*n^3+3117*n^2+88*n-345*Mod[n,2]-320*Mod[n,3]-90*Mod[n,4]-288*Mod[n^3-n^2+n,5])/240. (Bill Daly)\r\n这说明第答案为： \\[T(n)=\\dfrac{1678n^3+3117n^2+88n-345\\cdot(n\\%2)-320\\cdot(n\\%3)-90\\cdot(n\\%4)-288\\cdot\r\n((n^3-n^2+n)\\%5)}{240}\\]\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=36;struct P &#123;    ll x, y;    // 向量减法    P operator-(P p) const &#123;        return &#123;x - p.x, y - p.y&#125;;    &#125;    // 向量叉积    ll operator^(P p) const &#123;        return x * p.y - y * p.x;    &#125;    bool operator == (P &amp;p) const&#123;        return x==p.x&amp;&amp;y==p.y;    &#125;&#125;p[3]=&#123;P&#123;0,0&#125;,P&#123;4*N,0&#125;,P&#123;2*N,6*N&#125;&#125;;int m=0;struct L &#123;    P p1, p2;    // ax+by=c;    ll a, b, c;    L()&#123;&#125;    L(P p1, P p2) &#123;        this-&gt;p1 = p1;        this-&gt;p2 = p2;        a = p1.y - p2.y;        b = p2.x - p1.x;        c = p1.x * (p1.y - p2.y) - p1.y * (p1.x - p2.x);    &#125;&#125;l[9*N+14];bool in_triangle(P &amp;q)&#123;    bool neg=false,pos=false;    for(int i=0;i&lt;3;i++)&#123;        ll w=(p[i]-q)^(p[(i+1)%3]-q);        if(w&gt;0) pos=true;        if(w&lt;0) neg=true;    &#125;    return pos^neg;&#125;bool solve(L &amp;l1,L &amp;l2, P &amp;sol) &#123;    ll fm = l1.a * l2.b - l1.b * l2.a;    if (fm == 0)        return false;    ll fx = l1.c * l2.b - l1.b * l2.c;    ll fy = l1.a * l2.c - l1.c * l2.a;    sol = P&#123;fx/fm, fy/fm&#125;;    return true;&#125;int main() &#123;    for(int i=0;i&lt;N;i++)&#123;        l[++m]=L&#123;P&#123;4*i,0&#125;,P&#123;4*i+2,6&#125;&#125;;        l[++m]=L&#123;P&#123;4*i+4,0&#125;,P&#123;4*i+2,6&#125;&#125;;        l[++m]=L&#123;P&#123;2*i,6*i&#125;,P&#123;2*i+4,6*i&#125;&#125;;    &#125;    int M=N-1;    for(int i=0;i&lt;2*N-1;i++)&#123;        l[++m]=L&#123;P&#123;2*i+2,0&#125;,P&#123;2*i+2,6&#125;&#125;;        l[++m]=L&#123;P&#123;i+1,3*i+3&#125;,P&#123;0,4*i+4&#125;&#125;;    &#125;    for(int i=-M;i&lt;=M;i++)        l[++m]=L&#123;P&#123;4*i,0&#125;,P&#123;4*i+6,6&#125;&#125;;    int ans=0;    P a,b,c;    for(int i=1;i&lt;=m;i++)&#123;        for(int j=i+1;j&lt;=m;j++)&#123;            if(!solve(l[i],l[j],a)) continue;            for(int k=j+1;k&lt;=m;k++)&#123;                if(!solve(l[i],l[k],b)||!solve(l[j],l[k],c)) continue;                if(a==b||b==c||a==c) continue;                if(in_triangle(a)&amp;&amp;in_triangle(b)&amp;&amp;in_triangle(c))                    ++ans;            &#125;        &#125;    &#125;    printf(&quot;%d\\n&quot;,ans);&#125;\r\nN = 36ans = (1678 * N ** 3 + 3117 * N * N + 88 * N - N % 2 * 345 - N % 3 * 320 - N % 4 * 90 - (N ** 3 - N * N + N) % 5 * 288) // 240print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 164","url":"/project-euler/164/","content":"\r\nProject Euler 164\r\n题目\r\nNumbers\r\nfor which no three consecutive digits have a sum greater than a given\r\nvalue\r\nHow many \\(20\\) digit numbers \\(n\\) (without any leading zero) exist such\r\nthat no three consecutive digits of \\(n\\) have a sum greater than \\(9\\)?\r\n解决方案\r\n本题是一个明显的数位动态规划。\r\n令\\(f(i,a,b)(i\\ge 1,0\\le a+b\\le\r\n9)\\)为目前符合题意的\\(i\\)位数中，个位为\\(b\\)，十位为\\(a\\)的数的个数，为了保证添加连续三个数的和不超过\\(9\\)，那么个位后面添加的数必须不超过\\(9-a-b\\)。\r\n那么可以得到状态转移方程：\r\n\\[\r\nf(i,a,b)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i=1\\land a=0\\land b&gt;0 \\\\\r\n  &amp;0 &amp; &amp; \\text{else if}\\quad i=1 \\\\\r\n  &amp;\\sum_{j=0}^{9-a-b} f(i-1,j,a) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n由于只有一位数时，十位为\\(0\\)，因此只要求\\(b&gt;0\\)。而且，为了防止以后出现前导\\(0\\)，\\(f(1,0,0)=0\\)。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=20,M=10;ll f[N+4][M][M];int main()&#123;    for(int i=1;i&lt;=9;i++)        f[1][0][i]=1;    for(int i=2;i&lt;=N;i++)        for(int a=0;a&lt;=9;a++)            for(int b=0;a+b&lt;=9;b++)                for(int j=0;a+b+j&lt;=9;j++)                    f[i][a][b]+=f[i-1][j][a];    ll ans=0;    for(int a=0;a&lt;=9;a++)        for(int b=0;a+b&lt;=9;b++)            ans+=f[N][a][b];    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 168","url":"/project-euler/168/","content":"\r\nProject Euler 168\r\n题目\r\nNumber Rotations\r\nConsider the number \\(142857\\). We\r\ncan right-rotate this number by moving the last digit \\((7)\\) to the front of it, giving us \\(714285\\).\r\nIt can be verified that \\(714285=5\\times142857\\).\r\nThis demonstrates an unusual property of \\(142857\\): it is a divisor of its\r\nright-rotation.\r\nFind the last \\(5\\) digits of the\r\nsum of all integers \\(n, 10 &lt; n &lt;\r\n10^{100}\\), that have this property.\r\n解决方案\r\n令\\(N=100\\)。符合题意条件的数分成两部分：平凡的和非平凡的。\r\n\r\n平凡的：这一部分数的所有数位都相等。如\\(11,222\\)等。它们的和为\\(\\sum_{i=2}^N\\dfrac{10^i-1}{9}\\times 45 =\r\n\\sum_{i=2}^N(10^i-1)\\times 5\\)。\r\n非平凡的：本人先通过暴力程序，找到了一部分解，在OEIS上进行搜索，结果为A034089。\r\n\r\n找到COMMENT这一部分，发现如下信息：\r\nLet p(q) denote the period of the fraction q; then sequence is generated by p(i / (10k-1)), k=2,3,4,5,6,7,8,9; k &lt;= i &lt;= 9 and the concatenations of those periods, e.g., p(7/39)=a(5) p(2/19)=a(17).\r\n这说明，它是将每个分数\\(\\dfrac{i}{10k-1}(2\\le k\\le\r\ni\\le9)\\)的循环节不断用字符串进行拼接的形式构成的。如\\(\\dfrac{7}{49}=\\dfrac{1}{7}\\)，其循环节为\\(142857\\)，那么\\(142857142857\\)，\\(142857142857142857\\)等也是符合题意的数。\r\n因此直接进行枚举。分数的循环节则用长除法产生。\r\n代码\r\nN = 100ans = 0def repeating_portion(x: int, y: int):    s = &quot;&quot;    vis = [0 for _ in range(y)]    while True:        x *= 10        if vis[x % y]:            break        vis[x % y] = 1        s += str(x // y)        x %= y    return sfor i in range(2, N + 1):    ans += 5 * (10 ** i - 1)for k in range(2, 9 + 1):    for i in range(k, 9 + 1):        s = repeating_portion(i, 10 * k - 1)        t = s        while len(t) &lt;= N:            ans += int(t)            t += sans %= 10 ** 5print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 167","url":"/project-euler/167/","content":"\r\nProject Euler 167\r\n题目\r\nInvestigating Ulam sequences\r\nFor two positive integers \\(a\\) and\r\n\\(b\\), the Ulam sequence \\(U(a,b)\\) is defined by \\(U(a,b)_1 = a\\), \\(U(a,b)_2 = b\\) and for \\(k &gt; 2,U(a,b)_k\\) is the smallest integer\r\ngreater than \\(U(a,b)_{(k-1)}\\) which\r\ncan be written in exactly one way as the sum of two distinct previous\r\nmembers of U(a,b).\r\nFor example, the sequence \\(U(1,2)\\)\r\nbegins with\r\n\\(1, 2, 3 = 1 + 2, 4 = 1 + 3, 6 = 2 + 4, 8\r\n= 2 + 6, 11 = 3 + 8;\\)\r\n\\(5\\) does not belong to it because\r\n\\(5 = 1 + 4 = 2 + 3\\) has two\r\nrepresentations as the sum of two previous members, likewise \\(7 = 1 + 6 = 3 + 4\\).\r\nFind \\(\\sum U(2,2n+1)_k\\) for \\(2 \\leq n \\leq 10\\), where \\(k = 10^{11}\\).\r\n解决方案\r\n\r\n这篇文章提到，形如\\(U(2,2n+1),n\\ge\r\n2\\)的乌拉姆序列，有且仅有两个项是偶数，分别为第\\(1\\)项的\\(2\\)和第\\(n+4\\)项的\\(4n+4\\)。\r\n这个页面提到：如果乌拉姆序列中偶数的个数是有限的，那么它的差分序列从某一个起点开始是周期性的。\r\n\r\n第一个问题：如何高效计算序列\\(U(2,2n+1)\\)？\r\n不难看出，第\\(2\\)项和第\\(n+3\\)项之间的所有的奇数项是以\\(2n+1\\)为首项，\\(2\\)为公差的等差数列。\r\n根据乌拉姆序列的定义，第\\(i\\)项\\(U(2,2n+1)_i\\)一定由序列之前的某两个项相加而成。又由于第\\(n+5\\)项及以后的所有项都是奇数，那么这些项一定是由一个奇数和一个偶数相加得出，这个偶数要么是\\(2\\)，要么是\\(4n+4\\)。因此这将帮助我们以线性阶的时间复杂度计算序列\\(U(2,2n+1)\\)：计算一个奇数\\(x\\)是否在\\(U(2,2n+1)\\)，只需要判断\\(x-2\\)和\\(x-(4n+4)\\)是否有且仅有其中一个在\\(U(2,2n+1)\\)中。\r\n第二个问题：如何找到\\(U(2,2n+1)\\)的循环节，并通过循环节高效计算\\(U(2,2n+1)_k\\)？\r\n这个问题使用了这个假设：\\(U(2,2n+1)\\)的相邻两项差值的最大值为\\(4n+4\\)。并且，这个差值在每个循环节里面出现一次。（也就是说，后一项是前一项相加\\(4n+4\\)而得，而这两项中间的其它值都不符合乌拉姆序列的定义。）\r\n因此，我们可以枚举\\(U(2,2n+1)\\)的前多个值，如果找到了两对相邻项差值为\\(4n+4\\)，那么我们就找到了一个循环节。\r\n需要注意，循环节的长度非常大，要开足够的数组空间。长度值表示在OEIS的A100729中。由于差分序列是周期性的，因此每段周期提供的差值也是一样的，这个差值在OEIS的A100730。\r\n其它参考资料：页面\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 10;const ll K = 1e11;bool vis[1&lt;&lt;(2*N+4)];int ulam[1 &lt;&lt; (2 * N + 5)];ll cal(int n,ll m) &#123;    --m;    memset(vis, 0, sizeof(vis));    int p = 0, e1 = 2, e2 = 4 * n + 4;    ulam[p++] = e1;    for (int w = 2 * n + 1; w &lt;= e2; p++, w += 2) &#123;        ulam[p] = w;        vis[w &gt;&gt; 1] = true;    &#125;    ulam[p++] = e2;    int l, r;    for (int i = e2 + 1, cnt = 0;; i += 2) &#123;        if (vis[(i - e1) &gt;&gt; 1] ^ vis[(i - e2) &gt;&gt; 1]) &#123;            vis[i &gt;&gt; 1] = true;            ulam[p++] = i;            if (ulam[p - 1] - ulam[p - 2] == e2) &#123;                ++cnt;                if (cnt == 1) &#123;                    l = p - 2;                &#125; else &#123;                    r = p - 2;                    break;                &#125;            &#125;        &#125;    &#125;    int T = r - l;    //打印的两个值对应A100729和A100730。    //printf(&quot;%d %d\\n&quot;, T, ulam[r] - ulam[l]);    return m &lt; r ? ulam[m] : max(0ll, (m - l) / T) * (ulam[r] - ulam[l]) + ulam[(m - l) % T + l];&#125;int main() &#123;    ll ans = 0;    for (int n = 2; n &lt;= N; n++) &#123;        ans += cal(n, K);    &#125;    printf(&quot;%lld\\n&quot;, ans);&#125;\r\n","categories":["Project Euler"],"tags":["OEIS","论文"]},{"title":"Project Euler 17","url":"/project-euler/17/","content":"\r\nProject Euler 17\r\n题目\r\nNumber letter counts\r\nIf the numbers \\(1\\) to \\(5\\) are written out in words: one, two,\r\nthree, four, five, then there are \\(3 + 3 + 5\r\n+ 4 + 4 = 19\\) letters used in total.\r\nIf all the numbers from \\(1\\) to\r\n\\(1000\\) (one thousand) inclusive were\r\nwritten out in words, how many letters would be used?\r\nNOTE: Do not count spaces or hyphens. For example,\r\n\\(342\\) (three hundred and forty-two)\r\ncontains \\(23\\) letters and \\(115\\) (one hundred and fifteen) contains\r\n\\(20\\) letters. The use of “and” when\r\nwriting out numbers is in compliance with British usage.\r\n解决方案\r\n本代码分四种情况：\r\n\\(0\\sim20\\)：直接记录在字典中，直接获得即可。\r\n\\(21\\sim99\\)：计算出十位和个位的结果，然后直接相加。个位为\\(0\\)的情况下，不需要添加。\r\n所有\\(0\\sim100\\)的情况将存在另一个字典中。\r\n\\(100\\sim999\\)：将数拆成百位和(十位个位)两部分，需要注意用到\"hundred\"和\"and\"的情况。\r\n\\(1000\\)：直接写死。\r\n代码\r\nmp = &#123;    0: &quot;&quot;,    1: &quot;one&quot;,    2: &quot;two&quot;,    3: &quot;three&quot;,    4: &quot;four&quot;,    5: &quot;five&quot;,    6: &quot;six&quot;,    7: &quot;seven&quot;,    8: &quot;eight&quot;,    9: &quot;nine&quot;,    10: &quot;ten&quot;,    11: &quot;eleven&quot;,    12: &quot;twelve&quot;,    13: &quot;thirteen&quot;,    14: &quot;fourteen&quot;,    15: &quot;fifteen&quot;,    16: &quot;sixteen&quot;,    17: &quot;seventeen&quot;,    18: &quot;eighteen&quot;,    19: &quot;nineteen&quot;,    20: &quot;twenty&quot;,    30: &quot;thirty&quot;,    40: &quot;forty&quot;,    50: &quot;fifty&quot;,    60: &quot;sixty&quot;,    70: &quot;seventy&quot;,    80: &quot;eighty&quot;,    90: &quot;ninety&quot;,    100: &quot;hundred&quot;,    1000: &quot;one thousand&quot;,&#125;# 提前记录1000的结果。ans = len(mp[1000]) - 1mq = &#123;&#125;for i in range(1000):    if i &lt;= 20:        ans += len(mp[i])        mq[i] = len(mp[i])    elif i &lt; 100:        u, v = i // 10 * 10, i % 10        ans += len(mp[u]) + len(mp[v])        mq[i] = len(mp[u]) + len(mp[v])    else:        u, v = div(i, 100)        # hundred + 7        ans += mq[u] + 7        if v &gt; 0:            # and + 3            ans += mq[v] + 3print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 169","url":"/project-euler/169/","content":"\r\nProject Euler 169\r\n题目\r\nExploring\r\nthe number of different ways a number can be expressed as a sum of\r\npowers of \\(2\\)\r\nDefine \\(f(0)=1\\) and \\(f(n)\\) to be the number of different ways n\r\ncan be expressed as a sum of integer powers of \\(2\\) using each power no more than\r\ntwice.\r\nFor example, \\(f(10)=5\\) since there\r\nare five different ways to express \\(10\\):\r\n\\(\\begin{aligned}\r\n&amp; 1 + 1 + 8\\\\\r\n&amp; 1 + 1 + 4 + 4\\\\\r\n&amp; 1 + 1 + 2 + 2 + 4\\\\\r\n&amp; 2 + 4 + 4\\\\\r\n&amp; 2 + 8\r\n\\end{aligned}\\)\r\nWhat is \\(f(10^{25})\\)?\r\n解决方案\r\n如果\\(n\\)是一个奇数，那么就可以从\\(n\\)划分出一个\\(1=2^0\\)出来，然后再从\\(n-1\\)中继续进行。但注意这时\\(n-1\\)不能够再从\\(2^0\\)继续划分了，因为再用\\(2^0\\)就相当于用了\\(3\\)次\\(2^0\\)，不合题意。因此只能从\\(2^1\\)开始寻找，而这等价于值为\\(\\dfrac{n-1}{2}\\)的一个新问题。\r\n如果\\(n\\)是一个偶数，那么可以选择不将\\(2^0=1\\)分出来，直接从\\(2^1\\)开始找，这等价于值为\\(\\dfrac{n}{2}\\)的一个新问题；也可以选择将两个\\(2^0\\)分出来，再从剩下的\\(n-2\\)那一部分开始尝试将\\(2^1\\)划分出来，这等价于值为\\(\\dfrac{n-2}{2}\\)的新问题。\r\n因此，假设\\(f(i)(i&gt;0)\\)为题目中要求的划分数，可以列出如下状态转移方程：\r\n\\[\r\nf(i)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i=1 \\\\\r\n  &amp;f\\left(\\dfrac{i-1}{2}\\right) &amp; &amp; \\text{else if}\\quad i\r\n\\equiv 1 \\pmod 2 \\\\\r\n  &amp;f\\left(\\dfrac{i}{2}\\right)+f\\left(\\dfrac{i-2}{2}\\right)  &amp;\r\n&amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n为避免子问题的重复计算，代码实现使用了记忆化搜索。\r\n另外，用前几项查询OEIS，结果为A002487。\r\n代码\r\nN = 10 ** 25mp = &#123;&#125;def dfs(n: int):    if n &lt;= 1:        return 1    if n in mp.keys():        return mp[n]    m = n &gt;&gt; 1    if n &amp; 1:        mp[n] = dfs(m)    else:        mp[n] = dfs(m) + dfs(m - 1)    return mp[n]ans = dfs(N)print(ans)\r\n","categories":["Project Euler"],"tags":["动态规划","OEIS"]},{"title":"Project Euler 171","url":"/project-euler/171/","content":"\r\nProject Euler 171\r\n题目\r\nFinding\r\nnumbers for which the sum of the squares of the digits is a square\r\nFor a positive integer \\(n\\), let\r\n\\(f(n)\\) be the sum of the squares of\r\nthe digits (in base \\(10\\)) of n,\r\ne.g.\r\n\\(\\begin{aligned}\r\n&amp; f(3) = 3^2 = 9, \\\\\r\n&amp; f(25) = 2^2 + 5^2 = 4 + 25 = 29, \\\\\r\n&amp; f(442) = 4^2 + 4^2 + 2^2 = 16 + 16 + 4 = 36\r\n\\end{aligned}\\)\r\nFind the last nine digits of the sum of all \\(n\\), \\(0 &lt; n\r\n&lt; 10^{20}\\), such that \\(f(n)\\) is a perfect square.\r\n解决方案\r\n一道非常明显的数位动态规划题目。不过，这里要求我们统计的是满足条件的数的和。\r\n我们可以通过先统计个数，计算出每个数位上的数的贡献次数，从而计算出它们的和。\r\n设\\(N=20\\)。令\\(c(i,j)(1\\le i\\le N,0\\le j\\le 9^2\\cdot\r\ni)\\)表示\\(i\\)位数中，有多少个数的函数值\\(f\\)为\\(j\\)。不难列出以下状态转移方程：\r\n\\[\r\nc(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i=1\\land j\\in\\{x^2\\mid x\\in\r\n\\mathbb{N},1\\le x\\le 9\\} \\\\\r\n  &amp;0 &amp; &amp; \\text{else if}\\quad i=1\\\\\r\n  &amp;\\sum_{k=0}^{\\min(9,\\lfloor\\sqrt{j}\\rfloor)}c(i-1,j-k^2) &amp;\r\n&amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n其中，最后一行表示，每一个数都可以添加一个数位\\(k\\)在其后面，那么\\(f\\)就会增加\\(k^2\\)。\r\n根据符合状态的数的出现次数，可以确定每一个数位的贡献。令\\(s(i,j)(1\\le i\\le N,0\\le j\\le 9^2\\cdot\r\ni)\\)表示\\(i\\)位数中，函数值\\(f\\)为\\(j\\)的所有数之和，那么可以列出以下状态转移方程：\r\n\\[\r\ns(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;\\sqrt{j}  &amp; &amp; \\text{if}\\quad i=1\\land j\\in\\{x^2\\mid x\\in\r\n\\mathbb{N},1\\le x\\le 9\\} \\\\\r\n  &amp;0 &amp; &amp; \\text{else if}\\quad i=1\\\\\r\n  &amp;\\sum_{k=0}^{\\min(9,\\lfloor\\sqrt{j}\\rfloor)}10\\cdot\r\ns(i-1,j-k^2)+k\\cdot c(i-1,j-k^2) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n最后一行中，将\\(c(i-1,j-k^2)\\)个数后面都放置一个\\(k\\)，就可以产生贡献，而之前的数就需要向前进一位，乘\\(10\\)。\r\n最终答案为： \\[\\sum_{i=1}^N\\sum_{j=0}^{\\lfloor9\\sqrt{i}\\rfloor}s(i,j^2)\\]\r\n代码\r\nfrom itertools import countN = 20mod = 10 ** 9c = [[0 for _ in range(N * 9 * 9 + 1)] for _ in range(N + 1)]s = [[0 for _ in range(N * 9 * 9 + 1)] for _ in range(N + 1)]for j in range(1, 10):    c[1][j * j] = 1    s[1][j * j] = jfor i in range(2, N + 1):    for j in range(i * 9 * 9 + 1):        for k in range(10):            if j - k * k &lt; 0:                break            c[i][j] += c[i - 1][j - k * k]            s[i][j] += s[i - 1][j - k * k] * 10 + k * c[i - 1][j - k * k]ans = 0for j in count(1, 1):    if j * j &gt; 9 * 9 * N:        break    for i in range(1, N + 1):        ans += s[i][j * j]ans %= modprint(ans)\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 170","url":"/project-euler/170/","content":"\r\nProject Euler 170\r\n题目\r\nFind\r\nthe largest 0 to 9 pandigital that can be formed by concatenating\r\nproducts\r\nTake the number \\(6\\) and multiply\r\nit by each of \\(1273\\) and \\(9854\\):\r\n\\(6 × 1273 =  7638\\) \\(6 × 9854 = 59124\\)\r\nBy concatenating these products we get the \\(1\\) to \\(9\\) pandigital \\(763859124\\). We will call \\(763859124\\) the “concatenated product of\r\n\\(6\\) and \\((1273,9854)\\)”. Notice too, that the\r\nconcatenation of the input numbers, \\(612739854\\), is also \\(1\\) to \\(9\\) pandigital.\r\nThe same can be done for \\(0\\) to\r\n\\(9\\) pandigital numbers.\r\nWhat is the largest \\(0\\) to \\(9\\) pandigital \\(10\\)-digit concatenated product of an\r\ninteger with two or more other integers, such that the concatenation of\r\nthe input numbers is also a \\(0\\) to\r\n\\(9\\) pandigital 10-digit number?\r\n解决方案\r\n假设算式的形式为\\(a(a_0,a_1,\\dots)=(b_0,b_1,\\dots)\\)。\r\n通过枚举搜索答案：\r\n\r\n从大到小遍历候选的全排列，如果判定正确就退出。\r\n将整个全\\(0\\sim\r\n9\\)数串划分成多个子串，然后求最大公因数\\(\\gcd(b_0,b_1,\\dots)\\)。最大公因数的因子为乘数\\(a\\)的一个候选答案。因此，在计算开始之前现将\\(10^5\\)以内的所有数的因子保存（\\(1\\)除外）。\r\n为保证搜索效率，可以假设括号\\(()\\)中只有两个数\\(a_0,a_1\\)，这不影响寻找正确答案。\r\n\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;const int N=100004;int a[14];vector&lt;int&gt;d[N];string tp=&quot;0123456789&quot;;bool ok()&#123;    for(int p=1;p&lt;10;p++)&#123;        if(a[p]==0) continue;        int l=0,r=0;        for(int i=0;i&lt;10;i++) &#123;            if (i &lt; p) l = l * 10 + a[i];            else r = r * 10 + a[i];        &#125;        for(int x:d[__gcd(l,r)]) &#123;            string s = to_string(x) + to_string(l / x) + to_string(r / x);            sort(s.begin(), s.end());            if (s == tp) &#123;                return true;            &#125;        &#125;    &#125;    return false;&#125;int main()&#123;    for(int i=3;i&lt;N;i+=3)&#123;        for(int j=i;j&lt;N;j+=i)            d[j].push_back(i);    &#125;    for(int i=0;i&lt;10;i++)        a[i]=9-i;    do&#123;        if (ok()) break;    &#125; while (prev_permutation(a,a+10));    string ans;    for(int i=0;i&lt;10;i++)        ans+=char(&#x27;0&#x27;+a[i]);    cout&lt;&lt;ans&lt;&lt;endl;&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 173","url":"/project-euler/173/","content":"\r\nProject Euler 173\r\n题目\r\nUsing\r\nup to one million tiles how many different “hollow” square laminae can\r\nbe formed?\r\nWe shall define a square lamina to be a square outline with a square\r\n“hole” so that the shape possesses vertical and horizontal symmetry. For\r\nexample, using exactly thirty-two square tiles we can form two different\r\nsquare laminae:\r\n\r\nWith one-hundred tiles, and not necessarily using all of the tiles at\r\none time, it is possible to form forty-one different square laminae.\r\nUsing up to one million tiles how many different square laminae can\r\nbe formed?\r\n解决方案\r\n令\\(N=10^6\\)。假设内部的正方形边长为\\(a\\)，边框的宽度为\\(d\\)，那么大正方形的边长为\\(2d+a\\)，这个边框使用了\\((2d+a)^2-a^2=4d(a+d)\\)个正方形。\r\n那么得到\\(4d(a+d)\\le N\\)，有\\(a\\le \\dfrac{N}{4d}-d\\)。\r\n因此，直接枚举\\(d\\)的值，就可以得到满足当前条件下的\\(a\\)的个数。\r\n代码\r\nfrom itertools import countN = 10 ** 6M = N // 4ans = 0for d in count(1, 1):    w = M // d - d    if w &lt; 0:        break    ans += wprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 172","url":"/project-euler/172/","content":"\r\nProject Euler 172\r\n题目\r\nInvestigating\r\nnumbers with few repeated digits\r\nHow many \\(18\\)-digit numbers \\(n\\) (without leading zeros) are there such\r\nthat no digit occurs more than three times in \\(n\\)?\r\n多重全排列公式\r\n多重全排列公式：假设使用\\(r_1\\)个相同元素\\(c_1\\)，\\(r_2\\)个相同元素\\(c_2\\)，\\(\\dots\\)，\\(r_n\\)个相同元素\\(c_n\\)，那么可以构成以下数量的不同全排列个数：\r\n\\[\\dfrac{(\\sum_{i=1}^nr_i)!}{\\prod_{i=1}^nr_i!}\\]\r\n解决方案\r\n由于每个数位最多使用\\(3\\)次，因此分别枚举有\\(i,j,k,h(h+i+j+k=10)\\)个数位使用了\\(1\\)次，\\(2\\)次，\\(3\\)次，或者没有使用。由此，现在问题变成了两个独立的子步骤：这\\(i,j,k,h\\)个数位对应到\\(10\\)个数位，有多少种对应方式？当数位对应好后，有多少个排列？\r\n第一个步骤：分配各个数位的对应次数的数量为\\(\\dbinom{10}{i}\\dbinom{10-i}{j}\\dbinom{10-i-j}{k}=\\dfrac{10!}{i!\\cdot\r\nj!\\cdot k!\\cdot h!}\\)。\r\n第二个步骤：使用多重全排列公式，可以得到\\(\\dfrac{N!}{(0!)^h\\cdot(1!)^i\\cdot(2!)^j\\cdot(3!)^k}\\)。\r\n两个步骤前后相互独立，故相乘。\r\n注意这里要求不包括前导\\(0\\)，由于每一个数位填在最高位的概率都是平等的，因此最终答案需要乘个\\(\\dfrac{9}{10}\\)。\r\n代码\r\nN = 18M = max(N, 10)fac = [1]for i in range(1, M + 1):    fac.append(fac[-1] * i)ans = 0for i in range(11):    for j in range(11 - i):        for k in range(11 - i - j):            if i + 2 * j + 3 * k == N:                h = 10 - i - j - k                a = fac[N] // 2 ** j // 6 ** k                c = fac[10] // fac[h] // fac[i] // fac[j] // fac[k]                ans += a * cans = ans * 9 // 10print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 175","url":"/project-euler/175/","content":"\r\nProject Euler 175\r\n题目\r\nFractions\r\ninvolving the number of different ways a number can be expressed as a\r\nsum of powers of 2\r\nDefine \\(f(0)=1\\) and \\(f(n)\\) to be the number of ways to write\r\n\\(n\\) as a sum of powers of \\(2\\) where no power occurs more than\r\ntwice.\r\nFor example, \\(f(10)=5\\) since there\r\nare five different ways to express \\(10\\):\r\n\\(10 = 8+2 = 8+1+1 = 4+4+2 = 4+2+2+1+1 =\r\n4+4+1+1\\)\r\nIt can be shown that for every fraction \\(\\dfrac{p}{q} (p&gt;0, q&gt;0)\\) there\r\nexists at least one integer \\(n\\) such\r\nthat \\(\\dfrac{f(n)}{f(n-1)}=\\dfrac{p}{q}\\).\r\nFor instance, the smallest \\(n\\) for\r\nwhich \\(\\dfrac{f(n)}{f(n-1)}=\\dfrac{13}{17}\\) is\r\n\\(241\\).\r\nThe binary expansion of \\(241\\) is\r\n\\(11110001\\).\r\nReading this binary number from the most significant bit to the least\r\nsignificant bit there are \\(4\\) one’s,\r\n\\(3\\) zeroes and \\(1\\) one. We shall call the string \\(4,3,1\\) the Shortened Binary\r\nExpansion of \\(241\\).\r\nFind the Shortened Binary Expansion of the smallest \\(n\\) for which \\(\\dfrac{f(n)}{f(n-1)}=\\dfrac{123456789}{987654321}\\).\r\nGive your answer as comma separated integers, without any\r\nwhitespaces.\r\n解决方案\r\n利用前几项查询OEIS，结果为A002487（至于式子的推导，已经在169题中给出）。那么对于所有\\(n&gt;1\\)，可以写成\\(f(2n)=f(n),f(2n-1)=f(n)+f(n-1)\\)，其中\\(f(0)=0,f(1)=f(2)=1\\)。\r\n对于同一个\\(n\\)下的两个式子作商，有\r\n\\[\\dfrac{f(2n-1)}{f(2n)}=\\dfrac{f(n)+f(n-1)}{f(n)}=1+\\dfrac{f(n-1)}{f(n)}\\]\r\n通过这个式子，不难发现，当任意一个数\\(m\\)满足\\(f(m-1)&gt;f(m)\\)时，\\(m\\)为奇数，也就是\\(m\\)的二进制下最低位为\\(1\\)，否则\\(m\\)为偶数，最低位为\\(0\\)（此时需要将分式的分子分母交换）。\\(m\\)接下来的次低位则通过上面的式子的右边的那个分式\\(\\dfrac{f(n-1)}{f(n)}\\)决定。这启发我们使用辗转相除法解决这个问题。\r\n回到题目中，题目询问的分式是\\(\\dfrac{f(n)}{f(n-1)}\\)，那么和上面的讨论结果相反：如果当前分数的分子比分母小，那么\\(n\\)的低位为\\(1\\)，并且用分母减去分子；否则为\\(0\\)，用分子减去分母。\\(n\\)的数位从后向前填入。\r\n需要注意的是，如果填入的最高位是\\(0\\)，那么最高位需要变成\\(1\\)。\r\n代码\r\na, b = 123456789, 987654321ls = []while a and b:    if b &gt;= a:        ls.append((b // a, 1))        b %= a    else:        ls.append((a // b, 0))        a %= bif ls[-1][1] == 0:    x, y = ls[-1]    ls.pop()    ls.append((x - 1, 0))    ls.append((1, 1))ans = &quot;,&quot;.join([str(v[0]) for v in ls[::-1]])print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 174","url":"/project-euler/174/","content":"\r\nProject Euler 174\r\n题目\r\nCounting\r\nthe number of “hollow” square laminae that can form one, two, three, …\r\ndistinct arrangements\r\nWe shall define a square lamina to be a square outline with a square\r\n“hole” so that the shape possesses vertical and horizontal symmetry.\r\nGiven eight tiles it is possible to form a lamina in only one way:\r\n\\(3\\times 3\\) square with a \\(1\\times1\\) hole in the middle. However,\r\nusing thirty-two tiles it is possible to form two distinct laminae.\r\n\r\nIf \\(t\\) represents the number of\r\ntiles used, we shall say that \\(t = 8\\)\r\nis type \\(L(1)\\) and \\(t = 32\\) is type \\(L(2)\\).\r\nLet \\(N(n)\\) be the number of \\(t \\le 1000000\\) such that \\(t\\) is type \\(L(n)\\); for example, \\(N(15)\\) = \\(832\\).\r\nWhat is \\(\\sum N(n)\\) for \\(1 \\le n \\le 10\\)?\r\n解决方案\r\n与173题一样，令\\(N=1000000\\)。假设内部的正方形边长为\\(a\\)，边框的宽度为\\(d\\)，那么大正方形的边长为\\(2d+a\\)，这个边框使用了\\((2d+a)^2-a^2=4d(a+d)\\)个正方形。\r\n计算出的式子有常数因子\\(4\\)，因此只需要\\(\\dfrac{N}{4}\\)的空间。因此，直接枚举式子\\(a(a+d)\\)的值并统计即可。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1000000,Q=10;const int M=N/4;int cnt[M+4];int main()&#123;    for(int a=1;a+1&lt;=M;a++)        for(int d=1;d*(d+a)&lt;=M;d++)            ++cnt[d*(a+d)];    int ans=0;    for(int i=1;i&lt;=M;i++)        if(0&lt;cnt[i]&amp;&amp;cnt[i]&lt;=Q) ++ans;    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 176","url":"/project-euler/176/","content":"\r\nProject Euler 176\r\n题目\r\nRight-angled\r\ntriangles that share a cathetus\r\nThe four right-angled triangles with sides \\((9,12,15), (12,16,20), (5,12,13)\\) and\r\n\\((12,35,37)\\) all have one of the\r\nshorter sides (catheti) equal to \\(12\\). It can be shown that no other integer\r\nsided right-angled triangle exists with one of the catheti equal to\r\n\\(12\\).\r\nFind the smallest integer that can be the length of a cathetus of\r\nexactly \\(47547\\) different integer\r\nsided right-angled triangles.\r\n解决方案\r\n将前几项枚举出来，放入OEIS查询后发现结果为A046079。\r\n查询到FORMULA一栏，发现如下信息：\r\nLet n = (2^a0)*(p1^a1)*...*(pk^ak). Then a(n) = [(2*a0 - 1)*(2*a1 + 1)*(2*a2 + 1)*(2*a3 + 1)*...*(2*ak + 1) - 1]/2. Note that if there is no a0 term, i.e., if n is odd, then the first term is simply omitted. - Temple Keller (temple.keller(AT)gmail.com), Jan 05 2008\r\n这说明，如果一个数\\(n\\)的分解质因数为\\(n=2^{e_0}\\prod_{i=1}^k p_i^{e_i}\\)，\r\n那么，包含\\(n\\)这个数的勾股数组个数\\(f(n)\\)为：\r\n\\[\r\nf(n)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;\\dfrac{(2e_0-1) \\prod_{i=1}^k(2e_i+1)-1}{2}  &amp; &amp;\r\n\\text{if}\\quad e_0&gt;0 \\\\\r\n  &amp;\\dfrac{\\prod_{i=1}^k(2e_i+1)-1}{2} &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n因此，通过\\(n\\)的分解质因数枚举\\(n\\)即可，枚举时，为使\\(n\\)取到的最小，注意当\\(e_i&gt;e_j\\)时，那么\\(p_i&lt;p_j\\)。对\\(2\\)的质数枚举额外枚举。\r\n对于\\(f(n)\\)的一些证明：\r\n根据勾股定理\\(a^2+b^2=c^2\\)，得到\\(a^2=(c+b)(c-b)\\)，那么问题就转化为相当于有多少对\\((x,y)\\)使得\\(a^2=xy,x&lt;y\\)。每一对正数\\((x,y)\\)对应着一对正数\\((c,b)\\)。\r\n如果\\(a\\)是一个奇数，根据因数个数定理，不难发现答案就是\\(\\dfrac{\\prod_{i=1}^k(2e_i+1)-1}{2}\\)。\r\n如果\\(a\\)是一个偶数，那么\\(c+b\\)和\\(c-b\\)都为偶数，因此需要减去\\(c+b\\)和\\(c-b\\)中一个为偶数，一个为奇数的情况，也就是有：\\(\\dfrac{(2e_0+1)\\prod_{i=1}^k(2e_i+1)-2\\prod_{i=1}^k(2e_i+1)-1}{2}\\)，那么整理得：\\(\\dfrac{(2e_0-1)\r\n\\prod_{i=1}^k(2e_i+1)-1}{2}\\)。\r\n代码\r\nfrom tools import get_primeQ = 47547ans = -1pr = get_prime(3, len(bin(Q)) * 2)def dfs(val: int, f: int, lim: int, w: int):    global ans    if (ans != -1 and val &gt; ans) or (w - 1) // 2 &gt; Q:        return    if (w - 1) // 2 == Q:        ans = val        return    for i in range(1, lim):        val *= pr[f]        dfs(val, f + 1, i, w * (i * 2 + 1))for k in range(100):    if ans != -1 and (1 &lt;&lt; k) &gt;= ans:        break    if k == 0:        w = 1    else:        w = 2 * k - 1    dfs(1 &lt;&lt; k, 0, 66, w)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 177","url":"/project-euler/177/","content":"\r\nProject Euler 177\r\n题目\r\nInteger angled\r\nQuadrilaterals\r\nLet ABCD be a convex quadrilateral, with diagonals AC and BD. At each\r\nvertex the diagonal makes an angle with each of the two sides, creating\r\neight corner angles.\r\n\r\nFor example, at vertex \\(A\\), the\r\ntwo angles are \\(CAD, CAB\\).\r\nWe call such a quadrilateral for which all eight corner angles have\r\ninteger values when measured in degrees an “integer angled\r\nquadrilateral”. An example of an integer angled quadrilateral is a\r\nsquare, where all eight corner angles are \\(45°\\). Another example is given by \\(DAC = 20°, BAC = 60°, ABD = 50°, CBD = 30°, BCA =\r\n40°, DCA = 30°, CDB = 80°, ADB = 50°\\).\r\nWhat is the total number of non-similar integer angled\r\nquadrilaterals?\r\nNote: In your calculations you may assume that a calculated angle is\r\nintegral if it is within a tolerance of \\(10^{-9}\\) of an integer value.\r\n解决方案\r\n本题在枚举的过程中需要注意旋转、翻转的情况，需要去重。需要通过一些手段尽量减少枚举量。\r\n只需要枚举其中四个角\\(DAC,BAC,ABD,CBD\\)的大小，就可以通过正弦定理和余弦定理确定另外\\(4\\)个角的值，然后判断这些角是否都为整数。\r\n具体过程见代码。\r\n加上旋转，翻转后有八种方案，我们只保留其中一种。\r\n代码\r\n本代码根据题目下Thread的一份代码进行优化修改。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;double pi = acos(-1.0);double sina[184];double cosa[184];unsigned hs(int a, int b, int c, int d) &#123;    return (a &lt;&lt; 24) | (b &lt;&lt; 16) | (c &lt;&lt; 8) | d;&#125;int main() &#123;    int ans = 0;    for (int i = 0; i &lt;= 180; i++) &#123;        sina[i] = sin(i * pi / 180);        cosa[i] = cos(i * pi / 180);    &#125;    // 不失一般性，枚举的角DAC是八个角中最小的。后续计算中如果发现有比这更小的角，则直接跳出循环。    for (int DAC = 1; DAC &lt;= 45; DAC++)        // AB边上的另外两个角ABD，CBD至少有DAC这么大。        for (int BAC = DAC; BAC &lt;= 180 - DAC * 3; BAC++)            // CBD至少有DAC这么大。            for (int ABD = DAC; ABD &lt;= 180 - 2 * DAC - BAC; ABD++)                for (int CBD = DAC; CBD &lt;= 180 - DAC - BAC - ABD; CBD++) &#123;                    int BCA = 180 - (BAC + ABD + CBD);                    int ADB = 180 - (DAC + BAC + ABD);                    // AB=1                    double AC = sina[ABD + CBD] / sina[BCA];                    double AD = sina[ABD] / sina[ADB];                    double DC = sqrt(AC * AC + AD * AD - 2 * AC * AD * cosa[DAC]);                    double tmpACD = acos((AC * AC + DC * DC - AD * AD) / (2 * AC * DC)) * 180 / pi;                    int ACD = int(round(tmpACD));                    if (fabs(tmpACD - ACD) &gt; 1e-9) continue;                    if (ACD &lt; DAC) break;                    int CDB = 180 - (DAC + ACD + ADB);                    if (CDB &lt; DAC) break;                    unsigned h = hs(DAC, BAC, ABD, CBD);                    if (h &gt; hs(ABD, CBD, BCA, ACD)) continue;                    if (h &gt; hs(BCA, ACD, CDB, ADB)) continue;                    if (h &gt; hs(CDB, ADB, DAC, BAC)) continue;                    if (h &gt; hs(BAC, DAC, ADB, CDB)) continue;                    if (h &gt; hs(CBD, ABD, BAC, DAC)) continue;                    if (h &gt; hs(ACD, BCA, CBD, ABD)) continue;                    if (h &gt; hs(ADB, CDB, ACD, BCA)) continue;                    ++ans;                &#125;    printf(&quot;%d\\n&quot;, ans);    return 0;&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 179","url":"/project-euler/179/","content":"\r\nProject Euler 179\r\n题目\r\nConsecutive positive\r\ndivisors\r\nFind the number of integers \\(1 &lt; n &lt;\r\n10^7\\), for which \\(n\\) and\r\n\\(n + 1\\) have the same number of\r\npositive divisors. For example, \\(14\\)\r\nhas the positive divisors \\(1, 2, 7,\r\n14\\) while \\(15\\) has \\(1, 3, 5, 15\\).\r\n解决方案\r\n线性筛可以用于高速计算积性函数的值，本题需要求的积性函数是因数个数。\r\n\\(v[i]\\)是\\(i\\)最小的质因数。如果用比\\(v[i]\\)更小的质因数\\(p\\)产生了一个新数，那么\\(i\\)中的所有因数都需要乘以一个\\(p\\)，与原来的因数一起成为新数的因子，因此多添加了一倍的因子。\r\n如果\\(p=v[i]\\)，那么按照上面的说法，产生出来的因数是有重复的。假设\\(i\\)分解质因数后质因数\\(p\\)的次数为\\(e\\)，那么\\(p,p^2,\\dots,p^e\\)都是重复的一部分，而这一部分因数的数量恰好和\\(\\dfrac{i}{p}\\)因数数量相等，因此需要减去这一部分。\r\n计算完因数个数函数后，直接进行判断。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e7;int pr[N/4+40],v[N+1],s[N+1],m=0;int main()&#123;    s[1]=1;    for(int i=2;i&lt;=N;i++)&#123;        if(v[i]==0)&#123;            v[i]=i;s[i]=2;            pr[++m]=i;        &#125;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;N/i) break;            v[i*pr[j]]=pr[j];            if(pr[j]==v[i])                s[i*pr[j]]=s[i]+s[i]-s[i/pr[j]];            else                s[i*pr[j]]=s[i]+s[i];        &#125;    &#125;    int ans=0;    for(int i=1;i&lt;N;i++)        if(s[i]==s[i+1]) ++ans;    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 180","url":"/project-euler/180/","content":"\r\nProject Euler 180\r\n题目\r\nRational zeros\r\nof a function of three variables\r\nFor any integer \\(n\\), consider the\r\nthree functions\r\n\\[f_{1,n}(x,y,z)=x^{n+1}+y^{n+1}-z^{n+1}\\]\r\n\\[f_{2,n}(x,y,z)=(xy+yz+zx)(x^{n-1}+y^{n-1}-z^{n-1})\\]\r\n\\[f_{3,n}(x,y,z)=xyz(x^{n-2}+y^{n-2}-z^{n-2})\\]\r\nand their combination\r\n\\[f_n(x,y,z)=f_{1,n}(x,y,z)+f_{2,n}(x,y,z)-f_{3,n}(x,y,z)\\]\r\nWe call \\((x,y,z)\\) a golden triple\r\nof order \\(k\\) if \\(x\\), \\(y\\), and \\(z\\) are all rational numbers of the form\r\n\\(\\dfrac{a}{b}\\) with \\(0 &lt;a &lt; b \\le k\\) and there is (at\r\nleast) one integer \\(n\\), so that \\(f_n(x,y,z) = 0\\).\r\nLet \\(s(x,y,z) = x + y + z\\).\r\nLet \\(t = \\dfrac{u}{v}\\) be the sum\r\nof all distinct \\(s(x,y,z)\\) for all\r\ngolden triples \\((x,y,z)\\) of order\r\n\\(35\\).\r\nAll the \\(s(x,y,z)\\) and \\(t\\) must be in reduced form.\r\nFind \\(u + v\\).\r\n解决方案\r\n经过整理，可以发现\\(f_n(x,y,z)=(x+y+z)(x^n+y^n-z^n)\\)\r\n此时则变为求方程\\(x^n+y^n=z^n\\)是否有有理数解。\r\n设\\(x=\\dfrac{a}{b},y=\\dfrac{c}{d},z=\\dfrac{e}{f}\\).\r\n代入式子后，两边同乘\\((bdf)^n\\)，即可化成\\((adf)^n+(bcf)^n=(bde)^n\\)。\r\n根据费马大定理，当\\(n\\ge3\\)时无正整数解（题目中要求\\(n\\le-3\\)时的情况也类似），故此时方程\\(x^n+y^n=z^n\\)没有有理数解。因此，本题只需求解\\(n=-2,-1,1,2\\)的情况即可。\r\n不考虑\\(n=0\\)的情况，因为\\(f_0(x,y,z)=x+y+z&gt;0\\)。\r\n代码\r\nfrom fractions import FractionN = 35fraction_set = &#123;Fraction(a, b) for b in range(1, N + 1) for a in range(1, b)&#125;fraction_list = list(fraction_set)sqr = &#123;x * x: x for x in fraction_set&#125;l = len(fraction_list)st = set()for i in range(l):    for j in range(i, l):        x, y = fraction_list[i], fraction_list[j]        z = x + y        if z in fraction_set:            st.add(x + y + z)        z2 = x * x + y * y        if z2 in sqr.keys():            st.add(x + y + sqr[z2])        z = 1 / (1 / x + 1 / y)        if z in fraction_set:            st.add(x + y + z)        z2 = 1 / (1 / x / x + 1 / y / y)        if z2 in sqr.keys():            st.add(x + y + sqr[z2])s = sum(st)ans = s.numerator + s.denominatorprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 18","url":"/project-euler/18/","content":"\r\nProject Euler 18\r\n题目\r\nMaximum path sum I\r\nBy starting at the top of the triangle below and moving to adjacent\r\nnumbers on the row below, the maximum total from top to bottom is \\(23\\).\r\n\r\n3 7 4 2\r\n4 6 8 5 9 3\r\n\r\nThat is, \\(3 + 7 + 4 + 9 = 23\\).\r\nFind the maximum total from top to bottom of the triangle below:\r\n\r\n75 95 64 17 47 82 18 35 87 10 20 04 82 47\r\n65 19 01 23 75 03 34 88 02 77 73 07 63 67 99 65 04 28\r\n06 16 70 92 41 41 26 56 83 40 80 70 33 41 48 72 33 47 32 37\r\n16 94 29 53 71 44 65 25 43 91 52 97 51 14 70 11 33 28 77 73\r\n17 78 39 68 17 57 91 71 52 38 17 14 91 43 58 50 27 29 48 63\r\n66 04 68 89 53 67 30 73 16 69 87 40 31 04 62 98 27 23 09 70 98 73\r\n93 38 53 60 04 23\r\n\r\nNOTE: As there are only \\(16384\\) routes, it is possible to solve\r\nthis problem by trying every route. However, Problem 67, is the same challenge with a\r\ntriangle containing one-hundred rows; it cannot be solved by brute\r\nforce, and requires a clever method! ;o)\r\n解决方案\r\n将数字三角形直接转化成一个以左下角为顶点的直角三角形，存在p018.txt中，方便读取：\r\n 75 95\r\n64 17 47 82 18 35 87 10 20 04 82 47 65 19 01 23\r\n75 03 34 88 02 77 73 07 63 67 99 65 04 28 06 16 70 92\r\n41 41 26 56 83 40 80 70 33 41 48 72 33 47 32 37 16 94 29 53\r\n71 44 65 25 43 91 52 97 51 14 70 11 33 28 77 73 17 78 39 68 17\r\n57 91 71 52 38 17 14 91 43 58 50 27 29 48 63 66 04 68 89 53\r\n67 30 73 16 69 87 40 31 04 62 98 27 23 09 70 98 73 93 38 53 60 04\r\n23 \r\n此时可以将问题转化为：要么向下走，要么向右下角走。\r\n本题将用到动态规划算法。\r\n令\\(n=15\\)，其中\\(n\\)表示数字三角形的大小，记录状态\\(f(i,j)(1\\leq j\\leq i\\leq\r\nn)\\)为：当前走到第\\(i\\)行第\\(j\\)列的数的情况下，可以得到的路径最大和是多少，用\\(a[i][j]\\)表示第\\(i\\)行第\\(j\\)列的数。\r\n那么，可以得到状态转移方程：\r\n\\[\r\nf(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;a[i][j]  &amp; &amp; \\text{if}\\quad i=j=1 \\\\\r\n  &amp;f(i-1,j-1)+a[i][j] &amp; &amp; \\text{else if}\\quad j=i \\\\\r\n  &amp;f(i-1,j)+a[i][j] &amp; &amp; \\text{else if}\\quad j=1 \\\\\r\n  &amp;\\max(f(i-1,j-1),f(i-1,j)) + a[i][j] &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n最后的答案则是\\(\\max_{j=1}^n\\{f(n,j)\\}\\).\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;const int N=15;int t,f[N+4][N+4];int main()&#123;    freopen(&quot;p018.txt&quot;,&quot;r&quot;,stdin);    for(int i=1;i&lt;=N;i++)    for(int j=1;j&lt;=i;j++)&#123;        scanf(&quot;%d&quot;,&amp;t);        f[i][j]=max(f[i-1][j-1],f[i-1][j])+t;    &#125;    int ans=*max_element(f[N]+1,f[N]+N+1);    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 181","url":"/project-euler/181/","content":"\r\nProject Euler 181\r\n题目\r\nInvestigating\r\nin how many ways objects of two different colours can be grouped\r\nHaving three black objects B and one white object W they can be\r\ngrouped in 7 ways like this:\r\n\r\n\r\n\r\n(BBBW)\r\n(B,BBW)\r\n(B,B,BW)\r\n(B,B,B,W)\r\n(B,BB,W)\r\n(BBB,W)\r\n(BB,BW)\r\n\r\n\r\n\r\nIn how many ways can sixty black objects B and forty white objects W\r\nbe thus grouped?\r\n解决方案\r\n令\\(N=60,M=40\\)。不难发现，一个非空的内部组合一共有\\(O=(N+1)(M+1)-1\\)种不同情况。\r\n为了使得计数不重不漏，我们规定了一种内部组合的”顺序“，其中第\\(k(k\\le O)\\)种内部组合包含了\\(x[k]\\)个黑色物体，\\(y[k]\\)个白色物体。\r\n如果第\\(k\\)种内部组合已经出现了，那么以后就只能使用\\(k,k+1,\\dots,O\\)的内部组合，不能再使用以前的组合。\r\n那么，使用动态规划的方法进行计数。令\\(f(i,j,k)(0\\le i\\le N,0\\le j\\le M,0\\le k\\le\r\nO)\\)表示已经使用了\\(i\\)个黑色物体和\\(j\\)个白色物体，内部组合使用序号已经到达了\\(k\\)的情况。\r\n\\[\r\nf(i,j,k)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1 &amp; &amp; \\text{if}\\quad i=0\\land j=0 \\\\\r\n  &amp;0 &amp; &amp; \\text{else if}\\quad k=0 \\\\\r\n  &amp;f(i,j,k-1)+f(i-x[k],j-y[k],k) &amp; &amp; \\text{else if}\\quad\r\ni\\ge x[k]\\land j\\ge y[k] \\\\\r\n  &amp;f(i,j,k-1) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n注意，\\(k=0\\)时说明还没使用过任何一种内部组合，但是\\(i+j&gt;0\\)。这明显是不可能的，因此这些状态赋值为\\(0\\)。\r\n对于方程的第二行，如果当前使用的黑白物体数量都能够凑成一个第\\(k\\)内部组合，那么就可以找到上一轮的状态，产生第\\(k\\)种内部组合，到达当前状态。\r\n同时，每一个状态可以什么都不需要做，直接继承上一个状态的结果。\r\n最终答案为\\(f(N,M,O)\\)。\r\n将结果的前几项查询OEIS，发现结果为A054225。\r\n找到FORMULA一栏，发现如下信息：\r\nG.f.: Product_&#123; i=1..infinity, j=0..i&#125; 1/(1-x^(i-j)*y^j).\r\n这说明了，它们的数量的二维序列可以写成一个二元生成函数：\r\n\\[G(x,y)=\\prod_{k=1}^{\\infty}\\prod_{j=0}^k\\dfrac{1}{1-x^{k-j}y^j}\\]\r\n其中，\\(x^Ny^M\\)的系数即为所求答案。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=60,M=40;const int O=(N+1)*(M+1)-1;ll f[N+1][M+1][O+4];int x[O+4],y[O+4];int main() &#123;    for (int i = 0, p = 0; i &lt;= N; i++)        for (int j = 0; j &lt;= M; j++, p++) &#123;            x[p] = i;            y[p] = j;        &#125;    for (int j = 1; j &lt;= O; j++)        f[0][0][j] = 1;    for (int i = 0; i &lt;= N; i++) &#123;        for (int j = 0; j &lt;= M; j++) &#123;            if (i == 0 &amp;&amp; j == 0) continue;            for (int k = 1; k &lt;= O; k++) &#123;                f[i][j][k] = f[i][j][k - 1];                if (x[k] &lt;= i &amp;&amp; y[k] &lt;= j)                    f[i][j][k] += f[i - x[k]][j - y[k]][k];            &#125;        &#125;    &#125;    ll ans = f[N][M][O];    printf(&quot;%lld\\n&quot;, ans);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划","OEIS"]},{"title":"Project Euler 178","url":"/project-euler/178/","content":"\r\nProject Euler 178\r\n题目\r\nStep Numbers\r\nConsider the number \\(45656\\).\r\nIt can be seen that each pair of consecutive digits of \\(45656\\) has a difference of one.\r\nA number for which every pair of consecutive digits has a difference\r\nof one is called a step number.\r\nA pandigital number contains every decimal digit from \\(0\\) to \\(9\\) at least once.\r\nHow many pandigital step numbers less than \\(10^{40}\\) are there?\r\n解决方案\r\n本题是一道数位动态规划题。\r\n在每一个符合题意的数后面，都有两种方案填上一个数（如果个位是\\(0\\)或者是\\(9\\)，那么后面只能填上一位）。另外，数位的使用情况肯定是连续的，因此可以由\\(2^{10}=1024\\)的状态空间优化成\\(55\\)种使用情况。\r\n令\\(N=40\\)，那么令\\(f(i,l,r,d)(1\\le i\\le N,0\\le l\\le d\\le r \\le 9\r\n)\\)为有多少个\\(i\\)位数，使用了\\(l\\)和\\(r\\)之间的数位，目前个位为\\(d\\)的数有多少个。那么可以列出如下状态转移方程：\r\n\\[\r\nf(i,l,r,d)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i=1\\land l=r\\land r=d \\\\\r\n  &amp;0 &amp; &amp; \\text{else if}\\quad i=1\\lor l=r\\\\\r\n  &amp;f(i-1,l,r,d+1)+f(i-1,l+1,r,d+1) &amp; &amp; \\text{else if}\\quad\r\nl=d \\\\\r\n  &amp;f(i-1,l,r,d-1)+f(i-1,l,r-1,d-1) &amp; &amp; \\text{else if}\\quad\r\nr=d \\\\\r\n  &amp;f(i-1,l,r,d+1)+f(i-1,l,r,d-1) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n对于第三行，如果新填的数是来自区间的最左边，那么它有可能是第一次用，从\\(f(i-1,l+1,r,d+1)\\)转移而来；也有可能是再次使用，从\\(f(i-1,l,r,d+1)\\)转移而来。第四行也类似。\r\n对于最后一行，如果值在区间中间，那么它肯定不是第一次用，可以是之前填的数个位\\(-1\\)转移而来，也可以是\\(+1\\)转移而来。\r\n最终答案为：\r\n\\[\\sum_{i=1}^N\\sum_{d=0}^9f(i,0,9,d)\\]\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=40,M=10;ll f[N+3][M][M][M];int main()&#123;    for(int j=1;j&lt;M;j++)        f[1][j][j][j]=1;    for(int i=2;i&lt;=N;i++)        for(int l=0;l&lt;M;l++)            for(int r=l;r&lt;M;r++)                for(int d=l;d&lt;=r;d++)&#123;                    if(l&lt;d&amp;&amp;d&lt;r) f[i][l][r][d]=f[i-1][l][r][d-1]+f[i-1][l][r][d+1];                    else if(d==l) f[i][l][r][d]=f[i-1][l][r][d+1]+f[i-1][l+1][r][d+1];                    else f[i][l][r][d]=f[i-1][l][r][d-1]+f[i-1][l][r-1][d-1];                &#125;    ll ans=0;    for(int i=1;i&lt;=N;i++)        for(int d=0;d&lt;M;d++)            ans+=f[i][0][9][d];    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 183","url":"/project-euler/183/","content":"\r\nProject Euler 183\r\n题目\r\nMaximum product of parts\r\nLet \\(N\\) be a positive integer and\r\nlet \\(N\\) be split into \\(k\\) equal parts, \\(r = \\dfrac{N}{k}\\), so that \\(N = r + r + \\dots + r\\).\r\nLet \\(P\\) be the product of these\r\nparts, \\(P = r × r × \\dots × r =\r\nr^k\\).\r\nFor example, if \\(11\\) is split into\r\nfive equal parts, \\(11 = 2.2 + 2.2 + 2.2 + 2.2\r\n+ 2.2\\), then \\(P = 2.2^5 =\r\n51.53632\\).\r\nLet \\(M(N) = P_max\\) for a given\r\nvalue of \\(N\\).\r\nIt turns out that the maximum for \\(N =\r\n11\\) is found by splitting eleven into four equal parts which\r\nleads to \\(P_{\\max} =\r\n(\\dfrac{11}{4})^4\\); that is, \\(M(11) =\r\n\\dfrac{14641}{256} = 57.19140625\\), which is a terminating\r\ndecimal.\r\nHowever, for \\(N = 8\\) the maximum\r\nis achieved by splitting it into three equal parts, so \\(M(8) = \\dfrac{512}{27}\\), which is a\r\nnon-terminating decimal.\r\nLet \\(D(N) = N\\) if \\(M(N)\\) is a non-terminating decimal and\r\n\\(D(N) = -N\\) if \\(M(N)\\) is a terminating decimal.\r\nFor example, \\(\\sum D(N)\\) for \\(5 \\le N \\le 100\\) is \\(2438\\).\r\nFind \\(\\sum D(N)\\) for \\(5 \\le N \\le 10000\\).\r\n解决方案\r\n令函数\\(y(k)=\\left(\\dfrac{N}{k}\\right)^k\\)，其中\\(k\\in \\mathbb{N^+}\\)。\r\n由于函数\\(y(k)\\)的定义域是在整数域上，不好通过求导求最大值，因此将整数域扩展到实数域。\r\n令\\(z(x)=\\left(\\dfrac{N}{x}\\right)^x\\)，其中\\(x\\in \\mathbb{R}\\)。\r\n对\\(z(x)\\)求导，计算得\\(z\\)的导数\\(z&#39;(x)=\\left(\\dfrac{N}{x}\\right)^x\\cdot\r\n\\left(\\ln\\dfrac{N}{x}-1\\right)\\)。\r\n令\\(z&#39;(x)=0\\)，那么可以计算得到\\(x=\\dfrac{N}{e}\\)，\\(z(x)\\)在\\(x_0=\\dfrac{N}{e}\\)时将会取到最大值。\r\n回到函数\\(y(k)\\)，那么如果\\(y\\)要取到最大值，那么最大值点\\(k\\)为\\(\\left\\lfloor\\dfrac{N}{e}\\right\\rfloor,\\left\\lceil\\dfrac{N}{e}\\right\\rceil\\)两个值之一。\r\n因此，直接将它们代入函数\\(y(k)\\)代入，这种做法是可行的，不过由于\\(x_0=\\dfrac{N}{e}\\)是在指数上出现的，因此直接代入计算，可能会导致结果失真。这里取而代之的方法是，代入\\(y(k)\\)的对数函数\\(\\ln y(k)=k(\\ln N-\\ln k)\\)进行比较计算。\r\n最终找到最大值点\\(k_0\\)后，开始解决最大值是否为有限小数的问题。\r\n而这个问题比较简单，只需要判断分数\\(\\dfrac{N}{k_0}\\)是否为有限小数即可。\r\n代码\r\nfrom math import e, ceil, floor, log, gcdN = 10000ans = 0for n in range(5, N + 1):    val = n / e    l, r = floor(val), ceil(val)    logfl, logfr = l * log(n / l), r * log(n / r)    if logfl &gt; logfr:        x = l    else:        x = r    x //= gcd(x, n)    while x % 5 == 0:        x //= 5    while (x &amp; 1) == 0:        x &gt;&gt;= 1    if x == 1:        ans -= n    else:        ans += nprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 182","url":"/project-euler/182/","content":"\r\nProject Euler 182\r\n题目\r\nRSA encryption\r\nThe RSA encryption is based on the following procedure:\r\nGenerate two distinct primes \\(p\\)\r\nand \\(q\\).Compute \\(n=pq\\) and \\(\\varphi=(p-1)(q-1)\\).\r\nFind an integer \\(e,\r\n1&lt;e&lt;\\varphi\\), such that \\(\\gcd(e,\\varphi)=1\\).\r\nA message in this system is a number in the interval \\([0,n-1]\\).\r\nA text to be encrypted is then somehow converted to messages (numbers\r\nin the interval \\([0,n-1]\\)).\r\nTo encrypt the text, for each message, \\(m,\r\nc=m^e \\bmod n\\) is calculated.\r\nTo decrypt the text, the following procedure is needed: calculate\r\n\\(d\\) such that \\(ed=1 \\bmod \\varphi\\), then for each\r\nencrypted message, \\(c\\), calculate\r\n\\(m=c^d \\bmod n\\).\r\nThere exist values of \\(e\\) and\r\n\\(m\\) such that \\(m^e \\bmod n=m\\).\r\nWe call messages \\(m\\) for which\r\n\\(m^e \\bmod n=m\\) unconcealed\r\nmessages.\r\nAn issue when choosing e is that there should not be too many\r\nunconcealed messages.\r\nFor instance, let \\(p=19\\) and \\(q=37\\).\r\nThen \\(n=19\\times37=703\\) and \\(\\varphi=18\\times36=648\\).\r\nIf we choose \\(e=181\\), then,\r\nalthough \\(\\gcd(181,648)=1\\) it turns\r\nout that all possible messages \\(m (0\\le m\\le\r\nn-1)\\) are unconcealed when calculating \\(m^e \\bmod n\\).\r\nFor any valid choice of e there exist some unconcealed messages.It’s\r\nimportant that the number of unconcealed messages is at a minimum.\r\nChoose \\(p=1009\\) and \\(q=3643\\).\r\nFind the sum of all values of \\(e\\),\r\n\\(1&lt;e&lt;\\varphi(1009,3643)\\) and\r\n\\(\\gcd(e,\\varphi)=1\\), so that the\r\nnumber of unconcealed messages for this value of \\(e\\) is at a minimum.\r\n解决方案\r\n不难发现，\\(m^e\\equiv m \\pmod n \\Rightarrow\r\nm^e\\equiv m \\pmod p\\land m^e \\equiv m \\pmod q\\)。\r\n容易发现，当\\(m=0\\)时，为一个解。其余\\(m\\)满足\\(p \\mid\r\nm\\)或者\\(q\\mid m\\)都不是解。\r\n对于其余情况，不失一般性，仅解\\(m^e\\equiv m\r\n\\pmod p\\)，那么有\\(m^{e-1}\\equiv 1\r\n\\pmod p\\)。\r\n原问题转化成关于\\(m\\)的方程\\(m^{e-1}\\equiv 1 \\pmod\r\np\\)有多少个解。令\\(r=e-1\\)。\r\n设\\(g\\)为群\\(\\mathbb{Z}_p^{\\ast}\\)中的一个原根（原根：对于群元素\\(g\\)，假设\\(x\\)是满足\\(g^x\\equiv1 \\pmod p\\)的最小正整数，如果\\(x=p-1\\)，那么\\(g\\)为群\\(\\mathbb{Z}_p^{\\ast}\\)）。根据原根的定义，对于任意整数\\(i\\in\\{0,1,\\dots,p-2\\}\\)，\\(g^i\\)都可以和群元素\\(a\\)一一对应。\r\n令\\(m=g^i\\)，那么问题转化成\\(g^{ri}\\equiv1 \\pmod p\\)有多少个\\(i\\)是满足此式的。也就是说，有多少个\\(i\\)满足\\(ri\\equiv0\\pmod {p-1}\\)，即\\(p-1\\mid ri\\)。\r\n令\\(d=\\gcd(p-1,r)\\)，那么就得到\\(\\dfrac{p-1}{d}\\mid i\\)。因此，这样的\\(i\\)一共有\\(d\\)个。\r\n回到原来的题目，那么关于\\(m\\)的方程\\(m^{e-1}\\equiv 1\\pmod p\\)一共有\\(\\gcd(p-1,e-1)\\)个解。\r\n利用中国剩余定理的思想，并加上\\(m=0\\)的情况，关于\\(m\\)的方程\\(m^e\\equiv m \\pmod n\\)一共有\\((1+\\gcd(p-1,e-1))(1+\\gcd(q-1,e-1))\\)个解。\r\n一个优化：由于\\(\\gcd(e,\\varphi)=1\\)，因此\\(e\\)必须是奇数。所以对于上面的式子而言，\\(\\gcd(p-1,e-1),\\gcd(q-1,e-1)\\)的值至少为\\(2\\)。可以发现将会存在\\(e\\)满足这两个\\(\\gcd\\)的值都为\\(2\\)。\r\n更进一步的优化：事先寻找出所有模\\(p-1\\)为\\(2\\)的值，然后通过中国剩余定理进行合并。此处不详述这个优化。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int P=1009,Q=3643;int n=P*Q,phi=(P-1)*(Q-1);int main()&#123;    ll ans=0;    for(int e=2;e&lt;phi;e++)        if(__gcd(e,phi)==1&amp;&amp;__gcd(e-1,P-1)==2&amp;&amp;__gcd(e-1,Q-1)==2)            ans+=e;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 184","url":"/project-euler/184/","content":"\r\nProject Euler 184\r\n题目\r\nTriangles containing the\r\norigin\r\nConsider the set \\(I_r\\) of points\r\n\\((x,y)\\) with integer co-ordinates in\r\nthe interior of the circle with radius \\(r\\), centered at the origin, i.e. \\(x^2 + y^2 &lt; r^2\\).\r\nFor a radius of \\(2\\), \\(I_2\\) contains the nine points \\((0,0), (1,0), (1,1), (0,1), (-1,1), (-1,0),\r\n(-1,-1), (0,-1)\\) and \\((1,-1)\\). There are eight triangles having\r\nall three vertices in \\(I_2\\) which\r\ncontain the origin in the interior. Two of them are shown below, the\r\nothers are obtained from these by rotation.\r\n\r\nFor a radius of \\(3\\), there are\r\n\\(360\\) triangles containing the origin\r\nin the interior and having all vertices in \\(I_3\\) and for \\(I_5\\) the number is \\(10600\\).\r\nHow many triangles are there containing the origin in the interior\r\nand having all three vertices in \\(I_{105}\\)?\r\n解决方案\r\n令\\(N=105\\)，考虑在\\(x\\)轴上方以及\\(x\\)周的正半轴所有点\\((x,y)\\)（对这些点更形式化的定义：\\(0&lt;x^2+y^2&lt;N^2, y&gt;0\\lor (y=0\\land\r\nx&gt;0)\\)），按照极角统计这些点的数量。\r\n对于上半部分的这一些点，随机选择三个极角两两不相同的点，它们都能够对应\\(2\\)个原点\\(O\\)在内部的三角形，如下图：\r\n\r\n按照极角从小到大分别表示\\(A,B,C\\)三个点（其极角分别为\\(\\alpha.\\beta,\\gamma\\)），有两种情况：\r\n\r\n极角在中间的点\\(B\\)在\\(x\\)轴上面，极角在两侧的点\\(A,C\\)的中心对称点\\(A&#39;,C&#39;\\)在\\(x\\)轴下面。\r\n极角在中间的点\\(B\\)的中心对称点\\(B&#39;\\)在\\(x\\)轴下面，极角在两侧的点\\(A,C\\)在\\(x\\)轴上面。\r\n\r\n令\\(g(k)\\)表示上述极角为\\(k\\)的个数。令\\(s_r=\\sum_k g^r(k)\\)，那么本题答案为\\(\\dfrac{s_1^3-3s_1s_2+2s_3}{3}\\)。\r\n计算过程使用了容斥原理的思想，如下：\r\n一开始，顺序随机选定\\(A,B,C\\)三个点（不考虑极角顺序），有\\(s_1^3\\)种选择方法。然后，需要去掉三个点中有两个极角相同的情况，需要去掉\\(3s_1s_2\\)种选法。但是，三个点都在同一极角的情况又多减去了\\(2\\)次，因此需要添加回\\(2s_3\\)。由于\\(A,B,C\\)三个点选择方法本身是无序的，因此整个选择方法需要除\\(3!\\)。每一种选法都对应两个原点在内部的三角形，需要乘回\\(2\\)。因此本题的最终结果为：\r\n\\[\\dfrac{s_1^3-3s_1s_2+2s_3}{3}\\]\r\n（\\(O(\\log\r\nR)\\)甚至是亚线性做法待补）\r\n代码\r\nfrom fractions import FractionN = 6slopes_dict = &#123;&#125;nb_of_points = 0for i in range(0, N):    for j in range(1, N):        w = i * i + j * j        if i * i + j * j &lt; N * N:            nb_of_points += 1            if i != 0 and j != 0:                s = Fraction(j, i)                if s in slopes_dict.keys():                    slopes_dict[s] += 1                else:                    slopes_dict[s] = 1slopes_dict[0] = N - 1ls = list(slopes_dict.values()) * 2s1 = sum(ls)s2 = sum(x * x for x in ls)s3 = sum(x ** 3 for x in ls)ans = (s1 ** 3 - 3 * s1 * s2 + 2 * s3) // 3print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 185","url":"/project-euler/185/","content":"\r\nProject Euler 185\r\n题目\r\nNumber Mind\r\nThe game Number Mind is a variant of the well known game Master\r\nMind.\r\nInstead of coloured pegs, you have to guess a secret sequence of\r\ndigits. After each guess you’re only told in how many places you’ve\r\nguessed the correct digit. So, if the sequence was \\(1234\\) and you guessed \\(2036\\), you’d be told that you have one\r\ncorrect digit; however, you would NOT be told that you also have another\r\ndigit in the wrong place.\r\nFor instance, given the following guesses for a \\(5\\)-digit secret sequence,\r\n90342 ;2 correct 70794 ;0 correct 39458 ;2 correct 34109\r\n;1 correct 51545 ;2 correct 12531 ;1 correct\r\nThe correct sequence \\(39542\\) is\r\nunique.\r\nBased on the following guesses,\r\n5616185650518293 ;2 correct 3847439647293047 ;1 correct\r\n5855462940810587 ;3 correct 9742855507068353 ;3 correct\r\n4296849643607543 ;3 correct 3174248439465858 ;1 correct\r\n4513559094146117 ;2 correct 7890971548908067 ;3 correct\r\n8157356344118483 ;1 correct 2615250744386899 ;2 correct\r\n8690095851526254 ;3 correct 6375711915077050 ;1 correct\r\n6913859173121360 ;1 correct 6442889055042768 ;2 correct\r\n2321386104303845 ;0 correct 2326509471271448 ;2 correct\r\n5251583379644322 ;2 correct 1748270476758276 ;3 correct\r\n4895722652190306 ;1 correct 3041631117224635 ;3 correct\r\n1841236454324589 ;3 correct 2659862637316867 ;2 correct\r\nFind the unique 16-digit secret sequence.\r\n解决方案\r\n本代码基于深度优先搜索寻找答案，枚举的内容是枚举线索中“未确定的正确数位组合”。实现时，使用了嵌套DFS。外层的DFS用于搜索每个线索；内层DFS属于组合枚举，用于寻找“未确定的正确数位组合”。\r\n使用的优化如下：\r\n\r\n将每条线索基于正确数量从小到大排序，避免一开始枚举组合的数量过大。\r\n如果遍历到某条线索，发现正确数量太多，那么及时返回。\r\n枚举某条线索的“未确定的正确数位组合”时，忽略那些目前是错误的或者是已经填数的数位。\r\n\r\n本题也可以使用meet-in-the-middle思想，或者是模拟退火算法完成。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;const int N = 22;const int M = 16;const int D = 10;int vis[M][D] = &#123;0&#125;;int tmp[M];int A[N][M] = &#123;        &#123;2, 3, 2, 1, 3, 8, 6, 1, 0, 4, 3, 0, 3, 8, 4, 5&#125;,        &#123;3, 8, 4, 7, 4, 3, 9, 6, 4, 7, 2, 9, 3, 0, 4, 7&#125;,        &#123;3, 1, 7, 4, 2, 4, 8, 4, 3, 9, 4, 6, 5, 8, 5, 8&#125;,        &#123;8, 1, 5, 7, 3, 5, 6, 3, 4, 4, 1, 1, 8, 4, 8, 3&#125;,        &#123;6, 3, 7, 5, 7, 1, 1, 9, 1, 5, 0, 7, 7, 0, 5, 0&#125;,        &#123;6, 9, 1, 3, 8, 5, 9, 1, 7, 3, 1, 2, 1, 3, 6, 0&#125;,        &#123;4, 8, 9, 5, 7, 2, 2, 6, 5, 2, 1, 9, 0, 3, 0, 6&#125;,        &#123;5, 6, 1, 6, 1, 8, 5, 6, 5, 0, 5, 1, 8, 2, 9, 3&#125;,        &#123;4, 5, 1, 3, 5, 5, 9, 0, 9, 4, 1, 4, 6, 1, 1, 7&#125;,        &#123;2, 6, 1, 5, 2, 5, 0, 7, 4, 4, 3, 8, 6, 8, 9, 9&#125;,        &#123;6, 4, 4, 2, 8, 8, 9, 0, 5, 5, 0, 4, 2, 7, 6, 8&#125;,        &#123;2, 3, 2, 6, 5, 0, 9, 4, 7, 1, 2, 7, 1, 4, 4, 8&#125;,        &#123;5, 2, 5, 1, 5, 8, 3, 3, 7, 9, 6, 4, 4, 3, 2, 2&#125;,        &#123;2, 6, 5, 9, 8, 6, 2, 6, 3, 7, 3, 1, 6, 8, 6, 7&#125;,        &#123;5, 8, 5, 5, 4, 6, 2, 9, 4, 0, 8, 1, 0, 5, 8, 7&#125;,        &#123;9, 7, 4, 2, 8, 5, 5, 5, 0, 7, 0, 6, 8, 3, 5, 3&#125;,        &#123;4, 2, 9, 6, 8, 4, 9, 6, 4, 3, 6, 0, 7, 5, 4, 3&#125;,        &#123;7, 8, 9, 0, 9, 7, 1, 5, 4, 8, 9, 0, 8, 0, 6, 7&#125;,        &#123;8, 6, 9, 0, 0, 9, 5, 8, 5, 1, 5, 2, 6, 2, 5, 4&#125;,        &#123;1, 7, 4, 8, 2, 7, 0, 4, 7, 6, 7, 5, 8, 2, 7, 6&#125;,        &#123;3, 0, 4, 1, 6, 3, 1, 1, 1, 7, 2, 2, 4, 6, 3, 5&#125;,        &#123;1, 8, 4, 1, 2, 3, 6, 4, 5, 4, 3, 2, 4, 5, 8, 9&#125;&#125;;int B[N] = &#123;0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3&#125;;bool dfs1(int, int);bool dfs2(int f, int finish, int f1, int cnt, int st, char *neglect) &#123;    if (f1 == cnt) &#123;        for (int i = 0; i &lt; M; i++)            vis[i][A[f][i]]++;        if (dfs1(f + 1, finish + cnt)) return true;        for (int i = 0; i &lt; M; i++)            vis[i][A[f][i]]--;        return false;    &#125;    for (int i = st; i &lt; M; i++) &#123;        if (neglect[i]) continue;        tmp[i] = A[f][i];        if (dfs2(f, finish, f1 + 1, cnt, i + 1, neglect)) return true;        tmp[i] = -1;    &#125;    return false;&#125;bool dfs1(int f, int finish) &#123;    if (f == N) &#123;        for (int i = 0; i &lt; M; i++) &#123;            if (tmp[i] == -1) &#123;                for (int j = 0; j &lt; D; j++) &#123;                    if (vis[i][j] == 0)                        tmp[i] = j;                &#125;            &#125;        &#125;        return true;    &#125;    int cnt = B[f];    for (int i = 0; i &lt; M; i++)        cnt -= (A[f][i] == tmp[i]);    if (cnt &lt; 0)return false;    char neglect[M] = &#123;0&#125;;    for (int i = 0; i &lt; M; i++)        if (tmp[i] != -1 || vis[i][A[f][i]]) neglect[i] = 1;    if (dfs2(f, finish, 0, cnt, 0, neglect)) return true;    return false;&#125;int main() &#123;    memset(tmp,-1,sizeof(tmp));    dfs1(0, 0);    string ans;    for (int i = 0; i &lt; M; i++)        ans += char(&#x27;0&#x27; + tmp[i]);    cout &lt;&lt; ans &lt;&lt; endl;    return 0;&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 186","url":"/project-euler/186/","content":"\r\nProject Euler 186\r\n题目\r\nConnectedness of a network\r\nHere are the records from a busy telephone system with one million\r\nusers:\r\n\r\n\r\n\r\nRec Nr\r\nCaller\r\nCalled\r\n\r\n\r\n\r\n\r\n\\(1\\)\r\n\\(200007\\)\r\n\\(100053\\)\r\n\r\n\r\n\\(2\\)\r\n\\(600183\\)\r\n\\(500439\\)\r\n\r\n\r\n\\(3\\)\r\n\\(600863\\)\r\n\\(701497\\)\r\n\r\n\r\n\\(\\dots\\)\r\n\\(\\dots\\)\r\n\\(\\dots\\)\r\n\r\n\r\n\r\nThe telephone number of the caller and the called number in record\r\n\\(n\\) are \\(\\text{Caller}(n) = S_{2n-1}\\) and \\(\\text{Called}(n) = S_{2n}\\) where \\(S_{1,2,3,\\dots}\\) come from the “Lagged\r\nFibonacci Generator”:\r\nFor \\(1 \\le k \\le 55, S_k = [100003 -\r\n200003k + 300007 k^3] (\\text{modulo\\ } 1000000)\\) For \\(56 \\le k, S_k = [S_k-24 + S_k-55] (\\text{modulo\\ }\r\n1000000)\\)\r\nIf \\(\\text{Caller(n)} =\r\n\\text{Called(n)}\\) then the user is assumed to have misdialled\r\nand the call fails; otherwise the call is successful.\r\nFrom the start of the records, we say that any pair of users \\(X\\) and \\(Y\\) are friends if \\(X\\) calls \\(Y\\) or vice-versa. Similarly, \\(X\\) is a friend of a friend of \\(Z\\) if \\(X\\) is a friend of \\(Y\\) and \\(Y\\) is a friend of \\(Z\\); and so on for longer chains.\r\nThe Prime Minister’s phone number is \\(524287\\). After how many successful calls,\r\nnot counting misdials, will \\(99\\%\\) of\r\nthe users (including the PM) be a friend, or a friend of a friend etc.,\r\nof the Prime Minister?\r\n并查集\r\n并查集：用于高效处理一些不相交集合的数据结构。一般有两个操作：合并两个集合；查询两个元素是否在同一个集合中。\r\n可以通过优化将并查集这两种单次操作优化到\\(O(\\alpha(n))\\)级别，其中\\(\\alpha(n)\\)是反阿克曼函数（一个增长速率非常接近于零的函数）。\r\n解决方案\r\n本题为并查集的模板题，直接用并查集数据结构实现。\r\n代码中需要维护每个集合的大小。为了避免错误，只有两个元素不属于同一个集合时才需要合并。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=1000000,P=524287,A=N/100*99;const int M=N*5;int fa[N],sz[N];int find(int x)&#123;return x==fa[x]?x:fa[x]=find(fa[x]);&#125;void merge(int x,int y)&#123;    int u=find(x),v=find(y);    if(u!=v)&#123;        fa[u]=v;        sz[v]+=sz[u];    &#125;&#125;int s[M];int main()&#123;    int cnt=0,ans=0;    for(int i=0;i&lt;N;i++)        fa[i]=i,sz[i]=1;    for(int i=1;i&lt;=55;i++)        s[i]= (1ll * 300007 * i * i * i + 100003 - 200003 * i) % N;    for(int i=56;i&lt;M;i++)        s[i]= (s[i - 24] + s[i - 55]) % N;    for(int i=2;i&lt;M;i+=2)&#123;        if(s[i] == s[i - 1]) ++cnt;        else&#123;            merge(s[i], s[i - 1]);            if(sz[find(P)]&gt;=A)&#123;                ans=i/2-cnt;                break;            &#125;        &#125;    &#125;    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["并查集"]},{"title":"Project Euler 187","url":"/project-euler/187/","content":"\r\nProject Euler 187\r\n题目\r\nSemiprimes\r\nA composite is a number containing at least two prime factors. For\r\nexample, \\(15 = 3 \\times 5; 9 = 3 \\times 3; 12\r\n= 2 \\times 2 \\times 3\\).\r\nThere are ten composites below thirty containing precisely two, not\r\nnecessarily distinct, prime factors: \\(4, 6,\r\n9, 10, 14, 15, 21, 22, 25, 26\\).\r\nHow many composite integers, \\(n &lt;\r\n10^8\\), have precisely two, not necessarily distinct, prime\r\nfactors?\r\n解决方案\r\n由于要求的半素数其中一个质因子至少为\\(2\\)，因此只需要枚举\\(\\dfrac{N}{2}\\)之前的质数。\r\n由于\\(M=\\dfrac{N}{2}\\)的范围依旧比较大，故使用线性筛将所有质数枚举出来。\r\n按顺序产生质数后，设其数组为\\(pr\\)。使用双指针法，在第一层循环从左到右枚举左指针\\(l\\)，第二层循环右往左枚举右指针\\(r\\)，并枚举到第一个\\(pr[l]\\cdot pr[r]&lt; N\\)的最大\\(r\\)。\\(r\\)左边和\\(l\\)右边的所有质数都可以和\\(pr[l]\\)组成答案，统计这一段数的数量。\r\n需要注意还有一种情况，就是质数的平方数。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int O=1e8;const int N=O/2;int v[N+4],pr[N+4],m=0;int main()&#123;    for(int i=2;i&lt;N;i++)&#123;        if(v[i]==0)&#123;            pr[++m]=i;v[i]=i;        &#125;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;N/i) break;            v[i*pr[j]]=pr[j];        &#125;    &#125;    ll ans=0;    for(int l=1,r=m;l&lt;=r;l++)&#123;        for(;pr[l]*pr[r]&gt;=O;r--);        ans+=r-l+1;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["双指针"]},{"title":"Project Euler 189","url":"/project-euler/189/","content":"\r\nProject Euler 189\r\n题目\r\nTri-colouring a triangular\r\ngrid\r\nConsider the following configuration of 64 triangles:\r\n\r\nWe wish to colour the interior of each triangle with one of three\r\ncolours: red, green or blue, so that no two neighbouring triangles have\r\nthe same colour. Such a colouring shall be called valid. Here, two\r\ntriangles are said to be neighbouring if they share an edge.\r\nNote: if they only share a vertex, then they are not neighbours.\r\nFor example, here is a valid colouring of the above grid:\r\n\r\nA colouring \\(C’\\) which is obtained\r\nfrom a colouring \\(C\\) by rotation or\r\nreflection is considered distinct from \\(C\\) unless the two are identical.\r\nHow many distinct valid colourings are there for the above\r\nconfiguration?\r\n解决方案\r\n本题是一道基于三进制的状态压缩动态规划题目。\r\n由于每一层的三角形中只有正三角形才会对下一层产生影响，倒三角形不会。因此我们描述每一层的状态时，只描述第\\(k\\)层的\\(k\\)个正三角形的涂色状态，因此，用一个\\(k\\)位三进制数\\(b=b_{k-1}b_{k-2}\\dots\r\nb_0\\)来表示。其中，\\(b_i\\)只取值\\(0,1,2\\)，分别表示涂上的\\(3\\)种颜色。\r\n令\\(N=8\\)，设\\(f(i,j)(1\\le i\\le N,0\\le j&lt; 3^i)\\)第\\(i\\)行中，涂色状态为\\(j\\)的方法有多少种。在这里，\\(j\\)表示成\\(i\\)位三进制数\\(j_{i,i-1}j_{i,i-2}\\dots j_{i,0}\\)。\r\n那么，考虑倒三角形的涂色方案，如下图所示：\r\n\r\n确定了第\\(i\\)行和第\\(i-1\\)行的状态后，考虑转移。一个倒三角形填色的方案必须和相邻的三个正三角形的颜色不一样。第\\(i\\)行的\\(i-1\\)个倒三角形互不相邻，因此根据乘法原理，可以将这些填色方案相乘，完成转移。\r\n可以列出如下状态转移方程：\r\n\\[\r\nf(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i=1 \\\\\r\n  &amp;\\sum_{k=0}^{3^{i-1}-1}f(i-1,k)\\cdot\r\n\\prod_{l=0}^{i-1}  \\text{excluded}(j_{i,l},j_{i,l+1},k_{i-1,l})&amp;\r\n&amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n其中，函数\\(\\text{excluded}(a,b,c)\\)表示集合\\(\\{0,1,2\\}\\)去掉元素\\(a,b,c\\)后的大小。\r\n那么最终结果为：\r\n\\[\\sum_{j=0}^{3^N-1}f(N,j)\\]\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=8;const int M = pow(3,N);ll f[N+1][M];int pw3[N+1],c[8];vector&lt;int&gt;g[M];int main() &#123;    for (int i = 0; i &lt; 8; i++) &#123;        c[i] = 3 - __builtin_popcount(i);    &#125;    pw3[0] = 1;    for (int i = 1; i &lt;= N; i++)        pw3[i] = pw3[i - 1] * 3;    for (int j = 0; j &lt; pw3[N]; j++) &#123;        for (int k = 0, x = j; k &lt; N; k++, x /= 3)            g[j].push_back(x % 3);    &#125;    f[1][0] = f[1][1] = f[1][2] = 1;    for (int i = 2; i &lt;= N; i++) &#123;        for (int j = 0; j &lt; pw3[i]; j++) &#123;            for (int k = 0; k &lt; pw3[i - 1]; k++) &#123;                int v = 1;                for (int l = 0; l + 1 &lt; i; l++)                    v *= c[1 &lt;&lt; g[k][l] | 1 &lt;&lt; g[j][l] | 1 &lt;&lt; g[j][l + 1]];                f[i][j] += f[i - 1][k] * v;            &#125;        &#125;    &#125;    ll ans = 0;    for (int i = 0; i &lt; pw3[N]; i++)        ans += f[N][i];    printf(&quot;%lld\\n&quot;, ans);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 19","url":"/project-euler/19/","content":"\r\nProject Euler 19\r\n题目\r\nCounting Sundays\r\nYou are given the following information, but you may prefer to do\r\nsome research for yourself.\r\n\r\n\\(1\\) Jan \\(1900\\) was a Monday.\r\nThirty days has September, April, June and November. All\r\nthe rest have thirty-one, Saving February alone, Which has\r\ntwenty-eight, rain or shine. And on leap years,\r\ntwenty-nine.\r\nA leap year occurs on any year evenly divisible by \\(4\\), but not on a century unless it is\r\ndivisible by \\(400\\).\r\n\r\nHow many Sundays fell on the first of the month during the twentieth\r\ncentury (\\(1\\) Jan \\(1901\\) to \\(31\\) Dec \\(2000\\))?\r\n解决方案\r\n可以使用Python中datetime包的date类解决。\r\n代码\r\nfrom datetime import datel = 1901r = 2000ans = 0for y in range(l, r + 1):    for m in range(1, 13):        if date(y, m, 1).isoweekday() == 7:            ans += 1print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 188","url":"/project-euler/188/","content":"\r\nProject Euler 188\r\n题目\r\nThe hyperexponentiation of\r\na number\r\nThe hyperexponentiation or tetration of a number a\r\nby a positive integer b, denoted by \\(a\\uparrow\\uparrow b\\) or \\(^ba\\), is recursively defined by:\r\n\\(a\\uparrow\\uparrow1 = a,\r\na\\uparrow\\uparrow(k+1) = a^{(a\\uparrow\\uparrow k)}\\).\r\nThus we have e.g. \\(3\\uparrow\\uparrow2 =\r\n3^3 = 27\\), hence \\(3\\uparrow\\uparrow3\r\n= 3^{27} = 7625597484987\\) and \\(3\\uparrow\\uparrow4\\) is roughly \\(10^{3.6383346400240996*10^{12}}\\).\r\nFind the last \\(8\\) digits of \\(1777\\uparrow\\uparrow1855\\).\r\n欧拉降幂公式\r\n欧拉降幂公式，用于高效计算\\(a^b\\%\r\nm\\)的值（尤其\\(b\\)很大时）：\r\n\\[\r\na^b\\equiv\r\n\\left \\{\\begin{aligned}\r\n  &amp;a^{b\\% \\varphi(m)}  &amp; &amp; \\text{if}\\quad \\gcd(a,m)=1 \\\\\r\n  &amp;a^b &amp; &amp; \\text{else if}\\quad b&lt;\\varphi(m) &amp;\\pmod\r\nm\\\\\r\n  &amp;a^{b\\%\\varphi(m)+\\varphi(m)} &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n其中\\(\\varphi\\)为欧拉函数。\r\n解决方案\r\n根据式子的定义，通过欧拉降幂公式直接递归计算指数，再计算出式子的值本身。可以知道，递归的层数很低。\r\n代码\r\nfrom tools import phifrom math import logN = 1777M = 1855mod = 10 ** 8def dfs(a: int, f: int, mod: int):    if f &lt;= 1:        return pow(a, f, mod), False    elif mod == 1:        return 0, True    else:        ph = phi(mod)        val, flag = dfs(a, f - 1, ph)        if flag or val * log(a) &gt;= log(mod):            return pow(a, val + ph, mod), True        else:            return pow(a, val, mod), Falseans = &quot;&#123;:08&#125;&quot;.format(dfs(N, M, mod)[0])print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 190","url":"/project-euler/190/","content":"\r\nProject Euler 190\r\n题目\r\nMaximising a weighted\r\nproduct\r\nLet \\(S_m = (x_1, x_2, \\dots ,\r\nx_m)\\) be the \\(m\\)-tuple of\r\npositive real numbers with \\(x_1 + x_2 + \\dots\r\n+ x_m = m\\) for which \\(P_m = x_1\r\n*x_2^2* \\dots * x_m^m\\) is maximised.\r\nFor example, it can be verified that \\([P_{10}] = 4112\\) ([ ] is the integer part\r\nfunction).\r\nFind \\(\\sum[P_m]\\) for \\(2 \\le m \\le 15\\).\r\n拉格朗日乘数法\r\n拉格朗日乘数法（等式约束，与不等式约束相对）用于求多元函数在一定约束下的极值。拉格朗日乘数法可以将一个\\(n\\)元函数和\\(k\\)个约束条件的最优化问题转化成一个解\\(n+k\\)元方程组的解的问题。引入的一组新参数\\(\\lambda\\)，称为拉格朗日乘数。\r\n令\\(f(x_1,x_2,\\dots,x_n)\\)为需要求极值的多元函数，\\(g_1(x_1,x_2,\\dots,x_n)=0\\),\\(\\dots\\)为\\(k\\)个等式的约束，那么构造以下\\(n+k\\)元拉格朗日函数：\r\n\\[\\mathcal{L}(x_1,x_2,\\dots,x_n,\\lambda_1,\\lambda_2,\\dots,\\lambda_k)=f(x_1,x_2,\\dots,x_n)-\\sum_{i=1}^k\\lambda_ig_i(x_1,x_2,\\dots,x_n)\\]\r\n问题转化成对函数\\(\\mathcal{L}\\)求极值。\r\n解决方案\r\n令\\(f(x_1,x_2,\\dots,x_m)=\\prod_{i=1}^mx_i^i,g(x_1,x_2,\\dots,x_m)=\\sum_{i=1}^mx_i-m\\)。\r\n那么利用拉格朗日乘数法，构造拉格朗日函数：\r\n\\[\\mathcal{L}(x_1,x_2,\\dots,x_n,\\lambda)=f(x_1,x_2,\\dots,x_n)-\\lambda\r\ng(x_1,x_2,\\dots,x_n)=\\prod_{i=1}^mx_i^i-\\lambda\\left(\\sum_{i=1}^mx_i-m\\right)\\]\r\n为求最大值，对每个\\(x_i\\)求偏导数，有\r\n\\[\\dfrac{\\partial \\mathcal{L}}{\\partial\r\nx_i}=\\dfrac{i \\cdot f(x_1,x_2,\\dots,x_n)}{x_i}-\\lambda\\]\r\n令\\(\\dfrac{\\partial \\mathcal{L}}{\\partial\r\nx_i}=0\\)，得到\\(x_i=\\dfrac{i \\cdot\r\nf(x_1,x_2,\\dots,x_n)}{\\lambda}\\)。\r\n由这个式子不难发现，\\(x_i\\)的值，都是按比例分配的，即\\(\\forall\r\ni,j\\in[1,m],\\dfrac{x_i}{x_j}=\\dfrac{i}{j}\\)。\r\n因此根据\\(g\\)这个约束，可以得到最大值点为\\(x_i=\\dfrac{2i}{m+1}\\)。\r\n代码\r\nN = 15ans = 0for m in range(2, N + 1):    w = 1    for i in range(1, m + 1):        w *= (2 * i / (m + 1)) ** i    ans += int(w)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 191","url":"/project-euler/191/","content":"\r\nProject Euler 191\r\n题目\r\nPrize Strings\r\nA particular school offers cash rewards to children with good\r\nattendance and punctuality. If they are absent for three consecutive\r\ndays or late on more than one occasion then they forfeit their\r\nprize.\r\nDuring an \\(n\\)-day period a trinary\r\nstring is formed for each child consisting of L’s (late), O’s (on time),\r\nand A’s (absent).\r\nAlthough there are eighty-one trinary strings for a \\(4\\)-day period that can be formed, exactly\r\nforty-three strings would lead to a prize:\r\n OOOO OOOA\r\nOOOL OOAO OOAA OOAL OOLO OOLA OAOO OAOA OAOL OAAO OAAL OALO OALA\r\nOLOO OLOA OLAO OLAA AOOO AOOA AOOL AOAO AOAA AOAL AOLO AOLA AAOO\r\nAAOA AAOL AALO AALA ALOO ALOA ALAO ALAA LOOO LOOA LOAO LOAA LAOO\r\nLAOA LAAO\r\nHow many “prize” strings exist over a \\(30\\)-day period?\r\n解决方案\r\n本题可以使用动态规划进行解决。\r\n假设\\(f(i,j)(i\\ge 0,0\\le j\\le\r\n2)\\)为长度\\(i\\)的只有O和A的字符串中，字符串最后面已经有连续\\(j\\)个A的字符串个数。\r\n很容易列出以下状态转移方程：\r\n\\[\r\nf(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1 &amp; &amp; \\text{if}\\quad i=0\\land j=0 \\\\\r\n  &amp;0 &amp; &amp; \\text{else if}\\quad i=0 \\\\\r\n  &amp;\\sum_{k=0}^2f(i-1,k) &amp; &amp; \\text{else if}\\quad j=0 \\\\\r\n  &amp;f(i-1,j-1) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n无论什么情况，只要添加一个O，那么后面就没有连续的A了。如果添加一个A，那么连续的A的个数\\(j\\)就会增加\\(1\\)。\r\n令\\(g(i)=f(i,0)+f(i,1)+f(i,2)\\)，那么最终答案为\\(g(n)+\\sum_{i=1}^ng(i-1)\\cdot g(n-i)\\)。\r\n如果考虑上字母L，可以整合成一个\\(6\\)个状态的动态规划。在这个基础上，可以使用矩阵快速幂将整个流程加速到\\(O(\\log\r\nn)\\)级别（这并非是本方案的核心内容）。Leetcode\r\n552题解有对本题的更进一步的优化。\r\n代码\r\nN = 30f0, f1, f2 = 1, 0, 0g = [1]for i in range(1, N + 1):    f0, f1, f2 = f0 + f1 + f2, f0, f1    g.append(f0 + f1 + f2)ans = g[N]for i in range(1, N + 1):    ans += g[i - 1] * g[N - i]print(ans)\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 192","url":"/project-euler/192/","content":"\r\nProject Euler 192\r\n题目\r\nBest Approximations\r\nLet x be a real number.\r\nA best approximation to \\(x\\) for\r\nthe denominator bound \\(d\\) is a\r\nrational number \\(\\dfrac{r}{s}\\) in\r\nreduced form, with \\(s \\le d\\), such\r\nthat any rational number which is closer to \\(x\\) than \\(\\dfrac{r}{s}\\) has a denominator larger\r\nthan \\(d\\):\r\n\\[\\left|\\dfrac{p}{q}-x\\right| &lt;\r\n\\left|\\dfrac{r}{s}-x\\right| \\Rightarrow q &gt; d\\]\r\nFor example, the best approximation to \\(\\sqrt{13}\\) for the denominator bound \\(20\\) is \\(\\dfrac{18}{5}\\) and the best approximation\r\nto \\(\\sqrt{13}\\) for the denominator\r\nbound \\(30\\) is \\(\\dfrac{101}{28}\\).\r\nFind the sum of all denominators of the best approximations to \\(\\sqrt{n}\\) for the denominator bound \\(10^{12}\\), where \\(n\\) is not a perfect square and \\(1 &lt; n \\le 100000\\).\r\n解决方案\r\n令\\(M=10^{12}\\)。如果需要求无理数\\(\\sqrt{n}\\)的有理近似，那么我们将在Stern-Brocot\r\nTree上“尝试”查找这个数。（这里使用的Stern-Brocot\r\nTree是全体最简分数，因此最小值为\\(0\\)，最大值则推广到无穷。）\r\n最终，寻找到两个候选答案\\(\\dfrac{a}{c},\\dfrac{b}{d}\\)，满足\\(\\dfrac{a}{c}&lt;\\sqrt{n}&lt;\\dfrac{b}{d},c,d \\le\r\nM\\)。判断这两个分数谁比较接近即可。\r\n为了避免浮点数产生的误差，进行浮点数比较时会转成整数之间的比较：\r\n\r\n比较分数\\(\\dfrac{p}{q}\\)和\\(\\sqrt{n}\\)，相当于比较\\(p^2\\)和\\(nq^2\\)的大小。\r\n比较\\(\\sqrt{n}-\\dfrac{a}{c}\\)和\\(\\dfrac{b}{d}-\\sqrt{n}\\)，经转化后，相当于比较\\(4nc^2d^2\\)和\\((bc+ad)^2\\)的大小。\r\n\r\n另一个用有理数近似无理数的相关的方法是基于连分数的，在该页面中有介绍。\r\n代码\r\nN = 10 ** 5M = 10 ** 12def cal(n):    a, c = 0, 1    b, d = 1, 0    while True:        p = a + b        q = c + d        if q &gt; M:            if 4 * n * c ** 2 * d ** 2 &lt; (a * d + b * c) ** 2:                return c            else:                return d        else:            t = p * p - q * q * n            if t == 0:                # 找到了一个有理数p/q，其值为sqrt(n)，这说明n是个平方数，不是我们需要求的。                break            if t &gt; 0:                b, d = p, q            else:                a, c = p, q    return 0ans = sum(cal(x) for x in range(2, N + 1))print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 193","url":"/project-euler/193/","content":"\r\nProject Euler 193\r\n题目\r\nSquarefree Numbers\r\nA positive integer \\(n\\) is called\r\nsquarefree, if no square of a prime divides \\(n\\), thus \\(1, 2,\r\n3, 5, 6, 7, 10, 11\\) are squarefree, but not \\(4, 8, 9, 12\\).\r\nHow many squarefree numbers are there below \\(2^{50}\\)?\r\n莫比乌斯函数\r\n莫比乌斯函数，常用于容斥原理。\r\n假设\\(n\\)的分解质因数为\\(n=p_1^{e_1}\\cdot p_2^{e_2}\\cdot \\dots \\cdot\r\np_k^{e_k}\\)，那么莫比乌斯函数\\(\\mu(n)\\)函数值定义如下：\r\n\\[\r\n\\mu(n)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1 &amp; &amp; \\text{if}\\quad n=1 \\\\\r\n  &amp;0 &amp; &amp; \\text{else if}\\quad \\exists m\\in[1,k],e_m&gt;1 \\\\\r\n  &amp;(-1)^k &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n解决方案\r\n基于容斥原理的思想，我们首先假设所有数都是无平方因子数，然后减去有\\(1\\)个质因子的\\(e_i&gt;1\\)的数。在此减去过程中，会有\\(2\\)两个质因子的\\(e_i&gt;1\\)的质数被重复减去，因此需要补回。。。\r\n为了不重不漏，有平方因子数完全不参与上面的过程。\r\n那么发现，只要有偶数个质因子的就会被增加，有奇数个质因子就会被减去。莫比乌斯函数恰好帮助我们表示了整个过程。\r\n使用线性筛计算莫比乌斯函数：如果筛出来的是一个新质因子，那么对原来的莫比乌斯函数值乘\\(-1\\)就可以得到新数的莫比乌斯函数值，如果是旧的质因子，那么直接赋\\(0\\)。\r\n最终答案为： \\[\\sum_{k=1}^{\\lfloor\\sqrt{N}\\rfloor}\r\n\\left\\lfloor\\dfrac{N}{k^2}\\right\\rfloor\\cdot \\mu(k)\\]\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll N=1ll&lt;&lt;50;const ll M=sqrt(N);int mu[M+1];int pr[M+1],v[M+1],m=0;int main()&#123;    mu[1]=1;    for(int i=2;i&lt;=M;i++)&#123;        if(v[i]==0)&#123;            pr[++m]=i;v[i]=i;            mu[i]=-1;        &#125;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;M/i) break;            v[i*pr[j]]=pr[j];            mu[i*pr[j]]=(v[i]==pr[j]?0:-mu[i]);        &#125;    &#125;    ll ans=0;    for(int i=1;i&lt;=M;i++)        ans+=1ll*mu[i]*(N/(1ll*i*i));    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["容斥原理"]},{"title":"Project Euler 194","url":"/project-euler/194/","content":"\r\nProject Euler 194\r\n题目\r\nColoured Configurations\r\nConsider graphs built with the units A:  and B: , where the units are glued along the\r\nvertical edges as in the graph .\r\nA configuration of type \\((a,b,c)\\)\r\nis a graph thus built of \\(a\\) units A\r\nand \\(b\\) units B, where the graph’s\r\nvertices are coloured using up to \\(c\\)\r\ncolours, so that no two adjacent vertices have the same colour.\r\nThe compound graph above is an example of a configuration of type\r\n\\((2,2,6)\\), in fact of type \\((2,2,c)\\) for all \\(c \\ge 4\\).\r\nLet \\(N(a,b,c)\\) be the number of\r\nconfigurations of type \\((a,b,c)\\).\r\nFor example, \\(N(1,0,3) = 24, N(0,2,4) =\r\n92928\\) and \\(N(2,2,3) =\r\n20736\\).\r\nFind the last \\(8\\) digits of \\(N(25,75,1984)\\).\r\n删除-收缩公式\r\n删除-收缩公式用于将描述无向图\\(G=(V,E)\\)的任意函数\\(f\\)转化成递归的形式：\r\n\\[f(G)=f(G\\setminus e)+f(G/e)\\]\r\n其中，边\\(e\\in E\\)是图\\(G\\)的任意一遍。\\(\\setminus\\)运算是将边\\(e\\)从\\(E\\)中删去，而\\(/\\)运算则是将边\\(e\\)的两个端点\\((u,v)\\)合并成一个新点\\(w\\)，其它之前和\\(u,v\\)分别关联的边都关联到\\(w\\)上。\r\n色多项式\r\n色多项式\\(P(G,x)\\)，表示一个无向图\\(G=(V,E)\\)用\\(x\\)种颜色进行着色的方案数量，其中相邻两点颜色不同。这个多项式有以下特点：\r\n\r\n最高次数为\\(|V|\\)\r\n最高次数的项系数为\\(1\\)\r\n所有项的系数都为整数\r\n\r\n可以利用删除-收缩公式递归地求解该色多项式\\(P(G,x)\\)。不难发现，当一个图\\(G\\)没有任何边时，\\(P(G,x)=x^{|V|}\\)，这也是删除-收缩公式的递归终点。\r\n解决方案\r\n通过暴力地对上面的删除-收缩公式进行迭代，可以得到两个单元的色多项式分别为：\r\n\\[P(A,x)=x^7-10x^6+ 43 x^5-103\r\nx^4+146x^3-115x^2+38x\\]\r\n\\[P(B,x)=x^7-9x^6+ 35 x^5-77\r\nx^4+102x^3-76x^2+24x\\]\r\n假设\\(a=25\\)为单元\\(A\\)的个数，\\(b=75\\)为单元\\(B\\)的个数，\\(c=1984\\)为拥有的彩色种数，那么答案为：\r\n\\[\\dfrac{\\binom{a+b}{a}P^a(A,c)P^b(B,c)}{(c(c-1))^{a+b-1}}\\]\r\n注意到两个相邻单元之间染色的点是合在一起的，因此需要除回\\(c(c-1)\\)。\r\n代码\r\nfrom tools import CA = 25B = 75C = 1984mod = 10 ** 8pA = C ** 7 - 10 * C ** 6 + 43 * C ** 5 - 103 * C ** 4 + 146 * C ** 3 - 115 * C ** 2 + 38 * CpB = C ** 7 - 9 * C ** 6 + 35 * C ** 5 - 77 * C ** 4 + 102 * C ** 3 - 76 * C ** 2 + 24 * Cans = C(A + B, B) * pow(pA, A) * pow(pB, B) // (C * (C - 1)) ** (A + B - 1) % modprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 198","url":"/project-euler/198/","content":"\r\nProject Euler 198\r\n题目\r\nAmbiguous Numbers\r\nA best approximation to a real number \\(x\\) for the denominator bound \\(d\\) is a rational number \\(\\dfrac{r}{s}\\) (in reduced form) with \\(s \\le d\\), so that any rational number\r\n\\(\\dfrac{p}{q}\\) which is closer to\r\n\\(x\\) than \\(\\dfrac{r}{s}\\) has \\(q &gt; d\\).\r\nUsually the best approximation to a real number is uniquely\r\ndetermined for all denominator bounds. However, there are some\r\nexceptions, e.g. \\(\\dfrac{9}{40}\\) has\r\nthe two best approximations \\(\\dfrac{1}{4}\\) and \\(\\dfrac{1}{5}\\) for the denominator bound\r\n\\(6\\). We shall call a real number\r\n\\(x\\) ambiguous, if there is\r\nat least one denominator bound for which \\(x\\) possesses two best approximations.\r\nClearly, an ambiguous number is necessarily rational.\r\nHow many ambiguous numbers \\(x=\\dfrac{p}{q}\\), \\(0 &lt; x &lt; \\dfrac{1}{100}\\), are there\r\nwhose denominator \\(q\\) does not exceed\r\n\\(10^8\\)?\r\n解决方案\r\n如果存在一个正整数\\(m\\)，使得两个分数\\(x=\\dfrac{a}{c},y=\\dfrac{b}{d}\\)在第\\(m\\)个Farey序列是相邻的。那么\\(\\dfrac{x+y}{2}\\)很明显是一个答案。\r\n因此，可以考虑对Stern-Brocot\r\nTree进行遍历，枚举出Farey序列中有可能在Farey序列中相邻的分数，并统计。\r\n令\\(R=100\\)。为了减少枚举量，对于枚举出的两个分数\\(x,y\\)，如果\\(x\\ge\\dfrac{1}{R}\\)，那么没有必要在这个区间上继续寻找答案（此时这里计算出来的\\(\\dfrac{x+y}{2}\\)都大于\\(\\dfrac{1}{R}\\)，不合题意）。\r\n另外，由于直接使用递归会造成栈溢出（分析代码不难知道，最大的递归深度将会达到\\(O(N)\\)级别），因此这里使用非递归的方式遍历Stern-Brocot\r\nTree.\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll N=100000000;const int R=100;struct S&#123;    ll a,c,b,d;&#125;;int main()&#123;    int ans=0;    stack&lt;S&gt;st;    st.push(S&#123;0,1,1,1&#125;);    while(!st.empty())&#123;        S s=st.top();st.pop();        ll a=s.a,b=s.b,c=s.c,d=s.d;        if(c*d*2&gt;N) continue;        // 左边的分数已经大于等于1/R，没必要取下去。        if(a*R&gt;=c) continue;        ll p=a+b,q=c+d;        ll u=a*d+b*c,v=c*d*2;        if(u*R&lt;v) ++ans;        st.push(S&#123;a,c,p,q&#125;);        st.push(S&#123;p,q,b,d&#125;);    &#125;    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 197","url":"/project-euler/197/","content":"\r\nProject Euler 197\r\n题目\r\nInvestigating\r\nthe behaviour of a recursively defined sequence\r\nGiven is the function \\(f(x) = \\lfloor\r\n2^{30.403243784}-x^2\\rfloor \\times 10^{-9}\\) ( \\(\\lfloor \\quad \\rfloor\\) is the\r\nfloor-function), the sequence \\(u_n\\)\r\nis defined by \\(u_0 = -1\\) and \\(u_{n+1} = f(u_n)\\).\r\nFind \\(u_n + u_{n+1}\\) for \\(n = 10^{12}\\).\r\nGive your answer with \\(9\\) digits\r\nafter the decimal point.\r\n解决方案\r\n将序列打印出多项后发现，到了某一个下标（大约\\(600\\)前后）之后，数列的值是两个数反复交替出现。因此枚举量为常数，直接模拟。\r\n代码\r\nN = 10 ** 12M = min(N, 600)def f(x: float):    return int(2 ** (30.403243784 - x * x)) * 1e-9a = [-1]for i in range(M):    a.append(f(a[-1]))ans = a[M] + a[M - 1]print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 195","url":"/project-euler/195/","content":"\r\nProject Euler 195\r\n题目\r\nInscribed\r\ncircles of triangles with one angle of \\(60\\) degrees\r\nLet’s call an integer sided triangle with exactly one angle of \\(60\\) degrees a 60-degree triangle.\r\nLet \\(r\\) be the radius of the\r\ninscribed circle of such a \\(60\\)-degree triangle.\r\nThere are \\(1234\\) \\(60\\)-degree triangles for which \\(r \\le 100\\).\r\nLet \\(T(n)\\) be the number of \\(60\\)-degree triangles for which \\(r \\le n\\), so \\(T(100) = 1234, T(1000) = 22767\\) and \\(T(10000) = 359912\\).\r\nFind \\(T(1053779)\\).\r\n解决方案\r\n令\\(N=1053379\\)。根据余弦定理，假设三角形两边为长度\\(a,b\\)，第三条边的长度\\(c\\)，其对角为\\(60°\\)，那么\\(a,b,c\\)满足：\r\n\\[a^2+b^2-ab=c^2\\]\r\n这篇文章提到了一种构造出一组本原三元组\\((a,b,c)\\)（即\\(\\gcd(a,b,c)=1\\)）满足\\(a^2+b^2-ab=c^2\\)的方法：如果\\(m&gt;n,\\gcd(n,m)=1,3 \\nmid\r\n(m-n)\\),那么有：\r\n\\[a=2mn+n^2,b=2mn+m^2,c=m^2+n^2+mn\\qquad(1)\\]\r\n或者是\r\n\\[a=m^2-n^2,b=2mn+m^2,c=m^2+n^2+mn\\qquad(2)\\]\r\n根据等积法，不难发现内切圆的半径\\(r\\)满足\\(\\dfrac{a+b+c}{2}\\cdot r=\\dfrac{1}{2}ab\\sin\r\n60°\\)。\r\n分别代入式\\((1),(2)\\)，分别得到\r\n\\[r=\\dfrac{\\sqrt{3}mn}{2}\\qquad(3)\\]\r\n\\[r=\\dfrac{(m-n)(2n+m)}{2\\sqrt{3}}\\qquad(4)\\]\r\n因此，根据\\((3)(4)\\)式枚举出所有\\(r\\le\r\nN\\)的本原三元组后，计算对应非本原三元组的数量即可。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1053779;double eps=1e-8;double sq3=sqrt(3);int main() &#123;    int ans = 0;    for (int m = 1; 0.5 * sq3 * m &lt;= N; m++) &#123;        double r;        for (int n = 1; n &lt; m &amp;&amp; (r = 0.5 * sq3 * m * n - eps) &lt;= N; n++) &#123;            if ((m - n) % 3 &amp;&amp; __gcd(m, n) == 1) &#123;                ans += int(1.0 * N / r + eps);            &#125;        &#125;    &#125;    double c = 0.5 / sq3;    for (int n = 1; c * (2 * n + 1) &lt;= N; n++) &#123;        double r;        for (int m = n + 1; (r = c * (m - n) * (2 * n + m)  - eps) &lt;= N; m++) &#123;            if ((m - n) % 3 &amp;&amp; __gcd(m, n) == 1) &#123;                ans += int(1.0 * N / r + eps);            &#125;        &#125;    &#125;    printf(&quot;%d\\n&quot;, ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 199","url":"/project-euler/199/","content":"\r\nProject Euler 199\r\n题目\r\nIterative Circle Packing\r\nThree circles of equal radius are placed inside a larger circle such\r\nthat each pair of circles is tangent to one another and the inner\r\ncircles do not overlap. There are four uncovered “gaps” which are to be\r\nfilled iteratively with more tangent circles.\r\n\r\nAt each iteration, a maximally sized circle is placed in each gap,\r\nwhich creates more gaps for the next iteration. After \\(3\\) iterations (pictured), there are \\(108\\) gaps and the fraction of the area\r\nwhich is not covered by circles is \\(0.06790342\\), rounded to eight decimal\r\nplaces.\r\nWhat fraction of the area is not covered by circles after \\(10\\) iterations?\r\nGive your answer rounded to eight decimal places using the format\r\nx.xxxxxxxx .\r\n笛卡尔定理\r\n曲率\r\n如果一个圆的半径为\\(r\\)，那么其曲率\\(k\\)满足\\(|k|=\\dfrac{1}{r}\\)。对于两个圆而言，如果两个圆外切，那么曲率的正负符号相同；如果为内切，那么符号不同。\r\n笛卡尔定理：假设\\(4\\)个两两相切的圆的曲率分别为\\(k_1,k_2,k_3,k_4\\)，且这四个圆两两相切的切点均不同。那么这四个圆的曲率满足：\r\n\\[(k_1+k_2+k_3+k_4)^2=2(k_1^2+k_2^2+k_3^2+k_4^2)\\]\r\n如果已知三个圆的曲率，那么第四圆的曲率可以写成：\r\n\\[k_4=k_1+k_2+k_3\\pm2\\sqrt{k_1k_2+k_2k_3+k_3k_1}\\]\r\n解决方案\r\n为了避免重复计算，可以先将相同面积的合并计算。\r\n递归遍历所有的小圆，用笛卡尔定理计算它们的面积。\r\n计算第\\(4\\)个圆的曲率时，上面的公式取正号，是因为目前所求的所有圆都是和参数中的正曲率两个圆外切（只有外面那个大圆是负曲率的）。\r\n代码\r\nN = 10def getS(r: float):    return r * rdef dfs(k1: float, k2: float, k3: float, d: int):    k4 = k1 + k2 + k3 + 2 * (k1 * k2 + k2 * k3 + k3 * k1) ** 0.5    ans = getS(1 / k4)    if d == 1:        return ans    return ans + dfs(k1, k2, k4, d - 1) + dfs(k1, k3, k4, d - 1) + dfs(k2, k3, k4, d - 1)inK = inR = 1# 三个小圆内切于大圆，故大圆曲率为负。outK = 3 - 2 * 3 ** 0.5outR = -1 / outKans = getS(inR) * 3 + dfs(inK, inK, outK, N) * 3 + dfs(inK, inK, inK, N)ans = 1 - ans / getS(outR)print(&quot;&#123;:.8f&#125;&quot;.format(ans))\r\n","categories":["Project Euler"]},{"title":"Project Euler 20","url":"/project-euler/20/","content":"\r\nProject Euler 20\r\n题目\r\nFactorial digit sum\r\n\\(n!\\) means \\(n \\times (n − 1) \\times \\dots \\times 3 \\times 2\r\n\\times 1\\).\r\nFor example, \\(10! = 10 \\times 9 \\times\r\n\\dots \\times 3 \\times 2 \\times 1 = 3628800\\), and the sum of the\r\ndigits in the number \\(10!\\) is \\(3 + 6 + 2 + 8 + 8 + 0 + 0 = 27\\).\r\nFind the sum of the digits in the number \\(100!\\).\r\n解决方案\r\n使用sympy库的factorial直接计算阶乘的值，之后将封装在tools自定义工具类中，以fac(n)的方式调用。\r\n利用和第16题类似的方式求出其每个数位的和。\r\n代码\r\nfrom sympy import factorialN = 100ans = sum(list(map(int, str(factorial(N)))))print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 2","url":"/project-euler/2/","content":"\r\nProject Euler 2\r\n题目\r\nEven Fibonacci numbers\r\nEach new term in the Fibonacci sequence is generated by adding the\r\nprevious two terms. By starting with \\(1\\) and \\(2\\), the first \\(10\\) terms will be:\r\n\\[1, 2, 3, 5, 8, 13, 21, 34, 55, 89,\r\n\\dots\\]\r\nBy considering the terms in the Fibonacci sequence whose values do\r\nnot exceed four million, find the sum of the even-valued terms.\r\n解决方案\r\n直接依照递推式\\(F(i)=F(i-1)+F(i-2)\\)进行递推即可，时间复杂度为对数级别。\r\n代码\r\nN = 4 * 10 ** 6a, b = 1, 2ans = 0while True:    if a &gt; N:        break    if a % 2 == 0:        ans += a    c = a + b    a, b = b, cprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 200","url":"/project-euler/200/","content":"\r\nProject Euler 200\r\n题目\r\nFind\r\nthe \\(200\\text{th}\\) prime-proof sqube\r\ncontaining the contiguous sub-string “\\(200\\)”\r\nWe shall define a sqube to be a number of the form, \\(p^2q^3\\), where \\(p\\) and \\(q\\) are distinct primes.\r\nFor example, \\(200 = 5^2\\times 2^3\\)\r\nor \\(120072949 = 23^2\\times 61^3\\). The\r\nfirst five squbes are \\(72, 108, 200,\r\n392\\), and \\(500\\).\r\nInterestingly, \\(200\\) is also the\r\nfirst number for which you cannot change any single digit to make a\r\nprime; we shall call such numbers, prime-proof. The next prime-proof\r\nsqube which contains the contiguous sub-string “\\(200\\)” is \\(1992008\\).\r\nFind the \\(200\\text{th}\\)\r\nprime-proof sqube containing the contiguous sub-string “\\(200\\)”.\r\n解决方案\r\n令\\(Q=200\\)。由于本题所需要的质数上限比较难判定，所以使用的上限为\\(M=200000\\)。\r\n从小到大枚举所有满足形如\\(p^2q^3\\)的数。本题通过之间产生的质数直接从小到大枚举。为保证每次枚举的值最小，使用了优先队列。\r\n枚举时，为了避免枚举到\\(p=q\\)的情况，因此从一开始到整个的枚举过程，都需要保证\\(p&lt; q\\)或者是\\(p&gt;q\\)。此外，为了保证不重不漏，以\\(p&lt; q\\)的情形为例：当\\(p=2\\)时，可以往右枚举\\(q\\)，也可以往下枚举\\(p\\)，但是，一旦\\(p\\)被枚举过，就不能再枚举\\(q\\)了。（枚举示意图如下）因为此时枚举\\(q\\)会导致大量的重复枚举，使程序运行很慢。\r\n\r\n基于\\(p^2q^3\\)变一位是否为质数，这个直接调用库的算法判定。\r\n代码\r\nfrom tools import is_prime, get_primefrom queue import PriorityQueueQ = 200M = 200000def judge(n: int):    s = str(n)    l = len(s)    for i in range(l):        d = int(s[i])        for j in range(10):            if i + j == 0 or d == j:                continue            x = int(s[:i] + str(j) + s[i + 1:])            if is_prime(x):                return False    return Trueq = PriorityQueue()pr = get_prime(M)q.put((pr[0] ** 2 * pr[1] ** 3, 0, 1))q.put((pr[1] ** 2 * pr[0] ** 3, 1, 0))cnt = 0while True:    w, x, y = q.get()    if &quot;200&quot; in str(w) and judge(w):        cnt += 1        if cnt == Q:            ans = w            break    if x + 1 != y and not (x &gt; y and y != 0):        q.put((pr[x + 1] ** 2 * pr[y] ** 3, x + 1, y))    if x != y + 1 and not (x &lt; y and x != 0):        q.put((pr[x] ** 2 * pr[y + 1] ** 3, x, y + 1))print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 201","url":"/project-euler/201/","content":"\r\nProject Euler 201\r\n题目\r\nSubsets with a unique sum\r\nFor any set \\(A\\) of numbers, let\r\n\\(\\text{sum}(A)\\) be the sum of the\r\nelements of \\(A\\).\r\nConsider the set \\(B =\r\n\\{1,3,6,8,10,11\\}\\).\r\nThere are \\(20\\) subsets of \\(B\\) containing three elements, and their\r\nsums are:\r\n\\(\\text{sum}(\\{1,3,6\\}) =\r\n10\\), \\(\\text{sum}(\\{1,3,8\\}) =\r\n12\\), \\(\\text{sum}(\\{1,3,10\\}) =\r\n14\\), \\(\\text{sum}(\\{1,3,11\\}) =\r\n15\\), \\(\\text{sum}(\\{1,6,8\\}) =\r\n15\\), \\(\\text{sum}(\\{1,6,10\\}) =\r\n17\\), \\(\\text{sum}(\\{1,6,11\\}) =\r\n18\\), \\(\\text{sum}(\\{1,8,10\\}) =\r\n19\\), \\(\\text{sum}(\\{1,8,11\\}) =\r\n20\\), \\(\\text{sum}(\\{1,10,11\\}) =\r\n22\\), \\(\\text{sum}(\\{3,6,8\\}) =\r\n17\\), \\(\\text{sum}(\\{3,6,10\\}) =\r\n19\\), \\(\\text{sum}(\\{3,6,11\\}) =\r\n20\\), \\(\\text{sum}(\\{3,8,10\\}) =\r\n21\\), \\(\\text{sum}(\\{3,8,11\\}) =\r\n22\\), \\(\\text{sum}(\\{3,10,11\\}) =\r\n24\\), \\(\\text{sum}(\\{6,8,10\\}) =\r\n24\\), \\(\\text{sum}(\\{6,8,11\\}) =\r\n25\\), \\(\\text{sum}(\\{6,10,11\\}) =\r\n27\\), \\(\\text{sum}(\\{8,10,11\\}) =\r\n29\\).\r\nSome of these sums occur more than once, others are unique.\r\nFor a set \\(A\\), let \\(U(A,k)\\) be the set of unique sums of \\(k\\)-element subsets of \\(A\\), in our example we find \\(U(B,3) = \\{10,12,14,18,21,25,27,29\\}\\) and\r\n\\(\\text{sum}(U(B,3)) = 156\\).\r\nNow consider the \\(100\\)-element set\r\n\\(S = \\{1^2, 2^2, \\dots ,\r\n100^2\\}\\).\r\n\\(S\\) has \\(100891344545564193334812497256\\) \\(50\\)-element subsets.\r\nDetermine the sum of all integers which are the sum of exactly one of\r\nthe \\(50\\)-element subsets of \\(S\\), i.e. find \\(\\text{sum}(U(S,50))\\).\r\n解决方案\r\n使用动态规划的思想解决集合的计数问题。\r\n令\\(M=100,N=50,S\\)为\\(M^2\\)以内的最大的\\(N\\)个平方数之和。\r\n那么，设状态\\(f(i,j,k)(0\\le i\\le M,0\\le\r\nj\\le \\min(i,M),0\\le k\\le S)\\)表示集合\\(\\{1^2,2^2,\\dots,i^2\\}\\)中，有多少个子集满足以下两个条件：\r\n\r\n子集的大小为\\(j\\)\r\n子集的元素和为\\(k\\)\r\n\r\n其中，空集\\(\\emptyset\\)没有使用任何元素，因此大小为\\(0\\)，元素和为\\(0\\)，作为初始状态出现。\r\n可以列出关于\\(f(i,j,k)\\)的状态转移方程：\r\n\\[\r\nf(i,j,k)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i=0\\land j=0\\land k=0 \\\\\r\n  &amp;0  &amp; &amp; \\text{else if}\\quad i=0 \\\\\r\n  &amp;f(i-1,j,k) &amp; &amp; \\text{else if}\\quad j&lt;i^2 \\\\\r\n  &amp;f(i-1,j,k)+f(i-1,j-1,k-i^2) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n对于方程最后一行，新数\\(i^2\\)要么被使用了，就\\(f(i-1,j-1,k-i^2)\\)中的所有集合都添加一个\\(i^2\\)；要么没有被使用，直接将旧状态\\(f(i-1,j,k)\\)记录。\r\n因此，最终答案为\\(\\sum_{k=1}^S\r\nk\\cdot[f(M,N,k)=1]\\)。其中，\\([]\\)表示示性函数，表示\\([]\\)里面的值是否为真，如果为真，那么值为\\(1\\)，否则值为\\(0\\).\r\n由于本题只关心\\(f\\)的值是否为\\(0,1\\)，或者是超过\\(2\\)，因此为\\(f\\)定义一个新运算\\(\\circ\\)：\\(\\{0,1,2\\}^2\\rightarrow\\{0,1,2\\}\\)，其中\\(a\\circ b=\\min(a+b,2)\\)。因此不需要计算\\(f\\)的真实值，避免了溢出问题。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int M=100,N=50;const int S=M*(M+1)*(2*M+1)/6-N*(N+1)*(2*N+1)/6;int f[N+1][S+1];int add[3][3];int main() &#123;    f[0][0] = 1;    for (int i = 0; i &lt; 3; i++)        for (int j = 0; j &lt; 3; j++)            add[i][j] = min(2, i + j);    for (int i = 1, sum = 0; i &lt;= M; i++) &#123;        int v = i * i;        sum += v;        for (int j = min(N, i); j &gt;= 1; j--)            for (int k = min(S, sum); k &gt;= v; k--)                f[j][k] = add[f[j][k]][f[j - 1][k - v]];    &#125;    ll ans = 0;    for (int i = 1; i &lt;= S; i++)        if (f[N][i] == 1) ans += i;    printf(&quot;%lld\\n&quot;, ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 202","url":"/project-euler/202/","content":"\r\nProject Euler 202\r\n题目\r\nLaserbeam\r\nThree mirrors are arranged in the shape of an equilateral triangle,\r\nwith their reflective surfaces pointing inwards. There is an\r\ninfinitesimal gap at each vertex of the triangle through which a laser\r\nbeam may pass.\r\nLabel the vertices \\(A, B\\) and\r\n\\(C\\). There are \\(2\\) ways in which a laser beam may enter\r\nvertex \\(C\\), bounce off \\(11\\) surfaces, then exit through the same\r\nvertex: one way is shown below; the other is the reverse of that.\r\n\r\nThere are \\(80840\\) ways in which a\r\nlaser beam may enter vertex \\(C\\),\r\nbounce off \\(1000001\\) surfaces, then\r\nexit through the same vertex.\r\nIn how many ways can a laser beam enter at vertex \\(C\\), bounce off \\(12017639147\\) surfaces, then exit through\r\nthe same vertex?\r\n莫比乌斯反演\r\n莫比乌斯反演：假设有两个算术函数\\(f,g\\)，其中\\(f\\)可以写成\\(g\\)的以下关系式：\r\n\\[g(n)=\\sum_{d\\mid n}f(d)\\]\r\n那么有\r\n\\[f(n)=\\sum_{d\\mid\r\nn}\\mu\\left(\\dfrac{n}{d}\\right)g(d)\\]\r\n其中\\(\\mu\\)是莫比乌斯函数。\r\n注意算术函数\\(f\\)可以看成是\\(g\\)和\\(\\mu\\)的狄利克雷卷积，可以记作\\(f=\\mu*g\\).\r\n解决方案\r\n令\\(N=12017639147\\)。处理光线反射问题，最常使用的方法是将整个图形按照镜面对称地拓展开来。这时，处理反射的问题就变成了处理直线的问题。\r\n我们对这个等边三角形进行拓展，得到下图：\r\n\r\n其中，蓝色点就是通过镜面拓展出来后的\\(C\\)点。\r\n由于这是一个三角形阵列，不容易对每个点进行坐标编排，因此以原图中的点\\(C\\)为原点，将整个三角形阵列转化为平面直角坐标系上的点，如下图：\r\n\r\n那么很容易地观察出，拓展出来的\\(C(x,y)\\)满足关系：\\(y\\equiv x\\pmod 3\\)。\r\n如果光线不会提前射出，那么说明这个光线在经过拓展出来的点之前，是不会经过其它格点的。也就是说，\\(\\gcd(x,y)=1\\)。\r\n另一个观察：如果光线射到一个格点\\((x,y)\\)，那么它实际上被镜子反射\\((x-1)+(y-1)+(x+y-1)=2x+2y-3\\)次。因为他经过了\\(y-1\\)条水平的线（镜子），\\(x-1\\)条垂直的线，以及\\(x+y-1\\)条形如\\(x+y=k\\)的直线。\r\n也就是说，如果一个点\\((x,y)\\)满足\\(x+y=n,\\gcd(x,y)=1\\)，那么光线射到这个点时已经反射了\\(2n-3\\)次，注意到\\(2n-3\\)一定是一个奇数。\r\n那么很明显，当\\(N\\)为偶数时，答案为\\(0\\)。当\\(M=\\dfrac{N+3}{2}\\)为\\(3\\)的倍数时，答案也为\\(0\\)，因为\\(x+y=3k\\)上的所有\\(C\\)点的横纵坐标的最小公因数为\\(3\\)，不合题意。\r\n在上面的图中，当\\(n\\)不为\\(3\\)的倍数时，很容易数出直线\\(x+y=n\\)上有\\(F(n)=\\dfrac{n-G(n)}{3}\\)个点是\\(C\\)点，其中\\(G(n)\\in\\{-1,1\\},G(n)\\equiv n \\pmod\r\n3\\)。\r\n假设\\(f(n)\\)是在直线\\(x+y=n\\)上那些能被原点“看见”（也就是\\(\\gcd(x,y)=1\\)）的\\(C\\)点个数，那么\\(x+y=n\\)上被挡住的那些\\(C(x,y)\\)点将会被点\\(C&#39;(\\dfrac{x}{d},\\dfrac{y}{d})\\)挡住，其中\\(d=\\gcd(x,y)\\)。注意到\\(C&#39;\\)落在直线\\(x+y=\\dfrac{n}{d}\\)上，并且\\(\\dfrac{n}{d}\\)是\\(n\\)的一个因子。那么可以写出下面关于两个函数\\(F\\)和\\(f\\)的式子：\r\n\\[F(n)=\\sum_{d\\mid n}f(d)\\]\r\n根据莫比乌斯反演，\\(f\\)可以写成如下形式：\r\n\\[\\begin{aligned}\r\nf(n)&amp;=\\sum_{d\\mid n}\\mu\\left(\\dfrac{n}{d}\\right)\\cdot F(d)\\\\\r\n&amp;=\\dfrac{1}{3}\\left(\\sum_{d\\mid n}\\mu\\left(\\dfrac{n}{d}\\right)\\cdot\r\nd-\\sum_{d\\mid n}\\mu\\left(\\dfrac{n}{d}\\right)\\cdot G(d)\\right)\\\\\r\n\\end{aligned}\\]\r\n对于式子的第一项，在狄利克雷卷积的页面中，发现\\(\\varphi=\\mu*\\text{Id}\\)，其中\\(\\text{Id}(n)=n\\)，\\(\\varphi\\)为欧拉函数。\r\n令式子的第二项\\(g(n)=\\sum_{d\\mid\r\nn}\\mu\\left(\\dfrac{n}{d}\\right)\\cdot G(d)=\\sum_{d\\mid\r\nn}\\mu\\left(\\dfrac{n}{d}\\right)\\cdot G(n)\\cdot\r\nG\\left(\\dfrac{n}{d}\\right)=G(n)\\sum_{d\\mid n}\\mu(d)\\cdot\r\nG(d)\\).\r\n考虑上面求和式\\(g(n)\\)的值，但是这里只考虑因数\\(d\\)满足\\(\\mu(d)\\neq 0\\)的情况，注意此时\\(d\\)是一个无平方因子数。\r\n\r\n当\\(n\\)包含模\\(3\\)余\\(1\\)的质因子\\(p\\)时，那么\\(g(n)=0\\)。假设\\(p\\nmid d\\)，那么发现\\(\\mu(d)=-\\mu(pd)\\)，但是\\(G(d)=G(pd)\\)，那么有\\(\\mu(d)\\cdot G(d)+\\mu(pd)\\cdot\r\nG(pd)=0\\)。最终将这样的一对对\\(p,d\\)值的式子相加，即可得到\\(g(n)=0\\)。\r\n当\\(n\\)不包含模\\(3\\)余\\(1\\)的质因子时，那么\\(g(n)=G(n)\\cdot 2^r\\)，其中\\(r\\)是\\(n\\)的不同质因子个数。因为\\(\\mu(d)\\)必定和\\(G(d)\\)是同号的，即\\(\\mu(d)\\cdot G(d)=1\\)。\\(r\\)个不同的质因子意味着\\(n\\)有\\(2^r\\)个无平方因子，故得上式。\r\n\r\n因此，本题先计算出\\(M\\)，然后计算出\\(f(M)=\\dfrac{1}{3}(\\varphi(M)-g(M))\\)即可。\r\n代码\r\nfrom tools import phi, factorizationN = 12017639147def cal(n):    if n % 2 == 0:        return 0    m = (n + 3) // 2    if m % 3 == 0:        return 0    ls = factorization(m)    s = phi(m)    if 1 not in [a[0] % 3 for a in ls]:        g = -1 if m % 3 == 2 else 1        s -= g * 2 ** len(ls)    return s // 3ans = cal(N)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 204","url":"/project-euler/204/","content":"\r\nProject Euler 204\r\n题目\r\nGeneralised Hamming Numbers\r\nA Hamming number is a positive number which has no prime factor\r\nlarger than 5.\r\nSo the first few Hamming numbers are \\(1,\r\n2, 3, 4, 5, 6, 8, 9, 10, 12, 15\\).\r\nThere are \\(1105\\) Hamming numbers\r\nnot exceeding \\(10^8\\).\r\nWe will call a positive number a generalised Hamming number of type\r\n\\(n\\), if it has no prime factor larger\r\nthan \\(n\\).\r\nHence the Hamming numbers are the generalised Hamming numbers of type\r\n\\(5\\).\r\nHow many generalised Hamming numbers of type \\(100\\) are there which don’t exceed \\(10^9\\)?\r\n解决方案\r\n令\\(N=100,M=10^9\\)，\\(N\\)以内的质数存放在数组\\(pr\\)中，一共有\\(m\\)个。\r\n基本思想是：先产生有小质因子的合数，再利用这些小质因子的质数产生含有大质因子的合数。\r\n假设数组\\(g[i]\\)存放由第\\(1\\sim\r\ni\\)个质因数构成的广义汉明数，那么尝试将\\(g[i]\\)中的所有数都乘以\\(pr[i+1]^0,pr[i+1]^1,pr[i+1]^2,\\dots\\)，将产生的这些数存放到数组\\(g[i+1]\\)中。\r\n枚举发现，数组\\(g[m]\\)中的广义汉明数不多。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 100;const ll M = 1e9;vector&lt;int&gt;a,pr;bool vis[N+4];int main() &#123;    for (int i = 2; i &lt;= N; i++) &#123;        if (vis[i]) continue;        pr.push_back(i);        for (int j = i * i; j &lt;= N; j += i)            vis[j] = true;    &#125;    a.push_back(1);    for (int p: pr) &#123;        int m = a.size();        for (int i = 0; i &lt; m; i++) &#123;            for (ll x = 1ll * a[i] * p; x &lt;= M; x *= p)                a.push_back(x);        &#125;    &#125;    int ans = a.size();    printf(&quot;%d\\n&quot;, ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 196","url":"/project-euler/196/","content":"\r\nProject Euler 196\r\n题目\r\nPrime triplets\r\nBuild a triangle from all positive integers in the following way:\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\\(1\\)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\\(\\color{red}{2}\\)\r\n\\(\\color{red}{3}\\)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\\(4\\)\r\n\\(\\color{red}{5}\\)\r\n\\(6\\)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\\(\\color{red}{7}\\)\r\n\\(8\\)\r\n\\(9\\)\r\n\\(10\\)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\\(\\color{red}{11}\\)\r\n\\(12\\)\r\n\\(\\color{red}{13}\\)\r\n\\(14\\)\r\n\\(15\\)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\\(16\\)\r\n\\(\\color{red}{17}\\)\r\n\\(18\\)\r\n\\(\\color{red}{19}\\)\r\n\\(20\\)\r\n\\(21\\)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\\(22\\)\r\n\\(\\color{red}{23}\\)\r\n\\(24\\)\r\n\\(25\\)\r\n\\(26\\)\r\n\\(27\\)\r\n\\(28\\)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\\(\\color{red}{29}\\)\r\n\\(30\\)\r\n\\(\\color{red}{31}\\)\r\n\\(32\\)\r\n\\(33\\)\r\n\\(34\\)\r\n\\(35\\)\r\n\\(36\\)\r\n\r\n\r\n\r\n\r\n\r\n\\(\\color{red}{37}\\)\r\n\\(38\\)\r\n\\(39\\)\r\n\\(40\\)\r\n\\(\\color{red}{41}\\)\r\n\\(42\\)\r\n\\(\\color{red}{43}\\)\r\n\\(44\\)\r\n\\(45\\)\r\n\r\n\r\n\r\n\r\n\\(46\\)\r\n\\(\\color{red}{47}\\)\r\n\\(48\\)\r\n\\(49\\)\r\n\\(50\\)\r\n\\(51\\)\r\n\\(52\\)\r\n\\(\\color{red}{53}\\)\r\n\\(54\\)\r\n\\(55\\)\r\n\r\n\r\n\r\n\\(56\\)\r\n\\(57\\)\r\n\\(58\\)\r\n\\(\\color{red}{59}\\)\r\n\\(60\\)\r\n\\(\\color{red}{61}\\)\r\n\\(62\\)\r\n\\(63\\)\r\n\\(64\\)\r\n\\(65\\)\r\n\\(66\\)\r\n\r\n\r\n\\(\\dots\\)\r\n\\(\\dots\\)\r\n\\(\\dots\\)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nEach positive integer has up to eight neighbours in the triangle.\r\nA set of three primes is called a prime triplet if one of\r\nthe three primes has the other two as neighbours in the triangle.\r\nFor example, in the second row, the prime numbers \\(2\\) and \\(3\\) are elements of some prime triplet.\r\nIf row \\(8\\) is considered, it\r\ncontains two primes which are elements of some prime triplet, i.e. \\(29\\) and \\(31\\).\r\nIf row \\(9\\) is considered, it\r\ncontains only one prime which is an element of some prime triplet: \\(37\\).\r\nDefine \\(S(n)\\) as the sum of the\r\nprimes in row \\(n\\) which are elements\r\nof any prime triplet. Then \\(S(8)=60\\)\r\nand \\(S(9)=37\\).\r\nYou are given that \\(S(10000)=950007619\\).\r\nFind \\(S(5678027) +\r\nS(7208785)\\).\r\n解决方案\r\n如果要求第\\(S(N)\\)，为确保第\\(N\\)行的在质数三元组的数都能够被找到，第\\(N-2\\)行到第\\(N+2\\)的所有质数都需要每局出来。假设第\\(N-2\\)行的第一个质数为\\(L\\)，第\\(N+2\\)行的最后一个质数为\\(R\\)。\r\n第一个问题：找到\\(L,R\\)之间的所有质数。\r\n不难发现，虽然\\(L,R\\)是\\(O(n^2)\\)级别的，但是\\(R-L\\)却是\\(O(n)\\)级别的。另外，\\(L,R\\)之间的合数一定被\\(\\lfloor\\sqrt{R}\\rfloor\\)以内的质因数解决。这启发了我们用两次质数筛法解决：\r\n\r\n先用一般的埃氏筛法找到\\(\\lfloor\\sqrt{R}\\rfloor\\)以内的质数。\r\n将第一步筛出来的质数用于筛掉\\(L,R\\)之间的合数。这里的实现需要注意一些细节，如数组的偏移量是\\(L\\)；如果是用质数\\(p\\)来筛合数，那么要从\\(\\left\\lceil\\dfrac{L}{p}\\right\\rceil\\cdot\r\np\\)开始筛起。\r\n\r\n第二个问题：求解原问题答案。\r\n对于第\\(N\\)行的每一个数质数\\(n\\)而言，以它为中心的\\(5\\times5\\)方格内的数都是它的判断对象，如下图（绿色为内圈，蓝色为外圈）：\r\n\r\n\\(n\\)为答案的条件满足这两个之一：内圈中有两个是质数；内圈和外圈中一对有公共边或角（如上图深色部分）的数都是质数。\r\n因此为了解决第二个问题，可以先将这一对有公共边和角的数的相对坐标全都预处理出来，直接判断。\r\n本问题还有一些细节，实现时需要注意。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;# define pi pair&lt;int,int&gt;using namespace std;typedef long long ll;const int Q1=5678027,Q2=7208785;bool b[Q2*5+2];ll pr[Q2 + 104];int p=0;//对应8个方向中再向外走一步的格子的方向。不难发现，如果当前是质数，那么左边和右边一定是偶数，这可以排除左右两个方向。vector&lt;pi&gt;dr[3][3];int dx[8]=&#123;-1,-1,-1,0,0,1,1,1&#125;,dy[8]=&#123;-1,0,1,-1,1,-1,0,1&#125;;ll st(ll n)&#123;    return n*(n-1)/2+1;&#125;//判断第n+d行第y列的数是否为质数。bool is_prime(int n, int d, int y)&#123;    if(y&lt;0||y&gt;=n+d) return false;    else&#123;        n-=2;d+=2;        return !b[y+(n+n+d-1)*d/2];    &#125;&#125;//判断第n第y个质数是不是所求答案。bool is_answer(int n,int y)&#123;    if(!is_prime(n, 0, y)) return false;    int cnt=0;    for(int k=0;k&lt;8;k++)&#123;        if(dx[k]==0) continue;        if(is_prime(n, dx[k], y + dy[k]))&#123;            if(++cnt&gt;=2) return true;            for(auto &amp;[ox,oy]:dr[dx[k]+1][dy[k]+1])&#123;                if(is_prime(n, ox, y + oy)) return true;            &#125;        &#125;    &#125;    return false;&#125;ll solve(int row)&#123;    ll l=st(row-2),r=st(row+3)-1;    ll sq=sqrt(r);    p=0;    memset(b,0,sizeof(b));    for(int i=2;i&lt;=sq;i++)&#123;        if(b[i]) continue;        pr[++p]=i;        for(int j=i;1ll*i*j&lt;=sq;j++)            b[i*j]=true;    &#125;    memset(b,0,sizeof(b));    for(int i=1; i &lt;= p; i++)        for(ll j= (l + pr[i] - 1) / pr[i]; j * pr[i] &lt;= r; j++)            b[j * pr[i] - l]=true;    ll ans=0,nl=st(row);    for(int y=0;y&lt;row;y++)        if(is_answer(row,y)) ans+=nl+y;    return ans;&#125;int main()&#123;    for(int i=-1;i&lt;=1;i++)&#123;        for(int j=-1;j&lt;=1;j++)&#123;            if(i==0) continue;            for(int k=0;k&lt;8;k++)&#123;                int x=i+dx[k],y=j+dy[k];                if(max(abs(x),abs(y))==2)&#123;                    dr[i+1][j+1].push_back(pi(x,y));                &#125;            &#125;        &#125;    &#125;    ll ans = solve(Q1) + solve(Q2);    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 203","url":"/project-euler/203/","content":"\r\nProject Euler 203\r\n题目\r\nSquarefree Binomial\r\nCoefficients\r\nThe binomial coefficients \\(\\displaystyle\r\n\\binom n k\\) can be arranged in triangular form, Pascal’s\r\ntriangle, like this:\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n1\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n1\r\n\r\n1\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n1\r\n\r\n2\r\n\r\n1\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n1\r\n\r\n3\r\n\r\n3\r\n\r\n1\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n1\r\n\r\n4\r\n\r\n6\r\n\r\n4\r\n\r\n1\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n1\r\n\r\n5\r\n\r\n10\r\n\r\n10\r\n\r\n5\r\n\r\n1\r\n\r\n\r\n\r\n\r\n\r\n1\r\n\r\n6\r\n\r\n15\r\n\r\n20\r\n\r\n15\r\n\r\n6\r\n\r\n1\r\n\r\n\r\n\r\n1\r\n\r\n7\r\n\r\n21\r\n\r\n35\r\n\r\n35\r\n\r\n21\r\n\r\n7\r\n\r\n1\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n…\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nIt can be seen that the first eight rows of Pascal’s triangle contain\r\ntwelve distinct numbers: \\(1, 2, 3, 4, 5, 6, 7, 10, 15, 20, 21\\) and \\(35\\).\r\nA positive integer \\(n\\) is called\r\nsquarefree if no square of a prime divides \\(n\\).\r\nOf the twelve distinct numbers in the first eight rows of Pascal’s\r\ntriangle, all except \\(4\\) and \\(20\\) are squarefree.\r\nThe sum of the distinct squarefree numbers in the first eight rows is\r\n\\(105\\).\r\nFind the sum of the distinct squarefree numbers in the first \\(51\\) rows of Pascal’s triangle.\r\n解决方案\r\n由于需要遍历的行数比较少，因此枚举出杨辉三角前\\(51\\)行的所有数，并直接通过因式分解判断其是否为无平方数即可。\r\n代码\r\nfrom tools import get_pascals_triangle, factorizationN = 51ans = 1for x in set().union(*[ls for ls in get_pascals_triangle(N-1)]) - &#123;1&#125;:    if max(f[1] for f in factorization(x)) == 1:        ans += xprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 205","url":"/project-euler/205/","content":"\r\nProject Euler 205\r\n题目\r\nDice Game\r\nPeter has nine four-sided (pyramidal) dice, each with faces numbered\r\n\\(1, 2, 3, 4\\). Colin has six six-sided\r\n(cubic) dice, each with faces numbered \\(1, 2,\r\n3, 4, 5, 6\\).\r\nPeter and Colin roll their dice and compare totals: the highest total\r\nwins. The result is a draw if the totals are equal.\r\nWhat is the probability that Pyramidal Pete beats Cubic Colin? Give\r\nyour answer rounded to seven decimal places in the form 0.abcdefg\r\n解决方案\r\n为了求出Peter击败Colin的概率是多少，需要知道各自投出的点数和的分布律。\r\n假设某一人有\\(c\\)个骰子，这个骰子有\\(n\\)面，考虑使用动态规划的思想用来计算这个分布和：令\\(f_{c,n}(i,j)(0\\le i\\le c,0\\le j\\le\r\ncn)\\)表示使用了\\(i\\)个骰子时，投掷出和为\\(j\\)概率，那么不难列出如下状态转移方程：\r\n\\[\r\nf_{c,n}(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i=0\\land j=0 \\\\\r\n  &amp;0 &amp; &amp; \\text{else if}\\quad i=0\\lor j=0 \\\\\r\n  &amp;\\sum_{k=1}^{\\min(j,n)}\\dfrac{f_{c,n}(i-1,j-k)}{n} &amp; &amp;\r\n\\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n对于方程的第三行，状态\\(f_{c,n}(i-1,j-k)\\)都有\\(\\dfrac{1}{n}\\)的概率转移到当前状态。\r\n最终，所求的分布律为\\(f_{c,n}(c,\\cdot)\\)。\r\n假设Peter的分布律是\\(f(\\cdot)=f_{c_P,n_P}(c_P,\\cdot)\\)，Colin的分布律为\\(g(\\cdot)=f_{c_C,n_C}(c_C,\\cdot)\\)。那么，Peter击败Colin的概率为：\r\n\\[\\sum_{i=1}^{c_P\\cdot\r\nn_P}\\sum_{j=0}^{\\min(i-1,c_C\\cdot n_C)}f(i)\\cdot g(j)\\]\r\n代码\r\nCP, NP = 9, 4CC, NC = 6, 6def get_distribution(c: int, n: int):    f = [[0 for _ in range(c * n + 1)] for _ in range(c + 1)]    f[0][0] = 1    for i in range(1, c + 1):        for j in range(c * n + 1):            for k in range(1, min(j, n) + 1):                f[i][j] += f[i - 1][j - k] / n    return f[c]distribute_p = get_distribution(CP, NP)distribute_c = get_distribution(CC, NC)ans = s = 0for i in range(1, len(distribute_p)):    ans += distribute_p[i] * sum(distribute_c[:i])print(&quot;&#123;:.7f&#125;&quot;.format(ans))\r\n","categories":["Project Euler"],"tags":["动态规划","概率"]},{"title":"Project Euler 206","url":"/project-euler/206/","content":"\r\nProject Euler 206\r\n题目\r\nConcealed Square\r\nFind the unique positive integer whose square has the form\r\n1_2_3_4_5_6_7_8_9_0, where each “_” is a single digit.\r\n解决方案\r\n假设当前枚举的数位\\(n\\)。本题使用了如下剪枝方法：\r\n\r\n如果\\(n^2\\)最后一位是\\(0\\)，那么倒数第二位肯定也是\\(0\\)，故不考虑\\(n\\)的最低位\\(0\\)，直接舍去，在输出答案的时候恢复。\r\n需要枚举的\\(n\\)在\\(10^8\\)在\\(\\sqrt{2}\\times10^8\\)之间。因为\\(n^2\\)最高位为\\(1\\)，因此\\(10^{16}&lt; n^2&lt;2\\times 10^{16}\\)。\r\n因此，\\(n\\)是一个\\(9\\)位数，最高位为\\(1\\)。使用meet-in-the-middle的思想进行枚举。一部分是枚举\\(n\\)的中间\\(3\\)位，最多\\(415\\)种情况，注意到这中间\\(3\\)位明显不能够对\\(n^2\\)的低\\(5\\)位产生影响；另一部分是枚举\\(n\\)的低\\(5\\)位，由于中间\\(3\\)位的平方数值不会不能影响\\(n^2\\)低\\(5\\)位的值，因此枚举的过程中，只保留平方数个位为\\(9\\)，百位为\\(8\\)，万位为\\(7\\)的情况。这低\\(5\\)位中的\\(100000\\)种只有\\(240\\)种情况是符合的。\r\n\r\n排除了低\\(5\\)位的绝大多数情况后，最终枚举量其实很小。\r\n代码\r\nls = []for i in range(100000):    x = i * i % 100000    if x % 10 == 9 and x // 100 % 10 == 8 and x // 10000 % 10 == 7:        ls.append(i)for l in range(415):    for r in ls:        x = 100000000 + l * 100000 + r        if str(x * x)[::2] == &quot;123456789&quot;:            ans = x * 10print(ans)\r\n","categories":["Project Euler"],"tags":["meet-in-the-middle"]},{"title":"Project Euler 207","url":"/project-euler/207/","content":"\r\nProject Euler 207\r\n题目\r\nInteger partition equations\r\nFor some positive integers \\(k\\),\r\nthere exists an integer partition of the form   \\(4^t = 2^t + k\\), where \\(4^t, 2^t\\) and \\(k\\) are all positive integers and \\(t\\) is a real number.\r\nThe first two such partitions are \\(4^1 =\r\n2^1 + 2\\) and \\(4^{1.5849625\\dots} =\r\n2^{1.5849625\\dots} + 6\\).\r\nPartitions where \\(t\\) is also an\r\ninteger are called perfect.\r\nFor any \\(m \\ge 1\\) let \\(P(m)\\) be the proportion of such partitions\r\nthat are perfect with \\(k \\le m\\).\r\nThus \\(P(6) = 1/2\\).\r\nIn the following table are listed some values of \\(P(m)\\)\r\n\\(\\begin{aligned}\r\n   P(5) &amp;= &amp;1/1 \\\\\r\n   P(10)&amp; = &amp;1/2 \\\\\r\n   P(15) &amp;= &amp;2/3 \\\\\r\n   P(20) &amp;= &amp;1/2 \\\\\r\n   P(25) &amp;= &amp;1/2 \\\\\r\n   P(30) &amp;= &amp;2/5 \\\\\r\n   &amp;\\dots&amp;\\\\\r\n   P(180) &amp;=&amp; 1/4\\\\\r\n   P(185) &amp;=&amp; 3/13\r\n\\end{aligned}\\)\r\nFind the smallest \\(m\\) for which\r\n\\(P(m) &lt; 1/12345\\)\r\n解决方案\r\n令\\(x=2^t(x&gt;0)\\)，那么上面的方程就可以化成\\(x^2-x=k\\)。\r\n那么，当\\(x\\)为某一个正整数时，\\(x^2=x+k\\)就是一个划分，那么\\(k\\)就必须满足\\(k=x^2-x,x=1,2,\\dots\\)。\r\n回到题目中，如果\\(t\\)是一个整数，那么\\(x=2^t\\)就必须是一个二次幂。\r\n这启发我们先从小到大遍历\\(x\\)值，然后再判断\\(x\\)值是否为一个二次方数，计算出完美划分比率，直接进行判断。\r\n其中，使用如下代码判断一个有符号数\\(x\\)是否为一个二次方数：\r\n(x &amp; (x - 1)) == 0\r\n最终，答案是一个形如\\(x^2-x\\)的整数。\r\n代码\r\nfrom itertools import countQ = 12345cnt = 0for x in count(2, 1):    if (x &amp; (x - 1)) == 0:        cnt += 1    if cnt * Q &lt; x - 1:        ans = x * (x - 1)        breakprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 209","url":"/project-euler/209/","content":"\r\nProject Euler 209\r\n题目\r\nCircular Logic\r\nA \\(k\\)-input binary truth\r\ntable is a map from \\(k\\) input\r\nbits(binary digits, \\(0\\) [false] or\r\n\\(1\\) [true]) to \\(1\\) output bit. For example, the \\(2\\)-input binary truth tables for the\r\nlogical \\(\\text{AND}\\) and \\(\\text{XOR}\\) functions are:\r\n\r\n\r\n\r\n\\(x\\)\r\n\\(y\\)\r\n\\(x \\text{ AND } y\\)\r\n\r\n\\(x\\)\r\n\\(y\\)\r\n\\(x \\text{ XOR }  y\\)\r\n\r\n\r\n\r\n\r\n\\(0\\)\r\n\\(0\\)\r\n\\(0\\)\r\n\r\n\\(0\\)\r\n\\(0\\)\r\n\\(0\\)\r\n\r\n\r\n\\(0\\)\r\n\\(1\\)\r\n\\(0\\)\r\n\r\n\\(0\\)\r\n\\(1\\)\r\n\\(1\\)\r\n\r\n\r\n\\(1\\)\r\n\\(0\\)\r\n\\(0\\)\r\n\r\n\\(1\\)\r\n\\(0\\)\r\n\\(1\\)\r\n\r\n\r\n\\(1\\)\r\n\\(1\\)\r\n\\(1\\)\r\n\r\n\\(1\\)\r\n\\(1\\)\r\n\\(0\\)\r\n\r\n\r\n\r\nHow many \\(6\\)-input binary truth\r\ntables, \\(\\tau\\), satisfy the\r\nformula\r\n\\[\\tau(a, b, c, d, e, f) \\text{ AND } τ(b,\r\nc, d, e, f, a \\text{ XOR } (b \\text{ AND } c)) = 0 \\]\r\nfor all \\(6\\)-bit inputs \\((a, b, c, d, e, f)\\)?\r\n解决方案\r\n设一个\\(6\\)位二进制数\\(b=b_5b_4b_3b_2b_1b_0\\)表示\\(\\tau\\)函数的\\(6\\)个输入位\\(\\tau(b_0,b_1,b_2,b_3,b_4,b_5)\\)。\r\n根据题目中的定义，对于\\(\\forall b\\in\r\n\\{0,1\\}^6\\)，上面的式子中的两个\\(\\tau\\)必须有一个为\\(0\\)。\r\n我们枚举了\\(64\\)个不同的输入，根据上面的公式，发现它们组成了一个个环，这些环一共有\\(6\\)个，分别如下（以下分别表示\\(b\\)的值）：\r\n\\(\\begin{aligned}\r\n&amp; 0\\leftrightarrow0\\\\\r\n&amp;1\\leftrightarrow32\\leftrightarrow16\\leftrightarrow8\\leftrightarrow4\\leftrightarrow2\\leftrightarrow1\\\\\r\n&amp;3\\leftrightarrow33\\leftrightarrow48\\leftrightarrow24\\leftrightarrow12\\leftrightarrow6\\leftrightarrow35\\leftrightarrow49\\leftrightarrow56\\leftrightarrow28\\leftrightarrow14\\leftrightarrow39\\leftrightarrow19\\leftrightarrow41\\leftrightarrow52\\leftrightarrow26\\\\&amp;\r\n\\leftrightarrow13\\leftrightarrow38\\leftrightarrow51\\leftrightarrow57\\leftrightarrow60\\leftrightarrow30\\leftrightarrow47\\leftrightarrow23\\leftrightarrow11\\leftrightarrow37\\leftrightarrow50\\leftrightarrow25\\leftrightarrow44\\leftrightarrow22\\leftrightarrow43\\\\&amp;\r\n\\leftrightarrow53\\leftrightarrow58\\leftrightarrow29\\leftrightarrow46\\leftrightarrow55\\leftrightarrow27\\leftrightarrow45\\leftrightarrow54\\leftrightarrow59\\leftrightarrow61\\leftrightarrow62\\leftrightarrow63\\leftrightarrow31\\leftrightarrow15\\leftrightarrow7\\leftrightarrow3\\\\\r\n&amp;5\\leftrightarrow34\\leftrightarrow17\\leftrightarrow40\\leftrightarrow20\\leftrightarrow10\\leftrightarrow5\\\\\r\n&amp; 9\\leftrightarrow36\\leftrightarrow18\\leftrightarrow9\\\\\r\n&amp; 21\\leftrightarrow42\\leftrightarrow21\r\n\\end{aligned}\\)\r\n这些环中的相邻两个输入在\\(\\tau\\)的真值表其中必须其中一个是\\(0\\)。并且，不同环之间是相互独立的，因此将每个环的填法数相乘就是最终答案。这引出第二个问题：\r\n给定一个长度为\\(n\\)的环形数组，数组的值只能填\\(0\\)或\\(1\\)。有多少种填法，使得环形数组不能存在相邻两个值为\\(1\\)？\r\n这个问题可以使用动态规划方便地解决，假设所求的值为\\(f(n)\\)，那么可以写出如下状态转移方程：\r\n\\[\r\nf(i)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i=1 \\\\\r\n  &amp;3 &amp; &amp; \\text{else if}\\quad i=2 \\\\\r\n  &amp;f(i-1)+f(i-2) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n由于是一个环形数组，因此考虑在第\\(1\\)位和最后一位之间插入新的值。对于\\(f(n-1)\\)的情形，只需要插入一个\\(0\\)即可。对于\\(f(n-2)\\)的情形，那么就有以下情况考虑：\r\n\r\n第\\(1\\)位和第\\(n-2\\)位都为\\(0\\)，那么插入一个”\\(01\\)“。（如果插入”\\(10\\)“，那么会和\\(f(n-1)\\)的情况重复）\r\n第\\(1\\)位为\\(0\\)，第\\(n-2\\)位为\\(1\\)，那么插入一个”\\(01\\)“。\r\n第\\(1\\)位为\\(1\\)，第\\(n-2\\)位为\\(0\\)，那么插入一个”\\(10\\)“。\r\n\r\n这\\(3\\)种情况，对于\\(f(n-2)\\)中的任意一种情况，总是符合上面\\(3\\)种情况之一，进行对应的转移，因此都包含在\\(f(n-2)\\)中。\r\n这\\(6\\)个环的长度分别为\\(1,6,46,6,3,2\\)，因此答案为\\(f(1)\\cdot f(6)\\cdot f(46)\\cdot f(6)\\cdot f(3)\\cdot\r\nf(2)\\)\r\n代码\r\nM = 6f = [-1, 1, 3]for i in range(1 &lt;&lt; M):    f.append(f[-1] + f[-2])st = set()ans = 1for s in range(1 &lt;&lt; M):    if s in st:        continue    st.add(s)    cnt = 1    while True:        s = s &gt;&gt; 1 | (s &amp; 1 ^ ((s &gt;&gt; 1) &amp; (s &gt;&gt; 2) &amp; 1)) &lt;&lt; 5        if s in st:            break        cnt += 1        st.add(s)    ans *= f[cnt]print(ans)\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 208","url":"/project-euler/208/","content":"\r\nProject Euler 208\r\n题目\r\nRobot Walks\r\nA robot moves in a series of one-fifth circular arcs (\\(72°\\)), with a free choice of a clockwise\r\nor an anticlockwise arc for each step, but no turning on the spot.\r\nOne of \\(70932\\) possible closed\r\npaths of \\(25\\) arcs starting northward\r\nis\r\n\r\nGiven that the robot starts facing North, how many journeys of \\(70\\) arcs in length can it take that return\r\nit, after the final arc, to its starting position?(Any arc may be\r\ntraversed multiple times.)\r\n矩阵树定理\r\n此处的矩阵树定理给出如何求有向图中内向树（内向树的基图是一棵树，但是所有子节点都将指向父节点）个数和外向树（外向树的基图也是一棵树，但是所有父节点都将指向子节点）个数。\r\n内向树个数\r\n令\\(D^{\\text{out}}(G)\\)为有向图\\(G\\)出度的矩阵，它是一个对角矩阵，其中元素\\(d^{\\text{out}}_{i,i}(G)\\)表示节点\\(i\\)的出度。\r\n令\\(A(G)\\)为有向图\\(G\\)的邻接矩阵。\r\n令\\(Q^{\\text{out}}(G)=D^{\\text{out}}(G)-A(G)\\)为图\\(G\\)的出度拉普拉斯矩阵。\r\n那么以节点\\(w\\)为根的内向树的个数\\(t_w(G)\\)为：\r\n\\[t_w(G)=|M_{w,w}|\\]\r\n其中\\(M_{i,j}\\)表示矩阵\\(Q^{\\text{out}}(G)\\)去掉第\\(i\\)行和第\\(j\\)列的一个矩阵。\r\n外向树个数\r\n和求内向树个数类似，令\\(D^{\\text{in}}(G)\\)为有向图\\(G\\)入度的矩阵。\r\n令\\(Q^{\\text{in}}(G)=D^{\\text{in}}(G)-A(G)\\)为图\\(G\\)的入度拉普拉斯矩阵。\r\n那么以节点\\(w\\)为根的外向树的个数\\(t_w&#39;(G)\\)为：\r\n\\[t_w&#39;(G)=|M&#39;_{w,w}|\\]\r\n其中\\(M&#39;_{i,j}\\)表示矩阵\\(Q^{\\text{in}}(G)\\)去掉第\\(i\\)行和第\\(j\\)列的一个矩阵。\r\nBEST定理\r\nBEST定理给出了有向欧拉图\\(G=(V,E)\\)的不同欧拉回路条数\\(\\text {ec}(G)\\)为：\r\n\\[\\text {ec} (G)=t_{w}(G)\\prod _{v\\in\r\nV}(\\deg(v)-1)!\\]\r\n其中，\r\n\r\n\\(t_w(G)\\)是以\\(w\\)为根节点的内向树个数。由于\\(G\\)是一个欧拉图，因此对于\\(w,w&#39;\\in V\\)，都有\\(t_w(G)=t_{w&#39;}(G)\\).\\(t_w(G)\\)的值可以通过矩阵树定理求出。\r\n\\(\\deg(v)\\)是指节点\\(v\\)在这个有向图的出/入度。由于欧拉图中，每个节点出度和入度都是相同的，因此统一用\\(\\deg(v)\\)表示。\r\n\r\n注意定理适用于有重边的图，并且，这些重边将被视为是不一样的。因此如果重边使用的次序不一样，那么两条欧拉回路视为是不相同的。\r\n解决方案\r\n假设\\(m=70,n=\\dfrac{m}{5}=14\\)，那么答案为\r\n\\[\\sum_{j=0}^n\\dfrac{\\binom{n}{j}^5}{n^4}\\cdot(n^4-3jn^3+4j^2n^2-2j^3n+j^4)\\]\r\n如下图所示，当机器人选择了一个方向走，那么下一步它只能选择当前方向的前一个方向或者是后一个方向走。\r\n\r\n我们为每个初始方向标上一个序号，按照题意，当前如果行走的是第\\(i\\)个方向，那么下一步只能是第\\((i+1)\\% 5\\)或者是第\\((i-1)\\%5\\)个方向。\r\n可以发现，当机器人恰好沿着这\\(5\\)个方向都走一次时，它才能回到原点。因此，在这\\(m\\)个步骤中，每个方向出现的次数都是相等的，都为\\(n\\)次。如果\\(m\\)不是\\(5\\)的倍数，那么机器人没有办法走完其中一个“圈”，最终答案为\\(0\\)。\r\n另外，如果这五个方向以逆时针迭代一圈，那就能够下图的左边部分，相当于机器人逆时针走了一个完整的圈；如果以顺时针迭代一圈，那么就能够得到右边部分，相当于机器人顺时针走完了一个圈。因此机器人走完\\(m\\)步最终回到原点时，相当于这个机器已经走了逆时针\\(j\\)个圈，顺时针\\(n-j\\)个圈，其中\\(0\\le j\\le n\\)。\r\n\r\n把问题转化为一个图论模型：\r\n一个有向图\\(G=(V,E)\\)上分别有\\(5\\)个节点，对于每个节点\\(i\\)，它只能到达节点\\((i+1)\\% 5\\)或者是第\\((i-1)\\%5\\)。如果在整个过程中，机器人总共逆时针旋转了\\(j\\)圈，顺时针旋转了\\(n-j\\)圈。那么就相当于每个节点\\(i\\)，有\\(j\\)条有向边到达节点\\((i+1)\\%5\\)，有\\(n-j\\)条边到达节点\\((i-1)\\%5\\).那么问题就相当于转化为求\\(G\\)的欧拉回路条数。\r\n有向图\\(G\\)的邻接矩阵\\(A(G)\\)可以写成如下：\r\n\\[A(G)=\\begin{bmatrix}\r\n0 &amp; j &amp; 0 &amp; 0 &amp; n-j\\\\\r\nn-j &amp; 0 &amp; j &amp; 0 &amp; 0\\\\\r\n0 &amp; n-j &amp; 0 &amp; j &amp; 0\\\\\r\n0 &amp; 0 &amp; n-j &amp; 0 &amp; j\\\\\r\nj &amp; 0 &amp; 0 &amp; 0 &amp; n-j\r\n\\end{bmatrix}\\]\r\n不难写出它的出度拉普拉斯矩阵为：\r\n\\[Q^{\\text{out}}(G)=\\begin{bmatrix}\r\nn &amp; n-j &amp; 0 &amp; 0 &amp; j\\\\\r\nj &amp; n &amp; n-j &amp; 0 &amp; 0\\\\\r\n0 &amp; j &amp; n &amp; n-j &amp; 0\\\\\r\n0 &amp; 0 &amp; j &amp; n &amp; n-j\\\\\r\nn-j &amp; 0 &amp; 0 &amp; j &amp; n\r\n\\end{bmatrix}\\]\r\n那么根据BEST定理，将矩阵代入计算，可以得到BEST定理中生成树的个数为\\(n^4-3jn^3+4j^2n^2-2nj^3+j^4\\).\r\nBEST定理中\\(\\text{ec}(G)\\)中的另外一项，代入\\(\\deg(v)=n\\)，那么得到\\(((n-1)!)^5\\)。但是，在我们这个图上，每一条边视为相同的。因此，需要从\\(\\text{ec}(G)\\)中除去\\((j!)^5\\cdot((n-j)!)^5\\)。不过，机器人一开始可以从某条欧拉回路中的任意一条节点为\\(0\\)的出边开始出发，由于节点\\(0\\)有\\(n\\)条出边，那么需要乘回\\(n\\)。因此，另外一项最终系数为\\(\\dfrac{((n-1)!)^5}{(j!)^5\\cdot((n-j)!)^5}\\cdot\r\nn=\\dfrac{\\binom{n}{j}^5}{n^4}\\)。\r\n因此，综合起来，机器人可以行走的步数为：\r\n\\[\\sum_{j=0}^n\\dfrac{\\binom{n}{j}^5}{n^4}\\cdot(n^4-3jn^3+4j^2n^2-2j^3n+j^4)\\]\r\n代码\r\nfrom tools import get_pascals_triangleM = 70N = M // 5ans = 0C = get_pascals_triangle(N)for j in range(N + 1):    ans += (C[N][j] ** 5) * (N ** 4 + j ** 4 - 3 * j * (N ** 3) + 4 * j * j * N * N - 2 * N * (j ** 3)) // (N ** 4)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 210","url":"/project-euler/210/","content":"\r\nProject Euler 210\r\n题目\r\nObtuse Angled Triangles\r\nConsider the set \\(S(r)\\) of points\r\n\\((x,y)\\) with integer coordinates\r\nsatisfying |\\(x| + |y| \\le r\\).\r\nLet \\(O\\) be the point \\((0,0)\\) and \\(C\\) the point \\((\\dfrac{r}{4},\\dfrac{r}{4})\\).\r\nLet \\(N(r)\\) be the number of points\r\n\\(B\\) in \\(S(r)\\), so that the triangle \\(OBC\\) has an obtuse angle, i.e. the largest\r\nangle \\(\\alpha\\) satisfies \\(90°&lt;\\alpha&lt;180°\\).\r\nSo, for example, \\(N(4)=24\\) and\r\n\\(N(8)=100\\).\r\nWhat is \\(N(1,000,000,000)\\)?\r\n解决方案\r\n本解决方案只适用于\\(r\\)为\\(8\\)的倍数的情况。\r\n这些点一共由三部分组成，以\\(r=8\\)为例，如下图所示：\r\n\r\n其中，位于直线\\(x-y=0\\)上的点都不是合法的，因为\\(\\triangle\r\nOBC\\)此时是一个退化的三角形。接下来的计算将忽略这些点。\r\n那么一共有三种情况：\r\n\r\n\\(\\angle\r\nO\\)为钝角。这些点位于平面\\(x+y&lt;0\\)中，有\\(r^2\\)个。\r\n\\(\\angle\r\nC\\)为钝角。这些点位于平面\\(x+y&gt;\\dfrac{r}{2}\\)中，有\\(\\dfrac{r^2}{2}\\)个。\r\n\\(\\angle\r\nB\\)为钝角。这些点位于平面\\((x-\\dfrac{r}{8})^2+(y-\\dfrac{r}{8})^2&lt;\\dfrac{r^2}{32}\\)中，也就是一个圆内。\r\n\r\n接下来重点是计算情况3中的点个数。\r\n令\\(s=\\dfrac{r}{8}\\)，那么此时\\(s\\)是一个整数。这个圆的圆心也就是\\((s,s)\\)。\r\n将圆心挪到原点，此时等价于求圆\\(x^2+y^2=2s^2\\)内有多少个点，这部分点一共有\r\n\\[2\\cdot{\\lfloor\\sqrt{2s^2-1}\\rfloor}+\\sum_{x=1}^{\\lfloor\\sqrt{2s^2-1}\\rfloor}(4\\cdot\\lfloor\\sqrt{2s^2-x^2-1}\\rfloor+2)-2(s-1)\\]\r\n注意最后一项是在直线\\(x-y=0\\)上的点，一共有\\(2(s-1)\\)个，这些点需要去掉。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const ll N=1e9;int main()&#123;    ll ans=3ll*N*N/2;    ll s=N&gt;&gt;3;    ll r2=s*s*2;    for(ll x=0,y=sqrt(r2)+1;x*x&lt;=r2;x++)&#123;        for(;y&gt;=0&amp;&amp;x*x+y*y&gt;=r2;--y);        if(x==0) ans+=y*2;        else if(y&gt;=0) ans+=y*4+2;    &#125;    ans-=2*(s-1);    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 21","url":"/project-euler/21/","content":"\r\nProject Euler 21\r\n题目\r\nAmicable numbers\r\nLet \\(d(n)\\) be defined as the sum\r\nof proper divisors of \\(n\\) (numbers\r\nless than \\(n\\) which divide evenly\r\ninto \\(n\\)).\r\nIf \\(d(a) = b\\) and \\(d(b) = a\\), where \\(a \\neq b\\), then \\(a\\) and \\(b\\) are an amicable pair and each of \\(a\\) and \\(b\\) are called amicable numbers.\r\nFor example, the proper divisors of \\(220\\) are \\(1\\), \\(2\\), \\(4\\), \\(5\\), \\(10\\), \\(11\\), \\(20\\), \\(22\\), \\(44\\), \\(55\\) and \\(110\\); therefore \\(d(220) = 284\\). The proper divisors of\r\n\\(284\\) are \\(1\\), \\(2\\), \\(4\\), \\(71\\) and \\(142\\); so \\(d(284) = 220\\).\r\nEvaluate the sum of all the amicable numbers under \\(10000\\).\r\n因数和定理\r\n如果一个正整数\\(n\\)分解后成为：\r\n\\[n=\\prod_{i=1}^k p_i^{e_i}\\]\r\n那么\\(n\\)的因数的和为： \\[\\prod_{i=1}^k\r\n\\dfrac{p_i^{e_i+1}-1}{p_i-1}\\] 更一般的，因数的\\(k\\)次幂的和为 \\[\\prod_{i=1}^k\r\n\\dfrac{p_i^{k(e_i+1)}-1}{p_i^k-1}\\]\r\n计算因数和的函数将会封装在tools中并且以divisor_sigma(n,k=None)的方式调用。\r\n解决方案\r\n可以直接通过因数和定理，先将所有\\(10000\\)以下的数进行分解，然后计算出真因数的值。\r\n最后直接判断两对数是否满足亲和数的条件。\r\n计算\\(1\\sim\r\nn\\)中的所有因数和也可以通过欧拉筛加速计算。\r\n代码\r\nfrom tools import divisors_sigmaN = 10000d = [0 for _ in range(N)]for i in range(1, N):    d[i] = divisors_sigma(i)-ians = 0for i in range(1, N):    if N &gt; d[i] &gt; i == d[d[i]]:        ans += i + d[i]print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 211","url":"/project-euler/211/","content":"\r\nProject Euler 211\r\n题目\r\nDivisor Square Sum\r\nFor a positive integer \\(n\\), let\r\n\\(\\sigma_2(n)\\) be the sum of the\r\nsquares of its divisors. For example,\r\n\\[\\sigma_2(10) = 1 + 4 + 25 + 100 =\r\n130.\\]\r\nFind the sum of all \\(n, 0 &lt; n &lt;\r\n64,000,000\\) such that \\(\\sigma_2(n)\\) is a perfect square.\r\n解决方案\r\n在线性晒进行的过程中计算积性函数\\(\\sigma_2\\).筛出来的质数存放在数组\\(pr\\)中。\r\n如果一个合数\\(i\\)使用了一个新质数\\(p\\)筛出来了一个新数\\(i\\cdot\r\np\\)，那么新数比原来的数多出来了一个质因子，和原来的答案是独立的，因此有\\(\\sigma_2(i\\cdot\r\np)=\\sigma(i)\\cdot(p^2+1)\\)；否则，如果使用的是旧质数，那么按照上面的办法，新产生的一部分因子是重复的，而这一重复的部分恰好来自于\\(\\sigma_2(i/p)\\)。以下图为例：\r\n\r\n黑色一行为当前数的质因子，蓝色的一行为因子平方和。\\(16\\)通过一个旧的质因子\\(2\\)筛出来了一个新数\\(32\\)。新构造的一部分因子平方，和原来\\(16\\)的一部分因子平方是重叠的（如图黄色部分），因此直接相加会导致重复。不难理解，这一重复部分完全可以用\\(8=16/2\\)的那一部分来表示，也就是\\(\\sigma_2(i/p)\\cdot\r\np^2\\)。因此，这种情况下，\\(\\sigma_2(i\\cdot\r\np)=\\sigma_2(i)+(\\sigma_2(i)-\\sigma_2(i/p))p^2\\)来表示。\r\n最终，直接判断所有计算出来的\\(\\sigma_2\\)函数值是否为平方数即可。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=64000000;ll f[N+2],pr[N/4+400],v[N+2];int m=0;int main()&#123;    f[1]=1;    for(int i=2;i&lt;N;i++)&#123;        if(v[i]==0)&#123;            v[i]=i;f[i]=1ll*i*i+1;            pr[++m]=i;        &#125;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;N/i) break;            v[i*pr[j]]=pr[j];            if(pr[j]==v[i])&#123;                f[i*pr[j]]=f[i]+(f[i]-f[i/pr[j]])*pr[j]*pr[j];            &#125;            else&#123;                f[i*pr[j]]=f[i]*(pr[j]*pr[j]+1);            &#125;        &#125;    &#125;    ll ans=0;    for(int i=1;i&lt;N;i++)&#123;        ll sq=round(sqrt(f[i]));        if(sq*sq==f[i]) ans+=i;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 212","url":"/project-euler/212/","content":"\r\nProject Euler 212\r\n题目\r\nCombined Volume of Cuboids\r\nAn axis-aligned cuboid, specified by parameters \\(\\{ (x_0,y_0,z_0), (dx,dy,dz) \\}\\), consists\r\nof all points \\((X,Y,Z)\\) such that\r\n\\(x_0 \\le X \\le x_0+dx, y_0 \\le Y \\le\r\ny_0+dy\\) and \\(z_0 \\le Z \\le\r\nz_0+dz\\). The volume of the cuboid is the product, \\(dx \\times dy \\times dz\\). The combined\r\nvolume of a collection of cuboids is the volume of their union and\r\nwill be less than the sum of the individual volumes if any cuboids\r\noverlap.\r\nLet \\(C_1,\\dots,C_{50000}\\) be a\r\ncollection of \\(50000\\) axis-aligned\r\ncuboids such that \\(C_n\\) has\r\nparameters\r\n\\(\\begin{aligned}\r\nx_0 &amp;=&amp; S_{6n-5} \\text{ modulo } 10000\\\\\r\ny_0 &amp;=&amp; S_{6n-4} \\text{ modulo } 10000\\\\\r\nz_0 &amp;=&amp; S_{6n-3} \\text{ modulo } 10000\\\\\r\ndx &amp;=&amp; 1 + (S_{6n-2} \\text{ modulo } 399)\\\\\r\ndy &amp;=&amp; 1 + (S_{6n-1} \\text{ modulo } 399)\\\\\r\ndz &amp;=&amp; 1 + (S_{6n} \\text{ modulo } 399)\r\n\\end{aligned}\\)\r\nwhere \\(S_1,\\dots,S_{300000}\\) come\r\nfrom the “Lagged Fibonacci Generator”:\r\nFor \\(1 \\le k \\le 55, S_k = [100003 -\r\n200003k + 300007k^3]  (\\text{ modulo } 1000000)\\)\r\nFor \\(56 \\le k, S_k = [S_{k-24} + S_{k-55}]\r\n(\\text{ modulo } 1000000)\\)\r\nThus, \\(C_1\\) has parameters \\(\\{(7,53,183),(94,369,56)\\}\\), \\(C_2\\) has parameters \\(\\{(2383,3563,5079),(42,212,344)\\}\\), and so\r\non.\r\nThe combined volume of the first \\(100\\) cuboids, \\(C_1,\\dots,C_{100}\\), is \\(723581599\\).\r\nWhat is the combined volume of all \\(50000\\) cuboids, \\(C_1,\\dots,C_{50000}\\) ?\r\n解决方案\r\n这\\(50000\\)个方块有以下特点：\r\n\r\n它们是用伪随机算法“均匀”生成的，因此实际上，被方块占领的空间相对均匀。\r\n这些方块的边长很小（最多\\(399\\)），但是空间长度却很大（最多可以达到\\(10399\\)）。\r\n\r\n因此，我们可以将整个空间划分成多个部分，然后分别在每个部分中计算体积，最终再求和。并且，对于任何一个划分出来的空间，立方体的数量比较少（这说明我们在后面使用容斥原理时，枚举量将很少）。\r\n这里的划分方案是：每一个部分将划分成\\(B\\times B\\times B\\)的大小，其中\\(B=399\\)。这种划分方式保证了每一个方块最多只会被划分成\\(8\\)部分。\r\n对于每一个划分出来的空间而言，考虑使用容斥原理进行计算这一部分的体积：如果当前空间是奇数个方块的交集，那么这个交集的体积就需要在答案中加上，否则就从答案中减去。以此过程最终计算出答案。\r\n当然，本题也可以用八叉树进行实现，不过效率较低。\r\n代码\r\nfrom collections import defaultdictN = 50000block = 399def gen():    a = []    for i in range(1, 56):        a.append((100003 - 200003 * i + 300007 * i ** 3) % 1000000)        yield a[-1]    while True:        a.append((a[-24] + a[-55]) % 1000000)        yield a[-1]def dfs(f, flag, pre, here):    s = 0    for i in range(f, len(here)):        now = cubes[here[i]]        x, y, z = max(pre[0], now[0]), max(pre[1], now[1]), max(pre[2], now[2])        dx = min(pre[0] + pre[3], now[0] + now[3]) - x        dy = min(pre[1] + pre[4], now[1] + now[4]) - y        dz = min(pre[2] + pre[5], now[2] + now[5]) - z        if min(dx, dy, dz) &lt;= 0:            continue        s += flag * dx * dy * dz + dfs(i + 1, -flag, [x, y, z, dx, dy, dz], here)    return scubes = []mp = defaultdict(list)g = gen()for m in range(N):    a, b, c = g.__next__() % 10000, g.__next__() % 10000, g.__next__() % 10000    x, y, z = g.__next__() % 399 + 1, g.__next__() % 399 + 1, g.__next__() % 399 + 1    cubes.append((a, b, c, x, y, z))    for i in range(a // block, (a + x) // block + 1):        for j in range(b // block, (b + y) // block + 1):            for k in range(c // block, (c + z) // block + 1):                mp[i, j, k].append(m)ans = 0for pos, here in mp.items():    ans += dfs(0, 1, [pos[0] * block, pos[1] * block, pos[2] * block, block, block, block], here)print(ans)\r\n","categories":["Project Euler"],"tags":["容斥原理"]},{"title":"Project Euler 214","url":"/project-euler/214/","content":"\r\nProject Euler 214\r\n题目\r\nTotient Chains\r\nLet \\(\\varphi\\) be Euler’s totient\r\nfunction, i.e. for a natural number n, \\(varphi(n)\\) is the number of \\(k, 1 \\le k \\le n,\\) for which \\(\\gcd(k,n) = 1\\).\r\nBy iterating \\(\\varphi\\), each\r\npositive integer generates a decreasing chain of numbers ending in \\(1\\). E.g. if we start with \\(5\\) the sequence \\(5,4,2,1\\) is generated.\r\nHere is a listing of all chains with length \\(4\\):\r\n\\(\\begin{aligned}\r\n&amp; 5,4,2,1\\\\\r\n&amp; 7,6,2,1\\\\\r\n&amp; 8,4,2,1\\\\\r\n&amp; 9,6,2,1\\\\\r\n&amp; 10,4,2,1\\\\\r\n&amp; 12,4,2,1\\\\\r\n&amp; 14,6,2,1\\\\\r\n&amp; 18,6,2,1\r\n\\end{aligned}\\)\r\nOnly two of these chains start with a prime, their sum is \\(12\\). What is the sum of all primes less\r\nthan \\(40000000\\) which generate a\r\nchain of length \\(25\\)?\r\n解决方案\r\n令\\(N=40000000,M=25\\)。\r\n本题使用的\\(N\\)的范围比较大，不难想到使用线性筛来计算积性函数\\(\\varphi\\)的值。\r\n设\\(f(i)(i\\ge 1)\\)为以\\(i\\)为起点的链长度，根据题意，不难想到使用动态规划的方法来计算\\(f(i)\\)：\r\n\\[\r\nf(i)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i=1 \\\\\r\n  &amp;f(\\varphi(i))+1 &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n遍历所有\\(N\\)以内的质数，判断其\\(f\\)的函数值是否为\\(M\\)。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=40000000,M=25;int f[N+4],phi[N+4],pr[N+4],v[N+4];int m=0;int main()&#123;    phi[1]=f[1]=1;    for(int i=2;i&lt;N;i++)&#123;        if(v[i]==0)&#123;            v[i]=i;phi[i]=i-1;            pr[++m]=i;        &#125;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;N/i) break;            v[i*pr[j]]=pr[j];            if(pr[j]==v[i]) phi[i*pr[j]]=phi[i]*pr[j];            else phi[i*pr[j]]=phi[i]*(pr[j]-1);        &#125;        f[i]=f[phi[i]]+1;    &#125;    ll ans=0;    for(int i=1;i&lt;=m;i++)        if(f[pr[i]]==M) ans+=pr[i];    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 213","url":"/project-euler/213/","content":"\r\nProject Euler 213\r\n题目\r\nFlea Circus\r\nA \\(30\\times30\\) grid of squares\r\ncontains \\(900\\) fleas, initially one\r\nflea per square.\r\nWhen a bell is rung, each flea jumps to an adjacent square at random\r\n(usually \\(4\\) possibilities, except\r\nfor fleas on the edge of the grid or at the corners).\r\nWhat is the expected number of unoccupied squares after \\(50\\) rings of the bell? Give your answer\r\nrounded to six decimal places.\r\n解决方案\r\n令\\(N=30,M=50\\)。单独考虑\\(N\\times\r\nN\\)方格中每个格子上的跳蚤最终跳去的地方，使用动态规划的思想解决。\r\n令\\(f_{n,m}(i,j,k)(0\\le i\\le M,0\\le j,n&lt;\r\nN,0\\le k,m &lt; N)\\)表示从格子\\((n,m)\\)经过\\(i\\)步走到格子\\((j,k)\\)的概率。那么，可以列出以下状态转移方程：\r\n\\[\r\nf_{n,m}(i,j,k)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1 &amp; &amp; \\text{if}\\quad i=0\\land j=n\\land k=m \\\\\r\n  &amp;0 &amp; &amp; \\text{else if}\\quad i=0 \\\\\r\n  &amp;\\sum_{|j-x|+|k-y|=1,0\\le\r\nx,y&lt;N}\\dfrac{f_{n,m}(i-1,x,y)}{\\text{dir}(x,y)} &amp; &amp;\r\n\\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n其中，函数\\(\\text{dir}(x,y)\\)表示从格子\\((x,y)\\)可以跳往的方向数。\r\n方程的最后一行说明，在状态\\(f_{n,m}(i-1,x,y)\\)时，有\\(\\text{dir}(x,y)\\)的概率跳向\\((j,k)\\)。\r\n那么，独立地看单独一个格子\\((n,m)\\)。根据乘法原理，它上面没有跳蚤的概率为：\r\n\\[p(n,m)=\\prod_{i=0}^{N-1}\\prod_{j=0}^{M-1}f_{i,j}(M,n,m)\\]\r\n因此，最终答案即为期望之和，也就是\r\n\\[\\sum_{i=0}^{N-1}\\sum_{j=0}^{M-1}p(i,j)\\]\r\n注意到，由于正方形是对称的，因此本代码只计算了约\\(\\dfrac{1}{4}\\)的格子后就可以求出\\(p\\)。如果加上对角线的对称轴，只需要计算\\(\\dfrac{1}{8}\\)的格子即可。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N=30,M=50;int dx[4]=&#123;-1,1,0,0&#125;,dy[4]=&#123;0,0,-1,1&#125;;double f[M+1][N][N],g[N][N];int dir[N][N];void solve(int x,int y)&#123;    memset(f,0,sizeof(f));    f[0][x][y]=1;    for(int i=1;i&lt;=M;i++)        for(int j=0;j&lt;N;j++)            for(int k=0;k&lt;N;k++)&#123;                for(int r=0;r&lt;4;r++)&#123;                    int x=j+dx[r],y=k+dy[r];                    if(x&gt;=0&amp;&amp;y&gt;=0&amp;&amp;x&lt;N&amp;&amp;y&lt;N) f[i][j][k]+=f[i-1][x][y]/dir[x][y];                &#125;            &#125;    for(int i=0;i&lt;N;i++)        for(int j=0;j&lt;N;j++) &#123;            g[i][j] *= 1.0 - f[M][i][j];            if(i!=N-1-i) g[i][j] *= 1.0 - f[M][N-1-i][j];            if(j!=N-1-j) g[i][j] *= 1.0 - f[M][i][N-1-j];            if(i!=N-1-i&amp;&amp;j!=N-1-j) g[i][j] *= 1.0 - f[M][N-1-i][N-1-j];        &#125;&#125;int main()&#123;    clock_t a = clock();    for(int i=0;i&lt;N;i++)        for(int j=0;j&lt;N;j++) &#123;            g[i][j] = 1;            for (int k = 0; k &lt; 4; k++) &#123;                int x = i + dx[k], y = j + dy[k];                if (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; N &amp;&amp; y &lt; N) ++dir[i][j];            &#125;        &#125;    for(int i=0;i&lt;(N+1)/2;i++)        for(int j=0;j&lt;(N+1)/2;j++)            solve(i,j);    double ans=0;    for(int i=0;i&lt;N;i++)        for(int j=0;j&lt;N;j++)            ans+=g[i][j];    printf(&quot;%.6f\\n&quot;,ans);    cout &lt;&lt; clock() - a &lt;&lt; endl;&#125;\r\n","categories":["Project Euler"],"tags":["动态规划","概率"]},{"title":"Project Euler 215","url":"/project-euler/215/","content":"\r\nProject Euler 215\r\n题目\r\nCrack-free Walls\r\nConsider the problem of building a wall out of \\(2\\times1\\) and \\(3\\times1\\) bricks (horizontaldimensions)\r\nsuch that, for extra strength, the gaps between horizontally-adjacent\r\nbricks never line up in consecutive layers, i.e. never form a “running\r\ncrack”.\r\nFor example, the following \\(9\\times3\\) wall is not acceptable due to\r\nthe running crack shown in red:\r\n\r\nThere are eight ways of forming a crack-free \\(9\\times3\\) wall, written \\(W(9,3) = 8\\).\r\nCalculate \\(W(32,10)\\).\r\n解决方案\r\n令\\(N=32,M=10\\)。先将每一行可能的状态都搜索出来，存入一个下标起始为\\(1\\)的数组\\(st\\)中。这些状态用一个\\(N-1\\)位二进制数\\(b=b_{N-1}b_{N-2}\\dots\r\nb_2b_1\\)保存。其中，如果第\\(k\\)列有空隙，那么\\(b_k=1\\)，否则\\(b_k=0\\)。令\\(m\\)为数组\\(st\\)的长度。\r\n那么，如果一行的墙砖\\(st[i]\\)可以拼接在\\(st[j]\\)的下面，那么\\(st[j]\\&amp;st[i]=0\\)。这里的\\(\\&amp;\\)为与运算。这题就可以使用动态规划的思想轻易解决。\r\n假设\\(f(i,j)(1\\le i\\le M,1\\le j\\le\r\nm)\\)为已经铺好了前\\(i\\)行，其中第\\(i\\)行的状态为\\(st[j]\\)，那么可以列出如下状态转移方程：\r\n\\[\r\nf(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i=1 \\\\\r\n  &amp;\\sum_{st[j]\\&amp;st[k]=0}  f(i-1,k) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n最终答案为\\(\\sum_{j=1}^m\r\nf(M,j)\\)。\r\n代码\r\nM = 32N = 10def gen(M):    st = []    def dfs(f, s):        if f &gt; M:            return        elif f == M:            st.append(s ^ 1 &lt;&lt; M)            return        dfs(f + 2, s | 1 &lt;&lt; (f + 2))        dfs(f + 3, s | 1 &lt;&lt; (f + 3))    dfs(0, 0)    return stst = gen(M)g = [[] for _ in range(len(st))]for i in range(len(st)):    for j in range(i + 1, len(st)):        if (st[i] &amp; st[j]) == 0:            g[i].append(j)            g[j].append(i)f = [1] * len(st)for i in range(N-1):    f = [sum(f[j] for j in g[i]) for i in range(len(st))]ans = sum(f)print(ans)\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 216","url":"/project-euler/216/","content":"\r\nProject Euler 216\r\n题目\r\nInvestigating\r\nthe primality of numbers of the form \\(2n^2-1\\)\r\nConsider numbers \\(t(n)\\) of the\r\nform \\(t(n) = 2n^2-1\\) with \\(n &gt; 1\\).\r\nThe first such numbers are \\(7, 17, 31, 49,\r\n71, 97, 127\\) and \\(161\\).\r\nIt turns out that only \\(49 =\r\n7\\times7\\) and \\(161 =\r\n7\\times23\\) are not prime.\r\nFor \\(n \\le 10000\\) there are \\(2202\\) numbers \\(t(n)\\) that are prime.\r\nHow many numbers \\(t(n)\\) are prime\r\nfor \\(n \\le 50,000,000\\) ?\r\n解决方案\r\n一个结论：如果\\(p\\mid\r\nt(n)\\)，那么\\(p\\mid t(kp\\pm\r\nn)\\)，其中\\(k&gt;0\\)。\r\n原因：\\(t(kp\\pm n)=2(kp^2\\pm\r\nn)^2-1=2k^2p^4\\pm4kp^2n+2n^2-1\\)。我们已经假定了\\(p\\mid 2n^2-1\\)，因此\\(p\\mid t(kp\\pm n)\\)成立。\r\n这说明只要发现\\(t(n)\\)有一个质因子\\(p\\)，就可以将它把\\(t(n+p),t(n+2p),\\dots,t(p-n),t(2p-n),\\dots\\)筛掉。\r\n如果有一个数始终无法筛掉，说明它本身就是一个质数。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=50000000;ll T[N+4];int main()&#123;    int ans=0;    for(int n=2;n&lt;=N;n++)        T[n]=2ll*n*n-1;    for(int n=2;n&lt;=N;n++)&#123;        ll p=T[n];        if(p==2ll*n*n-1) ++ans;        if(p==1)            continue;        for(ll j=p+n;j&lt;=N;j+=p)            while(T[j]%p==0) T[j]/=p;        for(ll j=p-n;j&lt;=N;j+=p)            while(T[j]%p==0) T[j]/=p;    &#125;    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 217","url":"/project-euler/217/","content":"\r\nProject Euler 217\r\n题目\r\nBalanced Numbers\r\nA positive integer with \\(k\\)\r\n(decimal) digits is called balanced if its first \\(\\left\\lceil\\dfrac{k}{2}\\right\\rceil\\)\r\ndigits sum to the same value as its last \\(\\left\\lceil\\dfrac{k}{2}\\right\\rceil\\)\r\ndigits, where \\(\\lceil x\\rceil\\),\r\npronounced ceiling of \\(x\\),\r\nis the smallest integer \\(\\ge x\\), thus\r\n\\(\\lceil \\pi\\rceil=4\\) and \\(\\lceil 5\\rceil=5\\).\r\nSo, for example, all palindromes are balanced, as is \\(13722\\).\r\nLet \\(T(n)\\) be the sum of all\r\nbalanced numbers less than \\(10^n\\).\r\nThus: \\(T(1) = 45, T(2) = 540\\) and\r\n\\(T(5) = 334795890\\). Find \\(T(47) \\bmod 3^{15}\\).\r\n解决方案\r\n令\\(N=47,M=\\left\\lfloor\\dfrac{N}{2}\\right\\rfloor\\)。\r\n由于数位的前一半位和后面一半位的和相等，那么我们首先通过动态规划的思想枚举一半数字中相同数字和下的所有数，然后再将它们重新组合起来即可。\r\n那么，令状态\\(c(i,j)(1\\le i\\le M,0\\le j\\le\r\n9i)\\)为有前导\\(0\\)的\\(i\\)位十进制数中，数位和为\\(j\\)的个数。那么不难写出以下状态转移方程：\r\n\\[\r\nc(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i=1 \\\\\r\n  &amp;\\sum_{k=0}^{\\min(j,10)} c(i-1,j-k) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n其中，最后一行表示从一个数位和为\\(j-k\\)的\\(i-1\\)位数的最低位后面再添加一个数位\\(k\\)，那么就转移到了当前的状态。\r\n令状态\\(s(i,j)(1\\le i\\le M,0\\le j\\le\r\n9i)\\)为有前导\\(0\\)的\\(i\\)位十进制数中，数位和为\\(j\\)的所有数之和。那么可以写出以下状态转移方程：\r\n\\[\r\ns(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i=1 \\\\\r\n  &amp;\\sum_{k=0}^{\\min(j,10)} 10 s(i-1,j-k)+k\\cdot c(i-1)(j-k) &amp;\r\n&amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n其中，最后一行表示从一个数位和为\\(j-k\\)的\\(i-1\\)位数的最低位后面再添加一个数位\\(k\\)。这部分所有数都将乘以一个\\(10\\)再加到当前状态。然后还有最低位新添加的\\(k\\)，这一部分的数一共有\\(c(i-1,j-k)\\)个，因此当前状态还要补上\\(k\\cdot c(i-1,j-k)\\)的和。\r\n正式求解问题答案时，我们先枚举符合条件的数的数位个数\\(n\\)，令\\(m=\\left\\lfloor\\dfrac{n}{2}\\right\\rfloor\\)，再枚举一半的数位和\\(d\\)。需要注意的是，组合的过程中，高一半位是不能有前导\\(0\\)，而低一半位是可以有前导\\(0\\)。而求不能有前导\\(0\\)的情况，只需要进行以下差分即可。也就是说，令\\(C(i,j)=c(i,j)-c(i-1,j),S(i,j)=s(i,j)-s(i-1,j)\\)。\r\n\r\n当\\(n\\)为偶数时，直接将前半部分的数直接和后半部分的数一一组合即可得。最终结果为\\(S(m,d)\\cdot c(m,d)\\cdot 10^m+s(m,d)\\cdot\r\nC(m,d)\\)。\r\n当\\(n\\)为奇数时，注意到最中间的那个数位是可以任取的。那么，分成\\(3\\)部分来考虑这一些数的组合之和：左边一部分的数的组合之和为\\(S(m,d)\\cdot c(m,d)\\cdot 10^{m+1}\\cdot\r\n10\\)；中间的那个数位的组合之和\\(45\\cdot\r\n10^m\\cdot C(m,d)\\cdot c(m,d)\\)；右边一部分的组合之和为\\(s(m,d)\\cdot C(m,d)\\cdot\r\n10\\)。将这三部分相加即可。\r\n\r\n代码\r\nN = 47mod = 3 ** 15M = N &gt;&gt; 1D = 9 * Mc = [[0 for _ in range(D + 1)] for _ in range(M + 1)]s = [[0 for _ in range(D + 1)] for _ in range(M + 1)]for j in range(10):    c[1][j] = 1    s[1][j] = jfor i in range(2, M + 1):    for j in range(0, D + 1):        for k in range(min(10, j + 1)):            c[i][j] = (c[i][j] + c[i - 1][j - k]) % mod            s[i][j] = (s[i][j] + 10 * s[i - 1][j - k] + k * c[i - 1][j - k]) % modans = 45for n in range(2, N + 1):    m = n &gt;&gt; 1    pw = pow(10, m, mod)    for d in range(1, 9 * m + 1):        cl, cr = c[m][d] - c[m - 1][d], c[m][d]        sl, sr = s[m][d] - s[m - 1][d], s[m][d]        if n % 2 == 0:            ans = (ans + sl * cr * pw + sr * cl) % mod        else:            ans = (ans + sl * cr * pw * 10 * 10 + 45 * pw * cl * cr + sr * cl * 10) % modprint(ans)\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 218","url":"/project-euler/218/","content":"\r\nProject Euler 218\r\n题目\r\nPerfect right-angled\r\ntriangles\r\nConsider the right angled triangle with sides \\(a=7, b=24\\) and \\(c=25\\). The area of this triangle is \\(84\\), which is divisible by the perfect\r\nnumbers \\(6\\) and \\(28\\).\r\nMoreover it is a primitive right angled triangle as \\(\\gcd(a,b)=1\\) and \\(\\gcd(b,c)=1\\).\r\nAlso \\(c\\) is a perfect square. We\r\nwill call a right angled triangle perfect if\r\n\r\nit is a primitive right angled triangle\r\nits hypotenuse is a perfect square\r\n\r\nWe will call a right angled triangle super-perfect if\r\n\r\nit is a perfect right angled triangle and\r\nits area is a multiple of the perfect numbers \\(6\\) and \\(28\\).\r\n\r\nHow many perfect right-angled triangles with \\(c\\le10^{16}\\) exist that are not\r\nsuper-perfect?\r\n解决方案\r\n本题一个让人出乎意料之外的地方是，题目要求的三角形并不存在。也就是说，答案为\\(0\\)。\r\n接下来证明这个过程：\r\n勾股数组\\((a,b,c)\\)的产生。枚举一系列的二元组\\((s,t)\\)，其中\\(s&gt;t\\)，那么可以产生勾股数组\\((2st,s^2-t^2,s^2+t^2)\\)。\r\n由于\\(c\\)是一个完全平方数，那么存在一个数\\(m,c=m^2\\)，那么也就是有\\(s^2+t^2=m^2\\)，而这恰好又是一个勾股数组，因此，我们使用\\(p,q(p&gt;q)\\)来产生勾股数组\\((s,t,m)\\)。那么\\(s=\\max(2pq,p^2-q^2),t=\\min(2pq,p^2-q^2)\\)。\r\n因此，\r\n\\(\\begin{aligned}\r\n&amp; a=2st=4pq(p^2-q^2)\\\\\r\n&amp; b=s^2-t^2=|(p^2-q^2)^2-4p^2q^2|=|p^4+q^4-6p^2q^2|\r\n\\end{aligned}\\)\r\n那么三角形的面积为\r\n\\[S=\\dfrac{1}{2}ab=2pq(p^2-q^2)|p^4+q^4-6p^2q^2|\\]\r\n接下来是三个部分的证明：\\(3\\mid S,4\\mid\r\nS,7\\mid S\\)。因为\\(\\text{lcm}(6,28)=84=2^2\\times 3\\times\r\n7\\)，遵循一致的证明方法。需要注意的是，式子中的所有变量，除了项\\(pq\\)，都是以平方的出现。\r\n\\(3\\mid S\\)\r\n如果\\(p\\)或\\(q\\)是\\(3\\)的倍数，那么结论成立。\r\n对于任意的\\(x\\in\r\n\\mathbb{N}\\)，发现\\(x^2\\% 3\r\n\\in\\{0,1\\}\\)。\r\n如果\\(p^2\\%3=q^2\\%3=1\\)，那么\\((p^2-q^2)\\%3=0\\)，原结论成立。\r\n\\(4\\mid S\\)\r\n注意到，\\(S\\)有个常数因子\\(2\\)。\r\n如果\\(p\\)或\\(q\\)是\\(2\\)的倍数，那么结论成立。\r\n对于任意的\\(x\\in\r\n\\mathbb{N}\\)，发现\\(x^2\\% 2\r\n\\in\\{0,1\\}\\)。\r\n如果\\(p^2\\%2=q^2\\%2=1\\)，那么\\((p^2-q^2)\\%2=0\\)，原结论成立。\r\n\\(7\\mid S\\)\r\n如果\\(p\\)或\\(q\\)是\\(7\\)的倍数，那么结论成立。\r\n对于任意的\\(x\\in\r\n\\mathbb{N}\\)，发现\\(x^2\\% 7\r\n\\in\\{0,1,2,4\\}\\)。\r\n如果\\(p^2\\%7=q^2\\%7\\)，那么\\((p^2-q^2)\\%2=0\\)，原结论成立。\r\n不失一般性，\r\n如果\\(p^2\\%7=1,q^2\\%7=2\\)，那么\\((p^4+q^4-6p^2q^2)\\%7=0\\)\r\n如果\\(p^2\\%7=1,q^2\\%7=4\\)，那么\\((p^4+q^4-6p^2q^2)\\%7=0\\)\r\n如果\\(p^2\\%7=2,q^2\\%7=4\\)，那么\\((p^4+q^4-6p^2q^2)\\%7=0\\)\r\n因此，\\(7\\mid S\\)。\r\n最终，\\(84\\mid\r\nS\\)，因此题目所求三角形并不存在。\r\n代码\r\nprint(0)\r\n","categories":["Project Euler"]},{"title":"Project Euler 219","url":"/project-euler/219/","content":"\r\nProject Euler 219\r\n题目\r\nSkew-cost coding\r\nLet A and B be bit strings\r\n(sequences of \\(0\\)’s and \\(1\\)’s).If A is equal\r\nto the leftmost length(A) bits of\r\nB, then A is said to be a\r\nprefix of B.\r\nFor example, \\(00110\\) is a prefix\r\nof \\(\\underline{00110}1001\\), but not\r\nof \\(00111\\) or \\(100110\\). A prefix-free code of size\r\n\\(n\\) is a collection of \\(n\\) distinct bit strings such that no\r\nstring is a prefix of any other. For example, this is a prefix-free code\r\nof size \\(6\\):\r\n\\[0000, 0001, 001, 01, 10, 11\\]\r\nNow suppose that it costs one penny to transmit a ‘\\(0\\)’ bit, but four pence to transmit a\r\n‘\\(1\\)’.\r\nThen the total cost of the prefix-free code shown above is \\(35\\) pence, which happens to be the\r\ncheapest possible for the skewed pricing scheme in question.\r\nIn short, we write \\(\\text{Cost}(6) =\r\n35\\).\r\nWhat is \\(\\text{Cost}(10^9)\\)?\r\n解决方案\r\n令\\(N=10^9\\)。将这些编码方式按照公共前缀，可以构成一棵二叉树，每一个叶节点代表着一种编码方式。那么，我们就使用贪心的思想，考虑找到一个当前花费（深度）\\(c\\)最小的叶节点，然后将其编码分别添加一个\\(0\\)和\\(1\\)，分别在这棵树上形成两个新的叶节点，花费分别为\\(c+1,c+4\\)。如下图所示。\r\n\r\n最朴素的做法是使用优先队列直接对叶节点进行扩展，但是由于编码数\\(N=10^9\\)太大，因此考虑批量扩展，每次将花费为\\(i\\)的所有节点扩展出来。\r\n考虑使用动态规划思想进行扩展。令状态\\(c(i)(i\\ge 0)\\)表示最大花费不超过\\(i\\)的情况下，最多的编码数。不难写出如下状态转移方程：\r\n\\[\r\nc(i)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i\\le 3  \\\\\r\n  &amp;c(i-1)+c(i-4) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n对于方程的最后一行，这种操作相当于将一棵深度为\\(i-1\\)的树，将其前面所有编码的前面都添加一个\\(0\\)，然后再将一棵深度为\\(i-4\\)的树，再在这些编码的前面都添加一个编码\\(1\\)，从而将这两棵树合并成一棵高度为\\(i\\)的树。由于原来的两棵树已经无法在保持高度的情况下再扩展新的叶节点，因此这棵新树也不能扩展新的叶节点。\r\n令状态\\(s(i)(i\\ge\r\n0)\\)表示高度为\\(i\\)的树，叶节点的个数已经扩展到了上限，也就是\\(c(i)\\)，这时的编码总花费数。那么不难写出如下状态转移方程：\r\n\\[\r\ns(i)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0  &amp; &amp; \\text{if}\\quad i\\le 3  \\\\\r\n  &amp;s(i-1)+s(i-4)+c(i-1)+4c(i-4) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n对于方程的最后一行，\\(s(i-1)+s(i-4)\\)则是原来两棵树的花费总和。现在要为深度为\\(i-1\\)的树的全部编码前面都添加一个\\(0\\)，增加了花费\\(c(i-1)\\)；并为深度为\\(i-4\\)的树的全部编码前面都添加一个\\(1\\)，增加了花费\\(4c(i-4)\\).\r\n令\\(m\\)为最大的数使得\\(c(m)\\le N\\)，那么对于一棵高度为\\(m\\)，已经有\\(c(m)\\)个节点的树，如果再扩展叶节点，那么树的高度必须要增加。此时我们还需要扩展\\(N-c(m)\\)次。那么考虑那些高度为\\(m-3\\)的叶节点，将它们扩展后就变成了两个深度为\\(m-2\\)和\\(m+1\\)的两个叶节点。而每扩展一次，花费就增加\\(m+1+1\\).\r\n因此，最终答案为\\(s(m)+(N-c(m))\\cdot(m+2)\\).\r\n代码\r\nN = 10 ** 9c = [1, 1, 1, 1]s = [0, 0, 0, 0]while 1:    w = c[-1] + c[-4]    v = s[-1] + s[-4] + c[-1] + 4 * c[-4]    if w &gt; N:        break    c.append(w)    s.append(v)ans = (N - c[-1]) * (len(c) + 1) + s[-1]print(ans)\r\n","categories":["Project Euler"],"tags":["动态规划","贪心"]},{"title":"Project Euler 220","url":"/project-euler/220/","content":"\r\nProject Euler 220\r\n题目\r\nHeighway Dragon\r\nLet \\(\\mathbf{D}_0\\) be the\r\ntwo-letter string “Fa”. For \\(n\\ge1\\),\r\nderive \\(\\mathbf{D}_n\\) from \\(\\mathbf{D}_{n-1}\\) by the string-rewriting\r\nrules:\r\n“a” → “aRbFR”“b” → “LFaLb”\r\nThus, \\(\\mathbf{D}_0\\) = “Fa”, \\(\\mathbf{D}_1\\) = “FaRbFR”, \\(\\mathbf{D}_2\\) = “FaRbFRRLFaLbFR”, and so\r\non.\r\nThese strings can be interpreted as instructions to a computer\r\ngraphics program, with “F” meaning “draw forward one unit”, “L” meaning\r\n“turn left \\(90\\) degrees”, “R” meaning\r\n“turn right \\(90\\) degrees”, and “a”\r\nand “b” being ignored. The initial position of the computer cursor is\r\n\\((0,0)\\), pointing up towards \\((0,1)\\).\r\nThen \\(\\mathbf{D}_n\\) is an exotic\r\ndrawing known as the Heighway Dragon of order \\(n\\). For example, \\(\\mathbf{D}_{10}\\) is shown below; counting\r\neach “F” as one step, the highlighted spot at \\((18,16)\\) is the position reached after\r\n\\(500\\) steps.\r\n\r\nWhat is the position of the cursor after \\(10^{12}\\) steps in \\(D_{50}\\) ?\r\nGive your answer in the form \\(x,y\\)\r\nwith no spaces.\r\n解决方案\r\n令\\(N=10^{12}\\)。并假设机器人第\\(i\\)步走到的点为\\((x_i,y_i)\\)。\r\n令\\(a_0=\\varnothing,b_0=\\varnothing\\)，那么可以写出\r\n\\(\\begin{aligned}\r\na_n&amp;\\rightarrow a_{n-1}Rb_{n-1}FR\\\\\r\nb_n&amp;\\rightarrow LFa_{n-1}Lb_{n-1}\\\\\r\nD_n&amp;\\rightarrow Fa_n\r\n\\end{aligned}\\)\r\n令\\(D_n&#39;\\rightarrow\r\nb_{n-1}F\\)，那么可以将\\(a_n,b_n\\)从这些规则中消去：\r\n\\(\\begin{aligned}\r\nD_n&amp;\\rightarrow Fa_n\\rightarrow Fa_{n-1}Rb_{n-1}FR\\rightarrow\r\nD_{n-1}RD_{n-1}&#39;R\\\\\r\nD_n&#39;&amp;\\rightarrow b_nF\\rightarrow LFa_{n-1}Lb_{n-1}F\\rightarrow\r\nLD_{n-1}LD_{n-1}&#39;\\\\\r\n\\end{aligned}\\)\r\n最终这些规则可以写成：\r\n\\(\\begin{aligned}\r\nD_0&amp;\\rightarrow F\\\\\r\nD_0&#39;&amp;\\rightarrow F\\\\\r\nD_n&amp;\\rightarrow D_{n-1}RD_{n-1}&#39;R\\\\\r\nD_n&#39;&amp;\\rightarrow LD_{n-1}LD_{n-1}&#39;\\\\\r\n\\end{aligned}\\)\r\n可以发现，\\(D_{n-1}\\)是\\(D_n\\)的前缀，那么实际上可以将\\(D\\)可以看成是一个无限字符串。并且，如果走完\\(D_n\\)或者是\\(D_n&#39;\\)中的所有步骤，那么就相当于已经行走了\\(2^n\\)步。\r\n考虑动态规划的思想，从原点开始，如果运行完\\(D_n\\)或者是\\(D_n&#39;\\)中所有的指令后，当前机器人所处的位置和旋转的角度，用一个三元组\\((x,y,d)\\)来表示。那么，就按照给定的规则，逐步递推到运行第\\(N\\)个\\(F\\)的地方。\r\n另外，在该页面中查询到了这种龙形曲线的一些信息：在第\\(m\\)次迭代前，龙形曲线的最后一段端点在\\((a_{m-1},b_{m-1})\\)处。那么，将整个龙形曲线逆时针旋转\\(90°\\)，原点\\((0,0)\\)的位置将被旋转到\\((a_m,b_m)\\)，旋转前和旋转后的曲线合并在一起就是第\\(n\\)轮的迭代结果。另外，\\((a_0,b_0)=(0,1)\\)。并且，可以发现\\((x_{2^m},y_{2^m})=(a_m.b_m)\\)\r\n这启发我们给出了寻找坐标点另一个更简单的算法：如果需要求第\\(n\\)次行走的结果，那么需要找到最小的整数\\(t\\)使得\\(2^t\\ge\r\nn\\)，那么第\\(n\\)步的结果就相当于是将第\\(2^t-n\\)步的点\\((x_{2^t-n},y_{2^t-n})\\)绕\\((x_{2^{t-1}},y_{2^{t-1}})\\)点逆时针旋转\\(90°\\)得到。这相当于将问题转化成了两个子问题：找出点\\((x_{2^{t-1}},y_{2^{t-1}})\\)点\\((x_{2^t-n},y_{2^t-n})\\)的坐标。逐步递归即可得到最终答案。\r\n代码\r\nN = 10 ** 12def f(now: tuple, *dir_list):    x, y, d = now    for dif in dir_list:        if d == 0:            x, y = x + dif[0], y + dif[1]        elif d == 1:            x, y = x - dif[1], y + dif[0]        elif d == 2:            x, y = x - dif[0], y - dif[1]        else:            x, y = x + dif[1], y - dif[0]        d = (d + dif[2]) % 4    return x, y, dl = len(bin(N)) - 2F, L, R = (0, 1, 0), (0, 0, 1), (0, 0, -1)Da = [F]Db = [F]for i in range(1, l + 1):    Da.append(f(Da[i - 1], R, Db[i - 1], R))    Db.append(f(L, Da[i - 1], L, Db[i - 1]))now = (0, 0, 0)flag = 0for i in range(l - 1, -1, -1):    if flag == 0:        if N &gt;&gt; i &amp; 1:            now = f(now, Da[i], R)            flag = 1        else:            flag = 0    else:        now = f(now, L)        if N &gt;&gt; i &amp; 1:            now = f(now, Da[i], L)            flag = 1        else:            flag = 0ans = &quot;,&quot;.join(str(x) for x in now[:2])print(ans)\r\nN = 10 ** 12mp = &#123;0: (0, 0), 1: (0, 1)&#125;def cal(c, p):    cx, cy = c    px, py = p    return cx - py + cy, cy + px - cxdef find(n):    if n in mp.keys():        return mp[n]    pw = 1    while pw &lt; n:        pw *= 2    mp[n] = cal(find(pw // 2), find(pw - n))    return mp[n]ans = &quot;,&quot;.join(str(x) for x in find(N))print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 221","url":"/project-euler/221/","content":"\r\nProject Euler 221\r\n题目\r\nAlexandrian Integers\r\nWe shall call a positive integer \\(A\\) an “Alexandrian integer”, if there\r\nexist integers \\(p, q, r\\) such\r\nthat:\r\n\\[A=p·q·r \\text{ and }\r\n\\frac{1}{A}=\\frac{1}{p}+\\frac{1}{q}+\\frac{1}{r}\\]\r\nFor example, \\(630\\) is an\r\nAlexandrian integer (\\(p = 5, q = -7, r =\r\n-18\\)).\r\nIn fact, \\(630\\) is the \\(6^{\\text{th}}\\) Alexandrian integer, the\r\nfirst \\(6\\) Alexandrian integers being:\r\n\\(6, 42, 120, 156, 420\\) and \\(630\\).\r\nFind the \\(150000^{\\text{th}}\\)\r\nAlexandrian integer.\r\n解决方案\r\n可以发现，\\(p,q,r\\)中必定有其中一个数是正数，其余两个数是负数，假设\\(p\\)是正数，\\(q,r\\)是负数。\r\n因此问题等价于如下形式：\r\n寻找\\(A=pqr\\)，其中\\(p,q,r&gt;0\\)，使得\\(\\dfrac{1}{A}=\\dfrac{1}{p}-\\dfrac{1}{q}-\\dfrac{1}{r}\\)\r\n消去\\(A\\)，不难得到\r\n\\[qr-pr-qp=1\\]\r\n两边都加一个\\(p^2\\)，那么可以写成\r\n\\[(p-q)(p-r)=p^2+1\\]\r\n那么，先枚举\\(p\\)，再枚举\\(p^2+1\\)的因子\\(d\\)，那么可以得到\\(p-q=d,p-r=\\dfrac{p^2+1}{d}\\)，最终得到题目中要求的一个数：\r\n\\[A=p(p+d)(p+\\dfrac{p^2+1}{d})\\]\r\n令\\(f(n)=n^2+1\\)，那么使用216题的分解方式对\\(f(n)\\)进行分解：如果\\(p\\mid f(n)\\)，那么\\(p\\mid f(kp\\pm n)\\)，其中\\(k&gt;0\\)。再根据分解产生其所有因子。\r\n本题\\(p\\)的上限难以确定，如果查询的值为\\(Q=150000\\)，那么就假设为\\(\\dfrac{2Q}{3}+100\\)。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int Q = 150000;const int M = Q*2/3+100;const ll MX = 1e18;ll f[M+4];unordered_map&lt;ll,int&gt;fact[M+4];int main()&#123;    for(int i=1;i&lt;=M;i++)        f[i]=1ll*i*i+1;    for(int i=1;i&lt;=M;i++)&#123;        ll p=f[i];        if(p==1) continue;        for(ll j=i;j&lt;=M;j+=p)            while(f[j]%p==0) f[j]/=p,++fact[j][p];        for(ll j=p-i;j&lt;=M;j+=p)            while(f[j]%p==0) f[j]/=p,++fact[j][p];    &#125;    vector&lt;ll&gt;a;    for(ll p=1; p &lt;= M; p++)&#123;        ll n= p*p+1;        vector&lt;ll&gt;divs&#123;1&#125;;        for(auto &amp;[pr,e]:fact[p])&#123;            int l=0,r=divs.size();            for(int _ = 0;_ &lt; e;_++)&#123;                for(int j=l;j&lt;r;j++)                    if(divs[j]*divs[j]*pr*pr&lt;=n)                        divs.push_back(divs[j]*pr);                l=r;r=divs.size();            &#125;        &#125;        for(ll d:divs)&#123;            if(p*(p+d)&gt;MX/(p+(p*p+1)/d)) continue;            a.push_back(p*(p+d)*(p+(p*p+1)/d));        &#125;    &#125;    sort(a.begin(),a.end());    ll ans=a[Q-1];    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 22","url":"/project-euler/22/","content":"\r\nProject Euler 22\r\n题目\r\nNames score\r\nUsing names.txt (right\r\nclick and ‘Save Link/Target As…’), a 46K text file containing over\r\nfive-thousand first names, begin by sorting it into alphabetical order.\r\nThen working out the alphabetical value for each name, multiply this\r\nvalue by its alphabetical position in the list to obtain a name\r\nscore.\r\nFor example, when the list is sorted into alphabetical order, COLIN,\r\nwhich is worth \\(3 + 15 + 12 + 9 + 14 =\r\n53\\), is the \\(938\\text{th}\\)\r\nname in the list. So, COLIN would obtain a score of \\(938 \\times 53 = 49714\\).\r\nWhat is the total of all the name scores in the file?\r\n解决方案\r\n将读入的字符串用一个列表存下。然后直接排序，直接计算相加得到结果。\r\n代码\r\nls = open(&#x27;p022_names.txt&#x27;, &#x27;r&#x27;).readlines()[0].split(&#x27;,&#x27;)ls.sort()ans = 0for i in range(len(ls)):    s = ls[i].replace(&quot;\\&quot;&quot;, &quot;&quot;)    val = 0    for ch in s:        val += ord(ch) - ord(&#x27;A&#x27;) + 1    ans += val * (i + 1)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 222","url":"/project-euler/222/","content":"\r\nProject Euler 222\r\n题目\r\nSphere Packing\r\nWhat is the length of the shortest pipe, of internal radius \\(50\\text{mm}\\), that can fully contain \\(21\\) balls of radii \\(30\\text{mm}, 31\\text{mm}, \\dots,\r\n50\\text{mm}\\)?\r\nGive your answer in micrometres (\\(10^{-6}\r\n\\text{ m}\\)) rounded to the nearest integer.\r\n解决方案\r\n由于每个球的直径都大于管内的半径，因此每一个球在管内最多和两个球相切。如图：\r\n\r\n那么，如果半径为\\(r_2\\)的球放在\\(r_1\\)的球上面，并且管内的直径为\\(d\\)，那么它们的球心的高度之差可以由下面的公式给出（根据勾股定理即可推出）：\r\n\\[g(r_1,r_2)=\\sqrt{(r_1+r_2)^2-(r_1+r_2-d)^2}\\]\r\n由于每个球放进去时，它只和最上面的球接触。这启发我们使用状态压缩动态规划解决这个问题。\r\n假设一共有\\(n\\)个球，第\\(i\\)个球的半径为\\(r_i\\)，用一个\\(n\\)比特数\\(b=b_{n-1}b_{n-2}\\dots\r\nb_0\\)表示球体的使用情况，那么令\\(f(i,j)(0\\le i&lt;2^n,0\\le j&lt;\r\nn,i_j=1)\\)表示当前使用的球的情况个数为\\(i\\)，放在最高的球为\\(j\\)时，当前最高的球的圆心最矮有多高，那么可以列出以下状态转移方程：\r\n\\[\r\nf(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;r_j  &amp; &amp; \\text{if}\\quad i=2^j \\\\\r\n  &amp;\\min_{0\\le k&lt;n,(i\\oplus 2^j)_{k}=1} f(i\\oplus\r\n2^k,k)+g(r_k,r_j) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n那么，最终答案需要对\\(f\\)加回最高的那个球的半径，为：\r\n\\[\\min_{i=0}^n f(2^n-1,i)+r_i\\]\r\n顺带一提的是，最终答案的堆砌方法打印出来是这个样子：\r\n\\[[49, 47, 45, 43, 41, 39, 37, 35, 33, 31,\r\n30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50]\\]\r\n这是一个很有规律的模式，不过我尚未有证明这个模式的能力。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int M=21;double D=50;double f[1&lt;&lt;M][M],g[M][M];int r[M];int main()&#123;    for(int i=0;i&lt;M;i++)        r[i]=30+i;    D*=2;    memset(f,0x4f,sizeof(f));    for(int i=0;i&lt;M;i++)        f[1&lt;&lt;i][i]=r[i];    for(int i=0;i&lt;M;i++)        for(int j=i+1;j&lt;M;j++)&#123;            double d0=r[i]+r[j],d1=r[j]+r[i]-D;            g[i][j]=g[j][i]=sqrt(d0*d0-d1*d1);        &#125;    for(int s=1;s&lt;(1&lt;&lt;M);s++)&#123;        for(int i=0;i&lt;M;i++)&#123;            for(int j=0;j&lt;M;j++)&#123;                if((s&gt;&gt;j&amp;1)==0)                    f[s|1&lt;&lt;j][j]=min(f[s|1&lt;&lt;j][j],f[s][i]+g[i][j]);            &#125;        &#125;    &#125;    double ans=1e10;    for(int i=0;i&lt;M;i++)        ans=min(ans,f[(1&lt;&lt;M)-1][i]+r[i]);    ans *= 1000;    printf(&quot;%.f\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 223","url":"/project-euler/223/","content":"\r\nProject Euler 223\r\n题目\r\nAlmost right-angled triangles\r\nI\r\nLet us call an integer sided triangle with sides \\(a \\le b \\le c\\) barely acute if\r\nthe sides satisfy \\(a^2 + b^2 = c^2 +\r\n1\\).\r\nHow many barely acute triangles are there with perimeter \\(\\le 25,000,000\\)?\r\n解决方案\r\n本原勾股数组树是一种数据结构，如果已知一个本原勾股数组\\(t=(a,b,c)^T\\)，那么可以通过以下方式产生三个不同的本原勾股数组：构造三个矩阵，分别为\r\n\\[{\\displaystyle {\\begin{array}{lcr}\r\nA={\\begin{bmatrix}1&amp;-2&amp;2\\\\2&amp;-1&amp;2\\\\2&amp;-2&amp;3\\end{bmatrix}}&amp;\r\nB={\\begin{bmatrix}1&amp;2&amp;2\\\\2&amp;1&amp;2\\\\2&amp;2&amp;3\\end{bmatrix}}&amp;\r\nC={\\begin{bmatrix}-1&amp;2&amp;2\\\\-2&amp;1&amp;2\\\\-2&amp;2&amp;3\\end{bmatrix}}\r\n\\end{array}}}\\]\r\n那么，\\(At,Bt,Ct\\)分别是产生的三个不同的本原勾股数组。产生的本原勾股数组可以继续使用该方法继续产生新的本原勾股数组，从而整个结构构成了一课三叉树。\r\n它同时还介绍了，如果树根是\\((3,4,5)^T\\)，那么产生的本原勾股数组是不重不漏的。\r\n经过验证，如果\\(a^2+b^2=c^2+1\\)，上面的矩阵仍然是可用的（也就是说，如果已知\\(a^2+b^2=c^2+1\\)，那么产生的新\\((a&#39;,b&#39;,c&#39;)\\)也满足\\(a&#39;^2+b&#39;^2=c&#39;^2+1\\)）。但是需要注意枚举过程中，\\(a\\)和\\(b\\)有可能是相等的，三个产生分支需要去掉其中一个。\r\n经过小范围枚举，一共有两棵树，树根为\\((1,1,1)\\)和\\((1,2,2)。\\)\r\n本代码采用的是广度优先搜索，避免递归深度太大导致栈溢出。\r\n该页面也介绍了本原勾股数组树的一部分内容，事实上，本代码实现采用的是这个页面中的矩阵。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N = 25000000;struct T&#123;    int a,b,c;&#125;;int main()&#123;    int ans=2;    queue&lt;T&gt;q;    q.push(T&#123;1,1,1&#125;);    q.push(T&#123;1,2,2&#125;);    while(!q.empty())&#123;        T t=q.front();q.pop();        int a=t.a,b=t.b,c=t.c;        int x=a-2*b+2*c,y=2*a-b+2*c,z=2*a-2*b+3*c;        if(x+y+z&lt;=N)&#123;            ++ans;q.push(T&#123;x,y,z&#125;);        &#125;        x=-a+2*b+2*c,y=-2*a+b+2*c,z=-2*a+2*b+3*c;        if(a!=b&amp;&amp;x+y+z&lt;=N)&#123;            ++ans;q.push(T&#123;x,y,z&#125;);        &#125;        x=2*a+b+2*c,y=a+2*b+2*c,z=2*a+2*b+3*c;        if(x+y+z&lt;=N)&#123;            ++ans;q.push(T&#123;x,y,z&#125;);        &#125;    &#125;    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 224","url":"/project-euler/224/","content":"\r\nProject Euler 224\r\n题目\r\nAlmost right-angled triangles\r\nII\r\nLet us call an integer sided triangle with sides \\(a \\le b \\le c\\) barely obtuse if\r\nthe sides satisfy \\(a^2 + b^2 = c^2 -\r\n1\\).\r\nHow many barely obtuse triangles are there with perimeter \\(\\le 75,000,000\\)?\r\n解决方案\r\n做法与223题完全一样，但是此时只有一棵树，并且树根为\\((2,2,3)^T\\)。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N = 75000000;struct T&#123;    int a,b,c;&#125;;int main()&#123;    int ans=1;    queue&lt;T&gt;q;    q.push(T&#123;2,2,3&#125;);    while(!q.empty())&#123;        T t=q.front();q.pop();        int a=t.a,b=t.b,c=t.c;        int x=a-2*b+2*c,y=2*a-b+2*c,z=2*a-2*b+3*c;        if(x+y+z&lt;=N)&#123;            ++ans;q.push(T&#123;x,y,z&#125;);        &#125;        x=-a+2*b+2*c,y=-2*a+b+2*c,z=-2*a+2*b+3*c;        if(a!=b&amp;&amp;x+y+z&lt;=N)&#123;            ++ans;q.push(T&#123;x,y,z&#125;);        &#125;        x=2*a+b+2*c,y=a+2*b+2*c,z=2*a+2*b+3*c;        if(x+y+z&lt;=N)&#123;            ++ans;q.push(T&#123;x,y,z&#125;);        &#125;    &#125;    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 225","url":"/project-euler/225/","content":"\r\nProject Euler 225\r\n题目\r\nTribonacci non-divisors\r\nThe sequence \\(1, 1, 1, 3, 5, 9, 17, 31,\r\n57, 105, 193, 355, 653, 1201 \\dots\\) is defined by \\(T_1 = T_2 = T_3 = 1\\) and \\(T_n = T_n-1 + T_n-2 + T_n-3\\).\r\nIt can be shown that \\(27\\) does not\r\ndivide any terms of this sequence.\r\nIn fact, \\(27\\) is the first odd\r\nnumber with this property.\r\nFind the \\(124^{\\text{th}}\\) odd\r\nnumber that does not divide any terms of the above sequence.\r\n解决方案\r\n模\\(p\\)下的广义斐波那契序列必定是一个周期性序列。因为它的下一个数都是由最近的\\(m\\)个数（这里为\\(m=3\\)）相加决定的，这些数最多只有\\(p^m\\)种不同的可能性。也就是说，决定下一个数是多少的状态是有限的。最终无限的序列必定会呈现一个周期性。\r\n因此，利用这种性质，可以寻找序列的模\\(p\\)周期，从而判断出这个奇数是否不能将原序列中任何一个数相除。\r\n代码\r\nfrom itertools import countQ = 124cnt = 0for m in count(27, 2):    ok = 1    a = b = c = 1    while True:        a, b, c = b, c, (a + b + c) % m        if c == 0:            ok = 0            break        if a == b == c == 1:            break    if ok:        cnt += 1        if cnt == Q:            ans = m            breakprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 226","url":"/project-euler/226/","content":"\r\nProject Euler 226\r\n题目\r\nA Scoop of Blancmange\r\nThe blancmange curve is the set of points \\((x, y)\\) such that \\(0 \\le x \\le 1\\) and \\(y = \\sum \\limits_{n = 0}^{\\infty} {\\dfrac{s(2^n\r\nx)}{2^n}}\\), where \\(s(x)\\) is\r\nthe distance from \\(x\\) to the nearest\r\ninteger.\r\nThe area under the blancmange curve is equal to \\(\\dfrac{1}{2}\\), shown in pink in the\r\ndiagram below.\r\n\r\nLet \\(C\\) be the circle with centre\r\n\\((\\dfrac{1}{4},\\dfrac{1}{2})\\) and\r\nradius \\(\\dfrac{1}{4}\\), shown in black\r\nin the diagram.\r\nWhat area under the blancmange curve is enclosed by \\(C\\)?\r\nGive your answer rounded to eight decimal places in the form \\(0.abcdefgh\\)\r\n解决方案\r\n该页面给出了求解牛奶冻曲线积分的递推公式。如果\\(f(x)=\\sum \\limits_{n = 0}^{\\infty} {\\dfrac{s(2^n\r\nx)}{2^n}}\\)，那么有\\(I(x)\\)：\r\n\\[I(x)=\\int_{0}^x f(x)dx=\r\n\\left \\{\\begin{aligned}\r\n  &amp;\\dfrac{I(2x)}{4}+\\dfrac{x^2}{2}  &amp; &amp; \\text{if}\\quad 0\\le\r\nx\\le \\dfrac{1}{2} \\\\\r\n  &amp;\\dfrac{1}{2}-I(1-x)  &amp; &amp; \\text{if}\\quad \\dfrac{1}{2}\\le\r\nx\\le 1 \\\\\r\n  &amp;\\dfrac{n}{2}+I(x-n)  &amp; &amp; \\text{if}\\quad n\\le x\\le(n+1) \\\\\r\n\\end{aligned}\\right.\r\n\\]\r\n为方便计算，我们假设圆\\(C\\)和曲线中只有两个交点，其中右交点在\\(B(0.5,f(0.5))\\)，左交点通过二分法来求出，假设为为\\(A(a,f(a))\\)。\r\n接下来使用该页面的一些公式计算了弓形\\(\\mathop{AB}\\limits^{\\frown}\\)的面积，从而计算出弧\\(\\mathop{AB}\\limits^{\\frown}\\)竖直向下的那一块面积\\(S\\)，也就是说，\r\n\\[S=\\int_a^{\\frac{1}{2}} \\frac{1}{2} -\r\n\\sqrt{\\frac{1}{4}^2 - \\left(x - \\frac{1}{2}\\right)^2}dx\\]\r\n最终答案为\\(I(\\dfrac{1}{2})-I(a)-S\\)。\r\n代码\r\nfrom math import asin, sinf = lambda x: sum(abs(x * (1 &lt;&lt; n) - round(x * (1 &lt;&lt; n))) / (1 &lt;&lt; n) for n in range(60))g = lambda x: 0.5 - (x / 2 - x * x) ** 0.5def I(x):    if x &lt; 1e-13:        return 0    if x &lt;= 0.5:        return I(2 * x) / 4 + x * x / 2    else:        return 0.5 - I(1 - x)l, r = 0, 0.5for _ in range(100):    mid = (l + r) * 0.5    if f(mid) &gt; g(mid):        r = mid    else:        l = midxl, xr = l, 0.5yl, yr = g(xl), g(xr)cr = 1 / 4d = ((xl - xr) ** 2 + (yl - yr) ** 2) ** 0.5theta = 2 * asin(d / (2 * cr))arc_area = cr * cr / 2 * (theta - sin(theta))circle_integral = (yl + yr) * (xr - xl) / 2 - arc_areaans = I(xr) - I(xl) - circle_integralprint(&quot;&#123;:.8f&#125;&quot;.format(ans))\r\n","categories":["Project Euler"]},{"title":"Project Euler 227","url":"/project-euler/227/","content":"\r\nProject Euler 227\r\n题目\r\nThe Chase\r\nThe Chase is a game played with two dice and an even number\r\nof players.\r\nThe players sit around a table; the game begins with two opposite\r\nplayers having one die each. On each turn, the two players with a die\r\nroll it.\r\nIf a player rolls a \\(1\\), he passes\r\nthe die to his neighbour on the left; if he rolls a \\(6\\), he passes the die to his neighbour on\r\nthe right; otherwise, he keeps the die for the next turn.\r\nThe game ends when one player has both dice after they have been\r\nrolled and passed; that player has then lost.\r\nIn a game with \\(100\\) players, what\r\nis the expected number of turns the game lasts?\r\nGive your answer rounded to ten significant digits.\r\n解决方案\r\n令\\(N=100\\)，注意\\(N\\)必须是偶数，并令\\(M=\\dfrac{N}{2}\\)。不难发现，当前游戏的状态并不取决于是哪两个人拿着骰子，而只取决于拿着骰子的两个人的距离（注意这个距离是指比较短的那段距离，也就是两个人在圆上的劣弧长度）。\r\n那么，令\\(d_N(x)=\\min(x\\%N,(-x)\\%N)\\)，其中\\(x\\)是两人在优弧或者劣弧上的距离，\\(d_N(x)\\)用于求出两人在劣弧上的距离。\r\n根据题意，两人同时抛骰子，那么两个人距离的变化值的分布律可以写出：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\\(d\\)\r\n\\(-2\\)\r\n\\(-1\\)\r\n\\(0\\)\r\n\\(1\\)\r\n\\(2\\)\r\n\r\n\r\n\r\n\r\n\\(p(d)\\)\r\n\\(\\dfrac{1}{36}\\)\r\n\\(\\dfrac{2}{9}\\)\r\n\\(\\dfrac{1}{2}\\)\r\n\\(\\dfrac{2}{9}\\)\r\n\\(\\dfrac{1}{36}\\)\r\n\r\n\r\n\r\n那么，令状态\\(f(i)(0\\le i\\le\r\nM)\\)表示从游戏一开始后，两个骰子之间的距离第一次达到\\(i\\)的期望游戏轮数。对于\\(\\forall i,0\\le i&lt; M\\)，可以写出：\r\n\\[f(i)=1+\\sum_{d=-2}^2f(d_N(i+d))\\cdot\r\np(d)\\qquad(1)\\]\r\n由于游戏的初始状态是\\(M\\)，因此\\(f(M)=0\\)。\r\n这是一个有后效性的动态规划方程，因为状态之间形成了循环的依赖（状态\\(i\\)依赖于自身）。不过，这种情况下消除后效性很简单。右边有一个项也是\\(f(i)\\)，只需要挪到左边消除就可以完成消除后效性，从而正确计算结果。\r\n那么，将\\(f\\)中的每一个值全部当成是未知数，那么方程\\((1)\\)和\\(f(M)=0\\)构成了一个\\(M+1\\)元的线性方程组，解这个方程组即可，最终\\(f(0)\\)即为答案。\r\n代码\r\nimport numpy as npN = 100con = [1, 8, -18, 8, 1]M = N &gt;&gt; 1b = [-36] * M + [0]a = []for i in range(M):    t = [0 for _ in range(M + 1)]    for j in range(5):        x = i + j - 2        t[min(x % N, -x % N)] += con[j]    a.append(t)a.append([0] * M + [1])x = np.linalg.solve(a, b)ans = x[0]print(&quot;&#123;:.6f&#125;&quot;.format(ans))\r\n","categories":["Project Euler"],"tags":["动态规划","概率"]},{"title":"Project Euler 23","url":"/project-euler/23/","content":"\r\nProject Euler 23\r\n题目\r\nNon-abundant sums\r\nA perfect number is a number for which the sum of its proper divisors\r\nis exactly equal to the number. For example, the sum of the proper\r\ndivisors of \\(28\\) would be \\(1 + 2 + 4 + 7 + 14 = 28\\), which means that\r\n\\(28\\) is a perfect number.\r\nA number \\(n\\) is called deficient\r\nif the sum of its proper divisors is less than \\(n\\) and it is called abundant if this sum\r\nexceeds \\(n\\).\r\nAs \\(12\\) is the smallest abundant\r\nnumber, \\(1 + 2 + 3 + 4 + 6 = 16\\), the\r\nsmallest number that can be written as the sum of two abundant numbers\r\nis \\(24\\). By mathematical analysis, it\r\ncan be shown that all integers greater than \\(28123\\) can be written as the sum of two\r\nabundant numbers. However, this upper limit cannot be reduced any\r\nfurther by analysis even though it is known that the greatest number\r\nthat cannot be expressed as the sum of two abundant numbers is less than\r\nthis limit.\r\nFind the sum of all the positive integers which cannot be written as\r\nthe sum of two abundant numbers.\r\n解决方案\r\n范围比较小，可以将所有的盈数处理出来，这里直接通过计算真因子和从而计算出来（也可以使用欧拉筛）。\r\n枚举所有的盈数之和，并放进集合存储。\r\n代码\r\nfrom tools import divisors_sigmaN = 28123a = []for i in range(1, N + 1):    w = divisors_sigma(i)    if w - i &gt; i:        a.append(i)st = set()for i in range(len(a)):    for j in range(i, len(a)):        if a[i] + a[j] &gt; N:            break        st.add(a[i] + a[j])ans = N * (N + 1) // 2 - sum(st)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 230","url":"/project-euler/230/","content":"\r\nProject Euler 230\r\n题目\r\nFibonacci Words\r\nFor any two strings of digits, \\(A\\)\r\nand \\(B\\), we define \\(F_{A,B}\\) to be the sequence \\((A,B,AB,BAB,ABBAB,\\dots)\\) in which each\r\nterm is the concatenation of the previous two.\r\nFurther, we define \\(D_{A,B}(n)\\) to\r\nbe the \\(n^{\\text{th}}\\) digit in the\r\nfirst term of \\(F_{A,B}\\) that contains\r\nat least \\(n\\) digits. Example:\r\nLet \\(A=1415926535, B=8979323846\\).\r\nWe wish to find \\(D_{A,B}(35)\\),\r\nsay.\r\nThe first few terms of \\(F_{A,B}\\)\r\nare:\r\n\\(\\begin{aligned}\r\n&amp;1415926535\\\\\r\n&amp;8979323846\\\\\r\n&amp;14159265358979323846\\\\\r\n&amp;897932384614159265358979323846\\\\\r\n&amp;1415926535897932384689793238461415{\\color{red}9}265358979323846\r\n\\end{aligned}\\)\r\nThen \\(D_{A,B}(35)\\) is the \\(35^{\\text{th}}\\) digit in the fifth term,\r\nwhich is \\(9\\).\r\nNow we use for \\(A\\) the first \\(100\\) digits of \\(\\pi\\) behind the decimal point:\r\n1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\r\nand for B the next hundred digits:\r\n8214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196\r\n.\r\nFind \\(\\sum_{n = 0,1,\\dots,17}  10^n\\times\r\nD_{A,B}((127+19n)\\times7^n)\\).\r\n解决方案\r\n这题不需要真正地计算出这些字符串数组\\(F_{A,B}\\)的具体内容，只需要通过递推式计算出\\(F_{A,B}\\)中每个字符串的长度。\r\n假设\\(F_{A,B}[i][j]\\)为序列\\(F_{A,B}\\)的第\\(i\\)个字符串的第\\(j\\)个字符。由于\\(F_{A,B}[i]\\)是由\\(F_{A,B}[i-2]\\)和\\(F_{A,B}[i-1]\\)拼接而成。因此只需通过长度判断，就可以通过下标定位到前面两个字符串。如果需要查询的下标\\(k\\)落在\\(F_{A,B}[i-2]\\)中，那么转而在字符串\\(F_{A,B}[i-2]\\)继续查找，否则在\\(F_{A,B}[i-1]\\)中继续查找。如此迭代，直到回到初始字符串\\(A,B\\)，即可得到答案。\r\n代码\r\nN = 17A = &quot;1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679&quot;B = &quot;8214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196&quot;M = 100len_F = [len(A), len(B)]for i in range(M):    len_F.append(len_F[-2] + len_F[-1])def get_digit(f: int, pos: int):    if f == 0:        return A[pos - 1]    elif f == 1:        return B[pos - 1]    else:        if pos &lt;= len_F[f - 2]:            return get_digit(f - 2, pos)        else:            return get_digit(f - 1, pos - len_F[f - 2])ans = 0for n in range(N + 1):    p = (127 + 19 * n) * (7 ** n)    for i in range(M):        if len_F[i] &gt;= p:            ans += int(get_digit(i, p)) * 10 ** n            breakprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 229","url":"/project-euler/229/","content":"\r\nProject Euler 229\r\n题目\r\nFour Representations using\r\nSquares\r\nConsider the number \\(3600\\). It is\r\nvery special, because\r\n\\[\\begin{aligned}\r\n3600 &amp;= 48^2 + 36^2 \\\\\r\n3600 &amp;= 20^2 + 2\\times40^2 \\\\\r\n3600 &amp;= 30^2 + 3\\times30^2 \\\\\r\n3600 &amp;= 45^2 + 7\\times15^2 \\\\\r\n\\end{aligned}\\]\r\nSimilarly, we find that \\(88201 = 99^2 +\r\n280^2 = 287^2 + 2\\times54^2 = 283^2 + 3\\times52^2 = 197^2 +\r\n7\\times84^2\\).\r\nIn 1747, Euler proved which numbers are representable as a sum of two\r\nsquares.\r\nWe are interested in the numbers n which admit representations of all\r\nof the following four types:\r\n\\[\\begin{aligned}\r\nn &amp;= a_1^2 + b_1^2\\\\\r\nn &amp;= a_2^2 + 2 b_2^2\\\\\r\nn &amp;= a_3^2 + 3 b_3^2\\\\\r\nn &amp;= a_7^2 + 7 b_7^2,\\\\\r\n\\end{aligned}\\]\r\nwhere the \\(a_k\\) and \\(b_k\\) are positive integers.\r\nThere are \\(75373\\) such numbers\r\nthat do not exceed \\(10^7\\).\r\nHow many such numbers are there that do not exceed \\(2\\times10^9\\)?\r\n解决方案\r\n为了节省空间，每次对\\(1\\sim\r\nN\\)中连续分块的\\(M\\)个数暴力筛选。\r\n因此，在枚举\\(a_k^2+kb^2_k\\)的过程中，需要有四个临时数组\\(l_k\\)来存储表示\\(b\\)枚举到哪里了。\r\n同时，\\(M\\)的值必须比较大（如\\(N^{0.7}+1000\\)），不然筛选的过程会发生错误。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;const int N=2000000000;const int M= pow(N,0.7)+1000;const int SQN=sqrt(N);int l1[SQN+2],l2[SQN+2],l3[SQN+2],l7[SQN+2];unsigned char used[M];int main()&#123;    printf(&quot;%d\\n&quot;,M);    for(int i=1;i&lt;=SQN;i++)        l1[i]=l2[i]=l3[i]=l7[i]=1;    int ans=0;    for(int l=0,w,b;l&lt;=N;l+=M) &#123;        int r = min(l + M, N + 1);        for (int a = 1; a * a + l1[a] * l1[a] &lt; r; a++) &#123;            for (b = l1[a]; (w = a * a + b * b) &lt; r; b++)                used[w - l] |= 1;            l1[a] = b;        &#125;        for (int a = 1; a * a + l2[a] * l2[a] * 2 &lt; r; a++) &#123;            for (b = l2[a]; (w = a * a + b * b * 2) &lt; r; b++)                used[w - l] |= 2;            l2[a] = b;        &#125;        for (int a = 1; a * a + l3[a] * l3[a] * 3 &lt; r; a++) &#123;            for (b = l3[a]; (w = a * a + b * b * 3) &lt; r; b++)                used[w - l] |= 4;            l3[a] = b;        &#125;        for (int a = 1; a * a + l7[a] * l7[a] * 7 &lt; r; a++) &#123;            for (b = l7[a]; (w = a * a + b * b * 7) &lt; r; b++)                used[w - l] |= 8;            l7[a] = b;        &#125;        for (int i = l; i &lt; r; i++) &#123;            if (used[i - l] == 15) ++ans;            used[i - l] = 0;        &#125;    &#125;    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 231","url":"/project-euler/231/","content":"\r\nProject Euler 231\r\n题目\r\nThe prime\r\nfactorisation of binomial coefficients\r\nThe binomial coefficient \\(\\displaystyle\r\n\\binom {10} 3 = 120\\).\r\n\\(120 = 2^3 \\times 3 \\times 5 = 2 \\times 2\r\n\\times 2 \\times 3 \\times 5\\), and \\(2 +\r\n2 + 2 + 3 + 5 = 14\\).\r\nSo the sum of the terms in the prime factorisation of \\(\\displaystyle \\binom {10} 3\\) is \\(14\\).\r\nFind the sum of the terms in the prime factorisation of \\(\\displaystyle \\binom {20\\,000\\,000}\r\n{15\\,000\\,000}\\).\r\n解决方案\r\n组合数\\(\\dbinom{n}{m}\\)的定义为\\(\\dfrac{n!}{(n-m)!m!}\\)。因此，求一个质因数\\(p\\)在组合数的次数，本质上是求在阶乘中出现的次数。\r\n设\\(f(n, p)\\)是质因子\\(p\\)在\\(n!\\)中的次数，那么\\(f(n,p)=\\left\\lfloor\\dfrac{n}{p}\\right\\rfloor+\\left\\lfloor\\dfrac{n}{p^2}\\right\\rfloor+\\left\\lfloor\\dfrac{n}{p^3}\\right\\rfloor+\\dots\\)，每一项分别表示\\(1\\sim n\\)中有多少个数是\\(p,p^2,p^3\\dots\\)的倍数。\r\n因此根据组合数的定义式，\\(\\dbinom{n}{m}\\)的质因子\\(p\\)出现的次数为\\(f(n,p)-f(m,p)-f(n-m,p)\\)。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=20000000,M=15000000;int v[N+4],pr[N/10],m=0;ll f(ll n,ll p)&#123;    ll ans=0;    for(;n;n/=p)        ans+=n/p;    return ans;&#125;int main()&#123;    for(int i=2;i&lt;=N;i++)&#123;        if(v[i]==0)&#123;            v[i]=i;pr[++m]=i;        &#125;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;N/i) break;            v[i*pr[j]]=pr[j];        &#125;    &#125;    ll ans=0;    for(int i=1;i&lt;=m;i++)&#123;        int p=pr[i];        ans+=(f(N,p)-f(M,p)-f(N-M,p))*p;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 228","url":"/project-euler/228/","content":"\r\nProject Euler 228\r\n题目\r\nMinkowski Sums\r\nLet \\(S_n\\) be the regular \\(n\\)-sided polygon – or shape –\r\nwhose vertices \\(v_k (k=1,2,\\dots,n)\\)\r\nhave coordinates:\r\n\\[x_k= \\cos\\left(\\dfrac{2k-1}{n} \\times\r\n180°\\right)\\quad y_k= \\sin\\left(\\dfrac{2k-1}{n} \\times\r\n180°\\right)\\]\r\nEach \\(S_n\\) is to be interpreted as\r\na filled shape consisting of all points on the perimeter and in the\r\ninterior.\r\nThe Minkowski sum, \\(S+T\\),\r\nof two shapes \\(S\\) and \\(T\\) is the result of adding every point in\r\n\\(S\\) to every point in \\(T\\), where point addition is performed\r\ncoordinate-wise: \\((u,v) + (x,y) =\r\n(u+x,v+y)\\).\r\nFor example, the sum of \\(S_3\\) and\r\n\\(S_4\\) is the six-sided shape shown in\r\npink below:\r\n\r\nHow many sides does \\(S_{1864}+S_{1865}+\\dots+S_{1909}\\)\r\nhave?\r\n解决方案\r\n这个页面描述了求两个凸包\\(P,Q\\)的闵可夫斯基和的方法：\r\n\r\n分别逆时针沿着两个正\\(n\\)多边形\\(P,Q\\)的边界行走，枚举出\\(n\\)个边界的向量（如下图所示）。\r\n将这些向量按照极角进行排序。\r\n按顺序将这些向量首尾拼接，那么拼接出来的必定是一个封闭图形。这个图形就是\\(P,Q\\)的闵可夫斯基和。\r\n\r\n回到题目中，在求闵可夫斯基和的第三个步骤中，如果两个向量的极角相同，那么说明构造出来的新凸包中，这两个向量构造的边界实际上是同一条。\r\n因此，问题就转化为了这些边界中，总共有多少个向量是极角不同的。\r\n以\\(y\\)轴正半轴为基准，那么不难发现，正\\(n\\)变形的边界的极角分别是\\(0,\\dfrac{1}{n}\\cdot 2\\pi,\\dfrac{2}{n}\\cdot\r\n2\\pi,\\dots,\\dfrac{n-1}{n}\\cdot 2\\pi\\)。\r\n那么问题进一步转化成：分母在范围\\(1864\\sim\r\n1909\\)的真分数中，一共有多少个不同值的分数（包括\\(0\\)）？\r\n代码\r\nfrom fractions import FractionL, R = 1864, 1909ans = len(set(Fraction(i, j) for j in range(L, R + 1) for i in range(j)))print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 232","url":"/project-euler/232/","content":"\r\nProject Euler 232\r\n题目\r\nThe Race\r\nTwo players share an unbiased coin and take it in turns to play\r\nThe Race.\r\nOn Player \\(1\\)’s turn, the coin is\r\ntossed once. If it comes up Heads, then Player \\(1\\) scores one point; if it comes up Tails,\r\nthen no points are scored.\r\nOn Player \\(2\\)’s turn, a positive\r\ninteger, \\(T\\), is chosen by Player\r\n\\(2\\) and the coin is tossed \\(T\\) times. If it comes up all Heads, then\r\nPlayer \\(2\\) scores \\(2^{T-1}\\) points; otherwise, no points are\r\nscored.\r\nPlayer \\(1\\) goes first and the\r\nwinner is the first to \\(100\\) or more\r\npoints.\r\nPlayer \\(2\\) will always selects the\r\nnumber, \\(T\\), of coin tosses that\r\nmaximises the probability of winning.\r\nWhat is the probability that Player \\(2\\) wins?\r\nGive your answer rounded to eight decimal places in the form \\(0.abcdefgh\\).\r\n解决方案\r\n不难想到可以使用动态规划的思想解决。\r\n令\\(N=100\\)。令状态\\(f(i,j)(0\\le i,j\\le\r\nN)\\)表示当前是玩家\\(\\mathbf{2}\\)的回合，玩家\\(1\\)仍需要获得\\(i\\)分，玩家\\(2\\)仍需要获得\\(j\\)分的情况下，玩家\\(2\\)的胜率。\r\n假设\\(w_1=0.5,l_1=0.5\\)分别是玩家\\(1\\)单个回合的成功率和失败率，\\(w_2(T)=2^{T},l_2(T)=1-2^{T}\\)对玩家\\(2\\)同理。令\\(g(j,T)=\\max(j-2^{T-1},0)\\)，那么对\\(f(i,j)\\)的其中一个决策\\(T\\)可以写出如下方程：\r\n\\(\\begin{aligned}\r\nf(i,j)=&amp;w_1\\cdot w_2(T)\\cdot f(i-1,g(j,T))+l_1\\cdot w_2(T)\\cdot\r\nf(i,g(j,T))+\\\\\r\n&amp;w_1\\cdot l_2(T)\\cdot f(i-1,j) + l_1\\cdot l_2(T)\\cdot f(i,j)\r\n\\end{aligned}\\)\r\n这个方程表示玩家\\(2\\)先玩，接下来玩家\\(1\\)玩，两人分别成功和失败的组合，一共有四对。\r\n这是一个有后效性的动态规划方程，因为状态之间形成了循环的依赖（状态\\((i,j)\\)依赖于自身）。不过，这种情况下消除后效性很简单。右边有一个项也是\\(f(i,j)\\)，只需要挪到左边消除就可以完成消除后效性，从而正确计算结果。\r\n因此，可以正式地写出\\(f(i,j)\\)的状态转移方程：\r\n\\[\r\nf(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1 &amp; &amp; \\text{if}\\quad j=0 \\\\\r\n  &amp;0 &amp; &amp; \\text{else if}\\quad i=0 \\\\\r\n  &amp;\\max_{2^{T-2}\\le j}\\{\\dfrac{w_1\\cdot w_2(T)\\cdot\r\nf(i-1,g(j,T))+l_1\\cdot w_2(T)\\cdot f(i,g(j,T))+w_1\\cdot l_2(T)\\cdot\r\nf(i-1,j)}{1-l_1\\cdot l_2(T)}\\} &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n需要注意的是，\\((0,0)\\)本身不是一个合法的状态，但是为了方便计算故列出。因为玩家\\(2\\)在他自己的回合已经胜出游戏，因此\\(f(0,0)=1\\)。\r\n由于这个游戏是一开始是玩家\\(1\\)的回合，玩家\\(2\\)的胜率是以玩家\\(1\\)的回合结束作为条件的。因此玩家\\(2\\)在整场游戏的胜率为\\(w_1\\cdot f(N-1,N)+l_1\\cdot f(N,N)\\).\r\n代码\r\nN = 100w1 = l1 = 0.5f = [[0 for _ in range(N + 1)] for _ in range(N + 1)]for i in range(N + 1):    for j in range(N + 1):        if j == 0:            f[i][j] = 1        elif i == 0:            f[i][j] = 0        else:            pw = 1            while True:                w2 = 0.5 / pw                l2 = 1.0 - w2                t = max(j - pw, 0)                nw = w1 * w2 * f[i - 1][t] + l1 * w2 * f[i][t] + w1 * l2 * f[i - 1][j]                nw /= 1 - l1 * l2                f[i][j] = max(f[i][j], nw)                if t == 0:                    break                pw &lt;&lt;= 1ans = l1 * f[N][N] + w1 * f[N - 1][N]print(&quot;&#123;:.8f&#125;&quot;.format(ans))\r\n","categories":["Project Euler"],"tags":["动态规划","概率"]},{"title":"Project Euler 233","url":"/project-euler/233/","content":"\r\nProject Euler 233\r\n题目\r\nLattice points on a circle\r\nLet \\(f(N)\\) be the number of points\r\nwith integer coordinates that are on a circle passing through \\((0,0), (N,0),(0,N),\\) and \\((N,N)\\).\r\nIt can be shown that \\(f(10000)=36\\).\r\nWhat is the sum of all positive integers \\(N\\le10^{11}\\) such that \\(f(N)=420\\)?\r\n解决方案\r\n可以写出这个圆的标准方程：\r\n\\[(x-\\dfrac{N}{2})^2+(y-\\dfrac{N}{2})^2=\\dfrac{N^2}{2}\\]\r\n\\[(2x-N)^2+(2y-N)^2=2N^2\\]\r\n令\\(a=2x-N,b=2y-N\\)，那么转而寻求以下方程的解：\r\n\\[a^2+b^2=2N^2\\]\r\n不难发现，\\(a,b\\)的奇偶性一定相同。并且，\\(a,b\\)的奇偶性必须和\\(N\\)都相同，因为\\(x=\\dfrac{a+N}{2},y=\\dfrac{b+N}{2}\\)。只有如此，\\(x,y\\)才是整数。\r\n不过，可以证明，\\(a^2+b^2=2N^2\\)的解\\((a,b)\\)奇偶性一定和\\(N\\)相同，上面的问题不需要考虑。用反证法，假设\\(a,b\\)的奇偶性和\\(N\\)不同，得出方程两边的数奇偶性不同即可。\r\n那么，剩下的问题就只需要考虑这个方程的解的个数即可：\r\n\\[x^2+y^2=2N^2\\]\r\n页面1，页面2给出了一个信息：如果\\(n\\)可以将其分解成\\(n=2^g\\prod_{i=1}^k p_i^{e_i}\\prod_{j=1}^l\r\nq_j^{f_j}\\)，其中\\(p_i\\)是模\\(4\\)余\\(1\\)的质数，\\(q_j\\)是模\\(4\\)余\\(3\\)的质数。那么方程\\(x^2+y^2=n\\)的解的个数由\\(r_2(n)\\)决定：\r\n\\[r_2(n)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0  &amp; &amp; \\text{if}\\quad \\exists j,f_j\\equiv 1 \\pmod 2 \\\\\r\n  &amp;4\\prod_i(e_i+1) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n回到题目中，那么\\(f(n)\\)可以如下计算：\r\n\\[f(n)=r_2(2n^2)=4\\prod_{i=1}^k(2e_i+1)\\]\r\n由于\\(420=4\\cdot3\\cdot 5\\cdot\r\n7\\)，因此，题目所求的\\(n\\)有如下\\(5\\)种形式：\r\n\\[\\begin{aligned}\r\n&amp;Q\\cdot P_1\\cdot P_2^2\\cdot P_3^3\\\\\r\n&amp;Q\\cdot P_1\\cdot P_2^{17}\\\\\r\n&amp;Q\\cdot P_1^2\\cdot P_2^{10} \\\\\r\n&amp;Q\\cdot P_1^{3}\\cdot P_2^{7}\\\\\r\n&amp;Q\\cdot P_1^{57}\r\n\\end{aligned}\\]\r\n其中，\\(Q\\)是质数\\(2\\)和模\\(4\\)余\\(3\\)的质数组合成的数，\\(P_i\\)是模\\(4\\)余\\(1\\)的质数。第二种和第五种情况指数太大，故不考虑。\r\n令\\(M=10^{11}\\)，那么\\(Q\\le \\dfrac{M}{5^3\\cdot13^2\\cdot 17},P_i\\le\r\n\\dfrac{M}{5^2\\cdot13^2}\\)（均由第一种形式推出。）\r\n因此，先枚举\\(Q\\)的部分，再枚举\\(P=\\prod_JP_j^{E_J}\\)的部分，最终所有\\(PQ\\le M\\)的值就是答案。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const ll N=1e11;const ll MXQ = N/(5*5*5*13*13*17);const ll MXP = N/(5*5*5*13*13);ll s[MXQ+4];bool vis[MXP+4];int pr[MXP / 5 + 1000],m=0;int main()&#123;    s[1]=1;    for(int i=2;i&lt;=MXP;i++)&#123;        if(vis[i]) continue;        for(ll j=1ll*i*i;j&lt;=MXP;j+=i)&#123;            vis[j]=1;        &#125;        if(i%4==1) pr[++m]=i;        else&#123;            for(ll j=1;j&lt;=MXQ/i;j++)                if(s[j]) s[j*i]=1;        &#125;    &#125;    for(int i=1;i&lt;=MXQ;i++)        s[i]=s[i-1]+(s[i]?i:0);    ll u,v,w;    ll ans=0;    // 1    for(int i=1;i&lt;=m&amp;&amp;(u=pr[i]*pr[i]*pr[i])&lt;=N/(5*5*13);i++) &#123;        for(int j=1;j&lt;=m&amp;&amp;(v=u*pr[j]*pr[j])&lt;=N;j++)            if(i!=j)                for(int k=1;k&lt;=m&amp;&amp;(w=v*pr[k])&lt;=N;k++)                    if(i!=k&amp;&amp;j!=k) ans+=w*s[N/w];    &#125;    // 3    for(int i=1;i&lt;=m&amp;&amp; (u=pow(pr[i], 10)) &lt;= N; i++)&#123;        for(int j=1;j&lt;=m&amp;&amp; (v= u * pr[j] * pr[j]) &lt;= N; j++)            if(i!=j) ans+=v*s[N/v];        &#125;    // 4    for(int i=1;i&lt;=m&amp;&amp; (u=pow(pr[i], 7))&lt;=N; i++)&#123;        for(int j=1;j&lt;=m&amp;&amp; (v= u*pr[j]*pr[j]*pr[j])&lt;=N; j++)            if(i!=j) ans+=v*s[N/v];        &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 235","url":"/project-euler/235/","content":"\r\nProject Euler 235\r\n题目\r\nAn Arithmetic Geometric\r\nsequence\r\nGiven is the arithmetic-geometric sequence \\(u(k) = (900-3k)r^{k-1}\\). Let \\(s(n) = \\sum_{k=1\\dots n}u(k)\\).\r\nFind the value of \\(r\\) for which\r\n\\(s(5000) = -600,000,000,000\\).\r\nGive your answer rounded to \\(12\\)\r\nplaces behind the decimal point.\r\n解决方案\r\n使用浮点数上的二分法，直接暴力对\\(u(k)\\)求和得出结果。由于等比数列的项数膨胀很快，求和之后的值又比较小，因此二分区间仅仅取在\\(1\\)和\\(1.01\\)之间。\r\n为了省去求和过程，假设\\(u(k)=(Ak+B)r^{k-1}\\)，可以预先使用Mathematica求出\\(s(n)\\)的通项公式为（当然也可以通过错位相减法或者是裂项相消法手动求出）：\r\n\\[s(n)=\\dfrac{anr^{n+1}-a(n+1)r^n+a+b(r-1)(r^n-1)}{(r-1)^2}\\]\r\n直接在这条式子上面进行二分求\\(r\\)的值。\r\n代码\r\nN = -600000000000n = 5000l = 1.00r = 1.01for _ in range(100):    q = 0.5 * (l + r)    s = 0    for k in range(1, n + 1):        s += (900 - 3 * k) * (q ** (k - 1))    if s &lt; N:        r = q    else:        l = qans = lprint(&quot;&#123;:.12f&#125;&quot;.format(ans))\r\nsum[(ak+b)*q^(k-1),&#123;k,1,n&#125;]\r\nN = -600000000000n = 5000A = -3B = 900l = 1.00r = 1.01for _ in range(100):    q = 0.5 * (l + r)    s = (A * n * q ** (n + 1) - A * (n + 1) * q ** n + A + B * (q - 1) * (q ** n - 1)) / (q - 1) ** 2    if s &lt; N:        r = q    else:        l = qans = lprint(&quot;&#123;:.12f&#125;&quot;.format(ans))\r\n","categories":["Project Euler"],"tags":["二分"]},{"title":"Project Euler 236","url":"/project-euler/236/","content":"\r\nProject Euler 236\r\n题目\r\nLuxury Hampers\r\nSuppliers ‘A’ and ‘B’ provided the following numbers of products for\r\nthe luxury hamper market:\r\n\r\n\r\n\r\nProduct\r\n‘A’\r\n‘B’\r\n\r\n\r\n\r\n\r\nBeluga Caviar\r\n\\(5248\\)\r\n\\(640\\)\r\n\r\n\r\nChristmas Cake\r\n\\(1312\\)\r\n\\(1888\\)\r\n\r\n\r\nGammon Joint\r\n\\(2624\\)\r\n\\(3776\\)\r\n\r\n\r\nVintage Port\r\n\\(5760\\)\r\n\\(3776\\)\r\n\r\n\r\nChampagne Truffles\r\n\\(3936\\)\r\n\\(5664\\)\r\n\r\n\r\n\r\nAlthough the suppliers try very hard to ship their goods in perfect\r\ncondition, there is inevitably some spoilage - i.e. products\r\ngone bad. The suppliers compare their performance using two types of\r\nstatistic:\r\n\r\nThe five per-product spoilage rates for each supplier\r\nare equal to the number of products gone bad divided by the number of\r\nproducts supplied, for each of the five products in turn.\r\nThe overall spoilage rate for each supplier is equal to\r\nthe total number of products gone bad divided by the total number of\r\nproducts provided by that supplier.\r\n\r\nTo their surprise, the suppliers found that each of the five\r\nper-product spoilage rates was worse (higher) for ‘B’ than for ‘A’ by\r\nthe same factor (ratio of spoilage rates), \\(m&gt;1\\); and yet, paradoxically, the\r\noverall spoilage rate was worse for ‘A’ than for ‘B’, also by a factor\r\nof \\(m\\).\r\nThere are thirty-five \\(m&gt;1\\) for\r\nwhich this surprising result could have occurred, the smallest of which\r\nis \\(1476/1475\\).\r\nWhat’s the largest possible value of \\(m\\)?\r\nGive your answer as a fraction reduced to its lowest terms, in the\r\nform \\(u/v\\).\r\n解决方案\r\n假设\\(m=\\dfrac{u}{v}\\)，\\(\\gcd(u,v)=1\\)，\\(a_1,a_2,\\dots,a_5\\)分别是\\(A\\)店铺对应\\(5\\)个商品的损耗量，\\(b_1,b_2,\\dots,b_5\\)同理。\r\n那么可以写出以下几个等式：\r\n\\[\\dfrac{b_1}{a_1}=\\dfrac{5u}{41v}=\\dfrac{u_1}{v_1},\\dfrac{b_2}{a_2}=\\dfrac{b_3}{a_3}=\\dfrac\r\n{b_5}{a_5}=\\dfrac{59u}{41v}=\\dfrac{u_2}{v_2},\\dfrac{b_4}{a_4}=\\dfrac{59u}{90v}=\\dfrac{u_4}{v_4}\\]\r\n其中，\\(\\gcd(u_j,v_j)=1,j\\in\\{1,2,4\\}\\)。\r\n根据最后一个条件：A点的损耗总数为B的\\(m\\)倍，那么可以写出：\r\n\\[\\dfrac{\\sum_{i=1}^5a_i}{\\sum_{i=1}^5b_i}=\\dfrac{295u}{246v}=\\dfrac{U}{V}\\qquad(1)\\]\r\n其中\\(\\gcd(U,V)=1\\).\r\n我们可以考虑枚举\\(a_2,b_2\\)的所有值，求出所有可能的二元组\\(\\dfrac{u}{v}\\)。一个可能的\\(\\dfrac{u}{v}\\)就可以确定所有比值\\(\\dfrac{u_j}{v_j}\\)和\\(\\dfrac{U}{V}\\)。根据这些比值，倒推出所有可能的\\((a_i,b_i)\\)出来，\\((a_i,b_i)\\)的可能取值有\\((v_j,u_j),(2v_j,2u_j),(3v_j,3u_j),\\dots\\)。枚举的时候，注意\\((a_i,b_i)\\)不能超过原来的上限。\r\n可以发现，\\((a_2,b_2),(a_3,b_3),(a_5,b_5)\\)具有相同的比值，因此可以将它们统一考虑。\r\n那么，对于每对\\((u,v)\\)，现在考虑下面关于\\(k_1,k_2,k_4\\)的方程的解：\r\n\\[\\dfrac{k_1v_1+k_2v_2+k_4v_4}{k_1u_1+k_2u_2+k_4u_4}=\\dfrac{U}{V}\\]\r\n这个方程可以写成：\r\n\\[k_1(v_1V-u_1U)+k_2(v_2V-u_2U)+k_4(v_4V-u_4U)=0\\]\r\n其中\\(k_1,k_4&gt;0,k_2\\ge\r\n3\\)。如果找到了一组解\\((k_1,k_2,k_4)\\)，那么说明\\(\\dfrac{u}{v}\\)是一个可能的\\(m\\)。\r\n由于\\(k_1,k_2,k_4\\)的上限都很低，因此可以直接进行二重循环的枚举，当然也可以进行一次循环且使用扩展欧几里得算法解决。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;# define pi pair&lt;int,int&gt;typedef long long ll;using namespace std;bool ok(ll c1,ll c2,ll c3,ll k1,ll k2,ll k3)&#123;    for(int i=1;i&lt;=k1;i++)&#123;        for(int j=1;j&lt;=k3;j++)&#123;            ll x=-c1*i-c3*j;            if(x%c2) continue;            x/=c2;            if(3&lt;=x&amp;&amp;x&lt;=k2) return 1;        &#125;    &#125;    return 0;&#125;int main()&#123;    set&lt;pi&gt;st;    for(int a2=1;a2&lt;=1312;a2++)&#123;        for(int b2=1;b2&lt;=1888;b2++)&#123;            if(__gcd(a2,b2)!=1) continue;            int u=41*b2,v=59*a2;            if(u&lt;=v) continue;            int g=__gcd(u,v);            u/=g;v/=g;            int u1=5*u,v1=41*v;            g=__gcd(u1,v1);            u1/=g;v1/=g;            int u2=59*u,v2=41*v;            g=__gcd(u2,v2);            u2/=g;v2/=g;            int u4=59*u,v4=90*v;            g=__gcd(u4,v4);            u4/=g;v4/=g;            int U=295*u,V=246*v;            g=__gcd(U,V);            U/=g;V/=g;            ll k1=min(5248/v1,640/u1),k2=min(1312*6/v2,1888*6/u2),k4=min(5760/v4,3776/u4);            if(k1==0||k2==0||k4==0) continue;            if(ok(v1*V-u1*U,v2*V-u2*U,v4*V-u4*U,k1,k2,k4)) st.insert(pi(u,v));        &#125;    &#125;    string ans;    double mx=0;    for(auto &amp;[u,v]:st)&#123;        double d=1.0*u/v;        if(d&gt;mx) ans=to_string(u)+&quot;/&quot;+to_string(v),mx=d;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 237","url":"/project-euler/237/","content":"\r\nProject Euler 237\r\n题目\r\nTours on a \\(4 \\times n\\) playing board\r\nLet \\(T(n)\\) be the number of tours\r\nover a \\(4 \\times n\\) playing board\r\nsuch that:\r\n\r\nThe tour starts in the top left corner.\r\nThe tour consists of moves that are up, down, left, or right one\r\nsquare.\r\nThe tour visits each square exactly once.\r\nThe tour ends in the bottom left corner.\r\n\r\nThe diagram shows one tour over a \\(4\r\n\\times 10\\) board:\r\n\r\n\\(T(10)\\) is \\(2329\\). What is \\(T(10^{12}) \\text{ modulo } 10^8\\)?\r\n解决方案\r\n两个子问题：\r\n第一个问题：求出关于\\(4\\times\r\nn\\)格子上以\\((1,1)\\)为起点，以\\((4,1)\\)为终点的路径数\\(T(n)\\)的关系式。（参考了Thread中的信息。）\r\n使用暴力程序找出前几项后，查找OEIS，发现结果为A181688。在FORMULA一栏中，发现如下信息：\r\na(n) = 2*a(n-1) + 2*a(n-2) - 2*a(n-3) + a(n-4), n &gt; 4.\r\n再根据前几项枚举出来的值，不难发现\\(T\\)的递推公式为：\r\n\\[\r\nT(n)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i\\le 2\\\\\r\n  &amp;4 &amp; &amp; \\text{else if}\\quad i=3 \\\\\r\n  &amp;8 &amp; &amp; \\text{else if}\\quad i=4 \\\\\r\n  &amp;2T(n-1)+2T(n-2)-2T(n-3)+T(n-4) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n第二个问题：优化\r\n上面的递推式需要\\(O(n)\\)的时间复杂度才能计算出具体值，因此改用矩阵快速幂，将计算递推式的值的时间复杂度降到\\(O(\\log\r\nn)\\)。将线性递推式写成矩阵相乘的形式：\r\n令矩阵\\(A\\)为：\r\n\\(A=\\begin{bmatrix}\r\n2 &amp; 2 &amp; -2 &amp; 1\\\\\r\n1 &amp; 0 &amp; 0 &amp; 0 \\\\\r\n0 &amp; 1 &amp; 0 &amp; 0 \\\\\r\n0 &amp; 0 &amp; 1 &amp; 0\r\n\\end{bmatrix}\\)\r\n那么可以将递推式写成矩阵相乘的形式：\r\n\\[\r\n\\begin{bmatrix}\r\nT(n)\\\\\r\nT(n-1)\\\\\r\nT(n-2)\\\\\r\nT(n-3)\r\n\\end{bmatrix}\r\n=\r\nA\r\n\\begin{bmatrix}\r\nT(n-1)\\\\\r\nT(n-2)\\\\\r\nT(n-3)\\\\\r\nT(n-4)\r\n\\end{bmatrix}\r\n\\]\r\n通过该递推式可以产生矩阵\\(A\\)的幂。而矩阵\\(A\\)的幂次方\\(A^n\\)也可以在对数时间完成计算。因此能以\\(O(\\log n)\\)的时间复杂度计算\\(T(n)\\)的值。\r\n代码\r\nN = 10 ** 12mod = 10 ** 8def mul(a: list, b: list):    return [[sum(a[i][k] * b[k][j] for k in range(len(b))) % mod for j in range(len(b[0]))] for i in range(len(a))]a = [[1, 1, 4, 8]]b = [[0, 0, 0, 1], [1, 0, 0, -2], [0, 1, 0, 2], [0, 0, 1, 2]]N -= 1while N:    if N &amp; 1:        a = mul(a, b)    b = mul(b, b)    N &gt;&gt;= 1ans = a[0][0]print(ans)\r\n","categories":["Project Euler"],"tags":["矩阵快速幂"]},{"title":"Project Euler 234","url":"/project-euler/234/","content":"\r\nProject Euler 234\r\n题目\r\nSemidivisible numbers\r\nFor an integer \\(n \\ge 4\\), we\r\ndefine the lower prime square root of n, denoted by \\(\\text{lps}(n)\\), as the largest prime \\(\\le \\sqrt{n}\\) and the upper prime\r\nsquare root of \\(n\\), \\(\\text{ups}(n)\\), as the smallest prime\r\n\\(\\ge \\sqrt{n}\\).\r\nSo, for example, \\(\\text{lps}(4) = 2 =\r\n\\text{ups}(4), \\text{lps}(1000) = 31, \\text{ups}(1000) =\r\n37\\).\r\nLet us call an integer \\(n \\ge 4\\)\r\nsemidivisible, if one of \\(\\text{lps}(n)\\) and \\(\\text{ups}(n)\\) divides \\(n\\), but not both.\r\nThe sum of the semidivisible numbers not exceeding \\(15\\) is \\(30\\), the numbers are \\(8, 10\\) and \\(12\\). \\(15\\) is not semidivisible because it is a\r\nmultiple of both \\(\\text{lps}(15)=3\\)\r\nand \\(\\text{ups}(15)=5\\).\r\nAs a further example, the sum of the \\(92\\) semidivisible numbers up to \\(1000\\) is \\(34825\\).\r\nWhat is the sum of all semidivisible numbers not exceeding \\(999966663333\\) ?\r\n解决方案\r\n当一个数\\(n\\)是一个质数\\(p\\)的平方数时，\\(\\text{lps}(n) =\r\n\\text{ups}(n)\\)。这种数不属于本题考虑的范围内；\r\n否则，\\(\\text{lps}(n),\\text{ups}(n)\\)是两个相邻的质数（因为它们以\\(\\sqrt{n}\\)为分界点）。\r\n令\\(p\\)为一个质数，\\(q\\)是和\\(p\\)相邻并且大于\\(p\\)质数。那么\\(\\forall\r\np^2&lt;x&lt;q^2,\\text{lps}(x)=p,\\text{ups}(x)=q\\)。\r\n每次枚举到一对相邻的质数\\((p,q)\\)，我们可以在开区间\\((p^2,q^2)\\)寻找所有只被\\(p,q\\)之一整除的数。尽管区间\\((p^2,q^2)\\)范围很大，但是枚举步长是\\(p\\)，因此其实每个区间中枚举的数量是很少的。\r\n也可以通过容斥原理加速计算，省去枚举的时间。\r\n代码\r\nfrom tools import get_primeN = 999966663333pr = get_prime(int(N ** 0.5 + 4))ans = 0for i in range(1, len(pr)):    vl, vr = pr[i - 1], pr[i]    for v in range((vl * vl + vr - 1) // vr * vr, min(N + 1, vr * vr), vr):        if v % vl:            ans += v    for v in range(vl * (vl + 1), min(N + 1, vr * vr), vl):        if v % vr:            ans += vprint(ans)\r\nfrom tools import get_primeN = 999966663333def cal(l, r, v):    l, r = (l - 1) // v, r // v    return (r * (r + 1) // 2 - l * (l + 1) // 2) * vpr = get_prime(int(N ** 0.5 + 4))ans = 0for i in range(1, len(pr)):    vl, vr = pr[i - 1], pr[i]    l, r = min(vl * vl + 1, N + 1), min(vr * vr - 1, N + 1)    # pq的倍数被算了两次，所以要减去两次。    ans += cal(l, r, vl) + cal(l, r, vr) - cal(l, r, vl * vr) * 2print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 238","url":"/project-euler/238/","content":"\r\nProject Euler 238\r\n题目\r\nInfinite string tour\r\nCreate a sequence of numbers using the “Blum Blum Shub” pseudo-random\r\nnumber generator:\r\n\\(\\begin{aligned}\r\ns_0&amp;=14025256\\\\\r\ns_{n+1}&amp;=s_n^2 \\bmod 20300713\r\n\\end{aligned}\\)\r\nConcatenate these numbers  \\(s_0s_1s_2\\dots\\) to create a string \\(w\\) of infinite length.\r\nThen, \\(w = \\color{blue}14025256741014958470038053646\\dots\\)\r\nFor a positive integer \\(k\\), if no\r\nsubstring of \\(w\\) exists with a sum of\r\ndigits equal to \\(k\\), \\(p(k)\\) is defined to be zero. If at least\r\none substring of \\(w\\) exists with a\r\nsum of digits equal to \\(k\\), we define\r\n\\(p(k) = z\\), where \\(z\\) is the starting position of the\r\nearliest such substring.\r\nFor instance:\r\nThe substrings \\(\\color{blue}1, 14, 1402,\r\n\\dots\\) with respective sums of digits equal to \\(1, 5, 7, \\dots\\)\r\nstart at position \\(\\mathbf{1}\\),\r\nhence \\(p(1) = p(5) = p(7) = \\dots = \\mathbf{1}\\).\r\nThe substrings \\(\\color{blue}4, 402, 4025,\r\n\\dots\\) with respective sums of digits equal to \\(4, 6, 11, \\dots\\)\r\nstart at position \\(\\mathbf{2}\\),\r\nhence \\(p(4) = p(6) = p(11) = \\dots = 2\\).\r\nThe substrings \\(\\color{blue} 02, 0252,\r\n\\dots\\) with respective sums of digits equal to \\(2, 9, \\dots\\)\r\nstart at position \\(\\mathbf{3}\\),\r\nhence \\(p(2) = p(9) = \\dots = \\mathbf{3}\\).\r\nNote that substring \\(\\color{blue}025\\) starting at position\r\n\\(3\\), has a sum of digits equal to\r\n\\(7\\), but there was an earlier\r\nsubstring (starting at position \\(1\\))\r\nwith a sum of digits equal to \\(7\\), so\r\n\\(p(7) = 1\\), not \\(3\\).\r\nWe can verify that, for \\(0 &lt; k \\le 10^3, \\sum p(k) = 4742\\). Find\r\n\\(\\sum p(k)\\), for \\(0 &lt; k \\le 2\\cdot10^{15}\\).\r\n解决方案\r\n不难发现，序列\\(s\\)是一个周期序列，其周期为\\(2534198\\).\r\n因此，字符串\\(w\\)必定也是一个周期序列。\\(w\\)的字符串周期为\\(t=18886117\\)。单个周期中，所有数之和为\\(T=80846691\\).因此有\\(p(k)=p(k+T)\\)，因此这里只需要求出所有\\(1\\le k\\le T\\)的\\(p(k)\\)值即可。\r\n本方案通过暴力枚举的方式直接找到这一部分的\\(p\\)值，时间复杂度为\\(O(t^2)\\)。\r\n为了压缩时间，考虑以下缩减时间复杂度的方法：在枚举起点的时候，如果发现对于某个值\\(s\\)，\\(p(s+1),p(s+2),\\dots,p(T)\\)都已经求解出来，那么在枚举区间右端点\\(r\\)时，保持\\(\\sum_{i=l}^r w_i\\le s\\)。每次枚举\\(i\\)时，都先要将\\(s\\)维护好。经过测试，这种方式让外层循环进行了不到\\(100\\)次，效率可以接受。\r\n对于某个\\(k\\)，计算出\\(p(k)\\)后，那么就需要计算\\(1\\sim N\\)中有多少个值和\\(k\\)关于模\\(T\\)同余。这个值不难计算出是\\(\\left\\lfloor \\dfrac{N}{T}\\right\\rfloor+[k\\neq T\r\n\\land k\\le n\\%T]\\),其中\\([]\\)是示性函数。\r\n需要注意的是，有一部分\\(p\\)值，以\\(p(k)\\)为起点，\\(k\\)为和值的字符串跨越了两个周期，本代码给第二个区间预留了\\(C=100\\)位数字。\r\n对于\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll N=2e15;int s0 = 14025256;int mod = 20300713;const int A=2e7+1004,B=9e7+4,C=100;int d[A+C],t=0,T=0;bool vis[B+C];int main()&#123;    int pre=t;    for(int s=s0;;)&#123;        for(int x=s;x;d[++t]=x%10,T+=d[t],x/=10);        reverse(d+pre+1,d+t+1);        pre=t;        s=1ll*s*s%mod;        if(s==s0) break;    &#125;    int rs=T;    for(int i=1;i&lt;=C;i++)        d[t+i]=d[i],rs+=d[i];    ll ans=0;    for(int l=1,ps=T;l&lt;=t+C;l++)&#123;        if(l&gt;1&amp;&amp;d[l-1]==0) continue;        // 关键代码，大于$ps$的那一部分不需要再枚举。        ps=min(ps,rs);        for(;ps&gt;0&amp;&amp;vis[ps];ps--);        if(ps==0) break;        for(int r=l,s=0;r&lt;=t+C&amp;&amp;s+d[r]&lt;=ps;r++)&#123;            s+=d[r];            if(s&gt;0&amp;&amp;!vis[s])&#123;                ll cnt=N/T+(s==T?0:s&lt;=N%T);                ans+=cnt*l;                vis[s]=true;            &#125;        &#125;        rs-=d[l];    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["双指针"]},{"title":"Project Euler 239","url":"/project-euler/239/","content":"\r\nProject Euler 239\r\n题目\r\nTwenty-two Foolish Primes\r\nA set of disks numbered \\(1\\)\r\nthrough \\(100\\) are placed in a line in\r\nrandom order.\r\nWhat is the probability that we have a partial derangement such that\r\nexactly \\(22\\) prime number discs are\r\nfound away from their natural positions? (Any number of non-prime disks\r\nmay also be found in or out of their natural positions.)\r\nGive your answer rounded to \\(12\\)\r\nplaces behind the decimal point in the form \\(0.abcdefghijkl\\).\r\n解决方案\r\n令\\(N=100,O=22\\)，并且\\(N\\)以内一共有\\(M=25\\)个质数。\r\n不难以下两个过程是独立的：\r\n\r\n从\\(M\\)个质数中选择\\(M-O\\)个，将它们放在原地，一共有\\(\\dbinom{M}{O}\\)种方法。之后便不考虑这\\(M-O\\)个质数。\r\n这\\(O\\)个质数不应该在原地，但是剩下的\\(N-M\\)个非质数则随便排列。\r\n\r\n考虑使用动态规划的思想解决第二个步骤的问题。令\\(f(i,j)(0\\le j\\le\r\ni)\\)表示有多少个长度为\\(i\\)的排列\\(p_1,p_2,p_3,\\dots,p_{i-1},p_i\\)，对于特定的\\(j\\)个两两不同下标\\(a_1,a_2,\\dots,a_j\\)（注意些下标是可以随意假设的，这里你可以假设成\\(a_i=i\\)），满足\\(p_{a_1}\\neq a_1,p_{a_2}\\neq a_2,\\dots,p_{a_j}\\neq\r\na_j\\).那么可以写出如下状态转移方程：\r\n\\[\r\nf(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;i!  &amp; &amp; \\text{if}\\quad j=0 \\\\\r\n  &amp;f(i,j-1)-f(i-1,j-1)&amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n对于方程最后一行，\\(f(i-1,j-1)\\)中的每个排列\\(p_1,p_2,\\dots,p_{i-1}\\)，都可以映射到\\(f(i,j-1)\\)中的\\(p_1,p_2,\\dots,p_{i-1},\\underline{i}\\)。在\\(f(i-1,j-1)\\)中的\\(j-1\\)个特定下标中，如果再加上一个\\(a_j=i\\)，那么就相当于在\\(f(i,j-1)\\)中去掉被\\(f(i-1,j-1)\\)映射出来的排列，剩下的就成为\\(f(i,j)\\)中的排列。\r\n合并两个步骤，最终题目的答案为\\(\\dfrac{\\binom{M}{O}\\cdot\r\nf(N-M+O,O)}{N!}\\).\r\n代码\r\nfrom tools import CN = 100M = 25O = 22fac = [1]for i in range(1, N + 1):    fac.append(fac[-1] * i)f = [[0 for x in range(y + 1)] for y in range(N + 1)]  # A047920for i in range(N + 1):    f[i][0] = fac[i]    for j in range(1, i + 1):        f[i][j] = f[i][j - 1] - f[i - 1][j - 1]ans = C(M, O) * f[N - (M - O)][O] / fac[N]print(&quot;&#123;:.12f&#125;&quot;.format(ans))\r\n","categories":["Project Euler"]},{"title":"Project Euler 24","url":"/project-euler/24/","content":"\r\nProject Euler 24\r\n题目\r\nLexicographic permutations\r\nA permutation is an ordered arrangement of objects. For example,\r\n\\(3124\\) is one possible permutation of\r\nthe digits \\(1\\), \\(2\\), \\(3\\)\r\nand \\(4\\). If all of the permutations\r\nare listed numerically or alphabetically, we call it lexicographic\r\norder. The lexicographic permutations of \\(0\\), \\(1\\)\r\nand \\(2\\) are: \\[012 \\quad 021 \\quad 102 \\quad 120 \\quad 201 \\quad\r\n210\\] What is the millionth lexicographic permutation of the\r\ndigits \\(0\\), \\(1\\), \\(2\\), \\(3\\), \\(4\\), \\(5\\), \\(6\\), \\(7\\), \\(8\\)\r\nand \\(9\\)?\r\n解决方案\r\n使用康托逆展开即可。基本思想是，假设这是一个\\(n\\)阶置换。在本问题下，如果现在在填第\\(i(i\\)的下标从\\(0\\)开始\\()\\)个数，那么后面还有\\(n-i-1\\)个数，这\\(n-i-1\\)个数全排列一共有\\((n-i-1)!\\)种情况。并且，无论填哪个数，后面都是\\((n-i-1)!\\)种的情况。因此，用当前字典序排名整除值\\((n-i-1)!\\)，可以计算出当前目前的所需要填的值的排名。将这个值填充到第\\(i\\)个位置后，需要删除。接下来就一直往后解决该子结果下的新子问题。\r\n代码\r\nQ = 10 ** 6Q -= 1N = 10a = [i for i in range(N)]b = []for i in range(N):    p, now = divmod(Q, fac(N - i - 1))    b.append(a[p])    del a[p]    Q = nowans = &quot;&quot;.join(str(x) for x in b)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 240","url":"/project-euler/240/","content":"\r\nProject Euler 240\r\n题目\r\nTop Dice\r\nThere are \\(1111\\) ways in which\r\nfive \\(6\\)-sided dice (sides numbered\r\n\\(1\\) to \\(6\\)) can be rolled so that the top three\r\nsum to \\(15\\). Some examples are:\r\n\\(\\begin{aligned}\r\nD_1,D_2,D_3,D_4,D_5 = 4,3,6,3,5\\\\\r\nD_1,D_2,D_3,D_4,D_5 = 4,3,3,5,6\\\\\r\nD_1,D_2,D_3,D_4,D_5 = 3,3,3,6,6\\\\\r\nD_1,D_2,D_3,D_4,D_5 = 6,6,3,3,3\r\n\\end{aligned}\\)\r\nIn how many ways can twenty \\(12\\)-sided dice (sides numbered \\(1\\) to \\(12\\)) be rolled so that the top ten sum to\r\n\\(70\\)?\r\n解决方案\r\n令\\(N=20,M=10,K=12,S=70\\)。考虑使用动态规划解决本题。\r\n基本思想是：从小到大枚举需要添加的骰子。其中前\\(N-K\\)个不算和，只为后\\(K\\)个最大的算和。\r\n假设状态\\(f(i,j,k,l)(0\\le j\\le i\\le N,1\\le\r\nk\\le K,0\\le l\\le\r\nS)\\)表示满足以下条件的排列方案数：从小到大已经枚举了\\(i\\)个骰子，目前最大值为\\(k\\)，其中骰子\\(k\\)已经使用了\\(j\\)个，并且除去最小的不算数的那一部分，剩下的和为\\(l\\)。\r\n这里采用的动态规划使用的是“我为人人”的方式，也就是考虑当前状态能够转移到哪些地方。\r\n对于一个状态\\(f(i,j,k,l)\\)而言，它有以下转移方式：每次选择一个新的值\\(x\\)加入骰子序列，并且\\(x\\ge k\\)：\r\n当\\(x=k\\)时，有\\(f(i,j,k,l) \\cdot\\dfrac{i+1}{j+1}\\rightarrow\r\nf(i+1,j+1,x,l+x\\cdot [i\\ge N-M]\\).\r\n当\\(x&gt;k\\)时，有\\(f(i,j,k,l) \\cdot(i+1)\\rightarrow\r\nf(i+1,1,x,l+x\\cdot [i\\ge N-M]\\).\r\n其中，\\(f(i,j,k,l)\\)后面的那个系数是为了用于维护多重排列数。而\\([]\\)表示示性函数，表示\\([]\\)里面的值是否为真，如果为真，那么值为\\(1\\)，否则值为\\(0\\).\r\n那么，最终答案为：\r\n\\[\\sum_{j=1}^N\\sum_{k=1}^K\r\nf(N,j,k,S)\\]\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=20,M=10,K=12,S=70;ll f[N+4][N+4][K+4][S+4];int main()&#123;    f[0][0][1][0]=1;    for(int i=0;i&lt;N;i++)        for(int j=0;j&lt;=i;j++)            for(int k=1;k&lt;=K;k++)                for(int l=0;l&lt;=S;l++)&#123;                    if(f[i][j][k][l]==0) continue;                    for(int x=k;x&lt;=K;x++)&#123;                        int ns=(i&lt;N-M?l:l+x);                        if(ns&gt;S) continue;                        int nj=(x==k?j+1:1);                        f[i+1][nj][x][ns]+=f[i][j][k][l]*(i+1)/nj;                    &#125;                &#125;    ll ans=0;    for(int j=1;j&lt;=N;j++)        for(int k=1;k&lt;=K;k++)            ans+=f[N][j][k][S];    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 242","url":"/project-euler/242/","content":"\r\nProject Euler 242\r\n题目\r\nOdd Triplets\r\nGiven the set \\(\\{1,2,\\dots,n\\}\\),\r\nwe define \\(f(n,k)\\) as the number of\r\nits \\(k\\)-element subsets with an odd\r\nsum of elements. For example, \\(f(5,3)=4\\), since the set \\(\\{1,2,3,4,5\\}\\) has four \\(3\\)-element subsets having an odd sum of\r\nelements, i.e.: \\(\\{1,2,4\\}, \\{1,3,5\\},\r\n\\{2,3,4\\}\\) and \\(\\{2,4,5\\}\\).\r\nWhen all three values \\(n, k\\) and\r\n\\(f(n,k)\\) are odd, we say that they\r\nmake an odd-triplet \\([n,k,f(n,k)]\\). There are exactly five\r\nodd-triplets with \\(n\\le10\\),\r\nnamely:\\([1,1,f(1,1)=1], [5,1,f(5,1)=3],\r\n[5,5,f(5,5)=1], [9,1,f(9,1)=5]\\) and \\([9,9,f(9,9)=1]\\).\r\nHow many odd-triplets are there with \\(n\\le10^{12}\\)?\r\n卢卡斯定理\r\n卢卡斯定理：如果\\(p\\)是一个质数，那么计算组合数\\(\\dbinom{n}{m}\\% p\\)时可用以下公式。\r\n\\[\\dbinom{n}{m} \\equiv \\dbinom{n\\%p}{m\\%p}\r\n\\cdot\r\n\\dbinom{\\left\\lfloor\\frac{n}{p}\\right\\rfloor}{\\left\\lfloor\\frac{m}{p}\\right\\rfloor}\r\n\\pmod p\\]\r\n其中，在计算过程中，如果发生了\\(m&gt;n\\)，那么\\(\\dbinom{n}{m}\\%p=0\\)。\r\n可以看成是假设有两个等长的\\(p\\)进制数（可以有前导\\(0\\)）：\\(a=a_{k-1}\\dots a_2a_1a_0,b= b_{k-1}\\dots\r\nb_2b_1b_0\\)。那么\r\n\\[\\dbinom{a}{b}\\equiv  \\dbinom{a_{k-1}}{b_{k-1}}\\dots\r\n\\dbinom{a_{2}}{b_{2}}\\dbinom{a_{1}}{b_{1}}\\dbinom{a_{0}}{b_{0}}\\pmod\r\np\\]\r\n解决方案\r\n令\\(N=10^{12}\\)。将\\(f(i,j)\\)的所有奇数行和奇数列打印出来后，发现以下现象：\r\n\r\n如果\\(i,j\\)其中一个是形如\\(4k+3\\)的数，那么\\(f(i,j)\\)为偶数。这部分我们不需要考虑。\r\n如果\\(i,j\\)都是形如\\(4k+1\\)的数，那么\\(f(4k_0+1,4k_1+1)\\)的奇偶性将和\\(\\dbinom{k_0}{k_1}\\)相同。\r\n\r\n那么，这个问题就转化成了如下表述：在杨辉三角的前\\(\\left\\lfloor\\dfrac{N+3}{4}\\right\\rfloor\\)行中，有多少个数是奇数？\r\n这个问题的解决方式和148题完全相同，此处不再详述具体算法。\r\n接下来主要详述为什么这些现象是成立的。\r\n令\\(n=2a+1,m=2b+1\\)，那么不难发现，集合有\\(a\\)个偶数，\\(a+1\\)个奇数。为了保证选择的子集和是一个奇数，因此选择的\\(2b+1\\)个数中，必须有偶数个偶数。\r\n那么，就可以写出：\r\n\\[f(n,m)=\\sum_{\r\nk=\\left\\lceil\\frac{m-a-1}{2}\\right\\rceil}^{\\left\\lfloor\\frac{a}{2}\\right\\rfloor}\r\n\\dbinom{a}{2k}\\cdot \\dbinom{a+1}{m-2k}\\]\r\n发现\\(m-2k\\)必定为奇数，如果\\(a+1\\)是偶数，那么根据卢卡斯定理，\\(C_{a+1}^{m-2k}\\)必定是一个偶数。最终，\\(f(n,m)\\)为偶数。\r\n因此\\(a\\)必定为偶数，令\\(a=2c\\)，那么\\(n=4c+1\\)。\r\n代入\\(m=2b+1\\)，那么\\(f(n,m)\\)就可以重写成：\r\n\\[f(n,m)=\\sum_{\r\nk=\\left\\lceil\\frac{m-2c-1}{2}\\right\\rceil}^{\\left\\lfloor\\frac{a}{2}\\right\\rfloor}\\dbinom{2c}{2k}\r\n\\cdot\r\n\\dbinom{2c+1}{2b-2k+1}=\\sum_{k=\\left\\lceil\\frac{m-2c-1}{2}\\right\\rceil}^{\\left\\lfloor\\frac{a}{2}\\right\\rfloor}\\dbinom{2c}{2k}\\cdot\r\n\\dbinom{2c+1}{2(b-k)+1}\\]\r\n那么根据卢卡斯定理，可以写出：\r\n\\[f(n,m)\\equiv\r\n\\sum_{k}\\dbinom{c}{k}\\cdot\\dbinom{c}{b-k} \\pmod 2\\]\r\n如果\\(b\\)是奇数，那么就可以写成：\r\n\\[f(n,m)\\equiv\r\n2\\sum_{k&lt;\\frac{b}{2}}\\dbinom{c}{k}\\cdot\\dbinom{c}{b-k} \\pmod\r\n2\\]\r\n因为当\\(k&gt;\\dfrac{b}{2}\\)，求和式仍然是相同的。从式子中可以看出，此时\\(f(n,m)\\)是偶数。\r\n因此\\(b\\)必须是偶数，令\\(b=2d\\)，那么\\(m=4d+1\\)，并且\\(f(n,m)\\)可以写成：\r\n\\[f(n,m)\\equiv\\dbinom{c}{d}^2+2\\sum_{k&lt;d}\\dbinom{c}{k}\\cdot\\dbinom{c}{2d-k}\\equiv\r\n\\dbinom{c}{d} \\pmod 2\\]\r\n因此这种现象得证。由于\\(n=4c+1\\)，最终将问题转化成了求杨辉三角上前\\(\\left\\lfloor\\dfrac{N+3}{4}\\right\\rfloor\\)行元素中奇数的个数。\r\n代码\r\nN, p = 10 ** 12, 2def fun(n: int):    return n * (n + 1) // 2N = (N + 3) // 4ls = []while N:    ls.append(N % p)    N //= pans, mul = 0, 1for k in range(len(ls) - 1, -1, -1):    ans += mul * (fun(p) ** k) * fun(ls[k])    mul *= (ls[k] + 1)print(ans)\r\n","categories":["Project Euler"],"tags":["卢卡斯定理"]},{"title":"Project Euler 241","url":"/project-euler/241/","content":"\r\nProject Euler 241\r\n题目\r\nPerfection Quotients\r\nFor a positive integer \\(n\\), let\r\n\\(\\sigma(n)\\) be the sum of all\r\ndivisors of \\(n\\). For example, \\(\\sigma(6) = 1 + 2 + 3 + 6 = 12\\).\r\nA perfect number, as you probably know, is a number with \\(\\sigma(n) = 2n\\).\r\nLet us define the perfection quotient of a positive\r\ninteger as \\(p(n) =\r\n\\dfrac{\\sigma(n)}{n}\\).\r\nFind the sum of all positive integers \\(n\r\n\\le 10^{18}\\) for which \\(p(n)\\)\r\nhas the form \\(k + \\dfrac{1}{2}\\),\r\nwhere \\(k\\) is an integer.\r\n解决方案\r\n可以将\\(\\dfrac{\\sigma(n)}{n}=k+\\dfrac{1}{2}\\)改写成：\r\n\\[\\dfrac{(2k+1)\\cdot\r\nn}{2\\sigma(n)}=1\\]\r\n对于一个质数\\(q\\)，有\\(p(q^k)=\\dfrac{q^{k+1}-1}{q-1}\\cdot\\dfrac{1}{q^k}\\).\r\n给定一个数\\(\\dfrac{a}{b}=\\dfrac{2k+1}{2}\\)，不停除上一些形如\\(p(q_i^{k_i})\\)的值（其中\\(q_i\\)是质数），那么这个数将会逐渐减少。如果恰好能减少到\\(1\\)，那么就找到了一个答案\\(\\prod_i\r\nq_i^{k_i}\\).如果在除的过程中发现这个数小于\\(1\\)了，那么就返回。\r\n对于质数\\(q_i\\)的寻找方式：为了尽快消去分母\\(b\\)，考虑对\\(b\\)进行分解质因数，那么假设找到\\(b\\)的分解中最小的一项为\\(r^e\\)。那么就对\\(\\dfrac{a}{b}\\)尝试除\\(p(r^e),p(r^{e+1}),p(r^{e+2}),\\dots\\)往下继续进行搜索。\r\n关于\\(k\\)的枚举，该页面给出了\\(p(n)(n&gt;3)\\)的上限：\r\n\\[\\dfrac{\\sigma(n)}{n}&lt;e^{\\gamma}\r\n\\log\\log n+\\dfrac{0.6483}{\\log\\log n}\\]\r\n其中\\(\\gamma\\)为欧拉常数，值约为\\(0.57721 56649\\).因此，只需要保证\\(\\dfrac{2k+1}{2}\\)在这个范围内即可。\r\n代码\r\nfrom tools import gcd, factorizationfrom itertools import countfrom math import exp, logN = 10 ** 18ans = 0K = int((exp(0.57721566490153286) * log(log(N)) + 0.6483 / log(log(N)))*2)def dfs(n: int, fz: int, fm: int):    if n * fz &gt; N or gcd(n, fm) != 1 or fz &lt; fm:        return    if fm == 1:        if fz == 1:            global ans            ans += n        return    p = factorization(fm)[0][0]    e = 1    while fm % p ** (e + 1) == 0:        e += 1    for i in count(e, 1):        nw = n * p ** i        if nw &gt; N:            break        new_fz = fz * p ** i        new_fm = fm * (p ** (i + 1) - 1) // (p - 1)        g = gcd(new_fz, new_fm)        dfs(nw, new_fz // g, new_fm // g)for i in range(3, K+1, 2):    dfs(1, i, 2)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 243","url":"/project-euler/243/","content":"\r\nProject Euler 243\r\n题目\r\nResilience\r\nA positive fraction whose numerator is less than its denominator is\r\ncalled a proper fraction.\r\nFor any denominator, \\(d\\), there\r\nwill be \\(d−1\\) proper fractions; for\r\nexample, with \\(d=12\\):\r\n\\(\\dfrac{1}{12},\\dfrac{2}{12},\\dfrac{3}{12},\\dfrac{4}{12},\\dfrac{5}{12},\\dfrac{6}{12},\\dfrac{7}{12},\\dfrac{8}{12},\\dfrac{9}{12},\\dfrac{10}{12},\\dfrac{11}{12}\\)\r\nWe shall call a fraction that cannot be cancelled down a\r\nresilient fraction.\r\nFurthermore we shall define the resilience of a denominator,\r\n\\(R(d)\\), to be the ratio of its proper\r\nfractions that are resilient; for example, \\(R(12) = \\dfrac{4}{11}\\) .\r\nIn fact, \\(d=12\\) is the smallest\r\ndenominator having a resilience \\(R(d) &lt;\r\n\\dfrac{4}{10}\\).\r\nFind the smallest denominator \\(d\\),\r\nhaving a resilience \\(R(d) &lt;\r\n\\dfrac{15499}{94744}\\) .\r\n解决方案\r\n令\\(r=\\dfrac{15499}{94799}\\)\r\n根据欧拉函数\\(\\varphi\\)的定义，可以知道\\(R(d)=\\dfrac{\\varphi(d)}{d-1}\\).\r\n如果一个数\\(n\\)中质因数越来越多，那么\\(\\dfrac{\\varphi(n)}{n-1}\\)就会显著降低，因为随着\\(n\\)的增大这个比值会无限趋近于\\(\\dfrac{\\varphi(n)}{n}\\)。如果一个数\\(n\\)，它的质因数的幂指数越大，那么对答案的贡献将会越低。\r\n并且，如果这些质因数越小，\\(\\dfrac{\\varphi(n)}{n-1}\\)下降的越明显。基于这种贪心的思想，假设\\(n=\\prod_{i=1}^m pr[i]\\)，其中\\(pr\\)是一个从小到大的质数列表。\r\n从小到大枚举\\(m\\)，计算出\\(n\\)的值。如果发现\\(\\dfrac{\\varphi(n)}{n-1}&lt;\r\nr\\)，那么可以不必再找下去，\\(n\\)将是一个候选的答案。如果\\(\\dfrac{\\varphi(n)}{n-1}\\ge r\\)，但是\\(\\dfrac{\\varphi(n)}{n}&lt; r\\)\r\n，那么可以考虑寻找\\(n\\)的最小的倍数\\(k\\)，使得\\(\\dfrac{\\varphi(k)}{k}&lt; r\\)，这些\\(k\\)也是一个候选答案。\r\n这些候选答案的最小值就是最终答案，枚举速度很快。\r\n代码\r\nfrom sympy import nextprimefrom fractions import Fractionfrom math import ceilU, D = 15499, 94744f = Fraction(U, D)p = 2ans = 10 ** 100phi, n = 1, 1while True:    n *= p    phi *= p - 1    if Fraction(phi, n - 1) &lt; f:        ans = min(ans, n)        break    elif Fraction(phi, n) &lt; f:        # 计算出，k至少是n的c倍时，才会有phi(k)/(k-1)&lt;r。        x = -f / (phi - n * f)        c = ceil(x)        if c == x:            c += 1        ans = min(ans, c * n)    p = nextprime(p)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 246","url":"/project-euler/246/","content":"\r\nProject Euler 246\r\n题目\r\nTangents to an ellipse\r\nA definition for an ellipse is:\r\nGiven a circle \\(c\\) with centre\r\n\\(M\\) and radius \\(r\\) and a point \\(G\\) such that \\(d(G,M)&lt;r\\), the locus of the points that\r\nare equidistant from \\(c\\) and \\(G\\) form an ellipse.\r\nThe construction of the points of the ellipse is shown below.\r\n\r\nGiven are the points \\(M(-2000,1500)\\) and \\(G(8000,1500)\\).\r\nGiven is also the circle \\(c\\) with\r\ncentre \\(M\\) and radius \\(15000\\).\r\nThe locus of the points that are equidistant from \\(G\\) and \\(c\\) form an ellipse \\(e\\).\r\nFrom a point \\(P\\) outside \\(e\\) the two tangents \\(t_1\\) and \\(t_2\\) to the ellipse are drawn.\r\nLet the points where \\(t_1\\) and\r\n\\(t_2\\) touch the ellipse be \\(R\\) and \\(S\\).\r\n\r\nFor how many lattice points \\(P\\) is\r\nangle \\(RPS\\) greater than \\(45\\) degrees?\r\n解决方案\r\n\\(|EG|=|EU|\\)，\\(|EU|+|EM|=r\\)，因此\\(|EG|+|EM|=r=2a\\)，其中\\(2a\\)是椭圆的长轴长度，焦距\\(2c=d(G,M)\\)。由于椭圆的中心也在个点，那么为了方便处理问题，将椭圆的中心挪到原点，那么可以写成椭圆的标准方程：\r\n\\[\\dfrac{x^2}{a^2}+\\dfrac{y^2}{b^2}=1\\]\r\n其中\\(a=7500,c=5000,b^2=a^2-c^2\\)。\r\n那么，由于椭圆关于两个坐标轴对称，因此只考虑第一象限以及\\(x,y\\)轴正半轴上的格点。\r\n对于圆外任意一点\\(P(x_0,y_0)\\)，那么该点的点斜式方程为\\(y-y_0=k(x-x_0)\\)，那么和椭圆方程联立，得到一个关于\\(x\\)的一元二次方程：\r\n\\[(a^2k^2+b^2)x^2+(2a^2ky_0x-2a^2k^2x_0)x+a^2y_0^2-2a^2kx_0y_0+a^2k^2x_0^2-a^2b^2=0\\]\r\n由于所求直线为切线，因此令其\\(\\Delta=0\\)，得到关于\\(k\\)的一元二次方程：\r\n\\[(x_0^2 -\r\na^2)k^2-2x_0y_0k+y_0^2-b^2=0\\]\r\n也就是说，\\(k\\)不同的两个解对应着直线的斜率，不失一般性，假设其分别为\\(k_0,k_1\\)。那么这两条直线夹角的正切值为\\(\\left|\\dfrac{k_1-k_0}{1+k_0k_1}\\right|\\)。\r\n解决本题时，还采用了一个假设：当\\(\\angle\r\nRPS=45°\\)时，\\(P\\)点的轨迹\\(\\Gamma\\)是一个凸曲线。（如果\\(\\dfrac{a}{b}\\)值太大，那么\\(\\Gamma\\)将不会是一个凸曲线，我在这里没有进行太多的研究。）\r\n因此，枚举所有\\(x_0\\ge0\\)，二分查找\\(y_0\\)使其恰好在\\(\\Gamma\\)外部。那么，\\(y_0\\)以下（不包括\\(y_0\\)）的所有点都是答案，不过，这需要排除在椭圆内部的点。\r\n代码\r\nfrom math import ceil, sqrtfrom itertools import countMx, My = -2000, 1500Gx, Gy = 8000, 1500R = 15000a = R / 2c = ((Mx - Gx) ** 2 + (My - Gy) ** 2) ** 0.5 / 2a2 = a ** 2b2 = a2 - c ** 2eps = 1e-10cnt2 = cnt4 = 0pre_r = int((a + 4) * (a + 4))for x0 in count(0, 1):    y0 = ceil(sqrt(b2 * (1 - x0 * x0 / a2)) - eps) if x0 &lt; a else 0    l = y0    r = pre_r    while l &lt; r:        mid = (l + r) &gt;&gt; 1        if x0 != a:            A = x0 * x0 - a2            B = -2 * x0 * mid            C = mid * mid - b2            D = B * B - 4 * A * C            k = [(-B - sqrt(D)) / (2 * A), (-B + sqrt(D)) / (2 * A)]            tg = (k[1] - k[0]) / (1 + k[0] * k[1])        else:            k = (mid * mid - b2) / (2 * x0 * mid)            tg = 1 / k        if 0 &lt; tg &lt;= 1:            r = mid        else:            l = mid + 1    if l == 0:        break    # 统计不同点的个数。    if x0 == 0:        cnt2 += l - y0    elif y0 &gt; 0:        cnt4 += l - y0    else:        cnt4 += l - 1        if x0 &gt; a:            cnt2 += 1    pre_r = lans = cnt2 * 2 + cnt4 * 4print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 245","url":"/project-euler/245/","content":"\r\nProject Euler 245\r\n题目\r\nCoresilience\r\nWe shall call a fraction that cannot be cancelled down a resilient\r\nfraction.\r\nFurthermore we shall define the resilience of a denominator, \\(R(d)\\), to be the ratio of its proper\r\nfractions that are resilient; for example, \\(R(12) = \\dfrac{4}{11}\\).\r\nThe resilience of a number \\(d \\gt\r\n1\\) is then \\(\\dfrac{\\varphi(d)}{d -\r\n1}\\), where \\(\\varphi\\) is\r\nEuler’s totient function.\r\nWe further define the coresilience of a number \\(n \\gt 1\\) as \\(C(n) = \\dfrac{n - \\varphi(n)}{n - 1}\\).\r\nThe coresilience of a prime \\(p\\) is\r\n\\(C(p) = \\dfrac{1}{p - 1}\\).\r\nFind the sum of all composite integers \\(1 \\lt n \\le 2 \\times 10^{11}\\), for which\r\n\\(C(n)\\) is a\r\nunit fraction.\r\n解决方案\r\n令\\(N=2\\times 10^{11}\\)。\r\n证明：如果\\(C(n)\\)是一个单位分数，那么\\(n\\)是一个无平方因子数。\r\n假设\\(p\\)是\\(n\\)的任意一个质因子，\\(e\\)是一个最大的正整数使得\\(p^e\\mid n\\)。\r\n如果\\(C(n)\\)是一个单位分数，那么可以写成存在一个整数\\(m\\)，满足\\(m=\\dfrac{n-1}{n-\\varphi(n)}\\)\r\n那么，\\(\\varphi(n)\\)中有一个因子\\(p^{e-1}\\)。同时不难发现\\(p^{e-1}\\mid n\\)。因此如果\\(m\\)是一个整数，那么\\(p^{e-1}\\mid 1\\)，从而得出\\(e=1\\)。\r\n因此，\\(n\\)是一个无平方因子数。\r\n证明：\\(n\\)是奇数。也就是说，\\(n\\)没有\\(2\\)的质因子。\r\n如果\\(n\\)是偶数，那么\\(n-1\\)是奇数，\\(n-\\varphi(n)\\)是偶数，偶数不可能整除一个奇数，因此\\(n\\)不可能是偶数。\r\n证明：\\(m\\)是偶数。\r\n由于\\(n\\)是奇数\\(n-1\\)是偶数，\\(\\varphi(n)\\)是偶数，因此\\(m\\)一定是一个偶数。\r\n假设\\(n=p_1p_2\\dots\r\np_k\\)，并且对于\\(1&lt; i\\le\r\nk\\)，都有\\(p_{i-1}&lt;\r\np_i\\)。\r\n考虑当前已经有\\(x=\\prod_{i=1}^{k-1}p_i,y=\\prod_{i=1}^{k-1}(p_i-1)\\)，现在枚举一个新的\\(p=p_k\\)，有\\(n=xp\\)。\r\n那么，\\(\\dfrac{xp-1}{xp-y(p-1)}=\\dfrac{xp-1}{(x-y)p+y}=m\\)\r\n容易发现，随着\\(p\\)值增长，\\(m\\)也增长（由反比例函数的性质可知）。但是，\\(m\\)的增长速度非常慢（因为分母中有个\\(x-y\\)，并且\\(x-y\\)的值一般是比较接近\\(x\\)的）。可以求出\\(m\\)的范围，再通过枚举\\(m\\)反推出\\(p\\)。\r\n那么，根据以上约束，不难得出\\(p_{k-1}&lt;\r\np\\le\\dfrac{N}{x}\\)\r\n因此，可以给出\\(\\dfrac{xp_{k-1}}{(x-y)p_{k-1}+y}&lt;\r\nm\\le\\dfrac{N-1}{N-y(\\frac{N}{x})+y}\\)\r\n只需要枚举这个区间中所有的偶数\\(m\\)即可，这个区间范围比较小。根据\\(m\\)，重新计算出\\(p=\\dfrac{1+mx}{x-mx+my}\\)，并判断\\(p\\)是否为一个整数并且为一个质数。如果\\(p\\)满足要求，那么说明找到了一个答案\\(np\\)。\r\n另外一个问题：\\(x\\)的枚举。\\(x\\)的枚举比较容易，只需要枚举所有的质数之积即可。但是，用\\(x\\)扩展到下一个\\(x&#39;=xq\\)时，需要保证\\(q\\le \\sqrt{\\dfrac{N}{x}}\\)，因为\\(q\\)并非是答案中最大的质因数。\r\n另外，前几项在OEIS中查询后，结果为A160599。\r\n代码\r\n#include&lt;bits/stdc++.h&gt;#include &quot;tools.h&quot;typedef long long ll;using namespace std;const ll N = 200000000000;const int M = sqrt(N)+4;int pr[M/10+1000],m=0;bool vis[M+4];ll ans=0;void dfs(int f, ll x, ll y) &#123;    ll p_max = int_sqrt(N / x);    for (int i = f + 1; i &lt;= m &amp;&amp; pr[i] &lt;= p_max; i++) &#123;        dfs(i, x * pr[i], y * (pr[i] - 1));    &#125;    ll p = f &lt; m ? pr[f + 1] : pr[f] + 2;    ll num = p * x - 1, den = p * (x - y) + y;    ll kl = (num + den - 1) / den;    if (kl % 2 == 1) kl += 1;    num = (N / x) * x - 1;    den = (N / x) * (x - y) + y;    ll kr = num / den;    for (ll k = kl; k &lt;= kr; k += 2) &#123;        num = k * y + 1;        den = x - k * (x - y);        if (num % den == 0) &#123;            ll p = num / den;            if (is_prime(p))                ans += x * p;        &#125;    &#125;&#125;int main() &#123;    for (int i = 2; i &lt;= M; i++) &#123;        if (vis[i]) continue;        pr[++m] = i;        for (ll j = 1ll * i * i; j &lt;= M; j += i)            vis[j] = 1;    &#125;    for (int i = 2; i &lt;= m; i++)        dfs(i, pr[i], pr[i] - 1);    printf(&quot;%lld\\n&quot;, ans);&#125;\r\n","categories":["Project Euler"],"tags":["OEIS"]},{"title":"Project Euler 247","url":"/project-euler/247/","content":"\r\nProject Euler 247\r\n题目\r\nSquares under a hyperbola\r\nConsider the region constrained by \\(1 \\le\r\nx\\) and \\(0 \\le y \\le\r\n\\dfrac{1}{x}\\).\r\nLet \\(S_1\\) be the largest square\r\nthat can fit under the curve.\r\nLet \\(S_2\\) be the largest square\r\nthat fits in the remaining area, and so on.\r\nLet the index of \\(S_n\\) be\r\nthe pair (left, below) indicating the number of squares to the left of\r\n\\(S_n\\) and the number of squares below\r\n\\(S_n\\).\r\n\r\nThe diagram shows some such squares labelled by number.\r\n\\(S_2\\) has one square to its left\r\nand none below, so the index of \\(S_2\\)\r\nis \\((1,0)\\).\r\nIt can be seen that the index of \\(S_{32}\\) is \\((1,1)\\) as is the index of \\(S_{50}\\).\r\n\\(50\\) is the largest \\(n\\) for which the index of \\(S_n\\) is \\((1,1)\\).\r\nWhat is the largest \\(n\\) for which\r\nthe index of \\(S_n\\) is \\((3,3)\\)?\r\n解决方案\r\n假设当前正方形的左下角顶点为\\((x_0,y_0)\\)，那么通过以下步骤可以计算这个正方形的最大边长：\r\n\r\n联立两个方程：\\(y=\\dfrac{1}{x},y-y_0=x-x_0\\)，最终解得出右上角的定点为\\((x,y)\\)\r\n这个正方形的边长为\\(x-x_0\\)。\r\n\r\n为了进行加速，代码实现没有使用优先队列，而是使用了两次深度优先搜索：\r\n\r\n第一次用于找到坐标为\\((3,3)\\)的最小正方形，假设边长\\(l\\)。\r\n第二次用于找到比\\(l\\)大的所有正方形边长。\r\n\r\n两次搜索完成后，找到的个数加\\(1\\)就是答案。\r\n由于第二次深度优先搜索递归深度太大，故使用非递归进行模拟。\r\n代码\r\nN = 3M = 3min_size = 1ans = 1def cal(x, y):    b = y - x    return (-b + (b ** 2 + 4) ** 0.5) / 2 - xdef dfs(x, y, fx, fy):    if fx &gt; N or fy &gt; M:        return    size = cal(x, y)    global min_size    if fx == N and fy == M and size &lt; min_size:        min_size = size    dfs(x + size, y, fx + 1, fy)    dfs(x, y + size, fx, fy + 1)dfs(1, 0, 0, 0)st = [(1, 0)]while len(st) &gt; 0:    x, y = st.pop()    size = cal(x, y)    if size &gt; min_size:        ans += 1        st.append((x + size, y))        st.append((x, y + size))print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 244","url":"/project-euler/244/","content":"\r\nProject Euler 244\r\n题目\r\nSliders\r\nYou probably know the game Fifteen Puzzle. Here, instead of\r\nnumbered tiles, we have seven red tiles and eight blue tiles.\r\nA move is denoted by the uppercase initial of the direction (Left,\r\nRight, Up, Down) in which the tile is slid, e.g. starting from\r\nconfiguration (S), by the sequence\r\nLULUR we reach the configuration\r\n(E):\r\n(S),(E)\r\nFor each path, its checksum is calculated by (pseudocode):\r\n\\(\\begin{aligned}\r\n\\text{checksum} &amp;= 0\\\\\r\n\\text{checksum} &amp;= (\\text{checksum} \\times 243 + m_1) \\bmod\r\n100000007\\\\\r\n\\text{checksum} &amp;= (\\text{checksum} \\times 243 + m_2) \\bmod\r\n100000007\\\\\r\n&amp;\\dots&amp;\\\\\r\n\\text{checksum} &amp;= (\\text{checksum} \\times 243 + m_n) \\bmod\r\n100000007\r\n\\end{aligned}\\)\r\nwhere \\(m_k\\) is the ASCII value of\r\nthe \\(k^{\\text{th}}\\) letter in the\r\nmove sequence and the ASCII values for the moves are:\r\n\r\n\r\n\r\nL\r\n\\(76\\)\r\n\r\n\r\nR\r\n\\(82\\)\r\n\r\n\r\nU\r\n\\(85\\)\r\n\r\n\r\nD\r\n\\(68\\)\r\n\r\n\r\n\r\nFor the sequence LULUR given above, the checksum\r\nwould be \\(19761398\\). Now, starting\r\nfrom configuration (S), find all shortest ways to reach\r\nconfiguration (T).\r\n(S),(T)\r\nWhat is the sum of all checksums for the paths having the minimal\r\nlength?\r\n解决方案\r\n考虑使用广度优先搜素进行，从节点S到节点T处理出所有路径。\r\n不过，在实际的实现过程中发现，如果从S到某个节点U的最短路径\\(\\text{checksum}\\)之和，全部乘\\(243\\)再添加一个方向的ASCII码后就可以成为下一个未遍历节点的\\(\\text{checksum}\\)之和的一部分。因此实际上不需要求出所有最短路径并枚举，只需要维护S到当前的节点的\\(\\text{checksum}\\)之和即可。\r\n为了节省存储空间，将棋盘编码成了一个\\(16\\)位三进制数，以作为两个字典的键。\r\n代码\r\nfrom queue import Queuest = [[0, 1, 2, 2], [1, 1, 2, 2], [1, 1, 2, 2], [1, 1, 2, 2]]ed = [[0, 2, 1, 2], [2, 1, 2, 1], [1, 2, 1, 2], [2, 1, 2, 1]]dx, dy, code = [0, 0, -1, 1], [-1, 1, 0, 0], [82, 76, 68, 85]mod = 100000007def encode(a: list):    ans = 0    for i in range(4):        for j in range(4):            ans = ans * 3 + a[i][j]    return ansdis = &#123;encode(st): 0&#125;val = &#123;encode(st): 0&#125;q = Queue()q.put(st)while not q.empty():    u = q.get()    pre = encode(u)    for i in range(16):        # 以一重循环代替二重循环，i&gt;&gt;2为行号，i&amp;3为列号        if u[i &gt;&gt; 2][i &amp; 3] == 0:            x, y = i &gt;&gt; 2, i &amp; 3            break    for k in range(4):        nx, ny = x + dx[k], y + dy[k]        if nx &lt; 0 or ny &lt; 0 or nx &gt;= 4 or ny &gt;= 4:            continue        v = [a.copy() for a in u]        v[nx][ny], v[x][y] = v[x][y], v[nx][ny]        now = encode(v)        if now not in dis.keys():            dis[now] = dis[pre] + 1            val[now] = 0            q.put(v)        if dis[now] == dis[pre] + 1:            val[now] = (val[now] + val[pre] * 243 + code[k]) % modans = val[encode(ed)]print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 248","url":"/project-euler/248/","content":"\r\nProject Euler 248\r\n题目\r\nNumbers for\r\nwhich Euler’s totient function equals \\(13!\\)\r\nThe first number n for which \\(\\varphi(n)=13!\\) is \\(6227180929\\).\r\nFind the \\(150,000^{\\text{th}}\\)\r\nsuch number.\r\n解决方案\r\n令\\(M=13!\\)。如果\\(\\varphi(n)=M\\)，那么\\(n\\)的所有质因数\\(p\\)的欧拉函数\\(\\varphi(p)=p-1\\)，都有\\(p-1|M\\)。\r\n那么，先求出\\(M\\)的所有因数\\(d\\)，再将所有是质数的\\(d+1\\)存入数组\\(pr\\)中。\r\n最终，\\(n\\)一定是由数组\\(pr\\)的一些质因子相乘而得。\r\n考虑通过深度优先搜索，枚举出所有\\(\\varphi(n)=M\\)的\\(n\\)值。从大到小枚举所有质因数并逐一尝试，这样做可以有效减少枚举量。\r\n代码\r\nfrom tools import fac, is_prime, divisorsN = 13Q = 150000M = fac(N)pr = [x + 1 for x in divisors(M) if is_prime(x + 1)][::-1]ls = []def dfs(f, n, rest):    if rest == 1:        ls.append(n)    for i in range(f, len(pr)):        p = pr[i]        if rest % (p - 1) == 0:            dfs(i + 1, n * p, rest // (p - 1))            t_n, t_rest = n * p, rest // (p - 1)            while t_rest % p == 0:                t_rest //= p                t_n *= p                dfs(i + 1, t_n, t_rest)dfs(0, 1, M)ls.sort()ans = ls[Q - 1]print(ans)# 16s~17s\r\n","categories":["Project Euler"]},{"title":"Project Euler 250","url":"/project-euler/250/","content":"\r\nProject Euler 250\r\n题目\r\n\\(250250\\)\r\nFind the number of non-empty subsets of \\(\\{1^1, 2^2, 3^3,\\dots, 250250^{250250}\\}\\),\r\nthe sum of whose elements is divisible by \\(250\\). Enter the rightmost \\(16\\) digits as your answer.\r\n解决方案\r\n假设\\(n=250250,m=250\\)\r\n题目可以转化为：在这\\(2^{n}-1\\)个非空子集中，有多少个的子集的和模\\(m\\)的值为\\(0\\)？\r\n记录状态\\(f(i,j)(0\\leq i\\leq n,0\\leq j&lt;\r\nm)\\)为：当前使用了前\\(i\\)个数的情况下，有多少个子集的和对\\(m\\)取模为\\(j\\).\r\n对于第\\(i\\)个数\\(x=i^i\\)而言，有两种决策：取或者是不取。\r\n如果取，就是从\\(f(i-1,(j-x) \\%\r\nm)\\)转移而来。因为加了这一个数后，集合中所有的数和取模都变成了\\(j\\)。\r\n如果不取，那么直接保留上一次的结果，即\\(f(i-1,j)\\)。\r\n一开始什么数都不取的时候（空集），总和为\\(0\\)。最后需要减去空集的情况。\r\n最终可以写出状态转移方程如下：\r\n\\[\r\nf(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i=0\\land j=0 \\\\\r\n  &amp;0 &amp; &amp; \\text{else if}\\quad i=0 \\\\\r\n  &amp;f(i-1,j) + f(i-1,(j-i^i) \\% m) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n求得的答案为\\(f(n,0)-1\\)。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=250250;const int M=250;ll mod=1e16;ll qpow(ll n,ll m,ll mod)&#123;    ll a=1;    for(;m;m&gt;&gt;=1)&#123;        if(m&amp;1) a=a*n%mod;        n=n*n%mod;    &#125;    return a;&#125;ll f[2][M],c[M];int main()&#123;    f[0][0]=1;    for(int i=1,p=1;i&lt;=N;i++,p^=1)&#123;        int x=qpow(i,i,M);        ++c[x];        for(int j=0;j&lt;M;j++)&#123;            f[p][j]=f[p^1][j]+f[p^1][(j-x+M)%M];            if(f[p][j]&gt;=mod) f[p][j]-=mod;        &#125;    &#125;    printf(&quot;%016lld\\n&quot;,(f[N&amp;1][0]-1+mod)%mod);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 249","url":"/project-euler/249/","content":"\r\nProject Euler 249\r\n题目\r\nPrime Subset Sums\r\nLet \\(S = \\{2, 3, 5, \\dots, 4999\\}\\)\r\nbe the set of prime numbers less than \\(5000\\).\r\nFind the number of subsets of \\(S\\),\r\nthe sum of whose elements is a prime number.\r\nEnter the rightmost \\(16\\) digits as\r\nyour answer.\r\n解决方案\r\n我们使用动态规划的思想解决集合的计数问题。\r\n令\\(N=5000,M\\)为小于\\(N\\)的质数个数。\r\n通过筛法找出质数后，存放在数组\\(pr\\)中。令\\(f(i,j)(0\\le i\\le M,0\\le j\\le \\sum_{k=1}^i\r\npr[k])\\)为前\\(i\\)个质数组成的集合中，有多少个和为\\(j\\)的子集。不难列出如下状态转移方程：\r\n\\[\r\nf(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i=0\\land j=0 \\\\\r\n  &amp;f(i-1,j) &amp; &amp; \\text{else if}\\quad j&lt;pr[i] \\\\\r\n  &amp;f(i-1,j)+f(i-1,j-pr[i]) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n这是一个较为典型的01背包问题，对于方程最后一行，\\(pr[i]\\)要么被使用了，将所有\\(f(i-1,j-pr[i])\\)的所有方案都添加一个\\(pr[i]\\)；要么没被使用，直接从上一次的状态\\(f(i-1,j)\\)直接记录。\r\n最终答案为\\(\\sum_{j\\in\r\npr}f(M,j)\\)。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=5000;ll mod=1e16;const int M = N * N / log2(N)+24;bool b[M];int pr[M],m=0;ll f[M];void sieve(int n) &#123;    memset(b, 0, sizeof(b));    m = 0;    for (int i = 2; i &lt;= n; i++) &#123;        if (b[i]) continue;        pr[++m] = i;        for (int j = i + i; j &lt;= n; j += i)            b[j] = 1;    &#125;&#125;int main() &#123;    sieve(N - 1);    int sum = 0;    f[0] = 1;    for (int i = 1; i &lt;= m; i++) &#123;        int p = pr[i];        sum += p;        for (int j = sum; j &gt;= p; j--) &#123;            f[j] += f[j - p];            if (f[j] &gt;= mod) f[j] -= mod;        &#125;    &#125;    sieve(sum);    ll ans = 0;    for (int i = 1; i &lt;= m; i++)        ans = (ans + f[pr[i]]) % mod;    printf(&quot;%lld\\n&quot;, ans);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 25","url":"/project-euler/25/","content":"\r\nProject Euler 25\r\n题目\r\n\\(1000\\)-digit Fibonacci number\r\nThe Fibonacci sequence is defined by the recurrence relation: \\[F_1 = 1\\quad F_2= 1\\] \\[F_n = F_{n-1} + F_{n-2}\\] Hence the first\r\n\\(12\\) terms will be: \\[\\begin{aligned}F_1&amp;=1\\\\F_2&amp;=1\\\\F_3&amp;=2\\\\F_4&amp;=3\\\\F_5&amp;=5\\\\F_6&amp;=8\\\\F_7&amp;=13\\\\F_8&amp;=21\\\\F_9&amp;=34\\\\F_{10}&amp;=55\\\\F_{11}&amp;=89\\\\F_{12}&amp;=144\\\\\\end{aligned}\\]\r\nThe \\(12\\text{th}\\) term, \\(F_{12}\\), is the first term to contain\r\nthree digits.\r\nWhat is the first term in the Fibonacci sequence to contain \\(1000\\) digits?\r\n解决方案\r\n利用Python可以做大数运算的特点，直接迭代运算。\r\n代码\r\nfrom itertools import countN = 1000a = b = 1for i in count(1, 1):    if len(str(a)) == N:        ans = i        break    a, b = b, a + bprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 251","url":"/project-euler/251/","content":"\r\nProject Euler 251\r\n题目\r\nCardano Triplets\r\nA triplet of positive integers \\((a,b,c)\\) is called a Cardano Triplet if it\r\nsatisfies the condition:\r\n\\[\\sqrt[3]{a + b \\sqrt{c}} + \\sqrt[3]{a -\r\nb \\sqrt{c}} = 1\\]\r\nFor example, \\((2,1,5)\\) is a\r\nCardano Triplet.\r\nThere exist \\(149\\) Cardano Triplets\r\nfor which \\(a+b+c \\le 1000\\).\r\nFind how many Cardano Triplets exist such that \\(a+b+c \\le 110,000,000\\).\r\n解决方案\r\n本解决方案参考了Thread的内容。\r\n先将整个方程去除根号：\r\n\r\n等式两边立方，整理后得\r\n\r\n\\[2a+3\\sqrt[3]{a^2-b^2c}\\cdot(\\sqrt[3]{a +\r\nb \\sqrt{c}} + \\sqrt[3]{a - b \\sqrt{c}})=1\\]\r\n\r\n代入原来的\\(\\sqrt[3]{a + b \\sqrt{c}} +\r\n\\sqrt[3]{a - b \\sqrt{c}}=1\\)，移项后，整理得：\r\n\r\n\\[2a-1=-3\\sqrt[3]{a^2-b^2c}\\]\r\n\r\n等式两边再取立方，整理后得：\r\n\r\n\\[8a^3+15a^2+6a-1=27b^2c\\qquad(1)\\]\r\n原式等价于求\\(8a^3+15a^2+6a-1=27b^2c\\)的解。\r\n左边的式子可以分解为\\((a+1)^2(8a-1)\\)，不难发现，只有当\\(a\\)满足\\(a\\equiv\r\n2 \\pmod 3\\)时，\\(3\\mid\r\n(a+1)^2(8a-1)\\)。\r\n因此，令\\(a=3k+2,k\\ge0\\)，将此式代回\\((1)\\)，整理后，问题转化为求有多少个三元组\\((k,b,c)\\)，满足以下方程：\r\n\\[(k+1)^2(8k+5)=b^2c\\qquad\r\n(2)\\]\r\n其中，\\(k\\ge0,b&gt;0,c&gt;0,3k+2+b+c\\le\r\nN,N=110000000\\)。\r\n观察到\\((2)\\)两侧都是一个平方项乘以一个一次项，令\\(g=\\gcd(k+1,b)\\)，那么令\\(p,q\\)满足\\(k+1=gp,b=gq\\)，其中\\(\\gcd(p,q)=1\\)。那么将\\(p,q\\)代入\\((2)\\)，有\r\n\\[p^2(8k+5)=q^2c\\qquad(3)\\]\r\n由于\\(\\gcd(p,q)=1\\)，因此存在\\(m\\)，使得\\(c=mp^2,8k+5=mq^2\\)。\r\n联立\\(a=3k+2,b=gq,c=mp^2,k+1=gp,8k+5=mq^2\\)，可将问题转化为如下形式：\r\n有多少个整数三元组\\((a=3gp-1,b=gq,c=mp^2)\\)满足以下条件：\r\n\r\n\\(\\gcd(p,q)=1\\)\r\n\\(8gp=mq^2+3\\)\r\n\\(3gp+gq+mp^2\\le N+1\\)\r\n\\(p,q,g,m&gt;0\\)\r\n\r\n我们可以枚举每对互质的\\((p,q)\\)后进行统计。使用扩展欧几里得算法来计算出条件\\(2\\)的\\(g,m\\)值，假设一对最小正整数解为\\((g_0,m_0)\\)，那么这个方程的通解为\\(g&#39;=tq^2+g_0,m&#39;=8tp+m_0\\)，其中\\(t\\ge 0\\)。最终，将通解代入条件\\(3\\)，那么\\(t\\)满足\\(t(q^3+3pq^2+8p^3)+g_0q+m_0p^2+3g_0p\\le\r\nN+1\\)。统计满足条件的所有\\(t\\)的个数。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll N = 110000000;ll ex_gcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123;    if(b==0)&#123;        x=1;y=0;return a;    &#125;    ll g=ex_gcd(b,a%b,x,y);    ll z=x-(a/b)*y;    x=y;y=z;return g;&#125;//解不定方程ax+my=c。ll congruence(ll a,ll c,ll m,ll &amp;x,ll &amp;y) &#123;    ll g = ex_gcd(a, m, x, y);    if (c % g != 0) return -1;    ll mc = c / g;    ll ma = abs(a / g);    y *= mc;    y = (y % ma + ma) % ma;    x = (c - m * y) / a;    return abs(g);&#125;int main()&#123;    ll g,m;    //两个上限暂时还没证明出怎么来的。    ll mxQ = sqrt(((N+1)/3*8-3)/5)+3;    ll mxP = sqrt((N+1)/5)+3;    ll ans=0;    for(ll q=1;q&lt;=mxQ;q+=2)&#123;        for(ll p=1;p&lt;=mxP&amp;&amp;q*q*3+p*p*8+q*8&lt;=N*8-1;p++)&#123;            if(congruence(p*8,3,-q*q,g,m) != 1)                continue;            ll s = g*q+m*p*p+g*p*3,d = q*q*q+p*q*q*3+p*p*p*8;            ans += (s &lt;= N + 1 ? (N+1-s)/d+1:0);        &#125;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 253","url":"/project-euler/253/","content":"\r\nProject Euler 253\r\n题目\r\nTidying up\r\nA small child has a “number caterpillar” consisting of forty jigsaw\r\npieces, each with one number on it, which, when connected together in a\r\nline, reveal the numbers \\(1\\) to \\(40\\) in order.\r\nEvery night, the child’s father has to pick up the pieces of the\r\ncaterpillar that have been scattered across the play room. He picks up\r\nthe pieces at random and places them in the correct order. As the\r\ncaterpillar is built up in this way, it forms distinct segments that\r\ngradually merge together. The number of segments starts at zero (no\r\npieces placed), generally increases up to about eleven or twelve, then\r\ntends to drop again before finishing at a single segment (all pieces\r\nplaced).\r\nFor example:\r\n\r\n\r\n\r\nPiece Placed\r\nSegments So Far\r\n\r\n\r\n\r\n\r\n\\(12\\)\r\n\\(1\\)\r\n\r\n\r\n\\(4\\)\r\n\\(2\\)\r\n\r\n\r\n\\(29\\)\r\n\\(3\\)\r\n\r\n\r\n\\(6\\)\r\n\\(4\\)\r\n\r\n\r\n\\(34\\)\r\n\\(5\\)\r\n\r\n\r\n\\(5\\)\r\n\\(4\\)\r\n\r\n\r\n\\(35\\)\r\n\\(4\\)\r\n\r\n\r\n\\(\\dots\\)\r\n\\(\\dots\\)\r\n\r\n\r\n\r\nLet \\(M\\) be the maximum number of\r\nsegments encountered during a random tidy-up of the caterpillar.\r\nFor a caterpillar of ten pieces, the number of possibilities for each\r\n\\(M\\) is\r\n\r\n\r\n\r\nM\r\nPossibilities\r\n\r\n\r\n\r\n\r\n\\(1\\)\r\n\\(512\\)\r\n\r\n\r\n\\(2\\)\r\n\\(250912\\)\r\n\r\n\r\n\\(3\\)\r\n\\(1815264\\)\r\n\r\n\r\n\\(4\\)\r\n\\(1418112\\)\r\n\r\n\r\n\\(5\\)\r\n\\(144000\\)\r\n\r\n\r\n\r\nso the most likely value of \\(M\\) is\r\n\\(3\\) and the average value is \\(\\dfrac{385643}{113400} = 3.400732\\),\r\nrounded to six decimal places. The most likely value of \\(M\\) for a forty-piece caterpillar is \\(11\\); but what is the average value of\r\n\\(M\\)?\r\nGive your answer rounded to six decimal places.\r\n解决方案\r\n本题使用动态规划的思想解决。\r\n令\\(N=40,M=\\left\\lceil\\dfrac{M+1}{2}\\right\\rceil\\)。假设\\(f(i,j,k)(0&lt; k\\le M)\\)表示已经放置了\\(i\\)件拼图，并已经形成了\\(j\\)个连续的段，并在放置的过程中，段数不超过\\(k\\)的放法。那么状态转移方程就可以写作：\r\n\\[\r\nf(i,j,k)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1 &amp; &amp; \\text{if}\\quad i=1\\land j=1 \\\\\r\n  &amp;0 &amp; &amp; \\text{else if}\\quad i=1\\lor j\\le 0\\lor j&gt; k \\\\\r\n  &amp;j\\cdot f(i-1,j-1,k)+j\\cdot f(i-1,j+1,k)+2j\\cdot f(i-1,j,k)&amp;\r\n&amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n对于方程的最后一行，状态\\(f(i-1,j-1,k)\\)中有\\(j-1\\)个不同的段，那么我们拥有\\(s\\)个位置放置一块拼图形成一个新的段；状态\\(f(i-1,j+1,k)\\)中有\\(j+1\\)个段，那么我们有\\(j\\)个位置把相邻的两个段通过一个拼图形成一个新的段；状态\\(f(i-1,j,s)\\)中的每个段，直接在左边或者右边延伸，那么就有\\(2s\\)种延伸方式。\r\n那么，最终答案为：\r\n\\[\\dfrac{\\sum_{i=1}^M\r\ni\\cdot(f(N,1,i)-f(N,1,i-1))}{N!}\\]\r\n代码\r\nfrom tools import facN = 40M = (N + 1) &gt;&gt; 1mp = &#123;&#125;def f(n, m, p):    if n == 1:        return int(m == 1)    elif m &lt;= 0 or m &gt; p:        return 0    if (n, m, p) not in mp.keys():        mp[n, m, p] = f(n - 1, m - 1, p) * m + f(n - 1, m + 1, p) * m + f(n - 1, m, p) * m * 2    return mp[n, m, p]ans = sum(i * (f(N, 1, i) - f(N, 1, i - 1)) for i in range(1, M + 1)) / fac(N)print(&quot;&#123;:.6f&#125;&quot;.format(ans))\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 255","url":"/project-euler/255/","content":"\r\nProject Euler 255\r\n题目\r\nRounded Square Roots\r\nWe define the rounded-square-root of a positive integer n as\r\nthe square root of n rounded to the nearest integer.\r\nThe following procedure (essentially Heron’s method adapted to\r\ninteger arithmetic) finds the rounded-square-root of \\(n\\):\r\nLet \\(d\\) be the number of digits of\r\nthe number \\(n\\).\r\nIf \\(d\\) is odd, set \\(x_0 = 2 \\times 10^{(d-1)/2}\\).\r\nIf \\(d\\) is even, set \\(x_0 = 7 \\times 10^{(d-2)/2}\\).\r\nRepeat:\r\n\\[x_{k+1} = \\Biggl\\lfloor{\\dfrac{x_k +\r\n\\lceil{n / x_k}\\rceil}{2}}\\Biggr\\rfloor\\]\r\nuntil \\(x_{k+1} = x_k\\).\r\nAs an example, let us find the rounded-square-root of \\(n = 4321\\).\r\n\\(n\\) has \\(4\\) digits, so \\(x_0 = 7 \\times 10^{(4-2)/2} = 70\\). \\[x_1 = \\Biggl\\lfloor{\\dfrac{70 + \\lceil{4321 /\r\n70}\\rceil}{2}}\\Biggr\\rfloor = 66\\] \\[x_2 = \\Biggl\\lfloor{\\dfrac{66 + \\lceil{4321 /\r\n66}\\rceil}{2}}\\Biggr\\rfloor = 66\\]\r\nSince \\(x_2 = x_1\\), we stop\r\nhere.\r\nSo, after just two iterations, we have found that the\r\nrounded-square-root of \\(4321\\) is\r\n\\(66\\) (the actual square root is \\(65.7343137\\dots\\)).\r\nThe number of iterations required when using this method is\r\nsurprisingly low. For example, we can find the rounded-square-root\r\nof a \\(5\\)-digit integer \\((10,000 \\le n \\le 99,999)\\) with an average\r\nof \\(3.2102888889\\) iterations (the\r\naverage value was rounded to \\(10\\)\r\ndecimal places).\r\nUsing the procedure described above, what is the average number of\r\niterations required to find the rounded-square-root of a \\(14\\)-digit number \\((10^{13} \\le n &lt; 10^{14})\\)?\r\nGive your answer rounded to \\(10\\)\r\ndecimal places.\r\nNote: The symbols \\(\\lfloor x\r\n\\rfloor\\) and \\(\\lceil x\r\n\\rceil\\) represent the\r\nfloor function\r\nand ceiling\r\nfunction respectively.\r\n解决方案\r\n令\\(N=14\\)。\r\n实际上，\\(x_0\\)相对比较接近\\(\\sqrt{n}\\)。注意到迭代算法\\(\\lceil\r\nn/x_k\\rceil\\)的一项，因此从第一步迭代起，\\(n\\)从\\(10^{N-1}\\)到$ 10^N-1\\(，这几个数就按照这个值\\)n/x_0\\(的不同被划分成\\)O()$个连续的区间。接下来对同一个区间里面的数一起进行第一次迭代（注意这轮区间内迭代的结果都相同），然后一起进入下一轮。\r\n为了方便实现，整个迭代过程的模拟使用深度优先搜索。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=14;const ll x0=N&amp;1?pow(10,(N-1)&gt;&gt;1)*2:pow(10,(N-2)&gt;&gt;1)*7;ll cnt=0;void dfs(int f,ll v,ll l,ll r)&#123;    cnt+=r-l+1;    for(ll x=l,y=min(r,(l+v-1)/v*v);x&lt;=r;x=y+1,y=min(x+v-1,r))&#123;        ll w=((x+v-1)/v+v)&gt;&gt;1;        if(w==v) continue;        dfs(f+1,w,x,y);    &#125;&#125;int main()&#123;    ll l=pow(10,N-1),r=pow(10,N)-1;    dfs(1,x0,l,r);    double ans=1.0*cnt/(r-l+1);    printf(&quot;%.10f\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 252","url":"/project-euler/252/","content":"\r\nProject Euler 252\r\n题目\r\nConvex Holes\r\nGiven a set of points on a plane, we define a convex hole to be a\r\nconvex polygon having as vertices any of the given points and not\r\ncontaining any of the given points in its interior (in addition to the\r\nvertices, other given points may lie on the perimeter of the\r\npolygon).\r\nAs an example, the image below shows a set of twenty points and a few\r\nsuch convex holes. The convex hole shown as a red heptagon has an area\r\nequal to \\(1049694.5\\) square units,\r\nwhich is the highest possible area for a convex hole on the given set of\r\npoints.\r\n\r\nFor our example, we used the first \\(20\\) points \\((T_{2k−1},T_{2k})\\), for \\(k=1,2,\\dots,20\\), produced with the\r\npseudo-random number generator:\r\n\\(\\begin{aligned}\r\nS_0&amp;=290797\\\\\r\nS_{n+1}&amp;=S_n^2 \\text{ mod } 50515093\\\\\r\nT_n&amp;=(S_n \\bmod 2000)-1000\r\n\\end{aligned}\\)\r\ni.e. \\((527,144), (−488,732),\r\n(−454,−947), \\dots\\)\r\nWhat is the maximum area for a convex hole on the set containing the\r\nfirst \\(500\\) points in the\r\npseudo-random sequence?\r\nSpecify your answer including one digit after the decimal point.\r\n解决方案\r\n本题将尝试找到所有的凸空洞，并且求出它们的最大值。为了减少程序运行时间，我们尽量减少凸空洞的重复寻找次数，采取的措施是：枚举图中的每一个点\\(A(x_i,y_i)\\)作为整个坐标系的原点，将满足这些条件的点\\((x_j,y_j)\\)舍去：\\(y_j&lt;y_i\\lor (y_j=y_i \\and\r\nx_j&lt;x_i)\\).那么剩下的这些点中，\\(A\\)是最下方的，考虑以\\(A\\)为空洞的一个特定点进行枚举。\r\n那么，将所有的点都按照极角进行排序。考虑如下图的形式，主要思想是从逆时针方向起找到一个个三角形，这些三角形合并后恰好形成一个凸包。\r\n\r\n假设当前一共有\\(m\\)个点，这些点极角排序后，分别标记成\\(B_1,B_2,\\dots,B_m\\)。\r\n考虑状态\\(f(i,j)(1\\le j&lt; i\\le\r\nm)\\)表示逆时针方向上，以\\(\\triangle\r\nAB_iB_j\\)为最后一个三角形的凸包中，最大的面积值。需要注意的是，不存在其它点\\(B_k\\)使得\\(B_k\\)落在\\(\\triangle\r\nAB_iB_j\\)的内部（不包括边界）时，并且\\(O,B_i,B_j\\)不共线时，\\(f(i,j)\\)才是一个合法状态。对于所有不合法的状态，状态值\\(f\\)为\\(0\\)。\r\n那么，\\(f\\)的状态转移方程就可以写成如下形式：\r\n\\[f(i,j)=\\max(S_{\\triangle\r\nAB_iB_j},\\max_{k&lt;j,\\overrightarrow{B_jB_i}\\times\\overrightarrow{B_jB_k}&gt;0}\\{f(j,k)+S_{\\triangle\r\nAB_iB_j}\\})\\]\r\n只要点\\(B_k\\)在向量\\(\\overrightarrow{B_jB_i}\\)的左侧，从而\\(B_i,B_j,B_k\\)形成一个凸形。那么状态\\(f(j,k)\\)所代表的凸包和\\(\\triangle\r\nAB_iB_j\\)合并形成了一个新凸包。\r\n在枚举\\(i\\)时，需要先顺时针找到第一个\\(j\\)，使得\\(O,B_i,B_j\\)先不共线。然后找到所有的\\(k\\)使得\\(\\overrightarrow{B_jB_i}\\times\\overrightarrow{B_jB_k}&gt;0\\)，然后直接进行转移。如果直接这样子实现，那么每次枚举一个原点，就需要\\(O(n^3)\\)的转移，总体时间复杂度为\\(O(n^4)\\).\r\n考虑如此进行：如果我们已经确定了\\(f(i,j)\\)是一个合法状态，那么接下来就去寻找\\(k\\)，使得\\(f(j,k)\\)也是一个合法状态。如果找到一个最大的\\(k_0\\)使得\\(\\overrightarrow{B_jB_i}\\times\\overrightarrow{B_jB_{k_0}}&gt;0\\)，那么对于\\(k=k_0+1,k_0+2,\\dots,j-1,\\overrightarrow{B_jB_i}\\times\\overrightarrow{B_jB_{k}}&lt;0\\)都成立，也就是说，\\(B_j\\)在\\(\\triangle OB_iB_k\\)内部，那么\\(f(i,k)\\)都不是合法的，其都值为\\(0\\)，如下图所示。\r\n\r\n对于所有状态\\(1\\le k&#39;\\le\r\nk_0\\)，有以下说法：\r\n\r\n\\(B_{k&#39;}\\)在向量\\(\\overrightarrow{B_iB_{j}}\\)左侧，它们都是不合法的，因为\\(B_j\\)在\\(\\triangle AB_iB_k\\)内部。\r\n其余情况都可以进行转移。\r\n\r\n那么状态转移方程就可以改写成：\r\n\\[f(i,j)=\\max(S_{\\triangle\r\nAB_iB_j},\\max_{k=1}^{k_0}\\{f(j,k)+S_{\\triangle AB_iB_j}\\})\\]\r\n通过数据结构维护，这个递推式可以通过\\(O(n^2)\\)求出来。\r\n这个思路还提供了一种快速找到合法状态的方案：对于一个状态\\(f(i,j)\\)，计算出来了\\(k_0\\)后，这个\\(k_0\\)将作为下一次求解的\\(j\\)。\r\n另外，对于任意两点\\(B_i,B_j,S_{\\triangle\r\nAB_i,B_j}=|\\overrightarrow{AB_i}\\times\\overrightarrow{AB_j}|\\).\r\n最终答案为\\(\\displaystyle{\\max_{1\\le j\\le\r\ni\\le m}\\{f(i,j)\\}}\\).\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=500;struct P &#123;    ll x, y;    double rad;    P(ll xx=0,ll yy=0):x(xx),y(yy),rad(atan2(y,x))&#123;&#125;    // 向量减法    P operator-(P p) const &#123;        return P(x-p.x,y-p.y);    &#125;    // 向量叉积    ll operator^(P p) const &#123;        return x*p.y-y*p.x;    &#125;    // 极角排序用    bool operator &lt; (P p) const&#123;        return rad&lt;p.rad;    &#125;&#125;p[N+4];int T[N+N+4];int mx=0;int f[N+4][N+4];void solve(vector&lt;P&gt;&amp;v)&#123;    sort(v.begin(),v.end());    int m=v.size();    memset(f,0,sizeof(f));    for(int i=0,j;i&lt;m;i++)&#123;        for(j=i-1;j&gt;=0&amp;&amp;(v[i]^v[j])==0;j--);        bool ok=(j==i-1);        for(int k;j&gt;=0;)&#123;            for(k=j-1;k&gt;=0&amp;&amp;((v[i]-v[j])^(v[k]-v[j]))&lt;0;k--);            int s=abs(v[i]^v[j]);            if(k&gt;=0) s+=f[j][k];            if(ok) f[i][j]=s;            mx=max(mx,s);            j=k;        &#125;        if(ok)&#123;            for(int j=1;j&lt;i;j++)                f[i][j]=max(f[i][j],f[i][j-1]);        &#125;    &#125;&#125;int main()&#123;    T[0]=290797;    for(int i=1;i&lt;=N+N+1;i++)        T[i]=1ll*T[i-1]*T[i-1]%50515093,T[i-1]=T[i-1]%2000-1000;    for(int i=1;i&lt;=N;i++)        p[i]=P(T[2*i-1],T[2*i]);    vector&lt;P&gt;z;    for(int i=1;i&lt;=N;i++)&#123;        z.clear();        for(int j=1;j&lt;=N;j++)&#123;            if(p[j].y&gt;p[i].y||p[j].y==p[i].y&amp;&amp;p[j].x&gt;p[i].x)                z.push_back(p[j]-p[i]);        &#125;        solve(z);    &#125;    double ans=0.5*mx;    printf(&quot;%.1f\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 256","url":"/project-euler/256/","content":"\r\nProject Euler 256\r\n题目\r\nTatami-Free Rooms\r\nTatami are rectangular mats, used to completely cover the floor of a\r\nroom, without overlap.\r\nAssuming that the only type of available tatami has dimensions \\(1\\times2\\), there are obviously some\r\nlimitations for the shape and size of the rooms that can be covered.\r\nFor this problem, we consider only rectangular rooms with integer\r\ndimensions \\(a, b\\) and even size \\(s = a\\cdot b\\).\r\nWe use the term ‘size’ to denote the floor surface area of the room,\r\nand — without loss of generality — we add the condition \\(a\\le b\\).\r\nThere is one rule to follow when laying out tatami: there must be no\r\npoints where corners of four different mats meet.\r\nFor example, consider the two arrangements below for a \\(4\\times4\\) room:\r\n\r\nThe arrangement on the left is acceptable, whereas the one on the\r\nright is not: a red “X” in\r\nthe middle, marks the point where four tatami meet.\r\nBecause of this rule, certain even-sized rooms cannot be covered with\r\ntatami: we call them tatami-free rooms.\r\nFurther, we define \\(T(s)\\) as the\r\nnumber of tatami-free rooms of size \\(s\\).\r\nThe smallest tatami-free room has size \\(s\r\n= 70\\) and dimensions \\(7\\times10\\).\r\nAll the other rooms of size \\(s =\r\n70\\) can be covered with tatami; they are: \\(1\\times70, 2\\times35\\) and \\(5\\times14\\).\r\nHence, \\(T(70) = 1\\).\r\nSimilarly, we can verify that \\(T(1320) =\r\n5\\) because there are exactly \\(5\\) tatami-free rooms of size \\(s = 1320\\):\r\n\\(20\\times66, 22\\times60, 24\\times55,\r\n30\\times44\\) and \\(33\\times40\\).\r\nIn fact, \\(s = 1320\\) is the\r\nsmallest room-size \\(s\\) for which\r\n\\(T(s) = 5\\).\r\nFind the smallest room-size \\(s\\)\r\nfor which \\(T(s) = 200\\).\r\n解决方案\r\n本解决方案参考了Thread中的一些内容。\r\n这篇论文给出了关于每一种房间\\(a\\times b\\)铺满榻榻米的方案数\\(T(a,b)\\)。\r\n分开两种情况讨论：\\(a\\)为奇数和\\(a\\)为偶数的情况。\r\n当\\(a\\)是奇数时，定理\\(2.3\\)指出，\\(a\\times b\\)的铺设方案将会由\\(a\\times(a-1)\\)和\\(a\\times(a+1)\\)的铺设方案组合而成。\r\n因此，如果\\(T(a,b)&gt;0\\)，那么\\(b\\)是偶数，并且存在一个\\(k&gt;0\\)使得：\\(k(a-1)\\le b\\le k(a+1)\\)。换言之，如果\\(T(a,b)=0\\)，那么存在一个\\(k&gt;0\\)使得\\((a+1)\\cdot k+2\\le\r\nb\\le(a-1)\\cdot(k+1)-2\\)，恰好是上面区间的补。\r\n当\\(a\\)为偶数时，定理\\(2.4\\)指出，\\(a\\times b\\)的铺设方案将会由\\(a\\times a,a\\times (a-2),a\\times\r\n1\\)的铺设方案组合而成。其中，\\(a\\times1\\)的铺设方案会出现在\\(a\\times (a-2),a\\times\r\na\\)这两种铺设方案的任意两个之间。并且，\\(a\\times1\\)这种铺设方案还可以出现在第\\(1\\)列或者第\\(n\\)列，也可以不出现。\r\n如果\\(a\\times(a-2)\\)和\\(a\\times a\\)的铺设方案总共有\\(k\\)块，那么\\(a\\times 1\\)的铺设方案块数在\\(k-1\\sim k+1\\)之间。因此，如果\\(T(a,b)&gt;0\\)，那么存在\\(k\\)，使得\\(k(a-2)+k-1\\le b\\le\r\nka+k+1\\)；那么和奇数的情况类似，如果\\(T(a,b)=0\\)，那么存在一个\\(k&gt;0\\)使得\\((a+1)\\cdot k+2\\le\r\nb\\le(a-1)\\cdot(k+1)-2\\)。\r\n最终发现，两种情况的结论是一样的，即一个\\(a\\times\r\nb\\)的偶数面积矩形是无法铺满榻榻米的房间当且仅当存在一个整数\\(k\\)，满足：\r\n\\[(a+1)\\cdot k+2\\le\r\nb\\le(a-1)\\cdot(k+1)-2\\]\r\n因此，第一重循环枚举\\(a\\)，二重枚举\\(k\\)，最终枚举这个区间内的\\(b\\)值即可。\r\n本题上限难以确定，此处假设为\\(N=10^8\\)。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int Q=200;const ll N=100000000ll;int cnt[N+4];int solve()&#123;    for(ll a=1;a*a&lt;=N;a++)&#123;        for(ll k=1;(a+1)*k+2&lt;=(a-1)*(k+1)-2&amp;&amp;a*((a+1)*k+2)&lt;=N;k++)&#123;            for(ll b=(a+1)*k+2;b&lt;=(a-1)*(k+1)-2&amp;&amp;a*b&lt;=N;b++)&#123;                if(a&amp;b&amp;1) continue;                ++cnt[a*b];            &#125;        &#125;    &#125;    for(int i=0;i&lt;=N;i+=2)        if(cnt[i]==Q) return i;&#125;int main()&#123;    int ans = solve();    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["论文"]},{"title":"Project Euler 254","url":"/project-euler/254/","content":"\r\nProject Euler 254\r\n题目\r\nSums of Digit Factorials\r\nDefine \\(f(n)\\) as the sum of the\r\nfactorials of the digits of \\(n\\). For\r\nexample, \\(f(342) = 3! + 4! + 2! =\r\n32\\).\r\nDefine \\(sf(n)\\) as the sum of the\r\ndigits of \\(f(n)\\). So \\(sf(342) = 3 + 2 = 5\\).\r\nDefine \\(g(i)\\) to be the smallest\r\npositive integer \\(n\\) such that \\(sf(n) = i\\). Though \\(sf(342)\\) is \\(5\\), \\(sf(25)\\) is also \\(5\\), and it can be verified that \\(g(5)\\) is \\(25\\).\r\nDefine \\(sg(i)\\) as the sum of the\r\ndigits of \\(g(i)\\). So \\(sg(5) = 2 + 5 = 7\\).\r\nFurther, it can be verified that \\(g(20)\\) is \\(267\\) and \\(\\sum\r\nsg(i)\\) for \\(1 \\le i \\le 20\\)\r\nis \\(156\\).\r\nWhat is \\(\\sum sg(i)\\) for \\(1 \\le i \\le 150\\)?\r\n解决方案\r\n本解决方案参考了Thread中的一些内容。\r\n注意到一个特点：函数\\(f,sf\\)的计算过程中，只和每个数位本身的值有关，和数位在哪个位置无关。因此，\\(g(i)\\)的值一定是一个如此的数：在长度最短的基础上，从高位到低位是非递减的。\r\n这道题目使用了两次贪心思想：\r\n\r\n为了求\\(g(i)\\)时的值\\(n\\)最小，那么\\(f(n)\\)这个值也应该最小，此时\\(f(n)\\)的值至多以一个非\\(9\\)的数开头，然后都以\\(9\\)为结尾（如\\(19,299,9999\\)等）。\r\n根据上述特点，确定好\\(f(n)\\)后，划分\\(f(n)\\)的值时，先尽量取完\\(9\\)，再尽量取\\(8\\)，……，一直到尽量取完\\(1\\)。我们用一个向量\\(\\vec{a}=(a_1,a_2,\\dots,a_8,a_9)\\)来表示这时的取数情况，并且\\(g(i)\\)应该是由\\(a_1\\)个\\(1\\)，\\(a_2\\)个\\(2\\)，……，\\(a_9\\)个\\(9\\)拼接起来成的一个数。此后我们讨论\\(g(i)\\)时，\\(g(i)\\)就用这种向量来表示。\r\n\r\n但是，这种贪心思想在求\\(g(i)\\)，\\(i\\)比较大时是有效的，但是在\\(i\\)比较小时，上述第一次的贪心思想不成立（举个例子，\\(f(59)=363000,f(65)=840,sf(59)=sf(65)=12\\)）。因此为了规避，考虑小范围内（\\(63\\)以下）暴力枚举\\(f(n)\\)的值，大范围内（\\(63\\)及以上）贪心构造\\(f(n)\\)的值。\r\n令\\(s(\\vec{a})=\\sum_{k=1}^9\r\na_k,ds(\\vec{a})=\\sum_{k=1}^9 k\\cdot a_k\\).如果一个向量\\(\\vec{a}\\)比向量\\(\\vec{b}\\)更优，那么\\(s(\\vec{a})&lt;s(\\vec{b})\\)，或者是\\(s(\\vec{a})=s(\\vec{b})\\)并且\\(\\vec{a}\\)的“字典序”要大于\\(\\vec{b}\\)。\r\n令\\(h(i)=(a_1^i,a_2^i,\\dots,a_9^i)\\)是将数\\(i\\)按照上面第二次贪心思想进行划分的结果，用上面定义的向量表示；令\\(t(n)\\)表示\\(n\\)的各位数字之和。对于所有\\(1\\le i\\le 9!\\)，先用贪心的思想预处理出\\(h(i)\\)（注意这时所有的\\(a_9^i=0\\)）。接下来暴力枚举小范围的\\(f(n)\\)值（这里是枚举\\(10^7\\)以下的所有\\(f(n)\\)），那么\\(g(t(f(n)))\\)的一个候选值就是\\(h(f(n))\\)，最终将这些小范围的\\(g(i)\\)中最优的向量求出来。\r\n在大范围内，给定一个\\(i\\)，我们就可以按照贪心思想确定对应的\\(f(n)\\)值，这个值是\\((i\\%9+1)\\cdot\r\n10^{\\left\\lfloor\\frac{i}{9}\\right\\rfloor}-1\\)。确定了\\(f(n)\\)后，就可以按照第一次贪心的思想直接构造出\\(g(i)\\)最优的向量。\r\n最终，将所有最优的向量的\\(ds\\)函数值计算并相加即可。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int Q=150;const int S=9,W=362880,N=63,B=19,MX=1e7;ll pw[B],fac[B];int h[W][S],ds[W],s[W];int sq[N],pq[N][S];// 如果b字典序更大，b更优。bool ok(int a[],int b[]) &#123;    for (int i = 0; i &lt; S; i++)        if (a[i] != b[i]) return a[i] &lt; b[i];    return false;&#125;int main() &#123;    pw[0] = fac[0] = 1;    for (int i = 1; i &lt; B; i++)        pw[i] = pw[i - 1] * 10, fac[i] = fac[i - 1] * i;    // 每个数i，贪心取最大的值，尽量取完，然后再取最小的。h[i][j]表示从i中分出h[i][j]个fac[j]。    for (int i = 0; i &lt; W; i++) &#123;        for (int j = 8, t = i; j &gt; 0; j--) &#123;            h[i][j] = t / fac[j];            ds[i] += h[i][j] * j;            s[i] += h[i][j];            t %= fac[j];        &#125;    &#125;    //1~62时直接暴力枚举。枚举范围是10^7。    for (int fn = 0; fn &lt;= MX; fn++) &#123;        int a = fn / W, b = fn % W;        int sum = 0;        for (int x = fn; x; x /= 10)            sum += x % 10;        if (sum &gt;= N) continue;        //sq[n]：目前最优的g(fn的数位之和)中的数位个数。pq[n]：目前最优的g(fn的数位之和)中的向量。        if (sq[sum] == 0 || sq[sum] &gt; s[b] + a || sq[sum] == s[b] + a &amp;&amp; ok(pq[sum], h[b])) &#123;            sq[sum] = s[b] + a;            for (int i = 0; i &lt; S; i++)                pq[sum][i] = h[b][i];        &#125;    &#125;    ll ans = 0;    for (int i = 1; i &lt;= Q &amp;&amp; i &lt; N; i++) &#123;        ans += sq[i] * 9;        for (int j = 1; j &lt; S; j++)            ans -= pq[i][j] * (9 - j);    &#125;    //63以后全部贪心取9。    for (int i = N; i &lt;= Q; i++) &#123;        ll t = (i % 9 + 1) * pw[i / 9] - 1;        printf(&quot;%lld\\n&quot;,t);        ans += (t / W) * 9 + ds[t % W];    &#125;    printf(&quot;%lld\\n&quot;, ans);&#125;\r\n","categories":["Project Euler"],"tags":["贪心"]},{"title":"Project Euler 259","url":"/project-euler/259/","content":"\r\nProject Euler 259\r\n题目\r\nReachable Numbers\r\nA positive integer will be called reachable if it can result\r\nfrom an arithmetic expression obeying the following rules:\r\n\r\nUses the digits 1 through 9, in that order and exactly once\r\neach.\r\nAny successive digits can be concatenated (for example, using the\r\ndigits 2, 3 and 4 we obtain the number 234).\r\nOnly the four usual binary arithmetic operations (addition,\r\nsubtraction, multiplication and division) are allowed.\r\nEach operation can be used any number of times, or not at all.\r\nUnary\r\nminus is not allowed.\r\nAny number of (possibly nested) parentheses may be used to define\r\nthe order of operations.\r\n\r\nFor example, \\(42\\) is reachable,\r\nsince \\((1/23) *((4*5)-6) * (78-9) =\r\n42\\).\r\nWhat is the sum of all positive reachable integers?\r\n解决方案\r\n本题的做法和区间动态规划的进行做法比较像。\r\n如果现在要枚举\\(l,l+1,\\dots,r-1,r\\)这一些数组成的表达式的值，并存放在集合\\(st[l][r]\\)中。那么我们可以对于\\(\\forall k,l\\le k&lt; r\\)，枚举每个数\\(x\\in st[l][k],y\\in\r\nst[k+1][r]\\)，并将这些数通过任何一种运算，将运算结果（也就是\\(x+y,x-y,xy,x/y\\)）存放在集合\\(st[l][r]\\)中。当\\(y\\neq 0\\)时才能做除法运算。\r\n通过这种枚举方式，最终只需要判断集合\\(st[1][9]\\)存放的数是否为正整数即可。\r\n为了方便和效率，本题没有采用分数进行实现，而是使用一个误差用于判断这个数是否为整数。另外，如果做除法时除数的绝对值大于\\(10^5\\)，那么不允许做（因为做出来的结果，无法用一个数乘回去，使得分母被消除，避免诸如\\(\\dfrac{1}{23456789}\\)这种数混入答案）。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int M=9;unordered_set&lt;double&gt;st[10][10];unordered_set&lt;int&gt;ok;double eps=1e-6;int main()&#123;    for(int i=1;i&lt;=M;i++)&#123;        double w=0;        for(int j=i;j&lt;=M;j++)&#123;            w=w*10+j;            st[i][j].insert(w);        &#125;    &#125;    for(int len=2;len&lt;=M;len++)&#123;        for(int l=1;l+len-1&lt;=M;l++)&#123;            int r=l+len-1;            for(int k=l;k&lt;r;k++)&#123;                for(double vl:st[l][k]) for(double vr:st[k+1][r])&#123;                    st[l][r].insert(vl+vr);                    st[l][r].insert(vl-vr);                    st[l][r].insert(vl*vr);                    if(abs(vr)&gt;eps&amp;&amp;abs(vr)&lt;100000)                        st[l][r].insert(vl/vr);                &#125;            &#125;        &#125;    &#125;    for(double x:st[1][M])        if(abs(x-round(x))&lt;eps)&#123;            int w=round(x);            if(w&gt;0) ok.insert(w);        &#125;    ll ans=0;    for(int x:ok) ans+=x;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 258","url":"/project-euler/258/","content":"\r\nProject Euler 258\r\n题目\r\nA lagged Fibonacci sequence\r\nA sequence is defined as:\r\n\r\n\\(g_k = 1\\), for \\(0 \\leq k \\leq 1999\\)\r\n\\(g_k = g_{k-2000} + g_{k-1999}\\),\r\nfor \\(k \\geq 2000\\)\r\n\r\nFind \\(g_k \\bmod 20092010\\) for\r\n\\(k = 10^{18}\\).\r\n哈密顿-凯莱(Caylay-Camilton)定理\r\n如果一个\\(n\\)阶矩阵\\(A\\)的特征多项式为\\(f(\\lambda)=|A-\\lambda I|=\\sum_{i=0}^n\r\nb_i\\lambda^i\\)，其中\\(b^i\\)为系数。那么矩阵多项式\\(f(A)=\\sum_{i=0}^nb_iA^i\\)满足\\(f(A)=O\\).\r\n线性递推\r\n对于一个线性递推\\(a_n=\\sum_{j=1}^kc_ja_{n-j}\\)，可以构造如下矩阵进行\\(O(k^3\\log n)\\)的线性递推计算：\r\n\\[\r\n\\begin{bmatrix}\r\nc_1 &amp; c_2 &amp; c_3 &amp;\\cdots &amp;c_{k-1} &amp; c_k\\\\\r\n1 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0\\\\\r\n0 &amp; 1 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0\\\\\r\n\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp;\r\n\\vdots\\\\\r\n0 &amp; 0 &amp; 0 &amp;\\cdots &amp; 0 &amp; 0\\\\\r\n0 &amp; 0 &amp; 0 &amp;\\cdots &amp; 1 &amp; 0\r\n\\end{bmatrix}\r\n\\begin{bmatrix}\r\na_{n-1}\\\\\r\na_{n-2}\\\\\r\na_{n-3}\\\\\r\n\\vdots\\\\\r\na_{n-k+1}\\\\\r\na_{n-k}\r\n\\end{bmatrix}\r\n=\r\n\\begin{bmatrix}\r\na_n\\\\\r\na_{n-1}\\\\\r\na_{n-2}\\\\\r\n\\vdots\\\\\r\na_{n-k+2}\\\\\r\na_{n-k+1}\r\n\\end{bmatrix}\r\n\\]\r\n令\\(A=\\begin{bmatrix}\r\nc_1 &amp; c_2 &amp; c_3 &amp;\\cdots &amp;c_{k-1} &amp; c_k\\\\\r\n1 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0\\\\\r\n0 &amp; 1 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0\\\\\r\n\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp;\r\n\\vdots\\\\\r\n0 &amp; 0 &amp; 0 &amp;\\cdots &amp; 0 &amp; 0\\\\\r\n0 &amp; 0 &amp; 0 &amp;\\cdots &amp; 1 &amp; 0\r\n\\end{bmatrix},x=\r\n\\begin{bmatrix}\r\na_{k-1}\\\\\r\na_{k-2}\\\\\r\na_{k-3}\\\\\r\n\\vdots\\\\\r\na_1\\\\\r\na_0\r\n\\end{bmatrix}\\)\r\n解决方案\r\n可以知道，矩阵\\(A\\)的特征多项式为\\(f(\\lambda)=|A-\\lambda I|=\\lambda^k-(\\sum_{j=1}^k\r\nc_j \\lambda^{k-j})\\)。\r\n代入Caylay-Camilton定理，可以发现，\\(A^k=\\sum_{j=1}^k c_j A^{k-j}\\)。\r\n由题目可知\\(A^{2000}=A+I\\)。\r\nCaylay-Camilton定理说明，任意\\(m\\geq\r\nk\\)的矩阵幂\\(A^k\\)都可以表示成一个为\\(\\sum_{i=0}^{k-1}\r\nv_iA^i\\)的矩阵多项式，其中\\(v_i\\)为系数。\r\n而为了求\\(a_n\\)，可以计算\\(A^nx\\)，然后取向量\\(A^nx\\)的最后一个值\\((A^nx)_{k-1}\\)即可。\r\n那么令\\(A^n=\\sum_{i=0}^{k-1}\r\nv_iA^i\\)。\r\n可以知道，\\(A^nx=\\sum_{i=0}^{k-1}\r\nv_iA^ix\\)。\r\n系数\\(v_i\\)可以通过快速幂算法进行多项式卷积进行计算，然后将卷积结果系数大于等于\\(k\\)的部分通过矩阵多项式回退到小于\\(k\\)。\r\n最终结果为\\(a_n=\\sum_{i=0}^{k-1} v_i\\cdot\r\na_i\\)\r\n原因：容易发现，计算\\(Ax\\)只是将整个向量\\(x\\)向下平移了一次，新的值将在向量\\(x\\)上面填充。\r\n因此，不必要将整个向量\\(A^ix\\)计算出来，只需要将最后一个值\\((A^ix)_{k-1}\\)计算出来，并与系数相乘即可，因为此时的\\(i\\)不会发生\\(i\\geq k\\)的情况。\r\n代码\r\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int M=2000;ll N=1e18;ll mod = 20092010;// a代表递推式的前M个值ll a[M];// p代表Hamilton-Cayley而来的矩阵多项式的系数，题中为F(A)=A^2000=A+Ill p[M];// b代表A^(2^i)时所有的A^(2^i)=sum from j=0 to M-1 A^j*b_j时系数b_j的值。ll b[M];// v代表解决方案所指的v。ll v[M];void mul_ploy(ll a[M],ll b[M],ll p[M])&#123;    //做的是乘法，对应的就是多项式系数的卷积。    ll c[M&lt;&lt;1];memset(c,0,sizeof(c));    for(int i=0;i&lt;M;i++)        for(int j=0;j&lt;M;j++)            c[i+j]=(c[i+j]+a[i]*b[j])%mod;    //利用递推式F(A)的值，将&gt;=M的所有临时系数转化成&lt;M的系数。    for(int i=M*2-1;i&gt;=M;i--)        for(int j=0;j&lt;M;j++)            c[i-M+j]=(c[i-M+j]+c[i]*p[j])%mod;    for(int i=0;i&lt;M;i++)        a[i]=c[i];&#125;int main()&#123;    for(int i=0;i&lt;M;i++)        a[i]=1;    p[0]=p[1]=1;    b[1]=1;    v[0]=1;    for(;N;N&gt;&gt;=1)&#123;        if(N&amp;1) mul_ploy(v,b,p);        mul_ploy(b,b,p);    &#125;    ll ans=0;    //需要注意的是，当向量和一个矩阵相乘后，我们只要向量中的第一个值。因为向量乘一次这个矩阵递推式，那么所有值都会前移一次。    for(int i=0;i&lt;M;i++)        ans=(ans+v[i]*a[i])%mod;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 26","url":"/project-euler/26/","content":"\r\nProject Euler 26\r\n题目\r\nReciprocal cycles\r\nA unit fraction contains \\(1\\) in\r\nthe numerator. The decimal representation of the unit fractions with\r\ndenominators \\(2\\) to \\(10\\) are given:\r\n\\[\\begin{aligned}\r\n\\frac 1 2 &amp;= 0.5\\\\\r\n\\frac 1 3 &amp;= 0.(3)\\\\\r\n\\frac 1 4 &amp;= 0.25\\\\\r\n\\frac 1 5 &amp;= 0.2\\\\\r\n\\frac 1 6 &amp;= 0.1(6)\\\\\r\n\\frac 1 7 &amp;= 0.(142857)\\\\\r\n\\frac 1 8 &amp;= 0.125\\\\\r\n\\frac 1 9 &amp;= 0.(1)\\\\\r\n\\frac 1 {10} &amp;= 0.1\\\\\r\n\\end{aligned}\\]\r\nWhere \\(0.1(6)\\) means \\(0.166666\\ldots\\), and has a \\(1\\)-digit recurring cycle. It can be seen\r\nthat \\(\\dfrac{1}{7}\\) has a \\(6\\)-digit recurring cycle.\r\nFind the value of \\(1000\\) for which\r\n\\(\\dfrac{1}{d}\\) contains the longest\r\nrecurring cycle in its decimal fraction part.\r\n解决方案\r\n做竖式除法，本质上是每次将上一次的结果作为余数，乘以\\(10\\)，填上被除数后面一位后（不过，本题的被除数只有一开始的1，往后都是\\(0\\)）的结果再做一次带余的整数除法。\r\n在这道题，只要余数开始了循环，那么就可以根据上一次到达这个余数的时间计算周期。\r\n以\\(\\dfrac{2}{11}=0.181818\\dots\\)为例。\r\n\\(2*10 \\% 11 = 9,\\lfloor2* 10 / 11\\rfloor =\r\n1\\)\r\n\\(9*10 \\% 11 = 2,\\lfloor9* 10 / 11\\rfloor =\r\n8\\)\r\n余数\\(2\\)出现在了一开始的结果中，发生了循环，其长度为\\(2\\)。小数也计算了出来，分别为\\(1\\)和\\(8\\)。\r\n因此，在这个数据范围下，循环节长度能以线性的时空复杂度计算出来。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;const int N=1000;int f[N+4];int main()&#123;    int mx=0,ans=0;    for(int x=2;x&lt;N;x++)&#123;        memset(f,-1,sizeof(f));        int w=0;        for(int j=1,k=0;j;j=j*10%x)&#123;            if(f[j]!=-1)&#123;                w=k-f[j];                break;            &#125;            f[j]=k++;        &#125;        if(w&gt;mx) mx=w,ans=x;    &#125;    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 260","url":"/project-euler/260/","content":"\r\nProject Euler 260\r\n题目\r\nStone Game\r\nA game is played with three piles of stones and two players.\r\nAt her turn, a player removes one or more stones from the piles.\r\nHowever, if she takes stones from more than one pile, she must remove\r\nthe same number of stones from each of the selected piles. In other\r\nwords, the player chooses some \\(N&gt;0\\) and removes:\r\n\r\n\\(N\\) stones from any single pile;\r\nor\r\n\\(N\\) stones from each of any two\r\npiles (\\(2N\\) total); or\r\n\\(N\\) stones from each of the three\r\npiles (\\(3N\\) total).\r\n\r\nThe player taking the last stone(s) wins the game. A winning\r\nconfiguration is one where the first player can force a win.For\r\nexample, \\((0,0,13), (0,11,11)\\) and\r\n\\((5,5,5)\\) are winning configurations\r\nbecause the first player can immediately remove all stones.\r\nA losing configuration is one where the second player can\r\nforce a win, no matter what the first player does.For example, \\((0,1,2)\\) and \\((1,3,3)\\) are losing configurations: any\r\nlegal move leaves a winning configuration for the second player.\r\nConsider all losing configurations \\((x_i,y_i,z_i)\\) where \\(x_i \\le y_i \\le z_i \\le 100\\).We can verify\r\nthat \\(\\sum(x_i+y_i+z_i) = 173895\\) for\r\nthese.\r\nFind \\(\\sum(x_i+y_i+z_i)\\) where\r\n\\((x_i,y_i,z_i)\\) ranges over the\r\nlosing configurations with \\(x_i \\le y_i \\le\r\nz_i \\le 1000\\).\r\n解决方案\r\n令\\(N=1000\\)。这是一个无偏博弈，我们可以将游戏的状态视为有向无环图上的一个个节点。\r\n\r\n一个状态是必败状态，当且仅当它的所有后继的状态都是必胜状态。\r\n一个状态是必败状态，当且仅当它存在一个后继的状态是必败状态。\r\n由于取完所有石头就是胜利，因此没有后继的状态\\((0,0,0)\\)是必败状态。\r\n\r\n那么，对于一个状态\\((x,y,z)\\)，它有以下这么多种后继状态：\r\n\\(\\begin{aligned}\r\n&amp; (x-s,y,z),1\\le s\\le x\\\\\r\n&amp; (x,y-s,z),1\\le s\\le y\\\\\r\n&amp; (x,y,z-s),1\\le s\\le z\\\\\r\n&amp; (x,y-s,z-s),1\\le s\\le \\min(y,z)\\\\\r\n&amp; (x-s,y,z-s),1\\le s\\le \\min(x,z)\\\\\r\n&amp; (x-s,y-s,z),1\\le s\\le \\min(x,y)\\\\\r\n&amp; (x-s,y-s,z-s),1\\le s\\le \\min(x,y,z)\\\\\r\n\\end{aligned}\\)\r\n那么，当我们考虑一个状态\\((x,y,z)\\)的类型时，需要线性的时间复杂度。程序总体时间复杂度为\\(O(N^4)\\)，这明显是不能接受的。\r\n我们尝试将上面的每一种后继状态“集合”起来。然后分别判断整个集合里面是否都是存放的必胜态。\r\n有一些状态的分量因为大家都减去了\\(s\\)，但是其之间相对的差值仍然不会改变，考虑使用这些不变的相对差值将状态集中起来，那么可以如下集中：\r\n\\(\\begin{aligned}\r\n&amp; (x-s,y,z)\\rightarrow s_1(y,z)\\\\\r\n&amp; (x,y-s,z)\\rightarrow s_1(x,z)\\\\\r\n&amp; (x,y,z-s)\\rightarrow s_1(x,y)\\\\\r\n&amp; (x,y-s,z-s)\\rightarrow s_2(x,z-y)\\\\\r\n&amp; (x-s,y,z-s)\\rightarrow s_2(y,z-x)\\\\\r\n&amp; (x-s,y-s,z)\\rightarrow s_2(z,y-x)\\\\\r\n&amp; (x-s,y-s,z-s)\\rightarrow s_3(y-x,z-y)\\\\\r\n\\end{aligned}\\)\r\n在判断状态\\((x,y,z)\\)的类型时，只需要以常数时间维护好这些\\(s\\)值，然后就能够以常数时间判断。最终时间复杂度为\\(O(N^3)\\)。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;typedef long long ll;const int N = 1000;bool s1[N + 1][N + 1];bool s2[N + 1][N + 1];bool s3[N + 1][N + 1];int main() &#123;    ll ans=0;    for (int x = 0; x &lt;= N; x++)        for (int y = x; y &lt;= N; y++)            for (int z = y; z &lt;= N; z++) &#123;                if (!(s3[y - x][z - y] || s2[z][y - x] || s2[y][z - x] || s2[x][z - y] || s1[y][z] || s1[x][z] || s1[x][y])) &#123;                    s3[y - x][z - y] = true;                    s2[z][y - x] = true;                    s2[y][z - x] = true;                    s2[x][z - y] = true;                    s1[x][y] = true;                    s1[x][z] = true;                    s1[y][z] = true;                    ans += x + y + z;                &#125;            &#125;    printf(&quot;%lld\\n&quot;, ans);&#125;\r\n","categories":["Project Euler"],"tags":["博弈论"]},{"title":"Project Euler 265","url":"/project-euler/265/","content":"\r\nProject Euler 265\r\n题目\r\nBinary Circles\r\n\\(2^N\\) binary digits can be placed\r\nin a circle so that all the \\(N\\)-digit\r\nclockwise subsequences are distinct.\r\nFor \\(N=3\\), two such circular\r\narrangements are possible, ignoring rotations:\r\n\r\nFor the first arrangement, the \\(3\\)-digit subsequences, in clockwise order,\r\nare: \\(000, 001, 010, 101, 011, 111,\r\n110\\) and \\(100\\).\r\nEach circular arrangement can be encoded as a number by concatenating\r\nthe binary digits starting with the subsequence of all zeros as the most\r\nsignificant bits and proceeding clockwise. The two arrangements for\r\n\\(N=3\\) are thus represented as \\(23\\) and \\(29\\):\r\n\\[\\begin{aligned}\r\n00010111_2 = 23\\\\\r\n00011101_2 = 29\r\n\\end{aligned}\\]\r\nCalling \\(S(N)\\) the sum of the\r\nunique numeric representations, we can see that \\(S(3) = 23 + 29 = 52\\). Find \\(S(5)\\).\r\n解决方案\r\n本题没有太多需要注意的地方。直接把一个个二进制数视为一个节点，每个节点都有两条出边。然后再在图上寻找哈密顿回路即可。\r\nOEIS上的数列A016031提到，\\(2^N\\)个\\(N\\)比特串上述的环排列一共有\\(2^{2^{N-1}-N}\\)个。\r\n代码\r\nN = 5M = 1 &lt;&lt; Nmask = (1 &lt;&lt; N) - 1g = [[i &lt;&lt; 1 &amp; mask, (i &lt;&lt; 1 | 1) &amp; mask] for i in range(M)]vis = [0 for i in range(M)]vis[0] = 1ans = 0def dfs(f: int, u: int, s: int):    if f == M - 1:        if u == (M &gt;&gt; 1):            global ans            ans += s &gt;&gt; (N - 1)        return    for v in g[u]:        if vis[v]:            continue        vis[v] = 1        dfs(f + 1, v, s &lt;&lt; 1 | (v &amp; 1))        vis[v] = 0dfs(0, 0, 0)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 266","url":"/project-euler/266/","content":"\r\nProject Euler 266\r\n题目\r\nPseudo Square Root\r\nThe divisors of \\(12\\) are: \\(1,2,3,4,6\\) and \\(12\\).\r\nThe largest divisor of \\(12\\) that\r\ndoes not exceed the square root of \\(12\\) is \\(3\\).\r\nWe shall call the largest divisor of an integer \\(n\\) that does not exceed the square root of\r\n\\(n\\) the pseudo square root (\\(\\text{PSR}\\)) of \\(n\\).\r\nIt can be seen that \\(\\text{PSR}(3102)=47\\).\r\nLet \\(p\\) be the product of the\r\nprimes below \\(190\\). Find \\(\\text{PSR}(p) \\bmod 10^{16}\\).\r\n解决方案\r\n质数的个数只有\\(m=42\\)个，比较容易想到meet-in-the-middle思想。\r\n令\\(n\\)为这些质数的积。前\\(21\\)个质数可以产生\\(n\\)的因子的一部分，存放在数组\\(lm\\)中，后\\(21\\)个质数也可以产生\\(n\\)的因子的另一部分，放在数组\\(rm\\)中。\r\n那么，\\(lm,rm\\)中任意一对数的乘积组合就一一对应了\\(n\\)的因子。\r\n因此在\\(lm\\)中，每遍历一个数\\(x\\)，就在\\(rm\\)中找到一个最大的\\(y\\)，使得\\(xy\\le\r\n\\sqrt{N}\\)。\r\n采用排序后用双指针进行遍历的方法就可以完成这个问题。\r\n代码\r\nfrom tools import int_sqrt, get_primeN = 190mod = 10 ** 16pr = get_prime(N)lm, rm = [1], [1]for p in pr[:len(pr) &gt;&gt; 1]:    lm += [x * p for x in lm]for p in pr[len(pr) &gt;&gt; 1:]:    rm += [x * p for x in rm]sq = int_sqrt(lm[-1] * rm[-1])lm.sort()rm.sort()r = len(rm) - 1ans = 0for l in range(len(lm)):    while r &gt;= 0 and lm[l] * rm[r] &gt; sq:        r -= 1    if r &lt; 0:        break    ans = max(ans, lm[l] * rm[r])ans %= modprint(ans)\r\n","categories":["Project Euler"],"tags":["meet-in-the-middle"]},{"title":"Project Euler 263","url":"/project-euler/263/","content":"\r\nProject Euler 263\r\n题目\r\nAn engineers’ dream come true\r\nConsider the number \\(6\\). The\r\ndivisors of \\(6\\) are: \\(1,2,3\\) and \\(6\\).\r\nEvery number from \\(1\\) up to and\r\nincluding \\(6\\) can be written as a sum\r\nof distinct divisors of \\(6\\):\r\n\\(1=1, 2=2, 3=1+2, 4=1+3, 5=2+3,\r\n6=6.\\)\r\nA number \\(n\\) is called a practical\r\nnumber if every number from \\(1\\) up to\r\nand including \\(n\\) can be expressed as\r\na sum of distinct divisors of \\(n\\).\r\nA pair of consecutive prime numbers with a difference of six is\r\ncalled a sexy pair (since “sex” is the Latin word for “six”). The first\r\nsexy pair is \\((23, 29)\\).\r\nWe may occasionally find a triple-pair, which means three consecutive\r\nsexy prime pairs, such that the second member of each pair is the first\r\nmember of the next pair.\r\nWe shall call a number \\(n\\) such\r\nthat:\r\n\r\n\\((n-9, n-3), (n-3,n+3), (n+3,\r\nn+9)\\) form a triple-pair, and\r\nthe numbers \\(n-8, n-4, n, n+4\\)\r\nand \\(n+8\\) are all practical,\r\n\r\nan engineers’ paradise.\r\nFind the sum of the first four engineers’ paradises.\r\n解决方案\r\n这个页面给出了实际数的一个高效的判定：\r\n令\\(n\\)的分解为\\(\\prod_{i=1}^k p_i^{e_i}\\)，并且有\\(p_1&lt;p_2&lt;\\dots,p_k\\)。\\(n\\)是实际数当且仅当对于所有\\(1&lt;i\\le k\\)，都满足：\r\n\\[p_i\\le 1+\\sigma(\\prod_{j=1}^{i-1}\r\np_j^{e_j})=1+\\prod_{j=1}^{i-1} \\dfrac{p_j^{e_j+1}-1}{p_j-1}\\]\r\n其中\\(\\sigma(n)\\)是\\(n\\)的所有因数之和。\r\n并且，这个页面还提出了，除了\\(1,2\\)，所有实际数必定是\\(4\\)或者是\\(6\\)的倍数。\r\n接下来单独考虑每个数\\(2\\sim\r\n8\\)和候选数\\(n\\)的各种可能情况：\r\n\\(2\\)\r\n\\(n-3\\)是质数，因此\\(2\\mid n\\)。\r\n\\(3\\)\r\n\\(n-3\\)是质数，因此\\(3\\nmid n\\)。\r\n\\(4\\)\r\n根据\\(2\\)的情况，要么\\(n=4k_4\\)，要么\\(n=4k_4+2\\).\r\n当\\(n=4_k+2\\)时，\\(n-8,n-4,n,n+4,n+8\\)都不是\\(4\\)的倍数，但是无论\\(k\\)取什么，总有一个数不是\\(3\\)的倍数。因此\\(4\\mid n\\)。\r\n\\(5\\)\r\n由于\\(n-9,n-3,n+3,n+9\\)都是质数，只有当\\(n\\equiv 0 \\pmod 5\\)时，这\\(4\\)个数都不是\\(5\\)的倍数。\r\n\\(7\\)\r\n由于\\(n-9,n-3,n+3,n+9\\)都是质数，因此\\(n\\equiv 0\\text{ or }1\\text{ or } 6 \\pmod\r\n7\\)。\r\n\\(8\\)\r\n仅讨论\\(n=8k_8,8k_8+4\\)时的情况。为了使得\\(n+8,n-8\\)是实用数，那么它们的次小质因子中，其中一个必须为\\(3\\)，另一个必须为\\(7\\)（不是\\(5\\)的原因是\\(5\\mid n\\)），这种情况下只有当\\(n=8k_8+4\\)时才满足。\r\n在这种情况下，同样只有当\\(n\\equiv 1\\pmod\r\n7\\)时满足。\r\n综上所述，通过中国剩余定理，联立以下式子：\r\n\\[\\begin{aligned}\r\n&amp;n\\equiv 1, 2\\pmod 3\\\\\r\n&amp;n\\equiv 0\\pmod 5\\\\\r\n&amp;n\\equiv 1\\pmod 7\\\\\r\n&amp;n\\equiv 4\\pmod 8\r\n\\end{aligned}\\]\r\n得到当\\(n\\equiv \\pm 20\\pmod\r\n{840}\\)时，\\(n\\)才有可能是一个答案。\r\n暴力求出所有候选值，并进行判断即可。\r\n代码\r\nfrom itertools import countfrom sympy import nextprimefrom tools import factorization, is_primeQ = 4def is_practical(n):    mul = 1    for p, e in factorization(n):        if p &gt; 1 + mul:            return False        mul *= (p ** (e + 1) - 1) // (p - 1)    return Truedef gen():    for n in count(0, 840):        yield n + 20        yield n + 820ans = 0for x in gen():    if is_prime(x - 9) and is_prime(x - 3) and is_prime(x + 3) and is_prime(x + 9):        if is_practical(x - 8) and is_practical(x - 4) and is_practical(x) and is_practical(x + 4) and is_practical(                x + 8):            if nextprime(x - 9) == x - 3 and nextprime(x - 3) == x + 3 and nextprime(x + 3) == x + 9:                ans += x                Q -= 1                if Q == 0:                    breakprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 261","url":"/project-euler/261/","content":"\r\nProject Euler 261\r\n题目\r\nPivotal Square Sums\r\nLet us call a positive integer \\(k\\)\r\na square-pivot, if there is a pair of integers \\(m &gt; 0\\) and \\(n \\ge k\\), such that the sum of the \\((m+1)\\) consecutive squares up to \\(k\\) equals the sum of the \\(m\\) consecutive squares from \\((n+1)\\) on:\r\n\\[(k-m)^2 + \\dots + k^2 = (n+1)^2 + \\dots\r\n+ (n+m)^2.\\]\r\nSome small square-pivots are\r\n\\(\\begin{aligned}\r\n&amp;\\mathbf{4}: 3^2 + \\mathbf{4}^2 = 5^2 \\\\\r\n&amp;\\mathbf{21}: 20^2 + \\mathbf{21}^2 = 29^2 \\\\\r\n&amp;\\mathbf{24}: 21^2 + 22^2 + 23^2 + \\mathbf{24}^2 = 25^2 + 26^2 +\r\n27^2 \\\\\r\n&amp;\\mathbf{110}: 108^2 + 109^2 + \\mathbf{110}^2 = 133^2 + 134^2\r\n\\end{aligned}\\)\r\nFind the sum of all distinct square-pivots \\(\\le 10^{10}\\).\r\n解决方案\r\n本题解参考了Thread中的一些内容。\r\n令\\(N=10^{10}\\)。根据平方数的前缀和\\(s(n)=\\dfrac{n(n+1)(2n+1)}{6}\\)，不难将上述方程改写成\\(s(k)-s(k-m-1)=s(n+m)-s(n)\\)。整理后得:\r\n\\[k^2 (1 + m) - k m (1 + m) - m n (1 + m +\r\nn)=0\\]\r\n注意到\\(m&gt;0,n\\ge\r\nk,\\)对方程的两边同时除\\(m(m+1)\\)，得到\r\n\\[\\dfrac{k^2}{m}-k-n-\\dfrac{n^2}{m+1}=0\\qquad(1)\\]\r\n由于\\(n\\ge k\\)，因此\\(\\dfrac{k^2}{m}-k-k-\\dfrac{k^2}{m+1}\\ge\r\n0\\)，这给出了关于\\(m\\)的上限满足：\\(2m(m+1)\\le k\\)。因此有\\(2m(m+1)\\le N\\)。\r\n接下来进一步化简整个方程。构造两个整数\\(x,t\\)，满足：\r\n\\[\r\n\\left \\{\\begin{aligned}\r\n  &amp;2k=m(x+1)+t\\\\\r\n  &amp;2n=(m+1)(x-1)+t\r\n\\end{aligned}\\right.\r\n\\]\r\n回代到方程\\((1)\\)中，得到\\(-m - m^2 - t^2 + m x^2 + m^2\r\nx^2=0\\)，化简得：\r\n\\[m(m+1)(x^2-1)=t^2\\qquad(2)\\]\r\n令\\(m=r\\cdot p^2,m+1=s\\cdot\r\nq^2\\)，其中\\(r,s\\)是一个无平方因数。并且注意，\\(m\\)和\\(m+1\\)是互质的。因此\\(rpsq\\mid t\\)。令\\(y=\\dfrac{t}{rpsq}\\)，那么将\\(m,m+1,t\\)代入方程\\((2)\\)，得到\\(x^2-1=rsy^2\\)。将其移项，得到一个佩尔方程：\r\n\\[x^2-rsy^2=1\\qquad(3)\\]\r\n佩尔方程在66题已经讲过如何计算，此处不赘述。\r\n最终，从小到大枚举\\(m\\)，计算出\\(r,p,s,q\\)后，代入方程\\((3)\\)解佩尔方程。求出每一对特定解\\((x,y)\\)后，计算出\\(t=rpsqy\\)，最终代入到\\(k=\\dfrac{m(x+1)+t}{2}\\)。计算出每个解时，需要判断\\(m(x+1)+t\\)和\\((m+1)(x-1)+t\\)都是偶数，并且前者不超过后者。\r\n代码\r\nfrom tools import int_sqrt, factorization, pellN = 10 ** 10M = (-1 + int_sqrt(1 + 2 * N)) // 2lf = [0]lg = [0]for n in range(1, M + 3):    x, y = 1, 1    for p, e in factorization(n):        if e &amp; 1:            x *= p        y *= p ** (e &gt;&gt; 1)    lf.append(x)    lg.append(y)st = set()for m in range(1, M + 1):    D = lf[m] * lf[m + 1]    x1, y1 = pell(D)    x, y = x1, y1    tmp = lf[m] * lf[m + 1] * lg[m] * lg[m + 1]    while True:        t = tmp * y        kk = m * (x + 1) + t        if kk &gt; N * 2:            break        nn = (m + 1) * (x - 1) + t        if nn &gt;= kk and nn % 2 == 0 and kk % 2 == 0:            st.add(kk &gt;&gt; 1)        x, y = x1 * x + D * y1 * y, x1 * y + y1 * xans = sum(st)print(ans)\r\n","categories":["Project Euler"],"tags":["佩尔方程"]},{"title":"Project Euler 267","url":"/project-euler/267/","content":"\r\nProject Euler 267\r\n题目\r\nBillionaire\r\nYou are given a unique investment opportunity.\r\nStarting with \\(£1\\) of capital, you\r\ncan choose a fixed proportion, \\(f\\),\r\nof your capital to bet on a fair coin toss repeatedly for \\(1000\\) tosses.\r\nYour return is double your bet for heads and you lose your bet for\r\ntails.\r\nFor example, if \\(f=\\dfrac{1}{4}\\),\r\nfor the first toss you bet \\(£0.25\\),\r\nand if heads comes up you win \\(£0.5\\)\r\nand so then have \\(£1.5\\). You then bet\r\n\\(£0.375\\) and if the second toss is\r\ntails, you have \\(£1.125\\).\r\nChoosing \\(f\\) to maximize your\r\nchances of having at least \\(£1,000,000,000\\) after \\(1,000\\) flips, what is the chance that you\r\nbecome a billionaire?\r\nAll computations are assumed to be exact (no rounding), but give your\r\nanswer rounded to \\(12\\) digits behind\r\nthe decimal point in the form 0.abcdefghijkl.\r\n解决方案\r\n令\\(N=1000,M=10^9\\).根据题意，选定了\\(f\\)后抛一次硬币，如果正面向上，那么资本变成原来的\\((1+2f)\\)倍，否则变成原来的\\((1-f)\\)倍。\r\n那么，如果在整个过程中有\\(n\\)次硬币正面在上，那么最终获得的金额数是：\r\n\\[P(n)=(1+2f)^n\\cdot(1-f)^{N-n}\\]\r\n不难发现，随着\\(n\\)增长，\\(P(n)\\)也在增长，那么存在一个最小的\\(n=n_0\\)使得\\(P(n_0)\\ge M\\)。因此题目就转化成：求值\\(f\\)，使得这个\\(n_0\\)能够最小。\r\n对不等式两边取对数，可以写成：\\(n\\log(1+2f)+(N-n)\\log(1-f)\\ge \\log M\\)\r\n经过移项，那么可以写成\\(n(\\log(1+2f)-\\log(1-f))+N\\log(1-f)\\ge \\log\r\nM\\)\r\n由于\\(f&gt;0\\)，因此移项后就写成\\(n\\ge\\dfrac{\\log\r\nM-N\\log(1-f)}{\\log(1+2f)-\\log(1-f)}\\)\r\n令函数\\(h(x)=\\dfrac{\\log\r\nM-N\\log(1-x)}{\\log(1+2x)-\\log(1-x)},0&lt;\r\nx&lt;1\\).那么此时就是为了求函数\\(h(x)\\)的最小值。这里使用scipy.optimize中的fminbound方法求函数\\(h\\)的极小值点\\(x_0\\)。\r\n那么，最小的\\(n_0\\)就满足\\(n_0=\\lceil h(x_0)\\rceil\\)。\r\n根据二项分布的性质，不难得出最终结果为\\(\\dfrac{\\sum_{i=n_0}^N\\binom{N}{i}}{2^N}\\).\r\n代码\r\nfrom math import log2, ceilfrom scipy.optimize import fminboundfrom tools import get_pascals_triangleN = 1000M = 10 ** 9h = lambda x: (log2(M) - N * log2(1 - x)) / (log2(1 + 2 * x) - log2(1 - x))f = fminbound(h, 0, 1)n0 = ceil(h(f))C = get_pascals_triangle(N)ans = sum(C[N][j] for j in range(n0, N + 1)) / (1 &lt;&lt; N)print(&quot;&#123;:.12f&#125;&quot;.format(ans))\r\n","categories":["Project Euler"]},{"title":"Project Euler 271","url":"/project-euler/271/","content":"\r\nProject Euler 271\r\n题目\r\nModular Cubes, part \\(1\\)\r\nFor a positive number \\(n\\), define\r\n\\(S(n)\\) as the sum of the integers\r\n\\(x\\), for which \\(1&lt;x&lt;n\\) and \\(x^3\\equiv 1 \\bmod n\\).\r\nWhen \\(n=91\\), there are \\(8\\) possible values for \\(x\\), namely : \\(9, 16, 22, 29, 53, 74, 79, 81\\).\r\nThus, \\(S(91)=9+16+22+29+53+74+79+81=363\\).\r\nFind \\(S(13082761331670030)\\).\r\n解决方案\r\n写在前面：\r\n比较投机取巧的一种方法：直接使用sympy.ntheory.residue_ntheory库中的nthroot_mod方法。\r\n这个方法主要传入三个参数：nthroot_mod(a,n,p)，用来求解三次剩余\\(x^n\\equiv a \\pmod p\\).\r\n平常做法：\r\n首先将\\(n=13082761331670030\\)进行分解，得到\\(n=\\prod_{i=1}^k p_i^{e_i}\\).\r\n那么，求解\\(x^3\\equiv1\\pmod\r\nn\\)就变成了求解一系列的\\(x_i^3\\equiv\r\n1\\pmod {p_i^{e_i}}\\)，然后再分别将所有解通过中国剩余定理重新合并起来，就变成了原方程的解。\r\n并且，可以发现题目中给定的\\(n\\)，所有的\\(p_e^{e_i}\\)都很小。实际上，所有的\\(e_i\\)都为\\(1\\)，因此求解\\(x_i^3\\equiv 1\\pmod\r\n{p_i^{e_i}}\\)使用的是暴力枚举。\r\n代码\r\nfrom sympy.ntheory.residue_ntheory import nthroot_modN = 13082761331670030ans = sum(nthroot_mod(1, 3, N, all_roots=True)) - 1print(ans)\r\nfrom itertools import productfrom tools import factorizationfrom sympy import mod_inverseimport functools, operatorN = 13082761331670030def CRT(a, p):    M = functools.reduce(operator.mul, p, 1)    m_inv = [mod_inverse(M // x, x) for x in p]    return sum(a[i] * m_inv[i] * M // p[i] for i in range(len(a))) % Mpe = []sol = []for p, e in factorization(N):    n = p ** e    pe.append(n)    sol.append([x for x in range(n) if pow(x, 3, n) == 1])ans = sum(CRT(a, pe) for a in product(*sol)) - 1print(ans)\r\n","categories":["Project Euler"],"tags":["中国剩余定理"]},{"title":"Project Euler 27","url":"/project-euler/27/","content":"\r\nProject Euler 27\r\n题目\r\nQuadratic primes\r\nEuler discovered the remarkable quadratic formula: \\[n^2 + n + 41\\] It turns out that the\r\nformula will produce \\(40\\) primes for\r\nthe consecutive integer values \\(0 \\le n \\le\r\n39\\). However, when \\(n = 40\\),\r\n\\(40^2 + 40 + 41 = 40(40 + 1) + 41\\) is\r\ndivisible by \\(41\\), and certainly when\r\n\\(n = 41\\), \\(41^2 + 41 + 41\\) is clearly divisible by\r\n\\(41\\).\r\nThe incredible formula \\(n^2 - 79n +\r\n1601\\) was discovered, which produces \\(80\\) primes for the consecutive values\r\n\\(0 \\le n \\le 79\\). The product of the\r\ncoefficients, \\(−79\\) and \\(1601\\), is \\(−126479\\).\r\nConsidering quadratics of the form: \\(n^2 +\r\nan + b\\), where \\(|a|\\lt 1000\\)\r\nand \\(|b| \\le 1000\\);where \\(|n|\\) is the modulus/absolute value of\r\n\\(n\\), e.g. \\(|11| = 11\\) and \\(|-4| = 4\\).\r\nFind the product of the coefficients, \\(a\\) and \\(b\\), for the quadratic expression that\r\nproduces the maximum number of primes for consecutive values of \\(n\\), starting with \\(n = 0\\).\r\n解决方案\r\n设\\(p(n)=n^2+an+b\\)\r\n先用筛法将所有素数筛选出来（这里筛选的是范围\\(1000\\times1000+40\\)以内的素数）。\r\n然后通过枚举\\(a,b\\)的值，再用变量\\(n\\)判断长度。\r\n一个优化：\\(b\\)必须是一个正数，并且是一个质数。因为当一开始\\(n=0\\)时，判断的值就是\\(f(0)=b\\)本身。\r\n另一个优化：\\(a\\)可以从\\(1-b\\)开始枚举。因为\\(f(1)=a+b+1\\ge2\\) ，因此\\(a\\ge 1-b\\)。\r\n不过，加上了第二个优化后，需要额外进行一些细节上的判断，详见代码。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int M=2;const int N=M*M+40;bool v[N+4];vector&lt;int&gt;pr;int main()&#123;    for(int i=2;i&lt;=N;i++)&#123;        if(v[i]) continue;        if(i&lt;=M) pr.push_back(i);        for(ll j=1ll*i*i;j&lt;=N;j+=i)            v[j]=1;    &#125;    v[0]=v[1]=1;    int ans=0,mx=0,n;    for(int b:pr)        for(int a=1-b;a&lt;=M-1;++a)&#123;            for(n=0;n*n+n*a+b&gt;=0&amp;&amp;!v[n*n+n*a+b];++n);            if(n&gt;mx) mx=n,ans=a*b;        &#125;    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 268","url":"/project-euler/268/","content":"\r\nProject Euler 268\r\n题目\r\nCounting\r\nnumbers with at least four distinct prime factors less than 100\r\nIt can be verified that there are \\(23\\) positive integers less than \\(1000\\) that are divisible by at least four\r\ndistinct primes less than \\(100\\).\r\nFind how many positive integers less than \\(10^{16}\\) are divisible by at least four\r\ndistinct primes less than \\(100\\).\r\n解决方案\r\n令\\(M=23,N=10^{16},K=4,p_j\\)为这\\(M\\)个质数之一。\r\n那么根据容斥原理，答案为：\r\n\\[\\sum_{i=K}^M (-1)^{i-K}\\cdot\r\n\\dbinom{i-1}{K-1}\\cdot\r\n\\sum_{p_1&lt;p_2&lt;\\dots&lt;p_i}\\dfrac{N}{\\prod_{j=1}^ip_j}\\]\r\n其中前两项是容斥原理的系数，第一个则是将至少\\(K\\)个的添加，然后将重复算的\\(K+1\\)个减去，再将被重复减去的\\(K+2\\)个的补充回来……；第二个表示，这个大小为\\(i\\)的集合被之前重复的计算次数。\r\n第三项则是求\\(N\\)以内有多少个数同时具有\\(p_1,p_2,\\dots,p_j\\)这\\(j\\)个质因子，一共有\\(\\dfrac{N}{\\prod_{j=1}^ip_j}\\)个。\r\n代码\r\nfrom tools import get_prime, CN = 10 ** 16M = 100K = 4N -= 1pr = get_prime(M - 1)s = [0 for i in range(len(pr) + 1)]def dfs(f: int, n: int, v: int):    if f == len(pr) or n * pr[f] &gt; N:        s[v] += N // n        return    dfs(f + 1, n, v)    dfs(f + 1, n * pr[f], v + 1)dfs(0, 1, 0)ans = 0flag = Truefor i in range(K, len(s)):    if flag:        ans += s[i] * C(i - 1, K - 1)    else:        ans -= s[i] * C(i - 1, K - 1)    flag = not flagprint(ans)\r\n","categories":["Project Euler"],"tags":["容斥原理"]},{"title":"Project Euler 269","url":"/project-euler/269/","content":"\r\nProject Euler 269\r\n题目\r\nPolynomials with at\r\nleast one integer root\r\nA root or zero of a polynomial \\(P(x)\\) is a solution to the equation \\(P(x) = 0\\).\r\nDefine \\(P_n\\) as the polynomial\r\nwhose coefficients are the digits of n.\r\nFor example, \\(P_{5703}(x) = 5x^3 + 7x^2 +\r\n3\\). We can see that:\r\n\r\n\\(P_n(0)\\) is the last digit of\r\n\\(n\\),\r\n\\(P_n(1)\\) is the sum of the digits\r\nof \\(n\\),\r\n\\(P_n(10)\\) is \\(n\\) itself.\r\n\r\nDefine \\(Z(k)\\) as the number of\r\npositive integers, \\(n\\), not exceeding\r\n\\(k\\) for which the polynomial \\(P_n\\) has at least one integer root.\r\nIt can be verified that \\(Z(100\r\n000)\\) is \\(14696\\).\r\nWhat is \\(Z(10^{16})\\)?\r\n解决方案\r\n令\\(N=16\\)。不难发现，方程\\(P_n(x)=0\\)的整数根只能在范围\\([-9,0]\\)内，因为值\\(P_n(-10)\\)的最高次数项的绝对值一定大于其余项的绝对值之和。\r\n如果\\(x=0\\)是方程\\(P_n(x)=0\\)的解，当且仅当\\(n\\)是\\(10\\)的倍数。这类数一共有\\(10^{N-1}-1+1\\)个，注意这里其中一个答案是\\(10^N\\)。\r\n接下来只考虑范围\\([-9,-1]\\)内的解情况。由于\\(P_n(x)\\)的常系数项最多为\\(9\\)，而多项式\\((x+1)(x+2)(x+3)(x+4)\\)的常数项已经达到了\\(24\\)，因此\\(P_n(x)\\)最多只有\\(3\\)个整数根。\r\n考虑使用容斥原理，先计算出有多少个多项式的解含有\\(-1,-2,\\dots,-9\\)，再秋求和，然后再计算有多少个多项式的解同时含有\\((-1,-2),(-1,-3),\\dots\\)，并一一减去，相应的计算三个解时的情况，并加上。\r\n考虑一个\\(m\\)位有前导\\(0\\)数对应的多项式\\(p_m(x)\\)，它可以写成\\(p_m(x)=x\\cdot p_{m-1}(x) + d_m\\)。其中\\(d_m\\)表示常数项，\\(0\\le d_m\\le 9\\)，注意，\\(d_m\\)也表示这个\\(m\\)位有前导\\(0\\)数的个位。那么可以写成\\(p_{m-1}(x)=\\dfrac{p_m(x)-d_m}{x}\\)，进而递归寻找更小的项。\r\n令状态\\(f_3(n,b_1,b_2,b_3)(0\\le n&lt;\r\nN)\\)表示有多少个多项式\\(p_{N-n-1}(x)\\)，满足\\(p_{N-n-1}(a_k)=b_k,k=1,2,3\\)。那么可以写出\\(f\\)的状态转移方程：\r\n\\[\r\nf_3(n,b_1,b_2,b_3)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1 &amp; &amp; \\text{if}\\quad n=N-1\\land 0\\le b_1\\le 9\\land\r\nb_1=b_2=b_2 \\\\\r\n  &amp;0 &amp; &amp; \\text{else if}\\quad n=0 \\\\\r\n  &amp;\\sum_{\\substack{[n=0]\\le d\\le 9,\\\\a_k\\mid(b_k-d),k=1,2,3}}\r\nf(n+1,\\dfrac{b_1-d}{a_1},\\dfrac{b_2-d}{a_2},\\dfrac{b_3-d}{a_3}) &amp;\r\n&amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n其中，\\([]\\)表示示性函数，表示\\([]\\)里面的值是否为真，如果为真，那么值为\\(1\\)，否则值为\\(0\\).\r\n方程的最后一行，表示\\(d_m\\)随意从\\(0\\sim\r\n9\\)中随意选择。由于我们一开始已经计算了个位为\\(0\\)的情况，因此个位不能选择\\(0\\)。\r\n一开始，\\(p_{N-1}(x)=0\\)，因此同时具有\\(a_1,a_2,a_3\\)三个根的多项式个数为\\(f_3(0,0,0,0)\\)。\r\n\\(f_2,f_1\\)的计算过程也类似。\r\n最终用容斥原理将它们整合在一起即可。实际上，\\(|b_1|,|b_2|,|b_3|\\)这几个值都比较小。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 16;const int O = 100;int a1, a2, a3;ll f[N+1][O+O];ll g[N+1][O+O][O+O];ll h[N+1][O+O][O+O][O+O];ll f1(int n, int b) &#123;    ll &amp;ans = f[n][b + O];    if (ans != -1) return ans;    if (n == N - 1) &#123;        if (b &gt;= 0 &amp;&amp; b &lt;= 9) return ans = 1;        else return ans = 0;    &#125;    ans = 0;    for (int m = (n == 0 ? 1 : 0); m &lt; 10; m++) &#123;        if ((b - m) % a1 != 0) continue;        ans += f1(n + 1, (b - m) / a1);    &#125;    return ans;&#125;ll f2(int n, int b1, int b2) &#123;    ll &amp;ans = g[n][b1 + O][b2 + O];    if (ans != -1) return ans;    if (n == N - 1) &#123;        if (b1 &gt;= 0 &amp;&amp; b1 &lt;= 9 &amp;&amp; b1 == b2) return ans = 1;        else return ans = 0;    &#125;    ans = 0;    for (int m = (n == 0 ? 1 : 0); m &lt; 10; m++) &#123;        if ((b1 - m) % a1 != 0 || (b2 - m) % a2 != 0) continue;        ans += f2(n + 1, (b1 - m) / a1, (b2 - m) / a2);    &#125;    return ans;&#125;ll f3(int n, int b1, int b2, int b3) &#123;    ll &amp;ans = h[n][b1 + O][b2 + O][b3 + O];    if (ans != -1) return ans;    if (n == N - 1) &#123;        if (b1 &gt;= 0 &amp;&amp; b1 &lt;= 9 &amp;&amp; b1 == b2 &amp;&amp; b2 == b3) return ans = 1;        else return ans = 0;    &#125;    ans = 0;    for (int m = (n == 0 ? 1 : 0); m &lt; 10; m++) &#123;        if ((b1 - m) % a1 != 0 || (b2 - m) % a2 != 0 || (b3 - m) % a3 != 0) continue;        ans += f3(n + 1, (b1 - m) / a1, (b2 - m) / a2, (b3 - m) / a3);    &#125;    return ans;&#125;int main() &#123;    ll ans = 1;    for (int i = 1; i &lt; N; i++)        ans *= 10;    for (int i = 1; i &lt; 10; i++) &#123;        a1 = -i;        memset(f, -1, sizeof(f));        ans += f1(0, 0);    &#125;    for (int i = 1; i &lt; 10; i++)        for (int j = i + 1; i * j &lt; 10; j++) &#123;            a1 = -i;            a2 = -j;            memset(g, -1, sizeof(g));            ans -= f2(0, 0, 0);        &#125;    for (int i = 1; i &lt; 10; i++)        for (int j = i + 1; i * j &lt; 10; j++)            for (int k = j + 1; i * j * k &lt; 10; k++) &#123;                a1 = -i;                a2 = -j;                a3 = -k;                memset(h, -1, sizeof(h));                ans += f3(0, 0, 0, 0);            &#125;    printf(&quot;%lld\\n&quot;, ans);&#125;\r\n","categories":["Project Euler"],"tags":["容斥原理","动态规划"]},{"title":"Project Euler 272","url":"/project-euler/272/","content":"\r\nProject Euler 272\r\n题目\r\nModular Cubes, part \\(2\\)\r\nFor a positive number \\(n\\), define\r\n\\(C(n)\\) as the number of the integers\r\n\\(x\\), for which \\(1&lt;x&lt;n\\) and \\(x^3\\equiv 1 \\bmod n\\).\r\nWhen \\(n=91\\), there are \\(8\\) possible values for \\(x\\), namely : \\(9, 16, 22, 29, 53, 74, 79, 81\\).\r\nThus, \\(C(91)=8\\).\r\nFind the sum of the positive numbers \\(n\\le10^{11}\\) for which \\(C(n)=242\\).\r\n解决方案\r\n枚举\\(n\\)，直接暴力求取前一部分\\(n\\)的该方程的解的个数，在OEIS中查询，发现结果为A060839。在FORMULA一栏中发现如下内容：\r\nLet b(n) be the number of primes dividing n which are congruent to 1 mod 3 (sequence A005088); then a(n) is 3^b(n) if n is not divisible by 9 and 3^(b(n) + 1) if n is divisible by 9.\r\n也就是说，对于\\(n\\)的分解质因数\\(n=\\prod_{i=1}^k\r\np_i^{e_i}\\)而言。假设有\\(b\\)个\\(p_i\\)模\\(3\\)余\\(1\\)的质因子。如果\\(n\\)是\\(9\\)的倍数，那么方程\\(x^3 \\equiv1\\pmod n\\)有\\(3^{b+1}\\)个解，否则为\\(3^b\\)个。\r\n题目中问的是\\(242\\)，加上解\\(1\\)，那么实际上是询问\\(243=3^5\\)个解的情况，那么此处分开讨论\\(n\\)是否为\\(9\\)的倍数的情况。\r\n首先通过线性筛，将所有质因子只包含模\\(3\\)余\\(2\\)的数筛选出来，存在集合\\(Q_2\\)中，在这个过程中也过滤出模\\(3\\)余\\(1\\)的质数，存在集合\\(P_1\\)中。前\\(4\\)个模\\(3\\)余\\(1\\)的质数分别是：\\(7,13,19,31\\)。那么，进行组合枚举时，枚举的最大质数将不超过\\(M=\\max\\left(\\left\\lfloor\\dfrac{N}{\\max(9,31)\\cdot7\\cdot\r\n13,19}\\right\\rfloor,31\\right)\\)。此处的\\(M\\)不大。因此线性筛的最大范围为\\(M\\)。\r\n接下来先枚举\\(n\\)的质因数\\(3\\)的指数\\(e\\)。当\\(e&lt;2\\)时，那么对\\(P_1\\)进行\\(b\\)个元素的组合枚举，枚举出它们的乘积\\(3^e\\cdot p_1\\cdot p_2\\cdot ...\\cdot\r\np_b\\)。那么再将这个数和集合\\(Q_2\\)中的数一一组合，就能构造出一个个答案。当\\(e\\ge2\\)时也类似。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll N=100000000000;const int Q=242;const int O=log(Q+1)/log(3)+1e-8;const ll M=N/7/13/19/9+200;int vis[M+4];int pr[M/10+1000],m=0;ll v[M+4];ll ans=0,s[M+4];void dfs(int f,int pos,ll n)&#123;    if(f==0)&#123;        ans+=s[N/n]*n;        return;    &#125;    for(int i=pos;i&lt;=m;i++)&#123;        ll ok=n;        for(int k=0;k&lt;f&amp;&amp;i+k&lt;=m&amp;&amp;ok&lt;=N;k++)            ok*=pr[i+k];        if(ok&gt;N) break;        for(ll k=n*pr[i];k&lt;=N;k*=pr[i])            dfs(f-1,i+1,k);    &#125;&#125;int main()&#123;    s[1]=1;    for(int i=2;i&lt;=M;i++)&#123;        if(v[i]==0)&#123;            v[i]=i;pr[++m]=i;            s[i]=(i%3==2);        &#125;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;M/i) break;            v[i*pr[j]]=pr[j];            s[i*pr[j]]=pr[j]%3==2?s[i]:0;        &#125;    &#125;    int t=m;m=0;    for(int i=1;i&lt;=t;i++)        if(pr[i]%3==1) pr[++m]=pr[i];    for(int i=1;i&lt;=M;i++)        s[i]=s[i-1]+s[i]*i;    dfs(O,1,1);dfs(O,1,3);    for(ll k=9;k&lt;=N;k*=3)        dfs(O-1,1,k);    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["OEIS"]},{"title":"Project Euler 274","url":"/project-euler/274/","content":"\r\nProject Euler 274\r\n题目\r\nA lagged Fibonacci sequence\r\nFor each integer \\(p &gt; 1\\)\r\ncoprime to \\(10\\) there is a\r\npositive divisibility multiplier \\(m\r\n&lt; p\\) which preserves divisibility by \\(p\\) for the following function on any\r\npositive integer, \\(n\\):\r\n\\(f(n) = (\\text {all\\ but\\ the\\ last\\\r\ndigit\\ of\\ }n) + (\\text{the\\ last\\ digit\\ of\\ }n) * m\\)\r\nThat is, if \\(m\\) is the\r\ndivisibility multiplier for \\(p\\), then\r\n\\(f(n)\\) is divisible by \\(p\\) if and only if \\(n\\) is divisible by \\(p\\).\r\n(When \\(n\\) is much larger than\r\n\\(p\\), \\(f(n)\\) will be less than \\(n\\) and repeated application of f provides\r\na multiplicative divisibility test for \\(p\\).)\r\nFor example, the divisibility multiplier for \\(113\\) is \\(34\\).\r\n\\(f(76275) = 7627 + 5 * 34 = 7797\\)\r\n: \\(76275\\) and \\(7797\\) are both divisible by \\(113\\)\r\n\\(f(12345) = 1234 + 5 * 34 = 1404\\)\r\n: \\(12345\\) and \\(1404\\) are both not divisible by \\(113\\)\r\nThe sum of the divisibility multipliers for the primes that are\r\ncoprime to \\(10\\) and less than \\(1000\\) is \\(39517\\).\r\nWhat is the sum of the divisibility multipliers for the primes that\r\nare coprime to \\(10\\) and less than\r\n\\(10^7\\)?\r\n解决方案\r\n原题等价为： 对于\\(\\forall a \\in\r\n\\mathbb{Z},b\\in [0,9] \\cap \\mathbb{Z}\\)，有\r\n\\[10a+b \\equiv 0 \\pmod p \\Leftrightarrow\r\na+mb\\equiv 0\\pmod p\\]\r\n即为\\(10a+10mb\\equiv 0 \\pmod p\\)\r\n当上述条件满足时，有：\r\n\\(10a\\equiv -b \\equiv -10 mb\\pmod\r\np\\)\r\n由此得\\(10mb-b\\equiv 0\\pmod\r\np\\)。\r\n即为\\((10m-1)b\\equiv 0\\pmod\r\np\\)，对于所有\\(b\\)成立。\r\n令\\(b=1\\)，那么\\(m\\)满足\\(10m\\equiv 1 \\pmod p\\)。直接计算\\(10\\)对质数\\(p\\)的逆元即可。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e7;int pr[N + 4], v[N + 4], p = 0;ll qpow(ll n, ll m, ll mod) &#123;    ll a = 1;    for (; m; m &gt;&gt;= 1) &#123;        if (m &amp; 1) a = a * n % mod;        n = n * n % mod;    &#125;    return a;&#125;int main() &#123;    for (int i = 2; i &lt; N; i++) &#123;        if (v[i] == 0) &#123;            pr[++p] = i;            v[i] = i;        &#125;        for (int j = 1; j &lt;= p; j++) &#123;            if (pr[j] &gt; v[i] || pr[j] &gt; N / i) break;            v[i * pr[j]] = pr[j];        &#125;    &#125;    ll ans = qpow(10, 3 - 2, 3);    for (int i = 4; i &lt;= p; i++)        ans += qpow(10, pr[i] - 2, pr[i]);    printf(&quot;%lld\\n&quot;, ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 273","url":"/project-euler/273/","content":"\r\nProject Euler 273\r\n题目\r\nSum of Squares\r\nConsider equations of the form: \\(a^2 + b^2\r\n= N\\), \\(0 \\le a \\le b\\), \\(a, b\\) and \\(N\\) integer.\r\nFor \\(N=65\\) there are two\r\nsolutions:\\(a=1, b=8\\) and \\(a=4, b=7\\).\r\nWe call \\(S(N)\\) the sum of the\r\nvalues of \\(a\\) of all solutions of\r\n\\(a^2 + b^2 = N\\), \\(0 \\le a \\le b\\), \\(a, b\\) and \\(N\\) integer.\r\nThus \\(S(65) = 1 + 4 = 5\\).\r\nFind \\(\\sum S(N)\\), for all\r\nsquarefree \\(N\\) only divisible by\r\nprimes of the form \\(4k+1\\) with \\(4k+1 &lt; 150\\).\r\n婆罗摩笈多——斐波那契恒等式\r\n婆罗摩笈多——斐波那契恒等式说明，如果两个整数分别能表示成两个平方数之和，那么这两个整数的积也能表示成两个平方数之和：\r\n\\[(a^2+b^2)(c^2+d^2)=(ac-bd)^2+(ad+bc)^2=(ac+bd)^2+(ad-bc)^2\\]\r\n解决方案\r\n页面1，页面2说明了一个奇质数当且仅当它模\\(4\\)余\\(1\\)，才能表示成两个不同平方数之和，并且表示方式是唯一的。\r\n我们先求出\\(M=150\\)以内的所有模\\(4\\)余\\(1\\)的唯一平方数之和的表示\\(p_i=a_i^2+b_i^2\\)，然后根据婆罗摩笈多——斐波那契恒等式，将每一对表示方式进行不同的组合即可。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;# include &quot;tools.h&quot;using namespace std;typedef long long ll;const int N=150;vector&lt;int&gt;pr,u,v;ll dfs(int f,ll a,ll b)&#123;    if(f==u.size()) return min(abs(a),abs(b));    return dfs(f+1,a,b)+dfs(f+1,a*u[f]-b*v[f],a*v[f]+b*u[f])+dfs(f+1,a*u[f]+b*v[f],a*v[f]-b*u[f]);&#125;int main() &#123;    for(int p=1;p&lt;N;p+=4)        if(is_prime(p))&#123;            pr.push_back(p);            for(int a=1;a*a&lt;=p;a++)&#123;                int b=int_square(p-a*a);                if(a*a+b*b==p)&#123;                    u.push_back(a);                    v.push_back(b);                    break;                &#125;            &#125;        &#125;    ll ans=0;    for(int i=0;i&lt;u.size();i++)        ans+=dfs(i+1,u[i],v[i]);    printf(&quot;%lld\\n&quot;, ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 277","url":"/project-euler/277/","content":"\r\nProject Euler 277\r\n题目\r\nA Modified Collatz sequence\r\nA modified Collatz sequence of integers is obtained from a starting\r\nvalue \\(a_1\\) in the following way:\r\n\\(a_{n+1} = \\dfrac {a_n} 3\\quad\\) if\r\n\\(a_n\\) is divisible by \\(3\\). We shall denote this as a large\r\ndownward step, “D”.\r\n\\(a_{n+1} = \\dfrac {4 a_n+2}\r\n3\\quad\\) if \\(a_n\\) divided by\r\n\\(3\\) gives a remainder of \\(1\\). We shall denote this as an upward\r\nstep, “U”.\r\n\\(a_{n+1} = \\dfrac {2 a_n -1}\r\n3\\quad\\) if \\(a_n\\) divided by\r\n\\(3\\) gives a remainder of \\(2\\). We shall denote this as a small\r\ndownward step, “d”.\r\nThe sequence terminates when some \\(a_n =\r\n1\\).\r\nGiven any integer, we can list out the sequence of steps.\r\nFor instance if \\(a_1=231\\), then\r\nthe sequence \\(\\{a_n\\}=\\{231,77,51,17,11,7,10,14,9,3,1\\}\\)\r\ncorresponds to the steps “DdDddUUdDD”.\r\nOf course, there are other sequences that begin with that same\r\nsequence “DdDddUUdDD…”.\r\nFor instance, if \\(a_1=1004064\\),\r\nthen the sequence is DdDddUUdDDDdUDUUUdDdUUDDDUdDD.\r\nIn fact, \\(1004064\\) is the smallest\r\npossible \\(a_1 &gt; 10^6\\) that begins\r\nwith the sequence DdDddUUdDD.\r\nWhat is the smallest \\(a_1 &gt;\r\n10^{15}\\) that begins with the sequence\r\n“UDDDUdddDDUDDddDdDddDDUDDdUUDd”?\r\n解决方案\r\n令\\(N=10^{15}\\),s=“UDDDUdddDDUDDddDdDddDDUDDdUUDd”，并且字符串\\(s\\)的长度为\\(M\\).\r\n并且注意到，上面三个递推式都是线性变换。\r\n如果一开始\\(a_1\\)是一个已知的数\\(x\\)，那么经过这么多的递推变换后，最终得到的值是一个形如\\(kx+b\\)的数。注意\\(k,b\\)都是分数，但是\\(kx+b\\)是一个正整数，设这个正整数为\\(y\\).\r\n不难发现\\(k,b\\)的分母是\\(3^M\\)，那么将\\(k\\)和\\(b\\)分别写成\\(\\dfrac{u}{3^M},\\dfrac{v}{3^M}\\)，那么可以得到一个等式：\r\n\\[ux-3^My=-v\\]\r\n最终，我们可以使用扩展欧几里得算法解上面的方程，得出一个\\(x\\)，并且这个\\(x\\)将比\\(N\\)大。这个\\(x\\)最终是本题的答案。\r\n代码\r\nfrom fractions import FractionN = 10 ** 15S = &quot;UDDDUdddDDUDDddDdDddDDUDDdUUDd&quot;def ex_gcd(a: int, b: int):    if b == 0:        return 1, 0, a    else:        x, y, g = ex_gcd(b, a % b)        return y, x - (a // b) * y, gk = Fraction(1)b = Fraction(0)for ch in S:    if ch == &#x27;U&#x27;:        k = k * 4 / 3        b = (b * 4 + 2) / 3    elif ch == &#x27;D&#x27;:        k /= 3        b /= 3    else:        k = k * 2 / 3        b = (b * 2 - 1) / 3u, n, v = k.numerator, k.denominator, b.numeratorx, _, _ = ex_gcd(u, n)x = x * -v % nd = (N - x + n - 1) // nans = x + d * nprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 276","url":"/project-euler/276/","content":"\r\nProject Euler 276\r\n题目\r\nPrimitive Triangles\r\nConsider the triangles with integer sides \\(a, b\\) and \\(c\\) with \\(a \\le\r\nb \\le c\\).\r\nAn integer sided triangle \\((a,b,c)\\) is called primitive if \\(\\gcd(a,b,c)=1,(\\gcd(a,b,c)=\\gcd(a,\\gcd(b,c)))\\).\r\nHow many primitive integer sided triangles exist with a perimeter not\r\nexceeding \\(10 000 000\\)?\r\n解决方案\r\n首先考虑这个问题的一个简单版：\r\n去除互质的限制后，有多少个三角形？\r\n暴力枚举出一部分项后，查询OEIS，结果为A001400，找到FORMULA一栏，它给出了一个\\(9\\)阶的递推式：\r\na(n) = 1 + (a(n-2) + a(n-3) + a(n-4)) - (a(n-5) + a(n-6) + a(n-7)) + a(n-9). - Norman J. Meluch (norm(AT)iss.gm.com), Mar 09 2000\r\n那么，令去除掉互质限制后的周长不超过\\(n\\)的三角形个数为\\(f(n)\\)，令\\(g(n)\\)表示原本题目中要求的三角形个数。\r\n每一个互质的三角形，每条边的边长都延长到原来的\\(k\\)倍，那么它的周长也将延长到原来的\\(k\\)倍。每一个非互质三角形都对应着一个互质三角形。因此，可以写出\\(f\\)和\\(g\\)之间的关系：\r\n\\[f(n)=\\sum_{k=1}^n\r\ng\\left(\\left\\lfloor\\dfrac{n}{k}\\right\\rfloor\\right)\\]\r\n其中\\(k\\)就是不同的倍数。那么就可以写成关于\\(g(n)\\)的递推式：\r\n\\[g(n)=f(n)-\\sum_{k=2}^n\r\ng\\left(\\left\\lfloor\\dfrac{n}{k}\\right\\rfloor\\right)\\]\r\n右边的式子是一个明显的数论分块特征，最终使用数论分块来完成\\(g(n)\\)的计算。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;typedef long long ll;typedef unsigned long long ull;using namespace std;const int N=1e7;ull f[N+4]=&#123;0,0,0,1,1,2,3,5,6,9,11,15&#125;;ull g[N+4];ull cal(int n)&#123;    if(n&lt;=2) return 0;    if(g[n]!=0) return g[n];    ull ans=f[n];    for(int l=2,r;l&lt;=n;l=r+1)&#123;        r=n/(n/l);        ans-=cal(n/l)*(r-l+1);    &#125;    return g[n]=ans;&#125;int main()&#123;    for(int n=12;n&lt;=N;n++)        f[n]=(f[n-2]+f[n-3]+f[n-4])-(f[n-5]+f[n-6]+f[n-7])+f[n-9]+1;    ull ans=cal(N);    printf(&quot;%llu\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["OEIS","数论分块"]},{"title":"Project Euler 278","url":"/project-euler/278/","content":"\r\nProject Euler 278\r\n题目\r\nLinear Combinations of\r\nSemiprimes\r\nGiven the values of integers \\(1 &lt; a_1\r\n&lt; a_2 &lt; \\dots &lt; a_n\\), consider the linear\r\ncombination\r\n\\(q_1 a_1+q_2 a_2 + \\dots + q_n\r\na_n=b\\), using only integer values \\(q_k \\ge 0\\).\r\nNote that for a given set of \\(a_k\\), it may be that not all values of\r\n\\(b\\) are possible.\r\nFor instance, if \\(a_1=5\\) and \\(a_2=7\\), there are no \\(q_1 \\ge 0\\) and \\(q_2 \\ge 0\\) such that \\(b\\) could be\r\n\\(1, 2, 3, 4, 6, 8, 9, 11, 13, 16,\r\n18\\) or \\(23\\).\r\nIn fact, \\(23\\) is the largest\r\nimpossible value of \\(b\\) for \\(a_1=5\\) and \\(a_2=7\\).\r\nWe therefore call \\(f(5, 7) =\r\n23\\).\r\nSimilarly, it can be shown that \\(f(6, 10,\r\n15)=29\\) and \\(f(14, 22, 77) =\r\n195\\).\r\nFind \\(\\displaystyle \\sum f( p\\, q,p \\, r,\r\nq \\, r)\\), where \\(p\\), \\(q\\) and \\(r\\) are prime numbers and \\(p &lt; q &lt; r &lt; 5000\\).\r\n解决方案\r\n这篇论文给出了这种硬币问题的一个特殊场景（定理\\(1\\)）：\r\n假设序列\\([a_1,a_2,\\dots,a_k]\\)中的这些数两两互质，令\\(P=\\prod_{i=1}^k\r\na_i,A_i=\\dfrac{P}{a_i},B=\\sum_{i=1}^k A_i\\)。\r\n那么有\r\n\\[f(A_1,A_2,\\dots,A_k)=(k-1)P-B\\]\r\n回到本题。本题是这个结论\\(k=3\\)的情形，因此有：\\(f(pq,pr,qr)=2pqr-pq-pr-qr\\)\r\n令\\(N=5000\\)以内的所有质数存放在下标为\\(0\\)的数组\\(pr\\)，其长度假设为\\(m\\)。并令其前缀和为\\(s\\)，满足\\(s[k]=\\sum_{i=0}^k\r\npr[i].\\)使用前缀和可以将上面的求和计算优化到\\(O(N)\\)的时间复杂度。枚举质数\\(q\\)，其为第\\(i\\)个质数\\(pr[i]\\)，那么左边的\\(p\\)和右边的\\(r\\)任意组合，可以计算出上式每一块的贡献值：\r\n\r\n\\(2pqr:2\\cdot q \\cdot(s[m-1]-s[i]) \\cdot\r\ns[i-1]\\)\r\n\\(pr:(s[m-1]-s[i]) \\cdot\r\ns[i-1]\\)\r\n\\(pq:s[i-1] \\cdot q \\cdot (m - 1 -\r\ni)\\)\r\n\\(qr:(s[m-1] - s[i]) \\cdot q \\cdot\r\ni\\)\r\n\r\n注意前两块可以合并同类项。\r\n代码\r\nfrom tools import get_primeN = 5000pr = get_prime(N)s = []for p in pr:    s.append(p if len(s) == 0 else s[-1] + p)m = len(pr)ans = 0for i in range(1, len(pr) - 1):    q = pr[i]    ans += (s[-1] - s[i]) * s[i - 1] * (q * 2 - 1) - s[i - 1] * q * (m - 1 - i) - (s[-1] - s[i]) * q * iprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 279","url":"/project-euler/279/","content":"\r\nProject Euler 279\r\n题目\r\nTriangles\r\nwith integral sides and an integral angle\r\nHow many triangles are there with integral sides, at least one\r\nintegral angle (measured in degrees), and a perimeter that does not\r\nexceed \\(10^8\\)?\r\n解决方案\r\n可以知道，一个角为整数的情况下，仅有\\(60°,90°,120°\\)才满足题意。因此，本题综合了第75, 143, 195题的所有成果。直接使用它们的方法计算各自的三角形个数即可。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=100000000;int f1(int m,int n)&#123;return 5*m*n+2*m*m+2*n*n;&#125;int f2(int m,int n)&#123;return 3*m*n+3*m*m;&#125;int f3(int m,int n)&#123;return 3*m*n+2*m*m+n*n;&#125;int f4(int m,int n)&#123;return m*m+m*n;&#125;int main()&#123;    // 等腰三角形的情况    ll ans=N/3;    // 60    for(int m=2;f1(m,1)&lt;=N;m++)&#123;        for(int n=1,r;n&lt;m&amp;&amp;(r=f1(m,n))&lt;=N;n++)&#123;            if((m-n)%3&amp;&amp;__gcd(n,m)==1) ans+=N/r;        &#125;    &#125;    for(int m=2;f2(m,1)&lt;=N;m++)&#123;        for(int n=1,r;n&lt;m&amp;&amp;(r=f2(m,n))&lt;=N;n++)&#123;            if((m-n)%3&amp;&amp;__gcd(n,m)==1) ans+=N/r;        &#125;    &#125;    // 120    for(int m=2;f3(m,1)&lt;=N;m++)&#123;        for(int n=1,r;n&lt;m&amp;&amp;(r=f3(m,n))&lt;=N;n++)&#123;            if((m-n)%3&amp;&amp;__gcd(n,m)==1) ans+=N/r;        &#125;    &#125;    // 90    for(int m=3; f4(m,1)&lt;=N;m+=2)        for(int n=1,r;n&lt;m&amp;&amp;(r=f4(m,n))&lt;=N;n+=2)&#123;            if(__gcd(n,m)==1) ans+=N/r;        &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n使用Stern-Brocot\r\nTree可以优化多次计算最大公因数的过程：\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=100000000;ll ans=N/3;void dfs(int lu,int ld,int ru,int rd)&#123;    int n=lu+ru,m=ld+rd;    ll f1=5ll*m*n+2*m*m+2*n*n;    ll f2=3ll*m*n+3*m*m;    ll f3=3ll*m*n+2*m*m+n*n;    ll f4=1ll*m*m+m*n;    if(f1&gt;N&amp;&amp;f2&gt;N&amp;&amp;f3&gt;N&amp;&amp;f4&gt;N) return;    if((n-m)%3) ans+=1ll*N/f1+N/f2+N/f3;    if(n&amp;m&amp;1) ans+=N/f4;    dfs(lu,ld,n,m);    dfs(n,m,ru,rd);&#125;int main()&#123;    dfs(0,1,1,1);    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 282","url":"/project-euler/282/","content":"\r\nProject Euler 282\r\n题目\r\nThe Ackermann function\r\nFor non-negative integers \\(m, n\\),\r\nthe Ackermann function \\(A(m, n)\\) is\r\ndefined as follows:\r\n\\[A(m,n)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;n+1 &amp; &amp; \\text{if }  m=0 \\\\\r\n  &amp;A(m-1,1) &amp; &amp; \\text{if } m&gt;0\\text{ and } n=0\\\\\r\n  &amp;A(m-1,A(m,n-1)) &amp; &amp; \\text{if } m&gt;0\\text{ and }\r\nn&gt;0\\\\\r\n\\end{aligned}\\right.\\]\r\nFor example \\(A(1, 0) = 2, A(2, 2) =\r\n7\\) and \\(A(3, 4) = 125\\).\r\nFind \\(\\displaystyle\\sum_{n=0}^6\r\nA(n,n)\\) and give your answer mod \\(14^8\\).\r\n欧拉降幂公式\r\n欧拉降幂公式，用于高效计算\\(a^b\\%\r\nm\\)的值（尤其\\(b\\)很大时）：\r\n\\[\r\na^b\\equiv\r\n\\left \\{\\begin{aligned}\r\n  &amp;a^{b\\% \\varphi(m)}  &amp; &amp; \\text{if}\\quad \\gcd(a,m)=1 \\\\\r\n  &amp;a^b &amp; &amp; \\text{else if}\\quad b&lt;\\varphi(m) &amp;\\pmod\r\nm\\\\\r\n  &amp;a^{b\\%\\varphi(m)+\\varphi(m)} &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n解决方案\r\n令\\(M=14^8\\)。\r\n该页面介绍了阿克曼函数的一部分内容：\r\n\\(\\begin{aligned}\r\n&amp;A(0,n)=n+1;\\\\\r\n&amp;A(1,n)=n+2\\\\\r\n&amp;A(2,n)=2n+3;\\\\\r\n&amp;A(3,n)=2^{n+3}-3;\\\\\r\n&amp;A(m,n)=2\\uparrow^{m-2} (n+3)-3;\r\n\\end{aligned}\\)\r\n那么可以知道\r\n\r\n\\(A(5,5)=2\\uparrow^3 8-3=2\\uparrow^2\r\n(2\\uparrow^3 7)-3;\\)\r\n\\(A(6,6)=2\\uparrow^{4}9-3=2\\uparrow^3\r\n(2\\uparrow^4 8)-3=2\\uparrow^2 (2\\uparrow^3 ((2\\uparrow^4\r\n8)-1))-3.\\)\r\n\r\n可以知道，无论是\\(2\\uparrow^3\r\n7\\)还是\\(2\\uparrow^3 ((2\\uparrow^4\r\n8)-1)\\)都是非常大的数。我们使用欧拉降幂公式来计算\\(2\\uparrow^{2} n\\% M\\)的值。\r\n通过进一步打表发现，当\\(n\\)超过某个很小的正整数\\(n_0\\)后，数值\\(2\\uparrow^{2} n\\%\r\nM\\)的大小是恒定的。（打表程序和表内容如下所示）\r\nfor n in range(30):    print(n, dfs(2, n, mod)[0])\r\n0 11 22 43 164 655365 8040230406 13815362567 9156270088 1067397129 40792115210 82957516811 82957516812 82957516813 82957516814 82957516815 82957516816 82957516817 82957516818 82957516819 82957516820 82957516821 82957516822 82957516823 82957516824 82957516825 82957516826 82957516827 82957516828 82957516829 829575168\r\n由此我们可以判断出\\(A(5,5)\\%\r\nM\\)的值和\\(A(6,6)\\%\r\nM\\)的值是一样的，均为\\(2\\uparrow^{10}\\%M-3\\)。由此可以直接计算出相应的答案。\r\n代码\r\nfrom tools import phifrom math import logmod = 14 ** 8def dfs(a: int, f: int, mod: int):    if f &lt;= 1:        return pow(a, f, mod), False    elif mod == 1:        return 0, True    else:        ph = phi(mod)        val, flag = dfs(a, f - 1, ph)        if flag or val * log(a) &gt;= log(mod):            return pow(a, val + ph, mod), True        else:            return pow(a, val, mod), Falsedef cal(n):    if n == 0:        return n + 1    elif n == 1:        return n + 2    elif n == 2:        return 2 * n + 3    elif n == 3:        return pow(2, n + 3, mod) - 3    elif n == 4:        return dfs(2, n + 3, mod)[0] - 3    else:        return dfs(2, 10, mod)[0] - 3ans = sum(cal(x) for x in range(1, 7)) % modprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 28","url":"/project-euler/28/","content":"\r\nProject Euler 28\r\n题目\r\nNumber spiral diagonals\r\nStarting with the number \\(1\\) and\r\nmoving to the right in a clockwise direction a \\(5\\) by \\(5\\) spiral is formed as follows:\r\n\r\n21 22 23 24 25 20  7  8  9 10 19  6  1  2 11 18  5  4  3 12 17 16 15 14 13\r\n\r\nIt can be verified that the sum of the numbers on the diagonals is\r\n\\(101\\). What is the sum of the numbers\r\non the diagonals in a \\(1001\\) by \\(1001\\) spiral formed in the same way?\r\n解决方案\r\n容易观察到，从里面向外，每一个圈都会比里面的一个圈多\\(8\\)个元素。（以上图为例，第\\(1\\)个圈为\\(1\\)，第\\(2\\)个圈为\\(2\\sim9\\)，第\\(3\\)个圈为\\(10\\sim25\\)）。\r\n因此，在第\\(n\\)个圈中，四个角上的数可以分别用一个二次多项式\\(p(n)=an^2+bn+c\\)来定义这个通项公式。\r\n这里不再详细计算。\r\n通过OEIS查询，可以发现：\r\n右下角的通项公式为A054554，\\(4n^2-10n+7\\);\r\n左下角的通项公式为A053755，\\(4(n-1)^2+1\\);\r\n左上角的通项公式为A054569，\\(4n^2-6n+3\\);\r\n右上角的通项公式为\\((2n-1)^2\\).\r\n因此可以直接取所有值相加。\r\n也可以再用平方和公式进一步导出结果：\\(\\dfrac{2}{3}(8n^3-9n^2+7n)-3\\)\r\n代码\r\nNOTE: 本代码只适用于矩阵大小为奇数时的情况。\r\nN = 1001ans = 0# 1~N/2+1：从内向外的圈数。for i in range(1, N // 2 + 2):    ans += 4 * i * i - 10 * i + 7    ans += 4 * (i - 1) * (i - 1) + 1    ans += 4 * i * i - 6 * i + 3    ans += (2 * i - 1) ** 2# 中心点算重复了3次，故减去。ans -= 3print(ans)\r\nN = 1001N = N // 2 + 1ans = (8 * N ** 3 - 9 * N ** 2 + 7 * N) * 2 // 3 - 3print(ans)\r\n","categories":["Project Euler"],"tags":["OEIS"]},{"title":"Project Euler 285","url":"/project-euler/285/","content":"\r\nProject Euler 285\r\n题目\r\nPythagorean odds\r\nAlbert chooses a positive integer \\(k\\), then two real numbers \\(a, b\\) are randomly chosen in the interval\r\n\\([0,1]\\) with uniform\r\ndistribution.\r\nThe square root of the sum \\((k\\cdot\r\na+1)^2 + (k\\cdot b+1)^2\\) is then computed and rounded to the\r\nnearest integer. If the result is equal to \\(k\\), he scores \\(k\\) points; otherwise he scores\r\nnothing.\r\nFor example, if \\(k = 6, a = 0.2\\)\r\nand \\(b = 0.85\\), then \\((k\\cdot a+1)^2 + (k\\cdot\r\nb+1)^2 = 42.05\\).\r\nThe square root of \\(42.05\\) is\r\n\\(6.484\\dots\\) and when rounded to the\r\nnearest integer, it becomes \\(6\\).\r\nThis is equal to \\(k\\), so he scores\r\n\\(6\\) points.\r\nIt can be shown that if he plays \\(10\\) turns with \\(k = 1, k = 2, …, k = 10\\), the expected\r\nvalue of his total score, rounded to five decimal places, is \\(10.20914\\).\r\nIf he plays \\(10^5\\) turns with\r\n\\(k = 1, k = 2, k = 3, …, k = 10^5\\),\r\nwhat is the expected value of his total score, rounded to five decimal\r\nplaces?\r\n解决方案\r\n用数形结合的方法解决本问题。\r\n\r\n如果\\(a,b\\)分别是从\\([0,1]\\)中均匀选择的，那么令\\(x=ka+1,y=kb+1\\)，可以表示成一个点将在如图所示的正方形\\((1,1)-(k+1,k+1)\\)中选。\r\n在原点画一个半径为\\(k\\)的圆。可以发现，如果最终\\(\\sqrt{x^2+y^2}\\)可以四舍五入到\\(k\\)，那么\\(|\\sqrt{x^2+y^2}-k|\\leq\r\n\\dfrac{1}{2}\\)，因此，画两个半径为\\(k+\\dfrac{1}{2}\\)和\\(k-\\dfrac{1}{2}\\)。只要在这两个圆之间的所有点，都满足这个条件。\r\n因此，游戏成功的概率就为该上图中阴影面积占整个正方形选择区域的面积比率。\r\n每一场游戏都是独立的，计算出结果相加即可。\r\n需要注意当\\(k=1\\)时，这两个圆的内圆和正方形不相交。\r\n代码\r\nfrom math import asin, cos, pi# 计算整块在正方形内部的图形面积def cal(r: float):    sinT = 1 / r    T = asin(sinT)    A = pi / 2 - 2 * T    # 扇形面积    all_area = A * r * r / 2    return all_area - 0.5 * (r * cos(T) - 1) * 1 * 2N = 10 ** 5# 当k = 1时，特殊处理。ans = cal(1 + 0.5) / (1 ** 2) * 1for k in range(2, N + 1):    ans += (cal(k + 0.5) - cal(k - 0.5)) / (k ** 2) * kprint(&quot;&#123;:.5f&#125;&quot;.format(ans))\r\n","categories":["Project Euler"],"tags":["概率"]},{"title":"Project Euler 284","url":"/project-euler/284/","content":"\r\nProject Euler 284\r\n题目\r\nSteady Squares\r\nThe \\(3\\)-digit number \\(376\\) in the decimal numbering system is an\r\nexample of numbers with the special property that its square ends with\r\nthe same digits: \\(376^2 = 141376\\).\r\nLet’s call a number with this property a steady square.\r\nSteady squares can also be observed in other numbering systems. In\r\nthe base \\(14\\) numbering system, the\r\n\\(3\\)-digit number \\(c37\\) is also a steady square: \\(c37^2 = aa0c37\\), and the sum of its digits\r\nis \\(c+3+7=18\\) in the same numbering\r\nsystem. The letters \\(a, b, c\\) and\r\n\\(d\\) are used for the \\(10, 11, 12\\) and \\(13\\) digits respectively, in a manner\r\nsimilar to the hexadecimal numbering system.\r\nFor \\(1 \\le n \\le 9\\), the sum of\r\nthe digits of all the \\(n\\)-digit\r\nsteady squares in the base \\(14\\)\r\nnumbering system is \\(2d8\\) (\\(582\\) decimal). Steady squares with leading\r\n\\(0\\)’s are not allowed.\r\nFind the sum of the digits of all the n-digit steady squares in the\r\nbase \\(14\\) numbering system for \\(1 \\le n \\le 10000\\) (decimal) and give your\r\nanswer in the base \\(14\\) system using\r\nlower case letters where necessary.\r\n解决方案\r\n不难发现，如果一个\\(n\\)位\\(14\\)进制数是满足题意，那么它满足以下方程：\r\n\\[a^2\\equiv a\\pmod {14^n}\\]\r\n可以将其重新写成\\(a^2-a\\equiv0\\pmod\r\n{14^n}\\)。并且，方程的两个解\\(x_n,y_n\\)将会满足\\(x_n+y_n=14^n+1\\)，并且两个解的个位分别为\\(7\\)和\\(8\\)。因此，一对解中，除了其最低位之和为\\(15\\)，所有的对应位之和为\\(13\\)。根据中国剩余定理，不失一般性，假设\\(x_n\\equiv 1\\pmod {2^n},x_n\\equiv0\\pmod\r\n{7^n}\\)。\r\n通过进一步打表可以发现，在方程\\(a^2-a\\equiv0\\pmod\r\n{14^n}\\)的两个解的最高位中再添加一位，即可变成方程\\(a^2-a\\equiv0 \\pmod {14^{n+1}}\\)的解\\(x_{n+1},y_{n+1}\\)。\r\n令这个数位为\\(d\\)。那么令\\(x_{n+1}=14^nd + x_n\\)，并且有\\(x_{n+1}^2\\equiv x_{n+1}\\pmod\r\n{14^{n+1}}\\)\r\n联立后，得到\\(14^{2n}d^2+2\\cdot 14^nd\\cdot\r\nx_n+x_n^2\\equiv14^nd+x_n\\pmod {14^{n+1}}\\)\r\n最终，左边第一项明显是\\(14^{n+1}\\)的倍数；对于第二项，由于\\(x_n\\equiv0\\pmod\r\n{7^n}\\)，因此第二项也是\\(14^{n+1}\\)的倍数。\r\n因此，方程最终化成：\r\n\\[d\\equiv\\dfrac{x_n^2-x_n}{14^n}\\pmod\r\n{14}\\]\r\n因此将计算出的\\(d\\)拼接在\\(x_n\\)的最高位，形成\\(x_{n+1}\\)。\r\n最终直接统计即可。\r\n代码\r\n本题使用了GMP库进行大整数运算。\r\n#include &lt;bits/stdc++.h&gt;#include&lt;gmpxx.h&gt;using namespace std;typedef long long ll;const int N=10000,B=14;string to_B(mpz_class a)&#123;    string s;    for(;a;a/=B)&#123;        mpz_class b=a.get_si()%B;        int x=b.get_si();        if(x&lt;10) s+=char(&#x27;0&#x27;+x);        else s+=char(&#x27;a&#x27;+x-10);    &#125;    reverse(s.begin(),s.end());    return s;&#125;int f(int now)&#123;    int ans=1;    int d=now,s=0;    mpz_class x=0,pw=1,t;    for(int n=1;n&lt;=N;n++)&#123;        s+=d;        if(d==0) ans+=n*(B-1)+2-s;        else if(d==B-1) ans+=s;        else ans+=n*(B-1)+2;        x+=pw*d;pw*=B;        t=x*(x-1)/pw%B;        d=t.get_si();    &#125;    return ans;&#125;int main() &#123;    string ans=to_B(f(B/2));    cout&lt;&lt;ans&lt;&lt;endl;&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 286","url":"/project-euler/286/","content":"\r\nProject Euler 286\r\n题目\r\nScoring probabilities\r\nBarbara is a mathematician and a basketball player. She has found\r\nthat the probability of scoring a point when shooting from a distance\r\n\\(x\\) is exactly \\(\\left(1-\\dfrac{x}{q}\\right)\\), where \\(q\\) is a real constant greater than \\(50\\).\r\nDuring each practice run, she takes shots from distances \\(x=1, x=2, \\dots, x=50\\) and, according to\r\nher records, she has precisely a \\(2\\%\\) chance to score a total of exactly\r\n\\(20\\) points.\r\nFind \\(q\\) and give your answer\r\nrounded to \\(10\\) decimal places.\r\n解决方案\r\n令\\(N=50,M=20,Q=0.02\\)。如果\\(q\\)值确定了，那么可以使用动态规划的思想计算投篮\\(N\\)次，命中恰好\\(M\\)次的概率。\r\n假设状态\\(f(i,j)(0\\le i\\le N,0\\le j\\le\r\n\\min(i,M))\\)为已经投篮了\\(i\\)次，恰好命中了\\(j\\)次的概率，那么不难写出如下状态转移方程：\r\n\\[\r\nf(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0  &amp; &amp; \\text{if}\\quad i=0 \\\\\r\n  &amp;f(i-1,j)\\cdot\\dfrac{i}{q} &amp; &amp; \\text{else if}\\quad j=0 \\\\\r\n  &amp;f(i-1,j-1)\\cdot\\left(1-\\dfrac{i}{q}\\right) &amp; &amp; \\text{else\r\nif}\\quad j=i \\\\\r\n  &amp;f(i-1,j)\\cdot\\dfrac{i}{q} +\r\nf(i-1,j-1)\\cdot\\left(1-\\dfrac{i}{q}\\right)&amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n对于方程最后一行，前一项从\\(f(i-1,j)\\)时投篮不中转移过来，后一项则从\\(f(i-1,j-1)\\)时投篮命中转移过来。\r\n当\\(q=50\\)时，发现\\(f(N,M)\\)约为\\(0.0412\\)，随着\\(q\\)的上升，发现\\(f(N,M)\\)下降得很快，因此考虑进行浮点数上的二分：如果\\(f(N,M)&gt;Q\\)，那么说明\\(q\\)太小，否则\\(q\\)太大。\r\n代码\r\nN = 50M = 20Q = 0.02l = Nr = N &lt;&lt; 1for _ in range(100):    q = 0.5 * (l + r)    f = [[0 for i in range(M + 1)] for j in range(N + 1)]    f[0][0] = 1    for i in range(1, N + 1):        rt = 1 - i / q        for j in range(min(i, M) + 1):            if j &gt; 0:                f[i][j] += f[i - 1][j - 1] * rt            if j &lt; i:                f[i][j] += f[i - 1][j] * (1 - rt)    if f[N][M] &gt; Q:        l = q    else:        r = qans = lprint(&quot;&#123;:.10f&#125;&quot;.format(ans))\r\n","categories":["Project Euler"],"tags":["动态规划","概率","二分"]},{"title":"Project Euler 288","url":"/project-euler/288/","content":"\r\nProject Euler 288\r\n题目\r\nAn enormous factorial\r\nFor any prime \\(p\\) the number \\(N(p,q)\\) is defined by \\(N(p,q) = \\sum_{n=0\\text{ to }q} T_n*p^n\\)\r\nwith \\(T_n\\) generated by the following\r\nrandom number generator:\r\n\\[\\begin{aligned}\r\nS_0 &amp;= 290797\\\\\r\nS_{n+1} &amp;= S_n^2 \\bmod 50515093\\\\\r\nT_n &amp;= S_n \\bmod p\r\n\\end{aligned}\\]\r\nLet \\(\\text{Nfac}(p,q)\\) be the\r\nfactorial of \\(N(p,q)\\).\r\nLet \\(\\text{NF}(p,q)\\) be the number\r\nof factors \\(p\\) in \\(\\text{Nfac}(p,q)\\).\r\nYou are given that \\(\\text{NF}(3,10000)\r\n\\bmod 3^{20}=624955285\\).\r\nFind \\(\\text{NF}(61,10^7) \\bmod\r\n61^{10}\\).\r\n解决方案\r\n设\\(f(n, p)\\)是质因子\\(p\\)在\\(n!\\)中的次数，那么\\(f(n,p)=\\left\\lfloor\\dfrac{n}{p}\\right\\rfloor+\\left\\lfloor\\dfrac{n}{p^2}\\right\\rfloor+\\left\\lfloor\\dfrac{n}{p^3}\\right\\rfloor+\\dots\\)，每一项分别表示\\(1\\sim n\\)中有多少个数是\\(p,p^2,p^3\\dots\\)的倍数。\r\n那么，\\(\\text{NF}(p,q)=f(N(p,q),p)\\)。\r\n不过，恰巧的是，\\(N(p,q)\\)是一个关于\\(p\\)的\\(q\\)项式。因此，以\\(f(n,p)\\)的前两项为例子，有：\r\n\\(\\begin{aligned}\r\n&amp;\\left\\lfloor\\dfrac{N(p,q)}{p}\\right\\rfloor=\\sum_{i=1}^{q}\r\nT_ip^{i-1}\\\\\r\n&amp;\\left\\lfloor\\dfrac{N(p,q)}{p^2}\\right\\rfloor=\\sum_{i=2}^{q}\r\nT_ip^{i-2}\\\\\r\n&amp;\\dots\\\\\r\n&amp;\\left\\lfloor\\dfrac{N(p,q)}{p^q}\\right\\rfloor=T_q\\\\\\\\\r\n\\end{aligned}\\)\r\n那么，可以写出\r\n\\[\\text{NF}(p,q)=\\sum_{k=1}^q\\sum_{i=k}^qT_ip^{i-k}=\\sum_{i=1}^qT_i\\sum_{k=0}^{i-1}p^k\\]\r\n那么，式子两边可以分别同步计算\\(T_i\\)和\\(\\sum_{k=0}^{i-1}p^k\\)的值，最终重新相乘即可。\r\n一个可以优化的地方：由于取模数恰好是一个\\(p^K\\)，其中\\(K=10\\)，因此计算\\(\\sum_{k=0}^{i-1}p^i\\%\r\np^K\\)时，会发现到了第\\(K\\)项之后，值都是一样的。最终，计算过程节省了取模这一步骤。\r\n代码\r\nP = 61Q = 10 ** 7mod = 61 ** 10s = 290797sp = 1ans = 0for i in range(Q):    s = s * s % 50515093    t = s % P    ans = (ans + t * sp) % mod    sp = (sp * P + 1) % modprint(ans)\r\nP = 61Q = 10 ** 7N = 10mod = P ** Ns = 290797sp = 1ans = 0for i in range(Q):    s = s * s % 50515093    t = s % P    ans = (ans + t * sp) % mod    if i &lt; N:        sp = sp * P + 1print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 287","url":"/project-euler/287/","content":"\r\nProject Euler 287\r\n题目\r\nQuadtree\r\nencoding (a simple compression algorithm)\r\nThe quadtree encoding allows us to describe a \\(2^N\\times 2^N\\) black and white image as a\r\nsequence of bits (0 and 1). Those sequences are to be read from left to\r\nright like this:\r\n\r\nthe first bit deals with the complete \\(2^N\\times 2^N\\) region; “0” denotes a\r\nsplit:\r\nthe current \\(2^n\\times 2^n\\)\r\nregion is divided into 4 sub-regions of dimension \\(2^{n-1}\\times 2^{n-1}\\), the next bits\r\ncontains the description of the top left, top right, bottom left and\r\nbottom right sub-regions - in that order;\r\n“10” indicates that the current region contains only black\r\npixels;\r\n“11” indicates that the current region contains only white pixels.\r\nConsider the following \\(4\\times 4\\)\r\nimage (colored marks denote places where a split can occur):\r\n\r\n\r\nThis image can be described by several sequences, for example:\r\n“001010101001011111011010101010”,\r\nof length \\(30\\), or\r\n“0100101111101110”, of\r\nlength \\(16\\), which is the minimal\r\nsequence for this image.\r\nFor a positive integer \\(N\\), define\r\n\\(D_N\\) as the \\(2^N\\times 2^N\\) image with the following\r\ncoloring scheme:\r\n\r\nthe pixel with coordinates \\(x = 0,\r\ny = 0\\) corresponds to the bottom left pixel,\r\nif \\((x-2^{N-1})^2 + (y-2^{N-1})^2 \\leq 2^{2N-2}\\)\r\nthen the pixel is black,\r\notherwise the pixel is white.\r\n\r\nWhat is the length of the minimal sequence describing \\(D_{24}\\) ?\r\n解决方案\r\n以\\(N=4\\)为例，打印出来的图像是这个样子的（已经均分成四块，并且额外多打印了一行和一列）：\r\n00000000 10000000 000000111 11110000 000011111 11111100 000111111 11111110 000111111 11111110 001111111 11111111 001111111 11111111 001111111 11111111 011111111 11111111 101111111 11111111 001111111 11111111 001111111 11111111 000111111 11111110 000111111 11111110 000011111 11111100 000000111 11110000 000000000 10000000 0\r\n假设左上角为\\((0,0)\\)坐标。可以发现这个图形是一个圆。并且，不难证明这个图形是关于\\(y=x\\)这条直线对称的。因此我们一开始只需要对其中的\\(3\\)块进行计算。\r\n我们考虑对将右下角的图形对称操作，从而得到和另外三部分完全相同的图形。\r\n令\\(x_0=2^{N-1},y_0=2^{N-1}\\)，那么右下方的图形就是以点\\((x_0,y_0)\\)为左上角的边长为\\(2^{N-1}\\)的正方形。左下方的图形就相当于以点\\((x_0+1,y_0)\\)为左上角的正方形垂直对称得到。左上角的图形就相当于以点\\((x_0+1,y_0+1)\\)为左上角的正方形旋转\\(180°\\)得到。\r\n将左上方和左下方截取出来和右下方根据\\((x_0+1,y_0+1),(x_0+1,y_0)\\)截取出来对比的效果：\r\n11111111   1111111 101111111   1111111 001111111   1111111 001111111   1111111 000111111   1111110 000111111   1111110 000011111   1111100 000000111   1110000 000000000   1111111 000000111   1111111 000011111   1111111 000111111   1111110 000111111   1111110 001111111   1111100 001111111   1110000 001111111            0000000 0\r\n因此我们只关注右下方这一部分的圆（只是位置不同），最终将编码的长度相加起来即可。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=24;ll M=1&lt;&lt;(N-1);ll D=M*M;ll dfs(ll x,ll y,ll sz)&#123;    // 全白    ll dx=x-M,dy=y-M;    if(dx*dx+dy*dy&gt;D) return 2;    // 全黑    dx=x+sz-1-M;dy=y+sz-1-M;    if(dx*dx+dy*dy&lt;=D) return 2;    if(sz==2) return 9;    sz&gt;&gt;=1;    return dfs(x,y,sz)+dfs(x+sz,y+sz,sz)+dfs(x+sz,y,sz)+dfs(x,y+sz,sz)+1;&#125;int main()&#123;    ll ans=dfs(M,M,M)+dfs(M+1,M,M)*2+dfs(M+1,M+1,M)+1;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 290","url":"/project-euler/290/","content":"\r\nProject Euler 290\r\n题目\r\nDigital Signature\r\nHow many integers \\(0 \\le n &lt;\r\n10^{18}\\) have the property that the sum of the digits of \\(n\\) equals the sum of digits of \\(137n\\)?\r\n解决方案\r\n令\\(N=18,M=137\\)，考虑使用动态规划解决本题。基本思想是：从低位到高位给\\(n\\)填上数位。因为只要低位先填好了，无论是\\(n\\)还是\\(Mn\\)，高位填的数不影响低位的数位和。令\\(d(n,m)\\)表示数字\\(n\\)的低\\(m\\)位和，\\(d(n)\\)表示数字\\(n\\)的数位和。本题的动态规划过程考虑使用“我为人人”的方法，因为本质上都是对当前状态的所有数都添加一个新的数位\\(d\\)，从而到达下一个状态。\r\n令状态\\(f(i,c,s)(i &lt; N,c &lt;\r\nM)\\)表示满足如下条件的填法数量：\r\n\r\n当前已经填充了低\\(i\\)个数位；\r\n其\\(M\\)的倍数仍在高位产生了\\(c\\)的进位；\r\n已经填入的低\\(i\\)位，其\\(M\\)倍的低\\(k\\)位数位和与自身的数位和之差，也就是\\(s=d(Mn,k)-d(n,k)\\)。\r\n\r\n那么当\\(i=0\\)时，\\(f(0,0,0)=1\\)。其余\\(i=0\\)时的情况为\\(0\\)。\r\n考虑对\\(f(i,c,s)\\)中的所有数的第\\(i+1\\)位都拼接一个新的数位\\(0\\le d\\le 9\\)，那么可以进行转移：\r\n\\(c(i,c,s)\\rightarrow\r\nc(i+1,\\lfloor(c+Md)/10\\rfloor,s+(c+Md)\\%10-d)\\)\r\n原来的进位\\(c\\)再加上当前的\\(Md\\)后，其十位以上的数位变成了新的进位；而其个位则为当前数位。对于新数，\\(Mn\\)增加了一个数位\\((c+Md)\\%10\\)，而\\(n\\)增加了一个数位\\(d\\)，因此有如此转移过程。\r\n对于终点状态\\(f(N,\\cdot,\\cdot)\\)，由于进位\\(c\\)还没算上，因此仍然需要补上这些进位的数位之和再进行判断。因此最终答案为\r\n\\[\\sum_{c=0}^{M-1}\r\nf(N,c,-d(c))\\]\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=18,M=137;const int B= M*(2+log10(M));ll f[N+1][M][B+B];int main()&#123;    f[0][0][B] = 1;    for(int i=0;i&lt;N;i++)        for(int c=0;c&lt;M;c++)            for(int s=0;s&lt;B+B;s++)&#123;                if(f[i][c][s]==0) continue;                for(int d = 0;d &lt; 10;d++)&#123;                    int nc = (c+d*M)/10;                    int ns = s+(c+d*M)%10-d;                    f[i+1][nc][ns]+=f[i][c][s];                &#125;            &#125;    ll ans=0;    for(int c=0;c&lt;M;c++)&#123;        int ds=0;        for(int t=c;t;t/=10) ds+=t%10;        ans+=f[N][c][B-ds];    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 29","url":"/project-euler/29/","content":"\r\nProject Euler 29\r\n题目\r\nDistinct powers\r\nConsider all integer combinations of \\(a^b\\) for \\(2 \\le\r\na \\le 5\\) and \\(2 \\le b \\le\r\n5\\):\r\n\\[2^2=4, 2^3=8, 2^4=16, 2^5=32\\]\r\n\\[3^2=9, 3^3=27, 3^4=81, 3^5=243\\]\r\n\\[4^2=16, 4^3=64, 4^4=256, 4^5=1024\\]\r\n\\[5^2=25, 5^3=125, 5^4=625,\r\n5^5=3125\\]\r\nIf they are then placed in numerical order, with any repeats removed,\r\nwe get the following sequence of \\(15\\)\r\ndistinct terms:\r\n\\[4, 8, 9, 16, 25, 27, 32, 64, 81, 125,\r\n243, 256, 625, 1024, 3125\\] How many distinct terms are in the\r\nsequence generated by \\(a^b\\) for \\(2\\le a \\le 100\\) and \\(2 \\le  b \\le 100\\)?\r\n解决方案\r\n使用Python计算大数的特点，可以直接将所有数计算出来。\r\n另外一种方案是，把每个数对\\(e\\)取对数，然后把\\(b\\ln\r\na\\)计算出来。不过这种做法的代价是需要特别注意浮点数的误差。\r\n代码\r\nN = 100ans = len(set(a ** b for a in range(2, N + 1) for b in range(2, N + 1)))print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 291","url":"/project-euler/291/","content":"\r\nProject Euler 291\r\n题目\r\nPanaitopol Primes\r\nA prime number \\(p\\) is called a\r\nPanaitopol prime if \\(p = \\dfrac{x^4 -\r\ny^4}{x^3 + y^3}\\) for some positive integers \\(x\\) and \\(y\\).\r\nFind how many Panaitopol primes are less than \\(5\\times10^{15}\\).\r\n解决方案\r\n令\\(g=\\gcd(x,y)\\)，那么有\\(x=ga,y=gb\\)，其中\\(\\gcd(a,b)=1\\)。\r\n将上式写成\\(p(x^3+y^3)=x^4-y^4\\)，那么可以写成：\r\n\\[p(a^2-ab+b^2)=d(a^2+b^2)(a-b)\\]\r\n那么，\\(a^2-ab+b^2,(a^2+b^2)(a-b)\\)这两个数是互质的。\r\n因此，\\(p=(a^2+b^2)(a-b),d=a^2-ab+b^2\\)。\r\n但是，\\(p\\)是一个质数，但是有\\(a^2+b^2\\)和\\(a-b\\)两个质因式。因此\\(a-b=1\\)。\r\n得到\\(p\\)是形如\\(p=a^2+(a+1)^2\\)的质数。\r\n令\\(f(n)=2n^2+2n+1\\)\r\n那么接下来使用和216题相似的筛法：如果\\(p\\mid f(n)\\)，那么\\(p\\mid f(kp+n),p\\mid f(kp-n-1)\\)，其中\\(k&gt;0\\)。\r\n原因：\\(f(kp+n)=2(kp+n)^2+2(kp+n)+1 =\r\n2k^2p^2+4knp+2kp+2n^2+2n+1\\)。我们已经假定了\\(p\\mid 2n^2+2n+1\\)，因此\\(p\\mid f(kp+n)\\)成立。\\(p\\mid f(kp-n-1)\\)的情况类似。\r\n这说明只要发现\\(f(n)\\)有一个质因子\\(p\\)，就可以将它把\\(f(n+p),f(n+2p),\\dots,f(p-n-1),t(2p-n-1),\\dots\\)筛掉。\r\n如果有一个数始终无法筛掉，说明它本身就是一个质数。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const ll N=5e15;const int M= sqrt(N/2)+10;ll f[M+4];int main()&#123;    int m;    for(int i=1;i&lt;=M;i++)&#123;        f[i]=2ll*i*(i+1)+1;        if(f[i]&gt;=N)&#123;            m=i-1;break;        &#125;    &#125;    int ans=0;    for(int i=1;i&lt;=m;i++)&#123;        ll p=f[i];        if(p==2ll*i*(i+1)+1) ++ans;        if(p==1) continue;        for(ll j=p+i;j&lt;=m;j+=p)            while (f[j]%p==0) f[j]/=p;        for(ll j=p-i-1;j&lt;=m;j+=p)            while (f[j]%p==0) f[j]/=p;    &#125;    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 292","url":"/project-euler/292/","content":"\r\nProject Euler 292\r\n题目\r\nPythagorean Polygons\r\nWe shall define a pythagorean polygon to be a convex\r\npolygon with the following properties:\r\n\r\nthere are at least three vertices,\r\nno three vertices are aligned,\r\neach vertex has integer coordinates,\r\neach edge has integer length.\r\n\r\nFor a given integer \\(n\\), define\r\n\\(P(n)\\) as the number of distinct\r\npythagorean polygons for which the perimeter is \\(\\le n\\).\r\nPythagorean polygons should be considered distinct as long as none is\r\na translation of another.\r\nYou are given that \\(P(4)=1,\r\nP(30)=3655\\) and \\(P(60)=891045\\).\r\nFind \\(P(120)\\).\r\n解决方案\r\n这题可以使用动态规划来解决。令\\(N=120\\)。\r\n我们可以将所有凸多边形的每一条边都加上同一个方向的箭头，以此方便进行我们进行动态规划状态的设计。\r\n首先枚举出所有模长\\(\\le\r\nN\\)的位移向量\\((x,y,d),d=\\sqrt{x^2+y^2}\\)，存储在数组\\(v\\)中，并且将\\(v\\)中所有向量按照极角进行排序。此处假设所有位移向量\\(v\\)已经从小到大排好序（也就是逆时针方向）。并且，我们已经离散化好所有极角，假设一共有\\(m\\)种不同的极角，且第\\(i\\)小的极角大小为\\(i\\)。我们还需要注意的是，同一极角下的向量最多只能用一个，否则将会造成两条共线的边退化成同一条边，这些向量已经存储在了\\(u[i]\\)中。\r\n令状态\\(f(i,x,y,d)(i\\ge 0,0\\le d\\le\r\nN)\\)表示从原点\\((0,0)\\)起，使用了前\\(i\\)种极角不同的向量后，走到了位置\\((x,y)\\)，并且走过距离为\\(d\\)的方案数。一开始没有进行任何位移时，就没有使用任何的位移向量，因此\\(f(0,0,0,0)=1\\)。\r\n本题的动态规划过程考虑使用 “我为人人”\r\n的方法，本质上是从当前状态使用了其中一个属于\\(u[i]\\)的向量走到了下一步，有如下两种转移方式。\r\n\\(f(i,x,y,d)\\rightarrow\r\nf(i+1,x,y,d)\\)，也就是说，第\\(i\\)种位移向量不被使用。\r\n\\(f(i,x,y,d)\\rightarrow\r\nf(i+1,x+p.x,y+p.y,d+p.d)\\)，其中位移向量\\(p\\in u[i+1]\\)。\r\n那么最终答案为\\(\\displaystyle{\\sum_{d=1}^N\r\nf(m,0,0,d)}-c(v)\\)。其中\\(c(v)\\)表示\\(v\\)中所有位移向量中，长度不超过\\(\\dfrac{N}{2}\\)的个数的一半（因为我们还需要排除这种步行\\(2\\)步，直接掉头回到原点的情况。）\r\n为了加快程序的运行效率，实现时进行了如下优化：\r\n\r\n只考虑满足\\(x^2+y^2\\le\r\n\\dfrac{N^2}{4}\\)中的所有点，因为走出了这个范围的点最终没有足够距离走回点\\((0,0)\\)。\r\n\r\n代码\r\n#include &lt;bits/stdc++.h&gt;# define pi pair&lt;int,int&gt;# include &quot;tools.h&quot;using namespace std;typedef long long ll;const int N=120;struct V&#123;    int x,y,d;    int operator ^ (V &amp;v) const&#123;        return x*v.y-y*v.x;    &#125;    bool operator &lt; (V &amp;v) const&#123;        return (*this^v)&gt;0;    &#125;&#125;;const int O=N*2;int ok[O*2+4][O*2+4];ll f[2][O*2+4][O*2+4][N+4];int main()&#123;    vector&lt;V&gt;v;    vector&lt;pi&gt;pt_ls;    for(int x=-N;x&lt;=N;x++)        for(int y=-N;y&lt;=N;y++)&#123;            int d2=x*x+y*y;            if(d2&lt;=N*N/4) pt_ls.emplace_back(O+x,O+y),ok[O+x][O+y]=1;            if(d2&lt;=N*N&amp;&amp;is_square(d2)&amp;&amp;d2!=0)&#123;                int d=int_square(d2);                v.push_back(V&#123;x,y,d&#125;);            &#125;        &#125;    sort(v.begin(),v.end());    while (v.size()&gt;1&amp;&amp;(v.front()^v.back())==0)&#123;        v.push_back(v.front());v.erase(v.begin());    &#125;    int m=v.size(),p=0;    f[0][O][O][0]=1;    for(int i=0,j;i&lt;m;i=j,p^=1)&#123;        for(j=i;j&lt;m&amp;&amp;(v[i]^v[j])==0;++j);        for(auto &amp;[px,py]:pt_ls) &#123;            for (int d=0;d&lt;=N;d++) &#123;                f[p^1][px][py][d]=f[p][px][py][d];            &#125;        &#125;        for(auto &amp;[px,py]:pt_ls) &#123;            for (int d=0;d&lt;=N;d++) &#123;                if(!f[p][px][py][d]) continue;                for(int k=i;k&lt;j;k++)&#123;                    int nx=px+v[k].x,ny=py+v[k].y;                    if(ok[nx][ny]&amp;&amp;v[k].d+d&lt;=N)                        f[p^1][nx][ny][v[k].d+d]+=f[p][px][py][d];                &#125;            &#125;        &#125;    &#125;    ll ans=0,t=0;    for(int d=1;d&lt;=N;d++)        ans+=f[p][O][O][d];    for(V &amp;p:v)        if(p.d*2&lt;=N) ++t;    ans-=t/2;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 293","url":"/project-euler/293/","content":"\r\nProject Euler 293\r\n题目\r\nPseudo-Fortunate Numbers\r\nAn even positive integer \\(N\\) will\r\nbe called admissible, if it is a power of \\(2\\) or its distinct prime factors are\r\nconsecutive primes.\r\nThe first twelve admissible numbers are \\(2,4,6,8,12,16,18,24,30,32,36,48\\).\r\nIf \\(N\\) is admissible, the smallest\r\ninteger \\(M &gt; 1\\) such that \\(N+M\\) is prime, will be called the\r\npseudo-Fortunate number for \\(N\\).\r\nFor example, \\(N=630\\) is admissible\r\nsince it is even and its distinct prime factors are the consecutive\r\nprimes \\(2,3,5\\) and \\(7\\).\r\nThe next prime number after \\(631\\)\r\nis \\(641\\); hence, the pseudo-Fortunate\r\nnumber for \\(630\\) is \\(M=11\\).\r\nIt can also be seen that the pseudo-Fortunate number for \\(16\\) is \\(3\\).\r\nFind the sum of all distinct pseudo-Fortunate numbers for admissible\r\nnumbers \\(N\\) less than \\(10^9\\).\r\n解决方案\r\n由于可接受数\\(N\\)是一个偶数，并且质因子是连续的。那么\\(N\\)就是形如这种形式：\\(2^a,2^a\\cdot\r\n3^b,2^a\\cdot3^b\\cdot5^c,\\dots\\)。总之，一个质因子被使用了，那么它前面的质因子也要被使用。\r\n那么这些数其实数量很少，并且最大质因子其实也很小，因此考虑直接枚举\\(N\\)。\r\n每枚举一个\\(N\\)，那么求对应的\\(M\\)，相当于求大于\\(N+1\\)的下一个质数。一个数的下一个质数通过素性测试算法直接枚举就不难找到。本代码直接使用sympy库的nextprime方法求下一个质数。\r\n代码\r\nfrom sympy import nextprimeN = 10 ** 9pr = []M = p = 1while True:    p = nextprime(p)    M *= p    if M &gt;= N:        break    pr.append(p)st = set()def dfs(f: int, n: int):    if f == len(pr):        return    while True:        n *= pr[f]        if n &gt;= N:            break        st.add(nextprime(n + 1) - n)        dfs(f + 1, n)dfs(0, 1)ans = sum(st)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 294","url":"/project-euler/294/","content":"\r\nProject Euler 294\r\n题目\r\nSum of digits - experience \\(\\#23\\)\r\nFor a positive integer \\(k\\), define\r\n\\(d(k)\\) as the sum of the digits of\r\n\\(k\\) in its usual decimal\r\nrepresentation. Thus \\(d(42) = 4+2 =\r\n6\\).\r\nFor a positive integer \\(n\\), define\r\n\\(S(n)\\) as the number of positive\r\nintegers \\(k &lt; 10^n\\) with the\r\nfollowing properties :\r\n\r\n\\(k\\) is divisible by \\(23\\) and\r\n\\(d(k) = 23\\).\r\n\r\nYou are given that \\(S(9) = 263626\\)\r\nand \\(S(42) = 6377168878570056\\).\r\nFind \\(S(11^{12})\\) and give your\r\nanswer mod \\(10^9\\).\r\n解决方案\r\n不难想到使用动态规划解决本题。\r\n令\\(N=11^{12},M=23,O=23.\\)假设状态\\(f(i,j,k)(1\\le i\\le N,0\\le j&lt; M,0\\le k\\le\r\nO)\\)表示目前所有\\(i\\)位带前导\\(0\\)的非负整数中，模\\(M\\)为\\(j\\)，数位和为\\(k\\)的所有数之和。那么不难写出如下状态转移方程：\r\n\\[\r\nf(i,j,k)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i=1,0\\le i=j\\le \\min(9,O) \\\\\r\n  &amp;0 &amp; &amp; \\text{else if}\\quad i=1 \\\\\r\n  &amp;\\sum_{d=0}^{\\min(9,k)}\\sum_{0\\le x&lt;M,(10x+d)\\%M=j}\r\nf(i-1,x,k-d) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n其中，最后一条式子的意思是考虑在状态\\(f(i-1,x,k-d)\\)中的每一个数后面添加一个数位\\(d\\)，添加之后那么其对\\(M\\)的取模值就变成了\\((10x+d)\\%M\\)，数位和也变成了\\(k\\)。\r\n若盲目按照这个方程进行转移，由于\\(N\\)非常大，时间复杂度明显是不可接受的。\r\n考虑使用矩阵快速幂进行改善。定义一个转移矩阵\\(A\\)，其中这个矩阵的边长为\\(M(O+1)\\)，每一个对应下标值\\(i\\)的行和列都被编码成一个状态，用两个数\\((a_i,b_i)(0\\le a_i&lt; M,0\\le b_i\\le\r\nO)\\)表示。其中\\(a_i\\)表示当前的数模\\(M\\)的值，\\(b_i\\)表示当前的数的数位之和。\r\n如果存在\\(0\\le d&lt;10\\)，使得\\((10a_i+d)\\%M=a_j\\land\r\nb_i+d=b_j\\)，那么\\(A_{ij}=1\\)，否则\\(A_{ij}=0\\)。定义好矩阵\\(A\\)后直接通过矩阵快速幂加速转移。此时的时间复杂度为\\(O(M^3\\cdot O^3\\cdot \\log\r\nN)\\).时间比起直接求\\(f\\)有进步，但依然非常慢。\r\n更进一步的改进：如果我们已经求出了\\(f(a,\\cdot,\\cdot)\\)和\\(f(b,\\cdot,\\cdot)\\)中的所有值，我们可以以\\(O(M^2\\cdot N^2)\\)求出\\(f(a+b,\\cdot,\\cdot)\\)的所有值。\r\n枚举所有\\(f(a,i,j)\\)和\\(f(b,x,y)\\)，那么就将这两部分值合并起来：\r\n\\(f(a,i,j)\\cdot f(b,x,y)\\rightarrow\r\nf(a+b,i\\cdot 10^{b}+b,j+y)\\)\r\n我们将\\(f(a,\\cdot,\\cdot)\\)中的所有数都乘上一个\\(10^b\\)，然后加上\\(b\\)位数的所有情况，两部分一一互相拼接，最终就形成了\\(f(a+b,\\cdot,\\cdot)\\)，在这个过程中，需要维护好拼接之后的数模\\(M\\)的值，以及它们的数位之和。\r\n因此，这给了我们一个方案：依次求出\\(f(2^0,\\cdot,\\cdot),f(2^1,\\cdot,\\cdot),f(2^2,\\cdot,\\cdot),\\dots\\)。然后针对\\(N\\)，选择这些求出的\\(f(2^i,\\cdot,\\cdot)\\)进行合并即可。这种做法的时间复杂度为\\(O(M^2\\cdot N^2\\cdot \\log\r\nn)\\)，降低了次数阶。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll N=pow(11,12);const int M=23;const int O=23;ll mod=1000000000;ll fp[104][M+1][O+1],f[M+1][O+1];void cal(ll dest[M+1][O+1],ll a[M+1][O+1],ll b[M+1][O+1],int pw)&#123;    ll c[M+1][O+1]=&#123;0&#125;;    for(int i=0;i&lt;M;i++)        for(int j=0;j&lt;M;j++)            for(int k=0;k&lt;=O;k++)                for(int l=0;k+l&lt;=O;l++)&#123;                    c[(pw*i+j)%M][k+l]+=a[i][k]*b[j][l];                    c[(pw*i+j)%M][k+l]%=mod;                &#125;    memcpy(dest,c,sizeof(c));&#125;int main()&#123;    for(int i=0;i&lt;=min(9,O);i++)        fp[0][i][i]=f[i][i]=1;    int pw=10;    for(ll n=N-1,i=0;n;n&gt;&gt;=1,i++)&#123;        if(n&amp;1) cal(f,f,fp[i],pw);        cal(fp[i+1],fp[i],fp[i],pw);        pw=pw*pw%M;    &#125;    ll ans=f[0][O];    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划","矩阵快速幂&#43;"]},{"title":"Project Euler 296","url":"/project-euler/296/","content":"\r\nProject Euler 296\r\n题目\r\nAngular Bisector and Tangent\r\nGiven is an integer sided triangle \\(ABC\\) with \\(BC\r\n\\le AC \\le AB\\).\r\n\\(k\\) is the angular bisector of\r\nangle \\(ACB\\). \\(m\\) is the tangent at \\(C\\) to the circumscribed circle of \\(ABC\\). \\(n\\) is a line parallel to \\(m\\) through \\(B\\).\r\nThe intersection of \\(n\\) and \\(k\\) is called \\(E\\).\r\n\r\nHow many triangles \\(ABC\\) with a\r\nperimeter not exceeding \\(100 000\\)\r\nexist such that \\(BE\\) has integral\r\nlength?\r\n解决方案\r\n令\\(D=k\\cap AB,|BC|=a,|AC|=b,|AB|=c,\\odot\r\nP\\)为\\(\\triangle\r\nABC\\)的外接圆。且\\(n\\cap\\odot\r\nP=\\{B,G\\}\\)。\r\n令\\(\\angle ACD=\\angle\r\nBCD=\\alpha,CB\\)和切线\\(m\\)的夹角为\\(\\beta\\)。\r\n\r\n那么因为\\(m\\parallel n\\)，所以\\(\\angle CBE=\\beta\\)。\r\n那么有\\(\\angle DEB=\\angle BCD+\\angle\r\nCBE=\\alpha+\\beta\\).\r\n可以知道，由于\\(m\\)是\\(\\odot P\\)的切线，因此\\(CP\\bot n\\)，从而有\\(\\widehat{CG}=\\widehat{CB}\\)，因此有\\(\\angle CAB=\\angle CBE=\\beta\\)。\r\n那么有\\(\\angle CDB=\\angle CAB+\\angle\r\nACD=\\beta+\\alpha=\\angle DEB\\)，因此\\(\\triangle DEB\\)是等腰三角形，所以有\\(|BE|=|BD|\\)。\r\n根据角平分线定理，可以得到\\(|BD|=\\dfrac{ac}{a+b}\\)。\r\n为了保证\\(\\dfrac{ac}{a+b}\\)这个值是整数，我们考虑枚举每对互质的\\(a,b\\)，然后计算\\(c\\)的数量。为了节省计算最大公因数的过程，我们考虑使用Stern-Brocot\r\nTree来枚举每一对互质的\\((a,b)\\)。由于\\(a,b\\)互质，因此\\(a,a+b\\)一定也互质。那么，枚举的\\(c\\)一定是\\(a+b\\)的倍数。我们枚举好每对互质的\\(a,b\\)后，再枚举\\(g\\)使得\\(a&#39;=ga,b&#39;=gb\\)，这时的三角形第三条边\\(c&#39;\\)必定满足如下条件：\r\n\\(\\begin{aligned}\r\n&amp;c&#39;\\le N-(a+b)g\\\\\r\n&amp;c&#39;&lt;(a+b)g\\\\\r\n&amp;c&#39;\\ge bg\\\\\r\n&amp;a+b\\mid c&#39;\r\n\\end{aligned}\\)\r\n由此可以计算出，满足上面\\((a,b,g)\\)条件的\\(c\\)一共有\\(\\left\\lfloor\\dfrac{\\min((a+b)g-1,N-(a+b)g)}{a+b}\\right\\rfloor-\\left\\lfloor\\dfrac{bg}{a+b}\\right\\rfloor\\)个。由此枚举相加即可。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=100000;ll ans=0;void dfs(int lu,int ld,int ru,int rd)&#123;    int a=lu+ru,b=ld+rd;    if(a+4*b&gt;N) return;    int d=a+b;    for(int g=1;;g++)&#123;        int c_min=g*b,c_max=min(d*g-1,N-d*g);        if(c_min&gt;c_max) break;        ans+=c_max/d-(c_min-1)/d;    &#125;    dfs(lu,ld,a,b);    dfs(a,b,ru,rd);&#125;int main()&#123;    for(int g=1;;g++)&#123;        int c_min=g,c_max=min(2*g-1,N-g*2);        if(c_min&gt;c_max) break;        ans+=c_max/2-(c_min-1)/2;    &#125;    dfs(0,1,1,1);    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 297","url":"/project-euler/297/","content":"\r\nProject Euler 297\r\n题目\r\nZeckendorf Representation\r\nEach new term in the Fibonacci sequence is generated by adding the\r\nprevious two terms.\r\nStarting with \\(1\\) and \\(2\\), the first \\(10\\) terms will be: \\(1, 2, 3, 5, 8, 13, 21, 34, 55, 89\\).\r\nEvery positive integer can be uniquely written as a sum of\r\nnonconsecutive terms of the Fibonacci sequence. For example, \\(100 = 3 + 8 + 89\\).\r\nSuch a sum is called the Zeckendorf representation\r\nof the number.\r\nFor any integer \\(n&gt;0\\), let\r\n\\(z(n)\\) be the number of terms in the\r\nZeckendorf representation of \\(n\\).\r\nThus, \\(z(5)=1, z(14)=2, z(100)=3\\)\r\netc.\r\nAlso, for \\(0&lt;n&lt;10^6, \\sum\r\nz(n)=7894453\\).\r\nFind \\(\\sum z(n)\\) for \\(0&lt;n&lt;10^{17}\\).\r\n齐肯多夫定理\r\n齐肯多夫定理，任何一个数\\(n\\)，都可以表示成多个不相邻斐波那契数之和，并且这种表示方法是唯一的。\r\n解决方案\r\n令\\(N=10^{17},f(n)=\\sum_{i=1}^z(i).\\)\r\n对于一个数\\(n\\)求它的齐肯多夫表示法，不难想到使用贪心的方法：从大到小枚举斐波那契数\\(m\\)，如果\\(m\\)不超过\\(n\\)，那么记录下\\(m\\)，并从\\(n\\)减去\\(m\\)，否则跳过，直到\\(n\\)变成\\(0\\).\r\n当我们计算\\(f(n)\\)时，记\\(g(n)\\)为不超过\\(n\\)的最大斐波那契数。在\\(1\\sim n\\)这一部分数中，不难发现，\\(1\\sim g(n)-1\\)这一部分永远不会用到\\(g(n)\\)来表示。而\\(g(n)\\sim n\\)中的所有数都会用到\\(g(n)\\)表示，而将这一部分数都用\\(g(n)\\)表示后，接下来就以同样的思想考虑\\(0\\sim n-g(n)\\)这一部分，也就是\\(f(n-g(n))\\)。\r\n那么，不难写出\\(f(n)\\)的递推式：\r\n\\[\r\nf(n)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0 &amp; &amp; \\text{if}\\quad n=0 \\\\\r\n  &amp;f(g(n)-1)+f(n-g(n))+n-g(n)+1 &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n使用记忆化的递归可以快速求出\\(f(N-1)\\).\r\n代码\r\nN = 10 ** 17N -= 1f = [1, 2]mp = &#123;0: 0&#125;while True:    f.append(f[-1] + f[-2])    if f[-1] &gt; N:        breakdef dfs(n: int):    if n in mp.keys():        return mp[n]    p = 0    while p + 1 &lt; len(f) and f[p + 1] &lt;= n:        p += 1    ans = dfs(f[p] - 1) + dfs(n - f[p]) + n - f[p] + 1    mp[n] = ans    return ansans = dfs(N)print(ans)\r\n","categories":["Project Euler"],"tags":["贪心","齐肯多夫定理"]},{"title":"Project Euler 3","url":"/project-euler/3/","content":"\r\nProject Euler 3\r\n题目\r\nLargest prime factor\r\nThe prime factors of \\(13195\\) are\r\n\\(5, 7, 13\\) and \\(29\\).\r\nWhat is the largest prime factor of the number \\(600851475143\\) ?\r\n解决方案\r\n直接使用sympy中的分解质因数方法即可，以后将封装到自定义的tools工具包中，方法名为factorization。\r\n代码\r\nfrom sympy import factorintN = 600851475143ans = max(factorint(N).keys())print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 30","url":"/project-euler/30/","content":"\r\nProject Euler 30\r\n题目\r\nDigit fifth powers\r\nSurprisingly there are only three numbers that can be written as the\r\nsum of fourth powers of their digits: \\[1634=1^4+6^4+3^4+4^4\\] \\[8208=8^4+2^4+0^4+8^4\\] \\[9474=9^4+4^4+7^4+4^4\\]\r\nAs \\(1 = 1^4\\) is not a sum it is\r\nnot included.\r\nThe sum of these numbers is \\(1634 + 8208 +\r\n9474 = 19316\\).\r\nFind the sum of all the numbers that can be written as the sum of\r\nfifth powers of their digits.\r\n解决方案\r\n一个\\(n\\)位数如果全是\\(9\\)，那么其和数位和的\\(k\\)次幂为\\(n\\cdot\r\n9^k\\)。因此一个\\(n\\)位数的值绝不会超过\\(n \\cdot 9^k\\)。\r\n因此，直接枚举\\(n\\)位数直接算即可（注意不要超出当前的上限）。\r\n如果\\(n\\)满足\\(10^n&gt;n\\cdot\r\n9^k\\)，那么停止循环退出。因为\\(9^k\\)是相加的，比不上指数增长。\r\n代码\r\nfrom itertools import countK = 5ans = 0for n in count(1, 1):    mx = min(10 ** (n + 1) - 1, n * 9 ** K)    st = 10 ** n    if st &gt; n * 9 ** K:        break    for i in range(st, mx + 1):        s, w = 0, i        while w:            s += (w % 10) ** K            w //= 10        if s == i:            ans += iprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 300","url":"/project-euler/300/","content":"\r\nProject Euler 300\r\n题目\r\nProtein folding\r\nIn a very simplified form, we can consider proteins as strings\r\nconsisting of hydrophobic (H) and polar (P) elements,\r\ne.g. HHPPHHHPHHPH.\r\nFor this problem, the orientation of a protein is important; e.g. HPP\r\nis considered distinct from PPH. Thus, there are \\(2^n\\) distinct proteins consisting of \\(n\\) elements.\r\nWhen one encounters these strings in nature, they are always folded\r\nin such a way that the number of H-H contact points is as large as\r\npossible, since this is energetically advantageous.\r\nAs a result, the H-elements tend to accumulate in the inner part,\r\nwith the P-elements on the outside.\r\nNatural proteins are folded in three dimensions of course, but we\r\nwill only consider protein folding in two dimensions.\r\nThe figure below shows two possible ways that our example protein\r\ncould be folded (H-H contact points are shown with red dots).\r\n\r\nThe folding on the left has only six H-H contact points, thus it\r\nwould never occur naturally.\r\nOn the other hand, the folding on the right has nine H-H contact\r\npoints, which is optimal for this string.\r\nAssuming that H and P elements are equally likely to occur in any\r\nposition along the string, the average number of H-H contact points in\r\nan optimal folding of a random protein string of length \\(8\\) turns out to be \\(\\dfrac{850}{2^8}=3.3203125\\).\r\nWhat is the average number of H-H contact points in an optimal\r\nfolding of a random protein string of length \\(15\\)?\r\nGive your answer using as many decimal places as necessary for an\r\nexact result.\r\n解决方案\r\n一个很明显的事实：如果蛋白质序列的第\\(i\\)个和第\\(j\\)个元素在平面上相邻，那么\\(i\\)和\\(j\\)的奇偶性不相同。因此，我们假设偶数序号\\(e\\)和奇数序号\\(o\\)接触时，用一个编码来表示。这种编码方式的编码量是盲目编码时的约\\(\\dfrac{1}{4}\\)。当\\(N=15\\)时，元素之间的接触情况可以用一个\\(64\\)位整数表示。\r\n我的做法相对比较朴素。首先通过深度优先搜索枚举出所有可能出现的折叠情况，接下来枚举所有不同蛋白质的序列，和每种折叠情况一一组合比较，取最优的作为结果。\r\n为了加速运行，我使用了以下策略：\r\n\r\n枚举折叠情况时，固定第\\(1\\)个蛋白质在第\\(0\\)个右面。因为蛋白质的折叠形状和本身的位置没有关系。\r\n去掉一些不可能最优的折叠情况。部分折叠情况的接触面集合是另外一个折叠情况的子集，这些折叠情况不可能对应到最优的折叠情况。\r\n使用蝴蝶变换求出每一个\\(N\\)比特数的逆序，并且某个顺序和其逆序的最大接触面数明显是一样的，只枚举其中一个。这可以减少一半的枚举量。\r\n\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=15;int b[N+N+4][N+N+4];int dx[4]=&#123;-1,1,0,0&#125;,dy[4]=&#123;0,0,-1,1&#125;;int g[N][N];set&lt;ll&gt;st;void dfs(int fl,int px,int py,ll s)&#123;    for(int i=0;i&lt;4;i++)&#123;        int nx=px+dx[i],ny=py+dy[i];        if(b[nx][ny] != -1)            s|=1ll &lt;&lt; g[fl-1][b[nx][ny]];    &#125;    if(fl==N)&#123;        st.insert(s);        return;    &#125;    for(int i=0;i&lt;4;i++)&#123;        int nx=px+dx[i],ny=py+dy[i];        if(b[nx][ny] == -1)&#123;            b[nx][ny]=fl;            dfs(fl+1,nx,ny,s);            b[nx][ny]=-1;        &#125;    &#125;&#125;//计算出对应的分子。int rev[1&lt;&lt;N],mx[1&lt;&lt;N];int solve()&#123;    memset(b, -1, sizeof(b));    if(N==1) return 1;    int m=0;    for(int i=0;i&lt;N;i+=2)        for(int j=1;j&lt;N;j+=2)&#123;            g[i][j]= g[j][i]=m++;        &#125;    b[N][N]=0;b[N][N+1]=1;    dfs(2, N,N+1, g[0][1]);    set&lt;ll&gt;t(st);st.clear();    //去掉子集    for(auto it=t.rbegin();it!=t.rend();it++)&#123;        bool ok=1;        for(ll x:st)            if((x|*it)==x)&#123;                ok=0;break;            &#125;        if(ok) st.insert(*it);    &#125;    int sum=0;    for(int s=0;s&lt;(1&lt;&lt;N);s++)&#123;        //蝴蝶变换        rev[s] = ((rev[s &gt;&gt; 1] &gt;&gt; 1)) | ((s &amp; 1) &lt;&lt; (N - 1));        if(rev[s]&lt;s) sum+=mx[rev[s]];        else&#123;            ll y=0;            for(int i=0;i&lt;N;i+=2)                for(int j=1;j&lt;N;j+=2)                    if((s&gt;&gt;i&amp;1)&amp;&amp;(s&gt;&gt;j&amp;1))                        y|=1ll&lt;&lt;g[i][j];            for(ll x:st)                mx[s]=max(mx[s],__builtin_popcountll(x&amp;y));            sum+=mx[s];        &#125;    &#125;    return sum;&#125;int main()&#123;    int num=solve(),den=1&lt;&lt;N;    int g=__gcd(num, den);    num/=g;den/=g;    int lg=log2(den + 1e-6);    double ans=1.0*num/den;    printf(&quot;%.*f\\n&quot;, lg, ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 301","url":"/project-euler/301/","content":"\r\nProject Euler 301\r\n题目\r\nNim\r\nNim is a game played with heaps of stones, where two players\r\ntake it in turn to remove any number of stones from any heap until no\r\nstones remain. We’ll consider the three-heap normal-play version of Nim,\r\nwhich works as follows:\r\n\r\nAt the start of the game there are three heaps of stones.\r\nOn his turn the player removes any positive number of stones from\r\nany single heap.\r\nThe first player unable to move (because no stones remain)\r\nloses.\r\n\r\nIf \\((n_1,n_2,n_3)\\) indicates a Nim\r\nposition consisting of heaps of size \\(n_1,\r\nn_2\\) and \\(n_3\\) then there is\r\na simple function \\(X(n_1,n_2,n_3)\\) —\r\nthat you may look up or attempt to deduce for yourself — that\r\nreturns:\r\n\r\nzero if, with perfect strategy, the player about to move will\r\neventually lose; or\r\nnon-zero if, with perfect strategy, the player about to move will\r\neventually win.\r\n\r\nFor example \\(X(1,2,3) = 0\\)\r\nbecause, no matter what the current player does, his opponent can\r\nrespond with a move that leaves two heaps of equal size, at which point\r\nevery move by the current player can be mirrored by his opponent until\r\nno stones remain; so the current player loses. To illustrate:\r\n\r\ncurrent player moves to \\((1,2,1)\\)\r\nopponent moves to \\((1,0,1)\\)\r\ncurrent player moves to \\((0,0,1)\\)\r\nopponent moves to \\((0,0,0)\\), and\r\nso wins.\r\n\r\nFor how many positive integers \\(n\\le2^{30}\\) does \\(X(n,2n,3n) = 0\\)?\r\n解决方案\r\n关于这个NIM博弈的页面，给出了一个更一般的方法用来判断当前游戏状态是必胜态还是必败态：\r\n假设一共有\\(n\\)堆石头，每一堆的个数为\\(a_i\\)。那么游戏是必败态时，当且仅当\r\n\\[\\bigoplus_{i=1}^n a_i=a_1\\oplus\r\na_2\\oplus a_3 \\oplus\\dots\\oplus a_n=0\\]\r\n其中\\(\\oplus\\)是异或运算。\r\n因此，问题转化成有多少个正整数\\(n\\le\r\n2^{N},N=30\\)，满足\\(n\\oplus 2n\\oplus\r\n3n=0\\).也就是\\(n\\oplus 2n=\r\n3n\\).\r\n异或运算也被视为是二进制下的不进位加法。因此，当\\(n\\)和\\(2n\\)没有重合的\\(1\\)比特，也就是\\(n\\&amp;2n=0\\)时，才会满足\\(n\\oplus2n=n+2n=3n\\)相等。否则，因为异或中进位被消除了，那么\\(n\\oplus 2n&lt;3n\\).\r\n当\\(n\\&amp;2n=0\\)时，\\(n\\)不允许有两个相邻的位为\\(1\\).将\\(n=2^N\\)对应到\\(n=0\\)时的情况。那么问题就变成了有多少个\\(N\\)比特数，其中不存在两个相邻的位同为\\(1\\)？假设这个值为\\(F(N)\\)，那么不难发现这通过动态规划的思想就可以做出来：\r\n\\(f(1)=2,f(2)=3,f(i)=f(i-2)+f(i-1)\\)\r\n此处不再详述这个动态规划的过程。另外这道题的答案其实是斐波那契数。\r\n代码\r\nN = 30f = [1, 2]for i in range(N):    f.append(f[-1] + f[-2])print(f[N])\r\n","categories":["Project Euler"],"tags":["动态规划","博弈论"]},{"title":"Project Euler 306","url":"/project-euler/306/","content":"\r\nProject Euler 306\r\n题目\r\nPaper-strip Game\r\nThe following game is a classic example of Combinatorial Game\r\nTheory:\r\nTwo players start with a strip of \\(n\\) white squares and they take alternate\r\nturns.\r\nOn each turn, a player picks two contiguous white squares and paints\r\nthem black.\r\nThe first player who cannot make a move loses.\r\n\r\n\\(n = 1\\): No valid moves, so the\r\nfirst player loses automatically.\r\n\\(n = 2\\): Only one valid move,\r\nafter which the second player loses.\r\n\\(n = 3\\): Two valid moves, but\r\nboth leave a situation where the second player loses.\r\n\\(n = 4\\): Three valid moves for\r\nthe first player, who is able to win the game by painting the two middle\r\nsquares.\r\n\\(n = 5\\): Four valid moves for the\r\nfirst player (shown below in red), but no matter what the player does,\r\nthe second player (blue) wins.\r\n\r\n\r\nSo, for \\(1 \\le n \\le 5\\), there are\r\n\\(3\\) values of \\(n\\) for which the first player can force a\r\nwin.\r\nSimilarly, for \\(1 \\le n \\le 50\\),\r\nthere are 40 values of \\(n\\) for which\r\nthe first player can force a win.\r\nFor \\(1 \\le n \\le 1 000 000\\), how\r\nmany values of \\(n\\) are there for\r\nwhich the first player can force a win?\r\nSprague–Grundy定理\r\n\\(sg\\)函数是一个用来解决公平组合游戏(ICG)问题的一种工具。\r\n定义一个非负整数集合上的运算\\(\\text{mex}(s)\\)：表示集合\\(s\\)中未出现的最小的非负整数。\r\n我们定义一个游戏状态\\(n\\)，令\\(sg(n)=\\text{mex}(\\{sg(m)|n\\rightarrow\r\nm\\})\\).\\(m\\)是从\\(n\\)能够抵达的所有游戏状态。如果\\(sg(n)&gt;0\\)，那么状态\\(n\\)为必胜态；如果\\(sg(n)=0\\)，那么为必败态。\r\nSprague–Grundy，SG定理说明了，如果这个游戏当前的状态\\(n\\)，它可以看做是多个状态\\((n_1,n_2,\\dots,n_k)\\)的组合，那么就可以写成：\r\n\\[sg(n)=sg(n_1)\\oplus sg(n_2)\\oplus \\dots\r\n\\oplus sg(n_k)\\]\r\n以NIM游戏为例，如果当前有\\(n\\)堆石头，其中第\\(i\\)堆为\\(a_i\\)。那么状态\\(sg(a_1,a_2,\\dots,a_n)\\)可以看成是\\(sg(a_1),sg(a_2),\\dots,sg(a_n)\\)的组合，当前的状态是必胜态还是必败态由\\(sg(a_1)\\oplus sg(a_2)\\oplus\\dots\\oplus\r\nsg(a_n)\\)决定。\r\n因此一般使用SG定理解决问题，主要依靠的是分治的思想。\r\n解决方案\r\n当双方每一次占用相邻的格子时，可以把它看成是将一个长度为\\(n\\)的纸条，将其中相邻的两格占用后，产生了两个长度分别为\\(i,n-2-i(0\\le i\\le n-2-i)\\)的纸条。\r\n因此我们可以将一个长度为\\(n\\)的纸条看做是一个状态，设其为\\(sg(n)(n\\ge 0)\\).那么\\(sg(n)\\)的值就可以通过以下值计算出：\r\n\\[\r\nsg(n)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0 &amp; &amp; \\text{if}\\quad n\\le 1 \\\\\r\n  &amp;\\text{mex}(\\{sg(i)\\oplus sg(n-2-i)|0\\le i\\le n-2-i\\}) &amp; &amp;\r\n\\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n使用如下代码打印出这个游戏的\\(sg\\)函数前一部分序列，在OEIS中查询到结果为A002187。\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;const int N=100;int sg[N+4];bool mex[N+4];int main()&#123;    for(int i=1;i&lt;=N;i++)&#123;        memset(mex,0,sizeof(mex));        int j=0;        for(j=0;j&lt;=i-j-2;j++)            mex[sg[j]^sg[i-j-2]]=1;        for(j=0;mex[j];++j);        sg[i]=j;    &#125;    for(int i=0;i&lt;=N;i++)        printf(&quot;%d &quot;,sg[i]);&#125;\r\n在FORMULA一栏中查找到这个信息：\r\nHas period 34 with the only exceptions at n=0, 14, 16, 17, 31, 34 and 51.\r\n这说明这个\\(sg\\)函数是一个以\\(34\\)为周期的序列，除了\\(0,14,16,17,31,34,51\\)这几个状态。\r\n因此，计算时只需要单独考虑\\(1\\sim\r\n51\\)这几个项即可。\r\n代码\r\nN = 10 ** 6a = [0, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 0, 5, 2, 2, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 2, 7, 4, 0, 1, 1, 2,     0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 2]t = [3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9]ans = sum(a[i] &gt; 0 for i in range(min(N, len(a))))if N &gt; len(a):    N -= len(a)    block, res = divmod(N, len(t))    ans += block * (len(t) - t.count(0)) + res - t[:res].count(0)print(ans)\r\n","categories":["Project Euler"],"tags":["博弈论","SG定理"]},{"title":"Project Euler 304","url":"/project-euler/304/","content":"\r\nProject Euler 304\r\n题目\r\nPrimonacci\r\nFor any positive integer \\(n\\) the\r\nfunction \\(\\text{next-prime}(n)\\)\r\nreturns the smallest prime \\(p\\) such\r\nthat \\(p&gt;n\\).\r\nThe sequence \\(a(n)\\) is defined\r\nby:\\(a(1)=\\text{next-prime}(10^{14})\\)\r\nand \\(a(n)=\\text{next-prime}(a(n-1))\\)\r\nfor \\(n&gt;1\\).\r\nThe fibonacci sequence \\(f(n)\\) is\r\ndefined by: \\(f(0)=0, f(1)=1\\) and\r\n\\(f(n)=f(n-1)+f(n-2)\\) for \\(n&gt;1\\).\r\nThe sequence \\(b(n)\\) is defined as\r\n\\(f(a(n))\\).\r\nFind \\(\\sum b(n)\\) for \\(1\\le n\\le100 000\\). Give your answer \\(\\bmod\\ 1234567891011\\).\r\n解决方案\r\n将斐波那契数的通项公式写成矩阵形式：\r\n\\[\r\n\\begin{bmatrix}\r\n0 &amp; 1\\\\\r\n1 &amp; 1\r\n\\end{bmatrix}\r\n\\begin{bmatrix}\r\nf(i-2)\\\\\r\nf(i-1)\r\n\\end{bmatrix}\r\n=\r\n\\begin{bmatrix}\r\nf(i-1)\\\\\r\nf(i)\r\n\\end{bmatrix}\r\n\\]\r\n令\\(B=\\begin{bmatrix}\r\n0 &amp; 1\\\\\r\n1 &amp; 1\r\n\\end{bmatrix}\\)，那么通过矩阵快速幂，可以\\(O(\\log n)\\)的时间复杂度内求解出第\\(n\\)项的值。\r\n另外，上面的等式可以写成\r\n\\[\r\nB^d\r\n\\begin{bmatrix}\r\nf(i-d-1)\\\\\r\nf(i-d)\r\n\\end{bmatrix}\r\n=\r\n\\begin{bmatrix}\r\nf(i-1)\\\\\r\nf(i)\r\n\\end{bmatrix}\r\n\\]\r\n这\\(10^5\\)次的询问是独立的，并且之间的间隔\\(d\\)也比较小。我们可以基于上式来减少矩阵乘法的运算次数，用上一次的结果继续转移，计算出当前结果。\r\n求一个数的下一个质数，使用sympy的nextprime方法。\r\n代码\r\nfrom sympy import nextprimeM = 10 ** 14Q = 10 ** 5mod = 1234567891011def mul(a: list, b: list):    return [[sum(a[i][k] * b[k][j] for k in range(len(b))) % mod for j in range(len(b[0]))] for i in range(len(a))]b_pre = [[[0, 1], [1, 1]]]for i in range(len(bin(M+Q))+2):    b_pre.append(mul(b_pre[-1], b_pre[-1]))def cal(a, n):    i = 0    while n:        if n &amp; 1:            a = mul(a, b_pre[i])        i += 1        n &gt;&gt;= 1    return aa = [[0, 1]]ans = 0pre = 0for n in range(Q):    M = nextprime(M)    val = M - pre    a = cal(a, val)    ans = (ans + a[0][0]) % mod    pre = Mprint(ans)\r\n","categories":["Project Euler"],"tags":["矩阵快速幂"]},{"title":"Project Euler 303","url":"/project-euler/303/","content":"\r\nProject Euler 303\r\n题目\r\nMultiples with small digits\r\nFor a positive integer \\(n\\), define\r\n\\(f(n)\\) as the least positive multiple\r\nof \\(n\\) that, written in base \\(10\\), uses only digits \\(\\le 2\\).\r\nThus \\(f(2)=2, f(3)=12, f(7)=21, f(42)=210,\r\nf(89)=1121222\\).\r\nAlso, \\(\\sum^{100}_{n=1}\\dfrac{f(n)}{n}=11363107\\).\r\nFind \\(\\sum^{10000}_{n=1}\\dfrac{f(n)}{n}\\).\r\n解决方案\r\n对于每个询问的\\(1\\le n\\le\r\nN\\)，其中\\(N=10000\\)。考虑从小到大枚举所有数。广度优先搜索可以帮助我们高效枚举，并且能够进行适当的剪枝。\r\n根据广度优先搜素的性质，搜索的数恰好是从小到大的。当前搜索到一个数\\(m\\)，那么就可以考虑往它的后面分别添加三个数\\(0,1,2\\)，从而扩展出新的\\(3\\)个数\\(10m,10m+1,10m+2\\)。\r\n找到一个最小的满足条件的数位\\(n\\)的倍数，本质上是找到一个最小的满足条件的数，其模\\(n\\)为\\(0\\)，因此从模的角度思考。广度优先搜索剪枝的地方在于，如果\\((10m+i)\\%n\\)已经出现过，那么就不需要再将\\(10m+i\\)这个数放进队列中。因为由它继续扩展出来的数，模\\(n\\)的结果也将和往常一样。\r\n最终找到一个模\\(n\\)为\\(0\\)的数即为答案，单次询问的时间复杂度为\\(O(n)\\).\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;const int N=10000;bool vis[N+4];ull solve(int n)&#123;    if(n&lt;=2) return 1;    memset(vis,0,sizeof(vis));    queue&lt;ull&gt;q;    q.push(1);q.push(2);    vis[1]=vis[2]=1;    while (1) &#123;        ull x=q.front();q.pop();        if (x%n==0) return x/n;        for (unsigned i=0;i&lt;=2;i++) &#123;            ull y=x*10+i;            if (!vis[y%n]) &#123;                vis[y%n] = 1;                q.push(y);            &#125;        &#125;    &#125;&#125;int main()&#123;    ull ans=0;    for(int i=1;i&lt;=N;i++)        ans+=solve(i);    printf(&quot;%llu\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 307","url":"/project-euler/307/","content":"\r\nProject Euler 307\r\n题目\r\nChip Defects\r\n\\(k\\) defects are randomly\r\ndistributed amongst \\(n\\)\r\nintegrated-circuit chips produced by a factory (any number of defects\r\nmay be found on a chip and each defect is independent of the other\r\ndefects).\r\nLet \\(p(k,n)\\) represent the\r\nprobability that there is a chip with at least \\(3\\) defects.\r\nFor instance \\(p(3,7) \\approx\r\n0.0204081633\\).\r\nFind \\(p(20 000, 1 000 000)\\) and\r\ngive your answer rounded to \\(10\\)\r\ndecimal places in the form 0.abcdefghij.\r\n解决方案\r\n不难想到先考虑事件：全部零件最多只有\\(2\\)个缺陷。计算出这个事件的概率后，那么这个事件的补就是题目所求的至少一个零件有\\(3\\)个缺陷。\r\n令\\(K=20000,N=100000\\)。\r\n枚举\\(i\\)，有\\(i\\)个零件具有两个瑕疵，那么\\(K-2i\\)个零件具有一个瑕疵，\\(N-K+i\\)个零件是没有瑕疵的。那么不难算出，这种方式一共有\\(\\dbinom{N}{i}\\cdot\r\n\\dbinom{N-i}{K-2i}=\\dfrac{N!}{i!(K-2i)!(N-K+i)!}\\)种取法。\r\n对于瑕疵而言，相当于将\\(K\\)个瑕疵放进\\(i\\)个容量为\\(2\\)的不同篮子，将\\(K-2i\\)个瑕疵放进\\(K-2i\\)个容量为\\(1\\)的不同篮子的情况数。假设容量为\\(2\\)的篮子都放在容量为\\(1\\)的篮子后面，那么根据全排列数公式，可以写出\\(\\dfrac{K!}{(2!)^i\\cdot(1!)^{K-2i}}\\)\r\n最终可以得到：\r\n\\[p(K,N)=1-\\sum_{i=0,K-2i\\le\r\nN-i}^{\\min(\\frac{K}{2},N)}\\dfrac{1}{N^K}\\cdot\r\n\\dfrac{N!}{i!(K-2i)!(N-K+i)!}\\cdot \\dfrac{K!}{2^i} \\]\r\n注意到无论分子还是分母，数都比较大。因此考虑将它们转化成对数进行计算，在对数上计算完成后再通过幂运算转换成真正的结果。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;typedef long double ld;using namespace std;const int K=20000,N=1000000;ld fac[N+K+2];int main()&#123;    for(int i=1;i&lt;=N+K;i++)        fac[i]=fac[i-1]+log(i);    ld ans=0;    for(int i=0;i&lt;=K/2&amp;&amp;i&lt;=N;i++)&#123;        if(K-2*i&gt;N-i) continue;        ld val=fac[N]+fac[K]-fac[i]-fac[K-2*i]-fac[N-K+i]-log(N)*K-log(2)*i;        ans+=exp(val);    &#125;    ans=(ld)1-ans;    printf(&quot;%.10Lf\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["概率"]},{"title":"Project Euler 309","url":"/project-euler/309/","content":"\r\nProject Euler 309\r\n题目\r\nInteger Ladders\r\nIn the classic “Crossing Ladders” problem, we are given the lengths\r\n\\(x\\) and \\(y\\) of two ladders resting on the opposite\r\nwalls of a narrow, level street. We are also given the height \\(h\\) above the street where the two ladders\r\ncross and we are asked to find the width of the street \\((w)\\).\r\n\r\nHere, we are only concerned with instances where all four variables\r\nare positive integers.\r\nFor example, if \\(x = 70, y = 119\\)\r\nand \\(h = 30\\), we can calculate that\r\n\\(w = 56\\). In fact, for integer values\r\n\\(x, y, h\\) and \\(0 &lt; x &lt; y &lt; 200\\), there are only\r\nfive triplets \\((x,y,h)\\) producing\r\ninteger solutions for \\(w\\):\r\n\\((70, 119, 30), (74, 182, 21), (87, 105,\r\n35), (100, 116, 35)\\) and \\((119, 175,\r\n40)\\).\r\nFor integer values \\(x, y, h\\) and\r\n\\(0 &lt; x &lt; y &lt; 1 000 000\\), how\r\nmany triplets \\((x,y,h)\\) produce\r\ninteger solutions for \\(w\\)?\r\n解决方案\r\n令\\(N=10^6\\)。\r\n给上图添加一些变量，如下图所示\r\n\r\n根据两对直角三角形的相似性，得到\r\n\\[\\dfrac{h}{w_1}=\\dfrac{b}{w},\\dfrac{h}{w_2}=\\dfrac{a}{w}\\]\r\n通过\\(w_1+w_2=w\\)消去\\(w_1,w_2\\)，得到\r\n\\[\\dfrac{1}{a}+\\dfrac{1}{b}=\\dfrac{1}{h}\\]\r\n由上面的式子可以得到\\(h=\\dfrac{ab}{a+b}.\\)\r\n结合勾股定理\\(x^2=b^2+w^2,y^2=a^2+w^2\\)，有\\(b=\\sqrt{x^2-w^2},a=\\sqrt{y^2-w^2}\\)。\r\n那么，我们可以按照如下算法来寻找这些解：枚举所有勾股三元组\\(t,u,v\\)满足\\(v&lt;10^6\\)，并且数组\\(g[s]\\)存储这些满足\\(t=s\\lor\r\nu=s\\)的另一条直角边。然后枚举数组\\(g[w]\\)中的任意两条不同直角边\\((a,b)\\)，判断\\(a+b\\)是否整除\\(ab\\)即可。\r\n由于直角三角形非常分散，因此\\(g[w]\\)数组的长度非常短。由此暴力枚举，得出结果的时间非常快。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=1000000;vector&lt;int&gt;g[N+4];int main()&#123;    for(int s=3;s*s/2&lt;=N;s+=2)&#123;        for(int t=1;t&lt;s&amp;&amp;(s*s+t*t)/2&lt;=N;t+=2)&#123;            if(__gcd(s,t)==1)&#123;                int x=s*t,y=(s*s-t*t)&gt;&gt;1,z=(s*s+t*t)&gt;&gt;1;                for(int k=1;k*z&lt;N;k++)&#123;                    g[k*x].push_back(k*y);                    g[k*y].push_back(k*x);                &#125;            &#125;        &#125;    &#125;    int ans=0;    for(int i=1;i&lt;N;i++)&#123;        for(int j=0;j&lt;g[i].size();j++)&#123;            for(int k=0;k&lt;j;k++)&#123;                int a=g[i][j],b=g[i][k];                if(1ll*a*b%(a+b)==0) ++ans;            &#125;        &#125;    &#125;    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 31","url":"/project-euler/31/","content":"\r\nProject Euler 31\r\n题目\r\nCoin sums\r\nIn the United Kingdom the currency is made up of pound \\((£)\\) and pence \\((p)\\). There are eight coins in general\r\ncirculation:\r\n\\[1p, 2p, 5p, 10p, 20p, 50p, £1 (100p),\r\n\\text{and } £2 (200p).\\]\r\nIt is possible to make \\(£2\\) in the\r\nfollowing way:\r\n\\[1×£1 + 1×50p + 2×20p + 1×5p + 1×2p +\r\n3×1p\\]\r\nHow many different ways can \\(£2\\)\r\nbe made using any number of coins?\r\n解决方案\r\n一个标准的完全背包问题（只不过并非是真正意义上的动态规划，这里是一个单纯的递推题目）。\r\n记录状态\\(f(i,j)(1\\leq i\\leq n,0\\leq j\\leq\r\nm)\\)为：当前使用了前\\(i\\)种货币获得了\\(j\\)便士的方案数。\r\n在这里，\\(n=8,m=200,a=[1,2,5,10,20,50,100,200]\\).\r\n那么，可以得到递推方程：\r\n\\[\r\nf(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad j=0 \\\\\r\n  &amp;0 &amp; &amp; \\text{else if}\\quad i=1 \\land j&lt;a[i] \\\\\r\n  &amp;f(i,j-a[i]) &amp; &amp; \\text{else if}\\quad i=1&amp; \\\\\r\n  &amp;f(i-1,j) &amp; &amp; \\text{else if}\\quad j &lt; a[i] \\\\\r\n  &amp;f(i-1,j) + f(i,j-a[i]) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n两种递推分别对应取真正取第\\(i\\)种货币和不取第\\(i\\)种货币。\r\n代码\r\nN = 200ls = [1, 2, 5, 10, 20, 50, 100, 200]f = [0 for x in range(N + 1)]f[0] = 1for x in ls:    for i in range(x, N + 1):        f[i] += f[i - x]ans = f[N]print(ans)\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 315","url":"/project-euler/315/","content":"\r\nProject Euler 315\r\n题目\r\nDigital root clocks\r\n\r\nSam and Max are asked to transform two digital clocks into two\r\n“digital root” clocks.\r\nA digital root clock is a digital clock that calculates digital roots\r\nstep by step.\r\nWhen a clock is fed a number, it will show it and then it will start\r\nthe calculation, showing all the intermediate values until it gets to\r\nthe result.\r\nFor example, if the clock is fed the number \\(137\\), it will show: “137“\r\n→ “11“ → “2“ and then it will go\r\nblack, waiting for the next number.\r\nEvery digital number consists of some light segments: three\r\nhorizontal (top, middle, bottom) and four vertical (top-left, top-right,\r\nbottom-left, bottom-right).\r\nNumber “1“ is made of vertical top-right and\r\nbottom-right, number “4“ is made by middle horizontal\r\nand vertical top-left, top-right and bottom-right. Number\r\n“8“ lights them all.\r\nThe clocks consume energy only when segments are turned on/off.\r\nTo turn on a “2“ will cost 5 transitions, while a\r\n“7“ will cost only 4 transitions.\r\nSam and Max built two different clocks.\r\nSam’s clock is fed e.g. number 137: the clock shows\r\n“137“, then the panel is turned off, then the next\r\nnumber (“11“) is turned on, then the panel is turned\r\noff again and finally the last number (“2“) is turned\r\non and, after some time, off.\r\nFor the example, with number \\(137\\), Sam’s clock requires:\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n“137“:\r\n\\((2 + 5 + 4)  \\times 2 = 22\\)\r\ntransitions (“137“ on/off).\r\n\r\n\r\n“11“:\r\n\\((2 + 2)  \\times 2 = 8\\)\r\ntransitions (“11“ on/off).\r\n\r\n\r\n“2“:\r\n\\((5)  \\times 2 = 10\\) transitions\r\n(“2“ on/off).\r\n\r\n\r\n\r\nFor a grand total of 40 transitions. Max’s clock works differently.\r\nInstead of turning off the whole panel, it is smart enough to turn off\r\nonly those segments that won’t be needed for the next number.For\r\nnumber 137, Max’s clock requires:\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n“137“:\r\n\\(2 + 5 + 4 = 11\\) transitions\r\n(“137“ on)\\(7\\)\r\ntransitions (to turn off the segments that are not needed for number\r\n“11“).\r\n\r\n\r\n“11“:\r\n\\(0\\) transitions (number\r\n“11“ is already turned on correctly)\\(3\\) transitions (to turn off the first\r\n“1“ and the bottom part of the second\r\n“1“;the top part is common with number\r\n“2“).\r\n\r\n\r\n“2“:\r\n\\(4\\) transitions (to turn on the\r\nremaining segments in order to get a “2“)\\(5\\) transitions (to turn off number\r\n“2“).\r\n\r\n\r\n\r\nFor a grand total of \\(30\\)\r\ntransitions.\r\nOf course, Max’s clock consumes less power than Sam’s one.\r\nThe two clocks are fed all the prime numbers between \\(A = 10^7\\) and \\(B = 2\\times10^7\\).\r\nFind the difference between the total number of transitions needed by\r\nSam’s clock and that needed by Max’s one.\r\n解决方案\r\n对于一个数位上的数码管，有\\(2^7\\)种不同的使用情况。每一种使用情况用一个\\(7\\)位二进制数表示。如图下图是一种比较随机的编码。如果第\\(i\\)个管是亮的，那么这个二进制数的第\\(i\\)位为\\(1\\)，否则为\\(0\\)。\r\n\r\n不过实际上，我们只使用了其中的\\(10\\)种情况，用来表示\\(0\\sim9\\)。我们用\\(b[i]\\)表示这个数位的显示情况。\r\n如果一个数\\(x\\)要变成\\(y\\)，那么能够节省能量的地方满足：变化前和变化后对应的两个数位\\((x_i,y_i)\\)，有\\(b[x_i]\\&amp;b[y_i]&gt;0\\)。此时\\(b[x_i]\\&amp;b[y_i]\\)的比特数就是节省的能量数。\r\n需要注意的是，最终答案需要乘\\(2\\)，因为它减少了从亮到灭和从灭到亮的两个过程。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=2e7,M=1e7;const int O=10,P=7;int v[N+4],pr[N/10+100],m=0;int b[O]=&#123;119, 36, 93, 109, 46, 107, 123, 39, 127, 111&#125;;int g[O][O],c[1&lt;&lt;P];int cal_sum(int n)&#123;    int s=0;    for(;n;n/=10) s+=n%10;    return s;&#125;int cal_bits(int n,int m)&#123;    int s=0;    for(;n&amp;&amp;m;n/=10,m/=10)        s+=g[n%10][m%10];    return s;&#125;int cal(int n)&#123;    int s=0;    for(;n&gt;=10;)&#123;        int m=cal_sum(n);        s+=cal_bits(n,m);        n=m;    &#125;    return s*2;&#125;int main()&#123;    for(int i=1;i&lt;(1&lt;&lt;P);i++)        c[i]=__builtin_popcount(i);    for(int i=2;i&lt;=N;i++)&#123;        if(v[i]==0) v[i]=i,pr[++m]=i;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;N/i) break;            v[i*pr[j]]=pr[j];        &#125;    &#125;    for(int i=0;i&lt;O;i++)        for(int j=0;j&lt;O;j++)            g[i][j]=c[b[i]&amp;b[j]];    int ans=0;    for(int i=1;i&lt;=m;i++)        if(pr[i]&gt;M) ans+=cal(pr[i]);    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 310","url":"/project-euler/310/","content":"\r\nProject Euler 310\r\n题目\r\nNim Square\r\nAlice and Bob play the game Nim Square.\r\nNim Square is just like ordinary three-heap normal play Nim, but the\r\nplayers may only remove a square number of stones from a heap.\r\nThe number of stones in the three heaps is represented by the ordered\r\ntriple \\((a,b,c)\\).\r\nIf \\(0\\le a\\le b\\le c\\le29\\) then\r\nthe number of losing positions for the next player is \\(1160\\).\r\nFind the number of losing positions for the next player if \\(0\\le a\\le b\\le c\\le100 000\\).\r\nSprague–Grundy定理\r\n\\(sg\\)函数是一个用来解决公平组合游戏(ICG)问题的一种工具。\r\n定义一个非负整数集合上的运算\\(\\text{mex}(s)\\)：表示集合\\(s\\)中未出现的最小的非负整数。\r\n我们定义一个游戏状态\\(n\\)，令\\(sg(n)=\\text{mex}(\\{sg(m)|n\\rightarrow\r\nm\\})\\).\\(m\\)是从\\(n\\)能够抵达的所有游戏状态。如果\\(sg(n)&gt;0\\)，那么状态\\(n\\)为必胜态；如果\\(sg(n)=0\\)，那么为必败态。\r\nSprague–Grundy，SG定理说明了，如果这个游戏当前的状态\\(n\\)，它可以看做是多个状态\\((n_1,n_2,\\dots,n_k)\\)的组合，那么就可以写成：\r\n\\[sg(n)=sg(n_1)\\oplus sg(n_2)\\oplus \\dots\r\n\\oplus sg(n_k)\\]\r\n以NIM游戏为例，如果当前有\\(n\\)堆石头，其中第\\(i\\)堆为\\(a_i\\)。那么状态\\(sg(a_1,a_2,\\dots,a_n)\\)可以看成是\\(sg(a_1),sg(a_2),\\dots,sg(a_n)\\)的组合，当前的状态是必胜态还是必败态由\\(sg(a_1)\\oplus sg(a_2)\\oplus\\dots\\oplus\r\nsg(a_n)\\)决定。\r\n因此一般使用SG定理解决问题，主要依靠的是分治的思想。\r\n解决方案\r\n在每一次操作中，一方可以拿起三堆石头\\((a,b,c)\\)的其中一堆的石头的平方数个。并且这\\(3\\)堆石头是相互独立的。因此，三堆石头的\\(sg\\)函数\\(sg(a,b,c)=sg(a)\\oplus sg(b)\\oplus\r\nsg(c)\\).那么此时只需要单独考虑一堆石头的情况\\(sg(n)\\)。\r\n只拿一堆石头时，那么剩下的石头只可能为\\(n-1^2,n-2^2,n-3^2,\\dots\\)。那么不难写出\\(sg(n)\\)为：\r\n\\[\r\nsg(n)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0 &amp; &amp; \\text{if}\\quad n=0 \\\\\r\n  &amp;\\text{mex}(\\{sg(n-i^2)|1\\le i^2\\le n\\}) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n由此可以快速地求出每个独立状态的\\(sg\\)值。\r\n令\\(N=10^5\\)，那么问题就转化成有多少个三元组\\((a,b,c),0\\le a\\le b\\le c\\le N\\)，满足\\(sg(a)\\oplus sg(b)\\oplus sg(c)=0\\)。\r\n可以想到先统计在\\(0\\sim\r\nN\\)中有多少个值\\(n\\)，其中有\\(c(i)\\)个\\(n\\)满足\\(sg(n)=i\\)。令\\(O=\\max_{i=0}^N \\{sg(i)\\}\\)。并且其实\\(O\\)值很小。那么可以考虑通过枚举\\(i,j\\)使得\\(0\\le\r\ni\\le j\\le i\\oplus j \\le\r\nO\\)，进行组合计数即可。计数的过程中要注意当\\(i=j\\)时，\\(c[i]\\)和\\(c[j]\\)使用的是同一个部分下的所有数。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=100000;const int M=log(N+10)*10+10;int sg[N+4];bool mex[M+4];int cnt[M+4];int main()&#123;    for(int i=1;i&lt;=N;i++)&#123;        memset(mex,0,sizeof(mex));        for(int j=1;j*j&lt;=i;j++)            mex[sg[i-j*j]]=1;        int j=0;        for(;mex[j];++j);        sg[i]=j;        ++cnt[sg[i]];    &#125;    ++cnt[0];    int mx=*max_element(sg+1,sg+N+1);    ll ans=0;    for(int i=0;i&lt;=mx;i++)        for(int j=i+1;j&lt;=mx;j++)&#123;            int k=i^j;            if(mx&gt;=k&amp;&amp;k&gt;j)                ans+=1ll*cnt[i]*cnt[j]*cnt[k];        &#125;    for(int i=1;i&lt;=mx;i++)        ans+=1ll*cnt[i]*(cnt[i]+1)/2*cnt[0];    ans+=1ll*cnt[0]*(cnt[0]+1)*(cnt[0]+2)/6;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["博弈论","SG定理"]},{"title":"Project Euler 313","url":"/project-euler/313/","content":"\r\nProject Euler 313\r\n题目\r\nSliding game\r\nIn a sliding game a counter may slide horizontally or vertically into\r\nan empty space. The objective of the game is to move the red counter\r\nfrom the top left corner of a grid to the bottom right corner; the space\r\nalways starts in the bottom right corner. For example, the following\r\nsequence of pictures show how the game can be completed in five moves on\r\na \\(2\\) by \\(2\\) grid.\r\n\r\nLet \\(S(m,n)\\) represent the minimum\r\nnumber of moves to complete the game on an \\(m\\) by \\(n\\) grid. For example, it can be verified\r\nthat \\(S(5,4) = 25\\).\r\n\r\nThere are exactly \\(5482\\) grids for\r\nwhich \\(S(m,n) = p^2\\), where \\(p &lt; 100\\) is prime.\r\nHow many grids does \\(S(m,n) =\r\np^2\\), where \\(p &lt; 10^6\\) is\r\nprime?\r\n解决方案\r\n以一个比较低效的广度优先搜索打印出一部分\\(S(n,m)(n,m\\ge2)\\)的值：\r\nN = 15def solve(n, m):    from queue import Queue    dx, dy = [-1, 1, 0, 0], [0, 0, -1, 1]    st = 1, 1, n, m    mp = &#123;st: 0&#125;    q = Queue()    q.put(st)    while q.qsize() &gt; 0:        rx, ry, ex, ey = q.get()        if rx == n and ry == m:            return mp[rx, ry, ex, ey]        for i in range(4):            fx, fy = ex + dx[i], ey + dy[i]            if rx == fx and ry == fy:                sx, sy = ex, ey            else:                sx, sy = rx, ry            if 1 &lt;= fx &lt;= n and 1 &lt;= fy &lt;= m and (sx, sy, fx, fy) not in mp.keys():                mp[sx, sy, fx, fy] = mp[rx, ry, ex, ey] + 1                q.put((sx, sy, fx, fy))for n in range(2, N):    for m in range(2, N):        print(solve(n, m), end=&#x27; &#x27;)    print()\r\n可以发现以下规律：\r\n\\[\r\ns(m,n)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;6m+2n-13  &amp; &amp; \\text{if}\\quad m&gt;n \\\\\r\n  &amp;8m-11 &amp; &amp; \\text{else if}\\quad m=n \\\\\r\n  &amp;s(n,m) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n不难证明，不存在一个平方数，其模\\(8\\)的值为\\(5\\)，因此不考虑\\(s(m,m)\\)的情况。\r\n对于每一个质数\\(p\\)，现在的问题就是求有多少\\(m\\)满足以下条件：\r\n\r\n\\(n=\\dfrac{p^2+13-6m}{2}\\)\r\n\\(1&lt;n\\)\r\n\\(n&lt;m\\)\r\n\r\n联立第一个和第二个，得到\\(m&lt;\\dfrac{p^2+11}{6}\\)。联立第一个和第三个，得到\\(m&gt;\\dfrac{p^2+13}{8}\\)。最终就是求区间\\(\\left(\\dfrac{p^2+13}{8},\\dfrac{p^2+11}{6}\\right)\\)的整数个数。\r\n枚举所有质数\\(p\\)将这些区间中的整数个数相加即可。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=1000000;vector&lt;int&gt;pr;bool b[N+4];int main()&#123;    for(int i=2;i&lt;N;i++)&#123;        if(b[i]) continue;        pr.push_back(i);        for(ll j=1ll*i*i;j&lt;N;j+=i)            b[j]=1;    &#125;    ll ans=0;    for(int p:pr)        ans+=(1ll*p*p+11+5)/6-1-(1ll*p*p+13)/8;    ans&lt;&lt;=1;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 317","url":"/project-euler/317/","content":"\r\nProject Euler 317\r\n题目\r\nFirecracker\r\nA firecracker explodes at a height of \\(100\r\n\\text{m}\\) above level ground. It breaks into a large number of\r\nvery small fragments, which move in every direction; all of them have\r\nthe same initial velocity of \\(20\r\n\\text{m/s}\\).\r\nWe assume that the fragments move without air resistance, in a\r\nuniform gravitational field with \\(g=9.81\r\n\\text{m/s}^2\\).\r\nFind the volume (in \\(\\text{m}^3\\))\r\nof the region through which the fragments move before reaching the\r\nground.\r\nGive your answer rounded to four decimal places.\r\n解决方案\r\n可以发现，所要求解的物体是一个绕\\(y\\)轴旋转体。\r\n假设抛出的物体的方向和\\(x\\)轴正方向的夹角为\\(\\theta\\)，并且当前时间为\\(t\\)。那么可以列出如下\\((x,y)\\)关于\\((\\theta,t)\\)的参数方程：\r\n\\[\\left \\{\\begin{aligned}\r\n  &amp; x=vt\\cos\\theta\\\\\r\n  &amp; y=h+vt\\sin\\theta-\\dfrac{1}{2}gt^2\r\n\\end{aligned}\\right.\\]\r\n将\\(y\\)固定，在此约束下\\(t\\)和\\(\\theta\\)要取适当的值使得\\(x\\)取到最大值，这个过程用拉格朗日乘数法解决。\r\n因此，可以写出\r\n\\[\\mathcal{L}(\\lambda,\\theta,t)=vt\\cos\\theta-\\lambda(h+vt\\sin\\theta-\\dfrac{1}{2}gt^2-y)=0\\]\r\n计算得到：\r\n\\[\\dfrac{\\partial \\mathcal{L}}{\\partial\r\nt}=v\\cos\\theta-\\lambda v\\sin\\theta+\\lambda gt\\]\r\n\\[\\dfrac{\\partial \\mathcal{L}}{\\partial\r\n\\theta}=-vt\\sin\\theta-\\lambda vt\\cos\\theta\\]\r\n令\\(\\dfrac{\\partial \\mathcal{L}}{\\partial\r\nt}=0,\\dfrac{\\partial \\mathcal{L}}{\\partial\r\n\\theta}=0\\)，那么得到式子\\(v=gt\\sin\\theta\\)。然后联立\\(x=vt\\cos\\theta,y=h+vt\\sin\\theta-\\dfrac{1}{2}gt^2\\)，那么得到最终的曲线的方程：\r\n\\[x^2=\\dfrac{v^2}{g}(2h+\\dfrac{v^2}{g}-2y)\\]\r\n当物体从竖直向上抛出时，能够达到的高度最高，为\\(H=h+\\dfrac{v^2}{2g}\\)。\r\n因此，答案为\r\n\\[\\begin{aligned}\r\nI&amp;=\\int_{0}^H \\pi x^2dy=\\dfrac{\\pi\r\nv^2}{g}\\int_{0}^H2h+\\dfrac{v^2}{g}-2ydy=\\dfrac{2\\pi\r\nv^2}{g}\\int_{0}^HH-ydy \\\\\r\n&amp;=\\dfrac{\\pi v^2}{g}\\cdot H^2=\\dfrac{\\pi\r\nv^2}{g}\\cdot(h+\\dfrac{v^2}{2g})^2\r\n\\end{aligned}\\]\r\n代码\r\nfrom math import pih = 100v = 20g = 9.81ans = pi * (2 * g * v * h + v ** 3) ** 2 / (4 * g ** 3)print(&quot;&#123;:.4f&#125;&quot;.format(ans))\r\n","categories":["Project Euler"]},{"title":"Project Euler 321","url":"/project-euler/321/","content":"\r\nProject Euler 321\r\n题目\r\nSwapping Counters\r\nA horizontal row comprising of \\(2n +\r\n1\\) squares has \\(n\\) red\r\ncounters placed at one end and \\(n\\)\r\nblue counters at the other end, being separated by a single empty square\r\nin the centre. For example, when \\(n =\r\n3\\).\r\n\r\nA counter can move from one square to the next (slide) or can jump\r\nover another counter (hop) as long as the square next to that counter is\r\nunoccupied.\r\n\r\nLet \\(M(n)\\) represent the minimum\r\nnumber of moves/actions to completely reverse the positions of the\r\ncoloured counters; that is, move all the red counters to the right and\r\nall the blue counters to the left.\r\nIt can be verified \\(M(3) = 15\\),\r\nwhich also happens to be a triangle number.\r\nIf we create a sequence based on the values of n for which \\(M(n)\\) is a triangle number then the first\r\nfive terms would be: \\(1, 3, 10, 22,\\)\r\nand \\(63\\), and their sum would be\r\n\\(99\\).\r\nFind the sum of the first forty terms of this sequence.\r\n解决方案\r\n第一个问题：\\(M(n)\\)的式子是什么？\r\n可以发现，每一枚筹码如果移动到它的目标格子，都需要前进\\(n+1\\)格，因此\\(2n\\)枚筹码就总共需要前进\\(2n(n+1)\\)格子。\r\n但是，当两个不同颜色的筹码相遇时，一个筹码就可以朝另一个筹码跳跃，一次操作就会前进\\(2\\)格格子。这样的相遇一共会发生\\(n^2\\)次。\r\n因此，\\(M(n)=2n(n+1)-n^2=n^2+2n\\)。\r\n第二个问题：求解问题中要求的数。\r\n如果\\(M(n)\\)为三角数，设存在m，使得\\(n^2+2n=\\dfrac{m(m+1)}{2}\\)。\r\n移项，两边同乘一个数\\(8\\)，得到\\(4m(m+1)-8(n^2+2n)=0\\)\r\n进行配方，移项后得到\\((2m+1)^2-8(n+1)^2=-7\\)。\r\n令\\(x=2m+1,y=n+1\\)，那么得到\\(x^2-8y^2=-7\\)，该类方程为广义佩尔方程：\\(x^2-Dy^2=N\\)。\r\n但是，广义佩尔方程的基础解有多个，不像\\(N=1,-1\\)时的情形。\r\n经过一定范围的搜索，发现这个方程有\\(6\\)个基本解：\r\n\\((1, 1), (5, 2)\\)\r\n使用与第137题类似的方法，每一组\\(x^2-8y^2=-7\\)的通解由它的一个基础解\\((x_1,y_1)\\)和\\(x^2-8y^2=1\\)的通解\\((a_k,b_k)\\)得到。\r\n\\[\\left \\{\\begin{aligned}\r\n  &amp; x_{k+1}=x_1a_k+Dy_1b_k\\\\\r\n  &amp; y_{k+1}=y_1a_k+x_1b_k\r\n\\end{aligned}\\right.\r\n\\]\r\n再根据第66题的算法，可以得到\\(x^2-8y^2=1\\)的通解： \\[a_1=3,b_1=1\\] \\[\\left \\{\\begin{aligned}\r\n  &amp; a_{k+1}=3a_k+8b_k\\\\\r\n  &amp; b_{k+1}=a_k+3b_k\r\n\\end{aligned}\\right.\r\n\\]\r\n计算出每一对\\((x,y)\\)后，需要回代\\(m=\\dfrac{x-1}{2},n=y-1\\)。判断这时\\(m,n\\)是否为正整数。最终求出这些\\(n\\)的和\r\n代码\r\nN = 40def gen_solution():    D = 8    base_sol = [(1, 1), (5, 2)]    a, b = 3, 1    for x, y in base_sol:        yield x, y    while True:        for i in range(len(base_sol)):            x, y = base_sol[i]            x, y = x * a + D * y * b, x * b + y * a            yield x, y        a, b = 3 * a + 8 * b, a + 3 * bls = []for x, y in gen_solution():    if (x - 1) % 2 == 0 and (x - 1) // 2 &gt; 0:        ls.append(y - 1)        if len(ls) == N:            breakans = sum(ls)print(ans)\r\n","categories":["Project Euler"],"tags":["佩尔方程"]},{"title":"Project Euler 32","url":"/project-euler/32/","content":"\r\nProject Euler 32\r\n题目\r\nPandigital products\r\nWe shall say that an \\(n\\)-digit\r\nnumber is pandigital if it makes use of all the digits \\(1\\) to \\(n\\) exactly once; for example, the \\(5\\)-digit number, \\(15234\\), is \\(1\\) through \\(5\\) pandigital.\r\nThe product \\(7254\\) is unusual, as\r\nthe identity, \\(39 \\times 186 = 7254\\),\r\ncontaining multiplicand, multiplier, and product is \\(1\\) through \\(9\\) pandigital.\r\nFind the sum of all products whose multiplicand/multiplier/product\r\nidentity can be written as a \\(1\\)\r\nthrough \\(9\\) pandigital.\r\nHINT: Some products can be obtained in more than one way so be sure\r\nto only include it once in your sum.\r\n解决方案\r\n先枚举第\\(1\\)个因数，后枚举第\\(2\\)个因数。再判断两个因数和积拼接后的长度是否会大于\\(9\\).\r\n代码\r\nfrom itertools import countN = 1000c = &quot;123456789&quot;st = set()for i in range(1, N):    for j in count(i + 1, 1):        s = str(i) + str(j) + str(i * j)        if len(s) &gt; 9:            break        t = &quot;&quot;.join((lambda x: (x.sort(), x)[1])(list(s)))        if t == c:            st.add(i * j)ans = sum(st)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 323","url":"/project-euler/323/","content":"\r\nProject Euler 323\r\n题目\r\nBitwise-OR operations\r\non random integers\r\nLet \\(y_0, y_1, y_2,\\dots\\) be a\r\nsequence of random unsigned \\(32\\) bit\r\nintegers (i.e. \\(0 \\le y_i &lt;\r\n2^{32}\\), every value equally likely). For the sequence \\(x_i\\) the following recursion is given:\r\n\r\n\\(x_0 = 0\\) and\r\n\\(x_i = x_{i-1} \\mathbf{|}\r\ny_{i-1}\\), for \\(i &gt; 0\\). (\r\n\\(\\mathbf{|}\\) is the bitwise-OR\r\noperator)\r\n\r\nIt can be seen that eventually there will be an index \\(N\\) such that \\(x_i = 2^{32} -1\\) (a bit-pattern of all\r\nones) for all \\(i \\ge N\\).\r\nFind the expected value of \\(N\\).\r\nGive your answer rounded to \\(10\\)\r\ndigits after the decimal point.\r\n解决方案\r\n令\\(N=32\\)。\r\n一个观察点：当前状态其实和\\(y_i\\)的值没有关系，只和\\(y_i\\)的二进制\\(1\\)的个数有关系。\r\n因此，我们只考虑\\(y_i\\)中还有多少个\\(0\\)还没有被翻成\\(1\\)。\r\n令\\(f(i)(i\\ge 0)\\)表示还有\\(i\\)个\\(0\\)还没被翻成\\(1\\)的情况下，全都完成翻转的期望。\r\n那么，状态\\(i\\)有\\(\\dfrac{\\binom{i}{0}}{2^i}\\)的概率转换成状态\\(i\\)，也就是说，一个比特都没翻转成功；有\\(\\dfrac{\\binom{i}{1}}{2^i}\\)的概率转换成状态\\(i-1\\)，也就是说只有一个比特翻转成功了……有\\(\\dfrac{\\binom{i}{i}}{2^i}\\)的概率转换成状态\\(0\\)，此时\\(i\\)个比特全部成功翻转。那么，我们可以写出如下的式子：\r\n\\[f(i)=\\sum_{j=0}^i\\left(\\dfrac{\\binom{i}{j}}{2^n}\\cdot\r\nf(j)\\right)+1\\]\r\n这是一个有后效性的动态规划方程，因为状态之间形成了循环的依赖（状态\\(i\\)依赖于自身）。不过，这种情况下消除后效性很简单。右边有一个项也是\\(f(i)\\)，只需要挪到左边消除就可以完成消除后效性，从而正确计算结果。\r\n因此，可以正式写出状态转移方程：\r\n\\[\r\nf(i)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0  &amp; &amp; \\text{if}\\quad i=0 \\\\\r\n  &amp;\\dfrac{\\sum_{j=0}^{i-1}\\binom{i}{j}\\cdot f(j)+2^i}{2^i-1} &amp;\r\n&amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n因此，最终结果为\\(f(N)\\)。\r\n代码\r\nfrom tools import get_pascals_triangleN = 32C = get_pascals_triangle(N)f = [0]for n in range(1, N + 1):    f.append(2 ** n)    for i in range(n):        f[n] += C[n][i] * f[i]    f[n] /= 2 ** n - 1ans = f[N]print(&quot;&#123;:.10f&#125;&quot;.format(ans))\r\n","categories":["Project Euler"],"tags":["动态规划","概率"]},{"title":"Project Euler 318","url":"/project-euler/318/","content":"\r\nProject Euler 318\r\n题目\r\n\\(2011\\) nines\r\nConsider the real number \\(\\sqrt 2 + \\sqrt\r\n3\\). When we calculate the even powers of \\(\\sqrt 2 + \\sqrt 3\\) we get:\r\n\\(\\begin{aligned}\r\n&amp;(\\sqrt 2 + \\sqrt 3)^2 = 9.898979485566356 \\dots \\\\\r\n&amp;(\\sqrt 2 + \\sqrt 3)^4 = 97.98979485566356 \\dots \\\\\r\n&amp;(\\sqrt 2 + \\sqrt 3)^6 = 969.998969071069263 \\dots\\\\\r\n&amp;(\\sqrt 2 + \\sqrt 3)^8 = 9601.99989585502907 \\dots \\\\\r\n&amp;(\\sqrt 2 + \\sqrt 3)^{10} = 95049.999989479221 \\dots \\\\\r\n&amp;(\\sqrt 2 + \\sqrt 3)^{12} = 940897.9999989371855 \\dots \\\\\r\n&amp;(\\sqrt 2 + \\sqrt 3)^{14} = 9313929.99999989263 \\dots \\\\\r\n&amp;(\\sqrt 2 + \\sqrt 3)^{16} = 92198401.99999998915 \\dots \\\\\r\n\\end{aligned}\\)\r\nIt looks as if the number of consecutive nines at the beginning of\r\nthe fractional part of these powers is non-decreasing.\r\nIn fact it can be proven that the fractional part of \\((\\sqrt 2 + \\sqrt 3)^{2 n}\\) approaches\r\n\\(1\\) for large \\(n\\).\r\nConsider all real numbers of the form \\(\\sqrt p + \\sqrt q\\) with \\(p\\) and \\(q\\) positive integers and \\(p &lt; q\\), such that the fractional part\r\nof \\((\\sqrt p + \\sqrt q)^{ 2 n}\\)\r\napproaches \\(1\\) for large \\(n\\).\r\nLet \\(C(p,q,n)\\) be the number of\r\nconsecutive nines at the beginning of the fractional part of \\((\\sqrt p + \\sqrt q)^{ 2 n}\\).\r\nLet \\(N(p,q)\\) be the minimal value\r\nof \\(n\\) such that \\(C(p,q,n) \\ge 2011\\).\r\nFind \\(\\displaystyle \\sum N(p,q) \\,\\,\r\n\\text{ for } p+q \\le 2011\\).\r\n解决方案\r\n不难知道，\\((\\sqrt{p}+\\sqrt{q})^{2n}+(\\sqrt{q}-\\sqrt{p})^{2n}\\)一定是一个整数（通过二项式定理将两个式子拆开不难证明）。\r\n并且，如果需要得到题目中的那种收敛情况，那么就必须满足\\(\\sqrt{q}-\\sqrt{p}&lt;1\\)。那么随着\\(n\\)增大，值\\((\\sqrt{q}-\\sqrt{p})^{2n}\\)将无限逼近于\\(0\\).并且，通过加法可以知道\\((\\sqrt{p}+\\sqrt{q})^{2n}\\)的连续\\(9\\)的个数和\\((\\sqrt{p}-\\sqrt{q})^{2n}\\)的连续\\(0\\)个数相同。\r\n计算\\((\\sqrt{q}-\\sqrt{p})^{2n}\\)的连续\\(0\\)个数不难想到使用对数解决。通过计算，\\((\\sqrt{q}-\\sqrt{p})^{2n}\\)的连续\\(0\\)个数为\\(\\left\\lfloor-2n\\lg\r\n(\\sqrt{q}-\\sqrt{p})\\right\\rfloor\\).\r\n那么令\\(M=2011\\)，取对数后，随着\\(n\\)增长，数\\(-2n\\lg\r\n(\\sqrt{q}-\\sqrt{p})\\)也是线性增长的，因此可以计算出\\(N(p,q)\\)得:\r\n\\[N(p,q)=\\left\\lceil-\\dfrac{M}{2\\lg(\\sqrt{q}-\\sqrt{p})}\\right\\rceil\\]\r\n代码\r\n#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=2011,M=2011;double sq[N+4];int main()&#123;    for(int i=1;i&lt;=N;i++)        sq[i]=sqrt(i);    ll ans=0;    for(int p=1;p&lt;=N;p++)        for(int q=p+1;p+q&lt;=N&amp;&amp;sq[q]-sq[p]&lt;1;q++)&#123;            double g=-log10(sq[q]-sq[p])*2;            ans+=ceil(1.0*M/g);        &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 324","url":"/project-euler/324/","content":"\r\nProject Euler 324\r\n题目\r\nBuilding a tower\r\nLet \\(f(n)\\) represent the number of\r\nways one can fill a \\(3\\times3\\times\r\nn\\) tower with blocks of \\(2\\times1\\times1\\).\r\nYou’re allowed to rotate the blocks in any way you like; however,\r\nrotations, reflections etc of the tower itself are counted as\r\ndistinct.\r\nFor example (with \\(q = 100000007\\))\r\n:\r\n\\(\\begin{aligned}\r\n&amp;f(2) = 229,\\\\\r\n&amp;f(4) = 117805,\\\\\r\n&amp;f(10) \\bmod q = 96149360,\\\\\r\n&amp;f(10^3) \\bmod q = 24806056,\\\\\r\n&amp;f(10^6) \\bmod q = 30808124.\\\\\r\n\\end{aligned}\\)\r\nFind \\(f(10^{10000}) \\bmod\r\n100000007\\).\r\n解决方案\r\n令\\(N=10^{10000}\\)。\r\n将\\(f(2)\\)和\\(f(4)\\)放入OEIS中查找，发现结果为A028452。\r\n找到FORMULA一栏，发现如下信息：\r\na(n) = 679a(n-1) -76177a(n-2) +3519127a(n-3) -85911555a(n-4) +1235863045a(n-5) -11123194131a(n-6) +65256474997a(n-7) -257866595482a(n-8) +705239311926a(n-9) -1363115167354a(n-10) +1888426032982a(n-11) -1888426032982a(n-12) +1363115167354a(n-13) -705239311926a(n-14) +257866595482a(n-15) -65256474997a(n-16) +11123194131a(n-17) -1235863045a(n-18) +85911555a(n-19) -3519127a(n-20) +76177a(n-21) -679a(n-22) +a(n-23).\r\n其中，这里的\\(a(n)=f(2n)\\)。因为很明显知道，当\\(m\\)为奇数时，\\(f(m)=0\\)。\r\n因此此时就变成了求\\(a\\left(\\dfrac{N}{2}\\right)\\)的值。\r\n注意到\\(a\\)的递推式有\\(M=23\\)个项，因此使用矩阵快速幂加速时，所使用的矩阵大小\\(M\\)。因此，考虑使用第258题中的哈密顿-凯莱定理，将计算递推式的时间复杂度进一步降至\\(O(M^2 \\log N)\\)。\r\n代码\r\n此处使用GMP库对\\(N\\)进行处理。\r\n本份代码由第258题的代码修改而来。\r\n#include&lt;bits/stdc++.h&gt;#include &quot;gmpxx.h&quot;using namespace std;typedef long long ll;const int P=10000;mpz_class N(string(&quot;1&quot;)+string(P,&#x27;0&#x27;));ll mod = 100000007;const int M=23;// a代表递推式的前M个值ll a[M];string string_a[M]= &#123;        &quot;1&quot;,        &quot;229&quot;,        &quot;117805&quot;,        &quot;64647289&quot;,        &quot;35669566217&quot;,        &quot;19690797527709&quot;,        &quot;10870506600976757&quot;,        &quot;6001202979497804657&quot;,        &quot;3313042830624031354513&quot;,        &quot;1829008840116358153050197&quot;,        &quot;1009728374600381843221483965&quot;,        &quot;557433823481589253332775648233&quot;,        &quot;307738670509229621147710358375321&quot;,        &quot;169891178715542584369273129260748045&quot;,        &quot;93790658670253542024618689133882565125&quot;,        &quot;51778366130057389441239986148841747669217&quot;,        &quot;28584927722109981792301610403923348017948449&quot;,        &quot;15780685138381102545287108197623881881376915397&quot;,        &quot;8711934690116480171969789787256390490181022415693&quot;,        &quot;4809538076408327645969201260680362259835079086427481&quot;,        &quot;2655168723276120197512956906659822833388644760430125609&quot;,        &quot;1465820799640802552047402979496052449322258430218930512765&quot;,        &quot;809225642733724788155919446555896648357335949987871250500245&quot;&#125;;// p代表Hamilton-Cayley而来的矩阵多项式的系数。ll p[M]= &#123;        1,        -679,        76177,        -3519127,        85911555,        -1235863045,        11123194131,        -65256474997,        257866595482,        -705239311926,        1363115167354,        -1888426032982,        1888426032982,        -1363115167354,        705239311926,        -257866595482,        65256474997,        -11123194131,        1235863045,        -85911555,        3519127,        -76177,        679&#125;;// b代表A^(2^i)时所有的A^(2^i)=sum from j=0 to M-1 A^j*b_j时系数b_j的值。ll b[M];// v代表解决方案所指的v。ll v[M];void mul_ploy(ll a[M],ll b[M],ll p[M]) &#123;    //做的是乘法，对应的就是多项式系数的卷积。    ll c[M &lt;&lt; 1];    memset(c, 0, sizeof(c));    for (int i = 0; i &lt; M; i++)        for (int j = 0; j &lt; M; j++)            c[i + j] = (c[i + j] + a[i] * b[j]) % mod;    //利用递推式F(A)的值，将&gt;=M的所有临时系数转化成&lt;M的系数。    for (int i = M * 2 - 1; i &gt;= M; i--)        for (int j = 0; j &lt; M; j++)            c[i - M + j] = (c[i - M + j] + c[i] * p[j]) % mod;    for (int i = 0; i &lt; M; i++)        a[i] = c[i];&#125;int main() &#123;    ll ans = 0;    if ((N &amp; 1) == 0) &#123;        N &gt;&gt;= 1;        for (int i = 0; i &lt; M; i++) &#123;            for (char ch:string_a[i])                a[i] = (a[i] * 10 + ch - &#x27;0&#x27;) % mod;        &#125;        for (int i = 0; i &lt; M; i++)            p[i] = (p[i] % mod + mod) % mod;        b[1] = 1;        v[0] = 1;        for (; N; N &gt;&gt;= 1) &#123;            if ((N &amp; 1) == 1) mul_ploy(v, b, p);            mul_ploy(b, b, p);        &#125;        for (int i = 0; i &lt; M; i++)            ans = (ans + v[i] * a[i]) % mod;    &#125;    printf(&quot;%lld\\n&quot;, ans);&#125;\r\n","categories":["Project Euler"],"tags":["OEIS","矩阵快速幂"]},{"title":"Project Euler 326","url":"/project-euler/326/","content":"\r\nProject Euler 326\r\n题目\r\nModulo Summations\r\nLet \\(a_n\\) be a sequence\r\nrecursively defined by:\\(\\quad\r\na_1=1,\\quad\\displaystyle a_n=\\biggl(\\sum_{k=1}^{n-1}k\\cdot\r\na_k\\biggr)\\bmod n\\).\r\nSo the first \\(10\\) elements of\r\n\\(a_n\\) are: \\(1,1,0,3,0,3,5,4,1,9\\).\r\nLet \\(f(N,M)\\) represent the number\r\nof pairs \\((p,q)\\) such that:\r\n\\[ 1 \\le p \\le q \\le N \\text{ and }\r\n\\left(\\sum_{i=p}^{q}a_i\\right) \\text{ mod } M=0\\]\r\nIt can be seen that \\(f(10,10)=4\\)\r\nwith the pairs \\((3,3), (5,5), (7,9)\\)\r\nand \\((9,10)\\).\r\nYou are also given that \\(f(10^4,10^3)=97158\\).\r\nFind \\(f(10^{12},10^6)\\).\r\n解决方案\r\n通过以下程序进行打表，发现序列\\(a_n\\)满足如下规律：\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=200;int s[N+4],a[N+4];int main()&#123;    s[1]=a[1]=1;    for(int n=2;n&lt;=N;n++)&#123;        a[n]=s[n-1]%n;        s[n]=s[n-1]+a[n]*n;    &#125;    for(int i=0;i&lt;=N;i++)        printf(&quot;%d%c&quot;,a[i],&quot; \\n&quot;[i%6==5]);&#125;\r\n\\(\\begin{aligned}\r\n&amp;a_{6i}=3i\\\\\r\n&amp;a_{6i+1}=4i+1\\\\\r\n&amp;a_{6i+2}=3i+1\\\\\r\n&amp;a_{6i+3}=i\\\\\r\n&amp;a_{6i+4}=6i+3\\\\\r\n&amp;a_{6i+5}=i\r\n\\end{aligned}\\)\r\n那么令\\(\\displaystyle{S(n)=\\sum_{i=1}^na_i}\\)，那么根据这个周期性质，通过待定系数法来进行计算，不难写出：\r\n\\(\\begin{aligned}\r\n&amp;S(6i)=9i^2-i\\\\\r\n&amp;S(6i+1)=9i^2+3i+1\\\\\r\n&amp;S(6i+2)=9i^2+6i+2\\\\\r\n&amp;S(6i+3)=9i^2+7i+2\\\\\r\n&amp;S(6i+4)=9i^2+13i+5\\\\\r\n&amp;S(6i+5)=9i^2+14i+5\r\n\\end{aligned}\\)\r\n由于\\(\\displaystyle{S(q)-S(p)=\\sum_{i=p}^qa_i}\\)，因此问题可以转化成如下形式：\r\n有多少对\\((p,q)\\)满足如下条件：\r\n\r\n\\(0\\le p&lt; q&lt; N\\)\r\n\\(S(p)-S(q)\\equiv 0\\pmod\r\nM\\)，也就是\\(S(p)\\equiv S(q)\\pmod\r\nM\\)\r\n\r\n那么不难发现，我们可以统计\\(0\\sim\r\nN\\)中有多少个\\(i\\)满足\\(S(i)\\%M=j\\)，用数组\\(c\\)来存储个数，并统计在\\(c[j]\\)中。那么最终答案为\r\n\\[f(N,M)=\\sum_{i=0}^{M-1} \\dfrac{c[i]\\cdot\r\n(c[i]-1)}{2}\\]\r\n对于\\(j\\in[0,5]\\)，\\(S(6i+j)\\)都是二次多项式，因此不难发现\\(S(i+M)\\equiv S(i)\\pmod p\\)。\r\n因此，对于\\(i\\in[0,M),j\\in[0,5]\\)，我们统计有多少个非负整数\\(k\\)满足\\(6\\cdot(i+Mk)+j\\le\r\nN\\)。并将统计的值统计到\\(c[S(6i+j)\\%M]\\)即可。不难计算得到满足条件的\\(k\\)的个数为\\(\\left\\lfloor\\dfrac{N-6i-j}{6M}\\right\\rfloor+1\\)。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll N=1000000000000;const int M=1000000;const int T=6;ll c[M];ll v[T];int main()&#123;    for(int i=0;i&lt;M;i++)&#123;        v[0]=1ll*9*i*i-i;        v[1]=v[0]+4*i+1;        v[2]=v[1]+3*i+1;        v[3]=v[2]+i;        v[4]=v[3]+6*i+3;        v[5]=v[4]+i;        for(int j=0;j&lt;T;j++) &#123;            v[j]%=M;            c[v[j]]+=(N-j-T*i+T*M)/(T*M);        &#125;    &#125;    ll ans=0;    for(int i=0;i&lt;M;i++)        ans+=c[i]*(c[i]-1)/2;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 33","url":"/project-euler/33/","content":"\r\nProject Euler 33\r\n题目\r\nDigit cancelling fractions\r\nThe fraction \\(\\dfrac{49}{98}\\) is a\r\ncurious fraction, as an inexperienced mathematician in attempting to\r\nsimplify it may incorrectly believe that \\(\\dfrac{49}{98}=\\dfrac{4}{8}\\), which is\r\ncorrect, is obtained by cancelling the \\(9\\)s.\r\nWe shall consider fractions like, \\(\\dfrac{30}{50}=\\dfrac{3}{5}\\), to be\r\ntrivial examples.\r\nThere are exactly four non-trivial examples of this type of fraction,\r\nless than one in value, and containing two digits in the numerator and\r\ndenominator.\r\nIf the product of these four fractions is given in its lowest common\r\nterms, find the value of the denominator.\r\n解决方案\r\n所求解如果不是一个平凡解，那么，删除的位在分子和分母中一定不同，即有以下两种情况：\r\n\r\n删除分子的十位和分母的个位\r\n删除分子的个位和分母的十位\r\n\r\n枚举分子和分母，判断这两种情况。\r\n代码\r\nfrom tools import gcda, b = 1, 1for x in range(10, 100):    for y in range(x + 1, 100):        ok = False        u, v = x // 10, y % 10        if x * v == y * u and x % 10 == y // 10:            ok = True        u, v = x % 10, y // 10        if x * v == y * u and x // 10 == y % 10:            ok = True        if ok:            a *= x            b *= yans = b // gcd(a, b)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 327","url":"/project-euler/327/","content":"\r\nProject Euler 327\r\n题目\r\nRooms of Doom\r\nA series of three rooms are connected to each other by automatic\r\ndoors.\r\n\r\nEach door is operated by a security card. Once you enter a room the\r\ndoor automatically closes and that security card cannot be used again. A\r\nmachine at the start will dispense an unlimited number of cards, but\r\neach room (including the starting room) contains scanners and if they\r\ndetect that you are holding more than three security cards or if they\r\ndetect an unattended security card on the floor, then all the doors will\r\nbecome permanently locked. However, each room contains a box where you\r\nmay safely store any number of security cards for use at a later\r\nstage.\r\nIf you simply tried to travel through the rooms one at a time then as\r\nyou entered room \\(3\\) you would have\r\nused all three cards and would be trapped in that room forever!\r\nHowever, if you make use of the storage boxes, then escape is\r\npossible. For example, you could enter room \\(1\\) using your first card, place one card\r\nin the storage box, and use your third card to exit the room back to the\r\nstart. Then after collecting three more cards from the dispensing\r\nmachine you could use one to enter room \\(1\\) and collect the card you placed in the\r\nbox a moment ago. You now have three cards again and will be able to\r\ntravel through the remaining three doors. This method allows you to\r\ntravel through all three rooms using six security cards in total.\r\nIt is possible to travel through six rooms using a total of \\(123\\) security cards while carrying a\r\nmaximum of \\(3\\) cards.\r\nLet \\(C\\) be the maximum number of\r\ncards which can be carried at any time.\r\nLet \\(R\\) be the number of rooms to\r\ntravel through.\r\nLet \\(M(C,R)\\) be the minimum number\r\nof cards required from the dispensing machine to travel through R rooms\r\ncarrying up to a maximum of \\(C\\) cards\r\nat any time.\r\nFor example, \\(M(3,6)=123\\) and\r\n\\(M(4,6)=23\\). And, \\(\\sum M(C,6)=146\\) for \\(3 \\le C \\le 4\\).\r\nYou are given that \\(\\sum\r\nM(C,10)=10382\\) for \\(3 \\le C \\le\r\n10\\).\r\nFind \\(\\sum M(C,30)\\) for \\(3 \\le C \\le 40\\).\r\n解决方案\r\n当\\(R&lt; C\\)时，不难发现\\(M(C,R)=C+1\\)，这个人只需要一次拿完需要的卡就可以通过。\r\n当\\(R\\ge\r\nC\\)时，我们不能够一次过将所有卡带在身上了。因此还需要出门回到初始点取卡。在有\\(R\\)个房间的情况下，相当于先将足够的卡片先运到第\\(1\\)个房间；只要卡片足够了，那么接下来就变成了子问题\\(M(C,R-1)\\)。\\(M(C,R)\\)取决于\\(M(C,R-1)\\).\r\n此时需要的卡多于\\(C\\)张，需要多次进出房间，那么实际上每次只能运进去\\(C-2\\)张卡片。并且在最后一次运送时，由于已经不再打算出来，那么实际运进去的卡片就有\\(C-1\\)张。因此最后一次运送需要额外处理。\r\n除去最后一次运送的\\(C-1\\)张卡片，那么剩下的\\(f(C,R-1)-(C-1)\\)张卡片每次实际运送\\(C-2\\)张。不足\\(C-2\\)张则下次补上。\r\n需要注意的是，实际上，每一次的运送过程都是取\\(C\\)张卡片进行。\r\n本题其实还是使用了动态规划的思想。\r\n假设\\(C\\ge 3,R\\ge\r\n0\\)，那么可以写出\\(M(C,R)\\)的状态转移方程：\r\n\\[\r\nM(C,R)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;R+1  &amp; &amp; \\text{if}\\quad R&lt;C \\\\\r\n  &amp;\\left(\\left\\lfloor\r\n\\dfrac{f(C,R-1)-(C-1)}{C-2}\\right\\rfloor+1\\right)\\cdot C +\r\nt((f(C,R-1)-(C-1))\\%(C-2))&amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n其中\\(t(x)\\)表示如果\\(x=0\\)，那么\\(t(0)=0\\)，否则\\(t(x)=x+2\\).\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int C=40,R=30;ll f[C+1][R+1];int main()&#123;    for(ll c=3;c&lt;=C;c++)&#123;        for(int r=1;r&lt;c;r++) f[c][r]=r+1;        for(int r=c;r&lt;=R;r++)&#123;            ll q=(f[c][r-1]-(c-1))/(c-2);            ll d=(f[c][r-1]-(c-1))%(c-2);            f[c][r]=(q+1)*c+(d?d+2:0);        &#125;    &#125;    ll ans=0;    for(int c=3;c&lt;=C;c++)        ans+=f[c][R];    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 329","url":"/project-euler/329/","content":"\r\nProject Euler 329\r\n题目\r\nPrime Frog\r\nSusan has a prime frog.\r\nHer frog is jumping around over \\(500\\) squares numbered \\(1\\) to \\(500\\).\r\nHe can only jump one square to the left or to the right, with equal\r\nprobability, and he cannot jump outside the range \\([1;500]\\). (if it lands at either end, it\r\nautomatically jumps to the only available square on the next move.)\r\nWhen he is on a square with a prime number on it, he croaks ‘P’\r\n(PRIME) with probability \\(2/3\\) or ‘N’\r\n(NOT PRIME) with probability \\(1/3\\)\r\njust before jumping to the next square.\r\nWhen he is on a square with a number on it that is not a prime he\r\ncroaks ‘P’ with probability \\(1/3\\) or\r\n‘N’ with probability \\(2/3\\) just\r\nbefore jumping to the next square.\r\nGiven that the frog’s starting position is random with the same\r\nprobability for every square, and given that she listens to his first\r\n\\(15\\) croaks, what is the probability\r\nthat she hears the sequence PPPPNNPPPNPPNPN?\r\nGive your answer as a fraction \\(p/q\\) in reduced form.\r\n解决方案\r\n不难想到使用动态规划的方法来做。\r\n令\\(M=500\\)，\\(s\\)是PPPPNNPPPNPPNPN这个字符串本身，下标从\\(0\\)开始，\\(N\\)是这个字符串的长度。本题需要注意的一点是，这只青蛙是先叫出字母，然后再进行移动。\r\n假设\\(f(i,j)(0\\le i\\le N,1\\le j\\le\r\nM)\\)为青蛙已经正确地叫出了前\\(i\\)个字母，并且已经跳到了第\\(j\\)个格子的概率。那么不难写出如下状态转移方程：\r\n\\[\r\nf(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;\\dfrac{1}{M}  &amp; &amp; \\text{if}\\quad i=0 \\\\\r\n  &amp;f(i-1,j+1)\\cdot q_M(j+1)\\cdot p(j+1,s[i-1]) &amp; &amp;\r\n\\text{else if}\\quad j=1 \\\\\r\n  &amp;f(i-1,j-1)\\cdot q_M(j-1)\\cdot p(j-1,s[i-1]) &amp; &amp;\r\n\\text{else if}\\quad j=M \\\\\r\n  &amp;f(i-1,j+1)\\cdot q_M(j+1)\\cdot p(j+1,s[i-1])+f(i-1,j-1)\\cdot\r\nq_M(j-1)\\cdot p(j-1,s[i-1])&amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n其中，\\(q_M(j)\\)表示如果\\(j\\)等于\\(1\\)或者是\\(M\\)，那么\\(q_M(j)=1\\)，否则\\(q_M(j)=\\dfrac{1}{2}\\)；\\(p(n,c)\\)表示如果\\(n\\)的素性符合字母\\(c\\)的描述，那么\\(p(n,c)=\\dfrac{2}{3}\\)，否则\\(p(n,c)=\\dfrac{1}{3}\\).\r\n其中方程最后一行说明，第\\(j\\)个格子要么是从\\(j-1\\)以\\(q_M(j)\\)的概率跳过来的，并且有\\(p(j-1,s[i-1])\\)的概率叫出对应的字母；要么是从\\(j+1\\)跳过来的。\r\n那么本题的最终答案为\\(\\sum_{i=1}^M\r\nf(N,i)\\)。\r\n为了方便代码编写，我这里使用的方法是“我为人人”式动态规划。\r\n代码\r\nfrom fractions import Fractionfrom tools import is_primeM = 500s = &quot;PPPPNNPPPNPPNPN&quot;N = len(s)f = [[Fraction(0, 1) for x in range(M + 1)] for y in range(N + 1)]isp = [is_prime(i) for i in range(M + 1)]f[0] = [Fraction(0)] + [Fraction(1, M)] * Mfor i in range(N):    for j in range(1, M + 1):        q = 1 if j == 1 or j == M else Fraction(1, 2)        p = Fraction(1, 3) if isp[j] ^ (s[i] == &#x27;P&#x27;) else Fraction(2, 3)        if j &lt; M:            f[i + 1][j + 1] += f[i][j] * q * p        if j &gt; 1:            f[i + 1][j - 1] += f[i][j] * q * pans = sum(f[N])print(ans)\r\n","categories":["Project Euler"],"tags":["动态规划","概率"]},{"title":"Project Euler 333","url":"/project-euler/333/","content":"\r\nProject Euler 333\r\n题目\r\nSpecial partitions\r\nAll positive integers can be partitioned in such a way that each and\r\nevery term of the partition can be expressed as \\(2^i\\times3^j\\), where \\(i,j \\ge 0\\).\r\nLet’s consider only those such partitions where none of the terms can\r\ndivide any of the other terms.\r\nFor example, the partition of \\(17 = 2 + 6\r\n+ 9 = (2^1\\times3^0 + 2^1\\times3^1 + 2^0\\times3^2)\\) would not be\r\nvalid since \\(2\\) can divide \\(6\\). Neither would the partition \\(17 = 16 + 1 = (2^4\\times3^0 +\r\n2^0\\times3^0)\\) since \\(1\\) can\r\ndivide \\(16\\). The only valid partition\r\nof \\(17\\) would be \\(8 + 9 = (2^3\\times3^0 +\r\n2^0\\times3^2)\\).\r\nMany integers have more than one valid partition, the first being 11\r\nhaving the following two partitions.\r\n\\(11 = 2 + 9 = (2^1\\times3^0 +\r\n2^0\\times3^2)\\) \\(11 = 8 + 3 =\r\n(2^3\\times3^0 + 2^0\\times3^1)\\)\r\nLet’s define \\(P(n)\\) as the number\r\nof valid partitions of \\(n\\). For\r\nexample, \\(P(11) = 2\\).\r\nLet’s consider only the prime integers \\(q\\) which would have a single valid\r\npartition such as \\(P(17)\\).\r\nThe sum of the primes \\(q &lt;100\\)\r\nsuch that \\(P(q)=1\\) equals \\(233\\).\r\nFind the sum of the primes \\(q\r\n&lt;1000000\\) such that \\(P(q)=1\\).\r\n解决方案\r\n如果\\(n\\)的一个划分为\\(2^{e_1}3^{f_1}+2^{e_2}3^{f_2}+\\dots\\)是有效的，那么不能存在一对\\(e_i,e_j\\)或\\(f_i,f_j\\)满足\\(e_i=e_j\\)或\\(f_i=f_j\\)，并且不能够同时满足\\(e_i&lt;e_j,f_i,f_j\\)。因此假设\\(e_1&lt; e_2&lt; e_3&lt;\r\n\\dots\\)，那么必须有\\(f_1&gt;f_2&gt;f_3&gt;\\dots\\)\r\n令\\(N=10^6,M=\\left\\lceil\\log_3\r\nN\\right\\rceil+1,O=\\left\\lfloor\\log\r\n_2N\\right\\rfloor\\)。考虑用动态规划解决本问题。令状态\\(f(i,j,k)(-1\\le i\\le O,0\\le j&lt; N,0\\le k\\le\r\nM)\\)表示当前对数\\(j\\)的有效划分方法中，满足\\(e_1&lt;e_2&lt;\\dots\\le i,f_1&gt;f_2&gt;\\dots \\ge\r\nk\\)的方法数。需要注意的是，这里的\\(i=-1\\)这个状态并非真正存在，仅仅是为了定初值，然后进行转移。\r\n那么对于\\(i=-1,f(i,0,M)=1\\)。对于\\(i=-1\\)的其它情况，则为\\(0\\)。\r\n这里的动态规划使用我为人人的形式。对于任意一个状态\\(f(i,j,k)\\)，有以下转移：\r\n\r\n\\(f(i,j,k)\\rightarrow\r\nf(i+1,j,k)\\)，这个转移方式说明序列\\(e\\)不会存在\\(x\\)使得\\(e_x=i+1\\)。\r\n对于所有\\(l&lt; k,j+2^{i+1}3^l&lt;\r\nN\\)，都有\\(f(i,j,k)\\rightarrow\r\nf(i+1,j+2^{i+1}3^l,l)\\)，这说明\\(j\\)再加上一个数\\(2^{i+1}3^l\\)就变成了\\(j+2^{i+1}3^l\\)的一个划分方案，并且还是保持有效的。\r\n\r\n那么，最终答案为\r\n\\[P(n)=\\sum_{k=0}^M f(O,n,k)\\]\r\n代码\r\n#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=1000000;const int M=log(N+1)/log(3)+2;vector&lt;int&gt;pw23[36];int f[N+4][M];bool vis[N+4];int pr[N/10+100],m=0;int main()&#123;    for(int i=2;i&lt;N;i++)&#123;        if(vis[i]) continue;        pr[++m]=i;        for(ll j=1ll*i*i;j&lt;N;j+=i)            vis[j]=1;    &#125;    for(int i=0;(1&lt;&lt;i)&lt;N;i++)&#123;        int x=(1&lt;&lt;i);        for(int j=0;;j++)&#123;            pw23[i].push_back(x);            x*=3;            if(x&gt;=N) break;        &#125;    &#125;    f[0][M-1]=1;    for(int i=0;(1&lt;&lt;i)&lt;N;i++)&#123;        for(int j=N;j&gt;=0;j--)&#123;            for(int k=0;k&lt;M;k++)&#123;                if(f[j][k]==0) continue;                for(int l=0;l&lt;pw23[i].size()&amp;&amp;l&lt;k&amp;&amp;j+pw23[i][l]&lt;=N;l++)&#123;                    f[j+pw23[i][l]][l]+=f[j][k];                &#125;            &#125;        &#125;    &#125;    ll ans=0;    for(int i=1;i&lt;=m;i++)&#123;        int p=pr[i],c=0;        for(int j=0;j&lt;M;j++)            c+=f[p][j];        if(c==1) ans+=p;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 336","url":"/project-euler/336/","content":"\r\nProject Euler 336\r\n题目\r\nMaximix Arrangements\r\nA train is used to transport four carriages in the order: ABCD.\r\nHowever, sometimes when the train arrives to collect the carriages they\r\nare not in the correct order.\r\nTo rearrange the carriages they are all shunted on to a large\r\nrotating turntable. After the carriages are uncoupled at a specific\r\npoint the train moves off the turntable pulling the carriages still\r\nattached with it. The remaining carriages are rotated \\(180\\) degrees. All of the carriages are\r\nthen rejoined and this process is repeated as often as necessary in\r\norder to obtain the least number of uses of the turntable.\r\nSome arrangements, such as ADCB, can be solved easily: the carriages\r\nare separated between A and D, and after DCB are rotated the correct\r\norder has been achieved.\r\nHowever, Simple Simon, the train driver, is not known for his\r\nefficiency, so he always solves the problem by initially getting\r\ncarriage A in the correct place, then carriage B, and so on.\r\nUsing four carriages, the worst possible arrangements for Simon,\r\nwhich we shall call maximix arrangements, are DACB and DBAC;\r\neach requiring him five rotations (although, using the most efficient\r\napproach, they could be solved using just three rotations). The process\r\nhe uses for DACB is shown below.\r\n\r\nIt can be verified that there are \\(24\\) maximix arrangements for six\r\ncarriages, of which the tenth lexicographic maximix arrangement is\r\nDFAECB.\r\nFind the \\(2011^{\\text{th}}\\)\r\nlexicographic maximix arrangement for eleven carriages.\r\n解决方案\r\n令\\(N=11,Q=2011\\)。\r\n可以知道，最大的安排数是\\(2N-3\\)。这里使用数字\\(1\\)代表车厢A，\\(2\\)代表B，\\(3\\)代表C……按照这个人的排序方式，当\\(1\\)不在第\\(1\\)个位置并且不在第\\(N\\)个位置，那么他就需要\\(2\\)次翻转。翻转完成后，若\\(2\\)不在不在第\\(2\\)个位置并且不在第\\(N\\)个位置，那么同样需要\\(2\\)次翻转……最终到了第\\(N-1\\)个车厢，只有它在第\\(N\\)个位置时才翻转，而第\\(N\\)个车厢已经排好序。因此最大安排数为\\(2N-3\\)。\r\n因此，直接暴力枚举每个排列，按照题中的算法进行排序，直到找到第\\(Q\\)个排列。\r\n为了减少枚举量，发现第一个位置不可能为\\(1\\)或者是\\(2\\)。因为第一个是\\(1\\)，那就直接被算法跳过，肯定不是最优的；如果第一个是\\(2\\)，那么当\\(1\\)被翻转到第一个位置时，\\(2\\)将会在序列末尾，而不会在中间，少了所要求的一次翻转次数。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N=11,Q=2011;int a[N],b[N];int main()&#123;    a[0]=2;a[1]=0;a[2]=1;    for(int i=3;i&lt;N;i++)        a[i]=i;    int v=2*N-3,cnt=0;    do&#123;        int c=0;        memcpy(b,a,sizeof(a));        for(int i=0,p=0;i&lt;N;i++)&#123;            if(b[i]==i) break;            if(b[N-1]!=i)&#123;                for(p=i+1;b[p]!=i;p++);                reverse(b+p,b+N);                ++c;            &#125;            reverse(b+i,b+N);            ++c;        &#125;        if(c==v&amp;&amp;++cnt==Q) break;    &#125;while(next_permutation(a,a+N));    string ans=&quot;&quot;;    for(int i=0;i&lt;N;i++)        ans+=&#x27;A&#x27;+a[i];    cout&lt;&lt;ans&lt;&lt;endl;&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 34","url":"/project-euler/34/","content":"\r\nProject Euler 34\r\n题目\r\nDigit factorials\r\n\\(145\\) is a curious number, as\r\n\\(1! + 4! + 5! = 1 + 24 + 120 =\r\n145\\).\r\nFind the sum of all numbers which are equal to the sum of the\r\nfactorial of their digits.\r\nNote: as \\(1! = 1\\) and \\(2! = 2\\) are not sums they are not\r\nincluded.\r\n解决方案\r\n解法与30题相同。\r\n一个\\(n\\)位数如果全是\\(9\\)，那么其和数位和的\\(k\\)次幂为\\(n\\cdot\r\n9!\\)。因此一个\\(n\\)位数的值绝不会超过\\(n \\cdot 9!\\)。\r\n如果\\(n\\)满足\\(10^n&gt;n\\cdot 9!\\)，那么停止循环退出。\r\n代码\r\nfrom itertools import countfac = [1]for i in range(1, 10):    fac.append(fac[-1] * i)ans = 0for n in count(1, 1):    mx = min(10 ** (n + 1) - 1, n * fac[9])    st = 10 ** n    if st &gt; n * fac[9]:        break    for i in range(st, mx + 1):        s, w = 0, i        while w:            s += fac[w % 10]            w //= 10        if s == i:            ans += iprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 337","url":"/project-euler/337/","content":"\r\nProject Euler 337\r\n题目\r\nTotient Stairstep Sequences\r\nLet \\(\\{a_1, a_2,\\dots, a_n\\}\\) be\r\nan integer sequence of length n such that:\r\n\r\n\\(a_1 = 6\\)\r\nfor all \\(1 \\le i &lt; n\\) : \\(\\varphi(a_i) &lt; \\varphi(a_{i+1}) &lt; a_i &lt;\r\na_{i+1}\\quad ^1\\)\r\n\r\nLet \\(S(N)\\) be the number of such\r\nsequences with \\(a_n \\le N\\).\r\nFor example, \\(S(10) = 4: \\{6\\}, \\{6, 8\\},\r\n\\{6, 8, 9\\}\\) and \\(\\{6,\r\n10\\}\\).\r\nWe can verify that \\(S(100) =\r\n482073668\\) and \\(S(10 000) \\bmod 10^8\r\n= 73808307\\).\r\nFind \\(S(20 000 000) \\bmod\r\n10^8\\).\r\n\\(^1 \\quad \\varphi\\) denotes\r\nEuler’s totient function.\r\n解决方案\r\n在一个序列中，只有相邻的两个数才会有特定的放置关系，因此很容易想到动态规划的做法。\r\n和往常一样，假设\\(f(i)(i\\ge\r\n6)\\)为以数\\(i\\)为结尾的序列的数量，那么我们可以得到以下状态转移方程：\r\n\\[\r\nf(i)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i=6 \\\\\r\n  &amp;\\sum_{j,\\varphi(j)&lt;\\varphi(i)&lt;j&lt;i} f(j) &amp; &amp;\r\n\\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n不过，这种转移方式是\\(O(n^2)\\)的，如果为了使用树状数组优化，将转移过程下降到\\(O(n\\log\r\nn)\\)，那么需要进行大量的预处理（因为根据上面的式子，\\(\\varphi(a_{i+1})\\)的位置的难以确定）。\r\n因此，使用另外一种转移方式。令\\(N=20000000\\)。假设\\(f(i)(6\\le i\\le N)\\)为以数\\(i\\)为开头的序列的数量，那么我们可以得到以下状态转移方程：\r\n\\[\r\nf(i)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i=N \\\\\r\n  &amp;1+\\sum_{j,\\varphi(i)&lt;\\phi(j)&lt;i&lt;j} f(j) &amp; &amp;\r\n\\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n在计算\\(f(i)\\)时，树状数组已经保存了所有大于\\(i\\)时的状态值。因此，求出此时满足\\(\\varphi(i)&lt;\\varphi(j)&lt; i\\)的所有\\(j\\)，进行求和，而树状数组可以很方便地维护这一段的值之和。\r\n在后面这个转移过程中，\\(f(6)\\)为最终答案。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;# define lb(x) ((x)&amp;-(x))using namespace std;typedef long long ll;const int N=20000000;int phi[N+4];int s[N+4],f[N+4],mod=1e8;void add(int p,int x)&#123;    for(int i=p;i&lt;=N;i+=lb(i))        s[i]=(s[i]+x)%mod;&#125;int que(int p)&#123;    int ans=0;    for(int i=p;i;i-=lb(i))        ans=(ans+s[i])%mod;    return ans;&#125;int main()&#123;    for(int i=1;i&lt;=N;i++)        phi[i]=i;    for(int i=2;i&lt;=N;i++)&#123;        if(phi[i]==i)&#123;            for(int j=i;j&lt;=N;j+=i)                phi[j]=phi[j]/i*(i-1);        &#125;    &#125;    for(int i=N;i&gt;=6;i--)&#123;        int w=(que(i-1)-que(phi[i])+1+mod)%mod;        add(phi[i],w);        f[i]=w;    &#125;    int ans=f[6];    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划","树状数组"]},{"title":"Project Euler 342","url":"/project-euler/342/","content":"\r\nProject Euler 342\r\n题目\r\nThe totient of a square is a\r\ncube\r\nConsider the number \\(50\\).\r\n\\(50^2 = 2500 = 2^2 \\times 5^4\\), so\r\n\\(\\varphi(2500) = 2 \\times 4 \\times 5^3 = 8\r\n\\times 5^3 = 2^3 \\times 5^3. \\ ^1\\)\r\nSo \\(2500\\) is a square and \\(\\varphi(2500)\\) is a cube.\r\nFind the sum of all numbers \\(n\\),\r\n\\(1 &lt; n &lt; 10^{10}\\) such that\r\n\\(\\varphi(n^2)\\) is a cube.\r\n\\(^1\\ \\varphi\\) denotes\r\nEuler’s totient function.\r\n解决方案\r\n根据欧拉函数的定义，不难知道\\(\\varphi(n^2)=n\\cdot\\varphi(n)\\)。\r\n由于\\(\\varphi(p^e)=(p-1)p^{e-1}\\)，因子\\((p-1)\\)将会包含更小的质因子。因此枚举\\(n\\)时，从大到小枚举质因子。\r\n另外，\\(p^e\\cdot\r\n\\varphi(p^e)=(p-1)p^{2e-1}\\)。对于大的质因子而言，只有当\\(e\\equiv2\\pmod3\\)时，枚举的\\(n\\)才有可能满足\\(n\\cdot\r\n\\varphi(n)\\)是一个平方数；但是欧拉函数值产生的因子\\((p-1)\\)又会对以后枚举小的质因子造成影响，因此枚举时需要注意。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll N=10000000000;const int M=sqrt(N);bool vis[M+4];int pr[M+4],m=0;ll dfs(int p,ll n,ll phi)&#123;    if(p==0) return n;    ll t=phi;    int c=0;    for(;t%pr[p]==0;t/=pr[p],++c);    ll ans=0;    if(c%3==0) ans=dfs(p-1,n,phi);    for(int e=1;;e++)&#123;        n*=pr[p];        if(n&gt;=N) break;        if((e+e-1+c)%3) continue;        ans+=dfs(p-1,n,phi*(pr[p]-1));    &#125;    return ans;&#125;int main()&#123;    for(int i=2;i&lt;=M;i++)&#123;        if(!vis[i])&#123;            pr[++m]=i;            for(int j=i+i;j&lt;=M;j+=i)                vis[j]=1;        &#125;    &#125;    ll ans=dfs(m,1,1)-1;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 343","url":"/project-euler/343/","content":"\r\nProject Euler 343\r\n题目\r\nFractional Sequences\r\nFor any positive integer \\(k\\), a\r\nfinite sequence \\(a_i\\) of fractions\r\n\\(\\dfrac{x_i}{y_i}\\) is defined by:\r\n\\(a_1 = \\dfrac{1}{k}\\) and \\(a_i = \\dfrac{x_{i-1}+1}{y_{i-1}-1}\\)\r\nreduced to lowest terms for \\(i&gt;1\\).\r\nWhen \\(a_i\\) reaches some integer\r\n\\(n\\), the sequence stops. (That is,\r\nwhen \\(y_i=1\\).)\r\nDefine \\(f(k) = n\\).\r\nFor example, for \\(k = 20\\):\r\n\\(\\dfrac{1}{20} \\rightarrow \\dfrac{2}{19}\r\n\\rightarrow \\dfrac{3}{18} = \\dfrac{1}{6} \\rightarrow \\dfrac{2}{5}\r\n\\rightarrow \\dfrac{3}{4} \\rightarrow \\dfrac{4}{3} \\rightarrow\r\n\\dfrac{5}{2} \\rightarrow \\dfrac{6}{1} = 6\\)\r\nSo \\(f(20) = 6\\).\r\nAlso \\(f(1) = 1, f(2) = 2, f(3) =\r\n1\\) and \\(\\sum f(k^3) = 118937\\)\r\nfor \\(1 \\le k \\le 100\\).\r\nFind \\(\\sum f(k^3)\\) for \\(1 \\le k \\le 2\\times10^6\\).\r\n解决方案\r\n在迭代求\\(a_i\\)的过程中，如果不发生约分，那么分子和分母之和总是相等的，这个和一开始为\\(k+1\\)。因此从一开始，在迭代的过程中，当分子\\(x_i\\)满足\\(\\gcd(x_i,k+1)&gt;1\\)时，那么就会进行约分。由于\\(x_i\\)是从\\(1\\)开始迭代的，因此发生约分的时候，\\(x_i\\)是\\(k+1\\)的最小质因数，设其为\\(p\\)。约分后，分子变成\\(1\\)，分母变成\\((k+1-p)/p\\)，注意到也是一个新的分数单位，并且消去了\\(k+1\\)中最小的一个质因数\\(p\\)，此时是一个新的进入了新的迭代过程。\r\n最终，\\(k+1\\)的质因子从小到大一直被消去，直到剩下一个最大的质因子。\r\n如果一开始\\(k+1\\)是质数时，约分便不会再发生。故\\(f(k)\\)的值是\\(k+1\\)的最大质因子再减去\\(1\\).\r\n由于\\(n^3+1=(n+1)(n^2-n+1)\\)，\\(n^3+1\\)的最大质因子要么来自\\(n+1\\)，要么来自\\(n^2-n+1\\)。\r\n求\\(n+1\\)的最大质因子此处不详述，使用普通筛法即可。而\\(n^2-n+1\\)则使用和216题类似的筛法进行筛选：令\\(g(n)=n^2-n+1\\)，如果\\(p\\mid g(n)\\)，那么\\(p\\mid g(kp+n),p\\mid g(kp-n+1)\\)，其中\\(k&gt;0\\).\r\n最终求\\(f(k^3)\\)时将两部分结果合并即可。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=2e6;ll v1[N+4],b[N+4],v2[N+4];int main()&#123;    for(int i=2;i&lt;=N+1;i++)&#123;        if(v1[i]==0)&#123;            for(int j=i;j&lt;=N+1;j+=i)                v1[j]=i;        &#125;    &#125;    for(int i=1;i&lt;=N;i++)        v1[i]=v1[i+1];    for(int i=1;i&lt;=N;i++)        b[i]=1ll*i*i-i+1;    for(int i=2;i&lt;=N;i++)&#123;        ll p=b[i];        if(p==1) continue;        for(ll j=i;j&lt;=N;j+=p)            while(b[j]%p==0)                b[j]/=p,v2[j]=max(v2[j],p);        for(ll j=p-i+1;j&lt;=N;j+=p)            while(b[j]%p==0)                b[j]/=p,v2[j]=max(v2[j],p);    &#125;    ll ans=0;    for(int i=1;i&lt;=N;i++)        ans+=max(v1[i],v2[i])-1;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 340","url":"/project-euler/340/","content":"\r\nProject Euler 340\r\n题目\r\nCrazy Function\r\nFor fixed integers \\(a, b, c\\),\r\ndefine the crazy function \\(F(n)\\) as follows:\r\n\\(F(n) = n - c\\) for all \\(n &gt; b\\)\r\n\\(F(n) = F(a + F(a + F(a + F(a +\r\nn))))\\) for all \\(n \\le b\\)\r\nAlso, define \\(S(a, b, c) =\r\n\\sum_{n=0}^{b}F(n)\\).\r\nFor example, if \\(a = 50, b = 2000\\)\r\nand \\(c = 40\\), then \\(F(0) = 3240\\) and \\(F(2000) = 2040\\). Also, \\(S(50, 2000, 40) = 5204240\\). Find the last\r\n\\(9\\) digits of \\(S(21^7, 7^{21}, 12^7)\\).\r\n解决方案\r\n本题主要依靠多次调整\\(a,b,c\\)的值，利用python来打印出函数的图像来推测\\(F\\)的表达式。\r\n用以下代码打印一部分的图像，以\\(a=12,b=30,c=7\\)为例打印\\(F\\)的形状：\r\nimport matplotlib.pyplot as plta, b, c = 12, 30, 7def f(n):    if n &gt; b:        return n - c    else:        return f(a + f(a + f(a + f(a + n))))X = [i for i in range(b + b)]Y = list(map(f, X))fig, ax = plt.subplots()ax.scatter(X, Y)plt.show()\r\n\r\n最终发现了以下一些特点：\r\n\r\n从\\(b\\)往前起，每\\(a\\)个点视作一块。在每一块的内部，函数值都是递增的，并且恰好为\\(1\\)。块内的和可以使用等差数列之和不难计算出来。\r\n从\\(b\\)往前起的每一块，对应函数值都会增长\\(3a-3c\\)。也就是说，\\(F(n)=b+4(a-c)\\)，那么\\(F(n-a)=b+(a-c),F(n-2a)=b-2(a-c),\\dots\\)，那么块间也是等差数列就可以计算得出。不过，最左边一块不是完整的一块，需要单独计算。\r\n\r\n以\\(b-a+1\\sim\r\nb\\)这一块开始，通过等差数列公式可以计算出\\(t_0=\\sum_{i=b-a+1}^b\r\nF(i)=\\dfrac{a(2b+7a-8c+1)}{2}\\)\r\n那么计算块间之和。可以发现一共有\\(m=\\left\\lfloor\\dfrac{b+1}{a}\\right\\rfloor\\)块，并且首项为\\(t_0\\)，公差为\\(a\\cdot(3a-3c)\\)。再次通过等差数列公式计算出这一些完整的块的\\(F\\)值之和。\r\n剩下的不完整的块中有\\((b+1)\\%a\\)个元素，单独计算即可。\r\n代码\r\na, b, c = 21 ** 7, 7 ** 21, 12 ** 7mod = 10 ** 9def cal(l, d, n):    return n * (l + l + (n - 1) * d) // 2block, res = divmod(b + 1, a)t0 = cal(b + 4 * (a - c), -1, a)ans = cal(t0, a * (3 * a - 3 * c), block)ans += cal(b + 4 * (a - c) + block * 3 * (a - c), -1, res)ans %= modprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 345","url":"/project-euler/345/","content":"\r\nProject Euler 345\r\n题目\r\nMatrix Sum\r\nWe define the Matrix Sum of a matrix as the maximum possible\r\nsum of matrix elements such that none of the selected elements share the\r\nsame row or column.\r\nFor example, the Matrix Sum of the matrix below equals \\(3315 ( = 863 + 383 + 343 + 959 +\r\n767)\\):\r\n\\[\\begin{matrix}\r\n  7 &amp;  53 &amp; 183 &amp; 439 &amp; \\color{lightgreen} {863} \\\\\r\n497 &amp; \\color{lightgreen} {383} &amp; 563 &amp;  79 &amp; 973 \\\\\r\n287 &amp;  63 &amp; \\color{lightgreen} {343} &amp; 169 &amp; 583 \\\\\r\n627 &amp; 343 &amp; 773 &amp; \\color{lightgreen} {959} &amp; 943 \\\\\r\n\\color{lightgreen} {767} &amp; 473 &amp; 103 &amp; 699 &amp; 303\r\n\\end{matrix}\\]\r\nFind the Matrix Sum of:\r\n\r\n\r\n\r\n7\r\n53\r\n183\r\n439\r\n863\r\n497\r\n383\r\n563\r\n79\r\n973\r\n287\r\n63\r\n343\r\n169\r\n583\r\n\r\n\r\n627\r\n343\r\n773\r\n959\r\n943\r\n767\r\n473\r\n103\r\n699\r\n303\r\n957\r\n703\r\n583\r\n639\r\n913\r\n\r\n\r\n447\r\n283\r\n463\r\n29\r\n23\r\n487\r\n463\r\n993\r\n119\r\n883\r\n327\r\n493\r\n423\r\n159\r\n743\r\n\r\n\r\n217\r\n623\r\n3\r\n399\r\n853\r\n407\r\n103\r\n983\r\n89\r\n463\r\n290\r\n516\r\n212\r\n462\r\n350\r\n\r\n\r\n960\r\n376\r\n682\r\n962\r\n300\r\n780\r\n486\r\n502\r\n912\r\n800\r\n250\r\n346\r\n172\r\n812\r\n350\r\n\r\n\r\n870\r\n456\r\n192\r\n162\r\n593\r\n473\r\n915\r\n45\r\n989\r\n873\r\n823\r\n965\r\n425\r\n329\r\n803\r\n\r\n\r\n973\r\n965\r\n905\r\n919\r\n133\r\n673\r\n665\r\n235\r\n509\r\n613\r\n673\r\n815\r\n165\r\n992\r\n326\r\n\r\n\r\n322\r\n148\r\n972\r\n962\r\n286\r\n255\r\n941\r\n541\r\n265\r\n323\r\n925\r\n281\r\n601\r\n95\r\n973\r\n\r\n\r\n445\r\n721\r\n11\r\n525\r\n473\r\n65\r\n511\r\n164\r\n138\r\n672\r\n18\r\n428\r\n154\r\n448\r\n848\r\n\r\n\r\n414\r\n456\r\n310\r\n312\r\n798\r\n104\r\n566\r\n520\r\n302\r\n248\r\n694\r\n976\r\n430\r\n392\r\n198\r\n\r\n\r\n184\r\n829\r\n373\r\n181\r\n631\r\n101\r\n969\r\n613\r\n840\r\n740\r\n778\r\n458\r\n284\r\n760\r\n390\r\n\r\n\r\n821\r\n461\r\n843\r\n513\r\n17\r\n901\r\n711\r\n993\r\n293\r\n157\r\n274\r\n94\r\n192\r\n156\r\n574\r\n\r\n\r\n34\r\n124\r\n4\r\n878\r\n450\r\n476\r\n712\r\n914\r\n838\r\n669\r\n875\r\n299\r\n823\r\n329\r\n699\r\n\r\n\r\n815\r\n559\r\n813\r\n459\r\n522\r\n788\r\n168\r\n586\r\n966\r\n232\r\n308\r\n833\r\n251\r\n631\r\n107\r\n\r\n\r\n813\r\n883\r\n451\r\n509\r\n615\r\n77\r\n281\r\n613\r\n459\r\n205\r\n380\r\n274\r\n302\r\n35\r\n805\r\n\r\n\r\n\r\n解决方案\r\n不难想到使用状态压缩动态规划来完成这题。\r\n令\\(N=15\\)。并将这些数存在一个开始下标为\\(0\\)的\\(N\\times\r\nN\\)大小的数组中。我们使用一个\\(N\\)位二进制数\\(st\\)来表示当前的列的使用情况。如果第\\(i\\)列被使用了，那么\\(st\\)的第\\(i\\)位为\\(1\\)，否则为\\(0\\)。并且令\\(c(st)\\)为\\(N\\)位二进制数\\(st\\)中\\(1\\)的位数。\r\n那么令状态\\(f(st)(0\\le\r\nst&lt;2^N)\\)为在前\\(c(st)\\)行中，已经使用了\\(st\\)表示的一部分列，目前的最大和。那么可以写出如下状态转移方程：\r\n\\[\r\nf(st)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0  &amp; &amp; \\text{if}\\quad st=0 \\\\\r\n  &amp;\\max_{i=0,st\\&amp;2^i&gt;0}^{N-1}\r\n\\{f(st\\oplus2^i)+a[c(st)-1][i]\\}&amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n对于每一个状态\\(st\\)，通过\\(c(st)\\)我们就已经确定了当前已经使用的行数，并从新的一行开始选择。最终，从前已经使用的\\(f(st\\oplus 2^i)\\)和现在要选择的\\(a[c(st)-1][i]\\)数相合并，就转移到了当前状态。\r\n最终答案为\\(f[2^N-1]\\)，注意\\(c(2^N-1)=N\\)，这说明\\(N\\)行都已经被选完了。\r\n另外一种方法则是通过改造求将这个问题转换成最小费用最大流问题，从而可以在多项式时间内解决。\r\n由于同一行下，每一列的元素都是互斥的，这让我们考虑使用网络流的思想解决。因此我们将每一行和每一列都用一个节点表示，假设行节点为\\(a_i\\)，列节点为\\(b_j\\)，那么为每个行节点\\(a_i\\)向列节点\\(b_j\\) 连一条费用为\\(-a[i][j]\\)（注意这里是负数，因为问题模型是最小费用），容量为\\(1\\)的边。添加一个源点\\(s\\)，指向所有行节点，容量为\\(1\\)，费用为\\(0\\)；再添加一个汇点\\(t\\)，将所有列节点指向\\(t\\)，同样容量为\\(1\\)，费用为\\(0\\)。\r\n最终执行完算法后，花费的费用最小，并且每一行，每一列都被用到。取反符号后即为答案。\r\n此处的代码将使用networkx库中的max_flow_min_cost方法完成。\r\n通过查看费用流的\\(N^2\\)条边的使用情况，还可以得知哪\\(N\\)个数被选上了。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N=15;int a[N][N]=&#123;  7, 53,183,439,863,497,383,563, 79,973,287, 63,343,169,583,627,343,773,959,943,767,473,103,699,303,957,703,583,639,913,447,283,463, 29, 23,487,463,993,119,883,327,493,423,159,743,217,623,  3,399,853,407,103,983, 89,463,290,516,212,462,350,960,376,682,962,300,780,486,502,912,800,250,346,172,812,350,870,456,192,162,593,473,915, 45,989,873,823,965,425,329,803,973,965,905,919,133,673,665,235,509,613,673,815,165,992,326,322,148,972,962,286,255,941,541,265,323,925,281,601, 95,973,445,721, 11,525,473, 65,511,164,138,672, 18,428,154,448,848,414,456,310,312,798,104,566,520,302,248,694,976,430,392,198,184,829,373,181,631,101,969,613,840,740,778,458,284,760,390,821,461,843,513, 17,901,711,993,293,157,274, 94,192,156,574, 34,124,  4,878,450,476,712,914,838,669,875,299,823,329,699,815,559,813,459,522,788,168,586,966,232,308,833,251,631,107,813,883,451,509,615, 77,281,613,459,205,380,274,302, 35,805&#125;;int f[1&lt;&lt;N];int main()&#123;    for(int s=1;s&lt;(1&lt;&lt;N);s++)&#123;        int c=__builtin_popcount(s)-1;        for(int i=0;i&lt;N;i++)&#123;            if(s&gt;&gt;i&amp;1)                f[s]=max(f[s],f[s^1&lt;&lt;i]+a[c][i]);        &#125;    &#125;    printf(&quot;%d\\n&quot;,f[(1&lt;&lt;N)-1]);&#125;\r\nimport networkx as nxa = [[7, 53, 183, 439, 863, 497, 383, 563, 79, 973, 287, 63, 343, 169, 583],     [627, 343, 773, 959, 943, 767, 473, 103, 699, 303, 957, 703, 583, 639, 913],     [447, 283, 463, 29, 23, 487, 463, 993, 119, 883, 327, 493, 423, 159, 743],     [217, 623, 3, 399, 853, 407, 103, 983, 89, 463, 290, 516, 212, 462, 350],     [960, 376, 682, 962, 300, 780, 486, 502, 912, 800, 250, 346, 172, 812, 350],     [870, 456, 192, 162, 593, 473, 915, 45, 989, 873, 823, 965, 425, 329, 803],     [973, 965, 905, 919, 133, 673, 665, 235, 509, 613, 673, 815, 165, 992, 326],     [322, 148, 972, 962, 286, 255, 941, 541, 265, 323, 925, 281, 601, 95, 973],     [445, 721, 11, 525, 473, 65, 511, 164, 138, 672, 18, 428, 154, 448, 848],     [414, 456, 310, 312, 798, 104, 566, 520, 302, 248, 694, 976, 430, 392, 198],     [184, 829, 373, 181, 631, 101, 969, 613, 840, 740, 778, 458, 284, 760, 390],     [821, 461, 843, 513, 17, 901, 711, 993, 293, 157, 274, 94, 192, 156, 574],     [34, 124, 4, 878, 450, 476, 712, 914, 838, 669, 875, 299, 823, 329, 699],     [815, 559, 813, 459, 522, 788, 168, 586, 966, 232, 308, 833, 251, 631, 107],     [813, 883, 451, 509, 615, 77, 281, 613, 459, 205, 380, 274, 302, 35, 805]     ]n = len(a)s = -1t = -2g = nx.DiGraph()for i in range(n):    for j in range(n):        g.add_edge(i, j + n, capacity=1, weight=-a[i][j])for i in range(n):    g.add_edge(s, i, capacity=1, weight=0)    g.add_edge(i + n, t, capacity=1, weight=0)ans = -nx.cost_of_flow(g, nx.max_flow_min_cost(g, s, t))print(ans)\r\n","categories":["Project Euler"],"tags":["动态规划","图论"]},{"title":"Project Euler 346","url":"/project-euler/346/","content":"\r\nProject Euler 346\r\n题目\r\nStrong Repunits\r\nThe number \\(7\\) is special, because\r\n\\(7\\) is \\(111\\) written in base \\(2\\), and \\(11\\) written in base \\(6\\) (i.e. \\(7_{10} = 11_{6} = 111_{2}\\)). In other\r\nwords, \\(7\\) is a repunit in at least\r\ntwo bases \\(b &gt; 1\\).\r\nWe shall call a positive integer with this property a strong repunit.\r\nIt can be verified that there are \\(8\\)\r\nstrong repunits below \\(50\\): \\(\\{1,7,13,15,21,31,40,43\\}\\).\r\nFurthermore, the sum of all strong repunits below \\(1000\\) equals \\(15864\\).\r\nFind the sum of all strong repunits below \\(10^{12}\\).\r\n解决方案\r\n不难发现，对于任意一个数\\(n&gt;2\\)，\\(n\\)都可以写成\\(n-1\\)进制下的\\(11_{n-1}\\)，因此\\(2\\)个\\(1\\)是普遍情况。\r\n那么，题目可以转化为求所有满足以下条件的数\\(n\\)之和：存在一个\\(b\\)，\\(n\\)在\\(b\\)进制下所有数位都是\\(1\\)，并且数位个数达到\\(3\\)以上。\r\n令\\(N=10^{12}\\)。因此考虑枚举\\(b\\)，使得\\(n=b^2+b+1,n\\le N\\)。在\\(b\\)进制下，当前有一个满足题目条件的答案\\(m\\)，令\\(m&#39;=mb+1\\)，那么就产生了比\\(m\\)多一位的答案\\(m&#39;\\)。由此枚举，最终产生所有答案。\r\n代码\r\nfrom itertools import countN = 10 ** 12st = set()for b in count(2, 1):    n = b * b + b + 1    if n &gt; N:        break    while n &lt;= N:        st.add(n)        n = n * b + 1ans = sum(st) + 1print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 348","url":"/project-euler/348/","content":"\r\nProject Euler 348\r\n题目\r\nSum of a square and a cube\r\nMany numbers can be expressed as the sum of a square and a cube. Some\r\nof them in more than one way.\r\nConsider the palindromic numbers that can be expressed as the sum of\r\na square and a cube, both greater than \\(1\\), in exactly \\(4\\) different ways.\r\nFor example, \\(5229225\\) is a\r\npalindromic number and it can be expressed in exactly \\(4\\) different ways:\r\n\\(\\begin{aligned}\r\n&amp; 2285^2 + 20^3\\\\\r\n&amp; 2223^2 + 66^3\\\\\r\n&amp; 1810^2 + 125^3\\\\\r\n&amp; 1197^2 + 156^3\\\\\r\n\\end{aligned}\\)\r\nFind the sum of the five smallest such palindromic numbers.\r\n解决方案\r\n本题的解决方式比直接。先从小到大生成\\(2\\)位以上的回文数，然后再通过枚举立方数，判断减去后的数是否为平方数即可。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;# include &quot;tools.h&quot;using namespace std;typedef long long ll;const int M=4,Q=5;ll rev(ll n)&#123;    ll s=0;    for(;n;n/=10) s=s*10+n%10;    return s;&#125;bool ok(ll n)&#123;    int cnt=0;    for(ll i=1;i*i*i&lt;=n;i++)        if(is_square(n-i*i*i)) ++cnt;    return cnt==M;&#125;ll ans=0;void solve()&#123;    int cnt=0;    for(ll l=1;;l*=10)&#123;        ll r=l*10;        for(ll i=l;i&lt;r;i++)&#123;            ll w=i*r+rev(i);            if(ok(w))&#123;                ans+=w;                ++cnt;if(cnt==Q) return;            &#125;        &#125;        for(ll i=l;i&lt;r;i++)&#123;            for(int j=0;j&lt;10;j++)&#123;                ll w=(i*10+j)*r+rev(i);                if(ok(w))&#123;                    ans+=w;                    ++cnt;if(cnt==Q) return;                &#125;            &#125;        &#125;    &#125;&#125;int main()&#123;    solve();    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 347","url":"/project-euler/347/","content":"\r\nProject Euler 347\r\n题目\r\nLargest integer\r\ndivisible by two primes\r\nThe largest integer \\(\\le 100\\) that\r\nis only divisible by both the primes \\(2\\) and \\(3\\) is \\(96\\), as \\(96=32*3=2^5*3\\).\r\nFor two distinct primes \\(p\\) and \\(q\\) let \\(M(p,q,N)\\) be the largest positive integer\r\n\\(\\le N\\) only divisible by both \\(p\\) and \\(q\\) and \\(M(p,q,N)=0\\) if such a positive integer\r\ndoes not exist.\r\nE.g. \\(M(2,3,100)=96\\).\r\n\\(M(3,5,100)=75\\) and not \\(90\\) because \\(90\\) is divisible by \\(2 ,3\\) and \\(5\\).\r\nAlso \\(M(2,73,100)=0\\) because there\r\ndoes not exist a positive integer \\(\\le\r\n100\\) that is divisible by both \\(2\\) and \\(73\\).\r\nLet \\(S(N)\\) be the sum of all\r\ndistinct \\(M(p,q,N)\\). \\(S(100)=2262.\\)\r\nFind \\(S(10 000 000)\\).\r\n解决方案\r\n根据分解质因数的思想可以知道，如果\\(p,q\\)有其中一个不相同，那么\\(M(p,q,N)\\)也不会相同。\r\n因此，令\\(N=10000000\\)，枚举所有的\\(p,q(p&lt; q)\\)使得\\(pq\\le N\\)。那么找到一对\\((x,y)\\)使得\\(p^xq^y\\le N\\)并且\\(p^xq^y\\)最大，那么\\(p^xq^y\\)便是其中一个答案。\r\n另外一个地方则是，质数只需要筛选到\\(\\dfrac{N}{2}\\)即可。因为枚举的\\((p,q)\\)中，\\(p\\)至少为\\(2\\)，那么\\(q\\)最多为\\(\\dfrac{N}{2}\\)。\r\n代码\r\nfrom tools import get_primeN = 10 ** 7pr = get_prime(N // 2)ans = 0for i in range(len(pr) - 1):    for j in range(i + 1, len(pr)):        if pr[i] * pr[j] &gt; N:            break        mx = 0        x = pr[i]        while x * pr[j] &lt;= N:            y = pr[j]            while x * y &lt;= N:                mx = max(mx, x * y)                y *= pr[j]            x *= pr[i]        ans += mxprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 349","url":"/project-euler/349/","content":"\r\nProject Euler 349\r\n题目\r\nLangton’s ant\r\nAn ant moves on a regular grid of squares that are coloured either\r\nblack or white.\r\nThe ant is always oriented in one of the cardinal directions (left,\r\nright, up or down) and moves from square to adjacent square according to\r\nthe following rules:\r\n\r\nif it is on a black square, it flips the colour of the square to\r\nwhite, rotates \\(90\\) degrees\r\ncounterclockwise and moves forward one square.\r\nif it is on a white square, it flips the colour of the square to\r\nblack, rotates \\(90\\) degrees clockwise\r\nand moves forward one square.\r\n\r\nStarting with a grid that is entirely white, how many squares are\r\nblack after \\(10^{18}\\) moves of the\r\nant?\r\n解决方案\r\n如果当前是从白色格子转成黑色格子，那么在序列中记录一个值\\(1\\)，如果是黑色格子，那么记录一个值\\(-1\\)。\r\n最终，记录的这些值之和就是黑色格子数。\r\n考虑直接模拟这只蚂蚁的行为。本代码打印了蚂蚁的前\\(m=20000\\)步数的踪迹，发现在第约\\(10000\\)步时，记录的这个序列开始循环，其周期为\\(T=104\\)，并且在每个周期中，黑色格子每次增加\\(12\\)个。\r\n那么，本题直接枚举\\(m\\)步以内的所有颜色变化情况，之后的所有部分通过周期直接分块计算即可。\r\n代码\r\nfrom collections import defaultdictN = 10 ** 18mp = defaultdict(int)dx, dy = [-1, 0, 1, 0], [0, -1, 0, 1]x, y, k = 0, 0, 0a = []m = 20000T = 104for i in range(m):    if mp[x, y] == 0:        k = (k - 1) &amp; 3        a.append(1)    else:        k = (k + 1) &amp; 3        a.append(-1)    mp[x, y] ^= 1    x += dx[k]    y += dy[k]# print(a) 查看前m步的颜色变化情况。ans = sum(a[:min(m, N)])N -= min(N, m)a = a[-T:]block, res = N // T, N % Tans += sum(a) * block + sum(a[:res])print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 351","url":"/project-euler/351/","content":"\r\nProject Euler 351\r\n题目\r\nHexagonal orchards\r\nA hexagonal orchard of order \\(n\\) is a triangular lattice made up of\r\npoints within a regular hexagon with side \\(n\\). The following is an example of a\r\nhexagonal orchard of order \\(5\\):\r\n\r\nHighlighted in green are the points which are hidden from the center\r\nby a point closer to it. It can be seen that for a hexagonal orchard of\r\norder \\(5, 30\\) points are hidden from\r\nthe center.\r\nLet \\(H(n)\\) be the number of points\r\nhidden from the center in a hexagonal orchard of order \\(n\\).\r\n\\(H(5) = 30.\\ H(10) = 138.\\ H(1 000) =\r\n1177848.\\)\r\nFind \\(H(100 000 000)\\).\r\n解决方案\r\n我们考虑将整个图形建立坐标系进行分析。\r\n以正右为\\(x\\)轴正方向，以\\(x\\)轴逆时针旋转\\(120°\\)的为\\(y\\)轴正方向，那么可以建立一个平面坐标系，每一个点都有一个整数的坐标。\r\n然后，将\\(y\\)轴顺时针旋转\\(30°\\)，所有的点的位置跟着变化，那么整个\\(5\\)阶六边形图像就变成了以下模样：\r\n\r\n其中，绿色是被遮挡的点。\r\n对于原来的六边形，由于六片中，每一片都是平等的，因此我们只考虑\\(x\\)轴逆时针旋转\\(60°\\)这一片的计算，而这一片在新的坐标中则对应着上图中蓝色三角形的那一部分，我们只考虑的点是\\((x,y)\\)，其中\\(1\\le y\\le x\\le n\\)。\r\n如果一个点\\((x,y)\\)被遮挡了，那么\\(\\gcd(x,y)&gt;1\\)，因为点\\(\\left(\\dfrac{x}{\\gcd(x,y)},\\dfrac{y}{\\gcd(x,y)}\\right)\\)一定在线段\\((0,0)-(x,y)\\)上。\r\n因此，计算出所有没有被遮挡的点，它们的个数为\r\n\\[\\sum_{i=1}^n\\sum_{j=1}^i[\\gcd(i,j)=1]=\\sum_{i=1}^n\\varphi(i)\\]\r\n其中，\\([]\\)表示示性函数，表示\\([]\\)里面的值是否为真，如果为真，那么值为\\(1\\)，否则值为\\(0\\)。\\(\\varphi\\)表示为欧拉函数。\r\n那么，蓝色三角形中未被遮挡的点的数量为\\(\\dfrac{n(n+1)}{2}-\\sum_{i=1}^n\\varphi(i)\\)。\r\n因此，\r\n\\[H(n)=3n(n+1)-6\\sum_{i=1}^n\\varphi(i)\\]\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=1e8;int pr[N+4],v[N+4],m=0;int phi[N+4];int main()&#123;    phi[1]=1;    for(int i=2;i&lt;=N;i++)&#123;        if(v[i]==0)&#123;            v[i]=i;phi[i]=i-1;pr[++m]=i;        &#125;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;N/i) break;            v[i*pr[j]]=pr[j];            phi[i*pr[j]]=phi[i]*(v[i]==pr[j]?pr[j]:pr[j]-1);        &#125;    &#125;    ll sum=0;    for(int i=1;i&lt;=N;i++)        sum+=phi[i];    sum = 1ll*N*(N+1)/2-sum;    ll ans=sum*6;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 35","url":"/project-euler/35/","content":"\r\nProject Euler 35\r\n题目\r\nCircular primes\r\nThe number, \\(197\\), is called a\r\ncircular prime because all rotations of the digits: \\(197, 971,\\) and \\(719\\), are themselves prime.\r\nThere are thirteen such primes below \\(100:\r\n2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79,\\) and \\(97\\).\r\nHow many circular primes are there below one million?\r\n解决方法\r\n除了\\(2\\)和\\(5\\)，容易知道，如果素数只要包含了数位\\(024568\\)，那么这些素数都不符合条件。因为经过循环移位后，这些数一定会变成\\(2\\)的倍数或者是\\(5\\)的倍数。\r\n因此，仅需将剩下的这些数一个个进行枚举判断。\r\n循环位移通过字符串直接进行操作。\r\n代码\r\nfrom tools import get_primeN = 10 ** 6pr = set(x for x in get_prime(N) if all(c not in str(x) for c in &quot;024568&quot;))def change(x: int):    s = str(x)    return int(s[-1] + s[:-1])ans = int(N &gt;= 2) + int(N &gt;= 3)for x in pr:    m = len(str(x))    ok = 1    for i in range(m):        if x not in pr:            ok = 0            break        x = change(x)    ans += okprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 353","url":"/project-euler/353/","content":"\r\nProject Euler 353\r\n题目\r\nRisky moon\r\nA moon could be described by the sphere \\(C(r)\\) with centre \\((0,0,0)\\) and radius \\(r\\).\r\nThere are stations on the moon at the points on the surface of \\(C(r)\\) with integer coordinates. The\r\nstation at \\((0,0,r)\\) is called North\r\nPole station, the station at \\((0,0,-r)\\) is called South Pole\r\nstation.\r\nAll stations are connected with each other via the shortest road on\r\nthe great arc through the stations. A journey between two stations is\r\nrisky. If \\(d\\) is the length of the\r\nroad between two stations, \\(\\left(\\dfrac{d}{\\pi r}\\right)^2\\) is a\r\nmeasure for the risk of the journey (let us call it the risk of the\r\nroad). If the journey includes more than two stations, the risk of the\r\njourney is the sum of risks of the used roads.\r\nA direct journey from the North Pole station to the South Pole\r\nstation has the length \\(\\pi r\\) and\r\nrisk 1. The journey from the North Pole station to the South Pole\r\nstation via \\((0,r,0)\\) has the same\r\nlength, but a smaller risk:\r\n\\[\r\n\\left(\\frac{\\frac{1}{2}\\pi r}{\\pi r}\\right)^2+\\left(\\frac{\\frac{1}{2}\\pi\r\nr}{\\pi r}\\right)^2=0.5\r\n\\]\r\nThe minimal risk of a journey from the North Pole station to the\r\nSouth Pole station on \\(C(r)\\) is \\(M(r)\\).\r\nYou are given that \\(M(7)=0.1784943998\\) rounded to 10 digits\r\nbehind the decimal point.\r\nFind \\(\\displaystyle{\\sum_{n=1}^{15}M(2^n-1)}\\).\r\nGive your answer rounded to \\(10\\)\r\ndigits behind the decimal point in the form \\(a.bcdefghijk\\).\r\n解决方案\r\n本解决方案参考了Thread的一些内容。\r\n基本思想是先枚举出球面上的点，然后将任意两点间的距离求出，把所有的点和边看成是一个无向图，然后使用单源最短路径算法Dijkstra算法求两个极点的最小风险距离。\r\n假设现在需要求\\(M(r)\\)的值，那么不失一般性，只考虑这些范围内的点\\((x,y,z)\\)的坐标：\\(0\\le x\\le y\\le r,0\\le z\\le\r\nR\\)。可以发现枚举量不大，直接枚举即可。\r\n为了方便两点距离的计算，考虑将整个球体向中间缩小到原来的\\(\\dfrac{1}{r}\\)，原来在\\((x,y,z)\\)上的点，缩放后位于\\(\\left(\\dfrac{x}{r},\\dfrac{y}{r},\\dfrac{z}{r}\\right)\\)。方便之处在于不再需要考虑球体本身的半径，例如：\r\n计算两点之间\\(A,B\\)的圆心角的距离时，如果把它们都看作是从原点射出的向量，那么此举就简化了向量夹角公式。它们的夹角就是\\(\\theta=\\cos^{-1}\\vec{a}\\cdot\\vec{b}\\).因为\\(|\\vec{a}|=|\\vec{b}|=1\\).那么，两个考察站之间的风险值就是\\(\\left(\\dfrac{\\theta}{\\pi}\\right)^2\\).\r\n注意本题采用的Dijkstra算法不使用堆优化，因为这个图是稠密图（甚至是完全图）。如果使用了堆优化那么时间复杂度反而会更差。\r\n接下来通过下图说明：一条最优的路径是和赤道对称的。\r\n\r\n假设\\(d(A,B)\\)表示两个考察站的点之间的最小风险距离，并假设\\(N\\)是北极点，\\(S\\)是南极点，\\(A,B\\)是北半球的任意两个点，\\(A&#39;,B&#39;\\)则是它们对应在南半球的对称点，并且，\\(AA&#39;\\)和\\(BB&#39;\\)中间不存在其它点。\r\n假设\\(N\\rightarrow A\\rightarrow\r\nB&#39;\\rightarrow\r\nS\\)是一条的非对称的最优路径，那么由对称性可以知道，\\(N\\rightarrow B\\rightarrow A&#39;\\rightarrow\r\nS\\)也是一条最优路径。那么这两条最优路径在赤道上必定相交于一点，设为\\(C\\).\r\n那么第一条最优路径可以看成是\\(N\\rightarrow\r\nA\\rightarrow (C\\rightarrow) B \\rightarrow N\\)。注意\\(C\\)不一定是一个存在的点，故有这种表示方法。此时这种走法的距离将会远于\\(N\\rightarrow A\\rightarrow (O_A\\rightarrow )\r\nA\\rightarrow N\\).\r\n因此，如果当前走到\\(A\\)点时，跨过赤道到达\\(A&#39;\\)后，整条路径的长度就是\\(2\\cdot d(N,A)+\\left(\\dfrac{\\cos\r\n\\vec{a}\\cdot\\vec{a&#39;}}{\\pi}\\right)^2\\).最终结果取这些路径的最小值即可。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;double pi=acos(-1);const int N=15;struct P&#123;    double x,y,z,d;    void update(P &amp;p)&#123;        double r=acos(x*p.x+y*p.y+z*p.z);        d=min(d,p.d+r*r);    &#125;    double rev()&#123;        double r=acos(x*x+y*y-z*z);        return r*r+d*2;    &#125;&#125;;double solve(int r)&#123;    vector&lt;P&gt;v;    int r2=r*r;    for(int x=0;x*x&lt;=r2;x++)        for(int y=x;x*x+y*y&lt;=r2;y++)&#123;            int z2=r2-x*x-y*y;            int z=sqrt(z2);            if(z*z==z2)                v.push_back(P&#123;1.0*x/r,1.0*y/r,1.0*z/r,z==r?0:1e9&#125;);        &#125;    double ans=1e9;    int n=v.size();    for(int i=n-1;i&gt;=0;i--)&#123;        int k=0;        for(int j=0;j&lt;=i;j++)            if(v[k].d&gt;v[j].d) k=j;        swap(v[i],v[k]);        ans=min(ans,v[i].rev());        for(int j=0;j&lt;i;j++)            v[j].update(v[i]);    &#125;    return ans/pi/pi;&#125;int main()&#123;    double ans=0;    for (int i=1;i&lt;=N;i++) &#123;        double w=solve((1&lt;&lt;i)-1);        ans+=w;    &#125;    printf(&quot;%.10f\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 355","url":"/project-euler/355/","content":"\r\nProject Euler 355\r\n题目\r\nMaximal coprime subset\r\nDefine \\(Co(n)\\) to be the maximal\r\npossible sum of a set of mutually co-prime elements from \\(\\{1, 2, \\dots, n\\}\\).\r\nFor example \\(Co(10)\\) is \\(30\\) and hits that maximum on the subset\r\n\\(\\{1, 5, 7, 8, 9\\}\\).\r\nYou are given that \\(Co(30) = 193\\)\r\nand \\(Co(100) = 1356\\).\r\nFind \\(Co(200000)\\).\r\n解决方案\r\n令\\(N=200000\\)，令函数\\(f(n,p)\\)表示求\\(p\\)最大的质数幂\\(p^k\\le n\\)。\r\n本题基于这个假设完成：被选上集合的数\\(n\\)，必定是以下两类数之一：\r\n\r\n\\(f(n,p)\\).对于\\(N\\)以内的任何一个质数\\(p\\)。\r\n\\(f\\left(\\left\\lfloor\\dfrac{n}{q}\\right\\rfloor,p\\right)\\cdot\r\nq\\)，其中\\(p\\)是一个质数，\\(q\\)是一个大于\\(\\lfloor\\sqrt{N}\\rfloor\\)的质数。\r\n\r\n如果质数\\(p,q\\)构造出了候选答案的第二类数，那么其它第二类数必定不能含有\\(p,q\\)这两个质因子，因此我们可以将其转化成最小费用最大流问题来解决。一开始我们先假设候选答案中只有第一类数，其总和为\\(s\\)，往后再逐渐添加第二类数。\r\n假设小于等于\\(\\lfloor\\sqrt{N}\\rfloor\\)的质数为集合\\(P\\)，其余质数为集合\\(Q\\)。对于\\(p\\in\r\nP,q \\in Q\\)，如果\\(f\\left(\\left\\lfloor\\dfrac{n}{q}\\right\\rfloor,p\\right)\\cdot\r\np&gt;f(n,p)+q\\)，那么从节点\\(p\\)到节点\\(q\\)连一条容量为\\(1\\)，费用为\\(-\\left(f\\left(\\left\\lfloor\\dfrac{n}{q}\\right\\rfloor,p\\right)\\cdot\r\np-f(n,p)-q\\right)\\)的边。那么，将源点连向\\(P\\)中的每个节点，将\\(Q\\)中的每个节点连向汇点，这些边的容量都为\\(1\\)，费用都为\\(0\\)。\r\n最终使用networkx库中的max_flow_min_cost方法完成计算。将答案添加到\\(s\\)中，成为最终答案。需要注意的是，我们求的费用是最大值，因此整张图的费用权值都是负数。\r\n代码\r\nfrom tools import get_primeimport networkx as nxN = 200000def cal(n, p):    m = 1    while m * p &lt;= n:        m *= p    return mpr = get_prime(N)g = nx.DiGraph()ans = 1st, ed = [], []s, t = -1, -2for p in pr:    ans += cal(N, p)    if p ** 2 &lt;= N:        g.add_edge(s, p, capacity=1, weight=0)        st.append(p)    elif p + p &lt;= N:        g.add_edge(p, t, capacity=1, weight=0)        ed.append(p)for p in st:    for q in ed:        if p * q &gt; N:            break        k = cal(N // q, p) * q        if cal(N, p) + q &lt; k:            g.add_edge(p, q, capacity=1, weight=-(k - cal(N, p) - q))ans += -nx.cost_of_flow(g, nx.max_flow_min_cost(g, s, t))print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 357","url":"/project-euler/357/","content":"\r\nProject Euler 357\r\n题目\r\nPrime generating integers\r\nConsider the divisors of \\(30:\r\n1,2,3,5,6,10,15,30\\). It can be seen that for every divisor \\(d\\) of \\(30\\), \\(d+30/d\\) is prime.\r\nFind the sum of all positive integers \\(n\\) not exceeding \\(100 000 000\\) such that for every divisor\r\n\\(d\\) of \\(n\\), \\(d+n/d\\) is prime.\r\n解决方案\r\n如果一个数\\(n\\)满足题目要求，那么\\(n\\)一定满足以下条件。\r\n\r\n\\(n+1\\)一定是一个质数（因为每个数都有因子\\(1\\)，有\\(n+1=\\dfrac{n}{1}+1\\)）\r\n\\(n\\)是一个无平方因子数，如果存在一个质因子\\(p\\)，使得\\(p^2\\mid n\\)，那么\\(p+\\left(\\dfrac{n}{p}\\right)=p\\cdot\\left(1+\\dfrac{n}{p^2}\\right)\\)，那么此时的\\(p+\\dfrac{n}{p}\\)不是质数。\r\n\r\n对于这些满足条件的数，直接枚举它们的因数，判断答案合法性即可。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=100000000;int v[N+4],pr[N],m=0;bool is_square_free[N+4];bool ok(int x)&#123;    for(int i=1;i*i&lt;=x;i++)    if(x%i==0)&#123;        int w=i+x/i;        if(v[w]!=w) return 0;    &#125;    return 1;&#125;int main()&#123;    for(int i=2;i&lt;=N+1;i++)&#123;        if(v[i]==0) v[i]=i,pr[++m]=i,is_square_free[i]=1;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;(N+1)/i) break;            v[i*pr[j]]=pr[j];            is_square_free[i*pr[j]]=(v[i]==pr[j]?0:is_square_free[i]);        &#125;    &#125;    ll ans=1;    for(int i=2;i&lt;=m;i++)&#123;        int x=pr[i]-1;        if(is_square_free[x]&amp;&amp;ok(x)) ans+=x;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 358","url":"/project-euler/358/","content":"\r\nProject Euler 358\r\n题目\r\nCyclic numbers\r\nA cyclic number with \\(n\\) digits has a very interesting\r\nproperty:\r\nWhen it is multiplied by \\(1, 2, 3, 4,\r\n\\dots n\\), all the products have exactly the same digits, in the\r\nsame order, but rotated in a circular fashion!\r\nThe smallest cyclic number is the \\(6\\)-digit number \\(142857\\) :\r\n\\(\\begin{aligned}\r\n142857 \\times 1 = 142857\\\\\r\n142857 \\times 2 = 285714\\\\\r\n142857 \\times 3 = 428571\\\\\r\n142857 \\times 4 = 571428\\\\\r\n142857 \\times 5 = 714285\\\\\r\n142857 \\times 6 = 857142\r\n\\end{aligned}\\)\r\nThe next cyclic number is \\(0588235294117647\\) with \\(16\\) digits :\r\n\\(\\begin{aligned}\r\n&amp;0588235294117647 \\times 1 = 0588235294117647\\\\\r\n&amp;0588235294117647 \\times 2 = 1176470588235294\\\\\r\n&amp;0588235294117647 \\times 3 = 1764705882352941\\\\\r\n&amp;\\dots\\\\\r\n&amp;0588235294117647 \\times 16 = 9411764705882352\\\\\r\n\\end{aligned}\\)\r\nNote that for cyclic numbers, leading zeros are important.\r\nThere is only one cyclic number for which, the eleven leftmost digits\r\nare \\(00000000137\\) and the five\r\nrightmost digits are \\(56789\\) (i.e.,\r\nit has the form \\(00000000137\\dots56789\\) with an unknown\r\nnumber of digits in the middle). Find the sum of all its digits.\r\n解决方案\r\n本解决方案参考了循环数页面的部分内容。\r\n循环数和以质数为分母的分数单位\\(\\dfrac{1}{p}\\)息息相关。在\\(b\\)进制下，如果分数\\(\\dfrac{1}{p}\\)以小数形式的循环节长度为\\(p-1\\)，那么\\(\\dfrac{1}{p}\\)的前\\(p-1\\)位小数组合起来就是一个\\(b\\)进制下的循环数。\r\n此外还提到，如果\\(\\dfrac{1}{p}\\)在\\(b\\)进制下的循环节长度为\\(p-1\\)，那么\\(b\\)是群\\(\\mathbb{Z}_p^{\\star}\\)的原根。\r\n最终，通过一个质数\\(p\\)和一个满足条件的进制数\\(b\\)，可以构造出一个循环数\\(c(b,p)=\\dfrac{b^{p-1}-1}{p}\\).假设进制\\(b\\)为\\(10\\)，那么\\(f(b,p)\\cdot p\\)恰好为\\(b^{p-1}-1\\)，数位和为\\(9(p-1)\\)。分拆\\(f(b,p)\\cdot\r\np=f(b,p)+f(b,p)\\cdot(p-1)\\)，注意到这两个数\\(f(b,p)\\)实际上是\\(f(b,p)\\cdot(p-1)\\)的数位逆序，因此这两个数相等，最终循环数\\(f(b,p)\\)的数位和是\\(\\dfrac{(b-1)(p-1)}{2}\\).\r\n由于这个数的开头是\\(00000000137\\)，那么所需要寻找的质数\\(p\\)满足\\(0.00000000137\\le\\dfrac{1}{p}&lt;0.00000000138\\).在这个范围内进行寻找。\r\n为了加速程序运行，质数判断和原根判断是最慢的两个过程，应该放在后面判断。我们假设目前枚举出来的数\\(p\\)是个质数，那么根据\\(f(n,p)\\cdot p=b^{p-1}-1\\)，判断\\(p\\)是否满足\\(56789\\cdot\r\np\\%10^5=10^5-1\\)，如果是那么再进行剩下两个过程的判断。另外一方面，通过第一个判断的概率非常小，这足以让程序能够快速运行。\r\n代码\r\nfrom math import floor, ceilfrom sympy import is_primitive_rootfrom tools import phi, is_primeleft = &quot;00000000137&quot;right = &quot;56789&quot;val = float(&quot;0.&quot; + left)ed = floor(1 / val)val += 10 ** -len(left)st = ceil(1 / val)right_v = int(right)mod = 10 ** len(right)mod_1 = mod - 1ph = phi(mod)p = st - 1for p in range(st | 1, ed + 1, 2):    if right_v * p % mod == mod_1 and is_prime(p) and is_primitive_root(10, p):        ans = (p - 1) // 2 * 9        breakprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 363","url":"/project-euler/363/","content":"\r\nProject Euler 363\r\n题目\r\nBézier Curves\r\nA cubic Bézier curve is defined by four points: \\(P_0, P_1, P_2,\\) and \\(P_3\\).\r\n\r\nThe curve is constructed as follows:\r\nOn the segments \\(P_0 P_1\\), \\(P_1 P_2\\), and \\(P_2 P_3\\) the points \\(Q_0, Q_1,\\) and \\(Q_2\\) are drawn such that \\(\\dfrac{P_0 Q_0}{P_0 P_1} = \\dfrac{P_1 Q_1}{P_1\r\nP_2} = \\dfrac{P_2 Q_2}{P_2 P_3} = t\\), with \\(t\\) in \\([0,\r\n1]\\).\r\nOn the segments \\(Q_0 Q_1\\) and\r\n\\(Q_1 Q_2\\) the points \\(R_0\\) and \\(R_1\\) are drawn such that\r\n\\(\\dfrac{Q_0 R_0}{Q_0 Q_1} = \\dfrac{Q_1\r\nR_1}{Q_1 Q_2} = t\\) for the same value of \\(t\\).\r\nOn the segment \\(R_0 R_1\\) the point\r\n\\(B\\) is drawn such that \\(\\dfrac{R_0 B}{R_0 R_1} = t\\) for the same\r\nvalue of \\(t\\).\r\nThe Bézier curve defined by the points \\(P_0, P_1, P_2, P_3\\) is the locus of \\(B\\) as \\(Q_0\\) takes all possible positions on the\r\nsegment \\(P_0 P_1\\). (Please note that\r\nfor all points the value of \\(t\\) is\r\nthe same.)\r\nFrom the construction it is clear that the Bézier curve will be\r\ntangent to the segments \\(P_0 P_1\\) in\r\n\\(P_0\\) and \\(P_2 P_3\\) in \\(P_3\\).\r\nA cubic Bézier curve with \\(P_0 = (1, 0),\r\nP_1 = (1, v), P_2 = (v, 1),\\) and \\(P_3\r\n= (0, 1)\\) is used to approximate a quarter circle.\r\nThe value \\(v \\gt 0\\) is chosen such\r\nthat the area enclosed by the lines \\(O P_0,\r\nOP_3\\) and the curve is equal to \\(\\dfrac{\\pi}{4}\\) (the area of the quarter\r\ncircle).\r\nBy how many percent does the length of the curve differ from the\r\nlength of the quarter circle?\r\nThat is, if \\(L\\) is the length of\r\nthe curve, calculate \\(100 \\times \\dfrac{L -\r\n\\frac{\\pi}{2}}{\\frac{\\pi}{2}}\\)\r\nGive your answer rounded to \\(10\\)\r\ndigits behind the decimal point.\r\n解决方案\r\n这个页面给出了这条三次贝塞尔曲线的参数方程：\r\n\\[{\\displaystyle \\mathbf {B} (t)=\\mathbf\r\n{P} _{0}(1-t)^{3}+3\\mathbf {P} _{1}t(1-t)^{2}+3\\mathbf {P}\r\n_{2}t^{2}(1-t)+\\mathbf {P} _{3}t^{3}{,}t\\in [0,1]}\\]\r\n那么化简后，得到关于\\(x,y\\)的参数方程：\r\n\\[\\begin{aligned}\r\nx(t)&amp;=(1-t)^3+3t(1-t)^2+3t^2(1-t)v\\\\\r\ny(t)&amp;=3t(1-t)^2v+3t^2(1-t)+t^3\r\n\\end{aligned}\\]\r\n第一个问题：如何求贝塞尔曲线\\(B\\)和线段\\(C:P_3O,D:OP_0)\\)共同围绕而成的封闭曲线的面积？\r\n使用补线法进行计算，可以列出公式为：\r\n\\[\\dfrac{\\pi}{4}=S=\\dfrac{1}{2}\\int_{B+C+D}xdy-ydx\\]\r\n注意线段\\(B\\)和线段\\(C\\)的积分值都为\\(0\\)，那么只需要计算\\(\\dfrac{1}{2}\\int_Bxdy-ydx\\)即可。\r\n\\[\\dfrac{1}{2}(1+\\dfrac{6v}{5}-\\dfrac{3v^2}{10})=\\dfrac{\\pi}{4}\\]\r\n解这个一元二次方程，得到\\(v=2\\pm\\sqrt{\\dfrac{1}{3}(22-5\\pi)}\\)。\r\n由于按照题目的需要，它是一个\\(\\dfrac{1}{4}\\)圆的近似，因此取\\(v=2-\\sqrt{\\dfrac{1}{3}(22-5\\pi)}\\)\r\n第二个问题：如何求曲线的长度？\r\n\\[d_{P_0P_3}=\\int_0^1\\sqrt{x&#39;^2(t)+y&#39;^2(t)}dt\\]\r\n通过Mathematica直接计算出具体值即可。\r\n代码\r\nx[t_] = (1 - t)^3 + 3 t (1 - t)^2 + 3 t^2 (1 - t) vy[t_] = 3 t (1 - t)^2 v + 3 t^2 (1 - t) + t^3sol = First[Solve[1/2 (Integrate[x[t] y&#x27;[t] - y[t] x&#x27;[t], &#123;t, 0, 1&#125;]) == Pi/4, v]]L = NIntegrate[Sqrt[x&#x27;[t]^2 + y&#x27;[t]^2 /. sol], &#123;t, 0, 1&#125;]ans = 100*(L - Pi/2)/(Pi/2)\r\n","categories":["Project Euler"]},{"title":"Project Euler 359","url":"/project-euler/359/","content":"\r\nProject Euler 359\r\n题目\r\nHilbert’s New Hotel\r\nAn infinite number of people (numbered \\(1,\r\n2, 3,\\) etc.) are lined up to get a room at Hilbert’s newest\r\ninfinite hotel. The hotel contains an infinite number of floors\r\n(numbered \\(1, 2, 3,\\) etc.), and each\r\nfloor contains an infinite number of rooms (numbered \\(1, 2, 3,\\) etc.).\r\nInitially the hotel is empty. Hilbert declares a rule on how the n^th\r\nperson is assigned a room: person n gets the first vacant room in the\r\nlowest numbered floor satisfying either of the following:\r\n\r\nthe floor is empty\r\nthe floor is not empty, and if the latest person taking a room in\r\nthat floor is person m, then m + n is a perfect square\r\n\r\nPerson \\(1\\) gets room \\(1\\) in floor \\(1\\) since floor \\(1\\) is empty. Person \\(2\\) does not get room \\(2\\) in floor \\(1\\) since \\(1 + 2\r\n= 3\\) is not a perfect square. Person \\(2\\) instead gets room \\(1\\) in floor \\(2\\) since floor \\(2\\) is empty. Person \\(3\\) gets room \\(2\\) in floor \\(1\\) since \\(1 + 3\r\n= 4\\) is a perfect square.\r\nEventually, every person in the line gets a room in the hotel.\r\nDefine \\(P(f, r)\\) to be \\(n\\) if person \\(n\\) occupies room \\(r\\) in floor \\(f\\), and \\(0\\) if no person occupies the room. Here\r\nare a few examples:\r\n\\(\\begin{aligned}\r\n&amp;P(1, 1) = 1\\\\\r\n&amp;P(1, 2) = 3\\\\\r\n&amp;P(2, 1) = 2\\\\\r\n&amp;P(10, 20) = 440\\\\\r\n&amp;P(25, 75) = 4863\\\\\r\n&amp;P(99, 100) = 19454\r\n\\end{aligned}\\)\r\nFind the sum of all \\(P(f, r)\\) for\r\nall positive \\(f\\) and \\(r\\) such that \\(f\r\n\\times r = 71328803586048\\) and give the last \\(8\\) digits as your answer.\r\n解决方案\r\n通过暴力枚举前几项，可以在OEIS查询到结果为A083362。\r\n找到FORMULA一栏，给出了如下信息：\r\nT(0, k) = (k+1)*(k+2)/2 for k&gt;=0, T(n, 0) = floor((n+1)^2/2) for n&gt;0, T(n, k+1) = (2*floor((n+1)/2) + k+1)^2 - T(n, k) for n&gt;0 and k&gt;=0.\r\n这些信息给出的公式是以\\(0\\)为初始下标的。转化成以\\(1\\)为初始下标后，有\r\n\\[\r\np(f,r)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;\\dfrac{r(r+1)}{2}  &amp; &amp; \\text{if}\\quad f=1 \\\\\r\n  &amp;\\left\\lfloor\\dfrac{f^2}{2}\\right\\rfloor &amp; &amp; \\text{else\r\nif}\\quad f&gt;1\\land r=1 \\\\\r\n  &amp;\\left(2\\cdot\\left\\lfloor\\dfrac{f}{2}\\right\\rfloor+r-1\\right)^2-p(f,r-1)\r\n&amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n可以看到第三条式子是一个递推式，为了加速计算的过程，我们考虑将它改写成通式。\r\n通过Mathematica输入以下代码：\r\nRSolve[&#123;p[r] + p[r - 1] == (2*Floor[f/2] + r - 1)^2, p[1] == Floor[f^2/2]&#125;, p[r], r]\r\n运行后得出一个很长的式子。经过化简，得到通项公式：\r\n\\[\r\np(f,r)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;\\dfrac{r(r+1)}{2} &amp; &amp; \\text{if}\\quad f=1 \\\\\r\n  &amp;\\dfrac{r(r-1)}{2}\r\n+\\left\\lfloor\\dfrac{f}{2}\\right\\rfloor\\cdot\\left(\\left\\lfloor\\dfrac{f}{2}\\right\\rfloor+r-(r+f)\\%2\\right)&amp;\r\n&amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n直接进行计算即可。\r\n代码\r\nfrom tools import divisorsN = 71328803586048mod = 10 ** 9def P(f, r):    if f == 1:        return r * (r + 1) // 2    else:        return r * (r - 1) // 2 + f // 2 * (f // 2 + r - (r + f) % 2) * 2ans = sum(P(d, N // d) for d in divisors(N)) % modprint(ans)\r\n","categories":["Project Euler"],"tags":["OEIS"]},{"title":"Project Euler 36","url":"/project-euler/36/","content":"\r\nProject Euler 36\r\n题目\r\nDouble-base palindromes\r\nThe decimal number, \\(585 =\r\n1001001001_2\\) (binary), is palindromic in both bases.\r\nFind the sum of all numbers, less than one million, which are\r\npalindromic in base \\(10\\) and base\r\n\\(2\\).\r\n(Please note that the palindromic number, in either base, may not\r\ninclude leading zeros.)\r\n解决方案\r\n先枚举所有的二进制回文数，再判断其是否为十进制回文数。枚举的过程中，需要分开来考虑生成偶数长度的回文数和奇数长度的回文数。\r\n这将只需要枚举\\(O(\\sqrt\r\nN)\\)级别数量的数。\r\n代码\r\nN = 10 ** 6def gen(n):    s = bin(n)[2:]    t = s[::-1]    return int(s + t, 2), int(s + &#x27;0&#x27; + t, 2), int(s + &#x27;1&#x27; + t, 2)M = int(N ** 0.5) + 4ans = int(N &gt; 1)for i in range(1, M):    ls = gen(i)    for x in ls:        s = str(x)        if x &lt; N and s == s[::-1]:            ans += xprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 364","url":"/project-euler/364/","content":"\r\nProject Euler 364\r\n题目\r\nComfortable distance\r\nThere are \\(N\\) seats in a row.\r\n\\(N\\) people come after each other to\r\nfill the seats according to the following rules:\r\n\r\nIf there is any seat whose adjacent seat(s) are not occupied take\r\nsuch a seat.\r\nIf there is no such seat and there is any seat for which only one\r\nadjacent seat is occupied take such a seat.\r\nOtherwise take one of the remaining available seats.\r\n\r\nLet \\(T(N)\\) be the number of\r\npossibilities that \\(N\\) seats are\r\noccupied by \\(N\\) people with the given\r\nrules. The following figure shows \\(T(4)=8\\).\r\n\r\nWe can verify that \\(T(10) = 61632\\)\r\nand \\(T(1 000) \\bmod 100 000 007 =\r\n47255094\\).\r\nFind \\(T(1 000 000) \\bmod 100 000\r\n007\\).\r\n解决方案\r\n题目中的第\\(1\\)轮的占座位过程完成后，相邻的两个被占座位距离要么间隔\\(1\\)个空座位，要么间隔\\(2\\)个空座位。我们考虑第\\(1\\)步占座完成后的情形。\r\n由于第\\(1\\)个座位和第\\(n\\)个空座位比较特殊，因此首先进行考虑。在第\\(1\\)轮完成后，要么第\\(1\\)座位占了，要么第\\(2\\)个座位被占了；同理，要么第\\(n\\)个座位被占了，要么第\\(n-1\\)个座位被占了。\r\n假设\\(h\\in\\{0,1,2\\}\\)是第一轮结束后，第\\(1\\)个和第\\(n\\)个是空座位的个数，这\\(h\\)个座位将在第\\(2\\)轮占座位过程中被占用。排除这一特殊的部分后，假设\\(m\\)是长度\\(1\\)的空隙数，\\(k\\)是长度\\(2\\)的空隙数，那么\\(n,m,h,k\\)就满足这个关系：\\(m+2k+(m+k+1)=n-h\\)，化简后，得到\\(m=\\dfrac{n-h-1-3k}{2}\\)。\r\n固定\\(h\\)后，枚举\\(k\\)，枚举过程需要检验\\(k\\)以保证\\(m\\)计算出来后是一个整数。假设\\(f(n,h)\\)为考虑好特殊的\\(h\\)个座位后，不同的入座顺序后，那么\\(f(n,h)\\)可以写成：\r\n\\[f(n,h)=\\sum_{2m+3k=n-h-1}\r\n\\dbinom{m+k}{m} \\cdot (m+k+1)!\\cdot(k+h)!\\cdot\r\n2^{k}\\cdot(k+m)!\\]\r\n枚举给定的\\(k\\)后，中间的\\(m\\)个\\(1\\)空隙和\\(k\\)个\\(2\\)空隙不同的安排顺序有\\(\\dbinom{m+k}{m}\\)种；接下来第\\(1\\)轮占座的人对\\((m+k+1)\\)个间隔进行占座，有\\((m+k+1)!\\)种方式，第\\(1\\)轮结束后，一排座位被切分成多个空隙；第\\(2\\)轮将对\\(2\\)空隙和\\(h\\)个座位进行占用，但是\\(2\\)空隙在第\\(2\\)轮只能占用一个，因此有\\((k+h)!\\cdot2^k\\)种；第\\(3\\)轮则将第\\(2\\)轮中\\(2\\)空隙的另一个位置和\\(1\\)空隙全部占满，一共有\\((k+m)!\\)种。\r\n最终\\(T(n)=f(n,0)+2f(n,1)+f(n,2)\\).\r\n为了方便求模\\(p\\)中\\(1\\sim\r\nN\\)的逆元，有一种线性求出这些值的逆元的方法：假设目前要求\\(i\\)的逆元\\(i^{-1}\\%p\\)，那么\r\n设\\(q=\\left\\lfloor\\dfrac{p}{i}\\right\\rfloor,r=p\\%i\\)，那么可以写成\\(p=qi+r\\)，也就是\\(qi+r\\equiv 0\\pmod p\\)，即\\(r\\equiv -qi\\pmod p\\).\r\n两边同时除以\\(ir\\)，那么有\\(i^{-1}\\equiv -q\\cdot r^{-1}\\pmod p\\).\r\n最终将\\(q=\\left\\lfloor\\dfrac{p}{i}\\right\\rfloor,r=p\\%i\\)回代到上式，那么得到\\(i^{-1}\\equiv-\\left\\lfloor\\dfrac{p}{i}\\right\\rfloor\\cdot(p\\%i)^{-1}\\pmod\r\np\\).\r\n因此，将\\(i\\)从\\(1\\)到\\(N\\)按顺序求解即得到逆元。\r\n将\\(T(n)\\)前一部分数在OEIS中查询，结果为A192008。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=1000000;ll fac[N+4],inv[N+4],finv[N+4],pw2[N+4],mod=1e8+7;ll C(int n,int m)&#123;    return fac[n]*finv[n-m]%mod*finv[m]%mod;&#125;ll f(int n,int h)&#123;    ll ans=0;    for(int k=0;3*k&lt;=n-1-h;k++)&#123;        int m=n-1-h-3*k;        if(m&amp;1) continue;        m&gt;&gt;=1;        ans=(ans+fac[m+k+1]*C(m+k,m)%mod*pw2[k]%mod*fac[k+h]%mod*fac[k+m])%mod;    &#125;    return ans;&#125;ll T(int N)&#123;    return (f(N,0)+f(N,1)*2+f(N,2))%mod;&#125;int main()&#123;    fac[0]=fac[1]=inv[1]=finv[0]=finv[1]=pw2[0]=1;    pw2[1]=2%mod;    for(int i=2;i&lt;=N;i++)&#123;        fac[i]=fac[i-1]*i%mod;        inv[i]=(mod-mod/i)*inv[mod%i]%mod;        finv[i]=finv[i-1]*inv[i]%mod;        pw2[i]=pw2[i-1]*2%mod;    &#125;    printf(&quot;%lld\\n&quot;,T(N));&#125;\r\n","categories":["Project Euler"],"tags":["OEIS"]},{"title":"Project Euler 37","url":"/project-euler/37/","content":"\r\nProject Euler 37\r\n题目\r\nTruncatable primes\r\nThe number \\(3797\\) has an\r\ninteresting property. Being prime itself, it is possible to continuously\r\nremove digits from left to right, and remain prime at each stage: \\(3797, 797, 97,\\) and \\(7\\).\r\nSimilarly we can work from right to left: \\(3797\\), \\(379\\), \\(37\\), and \\(3\\).\r\nFind the sum of the only eleven primes that are both truncatable from\r\nleft to right and right to left.\r\nNOTE: \\(2, 3, 5,\\) and \\(7\\) are not considered to be truncatable\r\nprimes.\r\n解决方案\r\n和35题类似，如果素数的只要包含了数位\\(0468\\)，或者非最高位包含了\\(25\\)，那么这些素数都不符合条件。因为经过截断之后，这些数一定会变成\\(2\\)的倍数或者是\\(5\\)的倍数。\r\n因此，仅需将剩下的这些数一个个进行枚举判断。\r\n截断通过字符串直接进行操作。\r\n代码\r\nfrom tools import get_primeN = 1000000pr = &#123;x for x in &#123;x for x in get_prime(N) if all(c not in str(x) for c in &quot;0468&quot;)&#125; if all(c not in str(x)[1:] for c in &quot;25&quot;)&#125;ans = 0for x in pr:    if x &lt; 10:        continue    s = str(x)    m = len(s)    ok = True    for i in range(1, m):        if int(s[:i]) not in pr or int(s[i:]) not in pr:            ok = False            break    if ok:        ans += xprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 371","url":"/project-euler/371/","content":"\r\nProject Euler 371\r\n题目\r\nLicence plates\r\nOregon licence plates consist of three letters followed by a three\r\ndigit number (each digit can be from \\([0..9]\\)).\r\nWhile driving to work Seth plays the following game:\r\nWhenever the numbers of two licence plates seen on his trip add to\r\n\\(1000\\) that’s a win.\r\nE.g. \\(\\text{MIC}-012\\) and \\(\\text{HAN}-988\\) is a win and \\(\\text{RYU}-500\\) and \\(\\text{SET}-500\\) too (as long as he sees\r\nthem in the same trip).\r\nFind the expected number of plates he needs to see for a win.\r\nGive your answer rounded to \\(8\\)\r\ndecimal places behind the decimal point.\r\nNote: We assume that each licence plate seen is\r\nequally likely to have any three digit number on it.\r\n解决方案\r\n令\\(N=3\\)，表示号码牌位数。不难想到使用动态规划的思想解决。\r\n这一些数主要分成三块来看：\\(0,5\\cdot\r\n10^{N-1}\\)，以及其它剩下的数。\r\n当遇到一个数\\(0\\)时，那么对当前状态不会产生任何影响。而对于除\\(5\\cdot\r\n10^{N-1}\\)之外的其它数而言，如果遇到了\\(x\\)，那么当只有遇到\\(1000-x\\)时才算胜利（注意此时\\(x\\neq 10^N-x\\)），我们称\\(x\\)和\\(10^N-x\\)是一对号码牌；但是对于\\(5\\cdot\r\n10^{N-1}\\)，只要单独遇到两次则胜利。\r\n因此将\\(5\\cdot\r\n10^{N-1}\\)分开考虑。考虑状态\\(g(i)(0\\le\r\ni&lt;5\\cdot 10^{N-1})\\)表示已经遇到一次\\(5\\cdot\r\n10^{N-1}\\)时，并且已经遇到了独立的\\(i\\)对号码牌之中的一对，接下来进行游戏的期望轮数。那么就可以写出\\(g\\)的递推式如下：\r\n\\(g(i)=\\dfrac{1\\cdot g(i)+1\\cdot 0+i\\cdot\r\ng(i)+i\\cdot 0+(10^{N}-2i-2)\\cdot g(i+1)}{10^N}+1\\)\r\n其中\\(5\\)项分别表示：遇到了一个\\(0\\)号牌；再次遇到了一个\\(5\\cdot 10^{N-1}\\)号牌；遇到了\\(i\\)对号码牌中某一对的同一个；遇到了\\(i\\)对号码牌中某一对的另外一个；遇到了一对新的号码牌中的一个。\r\n这是一个有后效性的动态规划方程，因为状态之间形成了循环的依赖（状态\\(i\\)依赖于自身）。不过，这种情况下消除后效性很简单。右边项也是\\(g(i)\\)，只需要挪到左边消除就可以完成消除后效性，从而正确计算结果。\r\n为了方便正式状态转移方程，假设存在状态\\(g(5\\cdot 10^{N-1})\\),并令其为\\(0\\),整理关于\\(g\\)的方程，消除后效性后可以写成:\r\n\\[\r\ng(i)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0  &amp; &amp; \\text{if}\\quad i=5\\cdot 10^{N-1} \\\\\r\n  &amp;\\dfrac{(10^N-2i-2)\\cdot g(i+1)+10^N}{10^N-1-i} &amp; &amp;\r\n\\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n类似的，定义状态\\(f(i)(0\\le i&lt;5\\cdot\r\n10^{N-1})\\)表示已经遇到一次\\(5\\cdot\r\n10^{N-1}\\)时，并且已经遇到了独立的\\(i\\)对号码牌之中的一对，接下来进行游戏的期望轮数。那么理解了\\(g\\)的状递推式，不难写出关于\\(f\\)的递推式：\r\n\\(f(i)=\\dfrac{1\\cdot f(i)+1\\cdot\r\ng(i)+i\\cdot f(i)+i\\cdot 0+(10^{N}-2i-2)\\cdot\r\nf(i+1)}{10^N}+1\\)\r\n类似的，整理后可以写成\r\n\\[\r\nf(i)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0  &amp; &amp; \\text{if}\\quad i=5\\cdot 10^{N-1} \\\\\r\n  &amp;\\dfrac{g(i)+(10^N-2i-2)\\cdot f(i+1)+10^N}{10^N-1-i} &amp; &amp;\r\n\\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n那么，最终的答案为\\(f(0)\\).\r\n代码\r\nN = 3k = 10 ** N // 2 - 1f, g = 0, 0for i in range(k, -1, -1):    g = ((10 ** N - 2 * i - 2) * g + 10 ** N) / (10 ** N - 1 - i)    f = (g + (10 ** N - 2 * i - 2) * f + 10 ** N) / (10 ** N - 1 - i)ans = fprint(&quot;&#123;:.8f&#125;&quot;.format(ans))\r\n","categories":["Project Euler"],"tags":["动态规划","概率"]},{"title":"Project Euler 375","url":"/project-euler/375/","content":"\r\nProject Euler 375\r\n题目\r\nMinimum of subsequences\r\nLet \\(S_n\\) be an integer sequence\r\nproduced with the following pseudo-random number generator: \\[\r\n\\begin{aligned}\r\nS_0  &amp;= 290797 \\\\\r\nS_{n+1}  &amp;= S_n^2 \\bmod 50515093\r\n\\end{aligned}\r\n\\]\r\nLet \\(A(i, j)\\) be the minimum of\r\nthe numbers \\(S_i, S_{i+1}, \\ldots,\r\nS_j\\) for \\(i\\le j\\).\r\nLet \\(M(N) = \\sum A(i, j)\\) for\r\n\\(1 \\le i \\le j \\le N\\).\r\nWe can verify that \\(M(10) =\r\n432256955\\) and \\(M(10\\,000) =\r\n3264567774119\\).\r\nFind \\(M(2\\,000\\,000\\,000)\\).\r\n单调栈\r\n单调栈是一种数据结构，栈内元素保证单调性。这种数据结构用于维护这个序列中，每一个数在左边/右边比它大/小的第一个数。\r\n如果要求某个数右边比它第一个大的数，那么考虑从右往左遍历序列。对于每一个数，弹出栈中比它小的所有数。如果栈未空，那么栈顶的数就是答案，否则说明这个数右边没有比它大的数。最终把自身压入这个栈中。\r\n解决方案\r\n注意到，\\(S\\)是一个周期序列，其周期\\(T=6308948\\)，最小值为\\(m=3\\).\r\n对于这道题，我们考虑这个序列中每一个数\\(S_i\\)能够对答案\\(M(N)\\)。这启发我们先使用单调栈找出每一个数\\(S_i\\)分别在左边和右边严格比它小的第一个数\\(S_l,S_r\\)。那么对于所有区间\\([i,j],l &lt; i\\le j&lt; r\\)，区间\\([i,j]\\)都是以\\(S_i\\)为最小值，这些区间一共有\\((r-i)\\cdot (i-l)\\)个。另外，注意到\\(S\\)是周期序列，因此对\\(S_{i+T}\\)而言，也会有同样类似的结论。\r\n如果最小值\\(m\\)是某个区间的贡献，那么\\(m\\)可能横跨多个区间。为了避免重复计算，接下来先考虑比\\(m\\)大的数的贡献。\r\n接下来我们将原序列\\(S\\)中的\\(N\\)个值分成三部分，分别是：\\(S\\)的前\\(T\\)个数，\\(S\\)的最后\\(T\\)个数，以及中间其它数。由于\\(S\\)有周期性，我们只考虑\\(S\\)的前\\(2T+N\\%T\\)项，对这些项使用上面提到的单调栈算法两次，分别求出两个关于\\(i\\)的序列\\(l[i],r[i]\\)。不难发现可以将这些\\(i-l[i],r[i]-i\\)的值对应到原式序列的一个个下标里面。\r\n因此对前\\(T\\)个数和后\\(T\\)个数分别独立计算求和。对于中间剩下的\\(N-2T\\)这一部分数，可以考虑将它分成每\\(T\\)个元素一块，整体计算贡献。\r\n在计算的过程中统计所有非最小值的区间贡献数量之和。长度为\\(N\\)的序列意味着有\\(\\dfrac{N(N+1)}{2}\\)个区间，那么最后求\\(m\\)的时候用\\(\\dfrac{N(N+1)}{2}\\)减去这些区间数量和，那么就得到了\\(m\\)的区间贡献数。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int Q=2e9,T;const int A=290797,M=50515093;//容易知道，S1到后面为一个循环数组，其中周期为T。int S[M*3];int l[M*3],r[M*3];void gen(int m)&#123;    stack&lt;int&gt;st;    for(int i=0;i&lt;m;i++)&#123;        while(!st.empty() &amp;&amp; S[i] &lt; S[st.top()])            st.pop();        if(st.empty()) l[i]=0;        else l[i]=st.top()+1;        st.push(i);    &#125;    while(!st.empty())        st.pop();    for(int i=m-1;i&gt;=0;i--)&#123;        while(!st.empty() &amp;&amp; S[i] &lt; S[st.top()])            st.pop();        if(st.empty()) r[i]=m-1;        else r[i]=st.top()-1;        st.push(i);    &#125;&#125;ll solve()&#123;    //由于S数组是一个循环数组，故分类处理。    int mn=*min_element(S, S + T);    ll res=1ll*Q*(Q+1)/2,ans=0;    if(Q&lt;=T*2)&#123;        for(int i=T;i&lt;Q;i++)            S[i]=S[i-T];        gen(Q);        for(int i=0;i&lt;Q;i++)&#123;            ll tp=1ll*(i-l[i]+1)*(r[i]-i+1);            ans+=tp*S[i];            res-=tp;        &#125;        ans+=res*mn;    &#125;    else&#123;        for(int i=0;i&lt;T;i++)            S[i+T]=S[i+T+T]=S[i];        int block=Q/T,rest=Q%T;        gen(2*T+rest);        for(int i=0;i&lt;T;i++)&#123;            ll tp=1ll*(i-l[i]+1)*(r[i]-i+1);            ans+=tp*S[i];            res-=tp;            int j=2*T+rest-1-i;            tp=1ll*(j-l[j]+1)*(r[j]-j+1);            ans+=tp*S[j];            res-=tp;            tp=1ll*(i+T-l[i+T]+1)*(r[i]-i+1);            ll c=block-2+(i&lt;rest);            ans+=tp*S[i]*c;            res-=tp*c;        &#125;        ans+=res*mn;    &#125;    return ans;&#125;int main()&#123;    S[0]=1ll*A*A%M;    for(int i=1;i&lt;M;i++)&#123;        S[i]=1ll*S[i-1]*S[i-1]%M;        if(S[i]==S[0])&#123;            T=i;break;        &#125;    &#125;    ll ans=solve();    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 365","url":"/project-euler/365/","content":"\r\nProject Euler 365\r\n题目\r\nA huge binomial coefficient\r\nThe binomial coefficient \\(\\displaystyle{\\binom{10^{18}}{10^9}}\\) is a\r\nnumber with more than 9 billion (\\(9\\times\r\n10^9\\)) digits.\r\nLet \\(M(n,k,m)\\) denote the binomial\r\ncoefficient \\(\\displaystyle{\\binom{n}{k}}\\) modulo \\(m\\).\r\nCalculate \\(\\displaystyle{\\sum\r\nM(10^{18},10^9,p\\cdot q\\cdot r)}\\) for \\(1000\\lt p\\lt q\\lt r\\lt 5000\\) and \\(p\\),\\(q\\),\\(r\\)\r\nprime.\r\n解决方案\r\n令\\(pr\\)为所有满足\\(1000&lt; p&lt; 5000\\)的质数\\(p\\)的数组。\r\n利用卢卡斯定理，可以预处理出所有\\(\\displaystyle{\\binom{10^{18}}{10^9}}\\%p\\)的值。\r\n再使用中国剩余定理对任意三个质数下的解进行合并。\r\n发现在这些质数\\(p\\)中，大多数都有\\(\\displaystyle{\\binom{10^{18}}{10^9}}\\%p=0\\)。因此当枚举的三个质数都满足模\\(p\\)为\\(0\\)时，此时的解肯定为\\(0\\)，直接跳过。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll N=1e18,M=1e9;const int L=1000,R=5000;bool vis[R+4];vector&lt;int&gt;pr,a;int fac[R+4];ll inv(ll n,ll p)&#123;    ll a=1,m=p-2;    for(;m;m&gt;&gt;=1)&#123;        if(m&amp;1) a=a*n%p;        n=n*n%p;    &#125;    return a;&#125;ll CRT(ll *a,ll *p,int n)&#123;    ll M=1;    ll ans=0;    for(int i=0;i&lt;n;i++) M*=p[i];    for(int i=0;i&lt;n;i++)        ans=(ans+a[i]*inv(M/p[i],p[i])*(M/p[i]))%M;    return ans%M;&#125;int C(int n,int m,int p)&#123;    if(m&gt;n) return 0;    return fac[n]*inv(fac[m],p)%p*inv(fac[n-m],p)%p;&#125;ll lucas(ll n,ll m,ll p)&#123;    return n==0?1:C(n%p,m%p,p)*lucas(n/p,m/p,p)%p;&#125;int main()&#123;    for(int i=2;i&lt;R;i++)&#123;        if(vis[i]) continue;        if(i&gt;L) pr.push_back(i);        for(int j=i+i;j&lt;R;j+=i)            vis[j]=1;    &#125;    for(int p:pr)&#123;        fac[0]=1;        for(int i=1;i&lt;p;i++)            fac[i]=fac[i-1]*i%p;        a.push_back(lucas(N,M,p));    &#125;    ll ans=0;    for(int i=0;i&lt;pr.size();i++)        for(int j=0;j&lt;i;j++)            for(int k=0;k&lt;j;k++)                if(a[i]||a[j]||a[k])&#123;                    ll b[]=&#123;a[i],a[j],a[k]&#125;,p[]=&#123;pr[i],pr[j],pr[k]&#125;;                    ans+=CRT(b,p,3);                &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n上面的代码运行时间略久，这是因为计算中国剩余定理的过程中总需要计算重新计算逆元。考虑一开始就将所有逆元线性预处理出来，那么整个程序运行时间下降到原来的约\\(\\dfrac{1}{3}\\)。\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll N=1e18,M=1e9;const int L=1000,R=5000;bool vis[R+4];vector&lt;int&gt;pr,a;vector&lt;vector&lt;int&gt;&gt;inv_list;int fac[R+4];ll inv(ll n,ll p)&#123;    ll a=1,m=p-2;    for(;m;m&gt;&gt;=1)&#123;        if(m&amp;1) a=a*n%p;        n=n*n%p;    &#125;    return a;&#125;ll CRT(ll *a,ll *p,int n)&#123;    ll M=1;    ll ans=0;    for(int i=0;i&lt;n;i++) M*=p[i];    for(int i=0;i&lt;n;i++)        ans=(ans+a[i]*inv_list[p[i]][M/p[i]%p[i]]*(M/p[i]))%M;    return ans%M;&#125;int C(int n,int m,int p)&#123;    if(m&gt;n) return 0;    return fac[n]*inv_list[p][fac[m]]%p*inv_list[p][fac[n-m]]%p;&#125;ll lucas(ll n,ll m,ll p)&#123;    return n==0?1:C(n%p,m%p,p)*lucas(n/p,m/p,p)%p;&#125;int main()&#123;    inv_list.resize(R);    for(int i=2;i&lt;R;i++)&#123;        if(vis[i]) continue;        if(i&gt;L)&#123;            pr.push_back(i);            inv_list[i].resize(i);            inv_list[i][1]=1;            for(int j=2;j&lt;i;j++)&#123;                inv_list[i][j]=(i-i/j)*inv_list[i][i%j]%i;            &#125;        &#125;        for(int j=i+i;j&lt;R;j+=i)            vis[j]=1;    &#125;    for(int p:pr)&#123;        fac[0]=1;        for(int i=1;i&lt;p;i++)            fac[i]=fac[i-1]*i%p;        a.push_back(lucas(N,M,p));    &#125;    ll ans=0;    for(int i=0;i&lt;pr.size();i++)        for(int j=0;j&lt;i;j++)            for(int k=0;k&lt;j;k++)                if(a[i]||a[j]||a[k])&#123;                    ll b[]=&#123;a[i],a[j],a[k]&#125;,p[]=&#123;pr[i],pr[j],pr[k]&#125;;                    ans+=CRT(b,p,3);                &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["卢卡斯定理","中国剩余定理"]},{"title":"Project Euler 377","url":"/project-euler/377/","content":"\r\nProject Euler 377\r\n题目\r\nSum of digits - experience \\(\\#13\\)\r\nThere are \\(16\\) positive integers\r\nthat do not have a zero in their digits and that have a digital sum\r\nequal to \\(5\\), namely:\r\n\\(5, 14, 23, 32, 41, 113, 122, 131, 212,\r\n221, 311, 1112, 1121, 1211, 2111\\) and \\(11111\\).\r\nTheir sum is \\(17891\\).\r\nLet \\(f(n)\\) be the sum of all\r\npositive integers that do not have a zero in their digits and have a\r\ndigital sum equal to \\(n\\).\r\nFind \\(\\displaystyle \\sum_{i=1}^{17}\r\nf(13^i)\\).\r\nGive the last \\(9\\) digits as your\r\nanswer.\r\n解决方案\r\n注意这里需要求的是所有数之和。我们可以每次将一个数位拼接在一个数的后面，从而形成一个新的数。\r\n令状态\\(c(i)(i\\ge\r\n0)\\)表示没有数位\\(0\\)且数位和为\\(i\\)的数的个数，那么不难写出如下状态转移方程：\r\n\\[\r\nc(i)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i=0 \\\\\r\n  &amp;\\sum_{d=1}^{\\min(9,i)} c(i-d) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n将状态\\(c(i-d)\\)中的每一个数后面都添加一个数位\\(d\\)，那么就成为了\\(c(i)\\)中的数。\r\n得到\\(c(i)\\)后，令状态\\(s(i)(i\\ge 0)\\)表示没有数位\\(0\\)且数位和为\\(i\\)的数之和，那么不难写出如下状态转移方程：\r\n\\[\r\ns(i)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0  &amp; &amp; \\text{if}\\quad i=0 \\\\\r\n  &amp;\\sum_{d=1}^{\\min(9,i)} 10s(i-d)+d\\cdot c(i-d) &amp; &amp;\r\n\\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n拼接一个新的数位\\(d\\)后，状态\\(s(i-d)\\)中的所有数都需要左移一位，都乘\\(10\\)。这些数一共有\\(c(i-d)\\)个，故综合还需要添加\\(d\\cdot c(i-d)\\)。\r\n最终，\\(s(N)\\)可以以\\(O(N)\\)的时间复杂度计算出来。不过，对于题目要求的时间复杂度仍然不高，需要使用矩阵快速幂进行优化。\r\n无论是\\(c\\)还是\\(s\\)，后面都有\\(9\\)项，因此这个矩阵的大小为\\(18\\)。这是一个比较大的矩阵，因此系数矩阵在此不展示，详见代码。\r\n代码\r\nP = 13N = 17mod = 10 ** 9def mul(a: list, b: list):    return [[sum(a[i][k] * b[k][j] for k in range(len(b))) % mod for j in range(len(b[0]))] for i in range(len(a))]def f(n):    M = 18    # s[i-9],s[i-8],s[i-7],...,s[i-1],c[i-9],c[i-8],c[i-7],...,c[i-1]    a = [[0, 1, 13, 147, 1625, 17891, 196833, 2165227, 23817625, 1, 1, 2, 4, 8, 16, 32, 64, 128]]    b = [[0 for _ in range(M)] for _ in range(M)]    for i in range(9):        b[i][8] = 10        b[i + 9][8] = 9 - i        b[i + 9][8 + 9] = 1    for i in range(8):        b[i + 1][i] = b[i + 1 + 9][i + 9] = 1    while n:        if n &amp; 1:            a = mul(a, b)        b = mul(b, b)        n &gt;&gt;= 1    ans = a[0][0]    return ansans = sum(f(P ** i) for i in range(1, N + 1)) % modprint(ans)\r\n","categories":["Project Euler"],"tags":["动态规划","矩阵快速幂"]},{"title":"Project Euler 378","url":"/project-euler/378/","content":"\r\nProject Euler 378\r\n题目\r\nTriangle Triples\r\nLet \\(T(n)\\) be the \\(n^\\text{th}\\) triangle number, so \\(T(n) = \\dfrac{n(n + 1)}{2}\\).\r\nLet \\(dT(n)\\) be the number of\r\ndivisors of \\(T(n)\\).\r\nE.g.: \\(T(7) = 28\\) and \\(dT(7) = 6\\).\r\nLet \\(Tr(n)\\) be the number of\r\ntriples \\((i, j, k)\\) such that \\(1 \\le i \\lt j \\lt k \\le n\\) and \\(dT(i) \\gt dT(j) \\gt dT(k)\\)\r\n\\(Tr(20) = 14\\), \\(Tr(100) = 5772\\), and \\(Tr(1000) = 11174776\\).\r\nFind \\(Tr(60 000 000)\\).\r\nGive the last \\(18\\) digits of your\r\nanswer.\r\n解决方案\r\n令\\(N=600000000\\)，通过线性筛预处理处理出\\(1\\sim N+1\\)的因数个数，可以以\\(O(N)\\)的时间复杂度计算出所有\\(dT\\)值，令\\(M\\)是\\(1\\sim\r\nN\\)中\\(dT\\)值最大的一个。\r\n考虑使用动态规划的思想解决本题。令状态\\((i,j)(1\\le i\\le 3,1\\le j\\le\r\nN)\\)表示长度为\\(i\\)并且以\\(j\\)为结尾的序列有多少个（即\\(p_1&lt;p_2&lt;\\dots&lt;p_{i-1}&lt;j\\)\r\n并且\\(dT(p_1)&gt;dT(p_2)&gt;\\dots&gt;dT(p_{i-1})&gt;j\\)）\r\n那么不难写出关于\\(f(i,j)\\)的状态转移方程：\r\n\\[\r\nf(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i=1 \\\\\r\n  &amp;\\sum_{k&lt;j,dT(k)&gt;j} f(i-1,k) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n直接进行转移的效率非常低，因此考虑使用树状数组维护状态：将当前所有\\(f(i-1,k),k\\le j\\)的状态都按照值\\(dT(k)\\)存到树状数组中，那么询问时只需要以\\(O(\\log M)\\)的时间复杂度求得大于\\(dT(j)\\)的所有状态之和。\r\n最终答案为\\(\\sum_{j=1}^Nf(3,j)\\)，时间复杂度为\\(O(N\\log M)\\)。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;# define lb(i) ((i)&amp;(-i))typedef long long ll;using namespace std;const int N=60000000;ll mod=1e18;int M=0;int v[N+4],pr[N/10+100],m=0;int d[N+4];ll s[N+4],f[N+4];void pl(ll &amp;x,ll y)&#123;    x+=y;    if(x&gt;=mod) x-=mod;&#125;void add(int p,ll x)&#123;    for(int i=p;i&lt;=M;i+=lb(i))&#123;        pl(s[i],x);    &#125;&#125;ll que(int p)&#123;    ll a=0;    for(int i=p;i;i-=lb(i))        pl(a,s[i]);    return a;&#125;int main()&#123;    f[1]=1;    for(int i=2;i&lt;=N+1;i++)&#123;        if(v[i]==0)&#123;            v[i]=i;pr[++m]=i;f[i]=2;        &#125;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;(N+1)/i) break;            v[i*pr[j]]=pr[j];            f[i*pr[j]]=f[i]*2-(pr[j]==v[i]?f[i/pr[j]]:0);        &#125;    &#125;    for(int n=1;n&lt;=N;n++)        d[n]=n&amp;1?f[n]*f[(n+1)&gt;&gt;1]:f[n&gt;&gt;1]*f[n+1];    M=*max_element(d+1,d+N+1);    for(int i=1;i&lt;=N;i++)        f[i]=1;    for(int k=1;k&lt;=2;k++)&#123;        memset(s,0,sizeof(s));        ll sum=0;        for(int i=1;i&lt;=N;i++)&#123;            ll x=f[i];            f[i]=sum-que(d[i]);            add(d[i],x);            pl(sum,x);        &#125;    &#125;    ll ans=0;    for(int i=1;i&lt;=N;i++)        pl(ans,f[i]);    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划","树状数组"]},{"title":"Project Euler 38","url":"/project-euler/38/","content":"\r\nProject Euler 38\r\n题目\r\nPandigital multiples\r\nTake the number 192 and multiply it by each of \\(1, 2,\\) and \\(3\\):\r\n\\(\\begin{aligned}\r\n192 \\times 1 = 192\\\\\r\n192 \\times 2 = 384\\\\\r\n192 \\times 3 = 576\\\\\r\n\\end{aligned}\\)\r\nBy concatenating each product we get the \\(1\\) to \\(9\\) pandigital, \\(192384576\\). We will call \\(192384576\\) the concatenated product of\r\n\\(192\\) and \\((1,2,3)\\)\r\nThe same can be achieved by starting with \\(9\\) and multiplying by \\(1, 2, 3, 4,\\) and \\(5\\), giving the pandigital, \\(918273645\\), which is the concatenated\r\nproduct of \\(9\\) and \\((1,2,3,4,5)\\).\r\nWhat is the largest \\(1\\) to \\(9\\) pandigital \\(9\\)-digit number that can be formed as the\r\nconcatenated product of an integer with \\((1,2, \\dots ,n)\\) where \\(n &gt; 1\\)?\r\n解决方案\r\n如果需要\\(n&gt;1\\)，那么当任意一个数\\(n\\)，将\\(n\\)和\\(2n\\)拼接起来，长度会翻倍（很容易超过\\(9\\)），可以使用这个方法进行剪枝。\r\n代码\r\nb = &quot;123456789&quot;ans = 0for i in range(1, int(10**(len(b)/2))+4):    t = &quot;&quot;    for x in range(1, 10):        t += str(i * x)        if len(t) &gt;= 9:            break    u = &quot;&quot;.join((lambda x: (x.sort(), x)[1])(list(t)))    if u == b:        ans = max(ans, int(t))print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 388","url":"/project-euler/388/","content":"\r\nProject Euler 388\r\n题目\r\nDistinct Lines\r\nConsider all lattice points \\((a,b,c)\\) with \\(0 \\le a,b,c \\le N\\).\r\nFrom the origin \\(O(0,0,0)\\) all\r\nlines are drawn to the other lattice points.\r\nLet \\(D(N)\\) be the number of\r\ndistinct such lines.\r\nYou are given that \\(D(1 000 000) =\r\n831909254469114121\\).\r\nFind \\(D(10^{10})\\). Give as your\r\nanswer the first nine digits followed by the last nine digits.\r\n解决方案\r\n令\\(N=10^{10}\\)。\r\n在这个三维空间中，一共有\\((N+1)^3-1\\)个点，其坐标满足\\(\\max(a,b,c)&gt;0\\)。\r\n在这些点中，如果一个点不被前面的点”阻挡”，当且仅当其坐标满足\\(\\gcd(a,b,c)=1\\)。\r\n那么有：\r\n\\[\\begin{aligned}\r\n(N+1)^3-1&amp;=|\\{(a,b,c)|0\\le a,b,c\\le N,\\max(a,b,c)&gt;0\\}|\\\\\r\n&amp;=\\sum_{d=1}^N|\\{(a,b,c)|0\\le a,b,c\\le\r\nN,\\max(a,b,c)&gt;0,\\gcd(a,b,c)=d\\}|\\\\\r\n&amp;=\\sum_{d=1}^N\\left|\\left\\{(a,b,c)| 0\\le a,b,c \\le\r\n\\left\\lfloor\\dfrac{n}{d}\\right\\rfloor,\\max(a,b,c)&gt;0,\\gcd(a,b,c)=1\\right\\}\\right|\\\\\r\n&amp;=\\sum_{d=1}^ND\\left(\\dfrac{n}{d}\\right)\r\n\\end{aligned}\\]\r\n那么我们可以得到关于\\(D\\)的递推式，直接使用数论分块的方式进行求解即可：\r\n\\[D(N)=(N+1)^3-1-\\sum_{d=2}^N\r\nD\\left(\\dfrac{n}{d}\\right)\\]\r\n代码\r\n本代码使用了GMP库实现。\r\n# include &lt;bits/stdc++.h&gt;# include &quot;gmpxx.h&quot;using namespace std;typedef long long ll;const ll N=1e10;const int M=1000000;const int O = 9;mpz_class d[M+2];unordered_map&lt;ll,mpz_class&gt;mpD;mpz_class D(ll n) &#123;    if (n &lt;= M &amp;&amp; d[n] &gt; 0) return d[n];    else if (n &gt; M &amp;&amp; mpD.count(n)) return mpD[n];    mpz_class w = mpz_class(n+1)*(n+1)*(n+1) - 1;    for (ll l = 2, r; l &lt;= n; l = r + 1) &#123;        r = n / (n / l);        w -= D(n / l) * (r - l + 1);    &#125;    if (n &lt;= M) return d[n] = w;    else return mpD[n] = w;&#125;int main() &#123;    mpz_class ans2 = D(N);    string s = ans2.get_str();    string ans = s.substr(0, O) + s.substr(max(0, int(s.size()) - O));    cout &lt;&lt; ans &lt;&lt; endl;&#125;\r\n","categories":["Project Euler"],"tags":["数论分块"]},{"title":"Project Euler 366","url":"/project-euler/366/","content":"\r\nProject Euler 366\r\n题目\r\nStone Game III\r\nTwo players, Anton and Bernhard, are playing the following game.\r\nThere is one pile of \\(n\\)\r\nstones.\r\nThe first player may remove any positive number of stones, but not\r\nthe whole pile.\r\nThereafter, each player may remove at most twice the number of stones\r\nhis opponent took on the previous move.\r\nThe player who removes the last stone wins.\r\nE.g. \\(n=5\\)\r\nIf the first player takes anything more than one stone the next\r\nplayer will be able to take all remaining stones.\r\nIf the first player takes one stone, leaving four, his opponent will\r\ntake also one stone, leaving three stones.\r\nThe first player cannot take all three because he may take at most\r\n\\(2\\times1=2\\) stones. So let’s say he\r\ntakes also one stone, leaving \\(2\\).\r\nThe second player can take the two remaining stones and wins.\r\nSo \\(5\\) is a losing position for\r\nthe first player.\r\nFor some winning positions there is more than one possible move for\r\nthe first player.\r\nE.g. when \\(n=17\\) the first player\r\ncan remove one or four stones.\r\nLet \\(M(n)\\) be the maximum number\r\nof stones the first player can take from a winning position at his\r\nfirst turn and \\(M(n)=0\\) for any\r\nother position.\r\n\\(\\sum M(n)\\) for \\(n\\le100\\) is \\(728\\).\r\nFind \\(\\sum M(n)\\) for \\(n\\le10^{18}\\). Give your answer modulo\r\n\\(10^8\\).\r\n解决方案\r\n通过以下程序，直接打印出\\(M\\)的前\\(1000\\)项的值：\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=1000;bool f[N+4][N+4],v[N+4][N+4];bool ok(int n,int m)&#123;    if(n==0) return 0;    else if(n&lt;=m) return 1;    else if(v[n][m]) return f[n][m];    v[n][m]=1;    bool flag=0;    for(int i=1;i&lt;=m&amp;&amp;!flag;i++)        if(!ok(n-i,i*2)) flag=1;    return f[n][m]=flag;&#125;int main()&#123;    for(int n=1;n&lt;=N;n++)&#123;        int ans=0;        for(int i=1;i&lt;n;i++)&#123;            if(!ok(n-i,i*2)) ans=i;        &#125;        printf(&quot;%d %d\\n&quot;,n,ans);    &#125;&#125;\r\n假设第\\(i\\)个斐波那契数的值为\\(f_i\\)，其中\\(f_1=1,f_2=2\\)。发现对于区间\\([f_i,f_{i+1})\\)内的任意整数，函数值\\(M\\)是由一些连续的相邻整数段组成。更具体的解释为：\r\n\r\n如果\\(x\\le\r\n\\left\\lfloor\\dfrac{f_i-1}{2}\\right\\rfloor\\)，有\\(M(f_i+x)=x;\\)\r\n否则，对于\\(\\left\\lfloor\\dfrac{f_i-1}{2}\\right\\rfloor&lt;\r\nx&lt; f_{i-1}\\)，有\\(M(f_i+x)=M(x).\\)\r\n\r\n令\\(S(n)=\\sum_{i=1}^n\r\nM(i)\\)，那么我们直接进行分段计算。对于区间\\([f_i,f_{i+1})\\)的值，令\\(m_i=\\left\\lfloor\\dfrac{f_i-1}{2}\\right\\rfloor\\)，那么有\\(S(f_{i+1}-1)-S(f_i-1)=\\dfrac{m_i(m_i+1)}{2}+S(f_{i-1}-1)-S(m_i)\\)。\r\n暴力分块计算即可，另外使用记忆化搜索进行加速。\r\n代码\r\nN = 10 ** 18mod = 10 ** 8mp = &#123;0: 0, 1: 0, 2: 0&#125;def S(n):    if n in mp.keys():        return mp[n]    a, b, c = 1, 1, 2    s = 0    while True:        if c &gt; n:            c = n + 1        m = (b - 1) &gt;&gt; 1        if b + m &lt;= n:            s += m * (m + 1) // 2 + S(a - 1) - S(m)        else:            k = n - b            s += k * (k + 1) // 2        if c == n + 1:            break        a, b, c = b, c, b + c    mp[n] = s    return sans = S(N) % modprint(ans)\r\n","categories":["Project Euler"],"tags":["博弈论"]},{"title":"Project Euler 381","url":"/project-euler/381/","content":"\r\nProject Euler 381\r\n题目\r\n(prime-\\(k\\)) factorial\r\nFor a prime \\(p\\) let \\(S(p) = (\\sum(p-k)!) \\bmod(p)\\) for \\(1 \\le k \\le 5\\).\r\nFor example, if \\(p=7, (7-1)! + (7-2)! +\r\n(7-3)! + (7-4)! + (7-5)! = 6! + 5! + 4! + 3! + 2! = 720+120+24+6+2 =\r\n872\\).\r\nAs \\(872 \\bmod(7) = 4, S(7) =\r\n4\\).\r\nIt can be verified that \\(\\sum S(p) =\r\n480\\) for \\(5 \\le p &lt;\r\n100\\).\r\nFind \\(\\sum S(p)\\) for \\(5 \\le p &lt; 10^8\\).\r\n威尔逊定理\r\n威尔逊定理：一个数\\(p\\)为质数，当且仅当满足下面的条件：\r\n\\[(p-1)!\\equiv-1 \\pmod p\\]\r\n解决方案\r\n假设已知\\(a=(p-5)!\\%p\\)，那么有\r\n\\[\\begin{aligned}\r\nS(p)&amp;=(a+(p-4)a+(p-4)(p-3)a+\\dots+(p-4)(p-3)(p-2)(p-1)a) \\% p\\\\\r\n&amp;=(a+(-4)a+(-4)(-3)a+\\dots+(-4)(-3)(-2)(-1)a)\\%p\\\\\r\n&amp;=9a \\%p\r\n\\end{aligned}\\]\r\n那么接下来的问题是根据威尔逊计算\\(a\\)的值。\r\n可以发现，\\((p-1)\\%p=(p-1)(p-2)(p-3)(p-4)a\\%p=24a\\%p\\)。\r\n可以借助威尔逊定理，解出下面的式子，得到\\(a\\)的值。\r\n\\[24a\\equiv -1\\pmod p\\]\r\n为了避免扩展使用欧几里得算法的值，可以通过计算出\\(2,3\\)在\\(p\\)上的逆元，间接计算出\\(24\\)的逆元。\r\n计算完成后，最终得到\\(S(p)=-9\\cdot(24)^{-1}\\% p\\)。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=1e8;int pr[N+4],v[N+4],m=0;int main()&#123;    for(int i=2;i&lt;N;i++)&#123;        if(v[i]==0)&#123;            v[i]=i;pr[++m]=i;        &#125;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;N/i) break;            v[i*pr[j]]=pr[j];        &#125;    &#125;    ll ans=0;    for(int i=1;i&lt;=m;i++)&#123;        int p=pr[i];        if(p&gt;=5)&#123;            ll inv2=(p+1)&gt;&gt;1;            ll inv3=(p%3==1?(p+p+1)/3:(p+1)/3);            ans+=inv2*inv2%p*inv2%p*inv3%p*(p-1)%p*9%p;        &#125;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 389","url":"/project-euler/389/","content":"\r\nProject Euler 389\r\n题目\r\nPlatonic Dice\r\nAn unbiased single 4-sided die is thrown and its value, \\(T\\), is noted.\r\n\\(T\\) unbiased \\(6\\)-sided dice are thrown and their scores\r\nare added together. The sum, \\(C\\), is\r\nnoted.\r\n\\(C\\) unbiased \\(8\\)-sided dice are thrown and their scores\r\nare added together. The sum, \\(O\\), is\r\nnoted.\r\n\\(O\\) unbiased \\(12\\)-sided dice are thrown and their scores\r\nare added together. The sum, \\(D\\), is\r\nnoted.\r\n\\(D\\) unbiased \\(20\\)-sided dice are thrown and their scores\r\nare added together. The sum, \\(I\\), is\r\nnoted.\r\nFind the variance of \\(I\\), and give\r\nyour answer rounded to \\(4\\) decimal\r\nplaces.\r\n解决方案\r\n不难想到使用动态规划解决本题。\r\n当前先考虑一轮的过程：假设当前使用的是\\(m\\)面的骰子，那么令状态\\(g_m(i,j)(i,j\\ge 0)\\)表示具有\\(i\\)个\\(m\\)面骰子的情况下，能够掷出\\(j\\)个点的概率。不难写出\\(g_m\\)的状态转移方程：\r\n\\[\r\ng_m(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i=0 \\\\\r\n  &amp;\\sum_{k=\\max(j-m,0)}^{j-1}\\dfrac{g_m(i-1,k)}{m} &amp; &amp;\r\n\\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n这个方程说明对于一个状态\\(f(i-1,k)\\)，它有\\(\\dfrac{1}{m}\\)的概率转移到\\(g_m(i,k+1)\\)，也有\\(\\dfrac{1}{m}\\)的概率转移到\\(g_m(i+1,k+2),\\dots\\)\r\n假设整个过程使用的骰子的面的序列为\\(d=\\{4,6,8,12,20\\}\\)，其中第\\(i\\)轮使用的骰子的面数为\\(d[i]\\)，令\\(N=5\\)为这个序列长度，\\(M=\\prod_{k=1}^Nd_k\\)。令状态\\(f(i,j)(0\\le i\\le N,0\\le j\\le M)\\)在第\\(i\\)轮过后，投掷出\\(j\\)个点的概率。那么根据序列，不难写出状态转移方程为\r\n\\[\r\nf(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i=0 \\\\\r\n  &amp;\\sum_{k=1}^jf(i-1,k)\\cdot g_{d[i]}(k,j) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n这个方程说明对于一个状态\\(f(i-1,k)\\)抛出了\\(k\\)个\\(d[i]\\)面的骰子后，会有\\(g_{d[i]}(k,j)\\)的概率抛出\\(j\\)面，从而转移到\\(f(i,j)\\)。\r\n那么令\\(p(j)(0\\le j\\le\r\nM)=f(n,j)\\)，那么最终的变量\\(I\\)将会服从如\\(p\\)所示的分布。\r\n为了计算随机变量\\(I\\)的方差\\(D[I]\\)，利用公式\\(D[I]=E[I^2]-E^2[I]\\)进行计算即可。\r\n朴素实现一次\\(g_m(i,j)\\)的转移需要花费\\(O(m)\\)的时间复杂度。为了加速，我们注意到在实现\\(g_m\\)一个状态\\(g_m(i-1,j)\\)会等概率转移到下一个状态中的连续一段：\\(g(i,j+1),g(i,j+2),\\dots,g(i,j+m)\\)，因此考虑使用一个差分数组\\(g&#39;_m[i][j]\\)进行转移的保存：将\\(g&#39;[i][j+1]\\)加上\\(\\dfrac{g_m(i-1,j)}{m}\\)，将\\(g&#39;[i][j+m+1]\\)减去\\(\\dfrac{g_m(i-1,j)}{m}\\)。最终\\(g_m(i,j)=\\sum_{k=1}^j\r\ng&#39;[i][k]\\)就可以一次循环求出来，平均一个状态只有\\(O(1)\\)的时间复杂度。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt;d=&#123;4,6,8,12,20&#125;;int main()&#123;    int m=1;    vector&lt;double&gt;fp(2);    fp[1]=1;    for(int x:d)&#123;        vector&lt;double&gt;gp(1,1);        vector&lt;double&gt;fn(m*x+1,0);        for(int i=1;i&lt;=m;i++)&#123;            vector&lt;double&gt;gn(x*i+1+1);            for(int j=0;j&lt;=x*(i-1);j++)&#123;                gn[j+1]+=gp[j]/x;                gn[j+x+1]-=gp[j]/x;            &#125;            for(int j=1;j&lt;=x*i;j++)                gn[j]+=gn[j-1];            gp=gn;            for(int j=1;j&lt;=x*i;j++)                fn[j]+=fp[i]*gp[j];        &#125;        fp=fn;        m*=x;    &#125;    double ex1=0,ex2=0;    for(int i=1;i&lt;=m;i++)&#123;        ex1+=fp[i]*i;        ex2+=fp[i]*i*i;    &#125;    double ans=ex2-ex1*ex1;    printf(&quot;%.4f\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划","概率"]},{"title":"Project Euler 387","url":"/project-euler/387/","content":"\r\nProject Euler 387\r\n题目\r\nHarshad Numbers\r\nA Harshad or Niven number is a number that is\r\ndivisible by the sum of its digits.\r\n\\(201\\) is a Harshad number because\r\nit is divisible by \\(3\\) (the sum of\r\nits digits.)\r\nWhen we truncate the last digit from \\(201\\), we get \\(20\\), which is a Harshad number.\r\nWhen we truncate the last digit from \\(20\\), we get \\(2\\), which is also a Harshad number.\r\nLet’s call a Harshad number that, while recursively truncating the\r\nlast digit, always results in a Harshad number a right truncatable\r\nHarshad number.\r\nAlso:\r\n\\(201/3=67\\) which is prime.\r\nLet’s call a Harshad number that, when divided by the sum of its\r\ndigits, results in a prime a strong Harshad number.\r\nNow take the number \\(2011\\) which\r\nis prime.\r\nWhen we truncate the last digit from it we get \\(201\\), a strong Harshad number that is also\r\nright truncatable.\r\nLet’s call such primes strong, right truncatable Harshad\r\nprimes.\r\nYou are given that the sum of the strong, right truncatable Harshad\r\nprimes less than \\(10000\\) is \\(90619\\).\r\nFind the sum of the strong, right truncatable Harshad primes less\r\nthan \\(10^{14}\\).\r\n解决方案\r\n令\\(N=14.\\)不难发现，\\(1\\)位质数不是可右截强Harshad数，因为一位数与自己数位和的商为\\(1\\)，不是一个质数。\r\n本题主要关注可右截Harshad数。这种数的有一种生成思想：如果当前数\\(x\\)是一个可右截Harshad数，并且\\(10x+d\\)（\\(d\\)是一个新的数位）也是一个Harshad数，那么\\(10x+d\\)就是一个可右截Harshad数。\r\n很明显，\\(1\\sim\r\n9\\)本身就是可右截Harshad数，将作为起点进行扩展。最终发现，\\(10^{N-1}\\)以内的可右截Harshad数的数量不多。\r\n接下来，我们将枚举出来的可右截Harshad数，逐一直接判断是否为强Harshad数，并保留强Harshad数的一部分。\r\n对每个右截强Harshad数\\(y\\)，后面都填上\\(1,3,7,9\\)这\\(4\\)个数位\\(d\\)中的一个，那么构造出了\\(10y+d\\)。最终如果\\(10y+d\\)是质数，那么就添加到答案中。\r\n代码\r\nfrom tools import is_primeN = 14def is_harshad(n: int):    return n % sum(int(x) for x in str(n)) == 0ls = [[1, 2, 3, 4, 5, 6, 7, 8, 9]]tp = [1, 3, 7, 9]for i in range(N - 2):    ls.append([])    for x in ls[i]:        for j in range(10):            t = x * 10 + j            if is_harshad(t):                ls[i + 1].append(t)ans = 0for v in ls:    for n in v:        if not is_prime(n // sum(int(x) for x in str(n))):            continue        for y in tp:            w = n * 10 + y            if is_prime(w):                ans += wprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 39","url":"/project-euler/39/","content":"\r\nProject Euler 39\r\n题目\r\nInteger right triangles\r\nIf \\(p\\) is the perimeter of \\(a\\) right angle triangle with integral\r\nlength sides, \\(\\{a,b,c\\}\\), there are\r\nexactly three solutions for \\(p =\r\n120\\). \\[\\{20,48,52\\}, \\{24,45,51\\},\r\n\\{30,40,50\\}\\]\r\nFor which value of \\(p \\le 1000\\),\r\nis the number of solutions maximised?\r\n解决方案\r\n使用第9题时得出的结论，枚举\\(a\\)，即得到\\(b\\)的值：\r\n\\[b=\\dfrac{p^2-2ap}{2(p-a)}\\]\r\n因此，直接对解进行判断。\r\n代码\r\nN = 1000mx = 0ans = 0for p in range(3, N + 1):    cnt = 0    for a in range(1, p // 3 + 1):        if (p * p - 2 * a * p) % (2 * p - 2 * a) == 0:            b = (p * p - 2 * a * p) // (2 * p - 2 * a)            c = p - a - b            if a &lt; b &lt; c:                cnt += 1    if cnt &gt; mx:        ans = p        mx = cntprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 393","url":"/project-euler/393/","content":"\r\nProject Euler 393\r\n题目\r\nMigrating ants\r\nAn \\(n\\times n\\) grid of squares\r\ncontains \\(n^2\\) ants, one ant per\r\nsquare.\r\nAll ants decide to move simultaneously to an adjacent square (usually\r\n\\(4\\) possibilities, except for ants on\r\nthe edge of the grid or at the corners).\r\nWe define \\(f(n)\\) to be the number\r\nof ways this can happen without any ants ending on the same square and\r\nwithout any two ants crossing the same edge between two squares.\r\nYou are given that \\(f(4) =\r\n88\\).\r\nFind \\(f(10)\\).\r\n解决方案\r\n本解决方案参考了Thread中的一些内容。\r\n假设\\(N=10\\)。那么不难知道，对于每一个方格而言，只有以下\\(12\\)种情况，分别表示当前蚂蚁从这个格子从哪个方向走出去，以及哪个方向的蚂蚁将会走进来（用箭头表示方向）：\r\n\r\n这\\(12\\)种情况分别用一个编码来表示，规则如下：\r\n\r\n从正上方开始，顺时针表示当前格子的\\(4\\)个接触面的状态。\r\n如果当前的数字是\\(0\\)，那么接触面没有箭头。\r\n如果当前的数字是\\(1\\)，那么当前的接触面要么是用于向下箭头（上下方向时）或者向右箭头（左右方向时）的一部分。\r\n如果当前的数字是\\(2\\)，那么当前的接触面要么是用于向上箭头（上下方向时）或者向左箭头（左右方向时）的一部分。\r\n\r\n如果两个格子是相邻的，那么在某一种情况下，这两个接触面要么没有任何内容，要么两个格子接触刚刚好拼成一个箭头。\r\n因此，首先通过深度有限搜索，枚举每一行格子的上方状态集合\\(u\\)和下方状态集合\\(d\\)，并将\\(u\\)存在数组\\(pre[d]\\)中。\r\n这个状态集合用一个\\(N\\)位三进制数\\(d=d_{N-1}d_{N-2}\\dots\r\nd_1d_0\\)来表示。如果第\\(j\\)列格子的下方没有箭头，那么\\(d_j=0\\)；如果下方是下箭头的一部分，那么\\(d_j=1\\)；如果是上箭头的一部分，那么\\(d_j=2\\)。\r\n令状态\\(f(i,j)(0\\le i\\le N,0\\le j\\le\r\n3^N)\\)表示拼接完第\\(i\\)行的格子后，第\\(i\\)行所有格子的下方的箭头状态集合为\\(j\\)的拼接方案数。那么不难写出如下状态转移方程：\r\n\\[\r\nf(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i=0\\land j=0 \\\\\r\n  &amp;0 &amp; &amp; \\text{else if}\\quad i=0 \\\\\r\n  &amp;\\sum_{st\\in pre[j]} f(i-1,st) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n注意当\\(j=0\\)时，说明第\\(i\\)行的格子下方没有任何箭头的一部分。\r\n最终答案为\\(f(N,0).\\)\r\n代码\r\n#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=10;const int M=pow(3,N);vector&lt;vector&lt;int&gt;&gt;square&#123;    &#123;1,1,0,0&#125;,&#123;2,0,0,1&#125;,&#123;0,1,2,0&#125;,&#123;2,2,0,0&#125;,    &#123;1,0,1,0&#125;,&#123;0,1,0,1&#125;,&#123;2,0,2,0&#125;,&#123;0,2,0,2&#125;,    &#123;1,0,0,2&#125;,&#123;0,0,1,1&#125;,&#123;0,0,2,2&#125;,&#123;0,2,1,0&#125;&#125;;vector&lt;int&gt;g[M];void dfs(int f,int now,int u,int d)&#123;    if(f==N)&#123;        if(now==0) g[u].push_back(d);        return;    &#125;    for(auto &amp;s:square)        if(s[3]==now)            dfs(f+1,s[1],u*3+s[0],d*3+s[2]);&#125;ll f[2][M];int main()&#123;    dfs(0,0,0,0);    f[0][0]=1;    for(int i=0,p=0;i&lt;N;i++,p^=1)&#123;        memset(f[p^1],0,sizeof(f[p^1]));        for(int u=0;u&lt;M;u++)            for(int v:g[u])                f[p^1][v]+=f[p][u];    &#125;    printf(&quot;%lld\\n&quot;,f[N&amp;1][0]);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 394","url":"/project-euler/394/","content":"\r\nProject Euler 394\r\n题目\r\nEating pie\r\nJeff eats a pie in an unusual way.\r\nThe pie is circular. He starts with slicing an initial cut in the pie\r\nalong a radius. While there is at least a given fraction \\(F\\) of pie left, he performs the following\r\nprocedure:\r\n\r\nHe makes two slices from the pie centre to any point of what is\r\nremaining of the pie border, any point on the remaining pie border\r\nequally likely. This will divide the remaining pie into three\r\npieces.\r\nGoing counterclockwise from the initial cut, he takes the first\r\ntwo pie pieces and eats them.\r\n\r\nWhen less than a fraction \\(F\\) of\r\npie remains, he does not repeat this procedure. Instead, he eats all of\r\nthe remaining pie.\r\n\r\nFor \\(x \\ge 1\\), let \\(E(x)\\) be the expected number of times Jeff\r\nrepeats the procedure above with \\(F =\r\n\\dfrac{1}{x}\\).\r\nIt can be verified that \\(E(1) = 1, E(2)\r\n\\approx 1.2676536759,\\) and \\(E(7.5)\r\n\\approx 2.1215732071\\).\r\nFind \\(E(40)\\) rounded to \\(10\\) decimal places behind the decimal\r\npoint.\r\n解决方案\r\n本解决方案参考了Thread的一些内容。\r\n令\\(F=\\dfrac{1}{40}\\)。令\\(f(r)(0\\le r\\le\r\n1)\\)表示当前仍然剩下比率为\\(r\\)的派时，需要进行的轮数的期望。那么当\\(r&lt; F\\)时，\\(f(r)=0\\)。否则按照期望动态规划的思想，\\(f(r)\\)可以写成\r\n\\[f(r)=\\dfrac{1}{r^2}\\int_0^r\\int_0^r(1+f(\\min(r_1,r_2)))dr_1dr_2\\]\r\n由于每一轮中切的两刀是独立的，那么逆时针剩下的一部分就是两次剩余比率中的较小值。这个方程第一步可以化简为：\r\n\\[r^2f(r)=r^2+\\int_0^r\\int_0^rf(\\min(r_1,r_2))dr_1dr_2\\]\r\n目前只考虑右边的积分部分，可以发现，积分区域是独立对称的。假设\\(r_1\\le r_2\\)，那么可以改写成\r\n\\[\\begin{aligned}\r\n\\int_0^r\\int_0^rf(\\min(r_1,r_2))dr_1dr_2&amp;=2\\int_0^r\\int_{r_1}^rf(r_1)dr_2dr_1\\\\\r\n&amp;=2(r\\int_0^rf(r_1)dr_1-\\int_0^rr_1f(r_1)dr_1)\\\\\r\n&amp;=2(r\\int_F^rf(x)dx-\\int_F^rxf(x)dx)\r\n\\end{aligned}\\]\r\n重新代入上式，那么我们就得到了一个关于\\(f(r)\\)的积分方程：\r\n\\[r^2f(r)=r^2+2(r\\int_F^rf(x)dx-\\int_F^rxf(x)dx)\\qquad(1)\\]\r\n将其转化成微分方程求解。那么两边对\\(r\\)求一次导得到：\r\n\\[r^2f&#39;(r)+2rf(r)=2r+2(\\int_F^rf(x)dx+rf(r)-rf(r))\\]\r\n化简后，两边再对\\(r\\)求一次导，最终化简得到：\r\n\\[r^2f&#39;&#39;(r)+4rf&#39;(r)=2\\]\r\n在Mathematica中使用如下代码解上面的微分方程：\r\nDSolve[r^2*f&#x27;&#x27;[r] + 4 r *f&#x27;[r] == 2, f[r], r]\r\n最终得到这个微分方程的通解\\(f(r)\\)为：\r\n\\[f(r)=\\dfrac{\\ln\r\nr}{3}-\\dfrac{c_1}{3r^3}+c_2\\qquad(2)\\]\r\n将\\((2)\\)回代到\\((1)\\)，利用恒等的性质，并令\\(x=\\dfrac{1}{F}\\)，最终得到：\r\n\\(f(r)=\\dfrac{1}{9}(\\dfrac{2}{x^3r^3}+6\\ln\r\nxr+7)\\)\r\n那么\\(f(1)\\)就是所求值，\\(E(x)=\\dfrac{2x^3}{9}+\\dfrac{2\\ln\r\nx}{3}+\\dfrac{7}{9}\\)\r\n代码\r\nfrom math import logX = 40ans = 2 / 9 / X ** 3 + 2 * log(X) / 3 + 7 / 9print(&quot;&#123;:.10f&#125;&quot;.format(ans))\r\n","categories":["Project Euler"],"tags":["动态规划","概率"]},{"title":"Project Euler 395","url":"/project-euler/395/","content":"\r\nProject Euler 395\r\n题目\r\nPythagorean tree\r\nThe Pythagorean tree is a fractal generated by the\r\nfollowing procedure: Start with a unit square. Then, calling one of the\r\nsides its base (in the animation, the bottom side is the base):\r\n\r\nAttach a right triangle to the side opposite the base, with the\r\nhypotenuse coinciding with that side and with the sides in a 3-4-5\r\nratio. Note that the smaller side of the triangle must be on the ‘right’\r\nside with respect to the base (see animation).\r\nAttach a square to each leg of the right triangle, with one of its\r\nsides coinciding with that leg.\r\nRepeat this procedure for both squares, considering as their bases\r\nthe sides touching the triangle.\r\n\r\nThe resulting figure, after an infinite number of iterations, is the\r\nPythagorean tree.\r\n\r\nIt can be shown that there exists at least one rectangle, whose sides\r\nare parallel to the largest square of the Pythagorean tree, which\r\nencloses the Pythagorean tree completely.\r\nFind the smallest area possible for such a bounding rectangle, and\r\ngive your answer rounded to \\(10\\)\r\ndecimal places.\r\n解决方案\r\n将图形进行多次迭代后，得到了以下大概的一个轮廓：\r\n\r\n考虑使用广度优先搜索的过程进行迭代。\r\n我设计了一个阈值：在迭代过程中，如果正方形的长度小于阈值，那么停止迭代。需要注意的是，阈值的选择需要得当，否则勾股树的左下方那一部分长度可能会被忽略。\r\n在计算点的过程中还需要比较小心。以第一轮为例，正方形上方这将会产生一个直角三角形。直角顶点的坐标的计算方式是将直角三角形的斜边绕左边的点逆时针旋转约\\(37°\\)，然后再将边长缩减到原来的\\(0.8\\)倍得到。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;const double eps = 1e-15;double minx = 0, miny = 0, maxx = 1, maxy = 1;double leftRotate = acos(0.8);//直接将正方形的下边旋转约180-53度。double rightRotate = -acos(0.6);double tag = 5;struct Square &#123;    double len, x, y, rad;&#125;;int main() &#123;    queue&lt;Square&gt; q;    q.push(&#123;1, 0, 0, 0&#125;);    while (!q.empty()) &#123;        Square prm = q.front();q.pop();        //正方形左下角的点。        double len = prm.len, ldx = prm.x, ldy = prm.y, rad = prm.rad;        minx = min(minx, ldx);        maxx = max(maxx, ldx);        miny = min(miny, ldy);        maxy = max(maxy, ldy);        double cosrad = cos(rad);        double sinrad = sin(rad);        double dx = len * cosrad;        double dy = len * sinrad;        //正方形左上角的点。        double lux = ldx - dy, luy = ldy + dx;        //正方形位于上边上面的新点。        double tx = lux + ((dx * 0.8) - (dy * 0.6)) * 0.8,ty = luy + ((dx * 0.6) + (dy * 0.8)) * 0.8;        if (len * 0.8 &gt; eps) &#123;            double pl = len * tag * 0.8;            if (lux &gt; maxx - pl || lux &lt; minx + pl || luy &gt; maxy - pl || luy &lt; miny + pl) &#123;                q.push(&#123;len * 0.8, lux, luy, rad + leftRotate&#125;);            &#125;            if (len * 0.6 &gt; eps) &#123;                pl = len * tag * 0.6;                if (tx &gt; maxx - pl || tx &lt; minx + pl || ty &gt; maxy - pl || ty &lt; miny + pl) &#123;                    q.push(&#123;len * 0.6, tx, ty, rad + rightRotate&#125;);                &#125;            &#125;        &#125;    &#125;    double ans = (maxx - minx) * (maxy - miny);    printf(&quot;%.10f\\n&quot;, ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 4","url":"/project-euler/4/","content":"\r\nProject Euler 4\r\n题目\r\nLargest palindrome product\r\nA palindromic number reads the same both ways. The largest palindrome\r\nmade from the product of two \\(2\\)-digit numbers is \\(9009 = 91 \\times 99\\).\r\nFind the largest palindrome made from the product of two \\(3\\)-digit numbers.\r\n解决方法\r\n直接枚举所有的三位数和三位数的乘积，然后再判断乘积的值是否为回文字符串即可。\r\n代码\r\nN = 3ans = 0for i in range(10**(N-1), 10**N):    for j in range(10**(N-1), 10**N):        s = i * j        if str(s) == str(s)[::-1]:            ans = max(ans, s)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 40","url":"/project-euler/40/","content":"\r\nProject Euler 40\r\n题目\r\nChampernowne’s constant\r\nAn irrational decimal fraction is created by concatenating the\r\npositive integers:\r\n\r\n0.123456789101112131415161718192021…\r\n\r\nIt can be seen that the \\(12\\)th digit of the fractional\r\npart is \\(1\\).\r\nIf \\(d_n\\) represents the \\(n\\)th digit of the fractional\r\npart, find the value of the following expression.\r\n\\[d_1\\times d_{10} \\times d_{100} \\times\r\nd_{1000} \\times d_{10000} \\times d_{100000}\\times\r\nd_{1000000}\\]\r\n解决方案\r\n每一个\\(d_i\\)都是一个独立的问题，可以先计算后再相乘。\r\n可以发现，\\(1\\sim 9,10\\sim 99,100\\sim\r\n999,\\dots,10^{n-1}\\sim\r\n10^n-1,\\dots\\)，每一块都里面的数有相同的长度，而且，每一块的长度增长都是为\\(1\\)。\r\n因此，计算每一个独立的\\(d_i\\)时，先找到第\\(i\\)位属于那一块，然后再判断第\\(i\\)位属于哪一个数，之后直接相乘即可。\r\n代码\r\nfrom itertools import countque = [10 ** i for i in range(7)]def cal(x: int):    x -= 1    for i in count(1, 1):        l = 10 ** (i - 1)        r = 10 ** i - 1        if x &gt;= (r - l + 1) * i:            x -= (r - l + 1) * i        else:            d, pos = divmod(x, i)            val = d + l            ans = int(str(val)[pos])            break    return ansans = 1for x in que:    ans *= cal(x)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 401","url":"/project-euler/401/","content":"\r\nProject Euler 401\r\n题目\r\nSum of squares of divisors\r\nThe divisors of \\(6\\) are \\(1,2,3\\) and \\(6\\).\r\nThe sum of the squares of these numbers is \\(1+4+9+36=50\\).\r\nLet \\(\\text{sigma2}(n)\\) represent\r\nthe sum of the squares of the divisors of n. Thus \\(\\text{sigma2}(6)=50\\).\r\nLet \\(\\text{SIGMA2}\\) represent the\r\nsummatory function of \\(\\text{sigma2}\\), that is \\(\\text{SIGMA2}(n)=\\sum\\text{ sigma2}(i)\\)\r\nfor \\(i=1\\) to \\(n\\).\r\nThe first \\(6\\) values of SIGMA2\r\nare: \\(1,6,16,37,63\\) and \\(113\\).\r\nFind \\(\\text{SIGMA2}(10^{15}) \\text{ modulo\r\n} 10^9\\).\r\n数论分块\r\n这种方法一般用于计算关于某个函数\\(f\\)（\\(f\\)的前缀和\\(s(n)\\)可以很轻松地算出来）的下面的表达式：\r\n\\[g(n)=\\sum_{d=1}^nf(d)\\cdot\r\n\\left\\lfloor\\dfrac{n}{d}\\right\\rfloor\\]\r\n对于\\(d\\)任意不同的取值，\\(\\left\\lfloor\\dfrac{n}{d}\\right\\rfloor\\)只有\\(O(\\sqrt{n})\\)个值。\r\n一个块如果下标从\\(i\\)开始，那么到\\(\\left\\lfloor\\dfrac{n}{\\left\\lfloor\\frac{n}{i}\\right\\rfloor}\\right\\rfloor\\)才结束，而这块内部的所有\\(\\left\\lfloor\\dfrac{n}{d}\\right\\rfloor\\)都是相同的。下一个块的起点为\\(\\left\\lfloor\\dfrac{n}{\\left\\lfloor\\frac{n}{i}\\right\\rfloor}\\right\\rfloor+1\\)开始，这些块是首尾相接的。\r\n因此，从下标\\(i=1\\)开始，枚举计算每一块的\\(f\\)函数之和，并求和，用表达式来表示就是：\r\n\\[g(n)=\\sum_{k}\\left\\lfloor\\dfrac{n}{k}\\right\\rfloor\\cdot\\left(s\\left(\\left\\lfloor\\dfrac{n}{\\left\\lfloor\\frac{n}{k}\\right\\rfloor}\\right\\rfloor\\right)-s(k-1)\\right)\\]\r\n其中\\(k\\)是每一块的起点。\r\n解决方案\r\n不难想到每个因子\\(d\\)在\\(1\\sim n\\)中出现的次数总共为\\(\\left\\lfloor\\dfrac{n}{d}\\right\\rfloor\\)次。\r\n因此\\(\\text{SIGMA2}(n)=\\sum_{i=1}^n\\left\\lfloor\\dfrac{n}{d}\\right\\rfloor\\cdot\r\nd^2\\)。\r\n代入数论分块中，\\(f(n)=n^2\\)，那么就有\\(s(n)=\\dfrac{n(n+1)(2n+1)}{6}\\)，使用前缀和的思想相减。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll N=1e15;ll mod=1e9;ll inv3=666666667;ll f(ll n)&#123;    n%=mod;    return n*(n+1)/2%mod*(n+n+1)%mod*inv3%mod;&#125;int main()&#123;    ll ans=0,x;    for(x=1;x*x&lt;=N;x++)&#123;        ans=(ans+N/x%mod*x%mod*x)%mod;    &#125;    for(ll y;x&lt;=N;x=y+1)&#123;        y=N/(N/x);        ll c=(N/x)%mod;        ans=(ans+(f(y)-f(x-1)+mod)*c)%mod;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["数论分块"]},{"title":"Project Euler 405","url":"/project-euler/405/","content":"\r\nProject Euler 405\r\n题目\r\nA rectangular tiling\r\nWe wish to tile a rectangle whose length is twice its width.\r\nLet \\(T(0)\\) be the tiling\r\nconsisting of a single rectangle.\r\nFor \\(n &gt; 0\\), let \\(T(n)\\) be obtained from \\(T(n-1)\\) by replacing all tiles in the\r\nfollowing manner:\r\n\r\nThe following animation demonstrates the tilings \\(T(n)\\) for \\(n\\) from \\(0\\) to \\(5\\):\r\n\r\nLet \\(f(n)\\) be the number of points\r\nwhere four tiles meet in \\(T(n)\\).\r\nFor example, \\(f(1) = 0, f(4) = 82\\)\r\nand \\(f(10^9) \\bmod 17^7 =\r\n126897180\\).\r\nFind \\(f(10^k)\\) for \\(k = 10^{18}\\), give your answer modulo\r\n\\(17^7\\).\r\n解决方案\r\n可以发现，铺法\\(T(n)\\)的另一种导出方式如图所示：\r\n\r\n它将\\(4\\)个相同的\\(T(n-1)\\)按照如上的方式铺设而成。\r\n考虑用动态规划的方法解决本题。使用一个辅助状态\\(g(n)(n\\ge 0)\\)来表示当前铺法\\(T(n)\\)较长的边上的顶点个数（不包括角上的那\\(2\\)个顶点）。那么按照当前铺法，\\(T(n)\\)较短的边上的点的个数为\\(g(n-1)\\)。\r\n那么不难写出\\(g(n)\\)的状态转移方程：\r\n\\[g(n)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0 &amp; &amp; \\text{if}\\quad  n=0 \\\\\r\n  &amp;2 &amp; &amp; \\text{else if}\\quad  n=1 \\\\\r\n  &amp;g(n-1)+2g(n-2)+2&amp; &amp;\r\n\\text{else}\r\n\\end{aligned}\\right.\\]\r\n其中，\\(g(n)\\)的第三行中的第二项表示\\(2\\)个\\(T(n-1)\\)上较短的边的顶点个数，第三项表示新产生的\\(2\\)个顶点，如图所示青色的两个点。\r\n根据\\(g(n)\\)，不难写出状态\\(f(n)\\)的状态转移方程：\r\n\\[f(n)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0 &amp; &amp; \\text{if}\\quad  n\\le 1 \\\\\r\n  &amp;4f(n-1)+g(n-1)+2g(n-2)&amp; &amp;\r\n\\text{else}\r\n\\end{aligned}\\right.\\]\r\n显而易见，\\(4f(n-1)\\)是指\\(4\\)个\\(T(n-1)\\)铺法内部的点；\\(g(n-1)\\)则是中间两个\\(T(n-1)\\)的长边接触所产生的新点（如上图绿色线所标记，铺法\\(T\\)是上下左右对称的，因此只要长边上有的点都会被计入\\(f(n)\\)）；而对于第三项，由下图可以知道，在一侧，矩形是按照\\(1,2,1,2,1\\dots\\)的长度铺放，而另外一侧则是\\(2,1,2,1,2,\\dots\\)因此，在铺法\\(T(n)\\)下，一条橙色边的短边尽管有\\(g(n-2)\\)个点，但是仅有\\(\\dfrac{g(n-2)}{2}\\)的点和另外一侧是有相交的。因此根据上图有\\(4\\)条橙色边，由此得到第三个项\\(g(n-2)\\)。\r\n\r\n由于所求目标值\\(f(10^{10^{18}})\\)过大，因此考虑求出\\(f(n)\\)的通项公式。\r\n在Mathematica先使用如下命令求出\\(g(n)\\)：\r\nRSolve[&#123;g[n] == g[n - 1] + 2*g[n - 2] + 2, g[0] == 0, g[1] == 2&#125;, g[n], n]\r\n得到\\(g(n)\\)的通项公式为：\r\n\\[g(n)=\\dfrac{(-1)^{n+1}+2^{n+2}}{3}-1\\]\r\n再度运行如下命令求出\\(f(n)\\)：\r\ng[n_] := 1/3 (-3 + (-1)^(1 + n) + 2^(2 + n))RSolve[&#123;f[n] == 4 f[n - 1] + g[n - 1] + 2*g[n - 2], f[0] == 0, f[1] == 0&#125;, f[n], n]\r\n最终得到：\r\n\\[f(n) = \\dfrac{(-1)^{n+1} - 5 \\cdot\r\n2^{n+2} + 6 \\cdot 4^n}{15}  + 1\\]\r\n使用费马小定理直接优化计算过程即可。\r\n代码\r\nfrom tools import phi, mod_inverseK = 10 ** 18mod = 17 ** 7ph = phi(mod)t = pow(10, K, ph)u = pow(-1, t + 1, mod) - 20 * pow(2, t, mod) + 6 * pow(4, t, mod)v = mod_inverse(15, mod)ans = (u * v + 1) % modprint(ans)\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 402","url":"/project-euler/402/","content":"\r\nProject Euler 402\r\n题目\r\nInteger-valued polynomials\r\nIt can be shown that the polynomial \\(n^4 +\r\n4n^3 + 2n^2 + 5n\\) is a multiple of \\(6\\) for every integer \\(n\\). It can also be shown that \\(6\\) is the largest integer satisfying this\r\nproperty.\r\nDefine \\(M(a, b, c)\\) as the maximum\r\n\\(m\\) such that \\(n^4 + an^3 + bn^2 + cn\\) is a multiple of\r\n\\(m\\) for all integers \\(n\\). For example, \\(M(4, 2, 5) = 6\\).\r\nAlso, define \\(S(N)\\) as the sum of\r\n\\(M(a, b, c)\\) for all \\(0 &lt; a, b, c \\le N\\).\r\nWe can verify that \\(S(10) = 1972\\)\r\nand \\(S(10000) = 2024258331114\\).\r\nLet \\(F_k\\) be the Fibonacci\r\nsequence:\r\n\\(F_0 = 0, F_1 = 1\\) and\r\n\\(F_k = F_{k-1} + F_{k-2}\\) for\r\n\\(k \\ge 2\\).\r\nFind the last \\(9\\) digits of \\(\\sum S(F_k)\\) for \\(2 \\le k \\le 1234567890123\\).\r\n解决方案\r\n令\\(p(n)=n^4 + an^3 + bn^2 +\r\ncn,m=10^9\\)。那么可以得到\\(\\gcd(p(-1)+p(1),p(-2)+p(2))=\\gcd(2b+2,8b+32)=2\\gcd(b+1,12)\\)。\r\n也就是说，\\(M\\in\\{1,2,3,4,6,8,12,24\\}\\)。\r\n由于\\(24=3\\cdot\r\n2^3\\)，经过多次打表实验，可以得到如下结论：\r\n\\(\\begin{aligned}\r\n&amp;3\\mid M(a,b,c)\\Longleftrightarrow b\\equiv 2\\pmod 3 \\land(a+c)\\equiv\r\n0\\pmod 3;\\\\\r\n&amp;2\\mid M(a,b,c)\\Longleftrightarrow (a+b+c)\\equiv 1\\pmod 2;\\\\\r\n&amp;4\\mid M(a,b,c)\\Longleftrightarrow a\\equiv c\\equiv0\\pmod 2\\land\r\n(a+b+c)\\equiv 3\\pmod 4\\\\\r\n&amp;8\\mid M(a,b,c)\\Longleftrightarrow a\\equiv c\\equiv2\\pmod 4\\land\r\n(a+b+c)\\equiv 7\\pmod 8\\\\\r\n\\end{aligned}\\)\r\n那么，接下来的任务是以\\(O(1)\\)的时间复杂度计算\\(S(N)\\)。由于\\(a,b,c\\)的值都是模\\(24\\)相等的，因此我们可以将整个\\(N\\times N\\times N\\)的输入以\\(24\\times24\\times24\\)的大小进行划分。令\\(q=\\left\\lfloor\\dfrac{N}{24}\\right\\rfloor,r=N\\%24\\)，那么每一个\\(24\\times24\\times24\\)方块内部答案的总和都是相等的。\r\n因此，对于模数\\(m\\)，序列\\(S(n)\\% m\\)的周期为\\(24m\\)。可知序列\\(F_n\\%m\\)也是周期性的，并且\\(24m\\)一定是其中一个周期，因此我们考虑枚举\\(F_n\\%24m&#39;\\)的循环节。\r\n此外，由于\\(m=2^9\\cdot\r\n5^9\\)，因此我们可以分成两部分去求解这个问题：分别求解\\(S(n)\\% 2^9\\)和\\(S(n)\\%\r\n5^9\\)的值后，再用中国剩余定理进行合并，最终得到答案。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;# include &quot;tools.h&quot;using namespace std;typedef long long ll;const ll N=1234567890123;const ll mod = 1000000000;const int B=24;int M(int a,int b,int c)&#123;    int w=1;    if(b%3==2&amp;&amp;(a+c)%3==0) w*=3;    if(a%4==2&amp;&amp;c%4==2&amp;&amp;(a+b+c)%8==7) w*=8;    else if(a%2==0&amp;&amp;c%2==0&amp;&amp;(a+b+c)%4==3) w*=4;    else if((a+b+c)%2==1) w*=2;    return w;&#125;int s[B][B][B];ll z[4][B]=&#123;0&#125;;void init()&#123;    for(int a=1;a&lt;=B;a++)        for(int b=1;b&lt;=B;b++)            for(int c=1;c&lt;=B;c++)&#123;                int m=M(a,b,c);                for(int j=0;j&lt;B;j++)&#123;                    z[0][j]+=m;                    z[1][j]+=m*((j&gt;=a)+(j&gt;=b)+(j&gt;=c));                    z[2][j]+=m*((j&gt;=max(a,b))+(j&gt;=max(a,c))+(j&gt;=max(b,c)));                    if(j&gt;=a&amp;&amp;j&gt;=b&amp;&amp;j&gt;=c) z[3][j]+=m;                &#125;            &#125;&#125;ll S(ll n,ll mod)&#123;    ll q=n/B,r=n%B;    q%=mod;    return (z[0][r]*qpow(q,3,mod)%mod+z[1][r]*qpow(q,2,mod)%mod+z[2][r]*q%mod+z[3][r])%mod;&#125;ll cal(ll n,ll mod)&#123;    ll q=n/(mod*B),r=n%(mod*B);    ll T=min(mod*B,n);    ll a=0,b=1;    ll all=0,res=0;    for(int i=0;i&lt;T;i++)&#123;        ll k=S(b,mod);        all=(all+k)%mod;        if(i&lt;r) res=(res+k)%mod;        ll t=(a+b)%(mod*B);        a=b;b=t;    &#125;    ll ans=(q%mod*all%mod+res-S(1,mod)+mod)%mod;    return ans;&#125;int main()&#123;    init();    vector&lt;ll&gt;mod_list,res_list;    for(auto &amp;[p,e]:fact(ll_2_mpz(mod)))&#123;        mod_list.push_back(qpow_mpz(mpz_2_ll(p),e));    &#125;    for(ll p:mod_list) res_list.push_back(cal(N,p));    ll ans=CRT(mod_list,res_list);    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 417","url":"/project-euler/417/","content":"\r\nProject Euler 417\r\n题目\r\nReciprocal cycles II\r\nA unit fraction contains 1 in the numerator. The decimal\r\nrepresentation of the unit fractions with denominators 2 to 10 are\r\ngiven:\r\n\\(\\begin{aligned}\r\n&amp;\\dfrac{1}{2}=0.5\\\\\r\n&amp;\\dfrac{1}{3}=0.(3)\\\\\r\n&amp;\\dfrac{1}{4}=0.25\\\\\r\n&amp;\\dfrac{1}{5}=0.2\\\\\r\n&amp;\\dfrac{1}{6}=0.1(6)\\\\\r\n&amp;\\dfrac{1}{7}=0.(142857)\\\\\r\n&amp;\\dfrac{1}{8}=0.125\\\\\r\n&amp;\\dfrac{1}{9}=0.(1)\\\\\r\n&amp;\\dfrac{1}{10}=0.1\\\\\r\n\\end{aligned}\\)\r\nWhere \\(0.1(6)\\) means \\(0.166666\\dots\\), and has a \\(1\\)-digit recurring cycle. It can be seen\r\nthat \\(\\dfrac{1}{7}\\) has a \\(6\\)-digit recurring cycle.\r\nUnit fractions whose denominator has no other prime factors than\r\n\\(2\\) and/or \\(5\\) are not considered to have a recurring\r\ncycle.\r\nWe define the length of the recurring cycle of those unit fractions\r\nas \\(0\\).\r\nLet \\(L(n)\\) denote the length of\r\nthe recurring cycle of \\(\\dfrac{1}{n}\\).\r\nYou are given that \\(\\sum L(n)\\) for\r\n\\(3 \\le n \\le 1 000 000\\) equals \\(55535191115\\).\r\nFind \\(\\sum L(n)\\) for \\(3 \\le n \\le 100 000 000\\).\r\n解决方案\r\n根据有理数上有理数的除法，不难发现，\\(L(n)=L(2n)=L(5n)\\)。那么本题我们仅需考虑\\(L(n)\\)，其中\\(2,5\\nmid n\\)。\r\n这个页面指出，如果\\(n\\)的分解质因数为\\(n=\\prod_{i=1}^k p_i^{e_i}\\)，那么\\(L(n)=\\text{lcm}(L(p_1^{e_1}),L(p_2^{e_2}),\\dots,L(p_k^{e_k}))\\)。此外，这个页面还提到，绝大多数情况下，\\(L(p^e)=p\\cdot L(p^{e-1})\\)，除了\\(p^e=3,487,56598313\\)这几个数（OEIS页面为A045616），这是因为\\(p^2\\mid 10^{p-1}-1\\)。\r\n那么现在问题就是求\\(L(p)\\)，其中\\(p\\)是不为\\(2,5\\)的质数。本质上，\\(L(p)\\)的值相当于元素\\(10\\)在乘法群\\(\\mathbb{Z}_p^{\\ast}\\)上的阶\\(\\lambda_p(10)\\)。因此，一开始假设\\(\\lambda_p(10)=p-1\\)。枚举\\(p-1\\)的每个质因子\\(q\\)，尝试对\\(\\lambda_p(10)\\)除\\(q\\)。当发现\\(10^{\\lambda_p(10)}\\%p\\)不为\\(1\\)时，保留原来的值并停止。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=100000000;int v[N+4],pr[N/10+1000],m=0;int L[N+4];ll qpow(ll n,ll m,ll mod)&#123;    ll a=1;    for(;m;m&gt;&gt;=1)&#123;        if(m&amp;1) a=a*n%mod;        n=n*n%mod;    &#125;    return a;&#125;int main()&#123;    for(int i=2;i&lt;=N;i++)&#123;        if(v[i]==0)&#123;            v[i]=i;pr[++m]=i;        &#125;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;N/i) break;            v[i*pr[j]]=pr[j];        &#125;    &#125;    ll ans=0;    for(int n=3;n&lt;=N;n++)&#123;        int m=n;        for(;m%2==0;m&gt;&gt;=1);        for(;m%5==0;m/=5);        if(m&lt;n) L[n]=L[m];        else&#123;            if(v[n]==n)&#123;                L[n]=n-1;                ll x=n-1;                for(;x!=1;)&#123;                    int p=v[x];                    for(;x%p==0;x/=p);                    for(;L[n]%p==0&amp;&amp;qpow(10,L[n]/p,n)==1;L[n]/=p);                &#125;            &#125;else&#123;                int p=v[m];                for(;m%p==0;m/=p);                if(m==1&amp;&amp;(n/p==3||n/p==487)) L[n]=L[n/p];                else if(m==1) L[n]=L[n/p]*p;                else L[n]=lcm(L[m],L[n/m]);            &#125;        &#125;        ans+=L[n];    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 41","url":"/project-euler/41/","content":"\r\nProject Euler 41\r\n题目\r\nPandigital prime\r\nWe shall say that an \\(n\\)-digit\r\nnumber is pandigital if it makes use of all the digits \\(1\\) to \\(n\\) exactly once. For example, \\(2143\\) is a \\(4\\)-digit pandigital and is also prime.\r\nWhat is the largest \\(n\\)-digit\r\npandigital prime that exists?\r\n解决方案\r\n观察前\\(9\\)项\\(1\\sim n\\)中所有数之和\\(p(n)=\\dfrac{n(n+1)}{2}\\)的值：\r\n\\[1,3,6,10,15,21,28,36,45\\]\r\n可以发现，当\\(n\\neq 1,4,7\\)时，\\(p(n)\\equiv 0 \\pmod 3\\)。\r\n这说明在其它情况下，无论里面的数位排列如何，它们都是\\(3\\)的倍数，故对这一部分的数不需要进行判断。\r\n对于剩下的数，用itertools库中的permutations对每一个排列进行遍历，并判断拼成的数是不是质数。\r\n判断大质数使用gmpy2中的is_prime，它会以\\(2^{-64}\\)的概率将一个合数判断成质数。这个函数将会封装在自定义的tools工具包中。\r\n代码\r\nfrom itertools import permutationsfrom gmpy2 import is_primels = [7, 4, 1]ok = Falsefor n in ls:    per = permutations([n - i for i in range(n)])    for p in per:        w = int(&quot;&quot;.join(str(x) for x in p))        if is_prime(w):            ans = w            ok = True            break    if ok:        breakprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 407","url":"/project-euler/407/","content":"\r\nProject Euler 407\r\n题目\r\nIdempotents\r\nIf we calculate \\(a^2 \\bmod 6\\) for\r\n\\(0 \\le a \\le 5\\) we get: \\(0,1,4,3,4,1\\).\r\nThe largest value of a such that \\(a^2 ≡ a\r\n\\bmod 6\\) is \\(4\\).\r\nLet’s call \\(M(n)\\) the largest\r\nvalue of \\(a &lt; n\\) such that \\(a^2 \\equiv a \\pmod n\\). So \\(M(6) = 4\\).\r\nFind \\(\\sum M(n)\\) for \\(1 \\le n \\le 10^7\\).\r\n解决方案\r\n可以得到，原方程可以化简为：\r\n\\[a(a-1)\\equiv 0\\pmod\r\nn\\qquad(1)\\]\r\n由于\\(\\gcd(a,a-1)=1\\)，假设\\(n\\)的分解质因数为\\(n=\\prod_{i=1}^{k}\r\np_i^{e_i}\\)，那么对于任意一个\\(p_i^{e_i}\\)，要么\\(p_i^{e_i}\\mid a\\)，要么\\(p_i^{e_i}\\mid (a-1)\\)。\r\n那么枚举\\(\\{1,2,\\dots,k\\}\\)的所有子集\\(\\{i_1,i_2,\\dots,i_m\\}\\)，令\\(m_1=\\prod_{j=1}^mp_{i_j}^{e_{i_j}},m_2=\\dfrac{n}{m_1}\\)，那么方程\\((1)\\)的一个解\\(a\\)就可以通过这个方程组构造出来：\r\n\\[\\left \\{\\begin{aligned}\r\n  &amp; a\\equiv 0\\pmod {m_1}\\\\\r\n  &amp; a\\equiv 1\\pmod {m_2}\\\\\r\n\\end{aligned}\\right.\\]\r\n那么\\(a\\)可以很简单地表示成\\(a=m_1\\cdot \\text{inv}(m_1,m_2)\\)，其中\\(\\text{inv}(a,m)\\)表示\\(a\\%m\\)在群\\(\\mathbb{Z}_m^{\\ast}\\)上的逆元。\r\n此外，为了能够尽快分解质因数，我们首先将\\(N=10^7\\)以内的所有数的最大质因数\\(g(n)\\)求出，在正式分解\\(N\\)的时候能够根据\\(g(n)\\)有效加速。\r\n最终，直接枚举每个\\(n\\)并求解即可。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=1e7;int mxp[N+4],r[14],m;int inv(int a,int m)&#123; int b=m,x=1,y=0,t; while(b)&#123;  int q=a/b;  t=a-q*b;a=b;b=t;  t=x-q*y;x=y;y=t; &#125; return x&lt;0?x+m:x;&#125;int main()&#123;    for(int p=2;p&lt;=N;p++)        if(!mxp[p])            for(int i=p;i&lt;=N;i+=p) mxp[i]=p;    ll ans=0;    for(int n=1;n&lt;=N;n++)&#123;        m=0;        for(int x=n;x!=1;)&#123;            int w=1,p=mxp[x];            for(;x%p==0;x/=p,w*=p);            r[m++]=w;        &#125;        ll mx=0;        for(int s=0;s&lt;(1&lt;&lt;m);s++)&#123;            ll m1=1,m2=1;            for(int i=0;i&lt;m;i++)                s&gt;&gt;i&amp;1?m1*=r[i]:m2*=r[i];            mx=max(mx,m1*inv(m1,m2));        &#125;        ans+=mx;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 409","url":"/project-euler/409/","content":"\r\nProject Euler 409\r\n题目\r\nNim Extreme\r\nLet \\(n\\) be a positive integer.\r\nConsider nim positions where:\r\n\r\nThere are \\(n\\) non-empty\r\npiles.\r\nEach pile has size less than \\(2^n\\).\r\nNo two piles have the same size.\r\n\r\nLet \\(W(n)\\) be the number of\r\nwinning nim positions satisfying the above conditions (a position is\r\nwinning if the first player has a winning strategy). For example, \\(W(1) = 1, W(2) = 6, W(3) = 168, W(5) =\r\n19764360\\) and \\(W(100) \\bmod\r\n1 000 000 007 = 384777056\\).\r\nFind \\(W(10 000 000) \\bmod\r\n1 000 000 007\\).\r\n解决方案\r\n关于这个NIM博弈的页面，给出了一个更一般的方法用来判断当前游戏状态是必胜态还是必败态：\r\n假设一共有\\(n\\)堆石头，每一堆的个数为\\(a_i\\)。那么游戏是必败态时，当且仅当\r\n\\[\\bigoplus_{i=1}^n a_i=a_1\\oplus\r\na_2\\oplus a_3 \\oplus\\dots\\oplus a_n=0\\]\r\n其中\\(\\oplus\\)是异或运算。\r\n那么根据这个前置知识，考虑如下问题：\r\n有多少个长度为\\(m\\)的序列\\(\\{x\\}\\)，满足：\r\n\r\n\\(x_i\\)的数值两两不同。\r\n\\(\\forall i\\in[1,n],0&lt;\r\nx_i&lt;2^n\\)\r\n\\(x_1\\oplus x_2\\oplus x_3\r\n\\oplus\\dots\\oplus x_m=0\\)\r\n\r\n用\\(f_n(m)\\)来表示这个序列对个数。\r\n如果我们直接任意取前\\(m-1\\)个数，再令\\(x_{m}=\\bigoplus_{i=1}^{m-1}\r\nx_i\\)，那么答案很明显为\\(\\displaystyle{A_{2^n-1}^{m-1}=\\dfrac{(2^n-1)!}{(2^n-m)!}}\\)，令\\(g_n(m)=A_{2^n-1}^{m-1}\\)。\r\n那么我们考虑从\\(g_n(k)\\)排除掉一些情况从而得到\\(f_n(k)\\)。本题求解\\(f_n(k)\\)的使用了动态规划的思想：\r\n\r\n如果前\\(k-1\\)个数满足\\(\\bigoplus_{i=1}^{k-1}\r\nx_i=0\\)，那么说明\\(x_{k}=0\\)，不符合第\\(2\\)个条件。这种情况一共有\\(f_n(k-1)\\)种。\r\n如果前\\(k-1\\)个数满足\\(\\bigoplus_{i=1}^{k-1} x_i=x_j\\)，其中\\(j\\in [1,k-1]\\)，那么说明\\(x_{k}=x_j\\)，不符合第\\(1\\)个条件。这也意味着：\\(x_1\\oplus x_2\\oplus \\dots \\oplus x_{j-1}\\oplus\r\nx_{j+1}\\oplus \\dots \\oplus x_{k-1}=0\\)。这一类情况一共有\\(f_n(k-2)\\cdot (k-1) \\cdot\r\n(2^n-1-(k-2))\\)情况，其中这个式子的第二项是指\\(j\\)有\\(k-1\\)种取法，第三项是指\\(x_j\\)可以取遍除了\\(x\\)序列中的\\(k-2\\)个数，剩下的\\(2^n-1-(k-2)\\)个数。\r\n\r\n根据上面的内容，不难写出\\(f_n(k)\\)的递推式为：\r\n\\[f_n(k)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1 &amp; &amp; \\text{if}\\quad  k=0 \\\\\r\n  &amp;g_n(k)-f_n(k-1) &amp; &amp; \\text{else if}\\quad  k=1 \\\\\r\n  &amp;g_n(k)-f_n(k-1)-f_n(k-2)\\cdot (k-1)\\cdot (2^n-k+1)&amp; &amp;\r\n\\text{else}\r\n\\end{aligned}\\right.\\]\r\n那么整道题的最终答案为\r\n\\[g_n(n)-f_n(n)\\]\r\n代码\r\n# include &lt;bits/stdc++.h&gt;# include &quot;tools.h&quot;using namespace std;typedef long long ll;const int N=10000000;ll mod=1000000007;ll f[N+4];int main()&#123;    f[0]=1;    ll g=1,pw2=qpow(2,N,mod);    for(int i=1;i&lt;=N;i++)&#123;        f[i]=(g-f[i-1]+mod)%mod;        if(i&gt;=2) f[i]=(f[i]-f[i-2]*(i-1)%mod*(pw2-i+1+mod)%mod+mod)%mod;        g=g*(pw2-i+mod)%mod;    &#125;    ll ans=(g-f[N]+mod)%mod;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划","博弈论"]},{"title":"Project Euler 42","url":"/project-euler/42/","content":"\r\nProject Euler 42\r\n题目\r\nCoded triangle numbers\r\nThe \\(n^{\\text{th}}\\) term of the\r\nsequence of triangle numbers is given by, \\(t_n = \\dfrac{n(n+1)}{2}\\); so the first ten\r\ntriangle numbers are: \\[1, 3, 6, 10, 15, 21,\r\n28, 36, 45, 55, \\dots\\]\r\nBy converting each letter in a word to a number corresponding to its\r\nalphabetical position and adding these values we form a word value. For\r\nexample, the word value for SKY is \\(19 + 11 +\r\n25 = 55 = t_{10}\\). If the word value is a triangle number then\r\nwe shall call the word a triangle word.\r\nUsing words.txt(right click\r\nand ‘Save Link/Target As…’), a 16K text file containing nearly\r\ntwo-thousand common English words, how many are triangle words?\r\n解决方案\r\n先将三角形数直接添加到集合，然后计算每个单词的分值，再判断分值是否在集合中。\r\n代码\r\nls = [s[1:-1] for s in open(&#x27;p042_words.txt&#x27;, &#x27;r&#x27;).readlines()[0].split(&#x27;,&#x27;)]st = set()for i in range(1, 41):    st.add(i * (i + 1) // 2)ans = 0for s in ls:    sum = 0    for c in s:        sum += ord(c) - ord(&#x27;A&#x27;) + 1    if sum in st:        ans += 1print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 421","url":"/project-euler/421/","content":"\r\nProject Euler 421\r\n题目\r\nPrime factors of \\(n^{15}+1\\)\r\nNumbers of the form \\(n^{15}+1\\) are\r\ncomposite for every integer \\(n &gt;\r\n1\\).\r\nFor positive integers \\(n\\) and\r\n\\(m\\) let \\(s(n,m)\\) be defined as the sum of the\r\ndistinct prime factors of \\(n^{15}+1\\) not exceeding \\(m\\).\r\nE.g. \\(2^{15}+1 =\r\n3\\times3\\times11\\times331\\).\r\nSo \\(s(2,10) = 3\\) and \\(s(2,1000) = 3+11+331 = 345\\).\r\nAlso \\(10^{15}+1 =\r\n7\\times11\\times13\\times211\\times241\\times2161\\times9091\\).\r\nSo \\(s(10,100) = 31\\) and \\(s(10,1000) = 483\\).\r\nFind \\(\\sum s(n,10^8)\\) for \\(1 \\le n \\le 10^{11}\\).\r\n解决方案\r\n令\\(N=10^{11},M=10^8,K=15\\)。\r\n求群\\(\\mathbb{Z}_p^{\\ast}\\)的原根非常简单：从\\(2\\)开始枚举\\(g\\)，一个个进行判定。\r\n判断一个元素\\(g\\)是否为\\(\\mathbb{Z}_p^{\\ast}\\)的原根方法也比较简单：枚举\\(\\varphi(p)=p-1\\)的所有质因数\\(k\\)，如果存在\\(k\\)使得\\(g^{\\frac{p-1}{k}}\\equiv 1 \\pmod\r\np\\)，那么\\(g\\)就不是原根，否则\\(g\\)是原根。\r\n由于群\\(\\mathbb{Z}_p^{\\ast}\\)有\\(\\varphi(p-1)\\)个原根，因此实际上这种枚举原根的方法并不慢。\r\n回到本问题，本质上是枚举质数\\(p\\)，然后判断方程\\(n^{K}\\equiv -1 \\pmod\r\np\\)有多少个解小于等于\\(N\\)。为不失一般性，这里真正计算的解都小于\\(p\\)。\r\n首先考虑方程\\(n^{K}\\equiv 1 \\pmod\r\np\\) 的解。令\\(n=g^i\\)，其中\\(g\\)是群\\(\\mathbb{Z}_p^{\\ast}\\)上的原根，那么方程就化为：\r\n\\[g^{K\\cdot i}\\equiv g^0p\\pmod\r\np\\qquad(1)\\]\r\n那么就可以写成\r\n\\[Ki\\equiv 0\\pmod\r\n{p-1}\\qquad(2)\\]\r\n令\\(d=\\gcd(K,p-1)\\)。那么不难发现，方程\\((2)\\)的所有解满足\\(\\dfrac{p-1}{d}\\cdot j\\)，其中\\(j=0,1,\\dots,d-1.\\)\r\n因此，令\\(h\\equiv g^{\\frac{p-1}{d}}\\pmod\r\np\\)，那么方程\\((1)\\)的解为\\(h^j\\)，其中\\(j=0,1,\\dots,d-1.\\)\r\n为了解回原方程\\(n^{K}\\equiv -1\\pmod\r\np\\)，那么首先判断\\(\\dfrac{p-1}{d}\\)是否为偶数。如果不是，那么原方程无解（注意到这里\\(K=15\\)，因此\\(d\\)必为奇数，因此原方程必定有解，无需判断）；如果是，令\\(l=g^{\\frac{p-1}{2d}}\\)，那么原方程的解为\\(l\\cdot h^j\\)，其中\\(j=0,1,\\dots,d-1\\)。\r\n枚举方程\\(n^{K}\\equiv -1\\pmod\r\np\\)中的每个解\\(x\\)，那么这个解一共做出了\\(\\left\\lfloor\\dfrac{N-x}{p}\\right\\rfloor+1\\)次贡献。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll N=100000000000;const int M=100000000;const int K=15;int v[M+4],pr[M/10+1000],m=0;ll qpow(ll n,ll m,ll p)&#123;    ll a=1;    for(;m;m&gt;&gt;=1)&#123;        if(m&amp;1) a=a*n%p;        n=n*n%p;    &#125;    return a;&#125;int e[14],o=0;int primitive_root(int p)&#123;    if(p==2) return 1;    int x=p-1;    o=0;    for(;x!=1;)&#123;        int k=v[x];        e[++o]=k;        for(;x%k==0;x/=k);    &#125;    for(int g=2;;g++)&#123;        bool ok=1;        for(int i=1;i&lt;=o&amp;&amp;ok;i++)            if(qpow(g,(p-1)/e[i],p)==1) ok=0;        if(ok) return g;    &#125;    return -1;&#125;int main()&#123;    for(int i=2;i&lt;=M;i++)&#123;        if(v[i]==0)&#123;            v[i]=i;pr[++m]=i;        &#125;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;M/i) break;            v[i*pr[j]]=pr[j];        &#125;    &#125;    ll ans=(N+1)/2*2;    for(int i=2;i&lt;=m;i++)&#123;        int p=pr[i];        int g=primitive_root(p);        int d=__gcd(p-1,K);        if(((p-1)/d)&amp;1) continue;        ll l=qpow(g,(p-1)/(2*d),p);        ll h=qpow(g,(p-1)/d,p);        ll x,t=1,cnt=0;        for(int j=0;j&lt;d;j++)&#123;            x=l*t%p;            t=t*h%p;            cnt+=(N-x)/p+1;        &#125;        ans+=cnt*p;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 425","url":"/project-euler/425/","content":"\r\nProject Euler 425\r\n题目\r\nPrime connection\r\nTwo positive numbers \\(A\\) and \\(B\\) are said to be connected\r\n(denoted by “\\(A \\leftrightarrow B\\)”)\r\nif one of these conditions holds:\r\n\r\n\\(A\\) and \\(B\\) have the same length and differ in\r\nexactly one digit; for example, \\(123\r\n\\leftrightarrow 173\\).\r\nAdding one digit to the left of \\(A\\) (or \\(B\\)) makes \\(B\\) (or \\(A\\)); for example, \\(23 \\leftrightarrow 223\\) and \\(123 \\leftrightarrow 23\\).\r\n\r\nWe call a prime \\(P\\) a \\(2\\)’s relative if there exists a chain\r\nof connected primes between \\(2\\) and\r\n\\(P\\) and no prime in the chain exceeds\r\n\\(P\\).\r\nFor example, \\(127\\) is a \\(2\\)’s relative. One of the possible chains\r\nis shown below:\r\n\\(2 \\leftrightarrow 3 \\leftrightarrow 13\r\n\\leftrightarrow 113 \\leftrightarrow 103 \\leftrightarrow 107\r\n\\leftrightarrow 127\\)\r\nHowever, \\(11\\) and \\(103\\) are not \\(2\\)’s relatives.\r\nLet \\(F(N)\\) be the sum of the\r\nprimes \\(\\le N\\) which are not \\(2\\)’s relatives.\r\nWe can verify that \\(F(10^3) = 431\\)\r\nand \\(F(10^4) = 78728\\).\r\nFind \\(F(10^7)\\).\r\n并查集\r\n并查集：用于高效处理一些不相交集合的数据结构。一般有两个操作：合并两个集合；查询两个元素是否在同一个集合中。\r\n可以通过优化将并查集这两种单次操作优化到\\(O(\\alpha(n))\\)级别，其中\\(\\alpha(n)\\)是反阿克曼函数（一个增长速率非常接近于零的函数）。\r\n解决方案\r\n如果已经知道并查集这种数据结构，那么本题将很容易解决：\r\n从小到大枚举每个质数\\(p\\)，并且通过\\(p\\)直接枚举出如题意所需要的改变一位的质数\\(p&#39;\\)，合并质数\\(p\\)和\\(p&#39;\\)的所在集合。合并完成后，最终判断\\(p\\)和\\(2\\)是否在同一集合即可。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=1e7;int pr[N/10+100],m=0;bool vis[N+4];int fa[N+4];int find(int x)&#123;return fa[x]==x?x:fa[x]=find(fa[x]);&#125;void merge(int x,int y)&#123;fa[find(x)]=find(y);&#125;vector&lt;int&gt;pw10;int now[1004],p=0;void gen(int u)&#123;    p=0;    vector&lt;int&gt;d;    for(int x=u;x;x/=10)        d.push_back(x%10);    for(int i=0;i&lt;d.size();i++)&#123;        int x=u-pw10[i]*d[i];        if(i+1==d.size()) x+=pw10[i];        for(int j=(i+1==d.size()?1:0);j&lt;d[i];j++)&#123;            now[++p]=x;            x+=pw10[i];        &#125;    &#125;    if(d.size()&gt;=2&amp;&amp;d[d.size()-2]!=0)        now[++p]=u-pw10[d.size()-1]*d.back();&#125;int main()&#123;    vis[1]=1;    for(int i=2;i&lt;=N;i++)        if(!vis[i])&#123;            pr[++m]=i;            for(ll j=1ll*i*i;j&lt;=N;j+=i)                vis[j]=1;        &#125;    pw10.push_back(1);    while(pw10.back()&lt;=N) pw10.push_back(pw10.back()*10);    for(int i=1;i&lt;=m;i++)        fa[pr[i]]=pr[i];    ll ans=0;    for(int i=1;i&lt;=m;i++)&#123;        int u=pr[i];        gen(u);        for(int i=1;i&lt;=p;i++)&#123;            int k=now[i];            if(vis[k]) continue;            merge(k,u);        &#125;        if(find(2)!=find(u)) ans+=u;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["并查集"]},{"title":"Project Euler 429","url":"/project-euler/429/","content":"\r\nProject Euler 429\r\n题目\r\nSum of squares of unitary\r\ndivisors\r\nA unitary divisor \\(d\\) of a number\r\n\\(n\\) is a divisor of \\(n\\) that has the property \\(\\gcd\\left(d, \\dfrac{n}{d}\\right) = 1\\).\r\nThe unitary divisors of \\(4! = 24\\)\r\nare \\(1, 3, 8\\) and \\(24\\).\r\nThe sum of their squares is \\(1^2 + 3^2 +\r\n8^2 + 24^2 = 650\\).\r\nLet \\(S(n)\\) represent the sum of\r\nthe squares of the unitary divisors of \\(n\\). Thus \\(S(4!)=650\\).\r\nFind \\(S(100 000 000!) \\text{ modulo } 1\r\n000 000 009\\).\r\n解决方案\r\n如果一个正整数\\(n\\)分解后成为：\r\n\\[n=\\prod_{i=1}^m p_i^{e_i}\\]\r\n对于\\(n\\)的某个因子\\(d=\\prod_{i=1}^mp_i^{e_i&#39;}\\)而言，如果\\(\\gcd\\left(d,\\dfrac{n}{d}\\right)=1\\)，那么对于所有\\(i\\in [1,m]\\)，都有$e_i’{0,e_i} $。\r\n原因：如果\\(d\\)的一个质因子\\(p_i\\)的指数\\(e_i&#39;\\notin\\{0,e_i\\}\\)，也就是\\(0&lt;e_i&#39;&lt;e_i\\)，那么\\(\\dfrac{n}{d}\\)对应下的质因子的指数为\\(0&lt;e_i-e_i&#39;&lt;e_i\\)，因此\\(\\gcd\\left(d,\\dfrac{n}{d}\\right)\\)一定是\\(p_i\\)的倍数，所以原来的命题成立。\r\n这些因子一共有\\(2^m\\)个，因为对于所有\\(i\\in [1,m]\\)，\\(e_i&#39;\\)都有两个选择。因此，这\\(2^m\\)个因子的平方和为：\r\n\\[S(n)=\\prod_{i=1}^m(p_i^{2e_i}+1)\\]\r\n另一个问题则是：\\(n!\\)中质因子\\(p\\)出现了多少次？\r\n设\\(f(n, p)\\)是质因子\\(p\\)在\\(n!\\)中的次数，那么\\(f(n,p)=\\left\\lfloor\\dfrac{n}{p}\\right\\rfloor+\\left\\lfloor\\dfrac{n}{p^2}\\right\\rfloor+\\left\\lfloor\\dfrac{n}{p^3}\\right\\rfloor+\\dots\\)，每一项分别表示\\(1\\sim n\\)中有多少个数是\\(p,p^2,p^3\\dots\\)的倍数。\r\n最终，将这\\(2\\)个过程相结合，直接计算\\(S(N!)\\)的值，其中\\(N=10^8\\)。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=1e8;ll mod=1e9+9;ll qpow(ll n,ll m)&#123;    ll ans=1;    for(;m;m&gt;&gt;=1)&#123;        if(m&amp;1) ans=ans*n%mod;        n=n*n%mod;    &#125;    return ans;&#125;int cal(int n,int p)&#123;    int ans=0;    for(;n;n/=p)        ans+=n/p;    return ans;&#125;int pr[N+4],v[N+4],m=0;int main()&#123;    for(int i=2;i&lt;=N;i++)&#123;        if(v[i]==0)&#123;            v[i]=i;pr[++m]=i;        &#125;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;N/i) break;            v[i*pr[j]]=pr[j];        &#125;    &#125;    ll ans=1;    for(int i=1;i&lt;=m;i++)&#123;        ll cnt=cal(N,pr[i]);        ans=ans*(qpow(pr[i],cnt*2)+1)%mod;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 43","url":"/project-euler/43/","content":"\r\nProject Euler 43\r\n题目\r\nSub-string divisibility\r\nThe number, \\(1406357289\\), is a\r\n\\(0\\) to \\(9\\) pandigital number because it is made up\r\nof each of the digits \\(0\\) to \\(9\\) in some order, but it also has a rather\r\ninteresting sub-string divisibility property.\r\nLet \\(d_1\\) be the \\(1\\text{st}\\) digit, \\(d_2\\) be the \\(2\\text{nd}\\) digit, and so on. In this way,\r\nwe note the following:\r\n\\(d_2d_3d_4=406\\) is divisible by\r\n\\(2\\) \\(d_3d_4d_5=063\\) is divisible by \\(3\\) \\(d_4d_5d_6=635\\) is divisible by \\(5\\) \\(d_5d_6d_7=357\\) is divisible by \\(7\\) \\(d_6d_7d_8=572\\) is divisible by \\(11\\) \\(d_7d_8d_9=728\\) is divisible by \\(13\\) \\(d_8d_9d_{10}=289\\) is divisible by \\(17\\)\r\nFind the sum of all \\(0\\) to \\(9\\) pandigital numbers with this\r\nproperty.\r\n解决方案\r\n可以直接用itertools库中的permutations产生所有置换，然后一个个直接进行判断。\r\n比较一种优化的方法是自己手写深度优先搜索生成全排列，在恰当的地方及时剪枝，这将比上面的方法快不少。\r\n代码\r\nt = &quot;0123456789&quot;ans = 0for x in permutations(t):    s = &quot;&quot;.join(x)    ok = 1    if int(s[1:4]) % 2 != 0 or int(s[2:5]) % 3 != 0 or int(s[3:6]) % 5 != 0 or int(s[4:7]) % 7 != 0 or \\            int(s[5:8]) % 11 != 0 or int(s[6:9]) % 13 != 0 or int(s[7:10]) % 17 != 0:        ok = 0    if ok:        ans += int(s)print(ans)\r\nN = 10vis = [0 for i in range(N)]val = [0 for i in range(N)]m = [2, 3, 5, 7, 11, 13, 17]ans = 0def dfs(f: int):    global ans    if f == 10:        ans += int(&quot;&quot;.join(str(x) for x in val))        return    for i in range(10):        if vis[i]:            continue        if f == 0 and i == 0:            continue        if f &gt;= 3:            if (val[f - 2] * 100 + val[f - 1] * 10 + i) % m[f - 3] != 0:                continue        val[f] = i        vis[i] = True        dfs(f + 1)        vis[i] = Falsedfs(0)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 435","url":"/project-euler/435/","content":"\r\nProject Euler 435\r\n题目\r\nPolynomials of Fibonacci\r\nnumbers\r\nThe Fibonacci numbers \\(\\{f_n, n \\ge 0\\}\\) are defined recursively\r\nas \\(f_n = f_{n-1} + f_{n-2}\\) with\r\nbase cases \\(f_0 = 0\\) and \\(f_1 = 1\\). Define the polynomials \\(\\{F_n, n \\ge 0\\}\\) as \\(F_n(x) = \\displaystyle{\\sum_{i=0}^n f_i\r\nx^i}\\). For example, \\(F_7(x) = x + x^2\r\n+ 2x^3 + 3x^4 + 5x^5 + 8x^6 + 13x^7\\), and \\(F_7(11) = 268\\,357\\,683\\). Let \\(n = 10^{15}\\). Find the sum \\(\\displaystyle{\\sum_{x=0}^{100} F_n(x)}\\)\r\nand give your answer modulo \\(1\\,307\\,674\\,368\\,000 \\ (= 15!)\\).\r\n解决方案\r\n不难看到，可以将\\(F_n(x)\\)按照斐波那契数列的定义写成如下递推式：\r\n\\[\r\nF_n(x)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;x  &amp; &amp; \\text{if}\\quad n=1 \\\\\r\n  &amp;x^2+x &amp; &amp; \\text{else if}\\quad n=2 \\\\\r\n  &amp;x^2F_{n-2}(x)+xF_{n-1}(x)+x &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n只要\\(x\\)是一个定值，那么\\(F_{n}(x)\\)就可以看成是一个在\\(n\\)上的线性递推。\r\n将递推式写成矩阵形式，那么有：\r\n\\[\r\n\\begin{bmatrix}\r\n0 &amp; 1 &amp; 0\\\\\r\nx^2+x &amp; x &amp; 1\\\\\r\n0 &amp; 0 &amp; 1\r\n\\end{bmatrix}\r\n\\begin{bmatrix}\r\nF_{n-2}(x)\\\\\r\nF_{n-1}(x)\\\\\r\nx\r\n\\end{bmatrix}\r\n=\r\n\\begin{bmatrix}\r\nF_{n-1}(x)\\\\\r\nF_{n}(x)\\\\\r\nx\r\n\\end{bmatrix}\r\n\\]\r\n给定初值\\(F_1(x)=x\\)和\\(F_2(x)=x^2+x\\)，那么可以通过矩阵快速幂在\\(O(\\log n)\\)的时间复杂度内计算出\\(F_n(x)\\)的值。\r\n代码\r\nN = 10 ** 15M = 100mod = 1307674368000def mul(a: list, b: list):    return [[sum(a[i][k] * b[k][j] for k in range(len(b))) % mod for j in range(len(b[0]))] for i in range(len(a))]ans = 0for x in range(M + 1):    a = [[x, x * x + x, x]]    b = [[0, x * x, 0],         [1, x, 0],         [0, 1, 1]]    n = N - 1    while n:        if n &amp; 1:            a = mul(a, b)        b = mul(b, b)        n &gt;&gt;= 1    ans = (ans + a[0][0]) % modprint(ans)\r\n","categories":["Project Euler"],"tags":["矩阵快速幂"]},{"title":"Project Euler 437","url":"/project-euler/437/","content":"\r\nProject Euler 437\r\n题目\r\nFibonacci primitive roots\r\nWhen we calculate \\(8^n\\) modulo\r\n\\(11\\) for \\(n=0\\) to \\(9\\) we get: \\(1,\r\n8, 9, 6, 4, 10, 3, 2, 5, 7\\).\r\nAs we see all possible values from \\(1\\) to \\(10\\) occur. So \\(8\\) is a primitive root of\r\n\\(11\\).\r\nBut there is more:\r\nIf we take a closer look we see:\r\n\\(\\begin{aligned}\r\n&amp; 1+8=9\\\\\r\n&amp; 8+9=17\\equiv6 \\bmod 11\\\\\r\n&amp; 9+6=15\\equiv4 \\bmod 11\\\\\r\n&amp; 6+4=10\\\\\r\n&amp; 4+10=14\\equiv3 \\bmod 11\\\\\r\n&amp; 10+3=13\\equiv2 \\bmod 11\\\\\r\n&amp; 3+2=5\\\\\r\n&amp; 2+5=7\\\\\r\n&amp; 5+7=12\\equiv1 \\bmod 11.\r\n\\end{aligned}\\)\r\nSo the powers of \\(8\\) mod \\(11\\) are cyclic with period \\(10\\), and \\(8^n +\r\n8^{n+1} \\equiv 8^{n+2} \\pmod {11}\\).\r\n\\(8\\) is called a Fibonacci\r\nprimitive root of \\(11.\\)\r\nNot every prime has a Fibonacci primitive root.\r\nThere are \\(323\\) primes less than\r\n\\(10000\\) with one or more Fibonacci\r\nprimitive roots and the sum of these primes is \\(1480491\\).\r\nFind the sum of the primes less than \\(100,000,000\\) with at least one Fibonacci\r\nprimitive root.\r\n解决方案\r\n假设群\\(\\mathbb{Z}_p^{\\star}\\)上的一个原根为\\(g\\)，那么按照上面对斐波那契原根的定义，可以写成：\r\n\\(\\forall n,g^n+g^{n+1}-g^{n+2}\\equiv\r\n0\\pmod p\\)\r\n那么提取公因式，有\\(g^n(1+g-g^2)\\equiv\r\n0\\pmod p\\)\r\n由于\\(g\\)是原根，\\(g^n\\)永远不可能为\\(0\\)，因此转化为求\\(g^2-g-1\\equiv 0\\pmod p\\)\r\n也就是\\((2g-1)^2\\equiv 5\\pmod\r\np\\)\r\n解这个方程，如果找到了一个根\\(g\\)，那么不难发现\\(g&#39;=p-g+1\\)是这个方程的另外一个根。\r\n令\\(f(n)=n^2-n-1\\)，那么使用216题的分解方式对\\(f(n)\\)进行分解：如果\\(p\\mid f(n)\\)，那么\\(p\\mid f(kp+n),p\\mid f(kp-n+1)\\)，其中\\(k&gt;0\\)。那么最终若\\(f(n)\\)被筛剩一个质因子\\(p\\)，那么\\(n\\)就是方程\\(g^2-g-1\\equiv 0\\pmod p\\)的一个解。\r\n判断一个元素\\(g\\)是否为\\(\\mathbb{Z}_p^{\\ast}\\)的原根方法也比较简单：枚举\\(\\varphi(p)=p-1\\)的所有质因数\\(k\\)，如果存在\\(k\\)使得\\(g^{\\frac{p-1}{k}}\\equiv 1\\pmod\r\np\\)，那么\\(g\\)就不是原根，否则\\(g\\)是原根。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=100000000;ll f[N+4];int v[N+4],pr[N/10+1000],m=0;ll qpow(ll n,ll m,ll p)&#123;    ll a=1;    for(;m;m&gt;&gt;=1)&#123;        if(m&amp;1) a=a*n%p;        n=n*n%p;    &#125;    return a;&#125;bool is_primitive_root(int g,int p)&#123;    int x=p-1;    for(;x!=1;)&#123;        int k=v[x];        if(qpow(g,(p-1)/k,p)==1) return 0;        for(;x%k==0;x/=k);    &#125;    return 1;&#125;int main()&#123;    for(int i=1;i&lt;=N;i++)        f[i]=1ll*i*i-i-1;    for(int i=2;i&lt;=N;i++)&#123;        if(v[i]==0)&#123;            v[i]=i;pr[++m]=i;        &#125;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;N/i) break;            v[i*pr[j]]=pr[j];        &#125;    &#125;    ll ans=0;    for(int i=3;i&lt;N;i++)&#123;        ll p=f[i];        if(p==1||p&gt;N) continue;        if(is_primitive_root(i,p)||is_primitive_root(p-i+1,p)) ans+=p;        for(int j=i;j&lt;N;j+=p)            for(;f[j]%p==0;f[j]/=p);        for(int j=p-i+1;j&lt;N;j+=p)            for(;f[j]%p==0;f[j]/=p);    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 44","url":"/project-euler/44/","content":"\r\nProject Euler 44\r\n题目\r\nPentagon numbers\r\nPentagonal numbers are generated by the formula, \\(P_n=\\dfrac{n(3n−1)}{2}\\). The first ten\r\npentagonal numbers are: \\[1, 5, 12, 22, 35,\r\n51, 70, 92, 117, 145,\\dots\\]\r\nIt can be seen that \\(P_4 + P_7 = 22 + 70 =\r\n92 = P_8\\). However, their difference, \\(70 − 22 = 48\\), is not pentagonal.\r\nFind the pair of pentagonal numbers, \\(P_j\\) and \\(P_k\\), for which their sum and difference\r\nare pentagonal and \\(D = |P_k − P_j|\\)\r\nis minimised; what is the value of \\(D\\)?\r\n解决方案\r\n先从小到大处理五边形数和值\\(s\\)，再从小到大处理五边形数差值\\(d(d&lt;s)\\)。\r\n通过一个二元一次方程\\(a+b=s,a-b=d\\)解出\\(a\\)和\\(b\\)的值，如果\\(a\\)和\\(b\\)也都是五边形数，那么可以输出所需值\\(d\\)。\r\n代码\r\nfrom itertools import count# a+b=s,a-b=d,a-d=bdef solve():    p = []    st = set()    for s in (n * (3 * n - 1) // 2 for n in count(1)):        st.add(s)        for d in p:            if ((d ^ s) &amp; 1) == 0:                a = (d + s) &gt;&gt; 1                if a in st and s - a in st:                    return d        p.append(s)print(solve())\r\n","categories":["Project Euler"]},{"title":"Project Euler 440","url":"/project-euler/440/","content":"\r\nProject Euler 440\r\n题目\r\nGCD and Tiling\r\nWe want to tile a board of length \\(n\\) and height \\(1\\) completely, with either \\(1 \\times 2\\) blocks or \\(1 \\times 1\\) blocks with a single decimal\r\ndigit on top:\r\n\r\nFor example, here are some of the ways to tile a board of length\r\n\\(n = 8\\):\r\n\r\nLet \\(T(n)\\) be the number of ways\r\nto tile a board of length \\(n\\) as\r\ndescribed above. For example, \\(T(1) =\r\n10\\) and \\(T(2) = 101\\).\r\nLet \\(S(L)\\) be the triple sum \\(\\sum_{a,b,c} \\gcd(T(c^a), T(c^b))\\) for\r\n\\(1 \\le a, b, c \\le L\\).\r\nFor example:\r\n\\(\\begin{aligned}\r\n&amp;S(2) = 10444\\\\\r\n&amp;S(3) = 1292115238446807016106539989\\\\\r\n&amp;S(4) \\bmod 987 898 789 = 670616280.\r\n\\end{aligned}\\)\r\nFind \\(S(2000) \\bmod\r\n987 898 789\\).\r\n解决方案\r\n令\\(N=2000\\)\r\n不难知道递推式\\(T\\)满足\\(T(n)=10T(n-1)+T(n-2).\\)\r\n根据此页面关于线性递推式的性质，考虑将递推式在前面拼接两项\\(0,1\\)，成为\\(U\\)。那么可以写成\\(U(0)=0,U(1)=1,U(n)=10U(n-1)+U(n-2)\\)。\r\n使用这个性质后，那么有\\(\\gcd(U(n),U(m))=U(\\gcd(n,m))\\)。\r\n因此，问题转化为求\\(\\sum_{a=1}^N\\sum_{b=1}^N\\sum_{c=1}^N\r\nU(\\gcd(c^a+1,c^b+1)).\\)\r\n为求解\\(\\gcd(c^a+1,c^b+1)\\)，有以下结论：\r\n\r\n若\\(g=\\gcd(a,b)\\)，并且\\(\\dfrac{a}{g},\\dfrac{b}{g}\\)都是奇数，那么答案为\\(c^g+1\\)。\r\n否则，当\\(c\\)为奇数时答案为\\(2\\)，当\\(c\\)为偶数时，答案为\\(1\\)。\r\n\r\n根据欧几里得算法，\\(\\gcd(c^a+1,c^b+1),a&gt;b\\)可以进行如下变化：\r\n\\(\\begin{aligned}\r\n&amp;\\gcd(c^a+1,c^b+1)=\\gcd(c^a-c^b,c^b+1)=\\gcd(c^{a-b}-1,c^b+1)=\\gcd(c^{a-b}+c^b,c^b+1)\\\\\r\n=&amp;\\gcd(c^{|a-2b|}+1,c^b+1)\r\n\\end{aligned}\\)\r\n注意到迭代过程中，无论是\\(|a-2b|\\)还是\\(b\\)，都是\\(a,b\\)的线性组合。最后一轮迭代结束时，要么\\(a=b=g=\\gcd(a,b)\\)，\\(\\gcd(c^a+1,c^b+1)=c^g+1\\)；要么\\(b=0,c^b+1=2\\)（注意在此处，上一轮迭代情况将会有一个偶数\\(2g,|2b-2\\cdot b|=0\\)）。\r\n那么抛开\\(a,b\\)中的最大公因数\\(g\\)，单独讨论\\(a&#39;=\\dfrac{a}{g}\\)和\\(b&#39;=\\dfrac{b}{g}\\)。如果\\(a&#39;,b&#39;\\)都是奇数，那么在迭代\\((a&#39;,b&#39;)\\rightarrow(|a&#39;-2b&#39;|,b&#39;)\\)的过程中，都不会出现\\(a&#39;,b&#39;\\)中有一个是偶数的情况；如果其中一个是偶数，那么最终迭代的结果必将存在一个\\(a&#39;,b&#39;\\)为\\(0\\)。\r\n回到本问题，计算\\(S(N)\\)是一个三重循环，但是计算\\(\\gcd(c^a+1,c^b+1)\\)时，迭代的阶段可以不需要知道\\(c\\)，只有最后的时候才需要代入\\(c\\)计算出具体值。因此我们先枚举\\(a,b\\)，保留中间值\\(?^{\\gcd(a,b)}+1,3-?\\% 2\\)（这里的\\(?\\)用来指代未知的\\(c\\)值）。然后利用一个集合，分别统计这些不同的\\(?^{\\gcd(a,b)}+1,3-?\\%\r\n2\\)的个数。可以发现这个集合的大小为\\(O(N)\\)。然后再代入\\(c\\)进行计算。\r\n并且经过枚举，恰好发现\\(U(n)\\%987898789\\)这个序列的周期为\\(T=987898788\\)。那么求\\(U(c^g+1)\\)就相当于求\\(U((c^g+1)\\%T)\\)，求\\(U(n)\\)时使用矩阵快速幂算法即可。\r\n本题由于模数比较特殊，可以避免使用矩阵快速幂进行计算。通过Mathematica用以下代码求\\(U(n)\\) 的递推式，发现为：\r\nRSolve[&#123;a[n] == 10*a[n - 1] + a[n - 2], a[0] == 0, a[1] == 1&#125;, a[n], n]\r\n\\[U(n)=\\dfrac{(5+\\sqrt{26})^n -\r\n(5-\\sqrt{26})^n}{2\\sqrt{26}}\\]\r\n并且，\\(26\\)恰好是模数\\(987898789\\)的二次剩余。可以计算出\\(\\sqrt{26} \\equiv 445663912\r\n\\pmod{987898789}\\)。\r\n那么本题就不需要使用矩阵快速幂。只需要使用普通的快速幂算法进行计算即可，效率更高。并且，不需要先像上一种做法那样需要先枚举再确定周期。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=2000;ll T=987898788,mod=987898789;ll qpow(ll n,ll m,ll mod)&#123;    ll a=1;    for(;m;m&gt;&gt;=1)&#123;        if(m&amp;1) a=a*n%mod;        n=n*n%mod;    &#125;    return a;&#125;void mul_self(ll b[2][2])&#123;    ll c[2][2]=&#123;0&#125;;    for(int i=0;i&lt;2;i++)        for(int j=0;j&lt;2;j++)            for(int k=0;k&lt;2;k++)                c[i][j]=(c[i][j]+b[i][k]*b[k][j])%mod;    memcpy(b,c,sizeof(c));&#125;void mul(ll a[2],ll b[2][2])&#123;    ll c[2]=&#123;0&#125;;    for(int i=0;i&lt;2;i++)        for(int k=0;k&lt;2;k++)            c[i]=(c[i]+a[k]*b[k][i])%mod;    memcpy(a,c,sizeof(c));&#125;ll a[2],b[2][2];ll cal(ll n)&#123;    a[0]=0,a[1]=1;    b[0][0]=0;b[0][1]=b[1][0]=1;    b[1][1]=10;    for(;n;n&gt;&gt;=1)&#123;        if(n&amp;1) mul(a,b);        mul_self(b);    &#125;    return a[0];&#125;int cnt[N+4];int main()&#123;    for(int a=1;a&lt;=N;a++)&#123;        ++cnt[a];        for(int b=a+1;b&lt;=N;b++)&#123;            int g=__gcd(a,b);            if(a/g%2&amp;&amp;b/g%2) cnt[g]+=2;            else cnt[0]+=2;        &#125;    &#125;    ll ans=0;    for(int c=1;c&lt;=N;c++)&#123;        ans=(ans+cal(c&amp;1?2:1)*cnt[0])%mod;        for(int g=1;g&lt;=N;g++)            ans=(ans+cal(qpow(c,g,T)+1)*cnt[g])%mod;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=2000;ll mod=987898789;ll qpow(ll n,ll m,ll mod)&#123;    ll a=1;    for(;m;m&gt;&gt;=1)&#123;        if(m&amp;1) a=a*n%mod;        n=n*n%mod;    &#125;    return a;&#125;ll sqrt26=445663912;ll inv2sqrt26=qpow(sqrt26*2,mod-2,mod);ll cal(ll n)&#123;    return (qpow(5+sqrt26,n,mod)-qpow(mod-sqrt26+5,n,mod)+mod)*inv2sqrt26%mod;&#125;int cnt[N+4];int main()&#123;    for(int a=1;a&lt;=N;a++)&#123;        ++cnt[a];        for(int b=a+1;b&lt;=N;b++)&#123;            int g=__gcd(a,b);            if(a/g%2&amp;&amp;b/g%2) cnt[g]+=2;            else cnt[0]+=2;        &#125;    &#125;    ll ans=0;    for(int c=1;c&lt;=N;c++)&#123;        ans=(ans+cal(c&amp;1?2:1)*cnt[0])%mod;        for(int g=1;g&lt;=N;g++)            ans=(ans+cal(qpow(c,g,mod-1)+1)*cnt[g])%mod;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["矩阵快速幂"]},{"title":"Project Euler 443","url":"/project-euler/443/","content":"\r\nProject Euler 443\r\n题目\r\nGCD sequence\r\nLet \\(g(n)\\) be a sequence defined\r\nas follows:\r\n\\(g(4) = 13\\),\r\n\\(g(n) = g(n-1) + \\gcd(n, g(n-1))\\),\r\nfor \\(n &gt; 4\\).\r\nThe first few values are:\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\\(n\\)\r\n\\(4\\)\r\n\\(5\\)\r\n\\(6\\)\r\n\\(7\\)\r\n\\(8\\)\r\n\\(9\\)\r\n\\(10\\)\r\n\\(11\\)\r\n\\(12\\)\r\n\\(13\\)\r\n\\(14\\)\r\n\\(15\\)\r\n\\(16\\)\r\n\\(17\\)\r\n\\(18\\)\r\n\\(19\\)\r\n\\(20\\)\r\n\\(\\dots\\)\r\n\r\n\r\n\\(g(n)\\)\r\n\\(13\\)\r\n\\(14\\)\r\n\\(16\\)\r\n\\(17\\)\r\n\\(18\\)\r\n\\(27\\)\r\n\\(28\\)\r\n\\(29\\)\r\n\\(30\\)\r\n\\(31\\)\r\n\\(32\\)\r\n\\(33\\)\r\n\\(34\\)\r\n\\(51\\)\r\n\\(54\\)\r\n\\(55\\)\r\n\\(60\\)\r\n\\(\\dots\\)\r\n\r\n\r\n\r\nYou are given that \\(g(1000) =\r\n2524\\) and \\(g(1000000) =\r\n2624152\\).\r\nFind \\(g(10^{15})\\).\r\n解决方案\r\n令\\(N=10^{15}\\)，将\\(g\\)中的前一部分项打印出来，发现对于绝大多数\\(n\\)，都满足\\(g(n)=g(n-1)+1\\)。\r\n因此，我们考虑枚举出所有满足\\(\\gcd(n,g(n-1))&gt;1\\)的所有\\(n\\)，并找到这些\\(n\\)中最大的一个使得\\(n\\le N\\)，那么\\(g(N)=g(n)+N-n.\\)\r\n假设目前我们已经知道了某个\\(n\\)和它的函数值\\(g\\)，那么转为求下一个最小的\\(n&#39;\\)使得\\(\\gcd(n&#39;,g(n&#39;-1))&gt;1,n&#39;&gt;n\\)，那么在\\(d=n+1,n+2,\\dots,n&#39;-1\\)之前，都满足\\(\\gcd(d,g(d-1))=1\\)。\r\n那么对于一对\\(n,g\\)，问题转化成求一个最小的\\(k\\)，使得\\(\\gcd(n+k+1,g+k)&gt;1\\).根据辗转相除的性质，可以写为\\(\\gcd(g+k,g-n-1)&gt;1\\).\r\n可以发现，\\(g-n-1\\)是一个常数。因此我们将\\(g-n-1\\)进行分解，并枚举每个质因数\\(p_i\\)，并求出最小的\\(k_i\\)使得\\(g+k_i\\)是\\(p_i\\)的倍数，最终\\(k\\)是这些\\(k_i\\)中最小的一个。\r\n令\\(n&#39;=n+k+1\\)，那么\\(g&#39;=n+k+\\gcd(n+k+1,g+k)\\)，得到了一组新的\\(n&#39;,g(n)\\)值，由此迭代直到\\(N\\)处。\r\n代码\r\nfrom tools import factorization, gcdN = 10 ** 15n = 4g = 13while True:    p_list = [u[0] for u in factorization(g - n - 1)]    nxt = min((g + p - 1) // p * p for p in p_list)    k = nxt - g    np = n + k + 1    if np &gt; N:        g += N - n        break    g = nxt + gcd(np, nxt)    n = npprint(g)\r\n","categories":["Project Euler"]},{"title":"Project Euler 445","url":"/project-euler/445/","content":"\r\nProject Euler 445\r\n题目\r\nRetractions A\r\nFor every integer \\(n&gt;1\\), the\r\nfamily of functions \\(f_{n,a,b}\\) is\r\ndefined by\r\n$f_{n,a,b}(x)a x + b n,,, $ for \\(a,b,x\\) integer and \\(0&lt; a &lt;n, 0 \\le b &lt; n,0 \\le x &lt;\r\nn\\).\r\nWe will call \\(f_{n,a,b}\\) a\r\nretraction if \\(\\,\\,\\,\r\nf_{n,a,b}(f_{n,a,b}(x)) \\equiv f_{n,a,b}(x) \\mod n \\,\\,\\,\\) for\r\nevery \\(0 \\le x &lt; n\\).\r\nLet \\(R(n)\\) be the number of\r\nretractions for \\(n\\).\r\nYou are given that\r\n\\(\\displaystyle \\sum_{k=1}^{99\\,999}\r\nR\\left(\\binom {100\\,000} k\\right)  \\equiv 628701600 \\mod\r\n1\\,000\\,000\\,007\\).\r\nFind \\(\\displaystyle\r\n\\sum_{k=1}^{9\\,999\\,999} R\\left(\\binom {10\\,000\\,000}\r\nk\\right)\\).\r\nGive your answer modulo \\(1\\,000\\,000\\,007\\).\r\n解决方案\r\n令\\(N=10^7\\)。\r\n如题，\\(f_{n,a,b}(f_{n,a,b}(x)) \\equiv\r\nf_{n,a,b}(x) \\pmod n\\)将意味着：\r\n\\(a(ax+b)+b\\equiv ax+b \\pmod n\\)\r\n整理后，得到\\(a(a-1)x+ab\\equiv0\\pmod\r\nn\\)。\r\n不失一般性，令\\(x=0\\)，那么就能够得到\\(ab\\equiv 0 \\pmod n\\)。\r\n再令\\(x=1\\)，那么就得到\\(a(a-1)+ab\\equiv 0\\pmod n\\)，去除\\(ab\\)后，也就得到\\(a(a-1)\\equiv 0\\pmod n\\)。\r\n将\\(n\\)写成质因数分解的形式：\\(n=\\prod_{i=1}^k\r\np_i^{e_i}\\)，那么对于任意\\(i\\in[1,k]\\)，都有\\(a(a-1)\\equiv 0\\pmod{p_i^{e_i}},ab\\equiv\r\n0\\pmod{p_i^{e_i}}\\)。因此，我们从中国剩余定理的角度考虑\\(R(n)\\)的值。\r\n可以发现，\\(\\gcd(a,a-1)=1\\)，因此对于\\(a\\in[0,p_i^{e_i})\\)，要令\\(a(a-1)\\equiv\r\n0\\pmod{p_i^{e_i}}\\)，无外乎有以下两种情况：\r\n\r\n当\\(a\\equiv\r\n0\\pmod{p_i^{e_i}}\\)时，那么可以发现对于任意\\(b\\in[0,p_i^{e_i})\\)，\\(ab\\equiv\r\n0\\pmod{p_i^{e_i}}\\)都能满足。此时\\(b\\)值有\\(p_i^{e_i}\\)种取法。\r\n当\\(a\\equiv\r\n1\\pmod{p_i^{e_i}}\\)时，那么要令\\(ab\\equiv0\\pmod{p_i^{e_i}}\\)，只能取\\(b=0\\)。此时\\(b\\)仅有一种取法。\r\n\r\n综上所述，对于一个\\(n\\)，最终满足题目条件的不同的\\((a,b)\\)对数\\(R(n)\\)为\r\n\\[R(n)=\\prod_{i=1}^k(p_i^{e_i}+1)-n\\]\r\n这里减去\\(n\\)，是为了减去\\(a=0\\)时的情况（题目明确\\(a&gt;0\\)），因为按照中国剩余定理，最终组合产生的结果会等于\\(0\\)。\r\n因此，题目就变成了维护\\(\\prod_{i=1}^k(p_i^{e_i}+1)\\)的值。\r\n由于本题使用的\\(n\\)是组合数，通过递推公式\\(\\dbinom{n}{k}=\\dfrac{n-k+1}{k}\\cdot\\dbinom{n}{k-1}\\)，对\\(n-k+1\\)和\\(k\\)进行分解并维护即可。\r\n使用组合数的性质\\(\\dbinom{n}{k}=\\dbinom{n}{n-k}\\)可以减少一半的计算开销。\r\n对于\\(R(n)\\)项中的后面那个\\(n\\)，使用组合数公式优化计算：\r\n\\[\\sum_{i=0}^n\\dbinom{n}{i}=2^n\\]\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=10000000;ll mod=1000000007;int v[N+4];int pr[N/5+1000],m=0;void init()&#123;    for(int i=2;i&lt;=N;i++)&#123;        if(v[i]==0)&#123;            v[i]=i; pr[++m]=i;        &#125;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;N/i) break;            v[i*pr[j]]=pr[j];        &#125;    &#125;&#125;int p[14],e[14],o=0;void fact(int n)&#123;    o=0;    for(;n!=1;)&#123;        p[++o]=v[n];e[o]=0;        for(;n%p[o]==0;n/=p[o],++e[o]);    &#125;&#125;ll qpow(ll n,ll m)&#123;    ll a=1;    for(;m;m&gt;&gt;=1)&#123;        if(m&amp;1) a=a*n%mod;        n=n*n%mod;    &#125;    return a;&#125;int f[N+4];int main()&#123;    init();    ll ans=0,val=1;    for(int k=1;k&lt;=N/2;k++)&#123;        fact(N-k+1);        for(int i=1;i&lt;=o;i++)&#123;            if(f[p[i]]&gt;0) val=val*qpow(qpow(p[i],f[p[i]])+1,mod-2)%mod;            f[p[i]]+=e[i];            val=val*(qpow(p[i],f[p[i]])+1)%mod;        &#125;        fact(k);        for(int i=1;i&lt;=o;i++)&#123;            val=val*qpow(qpow(p[i],f[p[i]])+1,mod-2)%mod;            f[p[i]]-=e[i];            if(f[p[i]]&gt;0) val=val*(qpow(p[i],f[p[i]])+1)%mod;        &#125;        ans=(ans+val*2)%mod;    &#125;    if(N%2==0) ans=(ans-val+mod)%mod;    ans=(ans-qpow(2,N)+2+mod)%mod;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 446","url":"/project-euler/446/","content":"\r\nProject Euler 446\r\n题目\r\nRetractions B\r\nFor every integer \\(n&gt;1\\), the\r\nfamily of functions \\(f_{n,a,b}\\) is\r\ndefined by\r\n$f_{n,a,b}(x)a x + b n,,, $ for \\(a,b,x\\) integer and \\(0&lt; a &lt;n, 0 \\le b &lt; n,0 \\le x &lt;\r\nn\\).\r\nWe will call \\(f_{n,a,b}\\) a\r\nretraction if \\(\\,\\,\\,\r\nf_{n,a,b}(f_{n,a,b}(x)) \\equiv f_{n,a,b}(x) \\mod n \\,\\,\\,\\) for\r\nevery \\(0 \\le x &lt; n\\).\r\nLet \\(R(n)\\) be the number of\r\nretractions for \\(n\\).\r\n\\(\\displaystyle\r\nF(N)=\\sum_{n=1}^NR(n^4+4)\\).\r\n\\(F(1024)=77532377300600\\).\r\nFind \\(F(10^7)\\).\r\nGive your answer modulo \\(1\\,000\\,000\\,007\\).\r\n解决方案\r\n第445题直接给出了如下关于\\(R(n)\\)的式子，将\\(n\\)写成质因数分解的形式\\(n=\\prod_{i=1}^k p_i^{e_i}\\)。那么有：\r\n\\[R(n)=\\prod_{i=1}^k(p_i^{e_i}+1)-n\\]\r\n可以发现，通过因式分解，有\\(n^4+4=((n+1)^2+1)((n-1)^2+1)\\)。\r\n因此，考虑对\\(t(x)=x^2+1\\)进行分解，那么就有\\(n^4+4=t(n-1)\\cdot\r\nt(n+1)\\)。需要注意的是，当\\(n\\)为偶数时，\\(\\gcd(t(n-1),t(n+1))=2\\)，否则\\(\\gcd(t(n-1),t(n+1))=1\\)。因此考虑\\(n^4+4\\)的因式分解时，需要单独考虑质因子\\(2\\)。另一方面，不难证明，\\(4\\nmid t(n)\\)，因此\\(n^4+4\\)可以是\\(4\\)的倍数，但必定不能是\\(8\\)的倍数。\r\n对\\(t(n)\\)的分解采用第216题的方法：如果\\(p\\mid t(n)\\)，那么\\(p\\mid t(kp\\pm n)\\)，其中\\(k&gt;0\\)。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=10000000;const int M=N+1;ll mod=1000000007;ll p[M+4],f[M+4];int main()&#123;    for(int i=0;i&lt;=M;i++)&#123;        p[i]=1ll*i*i+1;        if(i&amp;1) p[i]&gt;&gt;=1;        f[i]=1;    &#125;    for(int i=2;i&lt;=M;i++)&#123;        ll q=p[i];        if(q&gt;1)&#123;            for(ll j=i;j&lt;=M;j+=q)&#123;                ll m=1;                for(;p[j]%q==0;p[j]/=q,m*=q);                f[j]=f[j]*(m+1)%mod;            &#125;            //似乎下面这一段不进行筛法也可以，原因尚未知。            /*for(ll j=q-i;j&lt;=M;j+=q)&#123;                ll m=1;                for(;p[j]%q==0;p[j]/=q,m*=q);                f[j]=f[j]*(m+1)%mod;            &#125;            */        &#125;    &#125;    ll ans=0;    for(int n=1;n&lt;=N;n++)&#123;        ll u=1ll*n*n%mod;        u=(u*u+4)%mod;        ll v=f[n-1]*f[n+1]%mod;        // 当n为偶数时，n^4+4是4的倍数，但不是8的倍数。        if(n%2==0) v=(v*5)%mod;        ans+=v-u;    &#125;    ans=(ans%mod+mod)%mod;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 448","url":"/project-euler/448/","content":"\r\nProject Euler 448\r\n题目\r\nAverage least common\r\nmultiple\r\nThe function \\(\\mathbf{lcm}(a,b)\\)\r\ndenotes the least common multiple of \\(a\\) and \\(b\\).\r\nLet \\(A(n)\\) be the average of the\r\nvalues of \\(\\mathbf{lcm}(n,i)\\) for\r\n\\(1\\le i\\le n\\).\r\nE.g: \\(A(2)=(2+2)/2=2\\) and \\(A(10)=(10+10+30+20+10+30+70+40+90+10)/10=32\\).\r\nLet \\(S(n)=\\sum A(k)\\) for \\(1\\le k\\le n\\).\r\n\\(S(100)=122726\\).\r\nFind \\(S(99999999019) \\bmod\r\n999999017\\).\r\n解决方案\r\n化简\\(A(n)\\)，有\r\n\\(\\begin{aligned}\r\nA(n)&amp;=\\sum_{i=1}^n \\dfrac{\\mathbf{lcm}(n,i)}{n}\\\\\r\n&amp;=\\sum_{i=1}^n \\dfrac{i}{\\gcd(n,i)}\\\\\r\n&amp;=\\sum_{g\\mid n}\\sum_{m=1}^{n/g} [\\gcd(n/g,m)=1]\\cdot m\\\\\r\n&amp;=\\sum_{d\\mid n}\\sum_{m=1}^{d} [\\gcd(d,m)=1]\\cdot m\\\\\r\n\\end{aligned}\\)\r\n令\\(\\displaystyle{f(n)=\\sum_{m=1}^{n}\r\n[\\gcd(n,m)=1]\\cdot n}\\)，根据OEIS序列A023896，可以知道:\r\n\\(f(n)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad n=1 \\\\\r\n  &amp;\\dfrac{n\\cdot \\varphi(n)}{2}&amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\\)\r\n那么可以如下化简\\(S(n)\\)：\r\n\\(\\begin{aligned}\r\nS(n)&amp;=\\sum_{m=1}^n A(m)\\\\\r\n&amp;=\\sum_{m=1}^n \\sum_{d\\mid m} f(n)\\\\\r\n&amp;=\\sum_{m=1}^n \\left\\lfloor\\dfrac{n}{m}\\right\\rfloor\\cdot f(n)\\\\\r\n&amp;=n+\\dfrac{1}{2}\\sum_{m=2}^n\r\n\\left\\lfloor\\dfrac{n}{m}\\right\\rfloor\\cdot m\\cdot \\varphi(m)\\\\\r\n&amp;=\\dfrac{1}{2}\\left(n+\\sum_{m=1}^n\r\n\\left\\lfloor\\dfrac{n}{m}\\right\\rfloor\\cdot m\\cdot \\varphi(m)\\right)\\\\\r\n\\end{aligned}\\)\r\n那么接下来的任务是计算\\(\\displaystyle{g(n)=\\sum_{m=1}^n\r\n\\left\\lfloor\\dfrac{n}{m}\\right\\rfloor\\cdot m\\cdot\r\n\\varphi(m)}\\)的值。\r\n令\\(\\displaystyle{h(n)=\\sum_{m=1}^n m\\cdot\r\n\\varphi(m)}\\)。不难发现，我们可以使用数论分块来计算\\(g(n)\\)的值：\r\n\\[g(n)=\\sum_{n=1}^{\\lfloor\\frac{n}{t+1}\\rfloor}\r\n\\left\\lfloor\\dfrac{n}{m}\\right\\rfloor\\cdot m\\cdot \\varphi(m) +\r\n\\sum_{m=1}^t\r\nm\\cdot\\left(h\\left(\\left\\lfloor\\dfrac{n}{m}\\right\\rfloor\\right)-h\\left(\\left\\lfloor\\dfrac{n}{m+1}\\right\\rfloor\\right)\\right)\\]\r\n其中\\(t=\\lfloor\\sqrt{n}\\rfloor\\)。\r\n那么接下来就是计算\\(h(n)\\)的值，有：\r\n\\(\\begin{aligned}\r\n\\dfrac{n(n+1)(2n+1)}{6} &amp;=\\sum_{k=1}^n k^2\\\\\r\n&amp;=\\sum_{k=1}^n k\\cdot \\sum_{d\\mid k}\\varphi(d)\\\\\r\n&amp;=\\sum_{d=1}^n \\varphi(d)\\cdot \\sum_{i=1}^{\\lfloor n/d\\rfloor}(id)\\\\\r\n&amp;=\\sum_{d=1}^n \\varphi(d)\\cdot d\\cdot \\sum_{i=1}^{\\lfloor\r\nn/d\\rfloor}i\\\\\r\n&amp;=\\sum_{i,d\\ge 1;id\\le n}^n \\varphi(d)\\cdot d\\cdot i\\\\\r\n&amp;=\\sum_{i=1}^n i\\cdot \\sum_{d=1}^{\\lfloor n/i\\rfloor}\r\n\\varphi(d)\\cdot d\\\\\r\n&amp;=\\sum_{i=1}^n i\\cdot\r\nh\\left(\\left\\lfloor\\dfrac{n}{i}\\right\\rfloor\\right)\r\n\\end{aligned}\\)\r\n因此，可以得到关于\\(h\\)的递归式：\r\n\\[h(n)=\\dfrac{n(n+1)(2n+1)}{6}-\\sum_{i=2}^n i\\cdot\r\nh\\left(\\left\\lfloor\\dfrac{n}{i}\\right\\rfloor\\right)\\]\r\n因此，同样右边这一部分可以继续使用数论分块来解决。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;#include &quot;tools.h&quot;using namespace std;typedef long long ll;const ll N=99999999019;ll mod=999999017;ll inv6=mod_inverse(6,mod);ll inv2=mod_inverse(2,mod);unordered_map&lt;ll,ll&gt;mp;const int M=20000000;int phi[M+4];ll sg[M+4];ll s(ll n)&#123;    n%=mod;    return n*(n+1)%mod*(n*2+1)%mod*inv6%mod;&#125;ll calH(ll n)&#123;    if(n&lt;=M) return sg[n];    else if(mp.count(n)) return mp[n];    ll ans=s(n);    for(ll l=2,r;l&lt;=n;l=r+1)&#123;        r=n/(n/l);        ans-=(l+r)%mod*((r-l+1)%mod)%mod*inv2%mod*calH(n/l)%mod;    &#125;    ans=(ans%mod+mod)%mod;    return mp[n]=ans;&#125;ll cal()&#123;    ll ans=0;    for(int i=1;i&lt;=min(N,1ll*M);i++)        ans=(ans+N/i%mod*phi[i]%mod*i)%mod;    for(ll l=M+1,r;l&lt;=N;l=r+1)&#123;        ll k=N/l;r=N/k;        ans=(ans+k*(calH(r)-calH(l-1)+mod)%mod)%mod;    &#125;    return (ans+N)%mod*inv2%mod;&#125;int main()&#123;    for(int i=1;i&lt;=M;i++)        phi[i]=i;    for(int i=2;i&lt;=M;i++)        if(phi[i]==i)&#123;            for(int j=i;j&lt;=M;j+=i)                phi[j]=phi[j]/i*(i-1);        &#125;    for(int i=1;i&lt;=M;i++)        sg[i]=(sg[i-1]+1ll*i*phi[i])%mod;    ll ans=cal();    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 430","url":"/project-euler/430/","content":"\r\nProject Euler 430\r\n题目\r\nRange flips\r\nN disks are placed in a row, indexed \\(1\\) to \\(N\\) from left to right.\r\nEach disk has a black side and white side. Initially all disks show\r\ntheir white side.\r\nAt each turn, two, not necessarily distinct, integers \\(A\\) and \\(B\\) between \\(1\\) and \\(N\\) (inclusive) are chosen uniformly at\r\nrandom.\r\nAll disks with an index from \\(A\\)\r\nto \\(B\\) (inclusive) are flipped.\r\nThe following example shows the case \\(N =\r\n8\\). At the first turn \\(A = 5\\)\r\nand \\(B = 2\\), and at the second turn\r\n\\(A = 4\\) and \\(B = 6\\).\r\n\r\nLet \\(E(N, M)\\) be the expected\r\nnumber of disks that show their white side after \\(M\\) turns.\r\nWe can verify that \\(E(3, 1) = 10/9, E(3,\r\n2) = 5/3, E(10, 4) \\approx 5.157\\) and \\(E(100, 10) \\approx 51.893\\).\r\nFind \\(E(10^{10}, 4000)\\).\r\nGive your answer rounded to \\(2\\)\r\ndecimal places behind the decimal point.\r\n解决方案\r\n我们将独立考虑每一个棋子的情况。\r\n令\\(I_{i,m}\\)表示示性随机变量：经过\\(m\\)轮翻转后，棋子仍然白色面朝上。（也就是说，发生了偶数次的翻转）\r\n对于第\\(i\\)个棋子，它在某一轮被翻转一次的概率为\\(p_i=\\dfrac{2i(n-i+1)-1}{n^2}\\).\r\n那么第\\(i\\)个棋子在这\\(m\\)次翻转中，其翻转次数\\(X_{i}\\)服从二项分布\\(B(m,p_i)\\)。令\\(q_i=1-p_i\\)\r\n结合\r\n\\(\\begin{aligned}\r\n&amp;(p+q)^m=\\sum_{i=0}^m\\dbinom{m}{i}p^iq^{m-i}\\\\\r\n&amp;(-p+q)^m=\\sum_{i=0}^m\\dbinom{m}{i}(-p)^iq^{m-i}\\\\\r\n\\end{aligned}\\)\r\n这两个式子可以得到\\(X\\)为偶数时的概率，也就是有\r\n\\(\\begin{aligned}\r\nI_{i,m}&amp;=P\\{X\\text{ is even}\\}\\\\\r\n&amp;=\\dfrac{1}{2}((q_i+p_i)^m+(q_i-p_i)^m)\\\\\r\n&amp;=\\dfrac{1}{2}(1+(1-2p_i)^m)\r\n\\end{aligned}\\)\r\n那么\r\n\\(\\begin{aligned}\r\nE(n,m)&amp;=\\sum_{i=1}^{n}I_{i,m}\\\\\r\n&amp;=\\sum_{i=1}^{n}\\dfrac{1}{2}(1+(1-2p_i)^m)\\\\\r\n&amp;=\\dfrac{n}{2}+\\dfrac{1}{2}\\sum_{1=1}^n(1-2p_i)^m\r\n\\end{aligned}\\)\r\n这时我们考虑计算\\(\\sum_{1=1}^n(1-2p_i)^m\\)的值。当\\(i\\approx\\dfrac{n}{2}\\)时，\\(p_i\\approx\\dfrac{1}{2}\\)，此时级数靠中央的所有项几乎可以忽略。因此，直接暴力进行计算即可。\r\n不难证明\\(p_i=p_{n+1-i}\\)，因此我们只需要计算一侧的结果即可。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll N=10000000000;const int M=4000;const int F=2;double eps= exp10(-F-20);double g(ll i,ll n) &#123;    return (2.0 * i * (n - i + 1) - 1) / n / n;&#125;int main()&#123;    double ans=0.5*N;    double s=0;    if(N&lt;=1000000)&#123;        for(int i=1;i&lt;=N;i++)&#123;            s+=pow(1.0-g(i,N)*2,M);        &#125;        ans+=s/2;    &#125;    else&#123;        ll i;        for(i=1;i+i&lt;=N;i++)&#123;            double w=pow(1.0-g(i,N)*2,M);            if(w&lt;eps) break;            s+=w;        &#125;        ans+=s;        if(i+i==N+1) ans+=0.5*pow(1.0-g(i,N)*2,M);    &#125;    printf(&quot;%.*f\\n&quot;,F,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 449","url":"/project-euler/449/","content":"\r\nProject Euler 449\r\n题目\r\nChocolate covered candy\r\nPhil the confectioner is making a new batch of chocolate covered\r\ncandy. Each candy centre is shaped like an ellipsoid of revolution\r\ndefined by the equation: \\(b^2x^2 + b^2y^2 +\r\na^2z^2 = a^2b^2\\).\r\nPhil wants to know how much chocolate is needed to cover one candy\r\ncentre with a uniform coat of chocolate one millimeter thick.\r\nIf \\(a=1\\text{mm}\\) and \\(a=1\\text{mm}\\), the amount of chocolate\r\nrequired is \\(\\frac{28}{3}π\r\n\\text{mm}^3\\).\r\nIf \\(a=2\\text{mm}\\) and \\(a=1\\text{mm}\\), the amount of chocolate\r\nrequired is approximately \\(60.35475635\r\n\\text{mm}^3\\).\r\nFind the amount of chocolate in \\(\\text{mm}^3\\) required if \\(a=3 \\text{mm}\\) and \\(b=1 \\text{mm}\\). Give your answer as the\r\nnumber rounded to \\(8\\) decimal places\r\nbehind the decimal point.\r\n平行曲线(Parallel Curves)\r\n平行曲线，即将这个曲线上的所有点朝着其在曲线上的法线方向移动相同的距离。可以向内也可以向外。\r\n如果一个曲线\\(F\\)的参数方程为\\((f(t),g(t))\\)，移动\\(k\\)的距离，那么移动后的曲线\\(F&#39;\\)的参数方程为 \\[\\left\\{\r\n\\begin{aligned}\r\nx(t) &amp; = &amp;\r\nf(t)\\pm\\frac{kg&#39;(t)}{\\sqrt{f&#39;^2(t)+g&#39;^2(t)}} \\\\\r\ny(t) &amp; = &amp;\r\ng(t)\\mp\\frac{kf&#39;(t)}{\\sqrt{f&#39;^2(t)+g&#39;^2(t)}}\r\n\\end{aligned}\r\n\\right.\r\n\\]\r\n解决方案\r\n本题中可将椭圆的方程化为\\(\\frac{x^2}{a^2}+\\frac{y^2}{a^2}+\\frac{z^2}{b^2}=1\\).因此可以将这个物体视为是\\(XOZ\\)平面上一个围绕\\(z\\)轴的旋转体。\r\n那么，\\(XOZ\\)平面上的这个方程可以视为\\(\\frac{x^2}{a^2}+\\frac{z^2}{b^2}=1\\).\r\n那么可以看出，这个\\(XOZ\\)平面上的椭圆的参数方程为\\(x=a\\cos t,z=b\\sin t\\).\r\n本体题意所需要的新的平行曲线是向外的，因此代入平行曲线中的式子，可以得到\r\n\\[\\left\\{\r\n\\begin{aligned}\r\nx(t) &amp; = &amp; a\\cos t + \\frac{bk \\cos t}{\\sqrt{a^2\\sin ^2t+b^2\r\n\\cos^2 t}} \\\\\r\nz(t) &amp; = &amp; b\\sin t + \\frac{ak \\sin t}{\\sqrt{a^2\\sin ^2t+b^2\r\n\\cos^2 t}}\r\n\\end{aligned}\r\n\\right.\r\n\\] 那么最终形成的物体的体积为 \\[V=\\int\r\n_{-\\frac{\\pi}{2}}^{\\frac{\\pi}{2}}\\pi x^2(t)\r\nd(z(t))=\\int_{-\\frac{\\pi}{2}}^{\\frac{\\pi}{2}}\\pi x^2(t)\r\nz&#39;(t)dt\\]\r\n减去原来已经有的，那么答案为\\(V_0=V-\\frac{4}{3}\\pi a^2b\\)。\r\n代码\r\na = 3b = 1k = 1x[t_] = a Cos[t] + b k Cos[t]/Sqrt[(a Sin[t])^2 + (b Cos[t])^2]z[t_] = b Sin[t] + a k Sin[t]/Sqrt[(a Sin[t])^2 + (b Cos[t])^2]N[Integrate[Pi*x[t]^2*D[z[t], t], &#123;t, -Pi/2, Pi/2&#125;] - 4 Pi a^2 b/3, 11]\r\n","categories":["Project Euler"]},{"title":"Project Euler 45","url":"/project-euler/45/","content":"\r\nProject Euler 45\r\n题目\r\nTriangular, pentagonal, and\r\nhexagonal\r\nTriangle, pentagonal, and hexagonal numbers are generated by the\r\nfollowing formulae:\r\n\r\n\r\n\r\nTriangle\r\n\\(T_n=\\dfrac{n(n+1)}{2}\\)\r\n\\(1, 3, 6, 10, 15,\\dots\\)\r\n\r\n\r\nPentagonal\r\n\\(P_n=\\dfrac{n(3n−1)}{2}\\)\r\n\\(1, 5, 12, 22, 35, \\dots\\)\r\n\r\n\r\nHexagonal\r\n\\(H_n=n(2n−1)\\)\r\n\\(1, 6, 15, 28, 45, \\dots\\)\r\n\r\n\r\n\r\nIt can be verified that \\(T_{285} = P_{165}\r\n= H_{143} = 40755\\).\r\nFind the next triangle number that is also pentagonal and\r\nhexagonal.\r\n解决方案\r\n每次先对当前(因变量，函数)进行排序。如果排完序后，发现三个函数值相同，那么说明找到了一个同时是三角形数、五边形数和六角形数的数，如果需要找下一个，就把所有自变量加一。\r\n否则，就将函数值最小的那个函数自变量加一，以此保持三个函数值之间的大小平衡。\r\n代码\r\nN = 3def T(n):    return (n * (n + 1)) &gt;&gt; 1def P(n):    return (n * (3 * n - 1)) &gt;&gt; 1def H(n):    return n * (2 * n - 1)ls = [[1, T], [1, P], [1, H]]while True:    ls.sort(key=lambda x: x[1](x[0]))    if ls[0][1](ls[0][0]) == ls[-1][1](ls[-1][0]):        N -= 1        if N == 0:            ans = ls[0][1](ls[0][0])            break        ls[0][0] += 1        ls[1][0] += 1        ls[2][0] += 1    else:        ls[0][0] += 1print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 451","url":"/project-euler/451/","content":"\r\nProject Euler 451\r\n题目\r\nModular inverses\r\nConsider the number \\(15\\).\r\nThere are eight positive numbers less than \\(15\\) which are coprime to \\(15: 1,2, 4, 7, 8, 11, 13, 14\\).\r\nThe modular inverses of these numbers modulo 15 are: \\(1, 8, 4, 13, 2, 11, 7, 14\\) because\r\n\\(\\begin{aligned}\r\n1 \\cdot 1 &amp;\\bmod 15=1\\\\\r\n2 \\cdot 8=16 &amp;\\bmod 15=1\\\\\r\n4 \\cdot 4=16 &amp;\\bmod 15=1\\\\\r\n7 \\cdot 13=91 &amp;\\bmod 15=1\\\\\r\n11 \\cdot 11=121 &amp;\\bmod 15=1\\\\\r\n14 \\cdot 14=196 &amp;\\bmod 15=1\r\n\\end{aligned}\\)\r\nLet \\(I(n)\\) be the largest positive\r\nnumber \\(m\\) smaller than \\(n-1\\) such that the modular inverse of\r\n\\(m\\) modulo \\(n\\) equals \\(m\\) itself.\r\nSo \\(I(15)=11\\).\r\nAlso \\(I(100)=51\\) and \\(I(7)=1\\).\r\nFind \\(\\sum I(n)\\) for \\(3\\le n\\le2\\cdot10^7\\)\r\n解决方案\r\n将问题进行正式描述：求\\(I(n)\\)的值，其中\\(I(n)\\)是方程\\(x^2\\equiv 1\\pmod n\\)中，小于\\(n-1\\)的最大正整数解。方程也可以化为：\r\n\\[(x+1)(x-1)\\equiv 0\\pmod\r\nn\\qquad(1)\\]\r\n假设\\(n\\)的分解质因数为\\(n=\\prod_{i=1}^{k}\r\np_i^{e_i}\\)，那么不难发现：\r\n\r\n对于任意一个\\(p_i\\)为奇数的\\(p_i^{e_i}\\)，要么\\(p_i^{e_i}\\mid x-1\\)，要么\\(p_i^{e_i}\\mid (x+1)\\)，因此方程\\((x+1)(x-1)\\equiv 0 \\pmod\r\n{p_i^{e_i}}\\)只有两个解：\\(1,-1\\)。\r\n对于\\(2^{e}\\)，在保持上面的性质的基础上，可以发现\\(4\\)并不能整除\\((x+1)\\)和\\((x-1)\\)，但是\\(2\\)可以，因此对于方程\\((x+1)(x-1)\\equiv 0\\pmod {2^e}\\)一共有\\(4\\)个解：\\(1,-1,2^{e-1}-1,2^{e-1}+1\\).当\\(e\\le 2\\)时，需要将这些值相同的解合并。\r\n\r\n最终，对于每个\\(p_i^{e_i}\\)分量，方程\\((x+1)(x-1)\\equiv 0 \\pmod\r\n{p_i^{e_i}}\\)都有多个解。通过中国剩余定理将它们进行合并成原方程\\((1)\\)的解再取最大值即可。\r\n不过由于数据范围\\(N=2\\times\r\n10^7\\)，比较大，因此实际上实现的时候，使用中国剩余定理先将多个形如\\(x^2\\equiv 1\\pmod\r\n{p_i^{e_i}}\\)方程的解两个两个地进行组合。具体方式如下：\r\n假设\\(n&#39;=\\prod_{i=1}^{k&#39;}p_i^{e_i},k&#39;&lt;\r\nk,m=p_{k&#39;+1}^{e_{k&#39;+1}}\\)，如果我们已经解出了\\(x^2\\equiv 1 \\pmod\r\n{n&#39;}\\)的所有解，那么再方程的所有解\\(x_b\\)和方程\\(x^2\\equiv 1 \\pmod {m}\\)的所有解\\(x_a\\)（注意\\(x_a\\)要么为\\(1\\)，要么为\\(-1\\)）一一组合，得到如下方程组：\r\n\\[\r\n\\left \\{\\begin{aligned}\r\n  &amp; x\\equiv x_a\\pmod {m}\\\\\r\n  &amp; x\\equiv x_b\\pmod {n&#39;}\\\\\r\n\\end{aligned}\\right.\r\n\\]\r\n令\\(x=t_am+x_a=t_bn&#39;+x_b\\)，那么得到一个以\\(t_a\\)和\\(t_b\\)为未知数的方程\\(t_am-t_bn&#39;=x_b-x_a\\).\r\n通过扩展欧几里得算法，我们可以解得方程\\(t_a&#39;m-t_b&#39;n&#39;=1\\)的解\\((t_a&#39;,t_b&#39;)\\)。那么得到\\(t_a=(x_b-x_a)t_a&#39;\\)\r\n那么得到\\(x=t_am+x_a=(x_b-x_a)t_a&#39;m+x_a=x_bt_a&#39;m+x_a(1-t&#39;_am)\\)。由于\\(x_a\\)能够分别取\\(1\\)和\\(-1\\)，因此每合并一个方程，都能够产生两个解：\\(x_bt_a&#39;m\\pm(1-t&#39;_am)\\)\r\n代码\r\n#include &lt;bits/stdc++.h&gt;# define lb(x) ((x)&amp;(-x))using namespace std;typedef long long ll;const int N=2e7;int qpow(ll n,ll m,ll mod)&#123;    ll a=1;    for(;m;m&gt;&gt;=1)&#123;        if(m&amp;1) a=a*n%mod;        n=n*n%mod;    &#125;    return a;&#125;int mxp[N+4];int a[1004],c=0;int r[14],m=0;int main()&#123;    for(int p=3;p&lt;=N;p++)        if(!mxp[p])            for(int i=p;i&lt;=N;i+=p) mxp[i]=p;    ll ans=0;    for(int i=3;i&lt;=N;i++)&#123;        m=c=0;        int pw2=lb(i);        if((pw2&amp;1)==0)&#123;            a[c++]=1;            if((pw2&amp;2)==0)&#123;                a[c++]=pw2-1;                if((pw2&amp;4)==0)&#123;                    a[c++]=(pw2&gt;&gt;1)+1;                    a[c++]=(pw2&gt;&gt;1)-1;                &#125;            &#125;        &#125;        else a[c++]=0;        int mul=pw2;        for(int v=i/mul;v!=1;)&#123;            int p=mxp[v],pw=1;            for(;v%p==0;v/=p,pw*=p);            int nmul=mul*pw;            ll x=qpow(mul,pw/p*(p-1)-1,pw)*mul%nmul;            ll y=1ll-x;            for(int pc=c,j=0;j&lt;pc;j++)&#123;                a[c++]=(a[j]*y+x)%nmul;                a[j]=(a[j]*y-x)%nmul;            &#125;            mul=nmul;        &#125;        int mx=0;        for(int j=0;j&lt;c;j++)&#123;            if(a[j]&lt;0) a[j]+=i;            if(a[j]!=i-1) mx=max(mx,a[j]);        &#125;        ans+=mx;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 457","url":"/project-euler/457/","content":"\r\nProject Euler 457\r\n题目\r\nA polynomial modulo\r\nthe square of a prime\r\nLet \\(f(n) = n^2 - 3n - 1\\).\r\nLet \\(p\\) be a prime.\r\nLet \\(R(p)\\) be the smallest\r\npositive integer \\(n\\) such that \\(f(n) \\bmod p^2 = 0\\) if such an integer\r\n\\(n\\) exists, otherwise \\(R(p) = 0\\).\r\nLet \\(SR(L)\\) be \\(\\sum R(p)\\) for all primes not exceeding\r\n\\(L\\).\r\nFind \\(SR(10^7)\\).\r\nTonelli–Shanks算法\r\nTonelli–Shanks算法是用于求解方程\\(x^2\\equiv a\\pmod p\\)的一个算法，其中\\(p\\)是一个质数。\r\n为求解这个方程，第一步首先需要使用欧拉准则进行判断方程是否有解：\r\n如果有解（\\(a\\)是二次剩余），那么有\\(a^{\\frac{p-1}{2}}\\equiv 1\\pmod\r\np\\)；否则（\\(a\\)不是二次剩余），有\\(a^{\\frac{p-1}{2}}\\equiv -1\\pmod p\\)。\r\n如果\\(p\\%\r\n4=3\\)，那么方程的其中一个解为\\(a^{\\frac{p+1}{4}}\\%P\\)。\r\n否则，先将\\(p-1\\)写成\\(p-1=Q2^S\\)，其中\\(Q\\)是一个奇数。并且随机找到一个\\(z\\)使得\\(z\\)是\\(p\\)的一个非二次剩余（注意这样的\\(z\\)有一半数量，很容易找到）。\r\n接下来初始化这一系列值：\r\n\\(\\begin{aligned}\r\nm&amp;\\leftarrow S\\\\\r\nc&amp;\\leftarrow z^Q\\\\\r\nt&amp;\\leftarrow a^Q\\\\\r\nr&amp;\\leftarrow a^{\\frac{Q+1}{2}}\r\n\\end{aligned}\\)\r\n然后对以下过程进行无限循环：\r\n\r\n如果\\(t=0\\)，返回\\(x=0\\)。\r\n如果\\(t=1\\)，返回\\(x=r\\)。\r\n找到最小的\\(i\\)使得\\(t^{2^i}\\equiv 1\\pmod p\\)\r\n接下来继续进行一系列赋值：\r\n\r\n\\(\\begin{aligned}\r\nb&amp;\\leftarrow c^{2^{m-i-1}}\\\\\r\nm&amp;\\leftarrow i\\\\\r\nc&amp;\\leftarrow b^2\\\\\r\nt&amp;\\leftarrow tb^2\\\\\r\nr&amp;\\leftarrow rb\r\n\\end{aligned}\\)\r\n整个算法的期望时间复杂度为\\(O(\\log^2\r\np)\\)。\r\nHensel引理\r\nHensel引理通常用于求解方程\\(f(x)\\equiv 0\\pmod {p^k}\\)，其中\\(f(x)\\)是一个整系数多项式，\\(p\\)是一个质数。它的基本思想是假设已知方程\\(f(x)\\equiv 0\\pmod\r\n{p^{k-1}}\\)的根，再将它扩展到\\(f(x)\\equiv 0 \\pmod {p^k}\\)时的情况。\r\n假设整数\\(r\\)满足\\(f(r)\\equiv0 \\pmod\r\n{p^{k-1}}\\)，那么考虑关于未知数\\(t\\)的方程：\r\n\\[f(r+tp^{k-1})\\equiv 0\\pmod\r\n{p^k}\\qquad(1)\\]\r\n\r\n如果\\(f&#39;(r)\\not\\equiv 0\\pmod\r\np\\)，那么存在唯一的正整数\\(t\\)使得\\((1)\\)成立。这个\\(t\\)满足\r\n\r\n\\[\\displaystyle tf&#39;(r)\\equiv\r\n-\\dfrac{f(r)}{p^{k-1}}{\\pmod {p}}\\]\r\n\r\n如果\\(f&#39;(r)\\equiv 0\\pmod\r\np,f(r)\\equiv0\\pmod p\\)，那么对于任意\\(t\\)，方程\\((1)\\)恒成立。\r\n如果\\(f&#39;(r)\\equiv 0\\pmod\r\np,f(r)\\not\\equiv0\\pmod p\\)，那么方程\\((1)\\)无解。\r\n\r\n解决方案\r\n题目的目标为求解方程\\(n^2-3n-1\\equiv 0\\pmod\r\n{p^2}\\)。\r\n由于\\(p\\)是一个质数（\\(p=2\\)时容易发现无解，不讨论），那么方程两边乘以一个\\(4\\)，配方后得到：\r\n\\[(2n-3)^2\\equiv13\\pmod {p^2}\\]\r\n为了避免特殊判断，当质数\\(p\\le\r\n13\\)时，\\(R(p)\\)将会被暴力计算出来。\r\n令\\(x=2n-3\\)，那么原方程的解将通过\\(n=\\dfrac{x+3}{2}\\)计算出来。\r\n令\\(f(x)=x^2-13\\)，假设通过Tonelli–Shanks算法求解得出方程\\(f(x)\\equiv0{\\pmod p}\\)的值为\\(r\\)。\r\n为求解\\(f(x)\\equiv0 \\pmod\r\n{p^2}\\)，根据Hensel引理，新解为\\(x=r+tp\\)，其中\\(t\\equiv \\dfrac{13-r^2}{p}\\cdot (2r)^{-1} \\pmod\r\np\\)\r\n最终分别计算出两个\\(x\\)后，回代出两个\\(n\\)的值，取最小值即可。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int M=10000000;int v[M+4],pr[M/10+1000],m=0;ll qpow(ll n,ll m,ll p)&#123;    ll a=1;    for(;m;m&gt;&gt;=1)&#123;        if(m&amp;1) a=a*n%p;        n=n*n%p;    &#125;    return a;&#125;int shanks(int a,int p) &#123;    if (p % 4 == 3)        return qpow(a, (p + 1) / 4, p);    int Q = p - 1;    int S = 0;    for (; !(Q &amp; 1); Q &gt;&gt;= 1) S++;    int z;    for (int i = 1; i &lt;= m; i++) &#123;        z = pr[i];        if (qpow(z, (p - 1) / 2, p) == p - 1) break;    &#125;    ll m = S;    ll c = qpow(z, Q, p);    ll t = qpow(a, Q, p);    ll r = qpow(a, (Q + 1) / 2, p);    while (true) &#123;        if (t == 0) return 0;        if (t == 1) return r;        ll tmp = t;        int i;        for (i = 0; i &lt; m &amp;&amp; tmp != 1; i++)            tmp = tmp * tmp % p;        ll b = qpow(c, 1 &lt;&lt; (m - i - 1), p);        m = i;        c = b * b % p;        t = t * c % p;        r = r * b % p;    &#125;&#125;int main()&#123;    for(int i=2;i&lt;=M;i++)&#123;        if(v[i]==0)&#123;            v[i]=i;pr[++m]=i;        &#125;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;M/i) break;            v[i*pr[j]]=pr[j];        &#125;    &#125;    ll ans=0;    for(int i=1;i&lt;=m;i++)&#123;        int p=pr[i];        if(p&lt;=13)&#123;            for(int n=1;n&lt;p*p;n++)&#123;                if((n*n-3*n-1)%(p*p)==0)&#123;                    ans+=n;                    break;                &#125;            &#125;        &#125;        else&#123;            if(qpow(13,(p-1)&gt;&gt;1,p)!=1) continue;            ll p2=1ll*p*p;            ll r=shanks(13,p);            ll t=((13ll-r*r)/p*qpow(r*2,p-2,p)%p+p)%p;            ll x=p*t+r;            ll n=(x&amp;1?(x+3)&gt;&gt;1:(x+3+p2)&gt;&gt;1);            x=p2-x;            ll m=(x&amp;1?(x+3)&gt;&gt;1:(x+3+p2)&gt;&gt;1);            ans+=min(n,m);        &#125;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 461","url":"/project-euler/461/","content":"\r\nProject Euler 461\r\n题目\r\nAlmost Pi\r\nLet \\(f_n(k)=e^{\\frac{k}{n}}-1\\),\r\nfor all non-negative integers \\(k\\).\r\nRemarkably, \\(f_{200}(6)+f_{200}(75)+f_{200}(89)+f_{200}(226)=\r\n\\underline{3.1415926}44529\\dots\\approx \\pi\\).\r\nIn fact, it is the best approximation of \\(\\pi\\) of the form \\(f_n(a)+f_n(b)+f_n(c)+f_n(d)\\) for \\(n=200\\).\r\nLet \\(g(n)=a^2+b^2+c^2+d^2\\) for\r\n\\(a, b, c, d\\) that minimize the error:\r\n\\(|f_n(a)+f_n(b)+f_n(c)+f_n(d)-\\pi|\\)\r\n(where \\(|x|\\) denotes the absolute\r\nvalue of \\(x\\)).\r\nYou are given \\(g(200)=6^2+75^2+89^2+226^2=64658\\).\r\nFind \\(g(10000)\\).\r\n解决方案\r\n可以看到，题中使用了\\(4\\)个\\(f_n(i)\\)进行逼近，那么我们考虑将这\\(4\\)个\\(f_n(i)\\)分成两对，然后使用meet-in-the-middle算法进行求解。\r\n\r\n先将所有\\(f_n(i)\\)枚举并计算出来，注意计算到的\\(f_n(i)&gt;\\pi\\)时，停止枚举。\r\n将以上的\\(f_n(i)+f_n(j)(i\\le\r\nj)\\)枚举出来。当枚举到\\(f_n(i)+f_n(j)&gt;\\pi\\)\r\n时，停止枚举。并记录所有的\\((f_n(i)+f_n(j),i^2+j^2)\\)二元组，存在数组\\(p\\)中。\r\n将\\(p\\)中按照第一关键字进行排序。这一步骤是算法中耗时最长的一部分。\r\n通过双指针法遍历数组\\(p\\)，找出最优的解。\r\n\r\n使用C++内置的pair比较慢，因此实现时重新自定义了一个结构体，整体效率大概增加了\\(\\dfrac{1}{3}\\)。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N=10000;double e=exp(1),pi=acos(-1.0);struct P&#123;    double x;    int id;    bool operator &lt; (const P &amp;p) const&#123;        return x&lt;p.x;    &#125;&#125;pa[N*N];double f[N+N];int m=0,n=0;int main()&#123;    double pi=acos(-1);    double mx=log(pi+1);    for(int i=0;i&lt;N+N;i++)&#123;        double e=1.0*i/N;        f[m++]=exp(e)-1;        if(e&gt;mx) break;    &#125;    for(int i=0;i&lt;m;i++)        for(int j=0;j&lt;=i;j++)&#123;            double w=f[i]+f[j];            pa[n++]=P&#123;w,i*i+j*j&#125;;            if(w&gt;pi) break;        &#125;    sort(pa,pa+n);    double eps=1e9;    int ans=0;    for(int l=0,r=n-1;l&lt;n;l++)&#123;        for(;r&gt;=0&amp;&amp;pa[l].x+pa[r].x&gt;pi;--r);        if(r&gt;0)&#123;            double w=abs(pi-pa[l].x-pa[r].x);            if(w&lt;eps)&#123;                eps=w;ans=pa[l].id+pa[r].id;            &#125;        &#125;        if(r+1&lt;n)&#123;            double w=abs(pi-pa[l].x-pa[r+1].x);            if(w&lt;eps)&#123;                eps=w;ans=pa[l].id+pa[r+1].id;            &#125;        &#125;    &#125;    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["meet-in-the-middle"]},{"title":"Project Euler 46","url":"/project-euler/46/","content":"\r\nProject Euler 46\r\n题目\r\nGoldbach’s other conjecture\r\nIt was proposed by Christian Goldbach that every odd composite number\r\ncan be written as the sum of a prime and twice a square\r\n\\(\\begin{aligned}\r\n9 &amp;= 7 + 2×1^2 \\\\\r\n15 &amp;= 7 + 2×2^2 \\\\\r\n21 &amp;= 3 + 2×3^2 \\\\\r\n25 &amp;= 7 + 2×3^2 \\\\\r\n27 &amp;= 19 + 2×2^2 \\\\\r\n33 &amp;= 31 + 2×1^2\\\\\r\n\\end{aligned}\\)\r\nIt turns out that the conjecture was false. What is the smallest odd\r\ncomposite that cannot be written as the sum of a prime and twice a\r\nsquare?\r\n解决方案\r\n从小到大先遍历每个奇数\\(n\\)，如果是合数，那就直接枚举\\(2i^2\\)，再判断\\(n-2i^2\\)是否为质数。否则就把当前素数添加进集合。\r\n可以发现这个数比较小，因此这种做法速度比较快。\r\n代码\r\nfrom itertools import countfrom tools import is_primepr = &#123;2&#125;for n in count(3, 2):    if is_prime(n):        pr.add(n)    else:        ok = False        for i in count(1, 1):            res = n - 2 * i * i            if res &lt;= 0:                break            if res in pr:                ok = True                break        if not ok:            ans = n            breakprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 458","url":"/project-euler/458/","content":"\r\nProject Euler 458\r\n题目\r\nPermutations of Project\r\nConsider the alphabet \\(A\\) made out\r\nof the letters of the word “project”: \\(A=\\{c,e,j,o,p,r,t\\}\\).\r\nLet \\(T(n)\\) be the number of\r\nstrings of length \\(n\\) consisting of\r\nletters from \\(A\\) that do not have a\r\nsubstring that is one of the \\(5040\\)\r\npermutations of “project”.\r\n\\(T(7)=7^7-7!=818503\\).\r\nFind \\(T(10^{12})\\). Give the last\r\n\\(9\\) digits of your answer.\r\n解决方案\r\n使用动态规划的思想做，使用矩阵快速幂进行优化。\r\n令\\(N=10^{12},M=7\\)。设\\(f(i,j)(1\\le i \\le N,1\\le j&lt; M,j\\le\r\ni)\\)为以下字符串的个数：长度为\\(i\\)，最后\\(j\\)个字符两两不同，但是最后\\(j+1\\)个字符却不是两两不同的。\r\n那么以矩阵的形式写出状态转移方程：\r\n\\[\r\n\\begin{bmatrix}\r\n1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1\\\\\r\n6 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1\\\\\r\n0 &amp; 5 &amp; 1 &amp; 1 &amp; 1 &amp; 1\\\\\r\n0 &amp; 0 &amp; 4 &amp; 1 &amp; 1 &amp; 1\\\\\r\n0 &amp; 0 &amp; 0 &amp; 3 &amp; 1 &amp; 1\\\\\r\n0 &amp; 0 &amp; 0 &amp; 0 &amp; 2 &amp; 1\r\n\\end{bmatrix}\r\n\\begin{bmatrix}\r\nf(i-1,1)\\\\\r\nf(i-1,2)\\\\\r\nf(i-1,3)\\\\\r\nf(i-1,4)\\\\\r\nf(i-1,5)\\\\\r\nf(i-1,6)\r\n\\end{bmatrix}\r\n=\r\n\\begin{bmatrix}\r\nf(i,1)\\\\\r\nf(i,2)\\\\\r\nf(i,3)\\\\\r\nf(i,4)\\\\\r\nf(i,5)\\\\\r\nf(i,6)\r\n\\end{bmatrix}\r\n\\]\r\n其中\\(f(1,1)=7,f(1,2)=f(1,3)=\\dots=f(1,6)=0\\)。\r\n对于状态\\(f(i,j)\\)，最后\\(j\\)个字符不同，那么可以随意新添加一个字符变成状态\\(f(i+1,j+1)\\)，有\\(m-j\\)种添加方式。或者是添加第\\(j\\)个字符中的倒数第\\(k\\)个，转换成状态\\(f(i+1,k)\\)（如以下例子）：\r\n一个字符串034523，添加一个5，变成0345235，也就是从\\(f(i,4)\\)转移到了\\(f(i+1,3)\\)；如果是添加一个2，那么变成0345232，转换成了状态\\(f(i+1,2)\\)；如果是添加一个6（同0和1），那么变成0345236，转换成状态\\(f(i+1,4)\\)。\r\n最终，直接使用矩阵快速幂进行处理即可，答案为\\(\\sum_{j=1}^{m-1}f(n,j)\\)。\r\n代码\r\nn = 10 ** 12m = 7mod = 10 ** 9def mul(a: list, b: list):    return [[sum(a[i][k] * b[k][j] for k in range(len(b))) % mod for j in range(len(b[0]))] for i in range(len(a))]a = [[m] + [0 for i in range(m - 2)]]b = [[0 for _ in range(m - 1)] for _ in range(m - 1)]for i in range(m - 2):    b[i][i + 1] = m - i - 1for i in range(m - 1):    for j in range(i + 1):        b[i][j] = 1n -= 1while n:    if n &amp; 1:        a = mul(a, b)    b = mul(b, b)    n &gt;&gt;= 1ans = sum(a[0]) % modprint(ans)\r\n","categories":["Project Euler"],"tags":["动态规划","矩阵快速幂"]},{"title":"Project Euler 463","url":"/project-euler/463/","content":"\r\nProject Euler 463\r\n题目\r\nA weird recurrence relation\r\nThe function \\(f\\) is defined for\r\nall positive integers as follows:\r\n\r\n\\(f(1)=1\\)\r\n\\(f(3)=3\\)\r\n\\(f(2n)=f(n)\\)\r\n\\(f(4n + 1)=2f(2n + 1) -\r\nf(n)\\)\r\n\\(f(4n + 3)=3f(2n + 1) -\r\n2f(n)\\)\r\n\r\nThe function \\(S(n)\\) is defined as\r\n\\(\\sum_{i=1}^{n}f(i)\\).\r\n\\(S(8)=22\\) and \\(S(100)=3604\\).\r\nFind \\(S(3^{37})\\). Give the last\r\n\\(9\\) digits of your answer.\r\n解决方案\r\n暴力枚举出\\(f\\)的前几项，在OEIS中查询得到结果为A030101。\r\n标题已经介绍了\\(f(n)\\)的含义：将\\(n\\)的二进制的所有比特进行逆序后得到的值。\r\n因此，计算\\(S(n)\\)时，分块计算：\\([2^0,2^1),[2^1,2^2),\\dots,[2^i,2^{i+1})\\)中的和。不难发现：\r\n\\[\\sum_{j=2^i}^{2^{i+1}-1}f(j)=2^i+\\dfrac{2^i\\cdot\r\n(0+2^i-1)}{2} \\cdot 2=2^{2i}\\]\r\n对于满足\\(2^i\\le n\r\n&lt;2^{i+1}-1\\)的这个区间，我们采用另一种计算方式。\r\n将\\(n\\)写成一个\\(k\\)位二进制数\\(n=n_0n_1n_2\\dots\r\nn_{k-1}\\)，从高到低位遍历位数，如果\\(n_i=1\\)，那么对于任意\\(m\\)满足\\(m_0=n_0,m_1=n_1,\\dots,m_{i-1}=n_{i-1}\\)，如果\\(m_i=0\\)，那么说明无论\\(m_{i+1},m_{i+2},\\dots,m_k\\)怎么取，\\(m&lt;n\\)\r\n均成立。因为最后面这一部分是自由选择的，我们将这一部分合并在一起算。\r\n如以下例子，'.'上的数无论怎么取，都比\\(n\\)小：\r\nn = 1 0 1 0 1 0 0 0 1 0 1 0m = 1 0 0 . . . . . . . . .\r\n因此，这一部分的和为\r\n\\[\\dfrac{2^{k-i-1}\\cdot (2^{k-i-1}-1)}{2}\r\n\\cdot 2^{i+1} + g_n(i)\\cdot 2^{k-i-1}\\]\r\n其中\\(g_n(i)\\)表示二进制数\\(n_{i-1}n_{i-2}\\dots n_1n_0.\\)\r\n按照上面的计算方法，枚举求和即可。注意需要跳过最高位，也就是\\(i=0\\)的情况。\r\n代码\r\nN = 3 ** 37mod = 10 ** 9N += 1s = 1ans = 0while s * 2 &lt;= N:    ans += (s - 1) * s + s    s &lt;&lt;= 1ls = list(map(int, list(bin(N)[2:])))st = 0for i in range(len(ls)):    if i &gt; 0 and ls[i]:        k = 1 &lt;&lt; (len(ls) - i - 1)        w = (k - 1) * k        ans += st * k + (w &lt;&lt; i)    st |= ls[i] &lt;&lt; ians %= modprint(ans)\r\n","categories":["Project Euler"],"tags":["OEIS"]},{"title":"Project Euler 47","url":"/project-euler/47/","content":"\r\nProject Euler 47\r\n题目\r\nDistinct primes factors\r\nThe first two consecutive numbers to have two distinct prime factors\r\nare:\r\n\\(14 = 2 × 7\\\\ 15 = 3 × 5\\)\r\nThe first three consecutive numbers to have three distinct prime\r\nfactors are:\r\n\\(644 = 2^2 × 7 × 23\\\\ 645 = 3 × 5 × 43\\\\\r\n646 = 2 × 17 × 19.\\)\r\nFind the first four consecutive integers to have four distinct prime\r\nfactors each. What is the first of these numbers?\r\n解决方案\r\n本题没有比较好的估计上限的方式，故使用一个个合数从小到大枚举直接进行枚举的算法。\r\n不过枚举过程中，有一点优化是：\r\n假设现在正在判断\\(m,m+1,m+2,m+3\\)是所求解。那么，如果\\(m+x(0&lt;x&lt;4)\\)是不符合条件的数，那么可以直接忽略掉\\(m\\sim\r\nm+x\\)之间的候选答案，直接判断后面4个数\\(m+x+1\\sim m+x+4\\)。\r\n这是因为只要在\\(m\\sim\r\nm+x\\)之间选了一个答案，终究还是要对\\(m+x\\)进行判定，故直接跳过这一段中所有的数。\r\n代码\r\nfrom tools import factorizationm = 2 * 3 * 5 * 7ans = 0while True:    if len(factorization(m)) != 4:        m += 1    elif len(factorization(m + 1)) != 4:        m += 2    elif len(factorization(m + 2)) != 4:        m += 3    elif len(factorization(m + 3)) != 4:        m += 4    else:        ans = m        breakprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 479","url":"/project-euler/479/","content":"\r\nProject Euler 479\r\n题目\r\nRoots on the Rise\r\nLet \\(a_k\\), \\(b_k\\), and \\(c_k\\) represent the three solutions (real\r\nor complex numbers) to the equation\r\n\\(\\dfrac{1}{x}=\\left(\\dfrac{k}{x}\\right)^2(k+x^2)-kx\\).\r\nFor instance, for \\(k=5\\), we see\r\nthat \\(\\{a_5, b_5, c_5 \\}\\) is\r\napproximately \\(\\{5.727244,\r\n-0.363622+2.057397i, -0.363622-2.057397i\\}\\).\r\nLet \\(\\displaystyle S(n) =\r\n\\sum_{p=1}^n\\sum_{k=1}^n(a_k+b_k)^p(b_k+c_k)^p(c_k+a_k)^p\\).\r\nInterestingly, \\(S(n)\\) is always an\r\ninteger. For example, \\(S(4) =\r\n51160\\).\r\nFind \\(S(10^6) \\text{ modulo\r\n}1\\,000\\,000\\,007\\).\r\n解决方案\r\n经过去分母和移项，原方程转化为\\(kx^3-k^2x^2+x-k^3=0(x \\neq 0)\\)。\r\n根据该页面关于三元一次方程\\(ax^3+bx^2+cx+d=0\\)的韦达定理：\r\n\\[x_1+x_2+x_3=-\\dfrac{b}{a},x_1x_2+x_2x_3+x_1x_3=\\dfrac{c}{a},x_1x_2x_3=-\\dfrac{d}{a}\\]\r\n得到：\r\n\\[a_k+b_k+c_k=k,a_kb_k+b_kc_k+c_ka_k=\\dfrac{1}{k},a_kb_kc_k=k^2\\]\r\n那么\r\n\\[(a_k+b_k)(b_k+c_k)(a_k+c_k)=(a_k+b_k+c_k)(a_kb_k+b_kc_k+c_ka_k)-a_kb_kc_k=1-k^2\\]\r\n因此再根据等比数列求和公式，有\r\n\\[S(n)=\\sum_{k=1}^n\\sum_{p=1}^n(1-k^2)^p=-\\sum_{k=1}^n\\dfrac{(1-k^2)((1-k^2)^n-1)}{k^2}\\]\r\n代码\r\nN = 10**6mod = 10 ** 9 + 7ans = 0for k in range(2, N + 1):    ans = (ans - (1 - k * k) * (pow(1 - k * k, N, mod) - 1) % mod * pow(k * k, mod - 2, mod)) % modprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 48","url":"/project-euler/48/","content":"\r\nProject Euler 48\r\n题目\r\nSelf powers\r\nThe series, \\(1^1 + 2^2 + 3^3 + … + 10^{10}\r\n= 10405071317\\).\r\nFind the last ten digits of the series, \\(1^1 + 2^2 + 3^3 + \\dots +\r\n1000^{1000}\\).\r\n解决方案\r\n快速幂算法，可以在\\(O(\\log\r\nm)\\)的时间复杂度内计算\\(a^m \\%\r\np\\)的值。\r\nPython代码如下：\r\ndef quick_power(a: int, m: int, p: int):    ans = 1    while m &gt; 0:        if m &amp; 1:            ans = ans * a % p        a = a * a % p        m &gt;&gt;= 1    return ans\r\n这个算法本质上是将幂\\(m\\)看作是二进制位。\r\n并且，\\(a^{2^i}\\)可以很容易地由\\(a^{2^{i-1}}\\)计算出：\\(a^{2^i}=(a^{2^{i-1}})^2\\)。\r\n因此，将幂指数\\(m\\)看作是二进制数，如果第\\(i\\)位上是\\(1\\)，那么就将结果乘上\\(a^{2^i}\\)。将所有值累乘起来就得到答案。\r\n由于Python自带pow(a,m,p)，因此直接调用即可。\r\n代码\r\nN = 1000mod = 10000000000ans = 0for i in range(1, N + 1):    ans = (ans + pow(i, i, mod)) % modprint(&quot;&#123;:09&#125;&quot;.format(ans))\r\n","categories":["Project Euler"]},{"title":"Project Euler 49","url":"/project-euler/49/","content":"\r\nProject Euler 49\r\n题目\r\nPrime permutations\r\nThe arithmetic sequence, \\(1487, 4817,\r\n8147\\), in which each of the terms increases by \\(3330\\), is unusual in two ways: (i) each of\r\nthe three terms are prime, and, (ii) each of the \\(4\\)-digit numbers are permutations of one\r\nanother.\r\nThere are no arithmetic sequences made up of three \\(1\\)-, \\(2\\)-, or \\(3\\)-digit primes, exhibiting this property,\r\nbut there is one other \\(4\\)-digit\r\nincreasing sequence.\r\nWhat \\(12\\)-digit number do you form\r\nby concatenating the three terms in this sequence?\r\n解决方案\r\n预处理出所有\\(4\\)位质数，并将使用相同数位的质数存放在一起。\r\n处于同一集合下的所有同数位的质数，最多只有\\(4!=24\\)个。因此可以直接暴力枚举，看看是否存在三个数为等差数列。\r\n代码\r\nfrom tools import get_primeM = 4pr = get_prime(10 ** M - 1)mp = &#123;&#125;for p in pr:    if p &gt;= 10 ** (M - 1):        s = &quot;&quot;.join((lambda x: (x.sort(), x)[1])(list(str(p))))        if s not in mp.keys():            mp[s] = []        mp[s].append(p)ls = []for v in mp.values():    for i in range(len(v)):        for j in range(i + 1, len(v)):            for k in range(j + 1, len(v)):                if v[j] + v[j] == v[i] + v[k]:                    ls.append(str(v[i]) + str(v[j]) + str(v[k]))ans = ls[1]print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 485","url":"/project-euler/485/","content":"\r\nProject Euler 485\r\n题目\r\nMaximum number of divisors\r\nLet \\(d(n)\\) be the number of\r\ndivisors of \\(n\\).\r\nLet \\(M(n,k)\\) be the maximum value\r\nof \\(d(j)\\) for \\(n \\le j \\le n+k-1\\).\r\nLet \\(S(u,k)\\) be the sum of \\(M(n,k)\\) for \\(1\r\n\\le n \\le u-k+1\\).\r\nYou are given that \\(S(1000,10)=17176\\).\r\nFind \\(S(100 000 000,100 000)\\).\r\n单调队列\r\n单调队列是一种数据结构，通常用于维护区间的最值。\r\n通常解决的问题是，给定一系列的区间\\([l_1,r_1],[l_2,r_2],[l_3,r_3],\\dots\\)的询问，分别求这些区间的最值。而且，\\(l_1\\le l_2\\le l_3\\le \\dots,r_1\\le r_2\\le r_3\\le\r\n\\dots\\)，即询问的\\(l_i,r_i\\)是不递减的。\r\n那么考虑维护一个队列。一开始，询问的元素都被推进队列中，随着整个程序的运行，序列前面的元素已经过时，不再被询问，被弹出队列；而后面需要被询问的元素逐渐被推入队列中。但是，推入的新元素可能比旧元素更优，那么此时旧元素原地退出队列，让位给新元素，整个过程将会保持队列的单调性。队头的元素最优，队尾的元素最劣。\r\n解决方案\r\n\\[S(N,K)=\\sum_{i=1}^{N-K+1}\r\n\\max_{j=i}^{i+K-1} \\{d(j)\\}\\]\r\n那么，询问值将是\\([1,K],[2,K+1],[3,K+2],\\dots\\)因此，使用单调队列来维护这些询问值。最终将每次维护结果的队头相加即可。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=100000000,K=100000;int f[N+4],v[N+4],pr[N/10+100],m=0;int main()&#123;    f[1]=1;    for(int i=2;i&lt;=N;i++)&#123;        if(v[i]==0) pr[++m]=i,v[i]=i,f[i]=2;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;N/i) break;            v[i*pr[j]]=pr[j];            f[i*pr[j]]=(v[i]==pr[j]?f[i]*2-f[i/pr[j]]:f[i]*2);        &#125;    &#125;    ll ans=0;    deque&lt;int&gt;q;    for(int i=K,j=1;i&lt;=N;i++)&#123;        while(!q.empty()&amp;&amp;i-q.front()&gt;=K) q.pop_front();        for(;j&lt;=i;j++)&#123;            while(!q.empty()&amp;&amp;f[j]&gt;=f[q.back()]) q.pop_back();            q.push_back(j);        &#125;        ans+=f[q.front()];    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 487","url":"/project-euler/487/","content":"\r\nProject Euler 487\r\n题目\r\nSums of power sums\r\nLet \\(f_k(n)\\) be the sum of the\r\n\\(k^{\\text{th}}\\) powers of the first\r\n\\(n\\) positive integers.\r\nFor example, \\(f_2(10) = 1^2 + 2^2 + 3^2 +\r\n4^2 + 5^2 + 6^2 + 7^2 + 8^2 + 9^2 + 10^2 = 385.\\)\r\nLet \\(S_k(n)\\) be the sum of \\(f_k(i)\\) for \\(1\r\n\\le i \\le n\\). For example, \\(S_4(100)\r\n= 35375333830.\\)\r\nWhat is \\(\\sum (S_{10000}(10^{12}) \\bmod\r\np)\\) over all primes \\(p\\)\r\nbetween \\(2\\cdot 10^9\\) and \\(2\\cdot10^9 + 2000\\)?\r\n解决方案\r\n注意到：\r\n\\[\\begin{aligned}\r\nS_k(n)&amp;=\\sum_{i=1}^n\\sum_{j=1}^i j^k=\\sum_{i=1}^n (n-i+1)\\cdot\r\ni^k=(n+1)\\cdot\\sum_{i=1}^n i^k-\\sum_{i=1}^n i^{k+1}\\\\\r\n&amp;=(n+1) f_k(n)-f_{k+1}(n)\r\n\\end{aligned}\\]\r\n那么现在问题就转变成了求\\(f_k(n)\\)。\r\nFaulhaber公式直接导出了\\(f_k(n)\\)：\r\n\\[f_k(n)=\\sum_{i=1}^n\r\ni^k=\\dfrac{n^{k+1}}{k+1}+\\dfrac{1}{2}n^k+\\sum_{i=2}^{k}\r\n\\dfrac{B_i}{i!}\\cdot\\dfrac{k!}{(k-i+1)!}\\cdot n^{k-i+1}\\]\r\n其中\\(B_i\\)是第\\(i\\)个伯努利数。在这个页面中伯努利数一共有两个版本，不过无论采用哪个版本都不会影响到上式的结果。以\\(B_n^{+}\\)为例，那么这里给出了\\(B_n^{+}\\)的递推式：\r\n\\[B_n^{+}=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1 &amp; &amp; \\text{if}\\quad n=0 \\\\\r\n  &amp;1-\\sum_{k=0}^{n-1} B_k^{+}\\cdot \\dfrac{n!}{k!(n-k+1)!}&amp; &amp;\r\n\\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n可以发现，当\\(n&gt;1\\)并且\\(n\\)为奇数时，\\(B_n=0\\)。实现时可以通过这个规律进行加速。\r\n那么如果直接按照上面的公式计算\\(f_k(n)\\)的值，一次计算需要花费\\(O(k^2)\\)的时间复杂度。在题目中的区间中一共有\\(100\\)个质数，直接代入公式进行计算效率将会比较低。\r\n可以证明，当\\(p-1\\nmid k\\)时，\\(\\sum_{i=1}^p i^k \\equiv 0\\pmod p.\\)\r\n原因：令\\(g\\)为乘法群\\(\\mathbb{Z}_p^{\\star}\\)上的原根，那么原式就可以写成：\r\n\\[\\sum_{i=1}^p (g^{i})^k \\equiv\r\n\\sum_{i=1}^p (g^k)^i\\equiv g^k\\cdot\\dfrac{(g^k)^{p-1}-1}{g^k-1}\\equiv\r\n0\\pmod p\\]\r\n由于\\(p-1\\nmid k\\)，因此\\(g^k\\neq\r\n1\\)。后面的式子通过费马小定理即可知道其值为\\(0\\)。\r\n因此，有\r\n\\[f_k(n)\\equiv f_k(n\\%p)\\equiv\r\n\\sum_{i=1}^{p-1-n\\%p} (-i)^k\\equiv (-1)^k\\cdot f_k(p-1-n\\%p)\\pmod\r\np\\]\r\n在这道题中，\\(p-1-n\\%p\\)是一个很小的数。当\\(p\\)接近$ 29+2000\\(时，\\)p-1-n%p$也不到$107\\(。因此可以通过暴力计算\\)f_k(p-1-n%p)p$的值。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;# include &quot;tools.h&quot;using namespace std;typedef long long ll;const int K=10000;const ll N=1e12;const int L=2000000000,R=2000002000;ll B[K+6];ll fac[K+6],inv[K+6],finv[K+6];ll cal(ll k,ll p)&#123;    ll n=N%p;    ll pwn=n,ans=0;    for(int i=k;i&gt;=2;i--)&#123;        ans=(ans+B[i]*finv[i]%p*fac[k]%p*finv[k-i+1]%p*pwn%p)%p;        pwn=pwn*n%p;    &#125;    return (ans+pwn*inv[2]%p+pwn*n%p*inv[k+1])%p;&#125;ll solve(ll p)&#123;    fac[0]=fac[1]=inv[1]=finv[0]=finv[1]=1;    for(int i=2;i&lt;=K+3;i++)&#123;        fac[i]=fac[i-1]*i%p;        inv[i]=(p-p/i)*inv[p%i]%p;        finv[i]=finv[i-1]*inv[i]%p;    &#125;    B[0]=1;    B[1]=inv[2];    for(int m=2;m&lt;=K+3;m+=2)&#123;        if(m&amp;1) continue;        B[m]=(p+p+1-inv[m+1]-inv[2])%p;        for(int k=2;k&lt;m;k+=2)            B[m]=(B[m]-fac[m]*finv[m-k+1]%p*finv[k]%p*B[k]%p+p)%p;    &#125;    ll n=N%p;    ll ans=((n+1)*cal(K,p)-cal(K+1,p)+p)%p;    return ans;&#125;int main()&#123;    ll ans=0;    for(int i=L;i&lt;=R;i++)        if(is_prime(i)) ans+=solve(i);    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n# include &lt;bits/stdc++.h&gt;# include &quot;tools.h&quot;using namespace std;typedef long long ll;const int K=10000;const ll N=1e12;const int L=2000000000,R=2000002000;ll qpow(ll n,ll m,ll mod)&#123;    ll a=1;    for(;m;m&gt;&gt;=1)&#123;        if(m&amp;1) a=a*n%mod;        n=n*n%mod;    &#125;    return a;&#125;ll solve(ll p)&#123;    ll n=N%p;    ll b=p-1-n;    ll t1=0,t2=0;    for(int i=1;i&lt;=b;i++)&#123;        ll x=qpow(i,K,p);        t1=(t1+x)%p;        t2=(t2+x*i)%p;    &#125;    ll ans=K&amp;1?t1*(n+1)+t2:-t1*(n+1)-t2;    return (ans%p+p)%p;&#125;int main()&#123;    ll ans=0;    for(int i=L;i&lt;=R;i++)        if(is_prime(i)) ans+=solve(i);    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 491","url":"/project-euler/491/","content":"\r\nProject Euler 491\r\n题目\r\nDouble pandigital\r\nnumber divisible by 11\r\nWe call a positive integer double pandigital if it uses all\r\nthe digits \\(0\\) to \\(9\\) exactly twice (with no leading zero).\r\nFor example, \\(40561817703823564929\\)\r\nis one such number.\r\nHow many double pandigital numbers are divisible by \\(11\\)?\r\n解决方案\r\n这题由于涉及到数位的使用个数，因此考虑使用动态规划进行。\r\n由于单个数位只使用\\(2\\)个，那么当前使用情况有\\(0,1,2\\)这三种情况，因此我们使用一个\\(10\\)位三进制数\\(b=b_9b_8\\dots\r\nb_0\\)来表示当前数位的使用情况。\r\n令\\(M=11\\)。令状态\\(f(b,j)(0&lt; b&lt;\r\n3^{10},0&lt;j&lt;M)\\)表示构造的数中，已经使用的数位的情况为\\(i\\)， 模\\(M\\)为\\(j\\)的数的个数。\r\n那么不难写出如下状态转移方程：\r\n\\[\r\nf(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad \\sum_{k=0}^9i_k=1\\land i=3^j \\\\\r\n  &amp;0 &amp; &amp; \\text{else if}\\quad \\sum_{k=0}^9i_k=1 \\\\\r\n  &amp;\\sum_{\\substack{0&lt;k&lt;10,\\\\i_k&gt;0,\\\\(10x+k)\\%M=j}}\r\nf(i-3^k,x) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n方程的最后一行表示，从状态\\(f(i-3^k,x)\\)中的所有数右边都添加一个数位\\(k\\)，那么添加后数位使用情况就变成\\(i\\)，数的模\\(M\\)值就变成\\((10x+k)\\%M\\)。\r\n最终答案为\\(f(3^{10}-1,0)\\)。\r\n代码中的实现则为另一种方式，它是以“我为人人”的方式实现的，即将当前状态转移到所有的后继可能的状态。在本题中，这种写法会有效减少代码量。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int D=10;const int M=11;const ll N=pow(3,D);ll f[N][M];int pw[D+1];int main() &#123;    pw[0]=1;    for(int i=1;i&lt;=D;i++)        pw[i]=pw[i-1]*3;    for(int i=1;i&lt;D;i++)        f[pw[i]][i%M]++;    for(int i=0;i&lt;pw[D];i++)        for(int j=0;j&lt;M;j++)            for(int k=0;k&lt;D;k++)                if(i/pw[k]%3&lt;2)                    f[i+pw[k]][(j*10+k)%M]+=f[i][j];    ll ans=f[N-1][0];    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 5","url":"/project-euler/5/","content":"\r\nProject Euler 5\r\n题目\r\nSmallest multiple\r\n\\(2520\\) is the smallest number that\r\ncan be divided by each of the numbers from \\(1\\) to \\(10\\) without any remainder.\r\nWhat is the smallest positive number that is evenly\r\ndivisible by all of the numbers from \\(1\\) to \\(20\\)?\r\n解决方案\r\n根据定义，所求的值为\\(1\\sim20\\)中间的所有数的最小公倍数\\(\\text{lcm}\\)。\r\n求多个数的\\(\\text{lcm}\\)和求多个数的最大公因数\\(\\gcd\\)做法一样，都是两两按顺序求。\r\n使用了gmpy2库中的lcm方法，以后将封装到tools工具包中。\r\n代码\r\nfrom gmpy2 import lcmN = 20ans = 1for i in range(1, 21):    ans = lcm(ans, i)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 492","url":"/project-euler/492/","content":"\r\nProject Euler 492\r\n题目\r\nExploding sequence\r\nDefine the sequence \\(a_1, a_2, a_3,\r\n\\dots\\) as:\r\n\r\n\\(a_1 = 1\\)\r\n\\(a_{n+1} = 6a_n^2 + 10a_n + 3\\)\r\nfor \\(n \\ge 1\\).\r\n\r\nExamples:\r\n\\(\\begin{aligned}\r\n&amp;a_3 = 2359\\\\\r\n&amp;a_6 = 269221280981320216750489044576319\\\\\r\n&amp;a_6 \\bmod 1 000 000 007 = 203064689\\\\\r\n&amp;a_{100} \\bmod 1 000 000 007 = 456482974\r\n\\end{aligned}\\)\r\nDefine \\(B(x,y,n)\\) as \\(\\sum (a_n \\bmod p)\\) for every prime \\(p\\) such that \\(x\r\n\\le p \\le x+y\\).\r\nExamples:\r\n\\(\\begin{aligned}\r\n&amp;B(10^9, 10^3, 10^3) = 23674718882\\\\\r\n&amp;B(10^9, 10^3, 10^{15}) = 20731563854\r\n\\end{aligned}\\)\r\nFind \\(B(10^9, 10^7, 10^{15})\\).\r\n解决方案\r\n构造一个新序列\\(b_n=6a_n+5\\)，并且回代到\\(a_n\\)的递推式中，那么得到\\(b_n\\)的递推式：\r\n\\[\\left\\{\\begin{aligned}\r\n&amp;b_1=11\\\\\r\n&amp;b_{n+1}=b_n^2-2\r\n\\end{aligned}\\right.\\]\r\n可以发现\\(b_n\\)的式子比起\\(a_n\\)消去了一次项，并且\\(b_n^2\\)的项系数恰好为\\(1\\)。\r\n根据\\(b_n\\)的递推式，再联想到如下关于\\(x\\)的等式：\r\n\\[x^2+\\dfrac{1}{x^2}=\\left(x+\\dfrac{1}{x}\\right)^2-2\\]\r\n如果将\\(b_1\\)写成形如\\(b_1=k+\\dfrac{1}{k}\\)的形式，那么\\(b_n\\)的通项公式可以很轻易地写出来：\r\n\\[b_n=k^{2^{n-1}}+\\dfrac{1}{k^{2^{n-1}}}\\]\r\n求解\\(k+\\dfrac{1}{k}=11\\)，得到\\(k=\\dfrac{11\\pm 3\\sqrt{13}}{2}\\)。\r\n接下来参考两种情况：\r\n\r\n如果\\(13\\)是\\(p\\)的二次剩余，那么计算出\\(13\\)的二次剩余后，直接代入计算\\(k\\)的值即可。\r\n如果\\(13\\)不是\\(p\\)的二次剩余，那么接下来这个地方参考了Thread的一些内容：考虑在域\\(\\mathbb{Z}_p[\\sqrt{13}]\\)进行运算，这个域的阶为\\(p^2-1\\)。这个域的乘法运算性质为：\\((x_1,y_1)\\times(x_2,y_2)=(x_1x_2+13y_1y_2,x_1y_2+x_2y_1)\\)，相当于是\\(x_1+y_1\\sqrt{13}\\)和\\(x_2+y_2\\sqrt{13}\\)这两个数相乘。那么根据这个运算性质，\\(\\left(\\dfrac{11}{2},\\dfrac{3}{2}\\right)^{2^{n-1}}\\)很容易就能够计算出来。\\(\\left(\\dfrac{11}{2},\\dfrac{3}{2}\\right)\\)在\\(\\mathbb{Z}_p[\\sqrt{13}]\\)上的逆元是\\(\\left(\\dfrac{11}{2},-\\dfrac{3}{2}\\right)\\)，具有共轭的性质。最终\\(\\left(\\dfrac{11}{2},\\dfrac{3}{2}\\right)^{2^{n-1}}+\\left(\\dfrac{11}{2},-\\dfrac{3}{2}\\right)^{2^{n-1}}\\)的\\(y\\)值一定为\\(0\\)，求出的\\(x\\)值即为最终的\\(b_n\\)。\r\n\r\n计算出\\(b_n\\)后，回代得到\\(a_n=\\dfrac{b_n-5}{6}\\)，直接计算即可。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;# include &quot;tools.h&quot;using namespace std;typedef long long ll;const int L=1000000000;const int M=10000000;const ll N=1000000000000000;struct Zpsqrt&#123;    static const ll D=13;    ll x,y,p;    Zpsqrt operator * (Zpsqrt a)&#123;        return Zpsqrt&#123;(x*a.x+y*a.y%p*D)%p,(x*a.y+y*a.x)%p,p&#125;;    &#125;    Zpsqrt qpow(ll m)&#123;        Zpsqrt a&#123;1,0,p&#125;,n=*this;        for(;m;m&gt;&gt;=1)&#123;            if(m&amp;1) a=a*n;            n=n*n;        &#125;        return a;    &#125;&#125;;ll cal(ll n,ll p)&#123;    ll s;    ll inv2=(p+1)&gt;&gt;1;    if(qpow(13,(p-1)&gt;&gt;1,p)==1)&#123;        ll e=qpow(2,n-1,p-1);        ll u=3ll*sqrt_mod_prime(13,p)+11;        ll k=u*inv2%p;        ll x=qpow(k,e,p);        ll y=mod_inverse(x,p);        s=x+y;    &#125;    else&#123;        Zpsqrt a&#123;inv2*11%p,inv2*3%p,p&#125;;        ll e=qpow_mpz(2,n-1,p*p-1);        a=a.qpow(e);        s=a.x&lt;&lt;1;    &#125;    s%=p;    return (s-5+p)*mod_inverse(6,p)%p;&#125;int main()&#123;    ll ans=0;    for(int p=next_prime(L-1);p&lt;=L+M;p=next_prime(p))&#123;        ans+=cal(N,p);    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 50","url":"/project-euler/50/","content":"\r\nProject Euler 50\r\n题目\r\nConsecutive prime sum\r\nThe prime \\(41\\), can be written as\r\nthe sum of six consecutive primes:\r\n\\[41 = 2 + 3 + 5 + 7 + 11 +\r\n13\\]\r\nThis is the longest sum of consecutive primes that adds to a prime\r\nbelow one-hundred.\r\nThe longest sum of consecutive primes below one-thousand that adds to\r\na prime, contains \\(21\\) terms, and is\r\nequal to \\(953\\).\r\nWhich prime, below one-million, can be written as the sum of the most\r\nconsecutive primes?\r\n解决方案\r\n可以先将小于\\(N=10^6\\)的质数筛选出来，然后做一遍前缀和。\r\n接下来，找到最大的前缀长度\\(l\\)，使得前\\(l\\)个质数和小于\\(N\\)。\r\n从前缀长度\\(l\\)往下遍历，在遍历这个前缀长度\\(i\\)时，看看有没有一个长度为\\(i\\)的子数组其和是一个质数。如果找到了，这就是一个全局最优解并退出。\r\n如果找不到，那么就需要判断子数组和是否超过\\(N\\)，超过了就及时退出循环，继续寻找\\(i-1\\)时的解。\r\n代码\r\nfrom tools import get_primeN = 1000000pr = get_prime(N)st = set(pr)s = [0]for x in pr:    s.append(s[-1] + x)for i in range(len(pr)):    if s[i] &gt; N:        p = i        breakfor l in range(p, 0, -1):    ok = False    for i in range(l, len(pr) + 1):        if s[i] - s[i - l] in st:            ans = s[i] - s[i - l]            ok = True            break        if s[i] - s[i - l] &gt; N:            break    if ok:        breakprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 493","url":"/project-euler/493/","content":"\r\nProject Euler 493\r\n题目\r\nUnder The Rainbow\r\n\\(70\\) colored balls are placed in\r\nan urn, \\(10\\) for each of the seven\r\nrainbow colors.\r\nWhat is the expected number of distinct colors in \\(20\\) randomly picked balls?\r\nGive your answer with nine digits after the decimal point\r\n(a.bcdefghij).\r\n解决方案\r\n假设每一组有\\(m=10\\)个球，一共有\\(g=7\\)组，一次取出\\(p=20\\)个球。\r\n令\\(X_i\\)表示第\\(i\\)种颜色的球出现的示性随机变量。如果\\(X_i=1\\)，那么就说明第\\(i\\)种颜色出现了，如果\\(X_i\\)为\\(0\\)，那么第\\(i\\)种颜色没有出现。\r\n那么，最终出现颜色个数的期望为\r\n\\[e=E[\\sum_{i=1}^gX_i]=\\sum_{i=1}^gE[X_i]\\]\r\n不失一般性，对于第\\(1\\)种颜色的球，它被抽出来的概率为\\(1-\\dfrac{\\binom{m(g-1)}{p}}{\\binom{mg}{p}}\\)。\r\n因此，\\(E[X_1]=1-\\dfrac{\\binom{m(g-1)}{p}}{\\binom{mg}{p}}\\)\r\n由于所有颜色的球的数量都是一样的，因此\\(E[X_1]=E[X_2]=\\dots=E[X_g]\\)。\r\n因此最终答案为\r\n\\[e=\\sum_{i=1}^gE[X_i]=gE[X_1]=g\\left(1-\\dfrac{\\binom{m(g-1)}{p}}{\\binom{mg}{p}}\\right)\\]\r\n代码\r\nfrom tools import CM = 10G = 7P = 20N = M * Gans = G * (1 - C(N - M, P) / C(N, P))print(&quot;&#123;:.9f&#125;&quot;.format(ans))\r\n","categories":["Project Euler"],"tags":["概率"]},{"title":"Project Euler 501","url":"/project-euler/501/","content":"\r\nProject Euler 501\r\n题目\r\nEight Divisors\r\nThe eight divisors of \\(24\\) are\r\n\\(1, 2, 3, 4, 6, 8, 12\\) and \\(24\\).\r\nThe ten numbers not exceeding \\(100\\) having exactly eight divisors are\r\n\\(24, 30, 40, 42, 54, 56, 66, 70, 78\\)\r\nand \\(88\\).\r\nLet \\(f(n)\\) be the count of numbers\r\nnot exceeding \\(n\\) with exactly eight\r\ndivisors.\r\nYou are given \\(f(100)=10,\r\nf(1000)=180\\) and \\(f(10^6)=224427\\).\r\nFind \\(f(10^{12})\\).\r\nLehmer公式\r\nLehmer公式给出了质数计数函数\\(\\pi\\)的一个计算方式：\r\n\\[\\pi(x)=\\varphi(x,a)+\\dfrac{(b+a-2)(b-a+1)}{2}-\\sum_{i=a+1}^b\\pi\\left(\\dfrac{x}{p_i}\\right)-\\sum_{i=a+1}^c\\sum_{j=i}^{b_i}\\left(\\pi\\left(\\dfrac{x}{p_ip_j}\\right)-(j-1)\\right)\\]\r\n其中，\\(p_i\\)表示第\\(i\\)个质数，\\(a=\\pi(\\sqrt[4]{x}),b=\\pi(\\sqrt{x}),c=\\pi(\\sqrt[3]{x}),b_i=\\pi\\left(\\sqrt{\\dfrac{x}{p_i}}\\right)\\)\r\n其中\\(\\varphi(x,a)\\)是\\(n\\)以内的数中，质因数只由第\\(a+1\\)个及以后的质数的个数，用容斥原理可以写成：\r\n\\[\\varphi(x,a)=x-\\sum_{i=1}^a\\left\\lfloor\\dfrac{x}{p_i}\\right\\rfloor+\\sum_{1\\le\r\ni\\le j\\le\r\na}\\left\\lfloor\\dfrac{x}{p_ip_j}\\right\\rfloor-\\dots\\]\r\n为了方便计算，页面说明\\(\\varphi(x,a)\\)还可以写成以下递推式形式：\r\n\\[\r\n\\varphi(x,a)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;\\left\\lceil\\dfrac{x}{2}\\right\\rceil  &amp; &amp; \\text{if}\\quad\r\nx=0\\lor a=1 \\\\\r\n  &amp;\\varphi(x,a-1)-\\varphi\\left(\\left\\lfloor\\dfrac{x}{p_a}\\right\\rfloor,a-1\\right)\r\n&amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n在计算函数\\(\\pi\\)和\\(\\varphi\\)时，需要使用记忆化方法记录函数值。\r\n解决方案\r\n令\\(N=10^{12}\\)，有\\(8\\)个因子的数分别有以下三种（以下使用的\\(p_i\\)均为质数）：\r\n\r\n\\(p_1\\)\r\n\\(p_1^3p_2\\)，其中满足\\(p_1\\neq p_2\\)\r\n\\(p_1p_2p_3\\)，其中满足\\(p_1&lt;p_2&lt;p_3\\)\r\n\r\n那么不难写出三种数对应的个数为：\r\n\r\n\\(f_1(n)=\\pi(\\sqrt[7]{N})\\)\r\n\\(f_2(n)=\\sum_{p_1\\le\r\n\\sqrt[3]{N}}\\left(\\pi\\left(\\dfrac{N}{p_1^3}\\right)\\right)-\\pi(\\sqrt[4]{N})\\)\r\n\\(f_3(n)=\\sum_{p_1\\le\r\n\\sqrt[3]{N}}\\sum_{p_1&lt;p_2&lt;\\sqrt{\\frac{N}{p_1}}}\\left(\\pi\\left(\\dfrac{N}{p_1\\cdot\r\np_2}\\right)-\\pi(p_2)\\right)\\)\r\n\r\n最终得到\\(f(n)=f_1(n)+f_2(n)+f_3(n).\\)\r\n那么现在问题就转化成了使用Lehmer公式计算函数\\(\\pi.\\)\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll N = 1000000000000;const ll M = pow(N, 2.0 / 3) + 2;bool vis[M + 1];int sum[M + 1],pr[M + 1],m;unordered_map&lt;ll,ll&gt; mp,mq;ll phi(ll x, ll a) &#123;    if (a == 1 || x == 0)return (x + 1) / 2;    ll &amp;v = mp[(x &lt;&lt; 10) + a];    if (v)return v;    return v = phi(x, a - 1) - phi(x / pr[a], a - 1);&#125;ll pi(ll n) &#123;    if (n &lt;= M)return sum[n];    ll &amp;v = mq[n];    if (v) return v;    ll a = pi(pow(n, 1.0 / 4));    ll b = pi(sqrt(n));    ll c = pi(pow(n, 1.0 / 3));    ll s = phi(n, a) + (b + a - 2) * (b - a + 1) / 2;    for (ll i = a + 1; i &lt;= b; i++) &#123;        ll w = n / pr[i];        s -= pi(w);        ll bi = pi(sqrt(w));        if (i &lt;= c) &#123;            for (ll j = i; j &lt;= bi; j++)                s += j - 1 - pi(w / pr[j]);        &#125;    &#125;    return v = s;&#125;int main() &#123;    for (ll i = 2; i &lt;= M; i++) &#123;        if (!vis[i]) &#123;            for (ll j = i * i; j &lt;= M; j += i) vis[j] = 1;            pr[++m] = i;        &#125;        sum[i] = m;    &#125;    ll ans=0;    ans+= pi(pow(N, 1.0 / 7));    ll tmp;    for (int i = 1; i &lt;= m &amp;&amp; (tmp = N / (1ll * pr[i] * pr[i] * pr[i])) &gt;= 2; i++)        ans += pi(tmp);    ans-= pi(pow(N, 1.0 / 4));    for (ll i = 1; 1ll * pr[i] * pr[i] * pr[i] &lt;= N; i++)        for (ll j = i + 1; j &lt;= m &amp;&amp; pr[j + 1] &lt;= (tmp = N / (1ll * pr[i] * pr[j])); j++)            ans += pi(tmp) - pi(pr[j]);    printf(&quot;%lld\\n&quot;, ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 509","url":"/project-euler/509/","content":"\r\nProject Euler 509\r\n题目\r\nDivisor Nim\r\nAnton and Bertrand love to play three pile Nim.\r\nHowever, after a lot of games of Nim they got bored and changed the\r\nrules somewhat.\r\nThey may only take a number of stones from a pile that is a\r\nproper\r\ndivisor of the number of stones present in the pile.\r\nE.g. if a pile at a certain moment contains \\(24\\) stones they may take only \\(1,2,3,4,6,8\\) or \\(12\\) stones from that pile.\r\nSo if a pile contains one stone they can’t take the last stone from\r\nit as \\(1\\) isn’t a proper divisor of\r\n\\(1\\).\r\nThe first player that can’t make a valid move loses the game. Of\r\ncourse both Anton and Bertrand play optimally.\r\nThe triple \\((a,b,c)\\) indicates the\r\nnumber of stones in the three piles.\r\nLet \\(S(n)\\) be the number of\r\nwinning positions for the next player for \\(1\r\n\\le a, b, c \\le n\\).\r\n\\(S(10) = 692\\) and \\(S(100) = 735494\\).\r\nFind \\(S(123456787654321)\\text{ modulo\r\n}1234567890\\).\r\n解决方案\r\n在每一次操作中，一方可以拿起三堆石头\\((a,b,c)\\)的其中一堆的石头的因数个。并且这\\(3\\)堆石头是相互独立的。因此，三堆石头的\\(sg\\)函数\\(sg(a,b,c)=sg(a)\\oplus sg(b)\\oplus\r\nsg(c)\\).那么此时只需要单独考虑一堆石头的情况\\(sg(n)\\)。\r\n只拿一堆石头时，不难写出\\(sg(n)\\)为：\r\n\\[\r\nsg(n)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0 &amp; &amp; \\text{if}\\quad  n=1 \\\\\r\n  &amp;\\text{mex}(\\{sg(n-d)|(d \\mid n)\\land d\\neq n \\}) &amp; &amp;\r\n\\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n其中运算\\(\\text{mex}(s)\\)表示集合\\(s\\)中未出现的最小的非负整数。\r\n那么通过以下程序暴力打印出一部分数的\\(sg\\)函数值，在OEIS中查询后结果为A007814。\r\n#include &lt;bits/stdc++.h&gt;# include &quot;tools.h&quot;using namespace std;typedef long long ll;const int N=100,M=100;int sg[N+4];bool mex[M+4];int main()&#123;    sg[1]=0;    for(int i=2;i&lt;=N;i++)&#123;        memset(mex,0,sizeof(mex));        vector&lt;ll&gt;d=divisors(i);        d.pop_back();        for(ll x:d)            mex[sg[i-x]]=1;        int j=0;        for(;mex[j];++j);        sg[i]=j;        printf(&quot;%d %d\\n&quot;,i,sg[i]);    &#125;&#125;\r\n这个数列说明\\(sg(n)\\)是最大的正整数\\(k\\)使得\\(2^k\\mid\r\nn\\)。\r\n那么不难计算得到，\\(1\\sim\r\nN\\)中有\\(\\left\\lfloor\\dfrac{N}{2^i}\\right\\rfloor-\\left\\lfloor\\dfrac{N}{2^{i+1}}\\right\\rfloor\\)个数，其\\(sg\\)函数值为\\(i\\)。\r\n因此，最终直接三重循环枚举\\(sg\\)值，直接求个数之积的和。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll N=123456787654321;const int M=60;ll cnt[M+4],mod=1234567890;int main()&#123;    for(int i=0;i&lt;=M;i++)        cnt[i]=((N&gt;&gt;i)-(N&gt;&gt;(i+1)))%mod;    ll ans=0;    for(int i=0;i&lt;=M;i++)        for(int j=0;j&lt;=M;j++)            for(int k=0;k&lt;=M;k++)                if(i^j^k) ans=(ans+cnt[i]*cnt[j]%mod*cnt[k])%mod;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["SG定理"]},{"title":"Project Euler 506","url":"/project-euler/506/","content":"\r\nProject Euler 506\r\n题目\r\nClock sequence\r\nConsider the infinite repeating sequence of digits:\r\n\\[1234321234321234321\\dots\\]\r\nAmazingly, you can break this sequence of digits into a sequence of\r\nintegers such that the sum of the digits in the \\(n\\)’th value is \\(n\\).\r\nThe sequence goes as follows:\r\n\\[1, 2, 3, 4, 32, 123, 43, 2123, 432,\r\n1234, 32123, \\dots\\]\r\nLet \\(v_n\\) be the \\(n\\)’th value in this sequence. For example,\r\n\\(v_2=2, v_5=32\\) and \\(v_{11}=32123\\).\r\nLet \\(S(n)\\) be \\(v_1+v_2+\\dots+v_n\\). For example, \\(S(11)=36120\\), and \\(S(1000) \\bmod 123454321 = 18232686\\).\r\nFind \\(S(10^{14})\\bmod\r\n123454321\\).\r\n解决方案\r\n打印数列的前\\(40\\)项，发现如下规律：\r\n1234321234321234321234321234321234321234321234321       2343212       3432123       4321234       32123432      123432123     43212343      2123432123    432123432     1234321234    32123432123   43212343212   34321234321   23432123432   123432123432  1234321       234321      2343212       343212      3432123       432123      4321234       321234      32123432      123432      123432123     432123      43212343      212343      2123432123    432123      432123432     123432      1234321234    321234      321234\r\n单独拿出第\\(2,17,32\\)项，可以看出：\r\n22       3432122       343212      343212\r\n第\\(i\\)个数是第\\(i-15\\)个数后面拼接一个固定的\\(6\\)位数，因此分开考虑，使用等比数列的前缀和进行计算即可。注意计算循环添加的那一部分数，相当于是等比数列前缀和的前缀和。\r\n代码\r\nfrom tools import mod_inverseN = 10 ** 14mod = 123454321inv = mod_inverse(10 ** 6 - 1, mod)m = 10 ** 6a = [1, 2, 3, 4, 32, 123, 43, 2123, 432, 1234, 32123, 43212, 34321, 23432, 123432]b = [234321, 343212, 432123, 321234, 123432, 432123, 212343, 432123, 123432, 321234, 432123, 343212, 234321, 123432,     123432]T = len(a)ans = 0for i in range(T):    cnt = N // T + (i &lt; N % T)    c1 = (pow(m, cnt, mod) - 1) * inv % mod    c2 = (c1 - cnt) * inv % mod    ans = (ans + a[i] * c1 + b[i] * c2) % modprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 51","url":"/project-euler/51/","content":"\r\nProject Euler 51\r\n题目\r\nPrime digit replacements\r\nBy replacing the \\(1^{\\text{st}}\\)\r\ndigit of the \\(2\\)-digit number \\(*3\\), it turns out that six of the nine\r\npossible values: \\(13, 23, 43, 53,\r\n73\\), and \\(83\\), are all\r\nprime.\r\nBy replacing the \\(3^{\\text{rd}}\\)\r\nand \\(4^{\\text{th}}\\) digits of \\(56**3\\) with the same digit, this \\(5\\)-digit number is the first example\r\nhaving seven primes among the ten generated numbers, yielding the\r\nfamily: \\(56003, 56113, 56333, 56443, 56663,\r\n56773,\\) and \\(56993\\).\r\nConsequently \\(56003\\), being the\r\nfirst member of this family, is the smallest prime with this\r\nproperty.\r\nFind the smallest prime which, by replacing part of the number (not\r\nnecessarily adjacent digits) with the same digit, is part of an eight\r\nprime value family.\r\n解决方案\r\n此处使用一个术语：模板，用来表示题意中带星号和数字的混合字符串。如题目中的\\(*3,56**3\\)等。\r\n这些模板通过将对所有星号(*)填入相同的数位，产生\\(9\\sim10\\)个数（当模板的最高位是星号时，将不能填入\\(0\\)）。\r\n一个关于模板的结论：\r\n如果一个模板能够产生\\(8\\)个质数，那么这个模板的星号个数必须为\\(3\\)的倍数。\r\n设模板中星号的个数为\\(k\\)，其余的数字之和为\\(s\\)，那么产生的数字的数位和为\\(s,s+k,s+2k,\\dots,s+9k\\)。\r\n\r\n当\\(k\\)满足\\(k\\equiv 0 \\pmod 3\\)时，可以发现： \\(s\\equiv s+k\\equiv s+2k\\equiv\\dots\\equiv s+9k\\pmod\r\n3\\)。\r\n\r\n这种情况下，当\\(s\\not\\equiv0\\pmod\r\n3\\)时，就有可能产生\\(8\\)个质数。\r\n\r\n否则，总有\r\n\r\n\\(\\begin{aligned}\r\n&amp; s\\equiv s+3k\\equiv s+6k\\equiv s+9k\\pmod 3 \\\\\r\n&amp; s+1k\\equiv s+4k\\equiv s+7k \\pmod 3 \\\\\r\n&amp; s+2k\\equiv s+5k\\equiv s+8k \\pmod 3\r\n\\end{aligned}\\)\r\n这三条式子中，总存在一条是和\\(0\\)是同余的。在这种情况下，就有\\(3\\)个合数，不能构造出\\(8\\)个质数，所以，原结论成立。\r\n另外，题目要求枚举的质数中，是某个模板下产生的\\(8\\)个质数中最小的。因此，所枚举的质数必定是以某个模板填入\\(0,1,2\\)这三个数位之一。\r\n因此，利用上面的结论，直接开始枚举质数。\r\n本代码使用sympy库中的nextprime函数，它将返回当前大于数的下一个质数。\r\n代码\r\nfrom sympy import nextprimefrom tools import is_primefrom itertools import count, combinationsM = 8a = [1, 2]# 将数的一部分下标替换成模板def change(s: str, pos_list):    ls = list(s)    for pos in pos_list:        ls[pos] = &#x27;*&#x27;    return &quot;&quot;.join(ls)def ok(n: int):    s = str(n)    # 存放字符串中,0,1,2的下标    pos = [[], [], []]    for i in range(len(s)):        if int(s[i]) &lt;= 2:            pos[int(s[i])].append(i)    # 产生星号数为3的倍数的模板    for stars in count(3, 3):        candidates = list(combinations(pos[0], stars)) + list(combinations(pos[1], stars)) + list(            list(combinations(pos[2], stars)))        if len(candidates) == 0:            break        for pos_list in candidates:            # 用来产生模板t。            t = change(s, pos_list)            cnt = 0            for i in range(10):                if i == 0 and t[0] == &#x27;*&#x27;:                    continue                if is_prime(int(t.replace(&#x27;*&#x27;, str(i)))):                    cnt += 1            if cnt &gt;= M:                return True    return Falsepr = 0while True:    pr = nextprime(pr)    if ok(pr):        ans = pr        breakprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 504","url":"/project-euler/504/","content":"\r\nProject Euler 504\r\n题目\r\nSquare on the Inside\r\nLet \\(ABCD\\) be a quadrilateral\r\nwhose vertices are lattice points lying on the coordinate axes as\r\nfollows:\r\n\\(A(a, 0), B(0, b), C(-c, 0), D(0,\r\n-d)\\), where \\(1 \\le a, b, c, d \\le\r\nm\\) and \\(a, b, c, d, m\\) are\r\nintegers.\r\nIt can be shown that for \\(m = 4\\)\r\nthere are exactly \\(256\\) valid ways to\r\nconstruct \\(ABCD\\). Of these \\(256\\) quadrilaterals, \\(42\\) of them strictly contain a\r\nsquare number of lattice points.\r\nHow many quadrilaterals \\(ABCD\\)\r\nstrictly contain a square number of lattice points for \\(m = 100\\)?\r\n皮克定理\r\n皮克定理：给定一个所有坐标点都在格点上的简单多边形。如果这个多边形的面积为\\(A\\)，边界上的格点有\\(b\\)个，内部的格点有\\(i\\)个。那么这三个变量满足关系：\r\n\\[A=i+\\dfrac{b}{2}-1\\]\r\n解决方案\r\n依靠皮克定理来解决问题。\r\n不难计算出，这个多边形的面积为\\(\\dfrac{(a+c)(b+d)}{2}\\)。\r\n如果一条线段的两端的坐标分别在格点\\((x_1,y_1),(x_2,y_2)\\)，那么在这些线段内部的格点有\\(\\gcd(|x_1-x_2|,|y_1-y_2|)-1\\)个。\r\n那么这个多边形内部的节点数为：\r\n\\(\\dfrac{(a+c)(b+d)-\\gcd(a,b)-\\gcd(b,c)-\\gcd(c,d)-\\gcd(d,a)-2}{2}\\)\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N=100;int g[N+1][N+1];bool isq[N*N*4+1];int main()&#123;    for(int i=1;i*i&lt;=4*N*N;i++)        isq[i*i]=1;    for(int i=1;i&lt;=N;i++)        for(int j=1;j&lt;=N;j++)            g[i][j]=__gcd(i,j);    int ans=0;    for(int a=1;a&lt;=N;a++)        for(int b=1;b&lt;=N;b++)            for(int c=a;c&lt;=N;c++)                for(int d=b;d&lt;=N;d++)&#123;                    int v=((a+c)*(b+d)-(g[a][b]+g[b][c]+g[c][d]+g[d][a])+2)&gt;&gt;1;                    if(isq[v]) ans+=(1+(a!=c))*(1+(b!=d));                &#125;    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 500","url":"/project-euler/500/","content":"\r\nProject Euler 500\r\n题目\r\nProblem \\(500\\)!!!\r\nThe number of divisors of \\(120\\) is\r\n\\(16\\).\r\nIn fact \\(120\\) is the smallest\r\nnumber having \\(16\\) divisors.\r\nFind the smallest number with \\(2^{500500}\\) divisors.\r\nGive your answer modulo \\(500500507\\).\r\n解决方案\r\n注意到，所求的数的除数是一个二次幂（\\(2^{N},N=500500\\)）,那么所求的这个数一定是形如这种形式：\r\n\\[2^{2^{e_1}-1}\\times3^{2^{e_2}-1}\\times\r\n5^{2^{e_3}-1}\\times \\dots\\]\r\n如果要令一个数\\(n\\)的因子数翻倍，观察\\(n\\)的因数个数公式\\(\\prod (e_i+1)\\)，有以下两个操作办法：\r\n\r\n为\\(n\\)乘上一个\\(n\\)中还未存在的质因数，这相当于添加了一个新的项\\((1+1)\\)。\r\n\\(n\\)的分解质因数中，假设其中一项为\\(p_i^{e_i}\\)，那么就为\\(n\\)乘上\\(p_i^{e_i+1}\\)，这相当于把项\\((e_i+1)\\)变成了\\((2e_i+2)\\)。另外，如果当前对应质因子\\(p_i\\)的一项是\\(x\\)，那么下一次待添加的就是\\(x^2\\)。\r\n\r\n因此，使用优先队列维护这些等待被\\(n\\)相乘的数，找出最小的一个为\\(n\\)乘上即可，过程迭代\\(N\\)次。\r\n代码\r\nfrom tools import get_primefrom queue import PriorityQueueM = 500500mod = 500500507pr = get_prime(M * int(len(bin(M)) - 2) + 14)N = M * int(len(bin(M)) - 2)q = PriorityQueue()for i in range(M):    q.put(pr[i])ans = 1for i in range(M):    x = q.get()    ans = ans * x % mod    q.put(x * x)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 511","url":"/project-euler/511/","content":"\r\nProject Euler 511\r\n题目\r\nSequences with nice\r\ndivisibility properties\r\nLet \\(\\text{Seq}(n,k)\\) be the\r\nnumber of positive-integer sequences \\(\\{a_i\\}_{1\\le i\\le n}\\) of length \\(n\\) such that:\r\n\r\n\\(n\\) is divisible by \\(a_i\\) for \\(1\\le\r\ni\\le n\\), and\r\n\\(n + a_1 + a_2 + \\dots + a_n\\) is\r\ndivisible by \\(k\\).\r\n\r\nExamples: \\(\\text{Seq}(3,4) = 4\\),\r\nand the \\(4\\) sequences are:\r\n\\(\\begin{aligned}\r\n\\{1, 1, 3\\} \\\\\r\n\\{1, 3, 1\\} \\\\\r\n\\{3, 1, 1\\} \\\\\r\n\\{3, 3, 3\\}\r\n\\end{aligned}\\)\r\n\\(\\text{Seq}(4,11) = 8\\), and the\r\n\\(8\\) sequences are:\r\n\\(\\begin{aligned}\r\n\\{1, 1, 1, 4\\}\\\\\r\n\\{1, 1, 4, 1\\}\\\\\r\n\\{1, 4, 1, 1\\}\\\\\r\n\\{4, 1, 1, 1\\}\\\\\r\n\\{2, 2, 2, 1\\}\\\\\r\n\\{2, 2, 1, 2\\}\\\\\r\n\\{2, 1, 2, 2\\}\\\\\r\n\\{1, 2, 2, 2\\}\\\\\r\n\\end{aligned}\\)\r\nThe last nine digits of \\(\\text{Seq}(1111,24)\\) are \\(840643584\\).\r\nFind the last nine digits of \\(\\text{Seq}(1234567898765,4321)\\).\r\n解决方案\r\n注意到第\\(2\\)个条件中的式子可以看成是\\((a_1+1)+(a_2+1)+\\dots+(a_n+1)\\)。因此在第\\(1\\)个条件时，处理完\\(n\\)的所有因子后，全部加\\(1\\)，那么第\\(2\\)个条件就可以转化成条件\\(a_1&#39;+a_2&#39;+\\dots+a_n&#39;\\)是\\(k\\)的倍数。\r\n假设\\(S\\)是经过第\\(1\\)个条件的限定后，可以填入序列\\(a&#39;\\)的数的集合。\r\n那么，不难想到使用动态规划来解决本题。令\\(N=1234567898765,M=4321\\)。假设状态\\(f(i,j)(0\\le i\\le\r\nN,0&lt;j&lt;M)\\)是长度为\\(n\\)的序列中，有多少种填法使得序列\\(a&#39;\\)的元素之和模\\(M\\)为\\(j\\)。那么不难写出状态转移方程为：\r\n\\[\r\nf(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad  i=0\\land j=0 \\\\\r\n  &amp;0 &amp; &amp; \\text{else if}\\quad  i=0 \\\\\r\n  &amp;\\sum_{x\\in S}f(i-1,(j-x)\\%M) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n但是，对于\\(N\\)这种数据范围而言，直接进行转移效率非常低。如果直接使用矩阵快速幂，那么矩阵的边长长达\\(M\\)，仍然不可接受。\r\n如果我们已经求出了长度为\\(a\\)的序列的各种填法\\(f(a,\\cdot)\\)和长度为\\(b\\)的各种填法\\(f(b,\\cdot)\\)，不难知道我们可以通过\\(O(M^2)\\)的时间复杂度组合出\\(f(a+b,\\cdot)\\)。\r\n枚举所有的\\(f(a,i)\\)和\\(f(b,j)\\)，将这两部分值直接合并起来：\r\n\\(f(a,i)\\cdot f(b,j)\\rightarrow\r\nf(a+b,(i+j)\\%M)\\)\r\n因此，这给了我们一个方案：依次求出\\(f(2^0,\\cdot),f(2^1,\\cdot),f(2^2,\\cdot),\\dots\\)。然后针对\\(N\\)，选择这些求出的\\(f(2^i,\\cdot)\\)进行合并即可。这种做法的时间复杂度为\\(O(M^2\\cdot \\log N)\\)。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll N=1234567898765,M=4321;ll mod=1e9;ll cnt[M];ll a[M],b[M];void getd(ll N)&#123;    for(ll i=1;i*i&lt;=N;i++)    if(N%i==0)&#123;        ++cnt[(i+1)%M];        if(i*i!=N) ++cnt[(N/i+1)%M];    &#125;&#125;void cal(ll a[M],ll b[M],ll ans[M])&#123;    ll c[M]=&#123;0&#125;;    for(int i=0;i&lt;M;i++)        for(int j=0;j&lt;M;j++)            c[(i+j)%M]=(c[(i+j)%M]+a[i]*b[j])%mod;    memcpy(ans,c,sizeof(c));&#125;int main()&#123;    getd(N);    a[0]=1;    memcpy(b,cnt,sizeof(b));    for(ll M=N;M;M&gt;&gt;=1)&#123;        if(M&amp;1) cal(a,b,a);        cal(b,b,b);    &#125;    printf(&quot;%lld\\n&quot;,a[0]);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划","矩阵快速幂&#43;"]},{"title":"Project Euler 512","url":"/project-euler/512/","content":"\r\nProject Euler 512\r\n题目\r\nSums of totients of powers\r\nLet \\(\\varphi(n)\\) be Euler’s\r\ntotient function.\r\nLet \\(f(n)=(\\sum_{i=1}^{n}\\varphi(n^i))\r\n\\text{ mod } (n+1)\\).\r\nLet \\(g(n)=\\sum_{i=1}^{n}\r\nf(i)\\).\r\n\\(g(100)=2007\\).\r\nFind \\(g(5 \\times 10^8)\\).\r\n解决方案\r\n根据欧拉函数的性质，不难写出\\(\\varphi(n^i)=\\varphi (n)\\cdot n^{i-1}\\)\r\n\\(f(n)=\\sum_{i=1}^n\\varphi(n^i)=\\varphi(n)\\sum_{i=0}^{n-1}\r\nn^i\\)\r\n因此\\(f(n) = \\varphi(n)\\cdot\r\n\\sum_{i=0}^{n-1}(-1)^i\\% (n+1)\\)。\r\n如果\\(n\\)为偶数，那么\\(f(n) = 0\\)\r\n如果\\(n\\)为奇数，那么\\(f(n)=\\varphi(n) \\% (n+1)\\)\r\n因此，\r\n\\[g(n)=\\sum_{i=1}^{\\left\\lfloor\\frac{n+1}{2}\\right\\rfloor}\\varphi(2i-1)\\]\r\n可以直接使用筛法计算奇数的欧拉函数值。\r\n为了使用数论分块加速，考虑\r\n\\[\\Phi(n)=\\sum_{i=1}^n\\varphi(n)\\]\r\n令\\(\\Phi_p(n)=\\sum_{i=1,p\\mid i}^n\r\n\\varphi(n)\\)，\\(p\\)是一个质数。那么\\(g(n)=\\Phi(n)-\\Phi_2(n)\\)。\\(\\Phi_p(n)\\)满足：\r\n\\[\\Phi_p(n)=\\varphi(p)\\cdot\\left(\\Phi\\left(\\dfrac{n}{p}\\right)+\\Phi\\left(\\dfrac{n}{p^2}\\right)+\\Phi\\left(\\dfrac{n}{p^3}\\right)+\\dots\\right)\\]\r\n说明：如果一个数\\(p^k\\cdot x,p\\nmid\r\nx,k&gt;1\\)，那么\\(\\varphi(p^k\\cdot\r\nx)=(p-1)p^{k-1}x\\)。因此，在上面的式子中，\\(\\varphi(p^k\\cdot x)\\)的一部分被算进\\(\\varphi(p)\\cdot\\Phi(\\dfrac{n}{p^k})\\)，另一部分被算进\\(\\varphi(p)\\cdot\\Phi(\\dfrac{n}{p^{k-1}})\\)。\r\n那么现在的问题就是使用数论分块的方法高效计算\\(\\Phi(n)\\)的值。\r\n\\[\\begin{aligned}\r\n\\dfrac{n(n+1)}{2}&amp;=|\\{(a,b)|1\\le a\\le b \\le n\\}|\\\\\r\n&amp;=\\sum_{d=1}^n|\\{(a,b)|1\\le a\\le b \\le n,\\gcd(a,b)=d\\}|\\\\\r\n&amp;=\\sum_{d=1}^n\\left|\\left\\{(a,b)| 1\\le a\\le b \\le\r\n\\left\\lfloor\\dfrac{n}{d}\\right\\rfloor,\\gcd(a,b)=1\\right\\}\\right|\\\\\r\n&amp;=\\sum_{d=1}^n\\Phi\\left(\\dfrac{n}{d}\\right)\r\n\\end{aligned}\\]\r\n因此，可以得到关于\\(\\Phi\\)的递归式：\r\n\\[\\Phi(n)=\\dfrac{n(n+1)}{2}-\\sum_{d=2}^n\\Phi\\left(\\dfrac{n}{d}\\right)\\]\r\n其中，右边这一部分可以使用数论分块来解决。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=5e8;const int M=(N+1)&gt;&gt;1;int phi[M+2];int main()&#123;    for(int i=1;i&lt;=M;i++)        phi[i]=2*i-1;    for(int i=2;i&lt;=M;i++)&#123;        int v=2*i-1;        if(phi[i]==v)&#123;            for(int j=i;j&lt;=M;j+=v)                phi[j]=phi[j]/v*(v-1);        &#125;    &#125;    ll ans=0;    for(int i=1;i&lt;=M;i++)        ans+=phi[i];    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=5e8;const int M= pow(N,2.0/3);ll s[M+2];int v[M+2],pr[M/10+1000],m=0;unordered_map&lt;ll,ll&gt;mp;ll sum_phi(ll n)&#123;    if(n&lt;=M) return s[n];    else if(mp.count(n)) return mp[n];    ll ans=n*(n+1)/2;    for(ll l=2,r;l&lt;=n;l=r+1)&#123;        r=n/(n/l);        ans-=(r-l+1)* sum_phi(n/l);    &#125;    return mp[n]=ans;&#125;int main()&#123;    s[1]=1;    for(int i=2;i&lt;=M;i++) &#123;        if(v[i]==0)&#123;            v[i]=i;pr[++m]=i;s[i]=i-1;        &#125;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;M/i) break;            v[i*pr[j]]=pr[j];            s[i*pr[j]]=s[i]*(pr[j]==v[i]?pr[j]:pr[j]-1);        &#125;    &#125;    for(int i=2;i&lt;=M;i++)        s[i]+=s[i-1];    ll ans = sum_phi(N);    for(ll i=2;i&lt;=N;i*=2)        ans -= sum_phi(N/i);    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["数论分块"]},{"title":"Project Euler 52","url":"/project-euler/52/","content":"\r\nProject Euler 52\r\n题目\r\nPermuted multiples\r\nIt can be seen that the number, \\(125874\\), and its double, \\(251748\\), contain exactly the same digits,\r\nbut in a different order.\r\nFind the smallest positive integer, \\(x\\), such that \\(2x, 3x, 4x, 5x,\\) and \\(6x\\), contain the same digits.\r\n解决方案\r\n直接枚举。可以发现，如果要满足上面的条件，那么\\(x\\)和\\(6x\\)的位数必须相同。\r\n因此，对于一个\\(n\\)位数而言，只需要枚举这些\\(n\\)位数的前\\(\\dfrac{1}{6}\\)的部分。\r\n代码\r\nfrom itertools import countfor i in count(1, 1):    l = 10 ** (i - 1)    r = 10 ** i // 6    ok = False    for x in range(l, r + 1):        st = set()        for i in range(1, 7):            st.add(&quot;&quot;.join((lambda x: (x.sort(), x)[1])(list(str(x * i)))))        if len(st) == 1:            ok = True            ans = x            break    if ok:        breakprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 523","url":"/project-euler/523/","content":"\r\nProject Euler 523\r\n题目\r\nFirst Sort I\r\nConsider the following algorithm for sorting a list:\r\n\r\nStarting from the beginning of the list, check each pair of adjacent\r\nelements in turn.\r\nIf the elements are out of order:\r\n\r\n\r\nMove the smallest element of the pair at the beginning of the\r\nlist.\r\nRestart the process from step 1.\r\n\r\n\r\nIf all pairs are in order, stop.\r\n\r\nFor example, the list \\(\\{4\\ 1\\ 3\\\r\n2\\}\\) is sorted as follows:\r\n\r\n4 1 3 2 (\\(4\\) and \\(1\\) are out of order so move \\(1\\) to the front of the list)\r\n1 4 3 2 (\\(4\\) and \\(3\\) are out of order so move \\(3\\) to the front of the list)\r\n3 1 4 2 (\\(3\\) and \\(1\\) are out of order so move \\(1\\) to the front of the list)\r\n1 3 4 2 (\\(4\\) and \\(2\\) are out of order so move \\(2\\) to the front of the list)\r\n2 1 3 4 (\\(2\\) and \\(1\\) are out of order so move \\(1\\) to the front of the list)\r\n1 2 3 4 (The list is now sorted)\r\n\r\nLet \\(F(L)\\) be the number of times\r\nstep 2a is executed to sort list \\(L\\).\r\nFor example, \\(F(\\{ 4\\ 1\\ 3\\ 2 \\}) =\r\n5\\).\r\nLet \\(E(n)\\) be the expected\r\nvalue of \\(F(P)\\) over all\r\npermutations \\(P\\) of the integers\r\n\\(\\{1, 2, \\dots, n\\}\\).\r\nYou are given \\(E(4) = 3.25\\) and\r\n\\(E(10) = 115.725\\).\r\nFind \\(E(30)\\). Give your answer\r\nrounded to two digits after the decimal point.\r\n解决方案\r\n对于一个\\(n\\)阶排列，只有当前\\(n-1\\)个元素有序时，第\\(n\\)个元素才会被题目所描述的算法遍历到。并且，使前\\(n-1\\)个元素有序，花费的期望可以视为\\(n-1\\)阶排列的子问题，为\\(E(n-1).\\)\r\n前\\(n-1\\)个数有序后，假设第\\(n\\)个数为\\(k\\)。那么当\\(k=n\\)时，算法结束。否则，\\(k\\)将会被移到第一个位置，那么现在排列看起来形如这个样子：\r\n\\(k,1,2,\\dots,k-2,k-1,\\mathbf{k+1},k+2,\\dots,n-1,n\\)\r\n那么发现\\(k+1,k+2,\\dots,n\\)这一部分已经是有序的，此时只需要将这个排列\\(k,1,2,\\dots,k-2,k-1\\)这一部分进行排序即可。令\\(f(k)\\)为使这个\\(k\\)阶排列有序需要迭代上面的算法次数。\r\n将这个排列排序成\\(1,2,\\dots,k-2,k,k-1\\)需要\\(f(k-1)\\)的迭代次数，因为前\\(k-1\\)个元素单独视为一个子问题。\r\n再运行一次上面的算法，那么排列就变成\\(k-1,1,2,\\dots,k-2,k\\)，完成这个排列也需要\\(f(k-1)\\)的次数。\r\n这说明，\\(f(k)=2f(k)+1,f(1)=0\\)，因此\\(f(k)=2^{k-1}-1\\)。\r\n那么说明，原来的\\(n\\)解排列如果以\\(k\\)为结尾，并且前\\(n-1\\)个元素已经排好序，那么仍然\\(f(k)+1=2^{k-1}\\)次排序。\r\n\\(n\\)阶排列的末尾的元素是均匀出现的，因此有\\(E(n)=E(n-1)+\\dfrac{1}{n}\\sum_{k=1}^{n-1}\r\n2^{k-1}\\)\r\n那么化简后，得到：\r\n\\[E(n)=E(n-1)+\\dfrac{2^{n-1}-1}{n}=\\sum_{i=1}^n\\dfrac{2^{i-1}-1}{i}\\]\r\n相关数列：A279683\r\n代码\r\nN = 30ans = sum((2 ** (i-1) - 1) / i for i in range(1, N + 1))print(&quot;&#123;:.2f&#125;&quot;.format(ans))\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 518","url":"/project-euler/518/","content":"\r\nProject Euler 518\r\n题目\r\nPrime triples and\r\ngeometric sequences\r\nLet \\(S(n) = a+b+c\\) over all\r\ntriples \\((a,b,c)\\) such that:\r\n\r\n\\(a, b\\), and \\(c\\) are prime numbers.\r\n\\(a &lt; b &lt; c &lt; n\\).\r\n\\(a+1, b+1\\), and \\(c+1\\) form a geometric\r\nsequence.\r\n\r\nFor example, \\(S(100) = 1035\\) with\r\nthe following triples:\r\n\\(\\begin{aligned}\r\n&amp; (2, 5, 11), (2, 11, 47), (5, 11, 23), (5, 17, 53), (7, 11, 17),\r\n(7, 23, 71), (11, 23, 47), \\\\\r\n&amp; (17, 23, 31), (17, 41, 97), (31, 47, 71), (71, 83, 97)\r\n\\end{aligned}\\)\r\nFind \\(S(10^8)\\).\r\n解决方案\r\n如果\\(a+1,b+1,c+1\\)是一个等比数列，那么不难观察出\\((b+1)^2=(a+1)(c+1)\\)。\r\n那么，不难发现，如果\\(a+1\\)有一些质因子\\(p\\)的指数是奇数，那么为了确保\\(b+1\\)是一个平方数，\\(c+1\\)的质因子\\(p\\)的指数也必须是奇数。\r\n假设函数\\(f\\)定义如下：\\(f(n)=m\\)意味着\\(m\\)是最小的因子使得\\(\\dfrac{n}{m}\\)是平方数。\r\n如果两个质数\\(p,q\\)满足\\(f(p+1)=f(q+1)\\)，那么这对\\((p,q)\\)才有可能产生一个答案。因此维护一些链表，这些链表用于存储\\(f\\)值相等情况下的\\(n\\)。\r\n由于函数\\(f\\)值是无平方因子数，因此这些链表的数量比较多，长度也比较短，那么可以在每条链表上进行二重循环，枚举\\(a+1,c+1\\)的值。最终计算出\\(b=\\sqrt{(a+1)(c+1)}-1\\)后，判断\\(b\\)是否为质数即可。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;#include &quot;tools.h&quot;typedef long long ll;using namespace std;const int N=1e8;const int M=N+1;int v[M+4],pr[M/10+1000],f[M+4],head[M+4],pre[M+4];int m=0;int main()&#123;    for(int i=2;i&lt;=N;i++)&#123;        if(v[i]==0)&#123;            f[i]=i;v[i]=i;pr[++m]=i;        &#125;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;N/i) break;            v[i*pr[j]]=pr[j];            f[i*pr[j]]=(f[i]%pr[j]==0?f[i]/pr[j]:f[i]*pr[j]);        &#125;    &#125;    for(int i=1;i&lt;=m&amp;&amp;pr[i]&lt;=N;i++)&#123;        int w=pr[i]+1;        pre[w]=head[f[w]];        head[f[w]]=w;    &#125;    ll ans=0;    for(int i=1;i&lt;=N;i++)        for(ll p=head[i];p;p=pre[p])            for(ll q=pre[p];q;q=pre[q])&#123;                ll s= int_sqrt(1ll*p*q);                if(v[s-1]==s-1) ans+=p+q+s-3;            &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 515","url":"/project-euler/515/","content":"\r\nProject Euler 515\r\n题目\r\nDissonant Numbers\r\nLet \\(d(p,n,0)\\) be the\r\nmultiplicative inverse of \\(n\\) modulo\r\nprime \\(p\\), defined as \\(n\\times d(p,n,0)=1\\bmod p\\).\r\nLet \\(d(p,n,k) = \\sum_{i=1}^n\r\nd(p,i,k−1)\\) for \\(k\\ge1\\).\r\nLet \\(D(a,b,k) = \\sum(d(p,p-1,k) \\bmod\r\np)\\) for all primes \\(a\\le\r\np&lt;a+b\\).\r\nYou are given:\r\n\r\n\\(D(101,1,10) = 45\\)\r\n\\(D(10^3,10^2,10^2) =\r\n8334\\)\r\n\\(D(10^6,10^3,10^3) =\r\n38162302\\)\r\n\r\nFind \\(D(10^9,10^5,10^5)\\).\r\n解决方案\r\n根据上面的定义，可以写出如下式子：\r\n\\(\\begin{aligned}\r\n&amp;d(p,n,0)=n^{-1}\\\\\r\n&amp;d(p,n,1)=\\sum_{i_1=1}^n i_1^{-1}\\\\\r\n&amp;d(p,n,2)=\\sum_{i_2=1}^n\\sum_{i_1=1}^{i_2} i_1^{-1}\\\\\r\n&amp;d(p,n,3)=\\sum_{i_3=1}^n\\sum_{i_2=1}^{i_3}\\sum_{i_1=1}^{i_2}\r\ni_1^{-1}\\\\\r\n&amp;\\dots\r\n\\end{aligned}\\)\r\n最终有\r\n\\(\\begin{aligned}\r\nd(p,n,k)&amp;=\\sum_{i_k=1}^n\\sum_{i_{k-1}=1}^{i_k}\\dots\\sum_{i_2=1}^{i_3}\\sum_{i_1=1}^{i_2}\r\ni_1^{-1}\\\\\r\n&amp;=\\sum_{i_1=1}^n\r\ni_1^{-1}\\cdot\\left(\\sum_{i_2=i_1}^n\\sum_{i_3=i_2}^n\\dots\\sum_{i_{k-1}=i_k}^n\\sum_{i_k=i_{k-1}}^n1\\right)\r\n\\end{aligned}\\)\r\n我们分析求和项\\(\\displaystyle{\\sum_{i_2=i_1}^n\\sum_{i_3=i_2}^n\\dots\\sum_{i_{k-1}=i_k}^n\\sum_{i_k=i_{k-1}}^n1}\\)的值。可以发现，这个求和式的结果等价于如下组合问题的结果：\r\n求有多少个长度为\\(k-1\\)的序列\\((i_2,i_3,\\dots,i_{k-1},i_k)\\)，满足如下条件：\r\n\r\n\\(i_1\\le i_2,i_k\\le n\\)\r\n\\(\\forall j\\in[3,k],i_{j-1}\\le\r\ni_j\\)均成立。\r\n\r\n将它们的条件转换成如下条件，得到的结果是等价的（想象一下，令\\(i&#39;_j=i_j+j-1\\)）。\r\n\r\n\\(i_1\\le i_2,i_k\\le n+k-2\\)\r\n\\(\\forall j\\in[3,k],i_{j-1}&lt;\r\ni_j\\)均成立。\r\n\r\n这个问题是一个普通的组合问题，它的答案为\\(\\dbinom{n+k-i_1-1}{k-1}\\).\r\n因此可以得到：\r\n\\[d(p,n,k)=\\sum_{i=1}^n\r\ni^{-1}\\cdot\\dbinom{n+k-i-1}{k-1}\\]\r\n代入\\(n=p-1\\)，得到\r\n\\(\\begin{aligned}\r\nd(p,p-1,k)&amp;\\equiv\\sum_{i=1}^{p-1} i^{-1}\\cdot\\dbinom{p+k-i-2}{k-1}\\\\\r\n&amp;\\equiv\\sum_{i=1}^{p-1}\r\ni^{-1}\\cdot\\dfrac{(p-i)(p-i+1)\\dots(p+k-i-3)(p+k-i-2)}{(k-1)!}\\\\\r\n&amp;\\equiv-\\dfrac{1}{k-1}\\sum_{i=1}^{p-1}\\dfrac{(p-i+1)\\dots(p+k-i-3)(p+k-i-2)}{(k-2)!}\\\\\r\n&amp;\\equiv-\\dfrac{1}{k-1}\\sum_{i=1}^{p-1}\\dbinom{p+k-i-2}{k-2}\\\\\r\n&amp;\\equiv-\\dfrac{1}{k-1}\\sum_{i=1}^{p-1}\\dbinom{i+k-2}{k-2}\\\\\r\n&amp;\\equiv-\\dfrac{1}{k-1}\\left(p\\cdot\r\n\\dfrac{\\binom{p+k-2}{k-2}}{k-1}-1\\right)\\\\\r\n&amp;\\equiv\\dfrac{1}{k-1} &amp;\\pmod p\r\n\\end{aligned}\\)\r\n最终，直接暴力计算\\(D(a,b,p)\\)的值即可。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;# include &quot;tools.h&quot;using namespace std;typedef long long ll;const int A=1000000000,B=100000,K=100000;int main()&#123;    ll ans=0;    for(int p=next_prime(A-1);p&lt;A+B;p=next_prime(p))&#123;        ans+=mod_inverse(K-1,p);    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 53","url":"/project-euler/53/","content":"\r\nProject Euler 53\r\n题目\r\nCombinatoric selections\r\nThere are exactly ten ways of selecting three from five, \\(12345\\):\r\n\\[ 123, 124, 125, 134, 135, 145, 234, 235,\r\n245, 345 \\]\r\nIn combinatorics, we use the notation, \\(\\displaystyle \\binom 5 3 = 10\\). In\r\ngeneral, \\(\\displaystyle \\binom n r =\r\n\\dfrac{n!}{r!(n-r)!}\\), where \\(r \\le\r\nn\\), \\(n! = n \\times (n-1) \\times \\dots\r\n\\times 3 \\times 2 \\times 1\\), and \\(0!\r\n= 1\\).\r\nIt is not until \\(n = 23\\), that a\r\nvalue exceeds one-million: \\(\\displaystyle\r\n\\binom {23} {10} = 1144066\\).\r\nHow many, not necessarily distinct, values of \\(\\displaystyle \\binom n r\\) for \\(1 \\le n \\le 100\\), are greater than\r\none-million?\r\n解决方案\r\n根据组合数的递推式，计算出杨辉三角前\\(101\\)行的值。\r\n由于Python支持计算大数，因此直接进行枚举判断。\r\n产生杨辉三角的方法将会被封装在自定义的tools工具包中，以get_pascals_triangle(n,mod=None)获得杨辉三角的前\\(n+1\\)行，其中所有值对mod取模。\r\n代码\r\nN = 100M = 10 ** 6ans = 0C = [[0 for y in range(x + 1)] for x in range(N + 1)]for i in range(N + 1):    C[i][0] = C[i][i] = 1    for j in range(1, i):        C[i][j] = C[i - 1][j - 1] + C[i - 1][j]    if i &gt; 0:        ans += sum(1 for j in range(i + 1) if C[i][j] &gt;= M)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 516","url":"/project-euler/516/","content":"\r\nProject Euler 516\r\n题目\r\n\\(5\\)-smooth\r\ntotients\r\n\\(5\\)-smooth numbers are numbers\r\nwhose largest prime factor doesn’t exceed \\(5\\).\r\n\\(5\\)-smooth numbers are also called\r\nHamming numbers.\r\nLet \\(S(L)\\) be the sum of the\r\nnumbers \\(n\\) not exceeding \\(L\\) such that Euler’s totient function\r\n\\(\\varphi(n)\\) is a Hamming number.\r\n\\(S(100)=3728\\).\r\nFind \\(S(10^{12})\\). Give your\r\nanswer modulo \\(2^{32}\\).\r\n解决方案\r\n可以发现，这些数都是形如以下形式：\r\n\\[2^a3^b5^c\\cdot\r\np_1p_2p_3\\dots\\]\r\n其中\\(p_i\\)是一些质数，它们满足\\(p_i-1=2^x3^y5^z\\)。这些质数引入的欧拉函数的质因子只有\\(2,3,5\\)。\r\n那么，枚举的过程分为两部分：一部分是枚举出\\(2^a3^b5^c\\)的值，直接暴力循环枚举。另一部分是枚举右边大于\\(5\\)的质数的乘积，通过递归进行枚举。\r\n最终，这两部分数两两之间的乘积就是答案。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const ll N = 1000000000000;const ll M = sqrt(N)+4;ll mod = 1ll&lt;&lt;32;bool vis[M+4];vector&lt;ll&gt; pr,a,p;bool is_prime(ll w) &#123;    for (ll x: pr) &#123;        if (x * x &gt; w) break;        if (w % x == 0) return false;    &#125;    return true;&#125;ll ans=0;void dfs(int f,ll w) &#123;    for (ll x: a) &#123;        ll z = w * x;        if (z &gt; N) break;        ans = (ans + z) % mod;    &#125;    for (; f &lt; p.size() &amp;&amp; p[f] &lt;= N / w; f++) &#123;        dfs(f + 1, w * p[f]);    &#125;&#125;int main() &#123;    for (ll i = 2; i &lt;= M; i++) &#123;        if (vis[i]) continue;        for (ll j = i * i; j &lt;= M; j += i)            vis[j] = 1;        pr.push_back(i);    &#125;    for (ll x = 1; x &lt;= N; x *= 2)        for (ll y = x; y &lt;= N; y *= 3)            for (ll z = y; z &lt;= N; z *= 5) &#123;                a.push_back(z);                if (z + 1 &gt; 5 &amp;&amp; is_prime(z + 1)) p.push_back(z + 1);            &#125;    sort(a.begin(), a.end());    sort(p.begin(), p.end());    dfs(0, 1);    printf(&quot;%lld\\n&quot;, ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 531","url":"/project-euler/531/","content":"\r\nProject Euler 531\r\n题目\r\nChinese leftovers\r\nLet \\(g(a,n,b,m)\\) be the smallest\r\nnon-negative solution \\(x\\) to the\r\nsystem:\r\n\\(\\begin{aligned}\r\n&amp; x = a \\bmod n\\\\\r\n&amp; x = b \\bmod m\r\n\\end{aligned}\\)\r\nif such a solution exists, otherwise \\(0\\).\r\nE.g. \\(g(2,4,4,6)=10\\), but \\(g(3,4,4,6)=0\\).\r\nLet \\(\\varphi(n)\\) be Euler’s\r\ntotient function.\r\nLet \\(f(n,m)=g(\\varphi(n),n,\\varphi(m),m)\\).\r\nFind \\(\\sum f(n,m)\\) for \\(1000000 \\le n &lt; m &lt; 1005000\\).\r\n解决方案\r\n题意比较裸，直接求出欧拉函数值然后通过中国剩余定理求方程的解即可。\r\n当然也可以令\\(x=t_an+a=t_bm+b\\)，那么可以写出方程\\(t_an-t_bm=b-a\\)，只需要用一次扩展欧几里得算法就可以求出\\(t_a,t_b\\)，从而重新计算出\\(x\\)。这种做法比起使用中国剩余定理，少使用了一次扩展欧几里得算法，故也可以考虑。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int L=1000000,R=1005000;int phi[R+4];ll ex_gcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123;    if(b==0)&#123;        x=1;y=0;return a;    &#125;    ll g=ex_gcd(b,a%b,x,y);    ll z=x-(a/b)*y;    x=y;y=z;return g;&#125;//解不定方程ax+my=c。ll congruence(ll a,ll c,ll m)&#123;    ll x,y,g;    g=ex_gcd(a,m,x,y);    if(c%g!=0) return -1;    x*=c/g;    ll t=m/g;    return (x%t+t)%t;&#125;ll CRT(ll b,ll m,ll c,ll n)&#123;    ll y=congruence(m,c-b,n);    if(y==-1) return -1;    ll x=m*y+b;    ll t=m*n;    return (x%t+t)%t;&#125;int main()&#123;    for(int i=1;i&lt;R;i++)        phi[i]=i;    for(int i=2;i&lt;R;i++)&#123;        if(phi[i]!=i) continue;        phi[i]=i-1;        for(int j=i+i;j&lt;R;j+=i)            phi[j]=phi[j]/i*(i-1);    &#125;    ll ans=0;    for(int i=L;i&lt;R;i++)&#123;        for(int j=i+1;j&lt;R;j++)&#123;            ll x=CRT(phi[i],i,phi[j],j);            if(x!=-1) ans+=x;        &#125;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["中国剩余定理"]},{"title":"Project Euler 539","url":"/project-euler/539/","content":"\r\nProject Euler 539\r\n题目\r\nOdd elimination\r\nStart from an ordered list of all integers from \\(1\\) to \\(n\\). Going from left to right, remove the\r\nfirst number and every other number afterward until the end of the list.\r\nRepeat the procedure from right to left, removing the right most number\r\nand every other number from the numbers left. Continue removing every\r\nother numbers, alternating left to right and right to left, until a\r\nsingle number remains.\r\nStarting with \\(n = 9\\), we\r\nhave:\r\n1 2 3 4 5 6 7 8 9\r\n2 4 6 8\r\n2 6\r\n6\r\nLet \\(P(n)\\) be the last number left\r\nstarting with a list of length \\(n\\).\r\nLet \\(\\displaystyle S(n) = \\sum_{k=1}^n\r\nP(k)\\)\r\nYou are given \\(P(1)=1, P(9) = 6,\r\nP(1000)=510, S(1000)=268271\\).\r\nFind \\(S(10^{18}) \\bmod\r\n987654321\\).\r\n解决方案\r\n通过暴力枚举前一小部分值，在OEIS中查询，发现结果为A347325。在FORMULA一栏，找到如下信息：\r\na(n) = 2 * (floor(n/2) + 1 - a(floor(n/2))) for n &gt; 1. See Zhang&#x27;s solution. - Zirui Wang, Jan 02 2022\r\n这直接给出了\\(P(n)\\)的递推公式：\r\n\\[\r\nP(n)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad  n=1 \\\\\r\n  &amp;2\\left(\\left\\lfloor\\dfrac{n}{2}\\right\\rfloor+1-P\\left(\\left\\lfloor\\dfrac{n}{2}\\right\\rfloor\\right)\\right)\r\n&amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n发现在这个公式下，当\\(n=2k,2k+1\\)时，\\(P(n)\\)的计算结果都相同。因此，当\\(n\\)为偶数时，写成\\(S(n)=S(n-1)\\)。当\\(n\\)为奇数，那么令\\(m=\\dfrac{n-1}{2}\\)，那么\r\n\\(\\begin{aligned}\r\nS(n)&amp;=1+\\sum_{i=2}^n\r\nP(i)=1+2\\sum_{i=2}^n\\left(\\left\\lfloor\\dfrac{i}{2}\\right\\rfloor+1-P\\left(\\left\\lfloor\\dfrac{i}{2}\\right\\rfloor\\right)\\right)\\\\\r\n&amp;=1+\\sum_{i=1}^m2(2m+2-2P(m))\\\\\r\n&amp;=1+2(m(m+1)+2m-2\\sum_{i=1}^mP(i))\\\\\r\n&amp;=1+2m(m+1)+4m-4S(m)\\\\\r\n\\end{aligned}\\)\r\n最终通过递归，可以以\\(O(\\log^2n)\\)的时间复杂度计算出\\(S(n)\\)。\r\n代码\r\nN = 10 ** 18mod = 987654321def P(n):    return 1 if n == 1 else 2 * (1 + n // 2 - P(n &gt;&gt; 1))def S(n):    if n &lt;= 1:        return n    elif n % 2 == 0:        return P(n) + S(n - 1)    else:        m = n &gt;&gt; 1        return 2 * (m * (m + 1) + n - 1 - 2 * S(m)) + 1ans = S(N) % modprint(ans)\r\n","categories":["Project Euler"],"tags":["OEIS"]},{"title":"Project Euler 537","url":"/project-euler/537/","content":"\r\nProject Euler 537\r\n题目\r\nCounting tuples\r\nLet \\(\\pi(x)\\) be the prime counting\r\nfunction, i.e. the number of prime numbers less than or equal to \\(x\\).\r\nFor example, \\(\\pi(1)=0, \\pi(2)=1,\r\n\\pi(100)=25\\).\r\nLet \\(T(n,k)\\) be the number of\r\n\\(k\\)-tuples \\((x_1,\\dots,x_k)\\) which satisfy:\r\n\r\nevery \\(x_i\\) is a positive\r\ninteger;\r\n\\(\\displaystyle \\sum_{i=1}^k\r\n\\pi(x_i)=n\\)\r\n\r\nFor example \\(T(3,3)=19\\).\r\nThe \\(19\\) tuples are\r\n\\(\\begin{aligned}\r\n&amp; (1,1,5), (1,5,1), (5,1,1), (1,1,6), (1,6,1), (6,1,1), (1,2,3), \\\\\r\n&amp; (1,3,2), (2,1,3), (2,3,1), (3,1,2), (3,2,1), (1,2,4), (1,4,2), \\\\\r\n&amp; (2,1,4), (2,4,1), (4,1,2), (4,2,1), (2,2,2).\r\n\\end{aligned}\\)\r\nYou are given \\(T(10,10) = 869 985\\)\r\nand \\(T(10^3,10^3) ≡ 578 270 566 \\pmod {1 004\r\n535 809}\\).\r\nFind \\(T(20 000, 20 000) \\bmod 1 004 535\r\n809\\).\r\n解决方案\r\n令\\(N=M=20000,P=1004535809\\)。考虑使用动态规划计算\\(T\\)。\r\n用\\(c[i]\\)表示\\(\\pi\\)序列中有多少个\\(n\\)为\\(\\pi(n)=i\\)。不难写出关于\\(T\\)的状态转移方程：\r\n\\[\r\nT(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1 &amp; &amp; \\text{if}\\quad  i=0\\land j=0 \\\\\r\n  &amp;0 &amp; &amp; \\text{else if}\\quad  i=0 \\\\\r\n  &amp;\\sum_{k=0}^j T(i-1,j-k) \\cdot c[k] &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n最后一行方程表示在状态\\(T(i-1,j-k)\\)中的序列填一个数，它的\\(\\pi\\)函数值中有\\(c[k]\\)个是\\(k\\)，从而达到状态\\(T(i,j)\\)。\r\n不过直接进行转移效率非常低。\r\n如果我们已经求出了长度为\\(a\\)的序列的各种填法\\(T(a,\\cdot)\\)和长度为\\(b\\)的各种填法\\(T(b,\\cdot)\\)，不难知道我们可以通过卷积组合出\\(T(a+b,\\cdot)\\)。\r\n枚举所有的\\(T(a,i)\\)和\\(T(b,j)\\)，将这两部分值直接合并起来：\r\n\\(T(a,i)\\cdot T(b,j)\\rightarrow\r\nT(a+b,i+j)\\)\r\n直接枚举这两部分的值效率非常低，可以使用快速数论变换加速计算这两部分的合并。快速数论变换最基本的用途就是用来求多项式模上的卷积，将\\(O(n^2)\\)的时间复杂度下降到\\(O(n\\log n)\\)。\r\n因此，这给了我们一个方案：依次求出\\(Tg(2^0,\\cdot),T(2^1,\\cdot),T(2^2,\\cdot),\\dots\\)。然后针对\\(Q\\)，选择这些求出的\\(T(2^i,\\cdot)\\)进行合并即可。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;#include &quot;tools.h&quot;using namespace std;typedef long long ll;const int N=20000,M=20000;int g=3,mod=1004535809;const int O=log(N)*N*2+4;int v[O+4],pr[O/10+1000],m=0;int main()&#123;    ntt.init(g,mod);    for(int i=2;i&lt;=O;i++)&#123;        if(v[i]==0)&#123;            v[i]=i;pr[++m]=i;        &#125;        for(int j=1;j&lt;=O;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;O/i) break;            v[i*pr[j]]=pr[j];        &#125;    &#125;    vector&lt;int&gt;a&#123;1&#125;,b(N+1);    b[0]=1;    for(int i=1;i&lt;=N;i++)        b[i]=pr[i+1]-pr[i];    for(int m=M;m;m&gt;&gt;=1)&#123;        if(m&amp;1) a=ntt.cal(a,b);        b=ntt.cal(b,b);        a.resize(N+1);        b.resize(N+1);    &#125;    int ans=a[N];    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划","快速数论变换"]},{"title":"Project Euler 54","url":"/project-euler/54/","content":"\r\nProject Euler 54\r\n题目\r\nPoker hands\r\nIn the card game poker, a hand consists of five cards and are ranked,\r\nfrom lowest to highest, in the following way:\r\n\r\nHigh Card: Highest value card.\r\nOne Pair: Two cards of the same value.\r\nTwo Pairs: Two different pairs.\r\nThree of a Kind: Three cards of the same\r\nvalue.\r\nStraight: All cards are consecutive values.\r\nFlush: All cards of the same suit.\r\nFull House: Three of a kind and a pair.\r\nFour of a Kind: Four cards of the same value.\r\nStraight Flush: All cards are consecutive values of\r\nsame suit.\r\nRoyal Flush: Ten, Jack, Queen, King, Ace, in same\r\nsuit.\r\n\r\nThe cards are valued in the order:2, 3, 4, 5, 6, 7, 8, 9, 10, Jack,\r\nQueen, King, Ace.\r\nIf two players have the same ranked hands then the rank made up of\r\nthe highest value wins; for example, a pair of eights beats a pair of\r\nfives (see example 1 below). But if two ranks tie, for example, both\r\nplayers have a pair of queens, then highest cards in each hand are\r\ncompared (see example 4 below); if the highest cards tie then the next\r\nhighest cards are compared, and so on.\r\nConsider the following five hands dealt to two players:\r\n\r\n\r\n\r\nHand\r\nPlayer 1\r\nPlayer 2\r\nWinner\r\n\r\n\r\n\r\n\r\n1\r\n5H 5C 6S 7S KD\r\n2C 3S 8S 8D TD\r\nPlayer 2\r\n\r\n\r\n\r\nPair of Fives\r\nPair of Eights\r\n\r\n\r\n\r\n2\r\n5D 8C 9S JS AC\r\n2C 5C 7D 8S QH\r\nPlayer 1\r\n\r\n\r\n\r\nHighest card Ace\r\nHighest card Queen\r\n\r\n\r\n\r\n3\r\n2D 9C AS AH AC\r\n3D 6D 7D TD QD\r\nPlayer 2\r\n\r\n\r\n\r\nThree Aces\r\nFlush with Diamonds\r\n\r\n\r\n\r\n4\r\n4D 6S 9H QH QC\r\n3D 6D 7H QD QS\r\nPlayer 1\r\n\r\n\r\n\r\nPair of Queens\r\nPair of Queens\r\n\r\n\r\n\r\n\r\nHighest card Nine\r\nHighest card Seven\r\n\r\n\r\n\r\n5\r\n2H 2D 4C 4D 4S\r\n3C 3D 3S 9S 9D\r\nPlayer 1\r\n\r\n\r\n\r\nFull House\r\nFull House\r\n\r\n\r\n\r\n\r\nwith Three Fours\r\nwith Three Threes\r\n\r\n\r\n\r\n\r\nThe file, poker.txt,\r\ncontains one-thousand random hands dealt to two players. Each line of\r\nthe file contains ten cards (separated by a single space): the first\r\nfive are Player 1’s cards and the last five are Player 2’s cards. You\r\ncan assume that all hands are valid (no invalid characters or repeated\r\ncards), each player’s hand is in no specific order, and in each hand\r\nthere is a clear winner.\r\nHow many hands does Player 1 win?\r\n解决方案\r\n本体属于细节题，参考代码和注释。\r\n基本思想是先判断手牌的等级，然后再计算出当前等级下的手牌最大的那张。\r\n代码\r\n# 判断5张牌是否同花。def same_suit(p):    for i in range(4):        if p[i][1] != p[i + 1][1]:            return False    return True# 判断5张牌是否一个顺子。def order(p):    for i in range(4):        if ord(p[i + 1][0]) - ord(p[i][0]) != 1:            return False    return Truedef get_level(p):    # 将5张牌的牌面收集起来。    r = p[0][0] + p[1][0] + p[2][0] + p[3][0] + p[4][0]    if same_suit(p) and order(p):        # 同花大顺        if p[4][0] == &#x27;M&#x27;:            return p, p[4], 10        # 同花顺        else:            return p, p[4], 9    # 四条    elif r[0] == r[1] == r[2] == r[3]:        return p[0:4], p[3], 8    elif r[1] == r[2] == r[3] == r[4]:        return p[1:5], p[4], 8    # 葫芦    elif r[0] == r[1] == r[2] and r[3] == r[4] or r[2] == r[3] == r[4] and r[0] == r[1]:        return p, p[2], 7    # 同花    elif same_suit(p):        return p, p[4], 6    # 顺子    elif order(p):        return p, p[4], 5    # 三条    elif r[0] == r[1] == r[2]:        return p[0:3], p[2], 4    elif r[3] == r[1] == r[2]:        return p[1:4], p[2], 4    elif r[3] == r[4] == r[2]:        return p[2:5], p[2], 4    # 两对    elif r[0] == r[1] and r[2] == r[3]:        return p[0:4], p[3], 3    elif r[0] == r[1] and r[3] == r[4]:        return p[0:2] + p[3:5], p[3], 3    elif r[1] == r[2] and r[3] == r[4]:        return p[1:5], p[3], 3    # 一对    elif r[0] == r[1]:        return p[0:2], p[1], 2    elif r[1] == r[2]:        return p[1:3], p[1], 2    elif r[2] == r[3]:        return p[2:4], p[3], 2    elif r[3] == r[4]:        return p[3:5], p[3], 2    # 单张    else:        return [p[4]], p[4], 1def cmp(p1, p2):    # 三元组(x, y, z)分别表示：真实用上比较等级的牌；真实用上比较等级的牌中，牌面最大的那张；等级数    x1, y1, z1 = get_level(p1)    x2, y2, z2 = get_level(p2)    # 如果等级不同，直接判断等级。    if z1 &gt; z2:        return 1    elif z1 &lt; z2:        return 0    # 如果等级相同，直接由相同数量最多的那张牌进行牌面比较（QQQQA &lt; KKKK2，2244A &lt; 3355K）。    if y1[0] &gt; y2[0]:        return 1    elif y1[0] &lt; y2[0]:        return 0    # 否则，就用剩下的牌的最大牌面比大小。    l1 = list(set(p1) - set(x1))    l2 = list(set(p2) - set(x2))    l1.sort()    l2.sort()    if l1[-1][0] &gt; l2[-1][0]:        return 1    return 0ls = [s[:-1].split(&#x27; &#x27;) for s in open(&#x27;p054_poker.txt&#x27;, &#x27;r&#x27;).readlines()]# 牌面大小重新映射，牌面越大，字母序号越大。mp = &#123;&#x27;2&#x27;: &#x27;A&#x27;, &#x27;3&#x27;: &#x27;B&#x27;, &#x27;4&#x27;: &#x27;C&#x27;, &#x27;5&#x27;: &#x27;D&#x27;, &#x27;6&#x27;: &#x27;E&#x27;, &#x27;7&#x27;: &#x27;F&#x27;, &#x27;8&#x27;: &#x27;G&#x27;, &#x27;9&#x27;: &#x27;H&#x27;, &#x27;T&#x27;: &#x27;I&#x27;, &#x27;J&#x27;: &#x27;J&#x27;, &#x27;Q&#x27;: &#x27;K&#x27;,      &#x27;K&#x27;: &#x27;L&#x27;, &#x27;A&#x27;: &#x27;M&#x27;&#125;ans = 0for v in ls:    for i in range(len(v)):        v[i] = mp[v[i][0]] + v[i][1]    p1, p2 = v[:5], v[5:]    # 两个人的手牌先按牌面大小排好序。    p1.sort()    p2.sort()    ans += cmp(p1, p2)print(ans)\r\n","categories":["Project Euler"],"tags":["模拟"]},{"title":"Project Euler 55","url":"/project-euler/55/","content":"\r\nProject Euler 55\r\n题目\r\nLychrel numbers\r\nIf we take \\(47\\), reverse and add,\r\n\\(47 + 74 = 121\\), which is\r\npalindromic.\r\nNot all numbers produce palindromes so quickly. For example,\r\n\\(\\begin{aligned}\r\n&amp;349 + 943 = 1292\\\\\r\n&amp;1292 + 2921 = 4213\\\\\r\n&amp;4213 + 3124 = 7337\\\\\r\n\\end{aligned}\\)\r\nThat is, \\(349\\) took three\r\niterations to arrive at a palindrome.\r\nAlthough no one has proved it yet, it is thought that some numbers,\r\nlike \\(196\\), never produce a\r\npalindrome. A number that never forms a palindrome through the reverse\r\nand add process is called a Lychrel number. Due to the theoretical\r\nnature of these numbers, and for the purpose of this problem, we shall\r\nassume that a number is Lychrel until proven otherwise. In addition you\r\nare given that for every number below ten-thousand, it will either (i)\r\nbecome a palindrome in less than fifty iterations, or, (ii) no one, with\r\nall the computing power that exists, has managed so far to map it to a\r\npalindrome. In fact, 10677 is the first number to be shown to require\r\nover fifty iterations before producing a palindrome: \\(4668731596684224866951378664\\) (\\(53\\) iterations, \\(28\\)-digits).\r\nSurprisingly, there are palindromic numbers that are themselves\r\nLychrel numbers; the first example is \\(4994\\).\r\nHow many Lychrel numbers are there below ten-thousand?\r\nNOTE: Wording was modified slightly on \\(24\\) April \\(2007\\) to emphasise the theoretical nature\r\nof Lychrel numbers.\r\n解决方案\r\n本题将迭代上限定为\\(50\\)，因此如果\\(50\\)次迭代完成后仍不是回文数，那么这个数是所要求的。\r\n因此通过Python直接进行暴力枚举迭代。\r\n代码\r\nN = 10000M = 50ans = 0for i in range(1, N):    w = i    for i in range(M):        s = str(w)        w = int(s) + int(s[::-1])        s = str(w)        if s == s[::-1]:            break    s = str(w)    if s != s[::-1]:        ans += 1print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 550","url":"/project-euler/550/","content":"\r\nProject Euler 550\r\n题目\r\nDivisor game\r\nTwo players are playing a game. There are \\(k\\) piles of stones. When it is his turn a\r\nplayer has to choose a pile and replace it by two piles of stones under\r\nthe following two conditions:\r\n\r\nBoth new piles must have a number of stones more than one and less\r\nthan the number of stones of the original pile.\r\nThe number of stones of each of the new piles must be a divisor of\r\nthe number of stones of the original pile.\r\n\r\nThe first player unable to make a valid move loses.\r\nLet \\(f(n,k)\\) be the number of\r\nwinning positions for the first player, assuming perfect play, when the\r\ngame is played with k piles each having between \\(2\\) and \\(n\\) stones (inclusively).\\(f(10,5)=40085\\).\r\nFind \\(f(10^7,10^{12})\\).Give your\r\nanswer modulo \\(987654321\\).\r\n解决方案\r\n令\\(N=10^7,Q=10^{12}\\)。\r\n可以看出这是一个公平组合游戏，我们将每一堆石头视为独立的一个游戏局面，使用SG定理来解决本题。这里的石头一共有\\(k\\)堆，第\\(i\\)堆一共有\\(a_i\\)个，那么整个游戏的\\(sg\\)函数值为\\(sg(a_1)\\oplus sg(a_2)\\oplus\\dots\r\nsg(a_k)\\)。\r\n考虑目前的某一堆石头，一共有\\(n\\)个，每一次操作是用两堆石头\\(d_1,d_2\\)来代替它，这两堆石头是两个独立的新局面。因此，可以写出一堆石头的\\(sg\\)函数定义：\r\n\\[\r\nsg(n)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0 &amp; &amp; \\text{if}\\quad  n=1 \\\\\r\n  &amp;\\text{mex}(\\{sg(d_1)\\oplus sg(d_2)|1&lt;d_1\\le d_2&lt;n,d_1\\mid\r\nn,d_2\\mid n\\}) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n其中运算\\(\\text{mex}(s)\\)表示集合\\(s\\)中未出现的最小的非负整数。\r\n可以发现，\\(1\\sim N\\)中的\\(sg\\)函数值都很小（不超过\\(2^6\\)）。用一个数组\\(c[i]\\)表示\\(1\\sim\r\nN\\)中有多少个数的\\(sg\\)函数值为\\(i\\)。\r\n不过在实现的时候，直接枚举\\(1\\sim\r\nN\\)中的所有因数再进行二重循环的效率是很低的。这里使用了一个优化方法：\r\n对于\\(n\\)的分解\\(n=\\prod_{i=1}^k p_i^{e_i}\\)而言，\\(sg(n)\\)只和无序多重集\\(\\{e_i\\}\\)有关，和\\(p_i\\)无关。因此，将\\(1\\sim N\\)中的每个数分解质因数后对集合\\(\\{e_i\\}\\)进行哈希。只要哈希值相同，那么\\(sg\\)函数值一定相同。如果发现哈希值是第一次生成，那么才按照上面的二重循环计算\\(sg\\)函数值。经过实现，在这个数量级下，只有约\\(500\\)个不同的哈希值。\r\n最终问题转化为有多少种方法可以将\\(sg\\)函数值填入一个长度为\\(Q\\)的序列，并且这\\(Q\\)个值的异或和不为\\(0\\)。\r\n令状态\\(g(i,j)(0\\le i\\le Q,0\\le\r\nj&lt;2^6)\\)表示填入长度为\\(i\\)的序列，并且异或和为\\(j\\)的方案数有多少个。那么不难写出状态转移方程为：\r\n\\[\r\ng(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad  i=0\\land j=0 \\\\\r\n  &amp;0 &amp; &amp; \\text{else if}\\quad  i=0 \\\\\r\n  &amp;\\sum_{k=0}^{2^6-1} g(i-1,j\\oplus k) \\cdot c[k] &amp; &amp;\r\n\\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n但是，对于\\(Q\\)这种数据范围而言，直接进行转移效率非常低。\r\n如果我们已经求出了长度为\\(a\\)的序列的各种填法\\(g(a,\\cdot)\\)和长度为\\(b\\)的各种填法\\(g(b,\\cdot)\\)，不难知道我们可以通过卷积组合出\\(g(a+b,\\cdot)\\)。\r\n枚举所有的\\(g(a,i)\\)和\\(g(b,j)\\)，将这两部分值直接合并起来：\r\n\\(g(a,i)\\cdot g(b,j)\\rightarrow\r\ng(a+b,i\\oplus j)\\)\r\n因此，这给了我们一个方案：依次求出\\(g(2^0,\\cdot),g(2^1,\\cdot),g(2^2,\\cdot),\\dots\\)。然后针对\\(Q\\)，选择这些求出的\\(g(2^i,\\cdot)\\)进行合并即可。\r\n最终答案为\\(\\sum_{i=1}^{2^6-1}\r\ng(Q,i)\\)。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;# include &quot;tools.h&quot;using namespace std;typedef long long ll;const int N=10000000;const ll Q=1e12;ll mod=987654321;int B=log2(N+1)+1;const int M=1&lt;&lt;7;int v[N+4],pr[N/10+100],m=0;int sg[N+4];bool mex[M];int p[10],e[10],e2[10],o=0;unordered_map&lt;ll,int&gt;sg_mem;void fact(int n)&#123;    o=0;    for(;n!=1;)&#123;        int x=v[n];        p[++o]=x;        e[o]=0;        for(;n%x==0;n/=x,++e[o]);    &#125;&#125;ll a[M],b[M];void cal(ll a[M],ll b[M],ll ans[M])&#123;    ll c[M]=&#123;0&#125;;    for(int i=0;i&lt;M;i++)        for(int j=0;j&lt;M;j++)            c[i^j]=(c[i^j]+a[i]*b[j])%mod;    memcpy(ans,c,sizeof(c));&#125;int main()&#123;    for(int i=2;i&lt;=N;i++)&#123;        if(v[i]==0)&#123;            v[i]=i;pr[++m]=i;        &#125;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;N/i) break;            v[i*pr[j]]=pr[j];        &#125;    &#125;    for(int i=2;i&lt;=N;i++)&#123;        fact(i);        memcpy(e2,e,sizeof(e));        sort(e2+1,e2+o+1);        ll hs=0;        for(int j=1;j&lt;=o;j++)            hs=hs*B+e2[j];        if(sg_mem.count(hs))            sg[i]=sg_mem[hs];        else&#123;            vector&lt;pl&gt;fact_v;            for(int j=1;j&lt;=o;j++)                fact_v.push_back(pl(p[j],e[j]));            vector&lt;ll&gt;d=divisors(fact_v);            d.pop_back();            d.erase(d.begin());            memset(mex,0,sizeof(mex));            for(int i=0;i&lt;d.size();i++)                for(int j=i;j&lt;d.size();j++)                    mex[sg[d[i]]^sg[d[j]]]=1;            int j=0;            for(;mex[j];++j);            sg[i]=sg_mem[hs]=j;        &#125;        ++b[sg[i]];    &#125;    a[0]=1;    for(ll n=Q;n;n&gt;&gt;=1)&#123;        if(n&amp;1) cal(a,b,a);        cal(b,b,b);    &#125;    ll ans=0;    for(int j=1;j&lt;M;j++)        ans=(ans+a[j])%mod;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划","矩阵快速幂&#43;","SG定理"]},{"title":"Project Euler 549","url":"/project-euler/549/","content":"\r\nProject Euler 549\r\n题目\r\nDivisibility of factorials\r\nThe smallest number \\(m\\) such that\r\n\\(10\\) divides \\(m!\\) is \\(m=5\\).\r\nThe smallest number \\(m\\) such that\r\n\\(25\\) divides \\(m!\\) is \\(m=10\\).\r\nLet \\(s(n)\\) be the smallest number\r\n\\(m\\) such that \\(n\\) divides \\(m!\\). So \\(s(10)=5\\) and \\(s(25)=10\\).\r\nLet \\(S(n)\\) be \\(\\sum s(i)\\) for \\(2 \\le i \\le n\\). \\(S(100)=2012\\).\r\nFind \\(S(10^8)\\).\r\n解决方案\r\n令\\(N=10^8.\\)\r\n设\\(f(n, p)\\)是质因子\\(p\\)在\\(n!\\)中的次数，那么\\(f(n,p)=\\left\\lfloor\\dfrac{n}{p}\\right\\rfloor+\\left\\lfloor\\dfrac{n}{p^2}\\right\\rfloor+\\left\\lfloor\\dfrac{n}{p^3}\\right\\rfloor+\\dots\\)\r\n令\\(n\\)的分解为\\(n=\\prod_{i=1}^kp_i^{e_i}\\)，那么不难看出\\(s(n)\\)本质上是取决于\\(n\\)的分解中，每个\\(p_i^{e_i}\\)的分量的\\(s\\)函数值。也就是说，\r\n\\[s(n)=\\max_{i=1}^k\\{s(p_i^{e_i})\\}\\]\r\n当求解\\(s(p_i^{e_i})\\)时，可以发现\\(e_i\\)其实很小，因此可以考虑从小到大枚举\\(p_i\\)的倍数\\(mp_i\\)，当\\(f(mp_i,p_i)\\ge e_i\\)时，终止枚举，并且\\(s(p_i^{e_i})=mp_i.\\)\r\n最终，通过筛法可以求出\\(N\\)以内的所有\\(s(n)\\)函数值。\r\n本题似乎可以使用min_25筛法进行优化到亚线性级别的时间复杂度，待补。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=1e8;int s[N+4];int cals(int p,int e)&#123;    ll k;    for(k=p;;k+=p)&#123;        ll t=k;        for(;t%p==0&amp;&amp;e&gt;0;--e,t/=p);        if(e==0) break;    &#125;    return k;&#125;int main()&#123;    for(int i=2;i&lt;=N;i++)&#123;        if(s[i]!=0) continue;        for(ll j=i,c=1;j&lt;=N;j*=i,++c)&#123;            int mx=cals(i,c);            for(ll k=j;k&lt;=N;k+=j)                s[k]=max(s[k],mx);        &#125;    &#125;    ll ans=0;    for(int i=2;i&lt;=N;i++)&#123;        ans+=s[i];    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 555","url":"/project-euler/555/","content":"\r\nProject Euler 555\r\n题目\r\nMcCarthy \\(91\\) function\r\nThe McCarthy 91 function is defined as follows: \\[\r\nM_{91}(n) =\r\n    \\begin{cases}\r\n        n - 10 &amp; \\text{if } n &gt; 100 \\\\\r\n        M_{91}(M_{91}(n+11)) &amp; \\text{if } 0 \\leq n \\leq 100\r\n    \\end{cases}\r\n\\]\r\nWe can generalize this definition by abstracting away the constants\r\ninto new variables:\r\n\\[\r\nM_{m,k,s}(n) =\r\n    \\begin{cases}\r\n        n - s &amp; \\text{if } n &gt; m \\\\\r\n        M_{m,k,s}(M_{m,k,s}(n+k)) &amp; \\text{if } 0 \\leq n \\leq m\r\n    \\end{cases}\r\n\\]\r\nThis way, we have \\(M_{91} =\r\nM_{100,11,10}\\).\r\nLet \\(F_{m,k,s}\\) be the set of\r\nfixed points of \\(M_{m,k,s}\\). That\r\nis,\r\n\\[F_{m,k,s}= \\left\\{ n \\in \\mathbb{N} \\, |\r\n\\, M_{m,k,s}(n) = n \\right\\}\\]\r\nFor example, the only fixed point of \\(M_{91}\\) is \\(n =\r\n91\\). In other words, \\(F_{100,11,10}=\r\n\\{91\\}\\).\r\nNow, define \\(SF(m,k,s)\\) as the sum\r\nof the elements in \\(F_{m,k,s}\\) and\r\nlet \\(S(p,m) = \\displaystyle \\sum_{1 \\leq s\r\n&lt; k \\leq p}{SF(m,k,s)}\\).\r\nFor example, \\(S(10, 10) = 225\\) and\r\n\\(S(1000, 1000)=208724467\\).\r\nFind \\(S(10^6, 10^6)\\).\r\n解决方案\r\n使用以下程序，调整参数\\(m,k,s\\)进行打表：\r\nm = 203k = 12s = 8def f(n):    if n &gt; m:        return n - s    else:        return f(f(n + k))for n in range(m + 4):    print(n, f(n))\r\n发现如下信息：\r\n\r\n当\\(n\\le m\\)时，\\(M_{m,k,s}(n)\\)是周期性的，其周期为\\(k-s\\)。\r\n\\(M_{m,k,s}(m)=m-2s+k\\)。\r\n\r\n如果存在\\(n\\)，使得\\(M_{m,k,s}(n)=n\\)，那么就意味着\\(m-2s+k\\equiv m\r\n\\pmod{k-s}\\)。化简后，得到\r\n\\[k\\equiv 0 \\pmod {k-s}\\]\r\n也就是说，只有满足\\(k-s\\mid\r\nk\\)时，\\(M_{m,k,s}(n)\\)中一整个周期都是方程\\(M_{m,k,s}(n)=n\\)的解。这些解的范围是以下区间中的整数：\r\n\\[(m-(2s-k)-(k-s),m-(2s-k)]\\]\r\n因此先枚举\\(d\\)值，再枚举\\(d\\)的倍数\\(k\\)，那么取\\(s=k-d\\)，回代到区间的式子中，计算这个区间中非负整数之和即可。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=1000000,M=1000000;int main()&#123;    ll ans=0;    for(int d=1;d&lt;=N;d++)&#123;        for(int k=d+d;k&lt;=N;k+=d)&#123;            int s=k-d;            int st=M-s-s+k;            int cnt=max(0,min(k-s,M-s-s+k+1));            ans+=1ll*(st+st-cnt+1)*cnt/2;        &#125;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 56","url":"/project-euler/56/","content":"\r\nProject Euler 56\r\n题目\r\nPowerful digit sum\r\nA googol (\\(10^{100}\\)) is a massive\r\nnumber: one followed by one-hundred zeros; \\(100^{100}\\) is almost unimaginably large:\r\none followed by two-hundred zeros. Despite their size, the sum of the\r\ndigits in each number is only \\(1\\).\r\nConsidering natural numbers of the form, \\(a^b\\), where \\(a,\r\nb &lt; 100\\), what is the maximum digital sum?\r\n解决方案\r\n使用Python直接计算\\(a^b\\)的值，并计算出数位的和。\r\n代码\r\nN = 100ans = 0for a in range(1, N):    for b in range(1, N):        ans = max(ans, sum(int(x) for x in str(a ** b)))print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 530","url":"/project-euler/530/","content":"\r\nProject Euler 530\r\n题目\r\nGCD of Divisors\r\nEvery divisor \\(d\\) of a number\r\n\\(n\\) has a complementary\r\ndivisor \\(\\dfrac{n}{d}\\).\r\nLet \\(f(n)\\) be the sum of the\r\ngreatest common divisor of \\(d\\) and \\(\\dfrac{n}{d}\\) over all positive divisors d\r\nof n, that is \\(f(n)=\\displaystyle\\sum\\limits_{d\\mid n}\r\n\\gcd(d,\\frac n d)\\).\r\nLet \\(F\\) be the summatory function\r\nof \\(f\\), that is \\(F(k)=\\displaystyle\\sum\\limits_{n=1}^k\r\nf(n)\\).\r\nYou are given that \\(F(10)=32\\) and\r\n\\(F(1000)=12776\\).\r\nFind \\(F(10^{15})\\).\r\n解决方案\r\n令\\(N=10^{15}\\)。那么\\(F(N)\\)相当于是求所有\\(a,b\\)满足\\(ab\\le\r\nk\\)的\\(\\gcd(a,b)\\)之和，也就是：\r\n\\[F(N)=\\sum_{i=1}^N\r\n\\sum_{j=1}^{\\left\\lfloor\\frac{N}{i}\\right\\rfloor}\r\n\\gcd(i,j)=\\sum_{d=1}^{\\lfloor\\sqrt{N}\\rfloor} d\\cdot\r\nS\\left(\\dfrac{n}{d}\\right)\\]\r\n其中，\\(S(n)\\)表示有多少对\\(i,j\\)，满足\\(ij\\le n\\land \\gcd(i,j)=1\\)。\r\n那么就可以写出如下等式：\r\n\\[\\begin{aligned}\r\n\\sum_{i=1}^n \\left\\lfloor\\dfrac{n}{i}\\right\\rfloor&amp;=|\\{(a,b)|ab\\le\r\nn\\}|\\\\\r\n&amp;=\\sum_{d=1}^{\\lfloor\\sqrt{n}\\rfloor}|\\{(a,b)|ab\\le\r\nn,\\gcd(a,b)=d\\}|\\\\\r\n&amp;=\\sum_{d=1}^{\\lfloor\\sqrt{n}\\rfloor}\\left|\\left\\{(a,b)|ab\\le\r\n\\left\\lfloor\\dfrac{n}{d^2}\\right\\rfloor,\\gcd(a,b)=1\\right\\}\\right|\\\\\r\n&amp;=\\sum_{d=1}^{\\lfloor\\sqrt{n}\\rfloor}S\\left(\\dfrac{n}{d^2}\\right)\r\n\\end{aligned}\\]\r\n因此，可以得到关于\\(S\\)的递归式：\r\n\\[S(n)=\\sum_{i=1}^n\r\n\\left\\lfloor\\dfrac{n}{i}\\right\\rfloor-\\sum_{d=2}^{\\lfloor\\sqrt{n}\\rfloor}S\\left(\\dfrac{n}{d^2}\\right)\\]\r\n因此计算\\(S(n)\\)时，式子的第一个项，使用数论分块即可完成计算，而第二个项则直接暴力枚举。\r\n正式计算\\(F(n)\\)时，同样直接枚举每一个项并相加即可。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll N=1000000000000000;const int M=pow(N,0.52)+4;unordered_map&lt;ll,ll&gt;mp;int v[M+4],pr[M/5+1000],m=0;int s[M+4];ll cal(ll n)&#123;    if(n&lt;=M) return s[n];    if(mp.count(n)) return mp[n];    ll ans=0;    for(ll l=1,r;l&lt;=n;l=r+1)&#123;        r=n/(n/l);        ans+=n/l*(r-l+1);    &#125;    for(ll l=2;l*l&lt;=n;l++)        ans-=cal(n/(l*l));    return mp[n]=ans;&#125;int main()&#123;    s[1]=1;    for(int i=2;i&lt;=M;i++)&#123;        if(v[i]==0)&#123;            v[i]=i;pr[++m]=i;s[i]=2;        &#125;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;M/i) break;            v[i*pr[j]]=pr[j];            s[i*pr[j]]=(pr[j]==v[i]?s[i]:s[i]*2);        &#125;        s[i]+=s[i-1];    &#125;    ll ans=0;    for(ll l=1;l*l&lt;=N;l++)        ans+=l*cal(N/(l*l));    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["数论分块"]},{"title":"Project Euler 561","url":"/project-euler/561/","content":"\r\nProject Euler 561\r\n题目\r\nDivisor Pairs\r\nLet \\(S(n)\\) be the number of pairs\r\n\\((a,b)\\) of distinct divisors of \\(n\\) such that \\(a\\) divides \\(b\\).\r\nFor \\(n=6\\) we get the following\r\npairs: \\((1,2), (1,3), (1,6),( 2,6)\\)\r\nand \\((3,6)\\). So \\(S(6)=5\\).\r\nLet \\(p_m\\#\\) be the product of the\r\nfirst \\(m\\) prime numbers, so \\(p_2\\# = 2*3 = 6\\).\r\nLet \\(E(m, n)\\) be the highest\r\ninteger \\(k\\) such that \\(2^k\\) divides \\(S((p_m\\#)^n)\\).\r\n\\(E(2,1) = 0\\) since \\(2^0\\) is the highest power of \\(2\\) that divides \\(S(6)=5\\).\r\nLet \\(Q(n)=\\sum_{i=1}^{n} E(904961,\r\ni)\\)\r\n\\(Q(8)=2714886\\).\r\nEvaluate \\(Q(10^{12})\\).\r\n解决方案\r\n令\\(n\\)的分解质因数为\\(n=\\prod_{i=1}^m p_i^{e_i}\\)。那么，\\(S(n)\\)的求解就化为以下问题：\r\n有多少对\\(m\\)维向量\\((\\vec{a},\\vec{b})\\)，其中\\(\\vec{a}=(a_1,a_2,\\dots,a_m),\\vec{b}=(b_1,b_2,\\dots,b_m)\\)，满足\\(\\forall i\\in[1,m],0\\le a_i\\le b_i\\le\r\ne_i\\)，并且\\(\\vec{a}\\neq\r\n\\vec{b}\\)？\r\n不难计算出\\(S(n)=\\prod_{i=1}^m\r\n\\dfrac{(e_i+1)(e_i+2)}{2}-\\prod_{i=1}^m (e_i+1)\\)\r\n计算\\(S((p_m\\#)^n)\\)时，可以发现\\(e_1=e_2=\\dots=e_m=n\\)。\r\n因此，\r\n\\[S((p_m\\#)^n)=\\left(\\dfrac{(n+1)(n+2)}{2}\\right)^m-(n+1)^m\\]\r\n当\\(n\\)是奇数时，上式可以改写成\\(S((p_m\\#)^n)=\\left(\\dfrac{n+1}{2}\\right)^m((n+2)^m-2^m)\\)，这确保了第二项是奇数。\r\n当\\(n\\)是偶数时，上式可以改写成\\(S((p_m\\#)^n)=(n+1)^m\\left(\\left(\\dfrac{n+2}{2}\\right)^m-1\\right)\\)，这时第一项是奇数。\r\n令函数\\(f(x)\\)为：最大的一个\\(e\\)使得\\(2^e\\mid\r\nx\\)。令\\(n=4k+a,a\\in\\{0,1,2,3\\}\\)。接下来描述\\(a\\)的\\(4\\)种情况，\\(a\\)将和上面讨论\\(S((p_m\\#)^n)\\)的奇偶性对应。\r\n\r\n当\\(a=0\\)时，代入\\(S((p_m\\#)^n)\\)的第二项，得到\\((2k+1)^m-1\\)，因式分解后为\\(2k\\cdot \\sum_{i=0}^{m-1}(2k+1)^i.\\)\r\n\r\n\r\n如果\\(m\\)为奇数，那么式子中的求和项有奇数个，因此整个值为奇数，此时\\(E(n,m)=f(k)+1\\).\r\n如果\\(m\\)为偶数，那么经过对\\((2k+1)^m-1\\)打表后再找规律，发现\\(E(n,m)=f(k)+1 +f(k+1)+f(m)\\)\r\n\r\n\r\n当\\(a=1\\)时，代入\\(S((p_m\\#)^n)\\)的第一项，得到\\((2k+1)^m\\)，这是个奇数，故\\(E(m,n)=0.\\)\r\n当\\(a=2\\)时，代入\\(S((p_m\\#)^n)\\)的第二项，得到\\((2k)^m-1\\)，这是个奇数，故\\(E(m,n)=0.\\)\r\n当\\(a=3\\)时，代入\\(S((p_m\\#)^n)\\)的第一项，得到\\((2k+2)^m\\)，那么\\(E(m,n)=m\\cdot\r\nf(2k+2)=m\\cdot(f(k+1)+1)\\).\r\n\r\n令\\(m=904961,N=10^{12}.\\)那么，有\\(\\left\\lfloor\\dfrac{N}{4}\\right\\rfloor\\)个数属于\\(a=0\\)的情况，有\\(\\left\\lfloor\\dfrac{N+1}{4}\\right\\rfloor\\)属于\\(a=3\\)种情况。\r\n令\\(F(n)=\\sum_{i=1}^n\r\nf(i)\\)，当\\(m\\)为奇数时，有：\r\n\\(\\begin{aligned}\r\n&amp;\\sum_{k=0}^{\\left\\lfloor\\frac{N+1}{4}\\right\\rfloor-1}m\\cdot(f(k+1)+1)+\\sum_{k=1}^{\\left\\lfloor\\frac{N}{4}\\right\\rfloor}f(k)+1\\\\\r\n=&amp;m\\cdot\r\nF\\left(\\left\\lfloor\\dfrac{N+1}{4}\\right\\rfloor\\right)+m\\cdot\\left\\lfloor\\dfrac{N+1}{4}\\right\\rfloor+F\\left(\\left\\lfloor\\dfrac{N}{4}\\right\\rfloor\\right)+\\left\\lfloor\\dfrac{N}{4}\\right\\rfloor\r\n\\end{aligned}\\)\r\n当\\(m\\)是偶数时，同样将式子代入即可。\r\n最终的问题则是高效计算\\(F(n)\\)。计算的思想使用了容斥原理：在\\(2^0\\)的倍数中，有多少个不是\\(2^1\\)的倍数，这些数贡献了\\(0\\)；在\\(2^1\\)的倍数中，有多少个不是\\(2^2\\)的倍数，这些数贡献了\\(1\\)……，最终，分类将它们的贡献相加即可。\r\n代码\r\nN = 10 ** 12M = 904962def F(n):    return sum(((n &gt;&gt; i) - (n &gt;&gt; (i + 1))) * i for i in range(len(bin(n)) - 2))c0 = N // 4c3 = (N + 1) // 4if M % 2 == 0:    ans = M * F(c3) + M * c3 + F(c0) + c0 + F(c0 + 1) + (bin(M)[::-1].find(&#x27;1&#x27;)) * c0else:    ans = M * F(c3) + M * c3 + F(c0) + c0print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 571","url":"/project-euler/571/","content":"\r\nProject Euler 571\r\n题目\r\nSuper Pandigital Numbers\r\nA positive number is pandigital in base \\(b\\) if it contains all digits from \\(0\\) to \\(b - 1\\) at least once when written in base\r\n\\(b\\).\r\nA \\(n\\)-super-pandigital\r\nnumber is a number that is simultaneously pandigital in all bases from\r\n\\(2\\) to \\(n\\) inclusively.\r\nFor example \\(978 = 1111010010_2 = 1100020_3 = 33102_4 = 12403_5\\)\r\nis the smallest \\(5\\)-super-pandigital\r\nnumber.\r\nSimilarly, \\(1093265784\\) is the\r\nsmallest \\(10\\)-super-pandigital\r\nnumber.\r\nThe sum of the \\(10\\) smallest \\(10\\)-super-pandigital numbers is \\(20319792309\\).\r\nWhat is the sum of the \\(10\\)\r\nsmallest \\(12\\)-super-pandigital\r\nnumbers?\r\n解决方案\r\n令\\(N=12\\)。本题通过按照字典序大小暴力枚举\\(N\\)阶置换。然后再从\\(11\\)到\\(4\\)进制判断这个数是否符合条件（不需要判断\\(2,3\\)进制，因为这个数只要符合\\(9\\)进制，那么它一定符合\\(3\\)进制；任何一个二进制数都有\\(0,1\\)两位）。将符合条件的数相加即可。\r\n代码\r\n本份代码效率略低，约\\(70s\\)。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=12;int Q=10;char a[N];bool check(ll x,int b)&#123;    int st=0,c=0;    for(;x;x/=b)&#123;        int w=x%b;        if(!(st&gt;&gt;w&amp;1)&amp;&amp;++c==b) return 1;        st|=1&lt;&lt;w;    &#125;    return 0;&#125;int main()&#123;    a[0]=1;a[1]=0;    for(int i=2;i&lt;N;i++)        a[i]=i;    ll ans=0;    do&#123;        ll x=0;        for(int i=0;i&lt;N;i++)            x=x*N+a[i];        bool ok=1;        for(int i=N-1;i&gt;3&amp;&amp;ok;i--)            if(!check(x,i)) ok=0;        if(ok)&#123;            vector&lt;int&gt;a;            ans+=x;            for(;x;x/=(N-1))&#123;                a.push_back(x%(N-1));            &#125;            reverse(a.begin(),a.end());            if(--Q==0) break;        &#125;    &#125;while(next_permutation(a,a+N));    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 57","url":"/project-euler/57/","content":"\r\nProject Euler 57\r\n题目\r\nSquare root convergents\r\nIt is possible to show that the square root of two can be expressed\r\nas an infinite continued fraction. \\[\\sqrt 2\r\n=1+ \\dfrac 1 {2+ \\dfrac 1 {2 +\\dfrac 1 {2+ \\dots}}}\\] By\r\nexpanding this for the first four iterations, we get:\r\n\\(1 + \\dfrac 1 2 = \\dfrac  32 =\r\n1.5\\)\r\n\\(1 + \\dfrac 1 {2 + \\dfrac 1 2} = \\dfrac 7\r\n5 = 1.4\\)\r\n\\(1 + \\dfrac 1 {2 + \\dfrac 1 {2+\\dfrac 1\r\n2}} = \\dfrac {17}{12} = 1.41666 \\dots\\)\r\n\\(1 + \\dfrac 1 {2 + \\dfrac 1 {2+\\dfrac 1\r\n{2+\\dfrac 1 2}}} = \\dfrac {41}{29} = 1.41379 \\dots\\)\r\nThe next three expansions are \\(\\dfrac\r\n{99}{70}\\), \\(\\dfrac\r\n{239}{169}\\), and \\(\\dfrac\r\n{577}{408}\\), but the eighth expansion, \\(\\dfrac {1393}{985}\\), is the first example\r\nwhere the number of digits in the numerator exceeds the number of digits\r\nin the denominator.\r\nIn the first one-thousand expansions, how many fractions contain a\r\nnumerator with more digits than the denominator?\r\n解决方案\r\n观察上面的连分数，将其写成一个序列\\(a_1,a_2,a_3,\\dots\\)，容易发现规律： \\[a_n=\\frac{1}{1+a_{n-1}}+1\\]\r\n因此，直接通过此式子进行\\(1000\\)次迭代求出每个序列的值。\r\n本代码使用的是fractions库中的Fraction类，它用于维护一个分数的类型。\r\n代码\r\nfrom fractions import FractionN = 1000a = Fraction(1, 1)ans = 0for i in range(1000):    a = 1 / (1 + a) + 1    if len(str(a.numerator)) &gt; len(str(a.denominator)):        ans += 1print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 58","url":"/project-euler/58/","content":"\r\nProject Euler 58\r\n题目\r\nSpiral primes\r\nStarting with 1 and spiralling anticlockwise in the following way, a\r\nsquare spiral with side length 7 is formed.\r\n\r\n37 36 35 34 33 32 31\r\n 38 17 16 15 14 13\r\n30  39 18  5  4  3\r\n12 29  40 19  6  1  2 11 28  41 20  7\r\n 8  9 10 27  42 21 22 23 24 25 26  43\r\n44 45 46 47 48 49\r\n\r\nIt is interesting to note that the odd squares lie along the bottom\r\nright diagonal, but what is more interesting is that \\(8\\) out of the \\(13\\) numbers lying along both diagonals are\r\nprime; that is, a ratio of \\(\\dfrac{8}{13}\r\n\\approx 62\\%\\).\r\nIf one complete new layer is wrapped around the spiral above, a\r\nsquare spiral with side length \\(9\\)\r\nwill be formed. If this process is continued, what is the side length of\r\nthe square spiral for which the ratio of primes along both diagonals\r\nfirst falls below \\(10\\%\\)?\r\n解决方案\r\n这个矩阵的四个角的元素的通项公式分别是：\\(4n^2-10n+7,4(n-1)^2+1,4n^2-6n+3,(2n-1)^2\\)，其中\\(n\\ge 1\\)，用的是第28题的结论。\r\n因此，这份代码将通过公式枚举出一个个质数，然后单独进行判断即可。\r\n代码\r\nfrom tools import is_primefrom itertools import countr = 0.1c0 = 0c1 = 1for i in count(2, 1):    for x in [4 * i * i - 10 * i + 7, 4 * (i - 1) * (i - 1) + 1, 4 * i * i - 6 * i + 3, (2 * i - 1) ** 2]:        c1 += 1        if is_prime(x):            c0 += 1    if c0 / c1 &lt; r:        ans = i * 2 - 1        breakprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 510","url":"/project-euler/510/","content":"\r\nProject Euler 510\r\n题目\r\nTangent Circles\r\nCircles \\(A\\) and \\(B\\) are tangent to each other and to line\r\n\\(L\\) at three distinct points.\r\nCircle \\(C\\) is inside the space\r\nbetween \\(A, B\\) and \\(L\\), and tangent to all three.\r\nLet \\(r_A, r_B\\) and \\(r_C\\) be the radii of A, B and C\r\nrespectively.\r\n\r\nLet \\(S(n)=\\sum r_A+r_B+r_C\\), for\r\n\\(0&lt;r_A\\le r_B\\le n\\) where \\(r_A, r_B\\) and \\(r_C\\) are integers.\r\nThe only solution for \\(0&lt;r_A\\le\r\nr_B\\le5\\) is \\(r_A=4, r_B=4\\)\r\nand \\(r_C=1\\), so \\(S(5)=4+4+1=9\\).\r\nYou are also given \\(S(100)=3072\\).\r\nFind \\(S(10^9)\\).\r\n笛卡尔定理\r\n笛卡尔定理的一种特殊情况：假设三个圆\\(A,B,C\\)两两相切，它们的半径分别是\\(r_A,r_B,r_C\\)，并且存在一条直线\\(L\\)，使得\\(L\\)是这三个圆的公切线。如果圆\\(C\\)在\\(L\\)上的切点位于另外两个圆\\(A,B\\)的切点的中间，那么\\(r_A,r_B,r_C\\)满足此式子：\r\n\\[\\dfrac{1}{\\sqrt{r_A}}+\\dfrac{1}{\\sqrt{r_B}}=\\dfrac{1}{\\sqrt{r_C}}\\]\r\n在这个特殊情况下，原本笛卡尔定理中的第四个圆的曲率被认为是\\(0\\)。\r\n解决方案\r\n可以将上面的式子写成\r\n\\[r_C=\\dfrac{r_Ar_B}{r_A+r_B+2\\sqrt{r_Ar_B}}\\]\r\n不难看出，如果\\(r_C\\)是一个有理数，那么\\(r_Ar_B\\)必须是一个平方数。\r\n假设\\(r_A=ta^2,r_B=tb^2,a\\le\r\nb,\\gcd(a,b)=1,t&gt;0\\)，那么就可以将\\((r_A,r_B,r_C)\\)写成一个三元组形式\\(\\left(ta^2,tb^2,\\dfrac{ta^2b^2}{(a+b)^2}\\right)\\)\r\n因此，\\((a+b)^2\\mid t\\)。\r\n那么，重新令\\(r_A=dp^2(p+q)^2,r_B=dq^2(p+q)^2,r_C=dp^2q^2\\)，其中\\(p\\le\r\nq,\\gcd(p,q)=1,d&gt;0\\)，那么枚举出每对互质的\\((p,q)\\)和\\(d\\)，就产生了一对符合要求的三元组\\((r_A,r_b,r_C)\\)。\r\n在代码实现中，\\((p,q)\\)的枚举是在Stern-Brocot\r\nTree上进行。\r\n代码\r\nN = 10 ** 9def cal(p, q):    a, b, c = p ** 2 * (p + q) ** 2, q ** 2 * (p + q) ** 2, (p * q) ** 2    d = N // b    return d * (d + 1) // 2 * (a + b + c)ans = cal(1, 1)st = [(0, 1, 1, 1)]while len(st) &gt; 0:    a, c, b, d = st.pop()    p, q = a + b, c + d    w = cal(p, q)    if w &gt; 0:        ans += w        st.append((a, c, p, q))        st.append((p, q, b, d))print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 560","url":"/project-euler/560/","content":"\r\nProject Euler 560\r\n题目\r\nCoprime Nim\r\nCoprime Nim is just like ordinary normal play Nim, but the players\r\nmay only remove a number of stones from a pile that is\r\ncoprime with the current size of the pile. Two players\r\nremove stones in turn. The player who removes the last stone wins.\r\nLet \\(L(n, k)\\) be the number of\r\nlosing starting positions for the first player,\r\nassuming perfect play, when the game is played with \\(k\\) piles, each having between \\(1\\) and \\(n - 1\\) stones inclusively.\r\nFor example, \\(L(5, 2) = 6\\) since\r\nthe losing initial positions are \\((1, 1),\r\n(2, 2), (2, 4), (3, 3), (4, 2)\\) and \\((4, 4)\\).\r\nYou are also given \\(L(10, 5) = 9964,\r\nL(10, 10) = 472400303, L(10^3, 10^3) \r\n\\bmod 1 000 000 007 = 954021836\\).\r\nFind \\(L(10^7, 10^7) \\bmod 1 000 000 007\\)\r\n快速沃尔什变换\r\n目标：给定两个长度为\\(N=2^n\\)的序列\\(a,b\\)（两个序列从下标从\\(0\\)开始），求一个长度为\\(N\\)的序列\\(c\\)，满足：\r\n\\[c_k=\\sum_{i \\circ j=k} a_i\\cdot\r\nb_j\\]\r\n其中运算符\\(\\circ\\)是三种位运算的运算符之一：与运算\\(\\&amp;\\)，或运算\\(|\\)，异或运算\\(\\oplus\\)。\r\n快速沃尔什变换可以将整个计算过程的时间复杂度从\\(O(N^2)\\)下降到\\(O(N \\log N)\\)。\r\n此处不详述这个算法，此处为参考文章和代码。\r\n解决方案\r\n令\\(N=10^7,K=10^7\\)。\r\n可以看出这是一个公平组合游戏，我们将每一堆石头视为独立的一个游戏局面，使用SG定理来解决本题。这里的石头一共有\\(K\\)堆，第\\(i\\)堆一共有\\(a_i\\)个，那么整个游戏的\\(sg\\)函数值为\\(sg(a_1)\\oplus sg(a_2)\\oplus\\dots\r\nsg(a_k)\\)。\r\n考虑目前的某一堆石头，一共有\\(n\\)个，每一次操作是取出\\(d\\)个石头，其中\\(\\gcd(n,d)=1\\)。因此，可以写出一堆石头的\\(sg\\)函数定义：\r\n\\[\r\nsg(n)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0 &amp; &amp; \\text{if}\\quad  n=0 \\\\\r\n  &amp;\\text{mex}(\\{sg(n-d)|\\gcd(i,d)=1\\}) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n其中运算\\(\\text{mex}(s)\\)表示集合\\(s\\)中未出现的最小的非负整数。\r\n那么考虑运行这一份代码，打印出前一部分项的\\(sg\\)函数。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=100,M=100;int sg[N+4];bool mex[M+4];int pr[N/10+100],v[N+4];int main()&#123;    for(int i=1;i&lt;=N;i++)&#123;        memset(mex,0,sizeof(mex));        for(int j=1;j&lt;=i;j++)            if(__gcd(i,j)==1) mex[sg[i-j]]=1;        int j=0;        for(;mex[j];++j);        sg[i]=j;        printf(&quot;%d %d\\n&quot;,i,sg[i]);    &#125;&#125;\r\n发现规律如下：\r\n\r\n\\(sg(1)=1\\)\r\n如果\\(n\\)为偶数，那么\\(sg(n)=0\\)\r\n否则，假设\\(n\\)的最小质因子为\\(p\\)，如果质数表中第\\(k\\)个质数（\\(k\\)从\\(1\\)开始算起）为\\(p\\)，那么\\(sg(n)=k\\)。\r\n\r\n最终问题转化为有多少种方法可以将\\(sg\\)函数值填入一个长度为\\(K\\)的序列，并且这\\(K\\)个值的异或和为\\(0\\)。\r\n令状态\\(g(i,j)(0\\le i\\le K,j\\ge\r\n0)\\)表示填入长度为\\(i\\)的序列，并且异或和为\\(j\\)的方案数有多少个。那么不难写出状态转移方程为：\r\n\\[\r\ng(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad  i=0\\land j=0 \\\\\r\n  &amp;0 &amp; &amp; \\text{else if}\\quad  i=0 \\\\\r\n  &amp;\\sum_{k} g(i-1,j\\oplus k) \\cdot c[k] &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n注意到，此时\\(sg\\)函数值比较大，可以达到\\(O\\left(\\dfrac{N}{\\log\r\nN}\\right)\\)的级别。对于\\(Q\\)这种数据范围而言，直接进行转移效率非常低。\r\n如果我们已经求出了长度为\\(a\\)的序列的各种填法\\(g(a,\\cdot)\\)和长度为\\(b\\)的各种填法\\(g(b,\\cdot)\\)，不难知道我们可以通过卷积组合出\\(g(a+b,\\cdot)\\)。\r\n枚举所有的\\(g(a,i)\\)和\\(g(b,j)\\)，将这两部分值直接合并起来：\r\n\\(g(a,i)\\cdot g(b,j)\\rightarrow\r\ng(a+b,i\\oplus j)\\)\r\n直接枚举这两部分的值效率非常低，可以使用快速沃尔什变换加速计算这两部分的合并。\r\n因此，这给了我们一个方案：依次求出\\(g(2^0,\\cdot),g(2^1,\\cdot),g(2^2,\\cdot),\\dots\\)。然后针对\\(Q\\)，选择这些求出的\\(g(2^i,\\cdot)\\)进行合并即可。\r\n最终答案为\\(g(Q,0)\\)。\r\n代码\r\n为了加速，特地设计了一个powXor的函数。如果直接按照上面的快速沃尔什变换模板使用，那么总共需要做\\(O(\\log\r\nQ)\\)次变换和逆变换。而此处由于是多次求值，因此总共只需要\\(3\\)次变换和逆变换。\r\n# include &lt;bits/stdc++.h&gt;# include &quot;tools.h&quot;using namespace std;typedef long long ll;const int N=10000000,M=10000000;int mod= 1000000007;int pr[N/5+100],v[N+4],m=0;int main()&#123;    for(int i=2;i&lt;=N;i++)&#123;        if(v[i]==0)&#123;            pr[++m]=i;v[i]=m;        &#125;        for(int j=1;j&lt;=m;j++)&#123;            if(j&gt;v[i]||pr[j]&gt;N/i) break;            v[i*pr[j]]=j;        &#125;    &#125;    v[1]=1;    for(int i=2;i&lt;=N;i+=2)        v[i]=0;    vector&lt;int&gt;b(m+1);    for(int i=1;i&lt;N;i++)        ++b[v[i]];    fwt.init_mod(mod);    int ans=fwt.powXor(b,M)[0];    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["SG定理","快速沃尔什变换"]},{"title":"Project Euler 581","url":"/project-euler/581/","content":"\r\nProject Euler 581\r\n题目\r\n\\(47\\)-smooth triangular numbers\r\nA number is \\(p\\)-smooth if it has\r\nno prime factors larger than \\(p\\).\r\nLet \\(T\\) be the sequence of\r\ntriangular numbers, ie \\(T(n)=\\dfrac{n(n+1)}{2}\\).\r\nFind the sum of all indices \\(n\\)\r\nsuch that \\(T(n)\\) is \\(47\\)-smooth.\r\nStørmer 定理\r\nStørmer定理，说明了上述定义的全体\\(P\\)-smooth数（注意这里的\\(P\\)是一个质数集合，比小于等于\\(p\\)的全体质数这种集合更普遍）中，连续两个数\\(n,n+1\\)都是\\(P\\)-smooth数的\\(n\\)的数量是有限的，并提供了一个算法查找这些\\(n\\)：\r\n假设集合\\(P\\)的大小为\\(k\\)，其中最大的质数为\\(r\\).\r\n那么枚举由集合\\(P\\)中的质因子组合而成的所有无平方因子数\\(q\\)（一共有\\(2^k\\)个这样的\\(q\\)），然后解以下佩尔方程：\r\n\\[x^2-2qy^2=1\\]\r\n那么，对这个佩尔方程的前\\(\\max\\left(3,\\dfrac{r+1}{2}\\right)\\)个解\\((x_i,y_i)\\)一一进行测试。如果\\(\\dfrac{x_i+1}{2},\\dfrac{x_i-1}{2}\\)都是\\(P\\)-smooth的，那么就找到了一个\\(P\\)-smooth对。\r\n注意当\\(q=2\\)时，佩尔方程无解，因此需要规避这种情况。\r\n解决方案\r\n如果一个三角形数\\(\\dfrac{n(n+1)}{2}\\)是\\(p\\)-smooth的，那么说明\\(n\\)和\\(n+1\\)是\\(p\\)-smooth的。\r\n一开始的想法则是通过深度优先搜索直接产生所有\\(p\\)-smooth数\\(x\\)，并判断\\(x+1\\)是否为\\(p\\)-smooth数。并且拟定一个枚举上限\\(2\\times 10^{12}\\)。\r\n之后，我查阅了Størmer定理并直接解决本问题，至于佩尔方程的解法在66题已经详述。\r\n不过，让我比较惊讶的是，Størmer定理的实现效率会比直接搜索更低。\r\nOEIS上的数列A002072则给出了最大答案的上限。在FORMULA一栏中，找到\r\na(n) &lt; 10^n/n except for n=4. (Conjectured, from experimental data.) - M. F. Hasler, Jan 16 2015\r\n在实现Størmer定理时，还顺带了这个条件进行剪枝。\r\n由于实现Størmer定理的效率过低，此处不附上使用它实现的代码。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int M=47;ll MX;int pr[M+4],m=0,b[M+4];ll ans=0;void dfs(int f,ll x)&#123;    if(f==m+1)&#123;        ll y=x+1;        for(int i=1;i&lt;=m&amp;&amp;y&gt;1;i++)            while(y%pr[i]==0) y/=pr[i];        if(y==1) ans+=x;        return;    &#125;    for(;x&lt;=MX;x*=pr[f])        dfs(f+1,x);&#125;int main()&#123;    for(int i=2;i&lt;=M;i++)&#123;        if(b[i]) continue;        pr[++m]=i;        for(int j=i+i;j&lt;=M;j+=i)            b[j]=1;    &#125;    MX=(m==4?4374:pow(10,m)/m);    dfs(1,1);    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 587","url":"/project-euler/587/","content":"\r\nProject Euler 587\r\n题目\r\nConcave triangle\r\nA square is drawn around a circle as shown in the diagram below on\r\nthe left. We shall call the blue shaded region the L-section.\r\nA line is drawn from the bottom left of the square to the top right\r\nas shown in the diagram on the right.\r\nWe shall call the orange shaded region a concave triangle.\r\n\r\nIt should be clear that the concave triangle occupies exactly half of\r\nthe L-section.\r\nTwo circles are placed next to each other horizontally, a rectangle\r\nis drawn around both circles, and a line is drawn from the bottom left\r\nto the top right as shown in the diagram below.\r\n\r\nThis time the concave triangle occupies approximately \\(36.46\\%\\) of the L-section.\r\nIf \\(n\\) circles are placed next to\r\neach other horizontally, a rectangle is drawn around the \\(n\\) circles, and a line is drawn from the\r\nbottom left to the top right, then it can be shown that the least value\r\nof \\(n\\) for which the concave triangle\r\noccupies less than \\(10\\%\\) of the\r\nL-section is \\(n = 15\\).\r\nWhat is the least value of \\(n\\) for\r\nwhich the concave triangle occupies less than \\(0.1\\%\\) of the L-section?\r\n解决方案\r\n这里假设每个圆的半径都为\\(1\\)。\r\n不难计算出，原本的L-section面积为\\(S_0=1-\\dfrac{\\pi}{4}\\)。\r\n假设题目中所求的圆的个数为\\(k\\)。以下图为例，此时的\\(k=3\\)。\r\n\r\n以\\(O\\)为原点，\\(OC\\)为\\(x\\)轴正方向建立平面直角坐标系，那么\\(\\odot P\\)的方程为\\((x-1)^2+(y-1)^2=1\\)，\\(OB\\)为\\(y=\\dfrac{x}{k}\\)。\r\n联立\\(OB\\)和\\(\\odot P\\)的方程，得到：\r\n\\[(k^2+1)x^2-2k(k+1)x+k^2=0\\]\r\n那么通过二次方程的求根公式，可以解出\\(A\\)的坐标。假设其为\\((x_0,y_0)\\)。\r\n那么凹三角形\\(OAC\\)就被直线\\(x=x_0\\)分成了两部分，一部分是左边的直角三角形，面积为\\(\\dfrac{x_0y_0}{2}\\)。另一部分通过积分进行计算，面积为\\(I\\)，其中\r\n\\[\\begin{aligned}\r\nI&amp;=\\int_{x_0}^1 1-\\sqrt{1-(x-1)^2}dx\\\\\r\n&amp;=\\int_{x_0-1}^01-\\sqrt{1-x^2}dx\\\\\r\n&amp;=\\int_{0}^{1-x_0}1-\\sqrt{1-x^2}dx\\\\\r\n&amp;=1-x_0-\\int_{0}^{1-x_0}\\sqrt{1-x^2}dx\r\n\\end{aligned}\\]\r\n经过查表，\\(\\int\r\n\\sqrt{1-x^2}dx=\\dfrac{1}{2}(\\arcsin x+x\\sqrt{1-x^2})+C\\)\r\n因此\r\n\\[I=1-x_0-\\dfrac{1}{2}(\\arcsin\r\n(1-x_0)+(1-x_0)\\sqrt{1-(1-x_0)^2})\\]\r\n因此凹三角形\\(OAC\\)的总面积为\r\n\\[S_k=\\dfrac{x_0y_0}{2}+1-x_0-\\dfrac{1}{2}(\\arcsin\r\n(1-x_0)+(1-x_0)\\sqrt{1-(1-x_0)^2})\\]\r\n那么题目所求比例值为\\(\\dfrac{S_k}{S_0}\\)。\r\n随着\\(k\\)越大，值\\(\\dfrac{S_k}{S_0}\\)越小，这个值具有单调性。为了找到符合题目要求的最小\\(k\\)，考虑使用二分查找算法解决。\r\n代码\r\nfrom math import pi, asinR = 0.001S0 = 1 - pi / 4k = 1l, r = 1, 10 ** 9while l &lt; r:    k = (l + r) &gt;&gt; 1    a = 1 + k * k    b = -k * k * 2 - k * 2    c = k * k    d = b * b - 4 * a * c    x = (-b - d ** 0.5) / (a * 2)    t = 1 - x    Sk = x * x / k / 2 + t - 0.5 * (asin(t) + t * (1 - t ** 2) ** 0.5)    if Sk / S0 &lt; R:        r = k    else:        l = k + 1ans = lprint(ans)\r\n","categories":["Project Euler"],"tags":["二分"]},{"title":"Project Euler 593","url":"/project-euler/593/","content":"\r\nProject Euler 593\r\n题目\r\nFleeting Medians\r\nWe define two sequences \\(S = \\{S(1), S(2),\r\n\\dots, S(n)\\}\\) and \\(S_2 = \\{S_2(1),\r\nS_2(2), \\dots, S_2(n)\\}\\):\r\n\\(S(k) = (p_k)^k \\bmod 10007\\) where\r\n\\(p_k\\) is the \\(k\\text{th}\\) prime number.\r\n\\(S_2(k) = S(k) +\r\nS\\left(\\left\\lfloor\\dfrac{k}{10000}\\right\\rfloor + 1\\right)\\)\r\nwhere \\(\\lfloor \\cdot \\rfloor\\) denotes\r\nthe floor function.\r\nThen let \\(M(i, j)\\) be the median\r\nof elements \\(S_2(i)\\) through \\(S_2(j)\\), inclusive. For example, \\(M(1, 10) = 2021.5\\) and \\(M(10^2, 10^3) = 4715.0\\).\r\nLet \\(F(n, k) = \\sum_{i=1}^{n-k+1} M(i, i +\r\nk - 1)\\). For example, \\(F(100, 10) =\r\n463628.5\\) and \\(F(10^5, 10^4) =\r\n675348207.5\\).\r\nFind \\(F(10^7, 10^5)\\). If the sum\r\nis not an integer, use \\(.5\\) to denote\r\na half. Otherwise, use \\(.0\\)\r\ninstead.\r\n解决方案\r\n令\\(N=10^7,M=10007,K=10^5\\)。\r\n计算出序列\\(S_2\\)后，那么问题只剩下计算出\\(M(i,i+K-1)\\)的值。由于\\(K\\)是偶数，因此我们需要计算出\\(S_2\\)的子数组\\(S_2[i:i+K-1]\\)中第\\(\\dfrac{K}{2},\\dfrac{K}{2}+1\\)大的值再将它们求平均值即可。这里将提供两种办法解决这个问题。\r\n第一种办法则是使用树状数组。树状数组的意义在于计算维护\\(s[i]\\)的值：小于等于\\(i\\)的数一共有多少个，它可以做到以\\(O(\\log\r\nM)\\)的时间复杂度维护好每一个长度为\\(K\\)的区间的数的数量。然后对树状数组进行二分，从而找到第\\(\\dfrac{K}{2},\\dfrac{K}{2}+1\\)大的值。单次计算操作需要\\(O(\\log^2 M)\\)的时间复杂度。\r\n第二种做法则是暴力维护两个多重集合sl, sr。sl用来存比较小的\\(\\dfrac{K}{2}\\)个数，sr用来存比较大的\\(\\dfrac{K}{2}\\)个数。最终sl的最大值和sr的最小值共同构成了这个最终中位数的值。单次操作的时间复杂度为\\(O(\\log k)\\)。\r\n然而，由于multiset本身操作的开销比较大。经过实验，虽然第一种做法的单次理论开销比较大，但是实践中它却远快于第二种做法。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;# define lb(i) ((i) &amp; -(i))# include &quot;tools.h&quot;using namespace std;typedef long long ll;const int N=1e7,K=1e5;const int M=10007;int s[N+4],s2[N+4];int t[M+M];void add(int p,int f)&#123;    for(int i=p;i&lt;M+M;i+=lb(i)) t[i]+=f;&#125;int que(int p)&#123;    int a=0;    for(int i=p;i;i-=lb(i)) a+=t[i];    return a;&#125;int que_rank(int k)&#123;    int l=1,r=M+M-1;    while(l&lt;r)&#123;        int mid=(l+r)&gt;&gt;1;        if(que(mid)&gt;=k) r=mid;        else l=mid+1;    &#125;    return l;&#125;int main()&#123;    vector&lt;int&gt;pr=get_prime_by_counts(N);    for(int i=1;i&lt;=N;i++)        s[i]=qpow(pr[i-1],i%(M-1),M);    for(int i=1;i&lt;=N;i++)        s2[i]=s[i]+s[i/10000+1];    for(int i=1;i&lt;K;i++)        add(s2[i],1);    ll sum=0;    for(int i=K;i&lt;=N;i++)&#123;        add(s2[i],1);        sum+=que_rank((K+1)&gt;&gt;1);        if(!(K&amp;1)) sum+=que_rank((K&gt;&gt;1)+1);        add(s2[i-K+1],-1);    &#125;    double ans=K&amp;1?sum:0.5*sum;    printf(&quot;%.1f\\n&quot;,ans);&#125;\r\n# include &lt;bits/stdc++.h&gt;# include &quot;tools.h&quot;using namespace std;typedef long long ll;const int N=1e7,K=1e5;const int M=10007;int s[N+4],s2[N+4];multiset&lt;int&gt;l,r;void balance()&#123;    while(l.size()&lt;r.size())&#123;        l.insert(*r.begin());r.erase(r.begin());    &#125;    while(l.size()&gt;r.size()+1)&#123;        r.insert(*l.rbegin());        auto it=l.end();        l.erase(--it);    &#125;&#125;void add(int x,int f)&#123;    if(f==1)&#123;        if(l.empty()||x&lt;=*l.rbegin()) l.insert(x);        else r.insert(x);    &#125;    else&#123;        auto it=l.find(x);        if(it!=l.end()) l.erase(it);        else r.erase(r.find(x));    &#125;    balance();&#125;int main()&#123;    vector&lt;int&gt;pr=get_prime_by_counts(N);    for(int i=1;i&lt;=N;i++)        s[i]=qpow(pr[i-1],i%(M-1),M);    for(int i=1;i&lt;=N;i++)        s2[i]=s[i]+s[i/10000+1];    for(int i=1;i&lt;K;i++)        l.insert(s2[i]);    balance();    ll sum=0;    for(int i=K;i&lt;=N;i++)&#123;        add(s2[i],1);        sum+=*l.rbegin();        if(!(K&amp;1)) sum+=*r.begin();        add(s2[i-K+1],-1);    &#125;    double ans=K&amp;1?sum:0.5*sum;    printf(&quot;%.1f\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["二分","树状数组"]},{"title":"Project Euler 577","url":"/project-euler/577/","content":"\r\nProject Euler 577\r\n题目\r\nCounting hexagons\r\nAn equilateral triangle with integer side length \\(n \\ge 3\\) is divided into \\(n^2\\) equilateral triangles with side\r\nlength \\(1\\) as shown in the diagram\r\nbelow.\r\nThe vertices of these triangles constitute a triangular lattice with\r\n\\(\\dfrac{(n+1)(n+2)} 2\\) lattice\r\npoints.\r\nLet \\(H(n)\\) be the number of all\r\nregular hexagons that can be found by connecting \\(6\\) of these points.\r\n\r\nFor example, \\(H(3)=1\\), \\(H(6)=12\\) and \\(H(20)=966\\).\r\nFind \\(\\displaystyle \\sum_{n=3}^{12345}\r\nH(n)\\).\r\n解决方案\r\n通过容斥原理，不难写成\\(H(n)=3H(n-1)-3H(n-2)+H(n-3)+F(n)\\)，其中\\(F(n)\\)是恰好能够镶嵌在边长为\\(n\\)的正三角形上的正六边形个数。\r\n并且，这些正六边形都只能镶嵌在边长为\\(3\\)的倍数的等边三角形上，如图：\r\n\r\n这是\\(n=9\\)种不同时的情况，\\(3\\)种颜色分别代表\\(3\\)个镶嵌的三角形。那么，当\\(n\\%3=0\\)时，\\(F(n)=\\dfrac{n}{3}\\)，否则\\(F(n)=0.\\)\r\n为了使得正六边形是镶嵌在边长为\\(n\\)的三角形中，那么这个正六边形中的六个顶点，逆时针顺序间隔的三个顶点分别在三角形的三条边上。假设间隔开的这三个顶点为\\(D,E,F\\)，原来的等边三角形三个顶点为\\(A,B,C\\)，那么必有\\(AD=BE=CF.\\)，然后等边三角形\\(DEF\\)每条边再向外扩展出一个顶角为\\(120°\\)的等腰三角形，那么新的三个顶点和原来的三个顶点将会形成一个正六边形。最终不难输出可以进行扩展的数量为\\(\\dfrac{n}{3}.\\)\r\n通过上面的递推式，在oeis中查找到相关序列为A011779。并且在PROG一栏发现如下信息：\r\n(PARI) a(n)=1/216 * n^4 + 1/12 * n^3 + 37/72 * n^2 + [5/4, 139/108, 131/108][1+n%3] * n + [1, 10/9, 7/9][1+n%3] \\\\ Yurii Ivanov, Jul 06 2021\r\n这直接给出了这个数列的通项公式，直接实现即可。\r\n代码\r\nN = 12345ans = 0for n in range(N - 2):    ans += (n ** 4 + 18 * n ** 3 + 111 * n ** 2 + [270 * n + 216, 278 * n + 240, 262 * n + 168][n % 3]) // 216print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 598","url":"/project-euler/598/","content":"\r\nProject Euler 598\r\n题目\r\nSplit Divisibilities\r\nConsider the number \\(48\\).\r\nThere are five pairs of integers \\(a\\) and \\(b\\) (\\(a \\leq\r\nb\\)) such that \\(a \\times b=48: (1,48),\r\n(2,24), (3,16), (4,12)\\) and \\((6,8)\\).\r\nIt can be seen that both \\(6\\) and\r\n\\(8\\) have \\(4\\) divisors.\r\nSo of those five pairs one consists of two integers with the same\r\nnumber of divisors.\r\nIn general: Let \\(C(n)\\) be the\r\nnumber of pairs of positive integers \\(a\r\n\\times b=n\\), (\\(a \\leq b\\))\r\nsuch that \\(a\\) and \\(b\\) have the same number of divisors; so\r\n\\(C(48)=1\\).\r\nYou are given \\(C(10!)=3: (1680, 2160),\r\n(1800, 2016)\\) and \\((1890,1920)\\).\r\nFind \\(C(100!)\\)\r\n解决方案\r\n令\\(n\\)的分解为\\(n=\\prod_{i=1}^k\r\np_i^{e_i}\\)，那么我们得到一个\\(k\\)维向量\\(\\vec{e}=[e_1,e_2,\\dots,e_k]\\)。根据因数个数定理\\(\\sigma_0(n)=\\prod_{i=1}^k(e_i+1)\\)，那么问题转化为如下形式：\r\n求有多少个\\(k\\)维向量\\(\\vec{a}\\)，满足以下条件：\r\n\r\n\\(\\forall i \\in [1,k],0\\le b_i\\le\r\ne_i\\)\r\n\\(\\prod_{i=1}^k\r\n(b_i+1)=\\prod_{i=1}^k(e_i-b_i+1)\\)，也就是\\(\\prod_{i=1}^k\\dfrac{b_i+1}{e_i-b_i+1}=1\\)\r\n\r\n可以发现，这些向量\\(b_i\\)和\\(n\\)的因子一一对应，因此最终答案就是这些向量个数的一半（注意还要考虑当\\(n\\)为平方数的情况）。\r\n那么不难想到一种朴素的做法：如果目前已经针对前\\(j\\)个质因子的指数暴力枚举，并且用字典存储统计得到的\\(v=\\prod_{i=1}^j\\dfrac{b_i+1}{e_i-b_i+1}\\)的方案个数。那么暴力枚举\\(b_{j+1}\\)和字典中的每个\\(v\\)，用新字典存储\\(v\\cdot\r\n\\dfrac{b_{j+1}+1}{e_{j+1}-b_{j+1}+1}\\)的个数。\r\n不过，这样直接暴力处理，之后字典产生的条目将会非常多，严重降低了效率。\r\n假设向量\\(\\vec{e}\\)已经降序排序，也就是\\(e_1\\ge e_2\\ge\\dots\\ge\r\ne_k\\)。由于我们最终需要求的\\(v\\)值是\\(1\\)，在计算完前\\(j\\)个项后，字典存储的\\(v\\)键都是以一个分数来表示。如果当前\\(v\\)的分子或者分母的最大质因数大于\\(e_{j+1}+1\\)，那么说明在后续操作中，这个最大质因子肯定不能被约掉，不能为最终\\(v=1\\)的情况做贡献，需要及时去除。\r\n经过如此操作后，字典的值将会省略掉一大部分，提高了效率。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;# define X first# define Y second# define lb(x) ((x) &amp; (-x))# define mem(a,b) memset(a,b,sizeof(a))# define debug freopen(&quot;r.txt&quot;,&quot;r&quot;,stdin)# define pi pair&lt;int,int&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const int N=100;struct Fraction&#123;    ll num,den;    Fraction(ll n=1,ll d=0)&#123;        ll g=__gcd(n,d);        num=n/g;den=d/g;    &#125;    Fraction operator + (Fraction f)&#123;        return Fraction(num*f.den+den*f.num,den*f.den);    &#125;    Fraction operator * (Fraction f)&#123;        return Fraction(num*f.num,den*f.den);    &#125;    Fraction inv()&#123;        return &#123;den,num&#125;;    &#125;    //这里的小于只是为了用于区分分数的不同，而并非是分数的值大小本身。    bool operator &lt; (const Fraction &amp;f) const&#123;        return num&lt;f.num||num==f.num&amp;&amp;den&lt;f.den;    &#125;&#125;;bool vis[N+4];int pr[N+4],m=0;int e[N+4];int cal(int n,int p)&#123;    int ans=0;    for(;n;n/=p) ans+=n/p;    return ans;&#125;int max_prime(ll n)&#123;    if(n==1) return -1;    int i;    for(i=1;i&lt;=m&amp;&amp;n!=1;)&#123;        if(n%pr[i]==0) n/=pr[i];        else ++i;    &#125;    return pr[i];&#125;map&lt;Fraction,ll&gt;mp[N+4];int main()&#123;    //freopen(&quot;w.txt&quot;,&quot;w&quot;,stdout);    for(int i=2;i&lt;=N;i++)&#123;        if(vis[i]) continue;        pr[++m]=i;        for(int j=i+i;j&lt;=N;j+=i)            vis[j]=1;    &#125;    for(int i=1;i&lt;=m;i++)        e[i]=cal(N,pr[i]);    for(int j=0;j&lt;=e[1];j++)        ++mp[1][Fraction(j+1,e[1]-j+1)];    for(int i=2;i&lt;m;i++)&#123;        for(int j=0;j&lt;=e[i];j++)&#123;            Fraction t(j+1,e[i]-j+1);            for(auto &amp;[k,v]:mp[i-1])&#123;                Fraction f=t*k;                if(max_prime(f.num)&lt;=e[i+1]+1&amp;&amp;max_prime(f.den)&lt;=e[i+1]+1)&#123;                    mp[i][f]+=v;                &#125;            &#125;        &#125;    &#125;    ll ans=0;    for(int j=0;j&lt;=e[m];j++)&#123;        ans+=mp[m-1][Fraction(j+1,e[m]-j+1)];    &#125;    ans&gt;&gt;=1;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 6","url":"/project-euler/6/","content":"\r\nProject Euler 6\r\n题目\r\nSum square difference\r\nThe sum of the squares of the first ten natural numbers is, \\[1^2 + 2^2 + ... + 10^2 = 385\\] The square\r\nof the sum of the first ten natural numbers is, \\[(1 + 2 + ... + 10)^2 = 55^2 = 3025\\] Hence\r\nthe difference between the sum of the squares of the first ten natural\r\nnumbers and the square of the sum is \\(3025 -\r\n385 = 2640\\).\r\nFind the difference between the sum of the squares of the first one\r\nhundred natural numbers and the square of the sum.\r\n解决方案\r\n两个公式：\r\n前\\(n\\)个数的平方和为\\(\\dfrac{n(n+1)(2n+1)}{6}\\).\r\n前\\(n\\)个数的和为\\(\\dfrac{n(n+1)}{2}\\).\r\n直接代入公式并计算。\r\n代码\r\nn = 100ans = (n * (n + 1) // 2) ** 2 - n * (n + 1) * (2 * n + 1) // 6print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 602","url":"/project-euler/602/","content":"\r\nProject Euler 602\r\n题目\r\nProduct of Head Counts\r\nAlice enlists the help of some friends to generate a random number,\r\nusing a single unfair coin. She and her friends sit around a table and,\r\nstarting with Alice, they take it in turns to toss the coin. Everyone\r\nkeeps a count of how many heads they obtain individually. The process\r\nends as soon as Alice obtains a Head. At this point, Alice multiplies\r\nall her friends’ Head counts together to obtain her random number.\r\nAs an illustration, suppose Alice is assisted by Bob, Charlie, and\r\nDawn, who are seated round the table in that order, and that they obtain\r\nthe sequence of Head/Tail outcomes THHH—TTTT—THHT—H\r\nbeginning and ending with Alice. Then Bob and Charlie each obtain \\(2\\) heads, and Dawn obtains \\(1\\) head. Alice’s random number is\r\ntherefore \\(2\\times 2\\times 1 =\r\n4\\).\r\nDefine \\(e(n, p)\\) to be the\r\nexpected value of Alice’s random number, where \\(n\\) is the number of friends helping\r\n(excluding Alice herself), and \\(p\\) is\r\nthe probability of the coin coming up Tails.\r\nIt turns out that, for any fixed \\(n\\), \\(e(n,\r\np)\\) is always a polynomial in \\(p\\). For example, \\(e(3, p) = p^3 + 4p^2 + p\\).\r\nDefine \\(c(n, k)\\) to be the\r\ncoefficient of \\(p^k\\) in the\r\npolynomial \\(e(n, p)\\). So \\(c(3, 1) = 1\\), \\(c(3, 2) = 4\\), and \\(c(3, 3) = 1\\).\r\nYou are given that \\(c(100, 40) \\equiv\r\n986699437 \\text{ } (\\text{mod } 10^9+7)\\).\r\nFind \\(c(10000000, 4000000) \\bmod\r\n10^9+7\\).\r\n解决方案\r\n不难直接写出关于\\(e(n,p)\\)的定义式：\r\n\\[\\begin{aligned}\r\ne(n,p)&amp;=\\sum_{k=1}^{\\infty} p^k \\cdot (1-p) \\cdot (k\\cdot (1-p))^n\\\\\r\n&amp;=\\sum_{k=1}^{\\infty} p^k \\cdot k^n\\cdot (1-p)^{n+1}\\\\\r\n&amp;=(1-p)^{n+1}\\cdot \\sum_{k=1}^{\\infty} p^k \\cdot k^n\r\n\\end{aligned}\\]\r\n其中，枚举变量\\(k\\)表示Alice已经连续抛出了\\(k\\)次反面，在第\\(k+1\\)次抛出了正面，游戏结束。而\\(k\\)个人分别是在做独立的伯努利实验，因此他们每一个人抛出正面的次数期望为\\(k\\cdot(1-p)\\)。\r\n那么根据二项式定理，左边可以展开成：\r\n\\[(1-p)^{n+1}=\\sum_{k=0}^{n+1} (-1)^k\\cdot\r\n\\dbinom{n+1}{k}p^k\\]\r\n和右边的多项式相乘，保留第\\(k\\)项的系数，因此有：\r\n\\[c(n,m)=\\sum_{k=0}^{m-1} (-1)^k\\cdot\r\n\\dbinom{n+1}{k} \\cdot (m-k)^n\\]\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=10000000,M=4000000;ll fac[N+4],finv[N+4],mod=1e9+7;ll qpow(ll n,ll m)&#123;    ll a=1;    for(;m;m&gt;&gt;=1)&#123;        if(m&amp;1) a=a*n%mod;        n=n*n%mod;    &#125;    return a;&#125;ll C(int n,int m)&#123;    return fac[n]*finv[n-m]%mod*finv[m]%mod;&#125;int main()&#123;    fac[0]=1;    for(int i=1;i&lt;=N+1;i++)&#123;        fac[i]=fac[i-1]*i%mod;    &#125;    finv[N+1]=qpow(fac[N+1],mod-2);    for(int i=N;i&gt;=0;i--)        finv[i]=finv[i+1]*(i+1)%mod;    ll ans=0;    for(int k=0,f=1;k&lt;M;k++,f=-f)        ans+=C(N+1,k)*qpow(M-k,N)*f%mod;    ans=(ans%mod+mod)%mod;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 60","url":"/project-euler/60/","content":"\r\nProject Euler 60\r\n题目\r\nPrime pair sets\r\nThe primes \\(3, 7, 109,\\) and \\(673\\), are quite remarkable. By taking any\r\ntwo primes and concatenating them in any order the result will always be\r\nprime. For example, taking \\(7\\) and\r\n\\(109\\), both \\(7109\\) and \\(1097\\) are prime. The sum of these four\r\nprimes, \\(792\\), represents the lowest\r\nsum for a set of four primes with this property.\r\nFind the lowest sum for a set of five primes for which any two primes\r\nconcatenate to produce another prime.\r\n解决方案\r\n本题的逼近上限难以通过分析方法计算出来，因此直接拟定一个上限，此处的上限定为\\(N=10^4\\)。\r\n这题可以从图论的角度上考虑简化。如果质数对\\((x,y)\\)满足题目条件，那么就将\\(x\\)和\\(y\\)连结一条边。\r\n那么，这个问题就转化为，在这张图上面找一个大小为\\(5\\)的团（团：无向图上的一个子图，但是这个子图是一个完全图。）\r\n在我没有了解过networkx库时，我写了第一份代码，它是直接深度优先搜索寻找一个大小为\\(5\\)的团，并且没有添加太多的优化，最终运行了约\\(8\\)秒。\r\n使用networkx的find_cliques函数，它可以找到图中的所有团。\r\n另外，寻找图的最大团的算法为Bron–Kerbosch\r\nalgorithm算法。networkx的find_cliques函数就是基于Bron-Kerbosch算法的迭代版本。\r\n代码\r\nfrom tools import get_prime, is_primeN = 10000M = 5pr = get_prime(N)n = len(pr)g = [[0 for i in range(n)] for j in range(n)]for i in range(n):    for j in range(i):        x, y = pr[i], pr[j]        u, v = int(str(x) + str(y)), int(str(y) + str(x))        if is_prime(u) and is_prime(v):            g[i][j] = g[j][i] = 1a = [0 for i in range(M)]ans = 0def dfs(p: int, f: int):    global ans    if f == M:        ans = sum([pr[x] for x in a])        return 1    while p &lt; n:        i = 0        while i &lt; f:            if g[a[i]][p] == 0:                break            i += 1        if i == f:            a[f] = p            if dfs(p + 1, f + 1):                return 1        p += 1    return 0dfs(0, 0)print(ans)\r\nfrom tools import get_prime, is_primeimport networkx as nxG = nx.Graph()N = 10000M = 5pr = get_prime(N)n = len(pr)for i in range(n):    for j in range(i):        x, y = pr[i], pr[j]        u, v = int(str(x) + str(y)), int(str(y) + str(x))        if is_prime(u) and is_prime(v):            G.add_edge(i, j)a = [b for b in nx.find_cliques(G) if len(b) == M]ans = min((sum(pr[x] for x in pos) for pos in a))print(ans)\r\n","categories":["Project Euler"],"tags":["图论"]},{"title":"Project Euler 601","url":"/project-euler/601/","content":"\r\nProject Euler 601\r\n题目\r\nDivisibility streaks\r\nFor every positive number \\(n\\) we\r\ndefine the function \\(\\text{streak}(n)=k\\) as the smallest\r\npositive integer \\(k\\) such that \\(n+k\\) is not divisible by \\(k+1\\).\r\nE.g: \\(13\\) is divisible by\r\n\\(1\\)  \\(14\\) is divisible by \\(2\\)  \\(15\\) is divisible by \\(3\\)  \\(16\\) is divisible by \\(4\\)  \\(17\\) is NOT divisible by \\(5\\)  So \\(\\text{streak}(13) = 4\\). \r\nSimilarly: \\(120\\) is\r\ndivisible by \\(1\\)  \\(121\\) is NOT divisible by \\(2\\)  So \\(\\text{streak}(120) = 1\\).\r\nDefine \\(P(s, N)\\) to be the number\r\nof integers \\(n\\), \\(1 &lt; n &lt; N\\), for which \\(\\text{streak}(n) = s\\).\r\nSo \\(P(3, 14) = 1\\) and \\(P(6, 10^6) = 14286\\).\r\nFind the sum, as \\(i\\) ranges from\r\n\\(1\\) to \\(31\\), of \\(P(i,\r\n4^i)\\).\r\n解决方案\r\n不难发现，\\(k+1\\mid\r\nn+k\\)当且仅当\\(k+1\\mid\r\nn-1\\)。\r\n那么根据\\(\\text{streak}(n)=k\\)就变成了，找到一个最小的\\(k\\)，使得\\(k+1\\nmid n-1\\)。这也就是说，所有\\(1,2,\\dots,k\\)都能整除\\(n-1\\)，但是\\(k+1\\)不行。\r\n可以知道，如果一个数\\(m\\)能够被\\(1,2,3,\\dots,k\\)整除，那么\\(\\text{lcm}(1,2,3,\\dots,k)\\mid m\\)。\r\n令函数\\(L(m)=\\text{lcm}(1,2,3,\\dots,m)\\)。\r\n那么不难确定，函数\\(P\\)的表达式为\r\n\\[P(s,N)=\\left\\lfloor\\dfrac{N-1}{L(s)}\\right\\rfloor-\\left\\lfloor\\dfrac{N-1}{L(s+1)}\\right\\rfloor-[s=1]\\]\r\n其中，\\([]\\)表示示性函数，表示\\([]\\)里面的值是否为真，如果为真，那么值为\\(1\\)，否则值为\\(0\\)。\r\n第一项则计算出了在\\(1\\sim\r\nN-1\\)中，有多少个数是\\(L(s)\\)的倍数，它们的\\(\\text{streak}\\)值大于等于\\(s\\)。第二项则减去\\(L(s+1)\\)的倍数，它们的\\(\\text{streak}\\)值大于等于\\(s+1\\)。那么剩下的数就确保了它们的\\(\\text{streak}\\)值为\\(s\\)。第三项则避免了\\(1\\)这个答案，以符合题目中的要求。\r\n代码\r\nfrom tools import lcmN = 31def P(s: int, n: int):    n -= 1    m = 1    for i in range(1, s + 1):        m = lcm(m, i)    c1 = n // m    if m == 1:        c1 -= 1    m = lcm(m, s + 1)    c2 = n // m    return c1 - c2ans = 0for i in range(1, N + 1):    ans += P(i, 4 ** i)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 59","url":"/project-euler/59/","content":"\r\nProject Euler 59\r\n题目\r\nXOR decryption\r\nEach character on a computer is assigned a unique code and the\r\npreferred standard is ASCII (American Standard Code for Information\r\nInterchange). For example, uppercase A = \\(65\\), asterisk (*) = \\(42\\), and lowercase k = \\(107\\).\r\nA modern encryption method is to take a text file, convert the bytes\r\nto ASCII, then XOR each byte with a given value, taken from a secret\r\nkey. The advantage with the XOR function is that using the same\r\nencryption key on the cipher text, restores the plain text; for example,\r\n\\(65\\ \\text{XOR}\\ 42 = 107\\), then\r\n\\(107\\ \\text{XOR}\\ 42 = 65\\).\r\nFor unbreakable encryption, the key is the same length as the plain\r\ntext message, and the key is made up of random bytes. The user would\r\nkeep the encrypted message and the encryption key in different\r\nlocations, and without both “halves”, it is impossible to decrypt the\r\nmessage.\r\nUnfortunately, this method is impractical for most users, so the\r\nmodified method is to use a password as a key. If the password is\r\nshorter than the message, which is likely, the key is repeated\r\ncyclically throughout the message. The balance for this method is using\r\na sufficiently long password key for security, but short enough to be\r\nmemorable.\r\nYour task has been made easy, as the encryption key consists of three\r\nlower case characters. Using cipher.txt (right click and\r\n‘Save Link/Target As…’), a file containing the encrypted ASCII codes,\r\nand the knowledge that the plain text must contain common English words,\r\ndecrypt the message and find the sum of the ASCII values in the original\r\ntext.\r\n解决方案\r\n在这种加密方式下，把密文的每个字符分成三份，第\\(i\\)个字符在第\\(i\\%3\\)份中，观察统计特性（取前四个最多的）。\r\n[(69, 86), (0, 62), (12, 34), (17, 32)][(88, 77), (29, 60), (12, 31), (11, 30)][(80, 103), (21, 42), (4, 40), (2, 29)]\r\n可以发现，某一个单一字符的密文使用的频率异常高，这是因为一篇英文文章中，有非常多数量的空格。可以认为，每一份的密文中，对应的密钥是空格的ACII码和频率最大的密文字符的异或值。\r\n找到密钥后，直接解密即可。\r\nNOTE: 本题所使用的密码学方案，是维吉尼亚密码的高级版本（维吉尼亚密码的基础版本是做\\(\\mathbb{Z_{26}}\\)上的模加法运算，而这里是做\\(\\{0,1\\}^7\\)上的异或运算），是一种基于多表密码的古典密码学方案。于19~20世纪被破译。\r\n代码\r\nfrom collections import CounterM = 3ls = [int(x) for x in open(&#x27;p059_cipher.txt&#x27;, &#x27;r&#x27;).readlines()[0].split(&#x27;,&#x27;)]counter_list = [Counter(ls[i::3]) for i in range(M)]# for v in counter_list:#     print(v.most_common(4))key = [counter_list[i].most_common(1)[0][0] ^ ord(&#x27; &#x27;) for i in range(M)]ans = 0for i in range(len(ls)):    ans += key[i % 3] ^ ls[i]print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 603","url":"/project-euler/603/","content":"\r\nProject Euler 603\r\n题目\r\nSubstring sums of prime\r\nconcatenations\r\nLet \\(S(n)\\) be the sum of all\r\ncontiguous integer-substrings that can be formed from the integer \\(n\\). The substrings need not be\r\ndistinct.\r\nFor example, \\(S(2024) = 2 + 0 + 2 + 4 + 20\r\n+ 02 + 24 + 202 + 024 + 2024 = 2304\\).\r\nLet \\(P(n)\\) be the integer formed\r\nby concatenating the first \\(n\\) primes\r\ntogether. For example, \\(P(7) =\r\n2357111317\\).\r\nLet \\(C(n, k)\\) be the integer\r\nformed by concatenating \\(k\\) copies of\r\n\\(P(n)\\) together. For example, \\(C(7, 3) =\r\n235711131723571113172357111317\\).\r\nEvaluate \\(S(C(10^6, 10^{12})) \\bmod (10^9\r\n+ 7)\\).\r\n解决方案\r\n先考虑以线性时间计算\\(S(n)\\)。\r\n将\\(n\\)看成是一个长度为\\(m\\)的字符串\\(n=s_0s_1s_2\\dots s_{m-1}s_m\\)。考虑第\\(i\\)个字符\\(s_i\\)，它对答案\\(S(n)\\)的贡献值为\\((i+1)\\cdot s_i\\cdot\r\n\\dfrac{10^{m-i}-1}{9}\\)。因为以\\(s_i\\)为结尾的字符串一共有\\((i+1)\\)个，以\\(s_i\\)为开头，\\(s_j(i\\le j&lt;\r\nm)\\)的字符串将会对答案贡献\\(10^{j-i}\\)。包含\\(s_i\\)的\\((i+1)(n-i)\\)个字符串对这两个步骤是独立的，因此最终答案为\\(\\displaystyle{S(n)=\\sum_{i=0}^{m-1}(i+1)\\cdot\r\ns_i\\cdot\\dfrac{10^{m-i}-1}{9}}\\)。\r\n对于一个长度为\\(m\\)的整数\\(n\\)被拼接\\(k\\)次后的整数\\(n&#39;\\)，其长度为\\(mk\\)，并且有\\(s&#39;_i=s&#39;_{i+m}=s&#39;_{i+2m}=\\dots=s&#39;_{i+(k-1)m}\\)。因此其结果为\r\n\\(\\begin{aligned}\r\n&amp;\\sum_{i=0}^{m-1}\\sum_{j=0}^{k-1}(i+jm+1)\\cdot s_i\\cdot\r\n\\dfrac{10^{mk-(i+jm)}-1}{9}\\\\\r\n=&amp;\\sum_{i=0}^{m-1} \\dfrac{s_i}{9}\\sum_{j=0}^{k-1}(i+jm+1)\\cdot\r\n(10^{mk-(i+jm)}-1)\\\\\r\n=&amp;\\sum_{i=0}^{m-1}\r\n\\dfrac{s_i}{9}\\left(-(i+1)k-\\dfrac{(k-1)km}{2}+\\sum_{j=0}^{k-1}(i+jm+1)\\cdot\r\n10^{mk-(i+jm)}\\right)\\\\\r\n=&amp;\\sum_{i=0}^{m-1}\r\n\\dfrac{s_i}{9}\\left(-(i+1)k-\\dfrac{(k-1)km}{2}+\\dfrac{10^{m-i}\r\n((i+1)uv+m (v-ku))}{u^2}\\right)\r\n\\end{aligned}\\)\r\n其中\\(u=10^m-1,v=10^{km}-1\\)。\r\n最终直接暴力计算出上面的求和式结果即可，前\\(10^6\\)个质数直接通过筛法获得。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;# include &quot;tools.h&quot;using namespace std;typedef long long ll;const int N=1000000;ll K=1e12;ll mod=1e9+7;vector&lt;int&gt;s;int main()&#123;    int p=0;    for(int i=0;i&lt;N;i++)&#123;        p=next_prime(p);        int pre=s.size();        for(int m=p;m;m/=10)            s.push_back(m%10);        reverse(s.begin()+pre,s.end());    &#125;    int m=s.size();    ll inv_2=mod_inverse(2,mod);    ll inv_9=mod_inverse(9,mod);    ll inv_10=mod_inverse(10,mod);    ll pw10m=qpow(10,m,mod);    ll u=(pw10m+mod-1)%mod;    ll v=(qpow(pw10m,K,mod)+mod-1)%mod;    ll inv_u2=mod_inverse(u*u%mod,mod);    ll b=(K-1)%mod*(K%mod)%mod*m%mod*inv_2%mod;    ll ans=0;    for(ll i=0,t=pw10m;i&lt;m;i++,t=t*inv_10%mod)&#123;        ll a=K%mod*(i+1)%mod;        ll c=t*((i+1)*u%mod*v%mod+m*(v-K%mod*u%mod+mod)%mod)%mod*inv_u2%mod;        ans=(ans+inv_9*s[i]%mod*(c-a-b+mod+mod))%mod;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 607","url":"/project-euler/607/","content":"\r\nProject Euler 607\r\n题目\r\nMarsh Crossing\r\nFrodo and Sam need to travel \\(100\\)\r\nleagues due East from point \\(A\\) to\r\npoint \\(B\\). On normal terrain, they\r\ncan cover \\(10\\) leagues per day, and\r\nso the journey would take \\(10\\) days.\r\nHowever, their path is crossed by a long marsh which runs exactly\r\nSouth-West to North-East, and walking through the marsh will slow them\r\ndown. The marsh is \\(50\\) leagues wide\r\nat all points, and the mid-point of \\(AB\\) is located in the middle of the marsh.\r\nA map of the region is shown in the diagram below:\r\n\r\nThe marsh consists of \\(5\\) distinct\r\nregions, each \\(10\\) leagues across, as\r\nshown by the shading in the map. The strip closest to point \\(A\\) is relatively light marsh, and can be\r\ncrossed at a speed of \\(9\\) leagues per\r\nday. However, each strip becomes progressively harder to navigate, the\r\nspeeds going down to \\(8, 7, 6\\) and\r\nfinally \\(5\\) leagues per day for the\r\nfinal region of marsh, before it ends and the terrain becomes easier\r\nagain, with the speed going back to \\(10\\) leagues per day.\r\nIf Frodo and Sam were to head directly East for point \\(B\\), they would travel exactly \\(100\\) leagues, and the journey would take\r\napproximately \\(13.4738\\) days.\r\nHowever, this time can be shortened if they deviate from the direct\r\npath.\r\nFind the shortest possible time required to travel from point \\(A\\) to \\(B\\), and give your answer in days, rounded\r\nto \\(10\\) decimal places.\r\n折射定律/斯涅尔定律(Snell’s\r\nLaw)\r\n费马原理\r\n费马原理，法国科学家皮埃尔·德·费马在1662年提出：光传播的路径是光程取极值的路径。这个极值可能是最大值、最小值，甚至是函数的拐点。最初提出时，又名“最短时间原理”：光线传播的路径是需时最少的路径。由费马原理可以导出斯涅尔定律。\r\n折射定律\r\n斯涅尔定律，假设光在介质1传播的速率为\\(v_1\\)，在介质2的传播速率为\\(v_2\\)。那么介质1的折射率为\\(n_1=\\frac{c}{v_1}\\)，介质2的折射率为\\(n_2=\\frac{c}{v_2}\\)，其中\\(c\\)为光速。\r\n光线从介质1在某一点\\(O\\)传播进入介质2，\\(\\theta_1\\)为入射角，\\(\\theta_2\\)为折射角。\r\n那么有折射定律：\r\n\\[n_1\\sin\r\n\\theta_1=n_2\\sin\\theta_2\\]\r\n解决方案\r\n由于此时需要从\\(A\\)到\\(B\\)的时间最短，并且各沼泽段的行走速度不一样。可以将各沼泽段分别视为“介质”，对应的行走速度视为光的传播速率，然后根据斯涅尔定律，一束“光”从A射向B，计算其最短时间即可。\r\n本代码使用二分法确定“入射角”，此时判断的是“光”最终射向点B的左侧还是右侧，并且在过程中计算“光程”。\r\n代码\r\nfrom math import sin, pis = d = 100 / 2 ** 0.5v = [10, 9, 8, 7, 6, 5, 10]dis = [(d - 50) / 2, 10, 10, 10, 10, 10, (d - 50) / 2]l, r = 0, pi / 2ans = 0for _ in range(100):    mid = 0.5 * (l + r)    sinv = [sin(mid)]    for i in range(1, len(v)):        sinv.append(sinv[0] / v[0] * v[i])    tm = 0    len_x = 0    for i in range(len(v)):        sin_val = sinv[i]        cos_val = (1 - sin_val ** 2) ** 0.5        tan_val = sin_val / cos_val        d = dis[i] / cos_val        tm += d / v[i]        len_x += dis[i] * tan_val    if len_x &lt; s:        l = mid    else:        r = mid    ans = tmprint(&quot;&#123;:.10f&#125;&quot;.format(ans))\r\n","categories":["Project Euler"]},{"title":"Project Euler 609","url":"/project-euler/609/","content":"\r\nProject Euler 609\r\n题目\r\n\\(\\pi\\)\r\nsequences\r\nFor every \\(n \\ge 1\\) the\r\nprime-counting function \\(\\pi(n)\\) is equal to the number of primes\r\nnot exceeding \\(n\\).\r\nE.g. \\(\\pi(6)=3\\) and \\(\\pi(100)=25\\).\r\nWe say that a sequence of integers \\(u  =\r\n(u_0,\\cdots,u_m)\\) is a \\(\\pi\\) sequence if\r\n\r\n\\(u_n \\ge 1\\) for every \\(n\\)\r\n\\(u_{n+1}= \\pi(u_n)\\)\r\n\\(u\\) has two or more elements\r\n\r\nFor \\(u_0=10\\) there are three\r\ndistinct \\(\\pi\\) sequences: \\((10,4),  (10,4,2)\\) and \\((10,4,2,1)\\).\r\nLet \\(c(u)\\) be the number of\r\nelements of \\(u\\) that are not\r\nprime.\r\nLet \\(p(n,k)\\) be the number of\r\n\\(\\pi\\) sequences \\(u\\) for which \\(u_0\\le n\\) and \\(c(u)=k\\).\r\nLet \\(P(n)\\) be the product of all\r\n\\(p(n,k)\\) that are larger than \\(0\\).\r\nYou are given: \\(P(10)=3\\times8\\times9\\times3=648\\) and\r\n\\(P(100)=31038676032\\).\r\nFind \\(P(10^8)\\). Give your answer\r\nmodulo \\(1000000007\\).\r\n解决方案\r\n利用线性筛生成所有质数，并直接计算出函数\\(\\pi\\)的值。\\(u\\)序列直接通过迭代\\(\\pi\\)值产生。\r\n注意到，对于相邻两个质数\\(p,q\\)，发现\\(\\pi(p)=\\pi(p+1)=\\pi(p+2)=\\dots=\\pi(q-1)\\)。因此，同时处理开头为\\(p\\sim q-1\\)的\\(u\\)序列。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=100000000;const int M=4*log2(N+4);int s[N+4];int v[N+4],pr[N+4],m=0;int cnt[M+4];ll mod=1e9+7;int main()&#123;    for(int i=2;i&lt;=N;i++)&#123;        if(v[i]==0) v[i]=i,pr[++m]=i;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;N/i) break;            v[i*pr[j]]=pr[j];        &#125;        s[i]=s[i-1]+(v[i]==i);    &#125;    for(int i=1;i&lt;=m;i++)&#123;        int l=pr[i],r=(i==m?N:pr[i+1]-1);        int c=0;        for(int j=s[l];j;j=s[j])&#123;            if(v[j]!=j) ++c;            cnt[c+1]+=r-l;            ++cnt[c];            if(j==1) break;        &#125;    &#125;    ll ans=1;    for(int j=0;j&lt;=M;j++)        if(cnt[j]&gt;0) ans=ans*cnt[j]%mod;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 61","url":"/project-euler/61/","content":"\r\nProject Euler 61\r\n题目\r\nCyclical figurate numbers\r\nTriangle, square, pentagonal, hexagonal, heptagonal, and octagonal\r\nnumbers are all figurate (polygonal) numbers and are generated by the\r\nfollowing formulae:\r\n\r\n\r\n\r\nTriangle\r\n\\(P_{3,n}=\\dfrac{n(n+1)}{2}\\)\r\n\\(1, 3, 6, 10, 15, \\dots\\)\r\n\r\n\r\nSquare\r\n\\(P_{4,n}=n^2\\)\r\n\\(1, 4, 9, 16, 25, \\dots\\)\r\n\r\n\r\nPentagonal\r\n\\(P_{5,n}=\\dfrac{n(3n−1)}{2}\\)\r\n\\(1, 5, 12, 22, 35, \\dots\\)\r\n\r\n\r\nHexagonal\r\n\\(P_{6,n}=n(2n−1)\\)\r\n\\(1, 6, 15, 28, 45, \\dots\\)\r\n\r\n\r\nHeptagonal\r\n\\(P_{7,n}=\\dfrac{n(5n−3)}{2}\\)\r\n\\(1, 7, 18, 34, 55, \\dots\\)\r\n\r\n\r\nOctagonal\r\n\\(P_{8,n}=n(3n−2)\\)\r\n\\(1, 8, 21, 40, 65, \\dots\\)\r\n\r\n\r\n\r\nThe ordered set of three \\(4\\)-digit\r\nnumbers: \\(8128, 2882, 8281\\), has\r\nthree interesting properties.\r\n\r\nThe set is cyclic, in that the last two digits of each number is the\r\nfirst two digits of the next number (including the last number with the\r\nfirst).\r\nEach polygonal type: triangle (\\(P_{3,127}=8128\\)), square (\\(P_{4,91}=8281\\)), and pentagonal (\\(P_{5,44}=2882\\)), is represented by a\r\ndifferent number in the set.\r\nThis is the only set of \\(4\\)-digit\r\nnumbers with this property.\r\n\r\nFind the sum of the only ordered set of six cyclic \\(4\\)-digit numbers for which each polygonal\r\ntype: triangle, square, pentagonal, hexagonal, heptagonal, and\r\noctagonal, is represented by a different number in the set.\r\n解决方案\r\n以题目中的例子\\(8128, 2882,\r\n8281\\)说明。\r\n先将\\(6\\)个公式中的每一个\\(4\\)位数拆分成两块，如\\([(81,28),(28,82),(82,81)]\\)，然后用前一块对应后一块的列表进行存储。\r\n用二进制状态压缩递推（动态规划进行存储）。状态\\(f(s,i,j),(0&lt;s&lt;2^6,0\\le i,j&lt;\r\n100)\\)表示在使用了一部分的公式下（用\\(6\\)比特的\\(s\\)表示），序列第一项的前一块为\\(i\\)，最后一项的后一块为\\(j\\)的情况下，整个序列里面前面一块的和。\r\n序列里所有元素前面一块之和乘\\(101\\)就是答案。如\\((81+28+82)\\times 101\\).\r\n由于这个序列是环形的，因此一开始先假设第\\(0\\)个公式被使用了。因此，状态值\\(s\\)第\\(0\\)比特为\\(0\\)时，视为不合法状态。\r\n最后答案为\\(f(2^6-1,i,i)\\times\r\n101\\)。其中\\(f(2^6-1,i,i)&gt;0,0\\leq i\r\n&lt; 100\\)。\r\n具体的转移过程请参考代码。\r\n代码\r\nN = 100M = 6O = 4# 一个数4位数拆分成两块，前两位一块，后两位一块。如果第i个式子中的四位数可以表示成100x+y，那么y在列表g[i][x]中。g = [[[] for j in range(N)] for i in range(6)]# f[s][i][j]：s是一个状态位，i是一开始的2位，j是当前序列的最后2位。表示当前状态下，所用到的前面一块的和。f = [[[-1 for j in range(N)] for k in range(N)] for i in range(1 &lt;&lt; M)]def add(p: int, m: int):    if len(str(m)) == O:        g[p][m // N].append(m % N)for i in range(N * N):    add(0, i * (i + 1) // 2)    add(1, i * i)    add(2, i * (3 * i - 1) // 2)    add(3, i * (2 * i - 1))    add(4, i * (5 * i - 3) // 2)    add(5, i * (3 * i - 2))for x in range(N):    for y in g[0][x]:        f[1][x][y] = xfor st in range(1, 1 &lt;&lt; M, 2):    for j in range(N):        for k in range(N):            if f[st][j][k] == -1:                continue            for p in range(M):                if st &gt;&gt; p &amp; 1:                    continue                for y in g[p][k]:                    f[st | 1 &lt;&lt; p][j][y] = f[st][j][k] + kans = max(f[(1 &lt;&lt; M) - 1][i][i] for i in range(N)) * 101print(ans)\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 613","url":"/project-euler/613/","content":"\r\nProject Euler 613\r\n题目\r\nPythagorean Ant\r\nDave is doing his homework on the balcony and, preparing a\r\npresentation about Pythagorean triangles, has just cut out a triangle\r\nwith side lengths 30cm, 40cm and 50cm from some cardboard, when a gust\r\nof wind blows the triangle down into the garden. Another gust blows a\r\nsmall ant straight onto this triangle. The poor ant is completely\r\ndisoriented and starts to crawl straight ahead in random direction in\r\norder to get back into the grass.\r\nAssuming that all possible positions of the ant within the triangle\r\nand all possible directions of moving on are equiprobable, what is the\r\nprobability that the ant leaves the triangle along its longest side?\r\nGive your answer rounded to 10 digits after the decimal point.\r\n解决方案\r\n建立一个\\(Rt\\triangle\r\nAOB\\)，其中\\(A(0,y_0),B(x_0,0)\\)。\r\n\r\n假设\\(Rt\\triangle\r\nABC\\)内任意一点\\(P(x,y)\\)，那么从\\(P\\)移动到最长边的概率为\\(\\angle APB\\)占整个\\(2\\pi\\)的比率。通过向量内积，可以直接计算出这个比率的值：\r\n\\[p(x,y)=\\frac{1}{2\\pi}\\cos^{-1}\r\n\\frac{x^2+y^2-xx_0-yy_0}{\\sqrt{(x_0-x)^2+y^2}\\cdot\\sqrt{x^2+(y_0-y)^2}}\\]\r\n那么，根据题意，可以直接计算以下二重积分的值：\r\n\\[I=\\int_0^{x_0}\\int_0^{y_0-\\frac{y_0}{x_0}}p(x,y)dydx\\]\r\n并将三角形的面积归一化，最终答案为：\r\n\\[P=\\frac{2}{x_0y_0}I\\]\r\n代码\r\nfrom math import acos, pifrom scipy.integrate import dblquadx0 = 30y0 = 40ans, err = dblquad(    lambda y, x: acos((x * x + y * y - x * x0 - y * y0)     / ((x0 - x) ** 2 + y ** 2) ** 0.5 / ((y0 - y) ** 2 + x ** 2) ** 0.5) / (2 * pi),    # y的上下限    0, x0,    # x的上下限    0, lambda x: y0 - y0 / x0 * x)ans /= x0 * y0 / 2print(&quot;&#123;:.10f&#125;&quot;.format(ans))# 答案是1/2-(a/4pib)*log((a^2+b^2)/a^2)-(b/4pia)*log((a^2+b^2)/b^2)\r\n","categories":["Project Euler"]},{"title":"Project Euler 612","url":"/project-euler/612/","content":"\r\nProject Euler 612\r\n题目\r\nFriend numbers\r\nLet’s call two numbers friend numbers if their\r\nrepresentation in base \\(10\\) has at\r\nleast one common digit.\r\nE.g. \\(1123\\) and \\(3981\\) are friend numbers.\r\nLet \\(f(n)\\) be the number of pairs\r\n\\((p,q)\\) with \\(1\\le p \\lt q \\lt n\\) such that \\(p\\) and \\(q\\) are friend numbers.\r\n\\(f(100)=1539\\).\r\nFind \\(f(10^{18}) \\bmod\r\n1000267129\\).\r\n解决方案\r\n令\\(N=18\\)。考虑使用容斥原理完成。\r\n用一个\\(10\\)位二进制数\\(d=d_9d_8\\dots d_0\\)表示一个数\\(n\\)，\\(0,1,2,\\dots9\\)中哪些数位出现了。如果\\(n\\)中有数位\\(i\\)，那么\\(d_i=1\\)，否则为\\(0\\)。\r\n从\\(1\\)到\\(2^{10}-1\\)枚举这个十位二进制数\\(d\\)，假设\\(1(d)\\)为\\(d\\)这个数中\\(1\\)比特的个数。那么令\\(f(d)\\)表示\\(1\\sim\r\n10^{N}-1\\)这些数中，有多少个数，其所有数位使用的数都在\\(d\\)中表示为\\(1\\)（也就是说，就算\\(d_k=1\\)，这些数的数位中也不一定含有数位\\(k\\)）。那么有：\r\n\\[\r\nf(d)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;\\sum_{n=1}^N (1(d))^n &amp; &amp; \\text{if}\\quad  d_0=0 \\\\\r\n  &amp;\\sum_{n=1}^N (1(d))^{n-1} \\cdot(1(d)-1) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n这是因为，\\(0\\)不能放在最高位，而其他数字都可以任意填充。\r\n接下来，令\\(g(d)\\)表示\\(1\\sim\r\n10^{N}-1\\)这些数中，有多少个数，其数位出现的情况表示为\\(d\\)（比\\(f\\)严格，\\(d_k=1\\)当且仅当数中含有数位\\(k\\)）。那么，通过容斥原理可以写出：\r\n\\[g(d)=\\sum_{m\\&amp;d=m}(-1)^{1(d)-1(m)}f(m)\\]\r\n也就是说，一开始先将\\(f(d)\\)的全部情况记入\\(g(d)\\)，再将缺某一个数位的从\\(g(d)\\)减去，接下来再将缺两个数位的再加回去，因为多减了……\r\n那么，只要将任意一对不含有相同数位的二元组减去，阿么剩下的都是友好数对。因此最终答案为：\r\n\\[\\dfrac{(10^N-1)(10^N-2)}{2}-\\sum_{i&lt;j,i\\&amp;j=0}\r\ng(i)\\cdot g(j)\\]\r\n代码\r\nN = 18D = 10mod = 1000267129f = [0 for _ in range(1 &lt;&lt; D)]ones = [bin(i).count(&#x27;1&#x27;) for i in range(1 &lt;&lt; D)]for s in range(1, 1 &lt;&lt; D):    for i in range(1, N + 1):        if s &amp; 1:            f[s] += (ones[s] - 1) * (ones[s] ** (i - 1))        else:            f[s] += ones[s] ** ifor s in range((1 &lt;&lt; D) - 1, -1, -1):    for k in range(s):        if (k &amp; s) == k:            if (ones[s] - ones[k]) &amp; 1:                f[s] -= f[k]            else:                f[s] += f[k]ans = (10 ** N - 1) * (10 ** N - 2) // 2for i in range(1 &lt;&lt; D):    for j in range(i):        if (i &amp; j) == 0:            ans -= f[i] * f[j]ans %= modprint(ans)\r\n","categories":["Project Euler"],"tags":["容斥原理"]},{"title":"Project Euler 62","url":"/project-euler/62/","content":"\r\nProject Euler 62\r\n题目\r\nCubic permutations\r\nThe cube, \\(41063625\\) (\\(345^3\\)), can be permuted to produce two\r\nother cubes: \\(56623104\\) (\\(384^3\\)) and \\(66430125\\) (\\(405^3\\)). In fact, \\(41063625\\) is the smallest cube which has\r\nexactly three permutations of its digits which are also cube.\r\nFind the smallest cube for which exactly five permutations of its\r\ndigits are cube.\r\n解决方案\r\n从小到大找出立方数。将使用数位的立方数汇总到一起。\r\n如果其中一个集合先汇总了\\(5\\)个立方数，那么就输出最小的。\r\n代码\r\nfrom itertools import countN = 5mp = &#123;&#125;for i in count(1, 1):    u = &quot;&quot;.join((lambda x: (x.sort(), x)[1])(list(str(i * i * i))))    if u not in mp.keys():        mp[u] = []    mp[u].append(i * i * i)    if len(mp[u]) == N:        ans = mp[u][0]        breakprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 622","url":"/project-euler/622/","content":"\r\nProject Euler 622\r\n题目\r\nRiffle Shuffles\r\nA riffle shuffle is executed as follows: a deck of cards is split\r\ninto two equal halves, with the top half taken in the left hand and the\r\nbottom half taken in the right hand. Next, the cards are interleaved\r\nexactly, with the top card in the right half inserted just after the top\r\ncard in the left half, the \\(2\\text{nd}\\) card in the right half just\r\nafter the \\(2\\text{nd}\\) card in the\r\nleft half, etc. (Note that this process preserves the location of the\r\ntop and bottom card of the deck)\r\nLet \\(s(n)\\) be the minimum number\r\nof consecutive riffle shuffles needed to restore a deck of size \\(n\\) to its original configuration, where\r\n\\(n\\) is a positive even number.\r\nAmazingly, a standard deck of \\(52\\)\r\ncards will first return to its original configuration after only \\(8\\) perfect shuffles, so \\(s(52) = 8\\). It can be verified that a deck\r\nof \\(86\\) cards will also return to its\r\noriginal configuration after exactly \\(8\\) shuffles, and the sum of all values of\r\n\\(n\\) that satisfy \\(s(n) = 8\\) is \\(412\\).\r\nFind the sum of all values of \\(n\\)\r\nthat satisfy \\(s(n) = 60\\).\r\n解决方案\r\n结论：洗\\(2n\\)张牌，恢复到原来的步骤数等于元素\\(2\\)在群\\(\\mathbb{Z}_{2n-1}^{\\ast}\\)上的阶\\(\\lambda_{2n-1}(2)\\)。\r\n说明：将\\(2n\\)张牌从小到大标记成数字\\(0\\sim 2n-1\\)，牌的位置也标记成\\(0\\sim 2n-1\\)，那么洗完一次牌后，第\\(0&lt;i&lt;n\\)张牌的位置将会到达\\(2i\\)。因为第\\(i\\)张牌前面都多了\\(i\\)张右边的牌。而第\\(n\\le j&lt;2n-1\\)张牌就到达了第\\(2j\\%(2n-1)\\)的位置。\r\n因此综上所述，第\\(i\\)张一轮完成后就到达了位置\\(2i\\%(2n-1)\\)，两轮完成后就是位置\\(2\\cdot 2i\\%(2n-1)\\)，三轮完成后就是\\(2^3i\\%(2n-1)\\)……\\(k\\)轮完成后就是\\(2^ki\\%(2n-1)\\)。因此，最终所有牌如果需要回到原来的位置，那么洗牌的最小轮数\\(k\\)就必须满足\\(2^k\\equiv1 \\pmod {2n-1}\\)，也就是元素\\(2\\)在群\\(\\mathbb{Z}_{2n-1}^{\\ast}\\)上的阶\\(\\lambda_{2n-1}(2)\\)。这说明\\(2n-1\\mid 2^k-1\\).\r\n令\\(N=60\\)。那么这我们可以枚举出\\(2^N-1\\)的所有因数\\(d\\)，然后再进一步判断\\(\\lambda_{d}(2)\\)的值是否为\\(N\\)即可。如果是\\(N\\)，那么\\(d+1\\)就为所需要的答案。\r\n代码\r\nfrom sympy import n_orderfrom tools import divisorsN = 60ans = sum((d+1) for d in divisors(2 ** N - 1) if n_order(2, d) == N)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 624","url":"/project-euler/624/","content":"\r\nProject Euler 624\r\n题目\r\nTwo heads are better than\r\none\r\nAn unbiased coin is tossed repeatedly until two consecutive heads are\r\nobtained. Suppose these occur on the \\((M-1)\\text{th}\\) and \\(M\\text{th}\\) toss.\r\nLet \\(P(n)\\) be the probability that\r\n\\(M\\) is divisible by \\(n\\). For example, the outcomes HH, HTHH,\r\nand THTTHH all count towards \\(P(2)\\),\r\nbut THH and HTTHH do not.\r\nYou are given that \\(P(2) =\\frac 3\r\n5\\) and \\(P(3)=\\frac 9  {31}\\).\r\nIndeed, it can be shown that \\(P(n)\\)\r\nis always a rational number.\r\nFor a prime \\(p\\) and a fully\r\nreduced fraction \\(\\frac a b\\), define\r\n\\(Q(\\frac a b,p)\\) to be the smallest\r\npositive \\(q\\) for which \\(a \\equiv b q \\pmod{p}\\). For example \\(Q(P(2), 109) = Q(\\frac 3 5, 109) = 66\\),\r\nbecause \\(5 \\cdot 66 = 330 \\equiv 3\r\n\\pmod{109}\\) and \\(66\\) is the\r\nsmallest positive such number.\r\nSimilarly \\(Q(P(3),109) = 46\\).\r\nFind \\(Q(P(10^{18}),1\\,000\\,000\\,009)\\).\r\n解决方案\r\n令\\(N=10^{18}\\)。使用马尔科夫链来考虑本问题。\r\n这个马尔科夫链一共有\\(3\\)个状态：\\(0,1,2\\)。其中第\\(i\\)个状态表示硬币已经连续抛出了两次正面。\r\n不过实际上，由于状态\\(2\\)在正式计算之前都不计入，因此我们接下来实际计算时抛弃了状态\\(2\\)，直到第\\(M-1\\)步时，我们再假设进入了状态\\(2\\)。那么可以写出如下状态转移矩阵：\r\n\\[\r\nA=\r\n\\begin{bmatrix}\r\n0.5 &amp;0.5\\\\\r\n0.5 &amp;0\r\n\\end{bmatrix}\r\n\\]\r\n其中第\\(i\\)行第\\(j\\)列表示从状态\\(i\\)转移到状态\\(j\\)的概率。\r\n令列向量\\(b=(1,0)^T\\)。因为一开始在状态\\(0\\)。那么列向量\\(b_k=A^kb\\)就表示进行了\\(k\\)步转移后，处在每一个状态的概率分布情况。\r\n将\\(b_k\\)向量的计算过程进一步改写，得：\r\n\\[\r\nb_k=A^kb=\\begin{bmatrix}\r\n0.5 &amp;0.5\\\\\r\n0.5 &amp;0\r\n\\end{bmatrix}^kb=\\dfrac{1}{2^k}\r\n\\begin{bmatrix}\r\n1 &amp;1\\\\\r\n1 &amp;0\r\n\\end{bmatrix}\\cdot b\\]\r\n通过经验发现，这个矩阵是计算斐波那契数列\\(a_0=0,a_1=1,a_n=a_{n-1}+a_{n-2},n\\ge\r\n2\\)的矩阵形式。列向量\\(b_k\\)的第二维恰好是\\(\\dfrac{a_k}{2^k}\\).\r\n令\\(\\phi_{+}=\\dfrac{1+\\sqrt{5}}{2},\\phi_{-}=\\dfrac{1-\\sqrt{5}}{2}\\)。\r\n假设\\(g(k)\\)表示经过\\(k\\)轮后，首次到达状态\\(2\\)的概率值。那么可以写出：\r\n\\[g(k)=\\dfrac{1}{2}\\cdot\r\n\\dfrac{a_{k-1}}{2^{k-1}}=\\dfrac{1}{2\\sqrt{5}}\\left(\\left(\\dfrac{\\phi_{+}}{2}\\right)^{k-1}\r\n-\\left(\\dfrac{\\phi_{-}}{2}\\right)^{k-1}\\right)\\]\r\n其中不难知道为\\(a_n=\\dfrac{1}{\\sqrt{5}}(\\phi_{+}^{n}\r\n-\\phi_{-}^n)\\).\r\n那么根据定义可以得到：\r\n\\[\\begin{aligned}\r\nP(n)&amp;=\\sum_{k=1}^{+\\infty} g(nk)=\\sum_{k=1}^{+\\infty}\r\n\\dfrac{1}{2\\sqrt{5}}\\left(\\left(\\dfrac{\\phi_{+}}{2}\\right)^{nk-1}\r\n-\\left(\\dfrac{\\phi_{-}}{2}\\right)^{nk-1}\\right) \\\\\r\n&amp;=\\dfrac{1}{2\\sqrt{5}}\\cdot\r\n\\left(\\dfrac{\\left(\\dfrac{\\phi_{+}}{2}\\right)^{n-1}}{1-\\left(\\dfrac{\\phi_{+}}{2}\\right)^n}-\\dfrac{\\left(\\dfrac{\\phi_{-}}{2}\\right)^{n-1}}{1-\\left(\\dfrac{\\phi_{-}}{2}\\right)^n}\\right)&amp;\\qquad(1)\\\\\r\n&amp;=\\dfrac{1}{\\sqrt{5}}\\cdot\r\n\\left(\\dfrac{\\phi_{+}^{n-1}}{2^n-\\phi_{+}^n}-\\dfrac{\\phi_{-}^{n-1}}{2^n-\\phi_{-}^n}\\right)\\\\\r\n&amp;=\\dfrac{1}{\\sqrt{5}}\\cdot\\dfrac{2^n(\\phi_{+}^{n-1}-\\phi_{-}^{n-1})+\\sqrt{5}\\cdot(-1)^{n-1}}{2^{2n}-2^n\\cdot(\\phi_{+}^n+\\phi_{-}^n)+(-1)^n}\\\\\r\n&amp;=\\dfrac{2^na_{n-1}+(-1)^{n-1}}{2^{2n}-2^n\\cdot\r\nb_{n}+(-1)^n}&amp;\\qquad(2)\\\\\r\n\\end{aligned}\\]\r\n其中\\(b\\)序列是\\(b_0=2,b_1=1,b_n=b_{n-1}+b_{n-2},n\\ge\r\n2\\)，递推式与斐波那契数列一样。\r\n因此通过矩阵快速幂，直接计算出\\(a_{N-1},b_N\\)的值。计算完成后，代入\\((2)\\)其中直接求逆元即可。\r\n由于\\(5\\)是\\(1000000009\\)的二次剩余，因此直接代入\\((1)\\)也可以做完运算。\r\n代码\r\nfrom sympy import mod_inverseN = 10 ** 18mod = 1000000009def mul(a: list, b: list):    return [[sum(a[i][k] * b[k][j] for k in range(len(b))) % mod for j in range(len(b[0]))] for i in range(len(a))]b = [[0, 1], [1, 1]]a = [[0, 1]]c = [[2, 1]]m = N - 1n = Nwhile n:    if m &amp; 1:        a = mul(a, b)    if n &amp; 1:        c = mul(c, b)    b = mul(b, b)    m &gt;&gt;= 1    n &gt;&gt;= 1num = pow(2, N, mod) * a[0][0] + pow(-1, N - 1, mod)den = pow(2, N + N, mod) - pow(2, N, mod) * c[0][0] + pow(-1, N, mod)ans = num * mod_inverse(den, mod) % modprint(ans)\r\nfrom sympy import mod_inverse, sqrt_modN = 10 ** 18mod = 1000000009sq5 = sqrt_mod(5, mod)inv2 = mod_inverse(2, mod)p1 = (1 + sq5) * inv2 * inv2 % modp2 = (1 - sq5) * inv2 * inv2 % modd1 = pow(p1, N - 1, mod) * mod_inverse(1 - pow(p1, N, mod), mod) % modd2 = pow(p2, N - 1, mod) * mod_inverse(1 - pow(p2, N, mod), mod) % modans = mod_inverse(sq5, mod) * inv2 * (d1 - d2) % modprint(ans)\r\n","categories":["Project Euler"],"tags":["矩阵快速幂","马尔科夫链"]},{"title":"Project Euler 621","url":"/project-euler/621/","content":"\r\nProject Euler 621\r\n题目\r\nExpressing\r\nan integer as the sum of triangular numbers\r\nGauss famously proved that every positive integer can be expressed as\r\nthe sum of three triangular numbers (including \\(0\\) as the lowest triangular number). In\r\nfact most numbers can be expressed as a sum of three triangular numbers\r\nin several ways.\r\nLet \\(G(n)\\) be the number of ways\r\nof expressing \\(n\\) as the sum of three\r\ntriangular numbers, regarding different arrangements of the terms of the\r\nsum as distinct.\r\nFor example, \\(G(9)=7\\), as 9 can be\r\nexpressed as: \\(3+3+3, 0+3+6, 0+6+3, 3+0+6,\r\n3+6+0, 6+0+3, 6+3+0\\).\r\nYou are given \\(G(1000)=78\\) and\r\n\\(G(10^6)=2106\\).\r\nFind \\(G(17526\\times10^9)\\).\r\n解决方案\r\n令\\(n=\\dfrac{a(a+1)}{2}+\\dfrac{b(b+1)}{2}+\\dfrac{c(c+1)}{2}\\).\r\n那么可以变形得：\r\n\\[8n+3=(2a+1)^2+(2b+1)^2+(2c+1)^2\\]\r\n令\\(r_3(n)\\)表示将一个数\\(n\\)写成\\(3\\)个奇数的平方的方法数，那么得\\(G(n)=r_3(8n+3)\\)。不难发现只有当\\(n\\)满足\\(n\\equiv\r\n3 \\pmod 8\\)时，\\(r_3(n)&gt;0\\)才成立。\r\n这篇论文给出了一个关于\\(r_3\\)的递推式：\r\n\\[r_3(9^\\lambda n) =\r\n\\begin{cases}\r\n3^\\lambda \\times r_3(n), &amp; \\text{if }n \\equiv 11 \\pmod{24} \\\\\r\n(2\\times3^\\lambda -1) \\times r_3(n) &amp; \\text{if } n \\equiv 19\r\n\\pmod{24} \\\\\r\n\\dfrac{3^{\\lambda+1}-1}{2} \\times r_3(n) &amp; \\text{if } n \\equiv 3\r\n\\text{ or } 51 \\pmod{72}\r\n\\end{cases}\\]\r\n由于\\(17526\\times 10^9\\times 8+3=3^8 \\times\r\n13 \\times 3527 \\times 466073\\)。因此计算时我们仅需考虑去掉\\(9^{\\lambda}\\)后的\\(n\\)。令\\(M=13\r\n\\times 3527 \\times 466073\\)，也就是\\(r_3(M)\\)。\r\n到了这一步，从小到大枚举奇数\\(i\\)，求解\\(r_2&#39;(M-i^2)\\)，其中\\(r_2&#39;(m)\\)表示方程\\(x^2+y^2=m\\)有多少对\\((x,y)\\)都是奇数，也是正整数的解。\r\n页面1，页面2给出了一个信息：如果\\(n\\)可以将其分解成\\(n=2^g\\prod_i p_i^{e_i}\\prod_j\r\nq_j^{f_j}\\)，其中\\(p_i\\)是模\\(4\\)余\\(1\\)的质数，\\(q_j\\)是模\\(4\\)余\\(3\\)的质数。那么方程\\(x^2+y^2=m\\)的解的个数由\\(r_2(m)\\)决定：\r\n\\[r_2(n)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0  &amp; &amp; \\text{if}\\quad  \\exists j,f_j\\equiv 1\\pmod 2 \\\\\r\n  &amp;4\\prod_i(e_i+1) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n由于目前只求正整数解，那么在求出\\(r_2\\)的基础上需要再除\\(4\\)。\r\n那么现在引入了一个麻烦：\\(r_2\\)是求所有解的个数，但是我们现在需要求的是\\(x,y\\)奇数解，怎么去掉潜在的偶数解？\r\n实际上对于任意一个\\(t\\)，如果\\(2\\mid t,4\\nmid t\\)，那么方程\\(x^2+y^2=t\\)明显不存在\\(x,y\\)同为偶数的解。而上面这种数\\(t=8n+3-i^2\\)实际上是满足这种情况的。令\\(i=2k+1,k\\ge 0\\)，那么就可以写成：\r\n\\[t=8n+3-i^2=8n+3-(2k+1)^2=8n-4k^2-4k+2\\equiv2\\pmod\r\n4\\]\r\n因此，\\(r_2&#39;(M-i^2)=\\dfrac{r_2(M-i^2)}{4}\\)。直接枚举奇数\\(i\\)，对\\(r_2&#39;(M-i^2)\\)求和即可。回代到上面的递推公式求出最终值。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll Q = 17526000000000;const int N = 10000000;int v[N + 1];int pr[N/5+1000],m=0;ll r2(ll n) &#123;    ll ans=1;    if (n&lt;=N) &#123;        for(;n!=1;)&#123;            int p=v[n],c=0;            for(;n%p==0;n/=p,++c);            if(p%4==3)&#123;                if(c&amp;1) return 0;            &#125;            else if(p%4==1) ans*=(c+1);        &#125;    &#125; else &#123;        for(int i=1;i&lt;=m&amp;&amp;1ll*pr[i]*pr[i]&lt;=n&amp;&amp;n&gt;N;i++)&#123;            int p=pr[i],c=0;            for(;n%p==0;n/=p,++c);            if(p%4==3)&#123;                if(c&amp;1) return 0;            &#125;            else if(p%4==1) ans*=(c+1);        &#125;        if(n&lt;N) return ans*r2(n);        else if(n&gt;1)&#123;            if(n%4==3) return 0;            else if(n%4==1) ans*=2;        &#125;    &#125;    return ans*4;&#125;ll r3(ll n) &#123;    ll ans=0;    for (ll i=1;i*i&lt;=n;i+=2)        ans+=r2(n-i*i);    ans*=2;    return ans;&#125;ll G(ll n) &#123;    ll m=n*8+3,pw3=1;    for(;m%9==0;m/=9,pw3*=3);    ll ans;    if(m%24==11) ans=pw3*r3(m);    else if(m%24==19) ans=(pw3*2-1)*r3(m);    else if(m%72==27) ans=r3(m*pw3*pw3);    else ans=(pw3*3-1)/2*r3(m);    return ans/8;&#125;int main() &#123;    v[1]=1;    for(int i=2;i&lt;=N;i++)&#123;        if(v[i]==0)&#123;            pr[++m]=i;            v[i]=i;        &#125;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;N/i) break;            v[i*pr[j]]=pr[j];        &#125;    &#125;    ll ans = G(Q);    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["论文"]},{"title":"Project Euler 625","url":"/project-euler/625/","content":"\r\nProject Euler 625\r\n题目\r\nGcd sum\r\n\\(G(N)=\\sum_{j=1}^N\\sum_{i=1}^j\r\n\\text{gcd}(i,j)\\).\r\nYou are given: \\(G(10)=122\\).\r\nFind \\(G(10^{11})\\). Give your\r\nanswer modulo \\(998244353\\).\r\n解决方案\r\n令\\(\\Phi(n)=\\sum_{i=1}^n\\varphi(n)\\)，其中\\(\\varphi\\)为欧拉函数。\r\n\\[\\begin{aligned}\r\nG(N)&amp;=\\sum_{j=1}^N\\sum_{i=1}^j\r\n\\text{gcd}(i,j)=\\sum_{g=1}^Ng\\sum_{j=1}^N\\sum_{i=1}^j[\\gcd(i,j)=g] \\\\\r\n&amp;=\\sum_{g=1}^Ng\\sum_{j=1}^N\\sum_{i=1}^j[\\gcd(i,j)=g] \\\\\r\n&amp;=\\sum_{g=1}^Ng\\sum_{j=1}^{\\left\\lfloor\\frac{N}{g}\\right\\rfloor}\\sum_{i=1}^j[\\gcd(i,j)=1]\\\\\r\n&amp;=\\sum_{g=1}^Ng\\sum_{j=1}^{\\left\\lfloor\\frac{N}{g}\\right\\rfloor}\\varphi(i)\\\\\r\n&amp;=\\sum_{g=1}^Ng\\Phi\\left(\\dfrac{N}{g}\\right)\r\n\\end{aligned}\\]\r\n其中，\\([]\\)表示示性函数，表示\\([]\\)里面的值是否为真，如果为真，那么值为\\(1\\)，否则值为\\(0\\).\r\n这启发我们使用数论分块进行解决。考虑两层嵌套的数论分块，外层的计算\\(g(n)\\)的值，内层的计算\\(\\Phi(n)\\)的值。\r\n那么现在的问题就是使用数论分块的方法高效计算\\(\\Phi(n)\\)的值。\r\n\\[\\begin{aligned}\r\n\\dfrac{n(n+1)}{2}&amp;=|\\{(a,b)|1\\le a\\le b \\le n\\}|\\\\\r\n&amp;=\\sum_{d=1}^n|\\{(a,b)|1\\le a\\le b \\le n,\\gcd(a,b)=d\\}|\\\\\r\n&amp;=\\sum_{d=1}^n\\left|\\left\\{(a,b)| 1\\le a\\le b \\le\r\n\\left\\lfloor\\dfrac{n}{d}\\right\\rfloor,\\gcd(a,b)=1\\right\\}\\right|\\\\\r\n&amp;=\\sum_{d=1}^n\\Phi\\left(\\dfrac{n}{d}\\right)\r\n\\end{aligned}\\]\r\n因此，可以得到关于\\(\\Phi\\)的递归式：\r\n\\[\\Phi(n)=\\dfrac{n(n+1)}{2}-\\sum_{d=2}^n\\Phi\\left(\\dfrac{n}{d}\\right)\\]\r\n代码\r\n#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const ll N=1e11;const ll mod=998244353;const int M = pow(N, 2.0 / 3);int s[M+4];int v[M+4],pr[M/10+1000],m=0;unordered_map&lt;ll,ll&gt;mp;ll inv2= (mod+1)&gt;&gt;1;ll sum_phi(ll n)&#123;    if(n &lt;= M) return s[n];    if(mp.count(n)) return mp[n];    ll ans= ((n + 1) % mod * (n % mod) % mod) * inv2 % mod;    for(ll l=2,r; l &lt;= n; l= r + 1)    &#123;        r= n / (n / l);        ans= (ans - (r - l + 1) % mod * sum_phi(n / l) % mod + mod) % mod;    &#125;    return mp[n]=ans;&#125;int main() &#123;    s[1]=1;    for(int i=2;i&lt;=M;i++) &#123;        if(v[i]==0)&#123;            v[i]=i;pr[++m]=i;s[i]=i-1;        &#125;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;M/i) break;            v[i*pr[j]]=pr[j];            s[i*pr[j]]=s[i]*(pr[j]==v[i]?pr[j]:pr[j]-1);        &#125;    &#125;    for(int i=2;i&lt;=M;i++)        s[i]=(s[i]+s[i-1])%mod;    ll ans=0;    for(ll l=1,r;l&lt;=N;l=r+1)&#123;        r=N/(N/l);        // l&lt;=g&lt;=r        ans=(ans+(l+r)%mod*((r-l+1)%mod)%mod*inv2%mod*sum_phi(N/l)+mod)%mod;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["数论分块"]},{"title":"Project Euler 63","url":"/project-euler/63/","content":"\r\nProject Euler 63\r\n题目\r\nPowerful digit counts\r\nThe \\(5\\)-digit number, \\(16807=7^5\\), is also a fifth power.\r\nSimilarly, the \\(9\\)-digit number,\r\n\\(134217728=8^9\\), is a ninth\r\npower.\r\nHow many \\(n\\)-digit positive\r\nintegers exist which are also an \\(n^\\text{th}\\) power?\r\n解决方案\r\n可以发现，\\(10^n\\)是一个\\(n+1\\)位数。因此，如果一个数\\(a^n\\)为\\(n\\)位数，那么\\(a\\leq 9\\)。\r\n当\\(9^n\\)的位数小于\\(n\\)位时，统计结束。（因为\\(n\\)就算增加\\(1\\)，\\(9^n\\)再乘一个\\(9\\)，也没办法使积的位数增加多于\\(1\\)位，变成\\(n+1\\)位）。\r\n代码\r\nfrom itertools import countans = 0for n in count(1, 1):    if len(str(9 ** n)) &lt; n:        break    for a in range(1, 10):        if len(str(a ** n)) == n:            ans += 1print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 618","url":"/project-euler/618/","content":"\r\nProject Euler 618\r\n题目\r\nNumbers with a given\r\nprime factor sum\r\nConsider the numbers \\(15\\), \\(16\\) and \\(18\\):\r\n\\(15=3\\times5\\) and \\(3+5=8\\). \\(16=2\\times2\\times2\\times2\\) and \\(2+2+2+2=8\\).\r\n\\(18=2\\times3\\times3\\) and \\(2+3+3=8\\). \\(15\\), \\(16\\) and \\(18\\) are the only numbers that have \\(8\\) as sum of the prime factors (counted\r\nwith multiplicity).\r\nWe define \\(S(k)\\) to be the sum of\r\nall numbers \\(n\\) where the sum of the\r\nprime factors (with multiplicity) of \\(n\\) is \\(k\\). Hence \\(S(8)=15+16+18=49\\).\r\nOther examples: \\(S(1)=0\\), \\(S(2)=2\\), \\(S(3)=3\\), \\(S(5)=5+6=11\\).\r\nThe Fibonacci sequence is \\(F_1=1\\),\r\n\\(F_2=1\\), \\(F_3=2\\), \\(F_4=3\\), \\(F_5=5\\), \\(\\ldots\\)Find the last nine digits of \\(\\sum_{k=2}^{24}S(F_k)\\).\r\n解决方案\r\n本题使用动态规划（递推）思路解决，其阶段性特征比较明显。\r\n设\\(p\\)为存放质数的数组，\\(f(i,j)(i,j\\geq 0)\\)为使用了前\\(i\\)种质数，质因数之和为\\(j\\)的所有数的和。可以列出以下递推方程：\r\n\\[\r\nf(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad  j=0 \\\\\r\n  &amp;0 &amp; &amp; \\text{else if}\\quad  i=0 \\\\\r\n  &amp;f(i-1,j) &amp; &amp; \\text{else if}\\quad  j&lt;p[j] \\\\\r\n  &amp;f(i-1,j)+f(i,j-p[i])\\times p[i] &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n那么对于方程最后一行，有以下情况：\r\n\r\n直接把前只使用\\(i-1\\)素数的情况转移过来。\r\n把\\(f(i,j-p[i])\\)中的所有数全部都添加一个质因数（也就是说，都乘一个\\(p[i]\\)），就变成了\\(f(i,j)\\)的情况，由此就能做到不重不漏的情况。\r\n\r\n将\\(F_{24}\\)以内的质数预处理出来，假设有\\(m\\)个。那么答案为\\(\\sum_{k=2}^{24} f(m,F_k)\\)。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=100000,Q=24;bool b[N+4];int pr[N+4],m=0;int que[144],p=0;ll f[N+4],mod=1e9;int main()&#123;    for(int i=1,a=1,b=2;i&lt;Q;i++)&#123;        que[++p]=a;        int c=a+b;        a=b;b=c;    &#125;    int mx=que[p];    for(int i=2;i&lt;=mx;i++)&#123;        if(b[i]) continue;        pr[++m]=i;        for(int j=i+i;j&lt;=mx;j+=i)            b[j]=1;    &#125;    f[0]=1;    for(int i=1;i&lt;=m;i++)        for(int j=pr[i];j&lt;=mx;j++)            f[j]=(f[j]+f[j-pr[i]]*pr[i])%mod;    ll ans=0;    for(int i=1;i&lt;=p;i++)        ans=(ans+f[que[i]])%mod;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 628","url":"/project-euler/628/","content":"\r\nProject Euler 628\r\n题目\r\nOpen chess positions\r\nA position in chess is an (orientated) arrangement of chess pieces\r\nplaced on a chessboard of given size. In the following, we consider all\r\npositions in which \\(n\\) pawns are\r\nplaced on a \\(n \\times n\\)\r\nboard in such a way, that there is a single pawn in every row and every\r\ncolumn.\r\nWe call such a position an open position, if a rook,\r\nstarting at the (empty) lower left corner and using only moves towards\r\nthe right or upwards, can reach the upper right corner without moving\r\nonto any field occupied by a pawn.\r\nLet \\(f(n)\\) be the number of open\r\npositions for a \\(n \\times n\\)\r\nchessboard.\r\nFor example, \\(f(3)=2\\), illustrated\r\nby the two open positions for a \\(3  \\times\r\n3\\) chessboard below.\r\n \r\nYou are also given \\(f(5)=70\\).\r\nFind \\(f(10^8)\\) modulo \\(1\\,008\\,691\\,207\\).\r\n解决方案\r\n一个局面不是开放局面，当且仅当从左上到右下存在一堵“墙”（如图所示）：\r\n\r\n因此，我们需要统计这种非开放局面的数量，然后用总局面数量\\(n!\\)减去这些非开放局面数量即可。\r\n如果墙位于左下方，那么长度为\\(i\\)的墙一共有\\((n-i)!\\)种方法，位于右上方的墙的情况相同，以及主对角线上的那\\(1\\)种情况。同时，需要减去左下方，右上方都有墙的情况（长度分别为\\(i,j\\)）：\\(\\displaystyle{\\sum_{i=1}^{n-1}\\sum_{j=1}^{n-i}}(n-i-j)!\\)。\r\n因此，最终可以得到：\r\n\\(\\begin{aligned}\r\nf(n)&amp;=n!-\\left(2\\sum_{i=1}^{n-1}(n-i)!+1-\\sum_{i=1}^{n-1}\\sum_{j=1}^{n-i}\r\n(n-i-j)!\\right)\\\\\r\n&amp;=n!-\\left(2\\sum_{i=1}^{n-1}i!+1-\\sum_{i=0}^{n-2}(n-i-1)\\cdot\r\ni!\\right)\\\\\r\n&amp;=n!-\\left(2\\cdot(n-1)!+2\\sum_{i=0}^{n-2}i!-1-\\sum_{i=0}^{n-2}(n-i-1)\\cdot\r\ni!\\right)\\\\\r\n&amp;=n!-\\left(2\\cdot(n-1)!-1-\\sum_{i=0}^{n-2}(n-i-3)\\cdot i!\\right)\\\\\r\n&amp;=(n-2)\\cdot(n-1)!+1+\\sum_{i=0}^{n-2}(n-i-3)\\cdot i!\\\\\r\n&amp;=n!+1+\\sum_{i=0}^{n-1}(n-i-3)\\cdot i!\\\\\r\n\\end{aligned}\\)\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=1e8;ll mod=1008691207;int main()&#123;    ll fac=1,ans=0;    for(int i=0;i&lt;=N-1;i++)&#123;        ans=(ans+fac*(N-i-3))%mod;        fac=fac*(i+1)%mod;    &#125;    ans=(ans+fac+1)%mod;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 630","url":"/project-euler/630/","content":"\r\nProject Euler 630\r\n题目\r\nCrossed lines\r\nGiven a set, \\(L\\), of unique lines,\r\nlet \\(M(L)\\) be the number of lines in\r\nthe set and let \\(S(L)\\) be the sum\r\nover every line of the number of times that line is crossed by another\r\nline in the set. For example, two sets of three lines are shown\r\nbelow:\r\n\r\nIn both cases M(L) is 3 and S(L) is 6: each of the three lines is\r\ncrossed by two other lines. Note that even if the lines cross at a\r\nsingle point, all of the separate crossings of lines are counted.\r\nConsider points \\((T_{2k−1}, T_{2k})\\), for integer \\(k \\ge 1\\), generated in the following\r\nway:\r\n\\(\\begin{aligned}\r\nS_0  &amp;=   290797\\\\\r\nS_{n+1}  &amp;=   {S_n}^2 \\bmod 50515093\\\\\r\nT_n  &amp;=   ( S_n \\bmod 2000 ) − 1000\r\n\\end{aligned}\\)\r\nFor example, the first three points are: \\((527, 144), (−488, 732), (−454, −947)\\).\r\nGiven the first \\(n\\) points generated\r\nin this manner, let \\(L_n\\) be the set\r\nof unique lines that can be formed by joining each\r\npoint with every other point, the lines being extended indefinitely in\r\nboth directions. We can then define \\(M(L_n)\\) and \\(S(L_n)\\) as described above.\r\nFor example, \\(M(L_3) = 3\\) and\r\n\\(S(L_3) = 6\\). Also \\(M(L_{100}) = 4948\\) and \\(S(L_{100}) = 24477690\\).\r\nFind \\(S(L_{2500})\\).\r\n解决方案\r\n斜率相同的两条的直线永远不会相交，斜率不相同那么两条直线就会相交。\r\n将每条斜率相同的直线划分汇集到一起，假设为\\(k_i\\)条。如果一共有\\(n\\)组斜率两两不相同的直线，那么\\(M(L)=\\sum_{i=1}^nk_i\\)，并且\\(S(L)=\\sum_{i=1}^n k_i\\cdot\r\n(M(L)-k_i)\\)。\r\n实现时，每一条直线都分别用两个点表示，因此引出两个问题：不同斜率的直线如何分类，以及如何对直线进行去重。\r\n为解决第一个问题，我们为这一些直线进行“定向”,即为沿着直线的两个方向指定一个向量。斜率相同的直线，定的方向都相同。然后就将这些直线将它们定下的方向向量作为关键字进行极角排序，排序完成后，相邻两条直线对应向量叉积若为\\(0\\)，那么说明它们是同一斜率下的。\r\n为解决第二个问题，考虑两条斜率相同的直线\\(P_1P_2\\)和\\(Q_1Q_2\\)是否为同一直线，并且已经定向成\\(\\overrightarrow{P_1P_2},\\overrightarrow{Q_1Q_2}\\)。为了方便第二步去重，首先极角排序时就需要内部处理好斜率相同时直线的位置。如果\\(\\overrightarrow{P_1P_2}\\times\\overrightarrow{P_1Q_1}&gt;0\\)，那么说明直线\\(Q_1Q_2\\)在\\(P_1P_2\\)的左（上）边。因此极角排序时，还需要以\\(\\overrightarrow{P_1P_2}\\times\\overrightarrow{P_1Q_1}\\)的正负性作为第二关键字进行排序。最终去重时，如果\\(\\overrightarrow{P_1P_2}\\times\\overrightarrow{P_1Q_1}=0\\)，那么说明两条直线其实是同一条，并去除。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;# define pi pair&lt;int,int&gt;using namespace std;typedef long long ll;const int N=2500;int S[N*2+4],T[N*2+4];struct P &#123;    ll x, y;    // 向量减法    P(ll xx=0,ll yy=0):x(xx),y(yy)&#123;&#125;    P operator-(P p) const &#123;        return &#123;x - p.x, y - p.y&#125;;    &#125;    // 向量叉积    ll operator^(P p) const &#123;        return x * p.y - y * p.x;    &#125;    bool operator &lt; (P&amp;p) const&#123;        return x&lt;p.x||x==p.x&amp;&amp;y&lt;p.y;    &#125;&#125;p[N+4];struct L &#123;    P p1, p2;    L()&#123;&#125;    L(P p1, P p2) &#123;        this-&gt;p1 = p1;        this-&gt;p2 = p2;    &#125;    P vec()&#123;return p2-p1;&#125;    bool operator ==(L &amp;l)&#123;        return ((vec())^(l.vec()))==0&amp;&amp;(vec()^(l.p1-p1))==0;    &#125;    bool operator &lt; (L &amp;l)&#123;        ll v=((vec())^(l.vec()));        if(v!=0) return v&lt;0;        return (vec()^(l.p1-p1))&lt;0;    &#125;&#125;l[N*(N-1)/2+4];int np=0,nl=0;int main()&#123;    S[0]=290797;    for(int i=1;i&lt;=N*2;i++)&#123;        S[i]=1ll*S[i-1]*S[i-1]%50515093;        T[i]=S[i]%2000-1000;    &#125;    for(int i=2;i&lt;=N+N;i+=2)        p[++np]=P(T[i-1],T[i]);    sort(p+1,p+np+1);    for(int i=1;i&lt;=N;i++)        for(int j=i+1;j&lt;=N;j++)            l[++nl]=L(p[i],p[j]);    sort(l+1,l+nl+1);    nl=unique(l+1,l+nl+1)-l-1;    ll ans=1ll*nl*(nl-1);    for(int i=1,j=1;i&lt;=nl;i=j)&#123;        for(;j&lt;=nl&amp;&amp;(l[i].vec()^l[j].vec())==0;++j);        ans-=1ll*(j-i)*(j-i-1);    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 64","url":"/project-euler/64/","content":"\r\nProject Euler 64\r\n题目\r\nOdd period square roots\r\nAll square roots are periodic when written as continued fractions and\r\ncan be written in the form:\r\n\\(\\sqrt{N}=a_0+\\dfrac 1 {a_1+\\dfrac 1 {a_2+\r\n\\dfrac 1 {a_3+ \\dots}}}\\)\r\nFor example, let us consider \\(\\sqrt{23}:\\) \\(\\sqrt{23}=4+\\sqrt{23}-4=4+\\dfrac 1 {\\dfrac 1\r\n{\\sqrt{23}-4}}=4+\\dfrac 1  {1+\\dfrac{\\sqrt{23}-3}7}\\)\r\nIf we continue we would get the following expansion:\r\n\\(\\sqrt{23}=4+\\dfrac 1 {1+\\dfrac 1 {3+\r\n\\dfrac 1 {1+\\dfrac 1 {8+ \\dots}}}}\\)\r\nThe process can be summarised as follows:\r\n\\(a_0=4, \\dfrac 1 {\\sqrt{23}-4}=\\dfrac\r\n{\\sqrt{23}+4} 7=1+\\dfrac {\\sqrt{23}-3} 7\\) \\(a_1=1, \\dfrac 7 {\\sqrt{23}-3}=\\dfrac\r\n{7(\\sqrt{23}+3)} {14}=3+\\dfrac {\\sqrt{23}-3} 2\\) \\(a_2=3, \\dfrac 2 {\\sqrt{23}-3}=\\dfrac\r\n{2(\\sqrt{23}+3)} {14}=1+\\dfrac {\\sqrt{23}-4} 7\\) \\(a_3=1, \\dfrac 7 {\\sqrt{23}-4}=\\dfrac\r\n{7(\\sqrt{23}+4)} 7=8+\\sqrt{23}-4\\) \\(a_4=8, \\dfrac 1 {\\sqrt{23}-4}=\\dfrac {\\sqrt{23}+4}\r\n7=1+\\dfrac {\\sqrt{23}-3} 7\\) \\(a_5=1, \\dfrac 7 {\\sqrt{23}-3}=\\dfrac {7\r\n(\\sqrt{23}+3)} {14}=3+\\dfrac {\\sqrt{23}-3} 2\\) \\(a_6=3, \\dfrac 2 {\\sqrt{23}-3}=\\dfrac\r\n{2(\\sqrt{23}+3)} {14}=1+\\dfrac {\\sqrt{23}-4} 7\\) \\(a_7=1, \\dfrac 7 {\\sqrt{23}-4}=\\dfrac\r\n{7(\\sqrt{23}+4)} {7}=8+\\sqrt{23}-4\\)\r\nIt can be seen that the sequence is repeating. For conciseness, we\r\nuse the notation \\(\\sqrt{23}=[4;(1,3,1,8)]\\), to indicate that\r\nthe block \\((1,3,1,8)\\) repeats\r\nindefinitely.\r\nThe first ten continued fraction representations of (irrational)\r\nsquare roots are:\r\n\\(\\sqrt{2}=[1;(2)]\\), period=\\(1\\) \\(\\sqrt{3}=[1;(1,2)]\\), period=\\(2\\) \\(\\sqrt{5}=[2;(4)]\\), period=\\(1\\) \\(\\sqrt{6}=[2;(2,4)]\\), period=\\(2\\) \\(\\sqrt{7}=[2;(1,1,1,4)]\\), period=\\(4\\) \\(\\sqrt{8}=[2;(1,4)]\\), period=\\(2\\) \\(\\sqrt{10}=[3;(6)]\\), period=\\(1\\) \\(\\sqrt{11}=[3;(3,6)]\\), period=\\(2\\) \\(\\sqrt{12}=[3;(2,6)]\\), period=\\(2\\) \\(\\sqrt{13}=[3;(1,1,1,1,6)]\\), period=\\(5\\)\r\nExactly four continued fractions, for \\(N\r\n\\le 13\\), have an odd period.\r\nHow many continued fractions for \\(N \\le\r\n10\\,000\\) have an odd period?\r\n解决方案\r\n本题主要以查阅资料等方式得以解决。\r\n该计算周期性连分数的维基百科页面中，给出了一种计算连分数序列\\(\\{a\\}\\)的递推算法：\r\n\\(\\begin{aligned}\r\nm_0 &amp;=0 \\\\\r\nd_0 &amp;= 1 \\\\\r\na_0&amp;=\\lfloor\\sqrt {S}\\rfloor \\\\\r\nm_{n+1}&amp;=d_na_n-m_n \\\\\r\nd_{n+1}&amp;=\\dfrac{S-m_{n+1}^2}{d_n}\\\\\r\na_{n+1}&amp;=\\left\\lfloor\\dfrac{a_0+m_{n+1}}{d_{n+1}}\\right\\rfloor\r\n\\end{aligned}\\)\r\n其中，\\(\\{m\\},\\{d\\},\\{a\\}\\)三个数列都是整数序列。当计算到\\(a_n=2a_0\\)时，算法终止迭代，\\(n\\)就是周期本身。\r\n依照该维基百科提供的内容，即可完成每个连分数的\\(\\{a\\}\\)序列周期计算。\r\n代码\r\nfrom tools import int_sqrt, is_square# https://en.wikipedia.org/wiki/Periodic_continued_fraction#Canonical_form_and_repetendN = 10000ans = 0for S in range(2, N + 1):    if is_square(S):        continue    m = 0    d = 1    a0 = int_sqrt(S)    tm = 0    a = a0    while a != 2 * a0:        m = d * a - m        d = (S - m * m) // d        a = (a0 + m) // d        tm += 1    if tm &amp; 1:        ans += 1print(ans)\r\n","categories":["Project Euler"],"tags":["论文"]},{"title":"Project Euler 643","url":"/project-euler/643/","content":"\r\nProject Euler 643\r\n题目\r\n\\(2\\)-Friendly\r\nTwo positive integers \\(a\\) and\r\n\\(b\\) are \\(2\\)-friendly when \\(\\gcd(a,b) = 2^t, t&gt;0\\). For example,\r\n\\(24\\) and \\(40\\) are \\(2\\)-friendly because \\(\\gcd(24,40) = 8 = 2^3\\) while \\(24\\) and \\(36\\) are not because \\(\\gcd(24,36) = 12 = 2^2\\cdot 3\\) not a power\r\nof \\(2\\).\r\nLet \\(f(n)\\) be the number of pairs,\r\n\\((p,q)\\), of positive integers with\r\n\\(1\\le p\\lt q\\le n\\) such that \\(p\\) and \\(q\\) are \\(2\\)-friendly. You are given \\(f(10^2) = 1031\\) and \\(f(10^6) = 321418433 \\text{ modulo }\r\n1\\,000\\,000\\,007\\).\r\nFind \\(f(10^{11})\\text{ modulo }\r\n1\\,000\\,000\\,007\\).\r\n解决方案\r\n令\\(\\Phi(n)=\\sum_{i=1}^n\\varphi(n)\\)，其中\\(\\varphi\\)为欧拉函数。\r\n那么\\(f(n)\\)定义并化简的步骤如下：\r\n\\[\\begin{aligned}\r\nf(n)&amp;=\\sum_{t=1}^{\\lfloor\r\n\\log_2n\\rfloor}(-1+\\sum_{q=1}^n\\sum_{p=1}^{q}[\\gcd(p,q)=2^t]) \\\\\r\n&amp;=\\sum_{t=1}^{\\lfloor\r\n\\log_2n\\rfloor}(-1+\\sum_{q=1}^{\\left\\lfloor\\frac{n}{2^t}\\right\\rfloor}\\sum_{p=1}^{q}[\\gcd(p,q)=1])\\\\\r\n&amp;=\\sum_{t=1}^{\\lfloor\r\n\\log_2n\\rfloor}(-1+\\sum_{q=1}^{\\left\\lfloor\\frac{n}{2^t}\\right\\rfloor}\\varphi(q))\\\\\r\n&amp;=\\sum_{t=1}^{\\lfloor\r\n\\log_2n\\rfloor}\\left(\\Phi\\left(\\left\\lfloor\\frac{n}{2^t}\\right\\rfloor\\right)-1\\right)\r\n\\end{aligned}\\]\r\n其中，\\([]\\)表示示性函数，表示\\([]\\)里面的值是否为真，如果为真，那么值为\\(1\\)，否则值为\\(0\\).\r\n和512题一样，现在的问题就是使用数论分块的方法高效计算\\(\\Phi(n)\\)的值。\r\n\\[\\begin{aligned}\r\n\\dfrac{n(n+1)}{2}&amp;=|\\{(a,b)|1\\le a\\le b \\le n\\}|\\\\\r\n&amp;=\\sum_{d=1}^n|\\{(a,b)|1\\le a\\le b \\le n,\\gcd(a,b)=d\\}|\\\\\r\n&amp;=\\sum_{d=1}^n\\left|\\left\\{(a,b)| 1\\le a\\le b \\le\r\n\\left\\lfloor\\dfrac{n}{d}\\right\\rfloor,\\gcd(a,b)=1\\right\\}\\right|\\\\\r\n&amp;=\\sum_{d=1}^n\\Phi\\left(\\dfrac{n}{d}\\right)\r\n\\end{aligned}\\]\r\n因此，可以得到关于\\(\\Phi\\)的递归式：\r\n\\[\\Phi(n)=\\dfrac{n(n+1)}{2}-\\sum_{d=2}^n\\Phi\\left(\\dfrac{n}{d}\\right)\\]\r\n其中，右边这一部分可以使用数论分块来解决。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const ll N=1e11;const ll mod=1000000007;const int M = pow(N, 2.0 / 3);int s[M+4];int v[M+4],pr[M/10+1000],m=0;unordered_map&lt;ll,ll&gt;mp;ll inv2= (mod+1)&gt;&gt;1;ll sum_phi(ll n)&#123;    if(n &lt;= M) return s[n];    if(mp.count(n)) return mp[n];    ll ans= ((n + 1) % mod * (n % mod) % mod) * inv2 % mod;    for(ll l=2,r; l &lt;= n; l= r + 1)    &#123;        r= n / (n / l);        ans= (ans - (r - l + 1) % mod * sum_phi(n / l) % mod + mod) % mod;    &#125;    return mp[n]=ans;&#125;int main() &#123;    s[1]=1;    for(int i=2;i&lt;=M;i++) &#123;        if(v[i]==0)&#123;            v[i]=i;pr[++m]=i;s[i]=i-1;        &#125;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;M/i) break;            v[i*pr[j]]=pr[j];            s[i*pr[j]]=s[i]*(pr[j]==v[i]?pr[j]:pr[j]-1);        &#125;    &#125;    for(int i=2;i&lt;=M;i++)        s[i]=(s[i]+s[i-1])%mod;    ll ans=0;    for(ll d=2; d &lt;= N; d&lt;&lt;=1)        ans= (ans + sum_phi(N / d) - 1) % mod;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["数论分块"]},{"title":"Project Euler 649","url":"/project-euler/649/","content":"\r\nProject Euler 649\r\n题目\r\nLow-Prime Chessboard Nim\r\nAlice and Bob are taking turns playing a game consisting of \\(c\\) different coins on a chessboard of size\r\n\\(n\\) by \\(n\\).\r\nThe game may start with any arrangement of \\(c\\) coins in squares on the board. It is\r\npossible at any time for more than one coin to occupy the same square on\r\nthe board at the same time. The coins are distinguishable, so swapping\r\ntwo coins gives a different arrangement if (and only if) they are on\r\ndifferent squares.\r\nOn a given turn, the player must choose a coin and move it either\r\nleft or up \\(2\\), \\(3\\), \\(5\\), or \\(7\\) spaces in a single direction. The only\r\nrestriction is that the coin cannot move off the edge of the board.\r\nThe game ends when a player is unable to make a valid move, thereby\r\ngranting the other player the victory.\r\nAssuming that Alice goes first and that both players are playing\r\noptimally, let \\(M(n, c)\\) be the\r\nnumber of possible starting arrangements for which Alice can ensure her\r\nvictory, given a board of size \\(n\\) by\r\n\\(n\\) with \\(c\\) distinct coins.\r\nFor example, \\(M(3, 1) = 4\\), \\(M(3, 2) = 40\\), and \\(M(9, 3) = 450304\\).\r\nWhat are the last \\(9\\) digits of\r\n\\(M(10\\,000\\,019, 100)\\)?\r\n解决方案\r\n令\\(N=10000019,C=100\\)。注意到，游戏中硬币之间是独立的，没有任何关系，因此多个硬币的游戏局面考虑用SG定理组合出来。\r\n考虑单独一个硬币时的局面。一个硬币可以向左或向上移动，并且一次只能朝其中一个方向移动\\(2,3,5,7\\)格。那么棋盘的两个方向也是相互独立的，同样也可以通过SG定理组合出来。\r\n两个坐标之间是独立的，硬币之间也是独立的，因此我们可以将这个游戏可以看成是\\(2C\\)个局面的组合。\r\n那么考虑一个硬币时一维的情况（也就是单独一个局面时的情况）。假设当前硬币在第\\(n\\)格，那么它就只能移向第\\(n-2,n-3,n-5,n-7\\)格。因此\\(n\\)的SG函数值不难写出为：\r\n\\[\r\nsg(n)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0 &amp; &amp; \\text{if}\\quad  n\\le 2 \\\\\r\n  &amp;\\text{mex}(\\{sg(n-x)|x\\in\\{2,3,5,7\\}\\land x&lt;n\\}) &amp; &amp;\r\n\\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n其中运算\\(\\text{mex}(s)\\)表示集合\\(s\\)中未出现的最小的非负整数。那么使用一下程序直接进行打表：\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=40,M=500;int sg[N+4],c[8];bool mex[144];vector&lt;int&gt;z&#123;2,3,5,7&#125;;int main()&#123;    for(int i=1;i&lt;=N;i++)&#123;        memset(mex,0,sizeof(mex));        for(int x:z)            if(i-x&gt;0) mex[sg[i-x]]=1;        int j=0;        for(;mex[j];++j);        sg[i]=j;        printf(&quot;%d\\n&quot;,j);    &#125;&#125;\r\n打完表后发现，从\\(1\\)开始，\\(sg\\)函数值是一个周期为\\(9\\)的序列，其中一个周期的序列为\\([0,0,1,1,2,2,3,3,4]\\)。\r\n因此，用一个数组\\(c[i]\\)表示\\(1\\sim N\\)中有多少个数的\\(sg\\)函数值为\\(i\\)。\\(c[i]\\)将会被很快地计算出。\r\n最终问题转化为有多少种方法可以将\\(sg\\)函数值填入一个长度为\\(2C\\)的序列，并且这\\(2C\\)个值的异或和不为\\(0\\)。\r\n令状态\\(f(i,j)(0\\le i\\le 2C,0\\le\r\nj&lt;2^3)\\)表示填入长度为\\(i\\)的序列，并且异或和为\\(j\\)的方案数有多少个。那么不难写出状态转移方程为：\r\n\\[\r\ng(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad  i=0\\land j=0 \\\\\r\n  &amp;0 &amp; &amp; \\text{else if}\\quad  i=0 \\\\\r\n  &amp;\\sum_{k=0}^{2^3-1} g(i-1,j\\oplus k) \\cdot c[k] &amp; &amp;\r\n\\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n如果我们已经求出了长度为\\(a\\)的序列的各种填法\\(f(a,\\cdot)\\)和长度为\\(b\\)的各种填法\\(f(b,\\cdot)\\)，不难知道我们可以通过卷积组合出\\(f(a+b,\\cdot)\\)。\r\n枚举所有的\\(f(a,i)\\)和\\(f(b,j)\\)，将这两部分值直接合并起来：\r\n\\(f(a,i)\\cdot f(b,j)\\rightarrow\r\nf(a+b,i\\oplus j)\\)\r\n因此，这给了我们一个方案：依次求出\\(f(2^0,\\cdot),f(2^1,\\cdot),f(2^2,\\cdot),\\dots\\)。然后针对\\(N\\)，选择这些求出的\\(f(2^i,\\cdot)\\)进行合并即可。\r\n最终答案为\\(\\sum_{i=1}^{2^3-1}\r\nf(N,i)\\)。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=10000019;const int C=100;const int D=1&lt;&lt;3;ll mod=1000000000;int sg[10]=&#123;0,0,0,1,1,2,2,3,3,4&#125;;ll a[D],b[D];void cal(ll a[D],ll b[D],ll ans[D])&#123;    ll c[D]=&#123;0&#125;;    for(int i=0;i&lt;D;i++)        for(int j=0;j&lt;D;j++)            c[i^j]=(c[i^j]+a[i]*b[j])%mod;    memcpy(ans,c,sizeof(c));&#125;int main()&#123;    for(int i=1;i&lt;=9;i++)        b[sg[i]]+=(N+9-i)/9%mod;    a[0]=1;    for(int c=C*2;c;c&gt;&gt;=1)&#123;        if(c&amp;1) cal(a,b,a);        cal(b,b,b);    &#125;    ll ans=0;    for(int i=1;i&lt;D;i++)        ans=(ans+a[i])%mod;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划","矩阵快速幂&#43;","SG定理"]},{"title":"Project Euler 637","url":"/project-euler/637/","content":"\r\nProject Euler 637\r\n题目\r\nFlexible digit sum\r\nGiven any positive integer \\(n\\), we\r\ncan construct a new integer by inserting plus signs between some of the\r\ndigits of the base \\(B\\) representation\r\nof \\(n\\), and then carrying out the\r\nadditions.\r\nFor example, from \\(n=123_{10}\\)\r\n(\\(n\\) in base \\(10\\)) we can construct the four base 10\r\nintegers \\(123_{10}\\), \\(1+23=24_{10}\\), \\(12+3=15_{10}\\) and \\(1+2+3=6_{10}\\)\r\nLet \\(f(n,B)\\) be the smallest\r\nnumber of steps needed to arrive at a single-digit number in base \\(B\\). For example, \\(f(7,10)=0\\) and \\(f(123,10)=1\\).\r\nLet \\(g(n,B_1,B_2)\\) be the sum of\r\nthe positive integers \\(i\\) not\r\nexceeding \\(n\\) such that \\(f(i,B_1)=f(i,B_2)\\).\r\nYou are given \\(g(100,10,3)=3302\\).\r\nFind \\(g(10^7,10,3)\\)\r\n解决方案\r\n解决过程比较暴力。对于一个数\\(n\\)，通过二进制枚举其每一个划分，并且将划分的值进行求和得到\\(s\\)。最终的目标是找到一个最优秀的\\(s\\)。也就是说，\\(\\displaystyle{f(n,B)=\\min_{s}\\{f(s,B)+1\\}}\\)。\r\n不过，直接暴力枚举后继状态\\(s\\)效果非常差，以下是一些改进过程：\r\n\r\n枚举状态的顺序：先枚举密的划分，再枚举疏的划分。因为基于一种虚假的贪心思想是，划分的越多，变成个位数的步骤越少。\r\n按照上面的枚举顺序，求解\\(f(n,B)\\)。当枚举到后继状态\\(s\\)满足\\(f(s,B)=0\\)时，说明此时必定有\\(f(n,B)=1\\)，这是显而易见的。如果后继状态\\(s\\)满足\\(f(s,B)=1\\)时，说明此时有\\(f(n,B)=2\\)，因为一开始枚举的状态是将所有数位都划分，如果在这种情况下都无法满足\\(f(n,B)=0\\)，那么后继更不可能存在\\(s\\)满足\\(f(s,B)=0\\)，因为这个划分的内部至少存在一个两位数；因此如果遇见\\(f(s,B)=1\\)，那么及时停止循环。\r\n\r\n由于对于绝大多数\\(n\\)而言，\\(f(n,3)\\le\r\n2\\)成立，因此上述优化可以有效增加效率。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=10000000;const int B1 = 10,B2 = 3;int f1[N+4],f2[N+4],w;int s[44],p;void parse(int n,int b)&#123;    p=0;    for(;n;n/=b)        s[p++]=n%b;    reverse(s,s+p);&#125;void solve(int n,int *f,int b)&#123;    for(int i=0;i&lt;=min(b-1,n);i++)        f[i]=0;    for(int i=b;i&lt;=n;i++)&#123;        int &amp;w=f[i];w=1e9;        parse(i,b);        int msk=1&lt;&lt;p;        // 优化点 (1)        for(int st=msk-1;st&gt;=(msk&gt;&gt;1);st--)&#123;            int sum=0,t=0;            for(int i=0;i&lt;p;i++)&#123;                t=t*b+s[i];                if(st&gt;&gt;i&amp;1)&#123;                    sum+=t;t=0;                &#125;            &#125;            w=min(w,f[sum]);            // 优化点 (2)            if(w&lt;=1) break;        &#125;        ++w;    &#125;&#125;int main()&#123;    solve(N,f1,B1);    solve(N,f2,B2);    ll ans = 0;    for(int i=1;i&lt;=N;i++)&#123;        if(f1[i]==f2[i])&#123;            ans += i;        &#125;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 657","url":"/project-euler/657/","content":"\r\nProject Euler 657\r\n题目\r\nIncomplete words\r\nIn the context of formal languages, any finite\r\nsequence of letters of a given alphabet \\(\\Sigma\\) is called a word\r\nover \\(\\Sigma\\). We call a word\r\nincomplete if it does not contain every letter of \\(\\Sigma\\).\r\nFor example, using the alphabet \\(\\Sigma=\\{\r\na, b, c\\}\\), ‘\\(ab\\)’, ‘\\(abab\\)’ and ‘\\(\\,\\)’ (the empty word) are incomplete words\r\nover \\(\\Sigma\\), while ‘\\(abac\\)’ is a complete word over \\(\\Sigma\\).\r\nGiven an alphabet \\(\\Sigma\\) of\r\n\\(\\alpha\\) letters, we define \\(I(\\alpha,n)\\) to be the number of\r\nincomplete words over \\(\\Sigma\\) with a\r\nlength not exceeding \\(n\\).\r\nFor example, \\(I(3,0)=1\\), \\(I(3,2)=13\\) and \\(I(3,4)=79\\).\r\nFind \\(I(10^7,10^{12})\\). Give your\r\nanswer modulo \\(1\\,000\\,000\\,007\\).\r\n解决方案\r\n令\\(N=10^7,M=10^{12}\\)。考虑使用容斥原理解决本题。\r\n如果当前只使用其中\\(i\\)个字母，那么单词的数量个数\\(f_{N,M}(i)\\)如下：\r\n\\[f_{N,M}(i)=\\dbinom{N}{i}\\sum_{j=0}^{M}\r\ni^j\\]\r\n这是一个很明显的等比数列求和式，但是当\\(i=1\\)时，式子不适用等比数列求和公式，因此化简成\\(N\\cdot (M+1)\\)，否则可以化简成\\(\\dbinom{N}{i}\\cdot\r\n\\dfrac{i^{M+1}-1}{i-1}\\)。\r\n注意到\\(f_{N,M}(N-1)\\)中的一些单词实际上有单词使用了\\(N-2\\)个字母，因此需要减去\\(f_{N,M}(N-2)\\)的情况，而使用\\(N-3\\)个字母的单词被重复减去了，需要加上……\r\n最终，\\(I\\)可以写成：\r\n\\[I(N,M)=\\sum_{i=0}^{N-1}(-1)^{N-1-i}\\cdot\r\nf_{N,M}(i)\\]\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=10000000;const ll M=1000000000000;ll mod=1000000007;ll fac[N+4],inv[N+4],finv[N+4];ll C(int n,int m)&#123;    return fac[n]*finv[n-m]%mod*finv[m]%mod;&#125;ll qpow(ll n,ll m)&#123;    m%=mod-1;    ll a=1;    for(;m;m&gt;&gt;=1)&#123;        if(m&amp;1) a=a*n%mod;        n=n*n%mod;    &#125;    return a;&#125;int main()&#123;    fac[0]=fac[1]=inv[1]=finv[0]=finv[1]=1;    for(int i=2;i&lt;=N;i++)&#123;        fac[i]=fac[i-1]*i%mod;        inv[i]=(mod-mod/i)*inv[mod%i]%mod;        finv[i]=finv[i-1]*inv[i]%mod;    &#125;    ll ans=0;    for(int i=N-1,f=1;i&gt;=0;i--,f=-f)&#123;        if(i==0) ans+=f;        else if(i==1) ans+=(M+1)%mod*N%mod*f;        else ans+=C(N,i)*(qpow(i,M+1)-1)%mod*inv[i-1]%mod*f;    &#125;    ans=(ans%mod+mod)%mod;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["容斥原理"]},{"title":"Project Euler 650","url":"/project-euler/650/","content":"\r\nProject Euler 650\r\n题目\r\nDivisors of Binomial Product\r\nLet \\(B(n) = \\displaystyle \\prod_{k=0}^n {n\r\n\\choose k}\\), a product of binomial coefficients.\r\nFor example, \\(B(5) = {5 \\choose 0} \\times\r\n{5 \\choose 1} \\times {5 \\choose 2}  \\times {5 \\choose 3} \\times {5\r\n\\choose 4} \\times {5 \\choose 5} = 1 \\times 5 \\times 10 \\times 10 \\times\r\n5 \\times 1 = 2500\\).\r\nLet \\(D(n) = \\displaystyle \\sum_{d\\mid\r\nB(n)} d\\), the sum of the divisors of \\(B(n)\\).\r\nFor example, the divisors of \\(B(5)\\) are \\(1,\r\n2, 4, 5, 10, 20, 25, 50, 100, 125, 250, 500, 625, 1250\\) and\r\n\\(2500\\),\r\nso \\(D(5) = 1 + 2 + 4 + 5 + 10 + 20 + 25 +\r\n50 + 100 + 125 + 250 + 500 + 625 + 1250 + 2500 = 5467\\).\r\nLet \\(S(n) = \\displaystyle \\sum_{k=1}^n\r\nD(k)\\).\r\nYou are given \\(S(5) = 5736\\), \\(S(10) = 141740594713218418\\) and \\(S(100) \\bmod 1\\,000\\,000\\,007 =\r\n332792866\\).\r\nFind \\(S(20\\,000) \\bmod\r\n1\\,000\\,000\\,007\\).\r\n解决方案\r\n根据组合数的定义，不难计算出\r\n\\[B(n)=\\dfrac{(n!)^{n+1}}{\\prod_{i=0}^n\r\n(i!)^2}\\]\r\n那么，不难将\\(B(n)\\)可以写成一个递推式：\r\n\\[B(n)=B(n-1)\\cdot\r\n\\dfrac{n^n}{n!}\\]\r\n直接维护\\(B(n)\\)的分解质因数\\(B(n)=p_1^{e_1}\\cdot p_2^{e_2}\\cdot\r\np_1^{e_3}\\dots\\)中\\(e_1,e_2,e_3\\dots\\)的值。每一次求好之后利用因数和定理\\(\\sigma(B(n))=\\prod\\dfrac{p_i^{e_i+1}-1}{p_i-1}\\)和快速幂算法进行计算。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=20000;bool vis[N+4];int p[24],e[24],o=0;int pr[N/10+1000],m=0;ll mod=1e9+7;void fact(int n)&#123;    o=0;    for(int i=1;i&lt;=m&amp;&amp;pr[i]*pr[i]&lt;=n;i++)        if(n%pr[i]==0)&#123;            p[++o]=pr[i];e[o]=0;            for(;n%pr[i]==0;n/=pr[i],++e[o]);        &#125;    if(n!=1)&#123;        p[++o]=n;e[o]=1;    &#125;&#125;ll qpow(ll n,ll m)&#123;    ll a=1;    for(;m;m&gt;&gt;=1)&#123;        if(m&amp;1) a=a*n%mod;        n=n*n%mod;    &#125;    return a;&#125;int fac_fact[N+4],now_fact[N+4];ll inv_p_1[N+4];int main()&#123;    for(int i=2;i&lt;=N;i++)&#123;        if(vis[i]) continue;        pr[++m]=i;        for(ll j=1ll*i*i;j&lt;=N;j+=i)            vis[j]=true;    &#125;    for(int i=1;i&lt;=m;i++)        inv_p_1[pr[i]]=qpow(pr[i]-1,mod-2);    ll ans=0;    for(int i=1;i&lt;=N;i++)&#123;        fact(i);        for(int j=1;j&lt;=o;j++) &#123;            fac_fact[p[j]]+=e[j];            now_fact[p[j]]+=e[j]*i;        &#125;        ll s=1;        for(int j=1;j&lt;=m&amp;&amp;pr[j]&lt;=i;j++)&#123;            now_fact[pr[j]]-=fac_fact[pr[j]];            s=s*(qpow(pr[j],now_fact[pr[j]]+1)-1)%mod*inv_p_1[pr[j]]%mod;        &#125;        ans=(ans+s)%mod;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 655","url":"/project-euler/655/","content":"\r\nProject Euler 655\r\n题目\r\nDivisible Palindromes\r\nThe numbers \\(545\\), \\(5\\,995\\) and \\(15\\,151\\) are the three smallest\r\npalindromes divisible by \\(109\\). There are nine palindromes less than\r\n\\(100\\,000\\) which are divisible by\r\n\\(109\\).\r\nHow many palindromes less than \\(10^{32}\\) are divisible by \\(10\\,000\\,019\\,\\) ?\r\n解决方案\r\n令\\(N=32,P=10000019\\)。考虑使用动态规划解决本题。\r\n为了减少时间复杂度，本题将考虑有前导\\(0\\)的情况。也就是说，如果需要求\\(N=7\\)以内的情况，那么一个\\(3\\)位的回文数前后将会各自补充两个零，从而形成\\(7\\)位的情况。这种方法只有当满足\\(\\gcd(P,10)=1\\)时才使用。\r\n我们考虑将回文数的对应两个数位“捆绑”在一起，然后将它们的系数放入数组\\(c\\)中。也就是说，\\(c=[10^0+10^{N-1},10^1+10^{N-2},\\dots,10^i+10^{N-i-1}]\\)。如果\\(N\\)还是一个奇数，那么还需要再将\\(10^{\\frac{N-1}{2}}\\)放入\\(c\\)中。那么，对于一个数位\\(d_1,d_2,\\dots,d_{m}\\in[0,9]\\)，\\(\\sum_{i=1}^{m} c[i]\\cdot\r\nd_i\\)将会组合出一个个\\(N\\)位有前导\\(0\\)回文数。\r\n令数组\\(c\\)的长度为\\(M\\)，也就是有\\(M=\\left\\lfloor\\dfrac{N+1}{2}\\right\\rfloor\\)。令状态\\(f(i,j)(0\\le i\\le M,0 \\le j&lt;\r\nP)\\)表示当前使用了\\(c\\)数组中前\\(i\\)个系数，组合出了模\\(P\\)为\\(j\\)的数的个数。不难写出\\(f\\)的状态转移方程为：\r\n\\[\r\nf(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1 &amp; &amp; \\text{if}\\quad  i=1\\land j=0 \\\\\r\n  &amp;0 &amp; &amp; \\text{else if}\\quad  i=1 \\\\\r\n  &amp;\\sum_{d=0}^9\\sum_{(k+c[i]\\cdot d)\\%p=j} f(i-1,k) &amp; &amp;\r\n\\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n那么\\(f(i,j)\\)就代表了\\(i,i-2,i-4,\\dots\\)位无前导\\(0\\)且模\\(P\\)为\\(j\\)的回文数个数。\r\n最终答案为\\(f(M,0)+f(M-1,0)\\)。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int P=10000019;const int N=32;int pw[N+4];ll f[2][P];int con[N+4],m=0;ll solve(int n)&#123;    m=0;    for(int i=0;i&lt;n/2;i++)        con[m++]=pw[i]+pw[n-1-i];    if(n&amp;1) con[m++]=pw[n/2];    memset(f[0],0,sizeof(f[0]));    f[0][0]=1;    for(int i=0,p=0;i&lt;m;i++,p^=1)&#123;        memset(f[p^1],0,sizeof(f[p^1]));        for(int j=0;j&lt;P;j++)&#123;            if(f[p][j]==0) continue;            for(int k=0;k&lt;10;k++)                f[p^1][(j+con[i]*k)%P]+=f[p][j];        &#125;    &#125;    return f[m&amp;1][0]-1;&#125;int main()&#123;    pw[0]=1;    for(int i=1;i&lt;=N;i++)        pw[i]=pw[i-1]*10%P;    ll ans=solve(N)+solve(N-1);    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 659","url":"/project-euler/659/","content":"\r\nProject Euler 659\r\n题目\r\nLargest prime\r\nConsider the sequence \\(n^2+3\\) with\r\n\\(n \\ge 1\\). If we write down the first\r\nterms of this sequence we get:\r\n\\(4, 7, 12, 19, 28, 39, 52, 67, 84, 103,\r\n124, 147, 172, 199, 228, 259, 292, 327, 364,\\dots.\\)\r\nWe see that the terms for \\(n=6\\)\r\nand \\(n=7\\) (\\(39\\) and \\(52\\)) are both divisible by \\(13\\).\r\nIn fact \\(13\\) is the largest prime\r\ndividing any two successive terms of this sequence.\r\nLet \\(P(k)\\) be the largest prime\r\nthat divides any two successive terms of the sequence \\(n^2+k^2\\).\r\nFind the last \\(18\\) digits of \\(\\displaystyle \\sum_{k=1}^{10\\,000\\,000}\r\nP(k)\\).\r\n解决方案\r\n根据题意，所求质数\\(p\\)必须保证存在\\(n\\)，使得下式成立：\r\n\\[\r\n\\left \\{\\begin{aligned}\r\n&amp; n^2+k^2\\equiv 0 &amp;\\pmod p \\qquad(1)\\\\\r\n&amp; (n+1)^2+k^2\\equiv 0 &amp;\\pmod p \\qquad(2)\r\n\\end{aligned}\\right.\r\n\\]\r\n对\\((2)\\)减去\\((1)\\)，得到\\(2n\\equiv -1\\pmod p\\)。\r\n对式子两边进行平方，得到\\(4n^2\\equiv 1\\pmod\r\np\\)。\r\n将式子和\\((1)\\)重新联立，消去\\(n\\)，得到\\(4k^2+1\\equiv 0 \\pmod p\\)。\r\n也就是说，\\(P(k)\\)为\\(4k^2+1\\)的最大质因数。\r\n最终采用和216题类似的筛法计算\\(P(k)\\)：如果\\(p\\mid P(k)\\)，那么\\(p\\mid P(tp\\pm k)\\)。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=10000000;ll mod=1000000000000000000;ll f[N+4],a[N+4];int main()&#123;    for(int n=1;n&lt;=N;n++)        f[n]=4ll*n*n+1;    for(int n=1;n&lt;=N;n++)&#123;        ll p=f[n];        if(p==1) continue;        a[n]=max(a[n],p);        for(ll j=p+n;j&lt;=N;j+=p)&#123;            a[j]=max(a[j],p);            while(f[j]%p==0) f[j]/=p;        &#125;        for(ll j=p-n;j&lt;=N;j+=p)&#123;            a[j]=max(a[j],p);            while(f[j]%p==0) f[j]/=p;        &#125;    &#125;    ll ans=0;    for(int i=1;i&lt;=N;i++)        ans=(ans+a[i])%mod;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 662","url":"/project-euler/662/","content":"\r\nProject Euler 662\r\n题目\r\nFibonacci paths\r\nAlice walks on a lattice grid. She can step from one lattice point\r\n\\(A (a,b)\\) to another \\(B (a+x,b+y)\\) providing distance \\(AB = \\sqrt{x^2+y^2}\\) is a Fibonacci number\r\n\\(\\{1,2,3,5,8,13,\\ldots\\}\\) and \\(x\\ge 0,\\) \\(y\\ge\r\n0\\).\r\nIn the lattice grid below Alice can step from the blue point to any\r\nof the red points.\r\n\r\nLet \\(F(W,H)\\) be the number of\r\npaths Alice can take from \\((0,0)\\) to\r\n\\((W,H)\\).\r\nYou are given \\(F(3,4) = 278\\) and\r\n\\(F(10,10) = 215846462\\).\r\nFind \\(F(10\\,000,10\\,000) \\bmod\r\n1\\,000\\,000\\,007\\).\r\n解决方案\r\n这道题目可以使用非常直接的动态规划思想解决。\r\n那么假设\\(N=M=10000\\)首先可以将所有移动单次移动步骤\\((x,y)\\)预处理出来，其中\\(x^2+y^2\\)是一个斐波那契数，\\(x^2+y^2\\le\r\nN^2+M^2\\)，在这个数据范围下，一共有\\(D=88\\)个移动步骤。\r\n令状态\\(f(i,j)(0\\le i\\le N,0\\le j\\le\r\nM)\\)为从点\\((0,0)\\)到点\\((i,j)\\)的路线数量，那么不难写出如下状态转移方程：\r\n\\[f(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad  i=0\\land j=0 \\\\\r\n  &amp;\\sum_{x,y,x\\le i,y\\le j} f(i-x,j-y)&amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n那么最终答案就是\\(f(N,M)\\)。\r\n但是，直接用代码描述这个方程的转移过程会非常慢，因为时间复杂度为\\(O(N\\cdot M\\cdot D)\\)，运行过程极慢。\r\n以下对程序的优化参考了Thread的一些内容。\r\n观察上面的过程，可以发现，直接进行状态转移时，依次访问的位置\\(f(i-x,j-y)\\)是毫无顺序的，这时内存的访问并不连续。非顺序访存将导致程序效率大大降低（如缓存总是被刷新等等）。\r\n那么，将数组每一列进行错开，数组中，以\\(f[i+j][i]\\)表示状态\\(f(i,j)\\)的值。转移时，先枚举坐标之和\\(t=i+j\\)，再枚举某个方向\\((x,y)\\)，然后从坐标之和为\\(t-x-y\\)处的点按顺序转移到坐标之和为\\(t\\)的点，从而达到顺序访存的目的（具体实现见代码）。\r\n代码\r\n这份代码是优化之前的，速度比较慢。\r\n#include &lt;bits/stdc++.h&gt;# define pi pair&lt;int,int&gt;typedef long long ll;using namespace std;const int N=10000,M=10000;vector&lt;pi&gt;v;vector&lt;int&gt;fib;ll f[N+M+1][M+1],mod=1e9+7;int main()&#123;    int a=1,b=2;    for(;a*a&lt;=N*N+M*M;)&#123;        int c=a+b;        fib.push_back(a);        a=b;b=c;    &#125;    for(int d:fib)&#123;        for(int x=0;x&lt;=N&amp;&amp;x*x&lt;=d*d;x++)&#123;            int y=int(sqrt(d*d-x*x)+1e-9);            if(y&lt;=M&amp;&amp;x*x+y*y==d*d)&#123;                v.push_back(pi(x,y));            &#125;        &#125;    &#125;    sort(v.begin(),v.end());    f[0][0]=1;    for(int i=0;i&lt;=N;i++)        for(int j=0;j&lt;=M;j++)&#123;            if(i==0&amp;&amp;j==0) continue;            if(i&gt;j&amp;&amp;i&lt;=M) f[i][j]=f[j][i];            else&#123;                for(auto &amp;[dx,dy]:v)&#123;                    if(dx&gt;i) break;                    if(dy&lt;=j)&#123;                        f[i][j]+=f[i-dx][j-dy];                        if(f[i][j]&gt;=mod) f[i][j]-=mod;                    &#125;                &#125;            &#125;        &#125;    ll ans=f[N][M];    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n这份代码是优化之后的，运行时间大概是原来的\\(\\dfrac{1}{4}\\)。\r\n#include &lt;bits/stdc++.h&gt;# define pi pair&lt;int,int&gt;typedef long long ll;using namespace std;const int N=10000,M=10000;vector&lt;pi&gt;v;vector&lt;int&gt;fib;ll f[N+M+1][M+1],mod=1e9+7;int main()&#123;    int a=1,b=2;    for(;a*a&lt;=N*N+M*M;)&#123;        int c=a+b;        fib.push_back(a);        a=b;b=c;    &#125;    for(int d:fib)&#123;        for(int x=0;x&lt;=N&amp;&amp;x*x&lt;=d*d;x++)&#123;            int y=int(sqrt(d*d-x*x)+1e-9);            if(y&lt;=M&amp;&amp;x*x+y*y==d*d)&#123;                v.push_back(pi(x,y));            &#125;        &#125;    &#125;    f[0][0]=1;    for(int t=0;t&lt;=N+M;t++)&#123;        int x_min=max(0,t-M),x_max=min(N,t);        for(auto &amp;[dx,dy]:v)&#123;            int s=t-dx-dy;            if(s&lt;0) continue;            for(int j=max(dx,x_min);j&lt;=x_max;j++)                f[t][j]+=f[s][j-dx];        &#125;        for(int j=x_min;j&lt;=x_max;j++)            f[t][j]%=mod;    &#125;    ll ans=f[N+M][N];    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 66","url":"/project-euler/66/","content":"\r\nProject Euler 66\r\n题目\r\nDiophantine equation\r\nConsider quadratic Diophantine equations of the form:\r\n\\[x^2 – Dy^2 = 1\\]\r\nFor example, when \\(D=13\\), the\r\nminimal solution in \\(x\\) is \\(649^2 – 13×180^2 = 1\\).\r\nIt can be assumed that there are no solutions in positive integers\r\nwhen D is square.\r\nBy finding minimal solutions in \\(x\\) for \\(D =\r\n\\{2, 3, 5, 6, 7\\}\\), we obtain the following:\r\n\\[\\begin{aligned}\r\n3^2 – 2×2^2 = 1 \\\\\r\n2^2 – 3×1^2 = 1 \\\\\r\n9^2 – 5×4^2 = 1 \\\\\r\n5^2 – 6×2^2 = 1 \\\\\r\n8^2 – 7×3^2 = 1 \\\\\r\n\\end{aligned}\\]\r\nHence, by considering minimal solutions in \\(x\\) for \\(D \\leq\r\n7\\), the largest \\(x\\) is\r\nobtained when \\(D=5\\).\r\nFind the value of \\(D \\leq 1000\\) in\r\nminimal solutions of \\(x\\) for which\r\nthe largest value of \\(x\\) is\r\nobtained.\r\n解决方案\r\nmathworld wolfram上介绍的关于佩尔方程\\(x^2-Dy^2=1\\)的一组特解的解法基于连分数解决（此处假设\\(D\\)为非平方整数）。\r\n设\\(\\sqrt{N}\\)产生的连分数序列表示成\\([a_0;(a_1,a_2,\\dots,a_n)]\\)，其中\\(a_n=2a_0\\)。\r\n那么计算\\(\\sqrt{N}\\)的连分数序列算法已在64题中的提到的维基百科页面给出：\r\n\\(\\begin{aligned}\r\nm_0 &amp;=0 \\\\\r\nd_0 &amp;= 1 \\\\\r\na_0&amp;=\\lfloor\\sqrt {S}\\rfloor \\\\\r\nm_{n+1}&amp;=d_na_n-m_n \\\\\r\nd_{n+1}&amp;=\\dfrac{S-m_{n+1}^2}{d_n}\\\\\r\na_{n+1}&amp;=\\left\\lfloor\\dfrac{a_0+m_{n+1}}{d_{n+1}}\\right\\rfloor\r\n\\end{aligned}\\)\r\n网站上提到，为计算\\(x^2-Dy^2=1\\)，假设\\(\\sqrt{N}\\)产生的第\\(m\\)个连分数\\([a_0,a_1,\\dots,a_m]\\)的分数形式为\\(\\dfrac{p_m}{q_m}\\)。\r\n那么如果连分数周期\\(n\\)为偶数，\\(x^2-Dy^2=1\\)的最小特解为\\((p_{n-1},q_{n-1})\\)。\r\n否则，\\(x^2-Dy^2=1\\)的最小特解为\\((p_{2n-1},q_{2n-1})\\)。\r\n直接使用这一些结论进行计算。\r\n另外，假设该最小特解为\\((x_1,y_1)\\)，那么佩尔方程的通解\\((x_k,y_k)\\)可以由以下结果导出：\r\n\\[x_k+y_k\\sqrt{D}=(x_1+y_1\\sqrt{D})^k\\]\r\n即有关于\\((x_k,y_k)\\)两个序列的递推式： \\[\r\n\\left \\{\\begin{aligned}\r\n  &amp; x_{k+1}=x_1x_k+Dy_1y_k\\\\\r\n  &amp; y_{k+1}=x_1y_k+y_1x_k\r\n\\end{aligned}\\right.\r\n\\]\r\n代码\r\nfrom fractions import Fractionfrom tools import int_sqrt, is_squareN = 1000ans, mx = 0, 0for D in range(1, N + 1):    if is_square(D):        continue    m = 0    d = 1    a0 = int(int_sqrt(D))    ls = [a0]    a = a0    tm = 0    while a != 2 * a0:        m = d * a - m        d = (D - m * m) // d        a = (a0 + m) // d        tm += 1        ls.append(a)    if tm % 2 == 0:        t = ls[:-1][::-1]    else:        t = (ls + ls[1:-1])[::-1]    w = Fraction(t[0])    for i in range(1, len(t)):        w = 1 / w + t[i]    x, y = w.numerator, w.denominator    if x &gt; mx:        mx = x        ans = Dprint(ans)\r\n","categories":["Project Euler"],"tags":["佩尔方程"]},{"title":"Project Euler 65","url":"/project-euler/65/","content":"\r\nProject Euler 65\r\n题目\r\nConvergents of \\(e\\)\r\nThe square root of \\(2\\) can be\r\nwritten as an infinite continued fraction.\r\n\\(\\sqrt{2} = 1 + \\dfrac{1}{2 + \\dfrac{1}{2\r\n+ \\dfrac{1}{2 + \\dfrac{1}{2 + \\dots}}}}\\)\r\nThe infinite continued fraction can be written, \\(\\sqrt{2} = [1; (2)]\\), \\((2)\\) indicates that 2 repeats ad\r\ninfinitum. In a similar way, \\(\\sqrt{23}\r\n= [4; (1, 3, 1, 8)]\\).\r\nIt turns out that the sequence of partial values of continued\r\nfractions for square roots provide the best rational approximations. Let\r\nus consider the convergents for \\(\\sqrt{2}\\).\r\n$1 + = $ \\(1 + \\dfrac{1}{2 + \\dfrac{1}{2}}\r\n= \\dfrac{7}{5}\\) \\(1 + \\dfrac{1}{2 +\r\n\\dfrac{1}{2 + \\dfrac{1}{2}}} = \\dfrac{17}{12}\\) \\(1 + \\dfrac{1}{2 + \\dfrac{1}{2 + \\dfrac{1}{2 +\r\n\\dfrac{1}{2}}}} = \\dfrac{41}{29}\\)\r\nHence the sequence of the first ten convergents for \\(\\sqrt{2}\\) are:\r\n\\(1, \\dfrac{3}{2}, \\dfrac{7}{5},\r\n\\dfrac{17}{12}, \\dfrac{41}{29}, \\dfrac{99}{70}, \\dfrac{239}{169},\r\n\\dfrac{577}{408}, \\dfrac{1393}{985}, \\dfrac{3363}{2378},\r\n...\\)\r\nWhat is most surprising is that the important mathematical\r\nconstant,\\(e = [2; 1, 2, 1, 1, 4, 1, 1, 6, 1,\r\n\\dots , 1, 2k, 1, \\dots]\\).\r\nThe first ten terms in the sequence of convergents for \\(e\\) are:\r\n\\(2, 3, \\dfrac{8}{3}, \\dfrac{11}{4},\r\n\\dfrac{19}{7}, \\dfrac{87}{32}, \\dfrac{106}{39}, \\dfrac{193}{71},\r\n\\dfrac{1264}{465}, \\dfrac{1457}{536}, ...\\)\r\nThe sum of digits in the numerator of the \\(10^{\\text{th}}\\) convergent is \\(1 + 4 + 5 + 7 = 17\\).\r\nFind the sum of digits in the numerator of the \\(100 ^{\\text{th}}\\) convergent of the\r\ncontinued fraction for \\(e\\).\r\n解决方案\r\n假设连分数序列为\\(a\\)，那么根据连分数的产生规则，第\\(n\\)个逼近值\\(b_{n,1}\\)如下构造：\r\n\\[b_{n,i}=\r\n\\left \\{\\begin{aligned}\r\n  &amp;a_n  &amp; &amp; \\text{if}\\quad i=n \\\\\r\n  &amp;a_i+\\dfrac{1}{b_{n,i+1}} &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n直接使用分数进行模拟即可。\r\n代码\r\nfrom fractions import FractionN = 100a = [2]v = 0for i in range(1, N + 1):    a += [1, 2 * i, 1]t = a[:N][::-1]w = Fraction(t[0])for i in range(1, len(t)):    w = 1 / w + t[i]ans = sum(int(x) for x in str(w.numerator))print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 663","url":"/project-euler/663/","content":"\r\nProject Euler 663\r\n题目\r\nSums of subarrays\r\nLet \\(t_k\\) be the\r\ntribonacci numbers defined as:\r\n\\(\\begin{aligned}\r\n&amp;\\quad t_0 = t_1 = 0;\\\\\r\n&amp;\\quad t_2 = 1; \\\\\r\n&amp;\\quad t_k = t_{k-1} + t_{k-2} + t_{k-3} \\quad \\text{   for   }  k\r\n\\ge 3\r\n\\end{aligned}\\)\r\nFor a given integer \\(n\\), let \\(A_n\\) be an array of length \\(n\\) (indexed from \\(0\\) to \\(n-1\\)), that is initially filled with\r\nzeros.\r\nThe array is changed iteratively by replacing \\(A_n[(t_{2 i-2} \\text{ mod } n)]\\) with\r\n\\(A_n[(t_{2 i-2} \\text{ mod } n)]+2 (t_{2 i-1}\r\n\\text{ mod } n)-n+1\\) in each step \\(i\\).\r\nAfter each step \\(i\\), define \\(M_n(i)\\) to be \\(\\displaystyle \\max\\{\\sum_{j=p}^q A_n[j]: 0\\le p\\le\r\nq&lt;n\\}\\), the maximal sum of any contiguous subarray of \\(A_n\\).\r\nThe first 6 steps for \\(n=5\\) are\r\nillustrated below:\r\nInitial state: \\(\\,\r\nA_5=\\{0,0,0,0,0\\}\\)\r\nStep \\(1:\\quad \\Rightarrow\r\nA_5=\\{-4,0,0,0,0\\}\\) , \\(M_5(1)=0\\)\r\nStep \\(2:\\quad \\Rightarrow A_5=\\{-4, -2, 0,\r\n0, 0\\}\\) , \\(M_5(2)=0\\)\r\nStep \\(3:\\quad \\Rightarrow A_5=\\{-4, -2, 4,\r\n0, 0\\}\\) , \\(M_5(3)=4\\)\r\nStep \\(4:\\quad \\Rightarrow A_5=\\{-4, -2, 6,\r\n0, 0\\}\\) , \\(M_5(4)=6\\)\r\nStep \\(5:\\quad \\Rightarrow A_5=\\{-4, -2, 6,\r\n0, 4\\}\\) , \\(M_5(5)=10\\)\r\nStep \\(6:\\quad \\Rightarrow A_5=\\{-4, 2, 6,\r\n0, 4\\}\\) , \\(M_5(6)=12\\)\r\nLet \\(\\displaystyle S(n,l)=\\sum_{i=1}^l\r\nM_n(i)\\). Thus \\(S(5,6)=32\\).\r\nYou are given \\(S(5,100)=2416\\),\r\n\\(S(14,100)=3881\\) and \\(S(107,1000)=1618572\\).\r\nFind \\(S(10\\,000\\,003,10\\,200\\,000)-S(10\\,000\\,003,10\\,000\\,000)\\).\r\n线段树\r\n线段树是一种用于维护区间内的数的一些计算结果，这些计算需要满足结合律（如加法，乘法，最小值，最大值）。假设这个序列为\\(a\\)，长度为\\(L\\)。它有以下特点：\r\n\r\n树的每个节点都代表一个区间的统计结果。\r\n根节点代表着整个区间\\([1,L]\\)，每个叶节点代表着某一个长度为\\(1\\)的区间\\([i,i]\\)。\r\n如果当前节点代表的区间为\\([L,R]\\)，那么左子节点代表的区间是\\([L,M]\\)，右子节点是\\([M+1,R]\\)，其中\\(M=\\left\\lfloor\\dfrac{L+R}{2}\\right\\rfloor\\)。\r\n\r\n线段树的三个操作：\r\n\r\n建树（初始化）。给定一个序列，自底向上地建立出一颗线段树。当两个子节点的信息维护好时，当前节点的信息也能迅速维护好。单次操作仅需要\\(O(L)\\)的时间复杂度。建树一旦完成，以后就不需要进行操作了。\r\n修改。从根节点往下搜索，递归找到需要修改的整个区间。修改完成后，再自底向上更新所有祖先节点的信息。单次操作仅需要\\(O(\\log L)\\)的时间复杂度。\r\n查询。从根节点往下搜索，如果查询的区间覆盖了当前整个区间，那么直接返回当前节点的信息；如果查询的区间和左/右子节点有交集，那么递归查询后，将结果合并。最终向上传递。单次操作也仅需要\\(O(\\log L)\\)的时间复杂度。\r\n\r\n因此，维护好各个节点，可以以高效的方式维护出需要结果的值。\r\n解决方案\r\n考虑使用线段树解决本题。每个节点\\(p\\)所代表的区间\\([L,R]\\)需要维护四个信息：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\\(\\text{dat}\\)\r\n\\(\\max_{L\\le l\\le r\\le R} \\sum_{i=l}^r\r\na[i]\\)，也就是题目中所需要求的值\r\n\r\n\r\n\\(\\text{lmax}\\)\r\n\\(\\max_{L\\le k\\le R} \\sum_{i=L}^k\r\na[i]\\)，也就是最大前缀和\r\n\r\n\r\n\\(\\text{rmax}\\)\r\n\\(\\max_{L\\le k\\le R} \\sum_{i=k}^R\r\na[i]\\)，也就是最大后缀和\r\n\r\n\r\n\\(\\text{sum}\\)\r\n\\(\\sum_{i=L}^R\r\na[i]\\)，也就是区间内的所有数之和\r\n\r\n\r\n\r\n那么，假设\\(p\\)的左右子节点分别为\\(ls,rs\\)，那么这四个属性的自低向上维护方式为：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\\(p.\\text{dat}=\\max(ls.\\text{dat},rs.\\text{dat},ls.\\text{rmax}+rs.\\text{lmax})\\)\r\n这说明当前区间的答案要么是取自左子节点，要么是取自右子节点；要么是左子节点的最大后缀进和与右子节点的最大前缀和合并形成一个新的答案。\r\n\r\n\r\n\\(p.\\text{lmax}=\\max(ls.\\text{lmax},ls.\\text{sum}+rs.\\text{lmax})\\)\r\n这说明当前区间的最大前缀和要么是来自左子节点的最大前缀和，要么是左子节点的整个区间和右子节点的最大前缀和合并形成当前区间的前缀。\r\n\r\n\r\n\\(p.\\text{rmax}=\\max(rs.\\text{rmax},rs.\\text{sum}+ls.\\text{rmax})\\)\r\n与最大前缀和类似。\r\n\r\n\r\n\\(p.\\text{sum}=ls.\\text{sum}+rs.\\text{sum}\\)\r\n\r\n\r\n\r\n\r\n其它仅需要遵循线段树的模式即可。\r\n代码\r\n第一份代码，严格在线段树上执行了计算\\(S(n,l)\\)时的各种操作，包括一开始建树，并且每次更新后计算所需要的结果。时间复杂度为\\(O(n\\log\r\nl)\\)。并且执行了两次，效率非常低。\r\n第二份代码，则减少了一部分没有必要的工作。由于计算的\\(n\\)相同，并且前\\(10000000\\)次操作的结果都被减去了。那么我们一开始先不建树，等前\\(10000000\\)次修改完成了，再建树。由于这个时候是直接对序列进行修改，时间复杂度为\\(O(1)\\)，忽略不计。建树完成后，再进行\\(200000\\)次的询问和记录答案操作。总体时间复杂度为\\(O(l+(l-n)\\log l)\\)。\r\n# include &lt;bits/stdc++.h&gt;# define ls p&lt;&lt;1# define rs p&lt;&lt;1|1using namespace std;typedef long long ll;const int N=10000003;const int L=10000000;const int R=10200000;ll INF = 0x3f3f3f3f3f3f3f3f;struct ST&#123;    ll sum, lmax, rmax, dat;    int l, r;&#125;t[N &lt;&lt; 2];ll a[N];void init(ST&amp;t, int v) &#123; t.dat=t.lmax=t.rmax=t.sum=v; &#125;void push_up(ST &amp;p,ST &amp;l,ST &amp;r)&#123;    p.sum=l.sum+r.sum;    p.lmax=max(l.lmax,l.sum+r.lmax);    p.rmax=max(r.rmax,r.sum+l.rmax);    p.dat=max(l.rmax+r.lmax,max(l.dat,r.dat));&#125;void build(int p, int l, int r)&#123;    t[p].l = l, t[p].r = r;    if (l == r)&#123;        init(t[p],a[l]);        return;    &#125;    int mid = (l + r) &gt;&gt; 1;    build(ls, l, mid); build(rs, mid + 1, r);    push_up(t[p],t[ls],t[rs]);&#125;void update(int p, int x, int v)&#123;    if (t[p].l == t[p].r) &#123;        init(t[p], t[p].dat+v);        return;    &#125;    int mid = (t[p].l + t[p].r) &gt;&gt; 1;    if (x &lt;= mid) update(ls, x, v);    else update(rs, x, v);    push_up(t[p],t[ls],t[rs]);&#125;ST que(int p, int l, int r)&#123;    if (l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r) return t[p];    int mid = (t[p].l + t[p].r) &gt;&gt; 1;    if(r&lt;=mid) return que(ls,l,r);    if(l&gt;mid) return que(rs,l,r);    ST left=que(ls,l,r),right=que(rs,l,r),res;    push_up(res,left,right);    return res;&#125;int t0,t1,t2;int gen()&#123;    int x=t0,k=(t0+t1+t2)%N;    t0=t1;t1=t2;t2=k;    return x;&#125;ll S(int N,int M)&#123;    memset(t,0,sizeof(t));    t0=t1=0;t2=1;    ll ans=0;    build(1,0,N-1);    for(int i=1;i&lt;=M;i++)&#123;        int p=gen();        int d=gen()*2-N+1;        update(1,p,d);        ans+=que(1,0,N-1).dat;    &#125;    return ans;&#125;int main()&#123;    printf(&quot;%lld\\n&quot;,S(N,R)-S(N,L));&#125;\r\n# include &lt;bits/stdc++.h&gt;# define ls p&lt;&lt;1# define rs p&lt;&lt;1|1using namespace std;typedef long long ll;const int N=10000003;const int L=10000000;const int R=10200000;ll INF = 0x3f3f3f3f3f3f3f3f;struct ST&#123;    ll sum, lmax, rmax, dat;    int l, r;&#125;t[N &lt;&lt; 2];ll a[N];void init(ST&amp;t, int v) &#123; t.dat=t.lmax=t.rmax=t.sum=v; &#125;void push_up(ST &amp;p,ST &amp;l,ST &amp;r)&#123;    p.sum=l.sum+r.sum;    p.lmax=max(l.lmax,l.sum+r.lmax);    p.rmax=max(r.rmax,r.sum+l.rmax);    p.dat=max(l.rmax+r.lmax,max(l.dat,r.dat));&#125;void build(int p, int l, int r)&#123;    t[p].l = l, t[p].r = r;    if (l == r)&#123;        init(t[p],a[l]);        return;    &#125;    int mid = (l + r) &gt;&gt; 1;    build(ls, l, mid); build(rs, mid + 1, r);    push_up(t[p],t[ls],t[rs]);&#125;void update(int p, int x, int v)&#123;    if (t[p].l == t[p].r) &#123;        init(t[p], t[p].dat+v);        return;    &#125;    int mid = (t[p].l + t[p].r) &gt;&gt; 1;    if (x &lt;= mid) update(ls, x, v);    else update(rs, x, v);    push_up(t[p],t[ls],t[rs]);&#125;ST que(int p, int l, int r)&#123;    if (l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r) return t[p];    int mid = (t[p].l + t[p].r) &gt;&gt; 1;    if(r&lt;=mid) return que(ls,l,r);    if(l&gt;mid) return que(rs,l,r);    ST left=que(ls,l,r),right=que(rs,l,r),res;    push_up(res,left,right);    return res;&#125;int t0,t1,t2;int gen()&#123;    int x=t0,k=(t0+t1+t2)%N;    t0=t1;t1=t2;t2=k;    return x;&#125;ll T(int N,int L,int R)&#123;    memset(t,0,sizeof(t));    t0=t1=0;t2=1;    ll ans=0;    for(int i=1;i&lt;=L;i++)&#123;        int p=gen();        int d=gen()*2-N+1;        a[p]+=d;    &#125;    build(1,0,N-1);    for(int i=L+1;i&lt;=R;i++)&#123;        int p=gen();        int d=gen()*2-N+1;        update(1,p,d);        ans+=que(1,0,N-1).dat;    &#125;    return ans;&#125;int main()&#123;    printf(&quot;%lld\\n&quot;,T(N,L,R));&#125;\r\n","categories":["Project Euler"],"tags":["线段树"]},{"title":"Project Euler 668","url":"/project-euler/668/","content":"\r\nProject Euler 668\r\n题目\r\nSquare root smooth Numbers\r\nA positive integer is called square root smooth if all of\r\nits prime factors are strictly less than its square root.\r\nIncluding the number \\(1\\), there\r\nare \\(29\\) square root smooth numbers\r\nnot exceeding \\(100\\).\r\nHow many square root smooth numbers are there not exceeding \\(10\\,000\\,000\\,000\\)?\r\n解决方案\r\n令\\(N=10^{10}\\)。我们考虑这个问题的对立：\\(N\\)以内有多少个数\\(n\\)，满足其最大的质因数\\(p\\)大于等于\\(n\\)的平方根？也就是说，\\(p\\ge\\left\\lfloor\\dfrac{n}{p}\\right\\rfloor\\)。\r\n假设质数集合为\\(P\\)。那么，考虑以每个质数\\(p\\)作为这个最大质因数，分开计算。那么，数\\(p,2p,3p,\\dots,(p-1)p,p^2\\)都是满足要求的数。\r\n因此，题目的答案为\r\n\\[N-\\sum_{p\\in P}\r\n\\min\\left(p,\\left\\lfloor\\dfrac{N}{p}\\right\\rfloor\\right)=N-\\sum_{p\\in\r\nP,p\\le \\sqrt{N}}p-\\sum_{p\\in P,p&gt; \\sqrt{N}}\r\n\\left\\lfloor\\dfrac{N}{p}\\right\\rfloor\\]\r\n对于式子的第二块，直接枚举\\(\\sqrt{N}\\)以内的质数并相加即可。\r\n对于式子的第三块，可以写成：\r\n\\[\\sum_{p\\in P,p&gt; \\sqrt{N}}\r\n\\left\\lfloor\\dfrac{N}{p}\\right\\rfloor=\\sum_{i=2}^{\\lfloor\\sqrt{N}\\rfloor}\\left(\\pi\\left(\\dfrac{N}{i-1}\\right)-\\pi\\left(\\dfrac{N}{i}\\right)\\right)\\cdot(i-1)\\]\r\n其中，\\(\\pi(n)\\)是质数计数函数，即\\(n\\)以内的质数个数。这条式子说明，有\\(\\pi\\left(\\dfrac{N}{i-1}\\right)-\\pi\\left(\\dfrac{N}{i}\\right)\\)个质数\\(p\\)，满足\\(1\\sim\r\nN\\)中有\\(i-1\\)个数是\\(p\\)的倍数，它们的贡献为\\((i-1)\\)。\r\n计算函数\\(\\pi\\)考虑使用Lehmer公式帮助计算。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll N = 10000000000;const ll M = N&lt;=10000?10000:pow(N, 2.0 / 3) + 2;bool vis[M + 1];int sum[M + 1],pr[M + 1],m;unordered_map&lt;ll,ll&gt; mp,mq;ll phi(ll x, ll a) &#123;    if (a == 1 || x == 0)return (x + 1) / 2;    ll &amp;v = mp[(x &lt;&lt; 10) + a];    if (v)return v;    return v = phi(x, a - 1) - phi(x / pr[a], a - 1);&#125;ll pi(ll n) &#123;    if (n &lt;= M)return sum[n];    ll &amp;v = mq[n];    if (v) return v;    ll a = pi(pow(n, 1.0 / 4));    ll b = pi(sqrt(n));    ll c = pi(pow(n, 1.0 / 3));    ll s = phi(n, a) + (b + a - 2) * (b - a + 1) / 2;    for (ll i = a + 1; i &lt;= b; i++) &#123;        ll w = n / pr[i];        s -= pi(w);        ll bi = pi(sqrt(w));        if (i &lt;= c) &#123;            for (ll j = i; j &lt;= bi; j++)                s += j - 1 - pi(w / pr[j]);        &#125;    &#125;    return v = s;&#125;int main() &#123;    clock_t cl = clock();    for (ll i = 2; i &lt;= M; i++) &#123;        if (!vis[i]) &#123;            for (ll j = i * i; j &lt;= M; j += i) vis[j] = 1;            pr[++m] = i;        &#125;        sum[i] = m;    &#125;    ll ans=0;    for(int i=1;i&lt;=m&amp;&amp;1ll*pr[i]*pr[i]&lt;=N;i++)        ans+=pr[i];    for(ll i=2;i*i&lt;=N;i++)        ans+=(pi(N/(i-1))-pi(N/i))*(i-1);    ans=N-ans;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 68","url":"/project-euler/68/","content":"\r\nProject Euler 68\r\n题目\r\nMagic \\(5\\)-gon ring\r\nConsider the following “magic” \\(3\\)-gon ring, filled with the numbers \\(1\\) to \\(6\\), and each line adding to nine.\r\n\r\nWorking clockwise, and starting from the group of\r\nthree with the numerically lowest external node (\\(4,3,2\\) in this example), each solution can\r\nbe described uniquely. For example, the above solution can be described\r\nby the set: \\(4,3,2; 6,2,1;\r\n5,1,3\\).\r\nIt is possible to complete the ring with four different totals: \\(9, 10, 11\\), and \\(12\\). There are eight solutions in\r\ntotal.\r\n\r\n\r\n\r\nTotal\r\nSolution Set\r\n\r\n\r\n\r\n\r\n\\(9\\)\r\n\\(4,2,3; 5,3,1; 6,1,2\\)\r\n\r\n\r\n\\(9\\)\r\n\\(4,3,2; 6,2,1; 5,1,3\\)\r\n\r\n\r\n\\(10\\)\r\n\\(2,3,5; 4,5,1; 6,1,3\\)\r\n\r\n\r\n\\(10\\)\r\n\\(2,5,3; 6,3,1; 4,1,5\\)\r\n\r\n\r\n\\(11\\)\r\n\\(1,4,6; 3,6,2; 5,2,4\\)\r\n\r\n\r\n\\(11\\)\r\n\\(1,6,4; 5,4,2; 3,2,6\\)\r\n\r\n\r\n\\(12\\)\r\n\\(1,5,6; 2,6,4; 3,4,5\\)\r\n\r\n\r\n\\(12\\)\r\n\\(1,6,5; 3,5,4; 2,4,6\\)\r\n\r\n\r\n\r\nBy concatenating each group it is possible to form \\(9\\)-digit strings; the maximum string for a\r\n\\(3\\)-gon ring is \\(432621513\\).\r\nUsing the numbers \\(1\\) to \\(10\\), and depending on arrangements, it is\r\npossible to form \\(16\\)- and \\(17\\)-digit strings. What is the maximum\r\n\\(16\\)-digit string\r\nfor a “magic” \\(5\\)-gon ring?\r\n\r\n解决方案\r\n为每个圈进行编号：\r\n\r\n其中，外圈用\\(0\\sim\r\n4\\)标记，内圈用\\(5\\sim9\\)来标记。\r\n由于输出的是\\(16\\)位数，因此枚举过程中需要排除\\(10\\)在内圈的情况。\r\n最终，枚举全排列，一个个进行判断。\r\n代码\r\nfrom itertools import permutationsa = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]ans = 0for a in permutations(a):    # 外圈最小的在首个，因此确保最小的下标是在0。    # 输出值只能有16位数，因此10只能在外圈。    if min(a[0:5]) != a[0] or 10 in a[5:10]:        continue    if a[0] + a[6] + a[7] == a[1] + a[7] + a[8] == a[2] + a[8] + a[9] == a[3] + a[9] + a[5] == a[4] + a[5] + a[6]:        s = [str(x) for x in a]        t = s[0] + s[6] + s[7] + s[1] + s[7] + s[8] + s[2] + s[8] + s[9] + s[3] + s[9] + s[5] + s[4] + s[5] + s[6]        ans = max(ans, int(t))print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 675","url":"/project-euler/675/","content":"\r\nProject Euler 675\r\n题目\r\n\\(2^{\\omega(n)}\\)\r\nLet \\(\\omega(n)\\) denote the number\r\nof distinct prime divisors of a positive integer \\(n\\).\r\nSo \\(\\omega(1) = 0\\) and \\(\\omega(360) = \\omega(2^{3} \\times 3^{2} \\times 5)\r\n= 3\\).\r\nLet \\(S(n)\\) be \\(\\Sigma_{d \\mid  n} 2^{\\omega(d)}\\).\r\nE.g. \\(S(6) =\r\n2^{\\omega(1)}+2^{\\omega(2)}+2^{\\omega(3)}+2^{\\omega(6)} =\r\n2^0+2^1+2^1+2^2 = 9\\).\r\nLet \\(F(n)=\\Sigma_{i=2}^n\r\nS(i!)\\).\r\n\\(F(10)=4821\\).\r\nFind \\(F(10\\,000\\,000)\\). Give your\r\nanswer modulo \\(1\\,000\\,000\\,087\\).\r\n解决方案\r\n假设\\(n\\)的分解为\\(\\prod_{i=1}^kp_i^{e_i}\\)。\r\n根据\\(\\omega\\)函数的定义，当\\(\\gcd(a,b)=1\\)时，有\\(\\omega(ab)=\\omega(a)+\\omega(b)\\)，并且，\\(\\omega(p_i^{e_i})=1\\).\r\n对于函数\\(S\\)而言，意味着每一项的\\(2^{\\omega(ab)}\\)可以写成\\(2^{\\omega(a)}\\cdot\r\n2^{\\omega(b)}\\)。那么考虑\\(n\\)的某个质因数分量\\(p_i^{e_i}\\)，那么发现，\\(S\\)中的每个和式包含了\\(2^{\\omega(p_i^0)},2^{\\omega(p_i^1)},\\dots,2^{\\omega(p_i^{e_i})}\\)中的某一个项，并且发现这些项跟除\\(2^{\\omega(p_i^j)}\\)以外的所有项都是一一组合。因此考虑将上面的这些项加起来，得到\\((2e_i+1)\\)。\r\n将每个分量进行同样的操作，最终得到\\(S(n)=\\prod_{i=1}^k(2e_i+1)\\)。\r\n由于本题计算的是\\(S(n!)\\)的前缀和，因此从小到大枚举\\(n\\)，并对\\(n\\)进行分解质因数。在整个过程中，用一个数组维护\\(n!\\)的分解质因数的结果，在此过程维护\\(S(n!)\\)的值。对于单独的一个\\(n\\)，如果使用线性逆元，那么维护成本为\\(O(\\log n)\\)。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;# define pi pair&lt;int,int&gt;using namespace std;typedef long long ll;const int N=10000000;const int M=2*N+1;ll mod=1000000087;int pr[N/10+100],v[N+4],m=0;int e[N+4];ll inv[M+4];int a[14],b[14],o=0;void fact(int n)&#123;    o=0;    for(;n!=1;)&#123;        a[++o]=v[n];        b[o]=0;        for(;n%a[o]==0;n/=a[o],++b[o]);    &#125;&#125;int main()&#123;    for(int i=2;i&lt;=N;i++)&#123;        if(v[i]==0) pr[++m]=i,v[i]=i;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;N/i) break;            v[i*pr[j]]=pr[j];        &#125;    &#125;    inv[1]=1;    for(int i=2;i&lt;=M;i++)        inv[i]=(mod-mod/i)*inv[mod%i]%mod;    ll ans=0,v=1;    for(int i=2;i&lt;=N;i++)&#123;        fact(i);        for(int j=1;j&lt;=o;j++)&#123;            v=v*inv[2*e[a[j]]+1]%mod;            e[a[j]]+=b[j];            v=v*(2*e[a[j]]+1)%mod;        &#125;        ans=(ans+v)%mod;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 67","url":"/project-euler/67/","content":"\r\nProject Euler 67\r\n题目\r\nMaximum path sum II\r\nBy starting at the top of the triangle below and moving to adjacent\r\nnumbers on the row below, the maximum total from top to bottom is \\(23\\).\r\n\r\n3 7 4 2\r\n4 6 8 5 9 3\r\n\r\nThat is, \\(3 + 7 + 4 + 9 = 23\\).\r\nFind the maximum total from top to bottom in triangle.txt (right click and\r\n‘Save Link/Target As…’), a 15K text file containing a triangle with\r\none-hundred rows.\r\nNOTE: This is a much more difficult version of Problem 18. It is not possible to try\r\nevery route to solve this problem, as there are \\(2^{99}\\) altogether! If you could check one\r\ntrillion (10^12) routes every second it would take over twenty billion\r\nyears to check them all. There is an efficient algorithm to solve it.\r\n;o)\r\n解决方案\r\n本题的题解和第18题完全一致，只是读入做了改动。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;const int N=15;int t,f[N+4][N+4];int main()&#123;    freopen(&quot;p067_triangle.txt&quot;,&quot;r&quot;,stdin);    for(int i=1;i&lt;=N;i++)    for(int j=1;j&lt;=i;j++)&#123;        scanf(&quot;%d&quot;,&amp;t);        f[i][j]=max(f[i-1][j-1],f[i-1][j])+t;    &#125;    int ans=*max_element(f[N]+1,f[N]+N+1);    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 684","url":"/project-euler/684/","content":"\r\nProject Euler 684\r\n题目\r\nInverse Digit Sum\r\nDefine \\(s(n)\\) to be the smallest\r\nnumber that has a digit sum of \\(n\\).\r\nFor example \\(s(10) = 19\\).\r\nLet \\(\\displaystyle S(k) = \\sum_{n=1}^k\r\ns(n)\\). You are given \\(S(20) =\r\n1074\\).\r\nFurther let \\(f_i\\) be the Fibonacci\r\nsequence defined by \\(f_0=0, f_1=1\\)\r\nand \\(f_i=f_{i-2}+f_{i-1}\\) for all\r\n\\(i \\ge 2\\).\r\nFind \\(\\displaystyle \\sum_{i=2}^{90}\r\nS(f_i)\\). Give your answer modulo \\(1\\,000\\,000\\,007\\).\r\n解决方案\r\n基于贪心思想，\\(s(n)\\)中除了最高位以外，其它位全是\\(9\\)。因此，\\(s(n)\\)的值为如下形式：\\(?999999999\\dots\\)这样保证了\\(s(n)\\)的位数是最小的，并且分配给高位的数是尽量小的。因此，\\(s(n)=10^{\\lfloor\\frac{n}{9}\\rfloor}\\cdot(n\\%9+1)-1\\)。\r\n\\(s(n)\\)中从小到大，每\\(9\\)个数划分成一块，那么不难发现，每一块里面的数都是\\(1999\\dots\\)到\\(9999\\dots\\)，每一块的长度完全一样。\r\n令\\(n=9q+r,0\\le r&lt;9\\)，那么\\(S(n)\\)由以下两部分数组成：\r\n\r\n所有完整的块的数字之和，这一部分数字有\\(q\\)个完整的块，这些完整的块的数之和通过等比数列公式容易求出为\\(6\\times(10^q-1)-9q\\).\r\n最后一块不完整的数之和这些数之和。这些数一共有\\(r\\)个，都是\\(k+1\\)位数。它们的和为\\(\\dfrac{1}{2}r(10^q(r+3)-2)\\)\r\n\r\n两部分加起来，得到:\r\n\\[S(n) = \\left(\\frac{(r+2)(r+1)}{2} +\r\n5\\right)\\cdot 10^q-9q-6-r\\]\r\n代码\r\nN = 90mod = 10 ** 9 + 7f = [0, 1]for i in range(2, N + 1):    f.append(f[-1] + f[-2])ans = 0for w in f[2:]:    q, r = divmod(w, 9)    ans = (ans + ((r + 1) * (r + 2) // 2 + 5) * pow(10, q, mod) - 9 * q - 6 - r) % modprint(ans)\r\n","categories":["Project Euler"],"tags":["贪心"]},{"title":"Project Euler 69","url":"/project-euler/69/","content":"\r\nProject Euler 69\r\n题目\r\nTotient maximum\r\nEuler’s Totient function, \\(\\varphi(n)\\) [sometimes called the phi\r\nfunction], is used to determine the number of numbers less than \\(n\\) which are relatively prime to \\(n\\). For example, as \\(1, 2, 4, 5, 7,\\) and \\(8\\), are all less than nine and relatively\r\nprime to nine, \\(\\varphi(9)=6\\).\r\n\r\n\r\n\r\n\\(n\\)\r\nRelatively Prime\r\n\\(\\varphi(n)\\)\r\n\\(n/\\varphi(n)\\)\r\n\r\n\r\n\r\n\r\n\\(2\\)\r\n\\(1\\)\r\n\\(1\\)\r\n\\(2\\)\r\n\r\n\r\n\\(3\\)\r\n\\(1,2\\)\r\n\\(2\\)\r\n\\(1.5\\)\r\n\r\n\r\n\\(4\\)\r\n\\(1,3\\)\r\n\\(2\\)\r\n\\(2\\)\r\n\r\n\r\n\\(5\\)\r\n\\(1,2,3,4\\)\r\n\\(4\\)\r\n\\(1.25\\)\r\n\r\n\r\n\\(6\\)\r\n\\(1,5\\)\r\n\\(2\\)\r\n\\(3\\)\r\n\r\n\r\n\\(7\\)\r\n\\(1,2,3,4,5,6\\)\r\n\\(6\\)\r\n\\(1.1666\\dots\\)\r\n\r\n\r\n\\(8\\)\r\n\\(1,3,5,7\\)\r\n\\(4\\)\r\n\\(2\\)\r\n\r\n\r\n\\(9\\)\r\n\\(1,2,4,5,7,8\\)\r\n\\(6\\)\r\n\\(1.5\\)\r\n\r\n\r\n\\(10\\)\r\n\\(1,3,7,9\\)\r\n\\(4\\)\r\n\\(2.5\\)\r\n\r\n\r\n\r\nIt can be seen that \\(n=6\\) produces\r\na maximum \\(n/\\varphi(n)\\) for \\(n \\leq 10\\).\r\nFind the value of \\(n \\leq\r\n1,000,000\\) for which \\(n/\\varphi(n)\\) is a maximum.\r\n欧拉函数\r\n如果一个正整数\\(n\\)分解后成为：\r\n\\[n=\\prod_{i=1}^k p_i^{e_i}\\]\r\n那么，欧拉函数值为： \\[\\varphi(n)=n\\prod_{i=1}^k\\left(1-\\dfrac{1}{p_i}\\right)\\]\r\n解决方案\r\n欧拉筛不仅可以用来筛选素数，还可以以\\(O(\\log\r\nn)\\)的时间复杂度计算积性函数的值。\r\n具体过程是，筛选出一个质数\\(p\\)后，遍历其所有倍数\\(i=kp\\)时，可以按照上式，对欧拉函数数组phi进行如此操作：\\(phi[i]:=phi[i] / p \\times (p-1)\\)。\r\n一开始时，欧拉函数值都是默认为自身。\r\n因此，本题就只需要计算出所有欧拉函数值，然后找到\\(n/\\varphi(n)\\)最大的\\(n\\)即可。\r\n代码\r\nN = 1000000phi = [i for i in range(N + 1)]val = 0ans = 0for i in range(2, N + 1):    if i == phi[i]:        for j in range(i, N + 1, i):            phi[j] //= i            phi[j] *= i - 1    w = i / phi[i]    if w &gt; val:        val = w        ans = iprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 679","url":"/project-euler/679/","content":"\r\nProject Euler 679\r\n题目\r\nFreefarea\r\nLet \\(S\\) be the set consisting of\r\nthe four letters \\(\\{\\texttt{`A&#39;},\\texttt{`E&#39;},\\texttt{`F&#39;},\\texttt{`R&#39;}\\}\\).\r\nFor \\(n\\ge 0\\), let \\(S^*(n)\\) denote the set of words of length\r\n\\(n\\) consisting of letters belonging\r\nto \\(S\\).\r\nWe designate the words \\(\\texttt{FREE},\r\n\\texttt{FARE}, \\texttt{AREA}, \\texttt{REEF}\\) as\r\nkeywords.\r\nLet \\(f(n)\\) be the number of words\r\nin \\(S^*(n)\\) that contains all four\r\nkeywords exactly once.\r\nThis first happens for \\(n=9\\), and\r\nindeed there is a unique 9 lettered word that contain each of the\r\nkeywords once: \\(\\texttt{FREEFAREA}\\)\r\nSo, \\(f(9)=1\\).\r\nYou are also given that \\(f(15)=72863\\).\r\nFind \\(f(30)\\).\r\n解决方案\r\n先将这\\(D=4\\)个关键字插入一棵Trie树，然后再使用AC自动机算法将这棵Trie树构建成一个确定有限状态自动机(DFA)。这个自动机每次读入一个字符，就会从当前状态转移到下一个指定的状态。一开始构建的Trie树的\\(D\\)个字符串的最终节点分别作为\\(D\\)个字符串的接受状态。也就是说，在构建Trie树时，假设插入一个字符串\\(s\\)后，最终到达的节点的编号（状态）为\\(st\\)，那么现在逐渐读入一个新的字符串\\(t\\)，并按照给定的转移过程逐渐转移，最终到达了状态\\(m\\)，那么相当于当前读入了一个字符串\\(s\\)。\r\n构建出DFA后，那么现在就将问题变成了一个图\\(G=(V,E)\\)上的动态规划问题，整个图一共有\\(|V|\\)个节点，编号\\(0\\sim |V|-1\\)。假设\\(D\\)个接受状态分别为\\(s_0,s_1,\\dots,s_{D-1}\\)。\r\n由于题目中要求\\(D\\)个字符串都需要恰好每个字符串都包含一次，因此考虑用一个\\(D\\)位二进制数\\(d=d_{D-1}d_{D-2}\\dots\r\nd_0\\)来表示图上的路径中，节点\\(s_0,s_1,\\dots,s_{D-1}\\)节点经过情况。如果\\(s_k\\)被路径经过，那么\\(d_k=1\\)，否则\\(d_k=0\\)。\r\n令\\(N=30\\)。令状态\\(g(i,j,k)(0\\le i\\le N,0\\le j&lt;|V|,0\\le\r\nk&lt;2^D)\\)表示有多少条从节点\\(0\\)开始的长度为\\(i\\)的路径中，目前在节点\\(j\\)，并且经过的接受状态节点情况为\\(k\\)。那么考虑使用我为人人式的方法进行如下实现：\r\n对于节点\\(j\\)的每个后继节点\\(v\\)：\r\n如果\\(v\\)是某个接受接受状态节点\\(s_l\\)，并且\\(2^l\\&amp;k=0\\)，那么就有转移\\(g(i,j,k)\\rightarrow g(i+1,v,2^l|k)\\)。\r\n如果\\(v\\)不是接受状态节点，那么就有转移\\(g(i,j,k)\\rightarrow g(i+1,v,k)\\)。\r\n那么最终结果为：\r\n\\[f(N)=\\sum_{j=0}^{|V|-1}g(N,j,2^D-1)\\]\r\n代码\r\n#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=30;const int MX=1004;const int D=4;string S=&quot;AEFR&quot;;vector&lt;string&gt;key_word&#123;    &quot;FREE&quot;,    &quot;FARE&quot;,    &quot;AREA&quot;,    &quot;REEF&quot;&#125;;unordered_map&lt;char,int&gt;tr[MX];int fail[MX];int pos[MX];int tot=0;void add(int id,string &amp;s)&#123;    int p=0;    for(char ch:s)&#123;        if(!tr[p].count(ch)) tr[p][ch]=++tot;        p=tr[p][ch];    &#125;    pos[p]=id;&#125;void build()&#123;    queue&lt;int&gt;q;    for(char ch:S)        if(tr[0].count(ch)) q.push(tr[0][ch]);    while(!q.empty())&#123;        int u=q.front();q.pop();        for(char ch:S)&#123;            if(tr[u].count(ch)) fail[tr[u][ch]]=tr[fail[u]][ch],q.push(tr[u][ch]);            else tr[u][ch]=tr[fail[u]][ch];        &#125;    &#125;&#125;ll f[N][MX][1&lt;&lt;D];int main()&#123;    memset(pos,-1,sizeof(pos));    for(int i=0;i&lt;key_word.size();i++)        add(i,key_word[i]);    build();    f[0][0][0]=1;    for(int i=0;i&lt;N;i++)        for(int j=0;j&lt;=tot;j++)            for(int k=0;k&lt;(1&lt;&lt;D);k++)                for(auto &amp;[ch,v]:tr[j])&#123;                    int st=k;                    if(pos[v]!=-1)&#123;                        if(k&gt;&gt;pos[v]&amp;1) continue;                        st|=1&lt;&lt;pos[v];                    &#125;                    f[i+1][v][st]+=f[i][j][k];                &#125;    ll ans=0;    for(int j=0;j&lt;=tot;j++)        ans+=f[N][j][(1&lt;&lt;D)-1];    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划","AC自动机"]},{"title":"Project Euler 688","url":"/project-euler/688/","content":"\r\nProject Euler 688\r\n题目\r\nPiles of Plates\r\nWe stack \\(n\\) plates into \\(k\\) non-empty piles where each pile is a\r\ndifferent size. Define \\(f(n,k)\\) to be\r\nthe maximum number of plates possible in the smallest pile. For example\r\nwhen \\(n = 10\\) and \\(k = 3\\) the piles \\(2,3,5\\) is the best that can be done and so\r\n\\(f(10,3) = 2\\). It is impossible to\r\ndivide \\(10\\) into \\(5\\) non-empty differently-sized piles and\r\nhence \\(f(10,5) = 0\\).\r\nDefine \\(F(n)\\) to be the sum of\r\n\\(f(n,k)\\) for all possible pile sizes\r\n\\(k\\ge 1\\). For example \\(F(100) = 275\\).\r\nFurther define \\(S(N) =\r\n\\displaystyle\\sum_{n=1}^N F(n)\\). You are given \\(S(100) = 12656\\).\r\nFind \\(S(10^{16})\\) giving your\r\nanswer modulo \\(1\\,000\\,000\\,007\\).\r\n解决方案\r\n令\\(N=10^{16}.\\)\r\n如果\\(n\\)个盘子放成\\(k\\)堆，那么一种贪心的方法则是先摆成\\(1,2,3,\\dots,k-1,k\\)这\\(k\\)堆，接下来将剩下的\\(n-\\dfrac{k(k+1)}{2}\\)碟子再均分到这\\(k\\)堆，如果剩下的碟子依然不能均分，那么全部都分给最大的那堆。因此不难写出函数\\(f\\)为：\r\n\\[\r\nf(n,k)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0  &amp; &amp; \\text{if}\\quad  n&lt;\\dfrac{k(k+1)}{2} \\\\\r\n  &amp;1+\\left\\lfloor\\dfrac{n}{k}-\\dfrac{k+1}{2}\\right\\rfloor &amp;\r\n&amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n不过，这个式子其实对解题并没有太大的帮助。\r\n将\\(S\\)的定义式子进行改写：\r\n\\[S(N)=\\sum_{n=1}^N\\sum_{k\\ge\r\n1}f(n,k)=\\sum_{1\\le \\frac{k(k+1)}{2}\\le\r\nN}\\sum_{n=\\frac{k(k+1)}{2}}^{N}f(n,k)\\]\r\n本质上，是将\\(n,k\\)的枚举顺序改变了。\r\n式子\\(\\sum_{n=\\frac{k(k+1)}{2}}^{N}f(n,k)\\)的值可以以\\(O(1)\\)的时间复杂度进行计算。因为按照此时\\(n\\)枚举顺序，\\(f(n,k)\\)将会是连续\\(k\\)个\\(1\\)，\\(k\\)个\\(2\\)，……考虑分块然后使用等差数列求和进行计算。\r\n令\\(x=N-\\dfrac{k(k+1)}{2}+1\\)，\\(q=\\left\\lfloor\\dfrac{x}{k}\\right\\rfloor,r=x\\%k\\)，那么分块后计算得\\(\\sum_{n=\\frac{k(k+1)}{2}}^{N}f(n,k)=k\\cdot\\dfrac{q\\cdot(q+1)}{2}+(q+1)\\cdot\r\nr\\)。\r\n最终枚举\\(k\\)并将这些值相加即可。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const ll Q=1e16;ll mod=1e9+7;ll inv2=(mod+1)&gt;&gt;1;int main()&#123;    ll ans=0;    for(ll k=1;;k++)&#123;        ll w=k*(k+1)/2;        if(w&gt;Q) break;        ll t=Q-w+1;        ll q=t/k%mod,r=t%k;        ans=(ans+k*q%mod*(q+1)%mod*inv2%mod+(q+1)*r%mod)%mod;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["贪心"]},{"title":"Project Euler 691","url":"/project-euler/691/","content":"\r\nProject Euler 691\r\n题目\r\nLong substring with many\r\nrepetitions\r\nGiven a character string \\(s\\), we\r\ndefine \\(L(k,s)\\) to be the length of\r\nthe longest substring of \\(s\\) which\r\nappears at least \\(k\\) times in \\(s\\), or \\(0\\) if such a substring does not exist. For\r\nexample, \\(L(3,\\text{“bbabcabcabcacba”})=4\\) because\r\nof the three occurrences of the substring \\(\\text{“abca”}\\), and \\(L(2,\\text{“bbabcabcabcacba”})=7\\) because\r\nof the repeated substring \\(\\text{“abcabca”}\\). Note that the\r\noccurrences can overlap.\r\nLet \\(a_n\\), \\(b_n\\) and \\(c_n\\) be the \\(0/1\\) sequences defined by:\r\n\r\n\\(a_0 = 0\\)\r\n\\(a_{2n} = a_{n}\\)\r\n\\(a_{2n+1} = 1-a_{n}\\)\r\n\\(b_n =\r\n\\left\\lfloor\\dfrac{n+1}{\\varphi}\\right\\rfloor -\r\n\\left\\lfloor\\dfrac{n}{\\varphi}\\right\\rfloor\\) (where \\(\\varphi\\) is the golden ratio)\r\n\\(c_n = a_n + b_n - 2a_nb_n\\)\r\n\r\nand \\(S_n\\) the character string\r\n\\(c_0\\ldots c_{n-1}\\). You are given\r\nthat \\(L(2,S_{10})=5, L(3,S_{10})=2,\r\nL(2,S_{100})=14, L(4,S_{100})=6, L(2,S_{1000})=86, L(3,S_{1000}) = 45,\r\nL(5,S_{1000}) = 31\\), and that the sum of non-zero \\(L(k,S_{1000})\\) for \\(k\\ge 1\\) is \\(2460\\).\r\nFind the sum of non-zero \\(L(k,S_{5000000})\\) for \\(k\\ge 1\\).\r\n后缀数组(Suffix Array)\r\n后缀树组是一个将字符串\\(s\\)的所有后缀进行排序后得到的数组，\\(sa[i]\\)表示第\\(i\\)小的后缀\\(s_{sa[i]}s_{sa[i]+1}\\dots\r\ns_n\\)（用第一个字符的下标代表后缀）。可以以\\(O(n\\log\r\nn)\\)的时间复杂度求出，最优秀的算法甚至达到\\(O(n)\\)。\r\n由\\(sa\\)可以以\\(O(n)\\)的时间推导出另一个数组\\(h\\)，其中\\(h[i](i\\ge 2)\\)表示后缀\\(sa[i-1]\\)和\\(sa[i]\\)的最长公共前缀的长度。可以认为\\(h[1]=0\\)。\r\n解决方案\r\n为了方便，我们将\\(S_n\\)假设成是\\(1\\)下标的，也就是\\(S_n=c_1c_2\\dots\r\nc_n\\)，并且和原来的字符串相同。\r\n直接使用模板计算出字符串\\(S_n\\)的\\(sa\\)数组和\\(h\\)数组后，不难知道\\(\\displaystyle{L(k,S_n)=\\text{argmax}_{i}\\{\\exists\r\np\\in[2,n-k+2]: \\min_{j=p}^{p+k-2}\\{h[j]\\}\\ge\r\ni\\}}\\)，也就是找到最大的\\(i\\)，使得\\(h\\)某一个长度为\\(k-1\\)的子数组都不低于\\(i\\)。\r\n可以知道\\(L\\)是单调非递增的，计算\\(L\\)的过程可以考虑使用区间并查集解决（这种并查集只会将相邻被填入集合中的数进行合并）。从大到小枚举可以填入的答案\\(i\\)，并且将\\(h[k]\\ge i\\)的所有连续段的最大值\\(M\\)求出来。最终，\\(\\forall j\\le M\\)，如果\\(L(j,S_n)\\)之前没被计算过，那么\\(L(j,S_n)=M\\)。\r\n代码\r\n这里的后缀数组求解使用了OI-WIKI中的模板，其基本思想是基数排序。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 5000000;int c[N+4];int sa[N+4], rk[N+4], oldrk[(N+4) &lt;&lt; 1], id[N+4], key1[N+4], cnt[N+4];int h[N + 4];bool cmp(int x, int y, int w) &#123;    return oldrk[x] == oldrk[y] &amp;&amp; oldrk[x + w] == oldrk[y + w];&#125;void run_sa(int *s,int n,int m) &#123;    for (int i = 1; i &lt;= n; ++i) ++cnt[rk[i] = s[i]];    for (int i = 1; i &lt;= m; ++i) cnt[i] += cnt[i - 1];    for (int i = n; i &gt;= 1; --i) sa[cnt[rk[i]]--] = i;    for (int w = 1, p;; w &lt;&lt;= 1, m = p) &#123;        p = 0;        for (int i = n; i &gt; n - w; --i) id[++p] = i;        for (int i = 1; i &lt;= n; ++i)            if (sa[i] &gt; w) id[++p] = sa[i] - w;        memset(cnt, 0, sizeof(cnt));        for (int i = 1; i &lt;= n; ++i) ++cnt[key1[i] = rk[id[i]]];        for (int i = 1; i &lt;= m; ++i) cnt[i] += cnt[i - 1];        for (int i = n; i &gt;= 1; --i) sa[cnt[key1[i]]--] = id[i];        memcpy(oldrk + 1, rk + 1, n * sizeof(int));        p = 0;        for (int i = 1; i &lt;= n; ++i)            rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;        if (p == n) &#123;            for (int i = 1; i &lt;= n; ++i) sa[rk[i]] = i;            break;        &#125;    &#125;    for (int i = 1, k = 0; i &lt;= n; ++i) &#123;        if (rk[i] == 0) continue;        if (k) --k;        while (max(sa[rk[i] - 1], i) + k &lt;= n &amp;&amp; s[i + k] == s[sa[rk[i] - 1] + k]) ++k;        h[rk[i]] = k;    &#125;&#125;int fa[N+4],sz[N+4],vis[N+4],mx = 0;int find(int x)&#123;return x==fa[x]?x:fa[x]=find(fa[x]);&#125;void merge(int x,int y)&#123;    int u=find(x),v=find(y);    if(u!=v)&#123;        fa[v]=u;        sz[u]+=sz[v];    &#125;&#125;vector&lt;int&gt;pt[N+4];int l[N+4];int main()&#123;    clock_t t = clock();    for(int i=1;i&lt;=N;i++)        c[i]=__builtin_popcount(i-1)&amp;1;    double ph=(1+sqrt(5.0))/2;    double pre=0;    for(int i=1;i&lt;=N;i++)&#123;        double now=1.0*i/ph;        c[i]^=int(now)-int(pre);        pre=now;    &#125;    run_sa(c,N,1);    for(int i=2;i&lt;=N;i++) &#123;        fa[i] = i, sz[i] = 1;        pt[h[i]].push_back(i);    &#125;    for(int i=N,p=1;i&gt;=1;i--)&#123;        for(int x:pt[i])&#123;            vis[x]=1;            if(vis[x-1]) merge(x-1,x);            if(vis[x+1]) merge(x+1,x);            mx=max(mx,sz[find(x)]);        &#125;        for(;p-1&lt;=mx;p++)           l[p] = i;    &#125;    ll ans = 0;    for(int i=1;i&lt;=N;i++)        ans += l[i];    printf(&quot;%lld\\n&quot;,ans);    cout &lt;&lt; clock()-t&lt;&lt;endl;&#125;\r\n","categories":["Project Euler"],"tags":["并查集","后缀数组"]},{"title":"Project Euler 692","url":"/project-euler/692/","content":"\r\nProject Euler 692\r\n题目\r\nSiegbert and Jo\r\nSiegbert and Jo take turns playing a game with a heap of \\(N\\) pebbles:\r\n\r\nSiegbert is the first to take some pebbles. He can take as many\r\npebbles as he wants. (Between \\(1\\) and\r\n\\(N\\) inclusive.)\r\nIn each of the following turns the current player must take at least\r\none pebble and at most twice the amount of pebbles taken by the previous\r\nplayer.\r\nThe player who takes the last pebble wins.\r\n\r\nAlthough Siegbert can always win by taking all the pebbles on his\r\nfirst turn, to make the game more interesting he chooses to take the\r\nsmallest number of pebbles that guarantees he will still win (assuming\r\nboth Siegbert and Jo play optimally for the rest of the game).\r\nLet \\(H(N)\\) be that minimal amount\r\nfor a heap of \\(N\\) pebbles.\r\n\\(H(1)=1\\), \\(H(4)=1\\), \\(H(17)=1\\), \\(H(8)=8\\) and \\(H(18)=5\\) .\r\nLet \\(G(n)\\) be \\(\\displaystyle{\\sum_{k=1}^n H(k)}\\).\r\n\\(G(13)=43\\).\r\nFind \\(G(23416728348467685)\\).\r\n解决方案\r\n这个游戏是斐波那契Nim，页面说明了\\(H(n)\\)是\\(n\\)的齐肯多夫表示法中的最小项。\r\n将\\(H(n)\\)的前一部分项打印出来，并在OEIS上查找到为A139764。\r\n假设\\(f(n)\\)是小于等于\\(n\\)以内的最大斐波那契数。观察\\(H(n)\\)的特征，发现：\r\n\r\n如果\\(n\\)是斐波那契数，那么\\(H(n)=f(n)\\)\r\n如果\\(n\\)不是斐波那契数，那么\\(H\\)的第\\(f(n)+1\\)项到第\\(n\\)项这一段，和第\\(1\\)项到\\(n-f(n)\\)这一段是完全相同的。\r\n\r\n因此不难计给出计算\\(G(n)\\)的递推式：\r\n\\[\r\nG(n)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1 &amp; &amp; \\text{if}\\quad  n=1 \\\\\r\n  &amp;G(n-1)+n  &amp; &amp; \\text{else if}\\quad  f(n)=n \\\\\r\n  &amp;G(n-f(n))+G(f(n))&amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n采用记忆化的方式，那么可以在\\(O(\\log\r\nn)\\)的时间复杂度内完成计算。\r\n代码\r\nN = 23416728348467685f = [1, 2]while True:    f.append(f[-1] + f[-2])    if f[-1] &gt; N:        breakG = &#123;1: 1&#125;def getG(n: int):    if n in G.keys():        return G[n]    for p in range(len(f) - 1):        if f[p + 1] &gt; n:            break    if f[p] == n:        G[n] = getG(n - 1) + n    else:        G[n] = getG(f[p]) + getG(n - f[p])    return G[n]ans = getG(N)print(ans)\r\n","categories":["Project Euler"],"tags":["博弈论","齐肯多夫定理"]},{"title":"Project Euler 697","url":"/project-euler/697/","content":"\r\nProject Euler 697\r\n题目\r\nRandomly Decaying Sequence\r\nGiven a fixed real number \\(c\\),\r\ndefine a random sequence \\((X_n)_{n\\ge\r\n0}\\) by the following random process:\r\n\r\n\\(X_0 = c\\) (with probability \\(1\\)).\r\nFor \\(n&gt;0\\), \\(X_n = U_n X_{n-1}\\) where \\(U_n\\) is a real number chosen at random\r\nbetween zero and one, uniformly, and independently of all previous\r\nchoices \\((U_m)_{m&lt;n}\\).\r\n\r\nIf we desire there to be precisely a \\(25\\%\\) probability that \\(X_{100}&lt;1\\), then this can be arranged\r\nby fixing \\(c\\) such that \\(\\log_{10} c \\approx 46.27\\).\r\nSuppose now that \\(c\\) is set to a\r\ndifferent value, so that there is precisely a \\(25\\%\\) probability that \\(X_{10\\,000\\,000}&lt;1\\).\r\nFind \\(\\log_{10} c\\) and give your\r\nanswer rounded to two places after the decimal point.\r\n解决方案\r\n令\\(n=10^7\\)。原问题是求\\(c\\)使得\\(P\r\n\\{c\\cdot\\prod_{i=1}^n U_i&lt;1\\}=0.25\\)。\r\n令\\(V_i=-\\ln U_i,v=\\ln\r\nc\\)。那么问题就变成求\\(v\\)使得\\(P\\{v-\\sum_{i=1}^n V_i&lt; 0\\}=0.25\\)。\r\n由于\\(U_i\\sim U(0,1)\\)，因此\\(V_i\\)是服从参数为\\(1\\)的指数分布，即\\(V_i\\sim \\text{Exp}(1)\\)。\r\n那么，随机变量\\(Y=\\sum_{i=1}^n\r\nV_i\\)服从参数为\\((n,1)\\)的伽马分布，即有\\(Y\\sim \\Gamma(n,1)\\)。\r\n由于目前是求\\(v\\)使得\\(P\\{Y&gt;v\\}=0.25\\)，也就是\\(\\Gamma(n,1)\\)的\\(0.75\\)分位点。根据伽马分布和伽马函数的定义，随机变量\\(Y\\)的概率密度函数为\r\n\\[f_Y(x)=x^{n-1}\\cdot e^{-x}\\]\r\n那么\\(Y\\)的分布函数恰好为不完全伽马函数\\(\\Gamma(n,x)\\)。我们使用scipy.special库中的方法gammainc(n,x)来计算\\(\\Gamma(n,x)\\)的值。为了确定\\(v\\)使得\\(\\Gamma(n,v)=0.75\\)，使用二分法进行完成。\r\n最终，\\(\\dfrac{v}{\\ln\r\n10}\\)为答案。\r\n代码\r\nfrom scipy.special import gammaincfrom math import logN = 10 ** 7R = 0.25R = 1 - Rl, r = 0, 10 ** 20for _ in range(100):    m = (l + r) * 0.5    v = gammainc(N, m)    if v &lt; R:        l = m    else:        r = mans = l / log(10)print(&quot;&#123;:.2f&#125;&quot;.format(ans))\r\n","categories":["Project Euler"],"tags":["概率"]},{"title":"Project Euler 686","url":"/project-euler/686/","content":"\r\nProject Euler 686\r\n题目\r\nPowers of Two\r\n\\(2^7=128\\) is the first power of\r\ntwo whose leading digits are “\\(12\\)”.\r\nThe next power of two whose leading digits are “\\(12\\)” is \\(2^{80}\\).\r\nDefine \\(p(L, n)\\) to be the \\(n\\text{th}\\)-smallest value of \\(j\\) such that the base \\(10\\) representation of \\(2^j\\) begins with the digits of \\(L\\).\r\nSo \\(p(12, 1) = 7\\) and \\(p(12, 2) = 80\\).\r\nYou are also given that \\(p(123, 45) =\r\n12710\\).\r\nFind \\(p(123, 678910)\\).\r\n解决方案\r\n将\\(2^k\\)对\\(10\\)进行取对数，那么得到\\(k\\log_{10} 2\\)。如果\\(2^k\\)是以\\(123\\)为开头，那么\\(k\\log_{10}2\\)的小数部分\\(d=k\\log _{10}2-\\lfloor\r\nk\\log_{10}2\\rfloor\\)满足\\(\\log_{10}1.23\\le d&lt;\\log_{10}\r\n1.24\\)。因此，最朴素的一种做法是从小到大枚举\\(k\\)，观察\\(k\\log_{10}2\\)的小数部分是否落在那个区间上即可。这个区间写成小数形式为：\r\n\\([0.08990511143939793,0.09342168516223506)\\qquad(1)\\)\r\n这个区间的长度为\\(0.0035165737228371324\\)\r\n不过，朴素枚举区间的效率比较慢。暴力枚举出前一部分项后，发现相邻的两项差值总在集合\\(S=\\{196, 289, 485\\}\\)中。\r\n可以发现这几个数有以下特征：\r\n\\(\\begin{aligned}\r\n&amp;196\\log_{10}2=59+0.00187915014031\\\\\r\n&amp;289\\log_{10}2=87-0.002331253109431941\\\\\r\n&amp;485\\log_{10}2=146-0.00045210296912046033\r\n\\end{aligned}\\)\r\n后面的尾数都很小，比上面的区间长度都小。假设当前\\(2^a\\)是一个答案，也就是说，\\(a\\log_{10}2\\)的小数部分\\(x\\)在区间\\((1)\\)内。那么，\r\n\r\n当\\(x\\in[0.08990511143939793,0.09342168516223506-0.00187915014031)\\)时，对\\(a\\)相加\\(196\\)，那么就找到了下一个答案。\r\n当\\(x\\in[0.08990511143939793+0.002331253109431941,0.09342168516223506)\\)时，对\\(a\\)相加\\(289\\)，那么就找到了下一个答案。\r\n当\\(x\\in[0.08990511143939793+0.00045210296912046033,0.09342168516223506)\\)时，对\\(a\\)相加\\(485\\)，那么就找到了下一个答案。\r\n\r\n并且发现，这三个条件所包括的区间的并，和原来的区间\\((1)\\)是相同的。因此对于每个答案\\(a\\)，只需要对集合\\(S\\)中的数，从小到大尝试一遍，都将会找到答案。\r\n枚举到第一个答案为\\(90\\)，因此从这个答案开始寻找。\r\n注意在实现过程中，多次计算\\(a\\log\r\n_{10}2\\)时，不要使用累加，因为这将会将浮点数误差累积起来。\r\n代码\r\nfrom math import log10N = 678910l, r = log10(1.23), log10(1.24)lg = log10(2)s = [196, 289, 485]ans = 90for _ in range(N - 1):    for j in range(len(s)):        val = (ans + s[j]) * lg        if l &lt;= val - int(val) &lt; r:            ans += s[j]            break    if j == len(s):        print(&quot;FAIL&quot;)        exit()print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 694","url":"/project-euler/694/","content":"\r\nProject Euler 694\r\n题目\r\nCube-full Divisors\r\nA positive integer \\(n\\) is\r\nconsidered cube-full, if for every prime \\(p\\) that divides \\(n\\), so does \\(p^3\\). Note that \\(1\\) is considered cube-full.\r\nLet \\(s(n)\\) be the function that\r\ncounts the number of cube-full divisors of \\(n\\). For example, \\(1\\), \\(8\\)\r\nand \\(16\\) are the three cube-full\r\ndivisors of \\(16\\). Therefore, \\(s(16)=3\\).\r\nLet \\(S(n)\\) represent the summatory\r\nfunction of \\(s(n)\\), that is \\(S(n)=\\displaystyle\\sum_{i=1}^n s(i)\\).\r\nYou are given \\(S(16) =  19\\), \\(S(100) = 126\\) and \\(S(10000) = 13344\\).\r\nFind \\(S(10^{18})\\).\r\n解决方案\r\n令\\(N=10^{18},M=\\lfloor\\sqrt[4]{N}\\rfloor.\\)计算\\(S\\)时，我们考虑枚举每一个满立方数\\(w\\)，那么它们在\\(N\\)以内出现的次数为\\(\\left\\lfloor\\dfrac{N}{w}\\right\\rfloor\\).\r\n通过考察\\(n\\)分解质因数\\(n=\\prod_{i=1}^kp_i^{e_i}\\)的每个\\(e_i\\)，可以发现每一个满立方数可以通过\\(x^3y^4z^5\\)来不重不漏地表出，其中\\(x,y\\)是两个无平方因子数，并且\\(\\gcd(x,y)=1.\\)\r\n实现时，首先使用筛法将\\(M\\)以内的所有无平方因子数进行筛选出来。前两层循环分别枚举两个无平方因子数\\(z\\)和\\(y\\)。注意判断\\(\\gcd(z,y)=1\\)时，只需要判断\\(zy\\)是否为无平方因子数即可，接下来直接枚举\\(x\\)，从而构造出一个满立方因子数\\(x^3y^4z^5\\)。\r\n代码\r\nfrom itertools import countfrom tools import int_sqrtN = 10 ** 18M = int(N ** (1 / 4))square_free = [1] * (M + 1)for i in range(2, int_sqrt(M) + 1):    k = i * i    for j in range(k, M + 1, k):        square_free[j] = 0ans = 0for z in count(1, 1):    z5 = z ** 5    if z ** 5 &gt; N:        break    if square_free[z]:        for y in count(1, 1):            y4 = y ** 4            mul = y4 * z5            if mul &gt; N:                break            if square_free[y] and square_free[z * y]:                for x in count(1, 1):                    x3 = x ** 3                    if mul * x3 &gt; N:                        break                    ans += N // (mul * x3)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 7","url":"/project-euler/7/","content":"\r\nProject Euler 7\r\n题目\r\n\\(10001\\text{st}\\) prime\r\nBy listing the first six prime numbers: \\(2, 3, 5, 7, 11\\), and \\(13\\), we can see that the \\(6\\text{th}\\) prime is \\(13\\).\r\nWhat is the \\(10 001\\text{st}\\)\r\nprime number?\r\n解决方案\r\n使用sympy库中的prime函数计算即可。筛选素数的常见筛法有线性筛和埃氏筛。\r\n埃氏筛的思想主要是标记所有合数。当遇到一个没有被标记过的数时，就认为它是质数，然后将这个质数的所有倍数全都标记为合数。因此，有一些合数会被它的所有质因数重复标记。\r\n线性筛的思想则是需要维护一个数组\\(v\\)。这个数组\\(v\\)的含义是\\(v[i]\\)是\\(i\\)的最小的质因数。线性筛比埃氏筛的效率高了一个对数级，因为其中的每个合数都只会被标记一次（被最小的质因数标记）。而数组\\(v\\)，则控制着每个数\\(i\\)不能利用比\\(v[i]\\)更大的质因数去重复标记其它合数。\r\n两种筛法都可以用来计算积性函数。\r\n代码\r\nfrom sympy.ntheory.generate import primeN = 10001ans = prime(N)print(ans)\r\n埃氏筛：\r\nQ = 10001pr = []N = Q * len(bin(Q)) - 2f = [0 for _ in range(N + 1)]for i in range(2, N + 1):    if f[i] == 0:        pr.append(i)        for j in range(i * i, N + 1, i):            f[j] = 1ans = pr[Q - 1]print(ans)\r\n线性筛：\r\n# include &lt;bits/stdc++.h&gt;using namespace std;const int Q=10001;const int N=(1+log2(Q))*Q+4;int v[N+4],pr[N+4],m=0;int main()&#123;    for(int i=2;i&lt;=N;i++)&#123;        if(v[i]==0)&#123;            v[i]=i;pr[++m]=i;        &#125;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;N/i)                break;            v[i*pr[j]]=pr[j];        &#125;    &#125;    int ans=pr[Q];    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 705","url":"/project-euler/705/","content":"\r\nProject Euler 705\r\n题目\r\nTotal Inversion\r\nCount of Divided Sequences\r\nThe inversion count of a sequence of digits is the smallest\r\nnumber of adjacent pairs that must be swapped to sort the sequence.\r\nFor example, \\(34214\\) has inversion\r\ncount of \\(5\\): \\(34214 \\to 32414 \\to 23414 \\to 23144 \\to 21344\r\n\\to12344\\).\r\nIf each digit of a sequence is replaced by one of its divisors a\r\ndivided sequence is obtained.\r\nFor example, the sequence \\(332\\)\r\nhas \\(8\\) divided sequences: \\(\\{332,331,312,311,132,131,112,111\\}\\).\r\nDefine \\(G(N)\\) to be the\r\nconcatenation of all primes less than \\(N\\), ignoring any zero digit.\r\nFor example, \\(G(20) =\r\n235711131719\\).\r\nDefine \\(F(N)\\) to be the sum of the\r\ninversion count for all possible divided sequences from the master\r\nsequence \\(G(N)\\).\r\nYou are given \\(F(20) = 3312\\) and\r\n\\(F(50) = 338079744\\).\r\nFind \\(F(10^8)\\). Give your answer\r\nmodulo \\(1\\,000\\,000\\,007\\).\r\n解决方案\r\n一个结论：一个数字串\\(s\\)的置换数的值为\\(\\displaystyle{\\sum_{i=1}^n\\sum_{j=i+1}^n\r\n[s_i&gt;s_j]}\\)，其中\\([]\\)表示示性函数，\\(n\\)为字符串\\(s\\)的长度。因此这题的主要思路是，统计\\(\\displaystyle{f(s,x,y)=\\sum_{i=1}^n\\sum_{j=i+1}^n\r\n[s_i=x\\land s_j=y]}\\)的数对数量，并且计算\\(\\displaystyle{\\sum_{x=1}^9\\sum_{j=i+1}^9f(s,x,y)}\\)的值即可。并且，\\(f(s,x,y)\\)的值可以通过前缀和以\\(O(n)\\)的时间复杂度计算出来。\r\n此外，令\\(c_i(i\\in\\{1,2,3,\\dots,8,9\\})\\)表示数字\\(i\\)的因子个数。那么按照题意，其整除列的个数为\\(\\displaystyle{M=\\prod_{i=1}^n\r\nc_{s_i}}\\).并且，令\\(\\displaystyle{g(x,y)=\\sum_{a\\mid x,b\\mid\r\ny}[a&gt;b]}\\)。对于一对下标\\((i,j)\\)，其中\\(i&lt;j\\)，那么这对下标的贡献为\\(\\dfrac{M\\cdot g(s_i,s_j)}{c_{s_i}\\cdot\r\nc_{s_j}}\\)。使用上面的方法统计不同的元素对再求和，得到最终答案为：\r\n\\[M\\cdot\\sum_{x=1}^9\\sum_{y=1}^9\\dfrac{f(s,x,y)\\cdot\r\ng(x,y)}{c_x\\cdot c_y}.\\]\r\n代码\r\n#include &lt;bits/stdc++.h&gt;# include &quot;tools.h&quot;using namespace std;typedef long long ll;const int N=1e8;ll mod=1e9+7;const int B=10;int c[B]=&#123;0, 1, 2, 2, 3, 2, 4, 2, 4, 3&#125;;int g[B][B] =&#123;        &#123;0, 0, 0, 0, 0, 0, 0, 0, 0, 0&#125;,        &#123;0, 0, 0, 0, 0, 0, 0, 0, 0, 0&#125;,        &#123;0, 1, 1, 1, 1, 1, 1, 1, 1, 1&#125;,        &#123;0, 1, 2, 1, 2, 1, 2, 1, 2, 1&#125;,        &#123;0, 2, 3, 3, 3, 2, 4, 2, 3, 3&#125;,        &#123;0, 1, 2, 2, 3, 1, 3, 1, 3, 2&#125;,        &#123;0, 3, 5, 4, 6, 4, 6, 3, 6, 4&#125;,        &#123;0, 1, 2, 2, 3, 2, 4, 1, 3, 2&#125;,        &#123;0, 3, 5, 5, 6, 4, 8, 4, 6, 5&#125;,        &#123;0, 2, 4, 3, 5, 3, 6, 3, 6, 3&#125;,&#125;;vector&lt;int&gt;s;ll cnt[B][B],inv[B];int d[B];int main()&#123;    for(int i=1;i&lt;B;i++)        inv[i] = mod_inverse(i,mod);    vector&lt;int&gt;v=get_prime(N-1);    for(int p:v)&#123;        int pre=s.size();        for(int m=p;m;m/=10)            if(m % 10)               s.push_back(m%10);        reverse(s.begin()+pre,s.end());    &#125;    for(int x:s)&#123;        for(int j=0;j&lt;B;j++)            cnt[j][x] += d[j];        ++d[x];    &#125;    ll nums=1;    for(int i=1;i&lt;B;i++)        nums=nums*qpow(c[i],d[i],mod)%mod;    ll ans=0;    for(int i=1;i&lt;B;i++)        for(int j=1;j&lt;B;j++)            ans+=cnt[i][j]%mod*nums%mod*inv[c[i]]%mod*inv[c[j]]%mod*g[i][j];    ans%=mod;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 706","url":"/project-euler/706/","content":"\r\nProject Euler 706\r\n题目\r\n\\(3\\)-Like\r\nNumbers\r\nFor a positive integer \\(n\\), define\r\n\\(f(n)\\) to be the number of non-empty\r\nsubstrings of \\(n\\) that are divisible\r\nby \\(3\\). For example, the string\r\n“\\(2573\\)” has \\(10\\) non-empty substrings, three of which\r\nrepresent numbers that are divisible by \\(3\\), namely \\(57,\r\n573\\) and \\(3\\). So \\(f(2573) = 3\\).\r\nIf \\(f(n)\\) is divisible by \\(3\\) then we say that \\(n\\) is \\(3\\)-like.\r\nDefine \\(F(d)\\) to be how many \\(d\\) digit numbers are \\(3\\)-like. For example, \\(F(2) = 30\\) and \\(F(6) = 290898\\).\r\nFind \\(F(10^5)\\). Give your answer\r\nmodulo \\(1\\,000\\,000\\,007\\).\r\n解决方案\r\n一个非常直接的动态规划题。\r\n令\\(N=10^5.\\)考虑到子串的个数，通常我们先将这个数\\(d=d_1d_2d_3\\dots\\)看成一个字符串，然后令其前缀和数组为\\(s\\)，其中\\(s[0]=0,s[i]=s[i-1]+d_i\\)，那么一个数的子串和就可以通过数组\\(s\\)进行一次减法求得。\r\n令\\(N=10^5\\)，假设已有状态\\(f(i,c_1,c_2,k,t)(1\\le i\\le N,0\\le\r\nc_1,c_2,t&lt;3)\\)为有多少个\\(i\\)位数满足以下条件：\r\n\r\n令\\(c_0=(i+1-c_1-c_2)\\%3\\)。这两个值其实也是状态之一，只不过可以被\\(i,c_1,c_2\\)表出。\r\n目前数组\\(s\\)一共有\\(i+1\\)项，其中有\\(c_j\\)个项模\\(3\\)的值为\\(j(0\\le\r\nj&lt;3)\\) ，注意\\(c_j\\)已经被\\(3\\)取模。\r\n目前\\(s[i]\\)的值为\\(k\\)。\r\n子串个数和\\(t\\)关于模\\(3\\)同余。\r\n\r\n那么状态的转移只需要考虑在每个数后面添加一个数位\\(0\\sim 9\\)，注意维护前缀和数组\\(s\\)新的一项。\r\n本题转移过程考虑进行我为人人式。\r\n不难知道初值\\(f(1,0,0,0,1)=f(1,1,0,1,0)=f(1,0,1,2,0)=3\\)，这\\(3\\)种情况分别对应一位数模\\(3\\)余\\(0\\)，模\\(3\\)余\\(1\\)，模\\(3\\)余\\(2\\)的情况。\r\n以\\(k=0\\)为例，那么有三种方式转移：\r\n\\(\\begin{aligned}\r\n&amp; f(i,c_1,c_2,0,t)\\cdot 4\\rightarrow f(i+1,c_1,c_2,0,(t+c_0)\\%3) \\\\\r\n&amp; f(i,c_1,c_2,0,t)\\cdot 3\\rightarrow\r\nf(i+1,(c_1+1)\\%3,c_2,1,(t+c_1)\\%3) \\\\\r\n&amp; f(i,c_1,c_2,0,t)\\cdot 3\\rightarrow\r\nf(i+1,c_1,(c_2+1)\\%3,1,(t+c_2)\\%3) \\\\\r\n\\end{aligned}\\)\r\n由于目前的前缀和\\(s[i]=0\\)，那么再添加数位\\(0,3,6,9\\)中的一个，那么\\(s[i+1]=0\\)，因此这时就多了\\(c_0\\)个符合题意的子串；如果添加数位\\(1,4,7\\)中的一个，那么\\(s[i+1]=1\\)，因此这时就多了\\(c_1\\)个符合题意的子串；如果添加一个数位\\(2,5,8\\)，那么\\(s[i+1]=2\\)，因此这时就多了\\(c_2\\)个符合题意的子串。\r\n因此，最终答案为\r\n\\[\\sum_{c_1=0}^3\\sum_{c_2=0}^3\\sum_{k=0}^3f(N,c_0,c_1,k,0)\\]\r\n本题也可以将整个状态转移过程写成一个\\(81\\times81\\)大小的矩阵，通过矩阵快速幂以\\(O(\\log\r\nN)\\)直接计算出结果。此处不再详述这个优化。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=100000;ll f[N+4][3][3][3][3],mod=1e9+7;void add(ll &amp;x,ll y)&#123;    x=(x+y)%mod;&#125;int main() &#123;    f[1][0][0][0][1] = 3;    f[1][1][0][1][0] = 3;    f[1][0][1][2][0] = 3;    for (int i = 1; i &lt; N; i++)        for (int c1 = 0; c1 &lt; 3; c1++)            for (int c2 = 0; c2 &lt; 3; c2++)                for (int t = 0; t &lt; 3; t++) &#123;                    int c0 = (i + 1 - c1 - c2 + 6) % 3;                    ll &amp;now0 = f[i][c1][c2][0][t], &amp;now1 = f[i][c1][c2][1][t], &amp;now2 = f[i][c1][c2][2][t];                    add(f[i + 1][c1][c2][0][(t + c0) % 3], now0 * 4); //0,3,6,9                    add(f[i + 1][(c1 + 1) % 3][c2][1][(t + c1) % 3], now0 * 3);//1,4,7                    add(f[i + 1][c1][(c2 + 1) % 3][2][(t + c2) % 3], now0 * 3);//2,5,8                    add(f[i + 1][(c1 + 1) % 3][c2][1][(t + c1) % 3], now1 * 4);//0,3,6,9                    add(f[i + 1][c1][(c2 + 1) % 3][2][(t + c2) % 3], now1 * 3);// 1,4,7                    add(f[i + 1][c1][c2][0][(t + c0) % 3], now1 * 3);//2,5,8                    add(f[i + 1][c1][(c2 + 1) % 3][2][(t + c2) % 3], now2 * 4);//0,3,6,9                    add(f[i + 1][c1][c2][0][(t + c0) % 3], now2 * 3);//1,4,7                    add(f[i + 1][(c1 + 1) % 3][c2][1][(t + c1) % 3], now2 * 3);//2,5,8                &#125;    ll ans = 0;    for (int c1 = 0; c1 &lt; 3; c1++)        for (int c2 = 0; c2 &lt; 3; c2++)            for (int k = 0; k &lt; 3; k++)                add(ans, f[N][c1][c2][k][0]);    printf(&quot;%lld\\n&quot;, ans);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 709","url":"/project-euler/709/","content":"\r\nProject Euler 709\r\n题目\r\nEven Stevens\r\nEvery day for the past \\(n\\) days\r\nEven Stevens brings home his groceries in a plastic bag. He stores these\r\nplastic bags in a cupboard. He either puts the plastic bag into the\r\ncupboard with the rest, or else he takes an even number\r\nof the existing bags (which may either be empty or previously filled\r\nwith other bags themselves) and places these into the current bag.\r\nAfter \\(4\\) days there are \\(5\\) possible packings and if the bags are\r\nnumbered \\(1\\) (oldest), \\(2, 3, 4\\), they are:\r\n\r\nFour empty bags,\r\n\\(1\\) and \\(2\\) inside \\(3,\r\n4\\) empty,\r\n\\(1\\) and \\(3\\) inside \\(4,\r\n2\\) empty,\r\n\\(1\\) and \\(2\\) inside \\(4,\r\n3\\) empty,\r\n\\(2\\) and \\(3\\) inside \\(4,\r\n1\\) empty.\r\n\r\nNote that \\(1, 2, 3\\) inside \\(4\\) is invalid because every bag must\r\ncontain an even number of bags.\r\nDefine \\(f(n)\\) to be the number of\r\npossible packings of \\(n\\) bags. Hence\r\n\\(f(4)=5\\). You are also given \\(f(8)=1\\,385\\).\r\nFind \\(f(24\\,680)\\) giving your\r\nanswer modulo \\(1\\,020\\,202\\,009\\).\r\n解决方案\r\n考虑以动态规划的思想计算\\(f(n)\\)，那么可以列出如下状态转移方程：\r\n\\[\r\nf(n)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad  n=0\\lor n=1 \\\\\r\n  &amp;f(n)=\\sum_{k=0}^{\\left\\lfloor\\frac{n-1}{2}\\right\\rfloor}\\dbinom{n-1}{2k}\\cdot\r\nf(2k)\\cdot f(n-1-2k) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n提示：可以发现，这些塑料袋的嵌套关系可以用一棵树来描述：\r\n\r\n如果\\(A\\)装了\\(B,C\\)，那么\\(B,C\\)就是\\(A\\)的子节点。\r\n如果\\(B\\)又装了其它\\(D,E\\)，那么\\(A\\)也是\\(D,E\\)的祖先节点。\r\n\\(A\\)的子树就包括其所有的后代节点（不包括自身）。\r\n\r\n由于题目要求每一个节点都必须有偶数个子节点，因此任何一棵子树都有偶数个子节点。那么，\\(f(n)\\)的含义就变成：\\(n\\)个节点可以构成多少种满足以上要求的树的集合（森林）？\r\n当第\\(n\\)个节点到来时，考虑任意选择将\\(2k\\)“包裹”在第\\(n\\)个节点下，而这\\(2k\\)个节点任意组成的森林种类为\\(f(2k)\\)种，节点\\(n\\)最终将这\\(2k\\)个节点形成的森林练成一棵树；剩下的\\(n-1-2k\\)个节点中，它们也可以任意组成森林，有\\(f(n-1-2k)\\)种。这三个步骤是独立的，故得到以上状态转移方程。\r\n顺带一提，暴力枚举出前几项后，查询OEIS，发现结果为A000111。在FORMULA一栏中找到了如下信息：\r\n2*a(n+1) = Sum_&#123;k=0..n&#125; binomial(n, k)*a(k)*a(n-k).\r\n这给出了\\(f(n)\\)的另一条递推公式：\r\n\\[f(n+1)=\\dfrac{\\sum_{k=0}^n\\binom{n}{k}\\cdot\r\nf(k)\\cdot f(n-k)}{2}\\]\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=24680;int mod=1020202009;ll fac[N+4],finv[N+4],inv[N+4];ll C(int n,int m)&#123;    return 1ll*fac[n]*finv[m]%mod*finv[n-m]%mod;&#125;ll f[N+4];int main()&#123;    fac[0]=fac[1]=inv[1]=finv[0]=finv[1]=1;    for(int i=2;i&lt;=N;i++)&#123;        fac[i]=fac[i-1]*i%mod;        inv[i]=(mod-mod/i)*inv[mod%i]%mod;        finv[i]=finv[i-1]*inv[i]%mod;    &#125;    f[0]=f[1]=1;    for(int n=1;n&lt;N;n++)&#123;        for(int k=0;k&lt;=n;k+=2)            f[n+1]=(f[n+1]+1ll*C(n,k)*f[k]%mod*f[n-k])%mod;    &#125;    printf(&quot;%lld\\n&quot;,f[N]);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 704","url":"/project-euler/704/","content":"\r\nProject Euler 704\r\n题目\r\nFactors of Two in\r\nBinomial Coefficients\r\nDefine \\(g(n, m)\\) to be the largest\r\ninteger \\(k\\) such that \\(2^k\\) divides \\(\\binom{n}m\\).\r\nFor example, \\(\\binom{12}5 = 792 = 2^3\r\n\\cdot 3^2 \\cdot 11\\), hence \\(g(12, 5)\r\n= 3\\).\r\nThen define \\(F(n) = \\max \\{ g(n, m) : 0\r\n\\le m \\le n \\}\\). \\(F(10) = 3\\)\r\nand \\(F(100) = 6\\).\r\nLet \\(S(N)\\) = \\(\\displaystyle\\sum_{n=1}^N{F(n)}\\). You are\r\ngiven that \\(S(100) = 389\\) and \\(S(10^7) = 203222840\\).\r\nFind \\(S(10^{16})\\).\r\n解决方案\r\n枚举\\(F\\)的前几项，观察到以下序列：\r\n01 02 1 2 03 2 3 1 3 2 3 04 3 4 2 4 3 4 1 4 3 4 2 4 3 4 05 4 5 3 5 4 5 2 5 4 5 3 5 4 5 1 5 4 5 3 5 4 5 2 5 4 5 3 5 4 5 06 5 6 4 6 5 6 3 6 5 6 4 6 5 6 2 6 5 6 4 6 5 6 3 6 5 6 4 6 5 6 1 6 5 6 4\r\n将第\\(F(2^i)\\sim\r\nF(2^{i+1}-1)\\)全部放在一行，可以看到每一行其实是将上一行的所有值都加一，再复制一次拼接在自身后面（除了最后的\\(0\\)）。\r\n因此，直接通过规律写出并化简关于\\(S\\)的递推式：\r\n\\[\r\nS(n)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0 &amp; &amp; \\text{if}\\quad  n=1 \\\\\r\n  &amp;(i-3)\\cdot 2^i+i+3 &amp; &amp; \\text{else if}\\quad  \\exists\r\ni,2^i-1=n \\\\\r\n  &amp;S(f(n))+S\\left(n-\\dfrac{f(n)+1}{2}\\right)-S\\left(\\dfrac{f(n)-1}{2}\\right)+n-f(n)\r\n&amp; &amp; \\text{else if}\\quad  n\\le \\dfrac{3f(n)+1}{2} \\\\\r\n  &amp;2S(f(n))-2S\\left(\\dfrac{f(n)-1}{2}\\right)+S(n-f(n)-1)+n-f(n)&amp;\r\n&amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n其中，\\(f(n)\\)是小于等于\\(n\\)的最大的形如\\(2^i-1\\)的数。\r\nOEIS相关序列：A119387\r\n代码\r\nN = 10 ** 16def S(n):    fn = (1 &lt;&lt; ((n + 1).bit_length() - 1)) - 1    if fn == n:        i = (n + 1).bit_length() - 1        return (i - 3) * 2 ** i + i + 3    elif n * 2 &lt;= 3 * fn + 1:        return S(fn) + S(n - ((fn + 1) &gt;&gt; 1)) - S((fn - 1) &gt;&gt; 1) + n - fn    else:        return S(fn) * 2 - S((fn - 1) &gt;&gt; 1) * 2 + S(n - fn - 1) + n - fnans = S(N)print(ans)\r\n","categories":["Project Euler"],"tags":["OEIS"]},{"title":"Project Euler 71","url":"/project-euler/71/","content":"\r\nProject Euler 71\r\n题目\r\nOrdered fractions\r\nConsider the fraction, \\(\\dfrac{n}{d}\\), where n and d are positive\r\nintegers. If \\(n&lt;d\\) and \\(\\gcd(n,d)=1\\), it is called a reduced\r\nproper fraction. If we list the set of reduced proper fractions for\r\n\\(d \\leq 8\\) in ascending order of\r\nsize, we get:\r\n\\[\\dfrac{1}{8},\\dfrac{1}{7},\\dfrac{1}{6},\\dfrac{1}{5},\\dfrac{1}{4},\\dfrac{2}{7},\\dfrac{1}{3},\\dfrac{3}{8},\\mathbf{\\dfrac{2}{5}},\\dfrac{3}{7},\\dfrac{1}{2},\\dfrac{4}{7},\\dfrac{3}{5},\\dfrac{5}{8},\\dfrac{2}{3},\\dfrac{5}{7},\\dfrac{3}{4},\\dfrac{4}{5},\\dfrac{5}{6},\\dfrac{6}{7},\\dfrac{7}{8}\\]\r\nIt can be seen that \\(\\dfrac{2}{5}\\)\r\nis the fraction immediately to the left of \\(\\dfrac{3}{7}\\). By listing the set of\r\nreduced proper fractions for \\(d \\leq\r\n1,000,000\\) in ascending order of size, find the numerator of the\r\nfraction immediately to the left of \\(\\dfrac{3}{7}\\).\r\n解决方案\r\n本题所描述的序列为Farey\r\n序列。该序列有如下性质：\r\n对于任意的Farey 序列\\(F_n\\)，其中任意连续的三个分数序列\\(\\dfrac{x_1}{y_1},\\dfrac{x_2}{y_2},\\dfrac{x_3}{y_3}\\)，满足\\(\\dfrac{x_2}{y_2}=\\dfrac{x_1+x_3}{y_1+y_3}\\)。\r\n本题目前比\\(\\dfrac{3}{7}\\)小的最大分数为\\(\\dfrac{2}{5}\\)，在中间插入一个新值\\(\\dfrac{3+2}{7+5}=\\dfrac{5}{12}\\)后，可以发现这个新值比\\(\\dfrac{2}{5}\\)更大，但同时还是比\\(\\dfrac{3}{7}\\)小。在\\(\\dfrac{5}{12}\\)和\\(\\dfrac{3}{7}\\)中间继续插入后，得到\\(\\dfrac{8}{19}...\\)\r\n以此类推，每插入一个新的数，分子增长\\(3\\)，分母增长了\\(7\\)，新插入值的序列可以用\\(\\dfrac{2+3k}{5+7k}\\)来表示。\r\n因此，所求分数的值满足最大的\\(k\\)使得\\(5+7k\\leq\r\n10^6\\)。\r\n代码\r\nN = 10 ** 6ru, rd = 3, 7lu, ld = 2, 5k = (N - ld) // rdans = lu + ru * kprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 700","url":"/project-euler/700/","content":"\r\nProject Euler 700\r\n题目\r\nEulercoin\r\nLeonhard Euler was born on \\(15\\)\r\nApril \\(1707\\).\r\nConsider the sequence \\(1504170715041707n\r\n\\bmod 4503599627370517\\).\r\nAn element of this sequence is defined to be an Eulercoin if it is\r\nstrictly smaller than all previously found Eulercoins.\r\nFor example, the first term is \\(1504170715041707\\) which is the first\r\nEulercoin. The second term is \\(3008341430083414\\) which is greater than\r\n\\(1504170715041707\\) so is not an\r\nEulercoin. However, the third term is \\(8912517754604\\) which is small enough to be\r\na new Eulercoin.\r\nThe sum of the first \\(2\\)\r\nEulercoins is therefore \\(1513083232796311\\).\r\nFind the sum of all Eulercoins.\r\n解决方案\r\n令\\(A=1504170715041707,B=4503599627370517.\\)\r\n已知第一个欧拉币为\\(B\\)。假设\\(B=Aq+r,0\\le r&lt;\r\nA\\)，不难发现第二个欧拉币为\\(\\left\\lceil\\dfrac{B}{A}\\right\\rceil\\cdot\r\nA-B\\)，也就是\\((q+1)A\\equiv A-r \\pmod\r\nB\\).\r\n到了下一轮，相当于是在求\\((A-r)\\cdot\r\nn\\%A的\\)欧拉币。将当前\\(A-r\\)看做上一轮的\\(A\\)，将当前的\\(A\\)看成上一轮的\\(B\\)，那么解决问题的方法和上一轮相同（此处从规律中看出，尚未得到证明）。因此得到一个递推序列：\r\n令\\(e_0=B,e_1=A,e_n=-e_{n-2}\\%e_{n-1}\\)\r\n最终，存在一个项最终为\\(e_m=0\\)，那么对于\\(1\\le i&lt; m\\)，\\(e_i\\)都是欧拉币。\r\n代码\r\nA = 1504170715041707B = 4503599627370517ans = 0while A &gt; 0:    ans += A    A, B = -B % A, Aprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 710","url":"/project-euler/710/","content":"\r\nProject Euler 710\r\n题目\r\nOne Million Members\r\nOn Sunday 5 April 2020 the Project Euler membership first\r\nexceeded one million members. We would like to present this problem to\r\ncelebrate that milestone. Thank you to everyone for being a part of\r\nProject Euler.\r\nThe number \\(6\\) can be written as a\r\npalindromic sum in exactly eight different ways:\r\n\\[(1, 1, 1, 1, 1, 1), (1, 1, 2, 1, 1), (1,\r\n2, 2, 1), (1, 4, 1), (2, 1, 1, 2), (2, 2, 2), (3, 3), (6)\\]\r\nWe shall define a twopal to be a palindromic tuple having at\r\nleast one element with a value of \\(2\\). It should also be noted that elements\r\nare not restricted to single digits. For example, \\((3, 2, 13, 6, 13, 2, 3)\\) is a valid\r\ntwopal.\r\nIf we let \\(t(n)\\) be the number of\r\ntwopals whose elements sum to \\(n\\),\r\nthen it can be seen that \\(t(6) =\r\n4\\):\r\n\\[(1, 1, 2, 1, 1), (1, 2, 2, 1), (2, 1, 1,\r\n2), (2, 2, 2)\\]\r\nSimilarly, \\(t(20) = 824\\).\r\nIn searching for the answer to the ultimate question of life, the\r\nuniverse, and everything, it can be verified that \\(t(42) = 1999923\\), which happens to be the\r\nfirst value of \\(t(n)\\) that exceeds\r\none million.\r\nHowever, your challenge to the “ultimatest” question of life, the\r\nuniverse, and everything is to find the least value of \\(n \\gt 42\\) such that \\(t(n)\\) is divisible by one million.\r\n解决方案\r\n不难想到使用动态规划解决本题。\r\n由于回文序列的左右两半是完全相同的，因此只考虑其中的一半。\r\n令状态\\(f_0(i)(i\\ge\r\n0)\\)表示当前序列不存在\\(2\\)的情况下，能够组成和为\\(i\\)的任意长度序列有多少个，那么不难写出状态转移方程为：\r\n\\[\r\nf_0(i)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1 &amp; &amp; \\text{if}\\quad  i\\le1 \\\\\r\n  &amp;\\sum_{j=1}^{i} f_0(i-j)-f_0(i-2)&amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n上面的方程表示将状态\\(f_0(i-j)\\)中的所有序列都添加一个\\(i\\)，那么就成为了\\(f_0(i)\\)中的序列，当然\\(j\\)不能为\\(2\\)，因此后面减去\\(f_0(i-2)\\)。\r\n令\\(f_1(i)(i\\ge\r\n0)\\)表示当前序列存在\\(2\\)的情况下，能够组成和为\\(i\\)的任意长度序列有多少个，那么不难写出状态转移方程为：\r\n\\[\r\nf_1(i)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0 &amp; &amp; \\text{if}\\quad  i\\le1 \\\\\r\n  &amp;\\sum_{j=1}^{i} f_1(i-j)+f_0(i-2)&amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n上面的方程表示将状态\\(f_1(i-j)\\)中的所有序列都添加一个\\(i\\)，那么就成为了\\(f_1(i)\\)中的序列；此外，将\\(f_0(i-2)\\)中的序列再添加一个\\(2\\)，那么这个序列就存在了\\(2\\)，变成了状态\\(f_1(i)\\).\r\n回到本题，如果需要求\\(t(N)\\)，那么\r\n\r\n当\\(N\\)为奇数时，这个回文序列必定为奇数长度，并且中间的数必为奇数，所以两边的数必定有\\(2\\)。因此\\(t(N)=\\sum_{i=1}^{\\frac{N-1}{2}}f_1(i).\\)\r\n当\\(N\\)为偶数时，考虑严格在序列两边的数，这些数必定存在一个为\\(2\\)（这种情况和奇数时一样）；如果没有\\(2\\)，那么序列的长度必定为奇数长度，并且中间的值为\\(2\\)。因此\\(t(N)=\\sum_{i=1}^{\\frac{N}{2}}f_1(i)+f_0\\left(\\dfrac{N}{2}-1\\right).\\)\r\n\r\n最终从小到大枚举\\(N\\)即可。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2000004;int s[N][2],f[N][2],mod=1000000;int main()&#123;    f[0][0]=s[0][0]=1;    f[1][0]=1;s[1][0]=2;    int ans=0;    for(int n=2;n&lt;N;n++)&#123;        f[n][0]=(s[n-1][0]-f[n-2][0]+mod)%mod;        f[n][1]=(s[n-1][1]+f[n-2][0])%mod;        s[n][0]=(s[n-1][0]+f[n][0])%mod;        s[n][1]=(s[n-1][1]+f[n][1])%mod;        int a=s[n/2][1];        if(n%2==0) a=(a+f[n/2-1][0])%mod;        if(n&gt;42&amp;&amp;a%mod==0) &#123;ans=n;break;&#125;    &#125;    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 713","url":"/project-euler/713/","content":"\r\nProject Euler 713\r\n题目\r\nTurán’s water heating system\r\nTuran has the electrical water heating system outside his house in a\r\nshed. The electrical system uses two fuses in series, one in the house\r\nand one in the shed. (Nowadays old fashioned fuses are often replaced\r\nwith reusable mini circuit breakers, but Turan’s system still uses old\r\nfashioned fuses.) For the heating system to work both fuses must\r\nwork.\r\nTuran has \\(N\\) fuses. He knows that\r\n\\(m\\) of them are working and the rest\r\nare blown. However, he doesn’t know which ones are blown. So he tries\r\ndifferent combinations until the heating system turns on.\r\nWe denote by \\(T(N,m)\\) the smallest\r\nnumber of tries required to ensure the heating system turns on.\r\n\\(T(3,2)=3\\) and \\(T(8,4)=7\\).\r\nLet \\(L(N)\\) be the sum of all \\(T(N, m)\\) for \\(2\r\n\\leq m \\leq N\\). \\(L(10^3)=3281346\\)\r\nFind \\(L(10^7)\\).\r\n解决方案\r\n将\\(N\\)条保险丝视为\\(N\\)个节点，视作是一个无向图。当一开始的时候，\\(N\\)个节点都是两两相邻的。如果两个节点被进行了一次测试，那么就将它们之间的边删除。\r\n可以知道，如果将\\(m\\)条能够使用的保险丝两两相连，那么就会形成一个大小为\\(m\\)的团。因此按照上面的删边过程，至少要将图删边删到不存在大小为\\(m\\)的团。当一个图不存在大小为\\(m\\)的团时，那么必定能找到一种解。\r\n那么现在问题就转变成：\\(N\\)个节点，至多只能留下多少条边（至少能删去多少条边），使得这个图不存在大小为\\(m\\)的团。策略则是将这\\(N\\)个节点均匀尽可能相等地均匀划分成\\(m-1\\)块，块内的节点不连边，不属于同一块的节点连两条边。图兰定理说明这个图是图兰图\\(T_{N,m-1}.\\)\r\n图兰定理还给出了图兰图\\(T_{n,r}\\)的边数（假设\\(n=qr+s,0\\le s&lt;r\\)）：\r\n\\[\\left(1-\\dfrac{1}{r}\\right)\\dfrac{n^2-s^2}{2}+\\dfrac{s(s-1)}{2}\\]\r\n那么我们只需要求\\(T_{N,m-1}\\)补图边数即为答案。\r\n如果不知道图兰图与图兰定理这些内容，考虑小范围内枚举出一部分项，在OEIS中查询到结果为A134546。在FORMULA一栏，找到：\r\nT(n,k) = k*floor(n/k)*floor((n+k)/k)/2 - floor(n/k)*(k-1-(n mod k)). - Bob Selcoe, Aug 21 2016\r\n那么直接模拟这段式子直接计算\\(L\\)即可。\r\n代码\r\nN = 10 ** 7ans = 0for r in range(1, N):    q, s = divmod(N, r)    ans += r * q * (q - 1) // 2 + s * qprint(ans)\r\n","categories":["Project Euler"],"tags":["OEIS","图论"]},{"title":"Project Euler 712","url":"/project-euler/712/","content":"\r\nProject Euler 712\r\n题目\r\nExponent Difference\r\nFor any integer \\(n&gt;0\\) and prime\r\nnumber \\(p,\\) define \\(\\nu_p(n)\\) as the greatest integer \\(r\\) such that \\(p^r\\) divides \\(n\\).\r\nDefine \\[D(n, m)  = \\sum_{p \\text{ prime}}\r\n\\left| \\nu_p(n) - \\nu_p(m)\\right|.\\] For example, \\(D(14,24) = 4\\).\r\nFurthermore, define \\[S(N) = \\sum_{1 \\le\r\nn, m \\le N} D(n, m).\\] You are given \\(S(10) = 210\\) and \\(S(10^2) = 37018\\).\r\nFind \\(S(10^{12})\\). Give your\r\nanswer modulo \\(1\\,000\\,000\\,007\\).\r\nLehmer公式\r\nLehmer公式给出了质数计数函数\\(\\pi\\)的一个计算方式：\r\n\\[\\pi(x)=\\varphi(x,a)+\\dfrac{(b+a-2)(b-a+1)}{2}-\\sum_{i=a+1}^b\\pi\\left(\\dfrac{x}{p_i}\\right)-\\sum_{i=a+1}^c\\sum_{j=i}^{b_i}\\left(\\pi\\left(\\dfrac{x}{p_ip_j}\\right)-(j-1)\\right)\\]\r\n其中，\\(p_i\\)表示第\\(i\\)个质数，\\(a=\\pi(\\sqrt[4]{x}),b=\\pi(\\sqrt{x}),c=\\pi(\\sqrt[3]{x}),b_i=\\pi\\left(\\sqrt{\\dfrac{x}{p_i}}\\right)\\)\r\n其中\\(\\varphi(x,a)\\)是\\(n\\)以内的数中，质因数只由第\\(a+1\\)个及以后的质数的个数，用容斥原理可以写成：\r\n\\[\\varphi(x,a)=x-\\sum_{i=1}^a\\left\\lfloor\\dfrac{x}{p_i}\\right\\rfloor+\\sum_{1\\le\r\ni\\le j\\le\r\na}\\left\\lfloor\\dfrac{x}{p_ip_j}\\right\\rfloor-\\dots\\]\r\n为了方便计算，页面说明\\(\\varphi(x,a)\\)还可以写成以下递推式形式：\r\n\\[\r\n\\varphi(x,a)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;\\left\\lceil\\dfrac{x}{2}\\right\\rceil  &amp; &amp; \\text{if}\\quad\r\nx=0\\lor a=1 \\\\\r\n  &amp;\\varphi(x,a-1)-\\varphi\\left(\\left\\lfloor\\dfrac{x}{p_a}\\right\\rfloor,a-1\\right)\r\n&amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n在计算函数\\(\\pi\\)和\\(\\varphi\\)时，需要使用记忆化方法记录函数值。\r\n解决方案\r\n本解决方案参考了Thread中的一些内容。\r\n令\\(N=10^{12}\\)。不难想到，单独考虑每一个的质数\\(p\\)，求取它们的贡献并相加。\r\n假设质数集合为\\(P\\)。我们考虑将\\(N\\)以内的质数分成两部分考虑：小于等于\\(\\lfloor\\sqrt{N}\\rfloor\\)和大于\\(\\lfloor\\sqrt{N}\\rfloor\\)的两部分。\r\n小于等于\\(\\lfloor\\sqrt{N}\\rfloor\\)的质数\\(p\\)这一部分贡献为：\r\n\\[\\sum_{p\\in P,p\\le\r\n\\lfloor\\sqrt{N}\\rfloor}\\sum_{i=0}^{+\\infty}\\sum_{j=i+1}^{+\\infty}2\\left(\\left\\lfloor\\dfrac{N}{p^i}\\right\\rfloor-\\left\\lfloor\\dfrac{N}{p^{i+1}}\\right\\rfloor\\right)\\left(\\left\\lfloor\\dfrac{N}{p^j}\\right\\rfloor-\\left\\lfloor\\dfrac{N}{p^{j+1}}\\right\\rfloor\\right)(j-i)\\]\r\n其中，上面的式子可以化简：\r\n\\[\\begin{aligned}\r\n&amp;\\sum_{i=0}^{+\\infty}\\sum_{j=i+1}^{+\\infty}\\left(\\left\\lfloor\\dfrac{N}{p^i}\\right\\rfloor-\\left\\lfloor\\dfrac{N}{p^{i+1}}\\right\\rfloor\\right)\\left(\\left\\lfloor\\dfrac{N}{p^j}\\right\\rfloor-\\left\\lfloor\\dfrac{N}{p^{j+1}}\\right\\rfloor\\right)\\left(j-i\\right)\\\\\r\n=&amp;\\sum_{i=0}^{+\\infty}\\left(\\left\\lfloor\\dfrac{N}{p^i}\\right\\rfloor-\\left\\lfloor\\dfrac{N}{p^{i+1}}\\right\\rfloor\\right)\\sum_{j=i+1}^{+\\infty}\\left(\\left\\lfloor\\dfrac{N}{p^j}\\right\\rfloor-\\left\\lfloor\\dfrac{N}{p^{j+1}}\\right\\rfloor\\right)\\left(j-i\\right)\\\\\r\n=&amp;\\sum_{i=0}^{+\\infty}\\left(\\left\\lfloor\\dfrac{N}{p^i}\\right\\rfloor-\\left\\lfloor\\dfrac{N}{p^{i+1}}\\right\\rfloor\\right)\\sum_{j=1}^{+\\infty}\\left(\\left\\lfloor\\dfrac{N}{p^{i+j}}\\right\\rfloor-\\left\\lfloor\\dfrac{N}{p^{i+j+1}}\\right\\rfloor\\right)\\cdot\r\nj\\\\\r\n=&amp;\\sum_{i=0}^{+\\infty}\\left(\\left\\lfloor\\dfrac{N}{p^i}\\right\\rfloor-\\left\\lfloor\\dfrac{N}{p^{i+1}}\\right\\rfloor\\right)\\sum_{j=1}^{+\\infty}\\left\\lfloor\\dfrac{N}{p^{i+j}}\\right\\rfloor\\\\\r\n=&amp;\\left(\\sum_{i=0}^{+\\infty}\\left\\lfloor\\dfrac{N}{p^i}\\right\\rfloor\\cdot\\sum_{j=1}^{+\\infty}\\left\\lfloor\\dfrac{N}{p^{i+j}}\\right\\rfloor\\right)-\\left(\\sum_{i=0}^{+\\infty}\\left\\lfloor\\dfrac{N}{p^{i+1}}\\right\\rfloor\\cdot\\sum_{j=1}^{+\\infty}\\left\\lfloor\\dfrac{N}{p^{i+j}}\\right\\rfloor\\right)\\\\\r\n=&amp;N\\cdot\\sum_{j=1}^{+\\infty}\\left\\lfloor\\dfrac{N}{p^j}\\right\\rfloor+\r\n\\left(\\sum_{i=1}^{+\\infty}\\left\\lfloor\\dfrac{N}{p^i}\\right\\rfloor\\cdot\\sum_{j=1}^{+\\infty}\\left\\lfloor\\dfrac{N}{p^{i+j}}\\right\\rfloor\\right)-\\left(\\sum_{i=1}^{+\\infty}\\left\\lfloor\\dfrac{N}{p^{i}}\\right\\rfloor\\cdot\\sum_{j=1}^{+\\infty}\\left\\lfloor\\dfrac{N}{p^{i+j-1}}\\right\\rfloor\\right)\\\\\r\n=&amp;N\\cdot\\sum_{j=1}^{+\\infty}\\left\\lfloor\\dfrac{N}{p^j}\\right\\rfloor+\r\n\\left(\\sum_{i=1}^{+\\infty}\\left\\lfloor\\dfrac{N}{p^i}\\right\\rfloor\\cdot\\sum_{j=1}^{+\\infty}\\left(\\left\\lfloor\\dfrac{N}{p^{i+j}}\\right\\rfloor-\\left\\lfloor\\dfrac{N}{p^{i+j-1}}\\right\\rfloor\\right)\\right)\\\\\r\n=&amp;N\\cdot\\sum_{j=1}^{+\\infty}\\left\\lfloor\\dfrac{N}{p^j}\\right\\rfloor-\r\n\\left(\\sum_{i=1}^{+\\infty}\\left\\lfloor\\dfrac{N}{p^i}\\right\\rfloor\\cdot\\left\\lfloor\\dfrac{N}{p^i}\\right\\rfloor\\right)\\\\\r\n=&amp;\\sum_{i=1}^{+\\infty}\\left(N-\\left\\lfloor\\dfrac{N}{p^i}\\right\\rfloor\\right)\\cdot\\left\\lfloor\\dfrac{N}{p^i}\\right\\rfloor\\\\\r\n\\end{aligned}\\]\r\n那么计算以下式子只需要计算\\(O(\\sqrt{N}\\cdot\r\n\\log N)\\)的时间复杂度：\r\n\\[\\sum_{p\\in P,p\\le\r\n\\lfloor\\sqrt{N}\\rfloor}\\sum_{i=1}^{+\\infty}\\left(N-\\left\\lfloor\\dfrac{N}{p^i}\\right\\rfloor\\right)\\cdot\\left\\lfloor\\dfrac{N}{p^i}\\right\\rfloor\\\\\\]\r\n大于\\(\\lfloor\\sqrt{N}\\rfloor\\)的质数\\(p\\)这一部分贡献如下。注意到，\\(1\\sim N\\)中，\\(p\\)的指数最多为\\(1\\)：\r\n\\[\\sum_{i=2}^{\\lfloor\\sqrt{N}\\rfloor}\\left(\\pi\\left(\\dfrac{N}{i-1}\\right)-\\pi\\left(\\dfrac{N}{i}\\right)\\right)\\cdot(i-1)(N-i+1)\\]\r\n这条式子说明，有\\(\\pi\\left(\\dfrac{N}{i-1}\\right)-\\pi\\left(\\dfrac{N}{i}\\right)\\)个质数\\(p\\)，满足\\(1\\sim\r\nN\\)中有\\(i-1\\)个数是\\(p\\)的倍数，它们的贡献为\\((i-1)(N-i+1)\\)。\r\n计算函数\\(\\pi\\)考虑使用Lehmer公式帮助计算。\r\n代码\r\n本代码效率略低，约\\(30s\\)，仍有很大改进空间。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll N = 1000000000000;ll mod=1000000007;const ll M = N&lt;=10000?10000:pow(N, 2.0 / 3) + 2;bool vis[M + 1];int sum[M + 1],pr[M + 1],m;unordered_map&lt;ll,ll&gt; mp,mq;ll phi(ll x, ll a) &#123;    if (a == 1 || x == 0)return (x + 1) / 2;    ll &amp;v = mp[(x &lt;&lt; 10) + a];    if (v)return v;    return v = phi(x, a - 1) - phi(x / pr[a], a - 1);&#125;ll pi(ll n) &#123;    if (n &lt;= M)return sum[n];    ll &amp;v = mq[n];    if (v) return v;    ll a = pi(pow(n, 1.0 / 4));    ll b = pi(sqrt(n));    ll c = pi(pow(n, 1.0 / 3));    ll s = phi(n, a) + (b + a - 2) * (b - a + 1) / 2;    for (ll i = a + 1; i &lt;= b; i++) &#123;        ll w = n / pr[i];        s -= pi(w);        ll bi = pi(sqrt(w));        if (i &lt;= c) &#123;            for (ll j = i; j &lt;= bi; j++)                s += j - 1 - pi(w / pr[j]);        &#125;    &#125;    return v = s;&#125;ll cal(ll p)&#123;    ll ans=0;    for(ll x=N/p;x;x/=p)&#123;        ans=(ans+x%mod*((N-x)%mod))%mod;    &#125;    return ans*2%mod;&#125;int main() &#123;    for (ll i = 2; i &lt;= M; i++) &#123;        if (!vis[i]) &#123;            for (ll j = i * i; j &lt;= M; j += i) vis[j] = 1;            pr[++m] = i;        &#125;        sum[i] = m;    &#125;    ll ans=0;    for(int i=1;i&lt;=m&amp;&amp;1ll*pr[i]*pr[i]&lt;=N;i++)        ans=(ans+cal(pr[i]))%mod;    for(int i=2;1ll*i*i&lt;=N;i++)        ans=(ans+(N-i+1)%mod*(i-1)%mod*((pi(N/(i-1))-pi(N/i))%mod)*2%mod)%mod;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 70","url":"/project-euler/70/","content":"\r\nProject Euler 70\r\n题目\r\nTotient permutation\r\nEuler’s Totient function, \\(\\varphi(n)\\) [sometimes called the phi\r\nfunction], is used to determine the number of numbers less than \\(n\\) which are relatively prime to \\(n\\). For example, as \\(1, 2, 4, 5, 7,\\) and \\(8\\), are all less than nine and relatively\r\nprime to nine, \\(\\varphi(9)=6\\).\r\nThe number \\(1\\) is considered to be\r\nrelatively prime to every positive number, so \\(\\varphi(1)=1\\).\r\nInterestingly, \\(\\varphi(87109)=79180\\), and it can be seen\r\nthat \\(87109\\) is a permutation of\r\n\\(79180\\).\r\nFind the value of \\(n, 1 &lt; n &lt;\r\n10^7\\), for which \\(\\varphi(n)\\)\r\nis a permutation of \\(n\\) and the ratio\r\n\\(n/\\varphi(n)\\) produces a\r\nminimum.\r\n解决方案\r\n需要注意，本题是求得满足排列要求的，并且使\\(\\dfrac{n}{\\varphi(n)}\\)最小的，在范围\\(n&lt;N\\)内的一个\\(n\\)。\r\n根据欧拉函数的公式\\(\\displaystyle{\\varphi(n)=n\\prod_{i=1}^k\\left(1-\\dfrac{1}{p_i}\\right)}\\)，可以知道，这个比值就等于\\(\\displaystyle{\\prod_{i=1}^k\r\n\\dfrac{p_i}{p_i-1}}\\).\r\n根据这个式子可以发现，只需要考虑质因数质数不大于\\(1\\)的情况即可，因为这个式子的大小和\\(e_i\\)没有任何关系。\r\n单独讨论一个质数\\(p\\)。很明显的是，随着\\(p\\)的增长，\\(\\dfrac{p}{p-1}\\)值逐渐减小。这说明，求出的\\(n\\)的质因数都应该是尽可能大的。\r\n因此，有另外一个推论：\\(n\\)的质因数个数越少越好。\r\n先考虑只有一个质因数的情况，也就是质数\\(p\\)。但是,\\(\\varphi(p)=p-1\\)，\\(p-1\\)不可能是\\(p\\)的一个排列。\r\n故考虑两个质因数的情况。枚举所有比较接近\\(\\sqrt\r\nN\\)的质数，将它们两两相乘，得到一些列形如\\(p_ip_j\\)，其中\\(p_ip_j\\leq N\\)的数，直接筛选。\r\n代码\r\nfrom gmpy2 import isqrtfrom tools import get_primeN = 10 ** 7M = isqrt(N)pr = get_prime(M // 5, M * 5 - 1)val = 100for i in range(len(pr)):    for j in range(i + 1, len(pr)):        w = pr[i] * pr[j]        if w &gt;= N:            break        phi = (pr[i] - 1) * (pr[j] - 1)        if &quot;&quot;.join((lambda x: (x.sort(), x)[1])(list(str(w)))) == \\                &quot;&quot;.join((lambda x: (x.sort(), x)[1])(list(str(phi)))) and w / phi &lt; val:            val = w / phi            ans = wprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 72","url":"/project-euler/72/","content":"\r\nProject Euler 72\r\n题目\r\nCounting fractions\r\nConsider the fraction, \\(\\dfrac{n}{d}\\), where n and d are positive\r\nintegers. If \\(n&lt;d\\) and \\(\\gcd(n,d)=1\\), it is called a reduced\r\nproper fraction. If we list the set of reduced proper fractions for\r\n\\(d \\leq 8\\) in ascending order of\r\nsize, we get:\r\n\\[\\dfrac{1}{8},\\dfrac{1}{7},\\dfrac{1}{6},\\dfrac{1}{5},\\dfrac{1}{4},\\dfrac{2}{7},\\dfrac{1}{3},\\dfrac{3}{8},\\dfrac{2}{5},\\dfrac{3}{7},\\dfrac{1}{2},\\dfrac{4}{7},\\dfrac{3}{5},\\dfrac{5}{8},\\dfrac{2}{3},\\dfrac{5}{7},\\dfrac{3}{4},\\dfrac{4}{5},\\dfrac{5}{6},\\dfrac{6}{7},\\dfrac{7}{8}\\]\r\nIt can be seen that there are \\(21\\)\r\nelements in this set.\r\nHow many elements would be contained in the set of reduced proper\r\nfractions for \\(d \\leq 1,000,000\\)?\r\n解决方案\r\n根据题意，第\\(m\\)个Farey 序列\\(F_m\\)的所有元素可以由该集合定义：\\(\\left\\{\\dfrac{n}{d} | \\gcd(n,d)=1,1\\le n&lt;d \\le\r\nm\\right\\}\\).\r\n通过分子分母互质的性质，联系到欧拉函数\\(\\varphi\\)的定义，可以得出本题答案：\r\n\\[\\sum_{i=1}^m \\varphi(i)-1\\]\r\n代码\r\nN = 1000000phi = [i for i in range(N + 1)]for i in range(2, N + 1):    if i == phi[i]:        for j in range(i, N + 1, i):            phi[j] //= i            phi[j] *= i - 1ans = sum(phi) - 1print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 719","url":"/project-euler/719/","content":"\r\nProject Euler 719\r\n题目\r\nNumber Splitting\r\nWe define an \\(S\\)-number to be a\r\nnatural number, \\(n\\), that is a\r\nperfect square and its square root can be obtained by splitting the\r\ndecimal representation of \\(n\\) into\r\n\\(2\\) or more numbers then adding the\r\nnumbers.\r\nFor example, \\(81\\) is an \\(S\\)-number because \\(\\sqrt{81} = 8+1\\).\r\n\\(6724\\) is an \\(S\\)-number: \\(\\sqrt{6724} = 6+72+4\\).\r\n\\(8281\\) is an \\(S\\)-number: \\(\\sqrt{8281} = 8+2+81 = 82+8+1\\).\r\n\\(9801\\) is an \\(S\\)-number: \\(\\sqrt{9801}=98+0+1\\).\r\nFurther we define \\(T(N)\\) to be the\r\nsum of all \\(S\\) numbers \\(n\\le N\\). You are given \\(T(10^4) = 41333\\).\r\nFind \\(T(10^{12})\\)\r\n解决方案\r\n对于\\(n&gt;1\\)，永远不会出现\\(n^2=n\\)的情况，因此这里不需要判断一个正确的划分方案是否只有一个数（而不是多个数相加）。\r\n另外一个优化之处则是只有当\\(n\\%9&lt;2\\)时，\\(n^2\\)才有可能是一个候选答案，原因：假设\\(d\\)是\\(n\\)的各位数字之和，那么无论等式右侧的数如何划分，它们的数位和模\\(9\\)和\\(n^2\\)的数位和模\\(9\\)是一样的。根据\\(S\\)数的定义，\\(n\\)和这些划分后的数位值相加相等，因此\\(n^2\\equiv n\\pmod 9.\\)\r\n其余的部分则使用深度优先搜索对\\(n\\)进行判断，在判断的过程中，注意加法的每个项不可能超过\\(n\\).\r\n代码\r\n# include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const ll N=1e12;ll m;int a[25],p=0;bool dfs(int f,ll s,ll w)&#123;    if(s&gt;m||w&gt;m) return 0;    if(f==p) return s+w==m;    if(dfs(f+1,s+w,a[f])||dfs(f+1,s,w*10+a[f])) return 1;    return 0;&#125;int main()&#123;    ll ans=0;    for(m=4;m*m&lt;=N;m++)&#123;        if(m%9&gt;1) continue;        ll t=m*m;        p=0;        for(;t;t/=10) a[p++]=t%10;        reverse(a,a+p);        if(dfs(0,0,0)) ans+=m*m;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 720","url":"/project-euler/720/","content":"\r\nProject Euler 720\r\n题目\r\nUnpredictable Permutations\r\nConsider all permutations of \\(\\{1, 2,\r\n\\ldots N\\}\\), listed in lexicographic order.\r\nFor example, for \\(N=4\\), the list\r\nstarts as follows:\r\n\\[\\begin{aligned}\r\n(1, 2, 3, 4) \\\\\r\n(1, 2, 4, 3) \\\\\r\n(1, 3, 2, 4) \\\\\r\n(1, 3, 4, 2) \\\\\r\n(1, 4, 2, 3) \\\\\r\n(1, 4, 3, 2) \\\\\r\n(2, 1, 3, 4) \\\\\r\n\\vdots\r\n\\end{aligned}\\]\r\nLet us call a permutation \\(P\\)\r\nunpredictable if there is no choice of three indices \\(i \\lt j \\lt k\\) such that \\(P(i)\\), \\(P(j)\\) and \\(P(k)\\) constitute an arithmetic\r\nprogression. For example, \\(P=(3, 4, 2,\r\n1)\\) is not unpredictable because \\(P(1), P(3), P(4)\\) is an arithmetic\r\nprogression.\r\nLet \\(S(N)\\) be the position within\r\nthe list of the first unpredictable permutation.\r\nFor example, given \\(N = 4\\), the\r\nfirst unpredictable permutation is \\((1, 3, 2,\r\n4)\\) so \\(S(4) = 3\\).\r\nYou are also given that \\(S(8) =\r\n2295\\) and \\(S(32) \\equiv 641839205\r\n\\pmod{1\\,000\\,000\\,007}\\).\r\nFind \\(S(2^{25})\\). Give your answer\r\nmodulo \\(1\\,000\\,000\\,007\\).\r\n解决方案\r\n令\\(N=25\\)。本题主要依靠打表找规律的方法解决。\r\n使用以下程序分别暴力打印出题目所需要的\\(2,4,8,16\\)阶排列：\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int a[18],n;bool b[18];bool dfs(int f)&#123;    if(f==n+1)&#123;        printf(&quot;%2d:&quot;,n);        for(int i=1;i&lt;=n;i++)            printf(&quot;%2d%c&quot;,a[i],&quot; \\n&quot;[i==n]);        return 1;    &#125;    else&#123;        for(int k=1;k&lt;=n;k++)&#123;            if(b[k]) continue;            bool ok=1;            for(int j=1;j&lt;f&amp;&amp;ok;j++)                for(int i=1;i&lt;j&amp;&amp;ok;i++)                    if((a[j]&lt;&lt;1)==a[i]+k) ok=0;            if(ok)&#123;                b[k]=1;                a[f]=k;                if(dfs(f+1)) return 1;                b[k]=0;            &#125;        &#125;    &#125;    return 0;&#125;int main()&#123;    for(n=2;n&lt;=16;n&lt;&lt;=1)&#123;        memset(b,0,sizeof(b));        dfs(1);    &#125;&#125;\r\n结果如下：\r\n 2: 1  2 4: 1  3  2  4 8: 1  5  3  2  7  6  4  816: 1  9  5  3 13 11  7  2 15 10  6  4 14 12  8 16\r\n从第\\(4\\)个排列起，可以发现，第\\(2n\\)个排列\\(P_{2n}\\)可以由第\\(n\\)个排列\\(P_n\\)产生而来：\r\n\r\n先将\\(P_n\\)中的所有数全部乘\\(2\\)，拼在\\(P_{2n}\\)的右半部分。\r\n再将\\(P_n\\)中的所有数全部乘\\(2\\)再减去\\(1\\)，拼在\\(P_{2n}\\)的左半部分。\r\n将中间的两个数交换，最终结果就是\\(P_{2n}\\)。\r\n\r\n这个过程可以在线性的时间复杂度完成。\r\n构造完这个排列后，基于康托展开的思想，使用树状数组直接计算这个排列的编码即可。时间复杂度为\\(O(N\\cdot 2^N)\\)。\r\n由于这个排列比较特殊，我们可以用一个数组\\(c\\)来维护\\(P_n\\)排列的信息：\\(c_n[i]\\)表示\\(P_n(i)\\)中右边有多少个数小于\\(P_n(i)\\)。\r\n对于左半部分，由于左半部分恰好是右半部分中每个数减去\\(1\\)，因此\\(c_{2n}[i]=c_n[i]+P_n(i)-1\\)；右半部分和\\(P_n\\)的相对大小没有变化，因此\\(P_{2n}(i+n)=P_n(i)\\)。\r\n不过，上面的结论对\\(i=n,n-1\\)时不成立，因为它还忽略了上面构造排列的第三个步骤。考虑第三个步骤后，\\(P_{2n}(n-1)=2\\)，因此\\(c_{2n}[n-1]=0\\)。更小的\\(2\\)被换到前面，那么实际上还需要减去\\(1\\)，因此\\(c_{2n}[n]=P_n(n-1)+c_n[n-1]-2\\)。\r\n那么最终答案为\\(\\sum_{i=0}^{2^N-1} i!\\cdot\r\nc_{2^N}[2^N-1-i]\\)，以更快的效率将康托展开系数处理了出来。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;#define lb(x) ((x)&amp;-(x))using namespace std;typedef long long ll;const int N=25;const int M=1&lt;&lt;N;int a[M]=&#123;1,3,2,4&#125;,m=4;int fac[M+1],mod=1000000007;void add(int &amp;x, int y) &#123;    (x += y) &gt;= mod &amp;&amp; (x -= mod);&#125;int s[M+1];void update(int p)&#123;    for(int i=p;i&lt;=M;i+=lb(i))        ++s[i];&#125;int que(int p)&#123;    int ans=0;    for(int i=p;i;i-=lb(i))        add(ans,s[i]);    return ans;&#125;int main()&#123;    fac[0]=1;    for(int i=1;i&lt;=M;i++)        fac[i]=1ll*fac[i-1]*i%mod;    while(m&lt;M)&#123;        for(int i=0;i&lt;m;i++)&#123;            a[m+i]=a[i]*2;            a[i]=a[i]*2-1;        &#125;        swap(a[m],a[m-1]);        m&lt;&lt;=1;    &#125;    int ans=1;    for(int i=0;i&lt;M;i++)&#123;        add(ans,1ll*(a[i]-que(a[i])-1)*fac[M-i-1]%mod);        update(a[i]);    &#125;    printf(&quot;%d\\n&quot;,ans);&#125;\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=25;const int M=1&lt;&lt;N;int a[M]=&#123;1,3,2,4&#125;,m=4;int c[M]=&#123;0,1,0,0&#125;;int mod=1000000007;int main()&#123;    while(m&lt;M)&#123;        for(int i=0;i&lt;m;i++)            c[i+m]=c[i];        c[m]=c[m-1]+a[m-1]-2;        for(int i=0;i&lt;m;i++)            c[i]+=a[i]-1;        c[m-1]=0;        for(int i=0;i&lt;m;i++)&#123;            a[m+i]=a[i]*2;            a[i]=a[i]*2-1;        &#125;        swap(a[m],a[m-1]);        m&lt;&lt;=1;    &#125;    ll ans=1,fac=1;    for(int i=0;i&lt;M;i++)&#123;        ans=(fac*c[M-1-i]+ans)%mod;        fac=fac*(i+1)%mod;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["树状数组"]},{"title":"Project Euler 721","url":"/project-euler/721/","content":"\r\nProject Euler 721\r\n题目\r\nHigh powers of irrational\r\nnumbers\r\nGiven is the function \\(f(a,n)=\\lfloor{(\\lceil{\\sqrt{a}\\:\\rceil}+\\sqrt{a}\\:)^n}\\rfloor\\).\r\n\\(\\lfloor{.}\\rfloor\\) denotes the\r\nfloor function and \\(\\lceil{.}\\rceil\\)\r\ndenotes the ceiling function.\r\n\\(f(5,2)=27\\) and \\(f(5,5)=3935\\).\r\n\\(G(n) = \\displaystyle \\sum_{a=1}^n f(a,\r\na^2).\\)\r\n$G(1000) 999,999,937=163861845. $\r\nFind \\(G(5\\,000\\,000).\\) Give your\r\nanswer modulo \\(999\\,999\\,937\\).\r\n解决方案\r\n由于\\(\\lceil\\sqrt{a}\\:\\rceil-\\sqrt{a}&lt;1\\)，并且根据二项式定理展开，补上共轭项消去根号，因此实际上\\(f(a,n)\\)可以写成：\r\n\\[f(a,n)=(\\lceil{\\sqrt{a}\\:\\rceil}+\\sqrt{a}\\:)^n+(\\lceil{\\sqrt{a}\\:\\rceil}-\\sqrt{a}\\:)^n-[\\nexists\r\nx:x^2=a]\\]\r\n其中，\\([]\\)为示性函数，这说明如果\\([]\\)中的值为真，那么函数值为\\(1\\)，否则为\\(0\\)。令\\(g(a,n)=(\\lceil{\\sqrt{a}\\:\\rceil}+\\sqrt{a}\\:)^n+(\\lceil{\\sqrt{a}\\:\\rceil}-\\sqrt{a}\\:)^n\\)，也就是\\(g(a,n)=f(a,n)+[\\nexists\r\nx:x^2=a]\\)。可以发现，\\(g(a,n)\\)为一个关于\\(n\\)的二阶线性递推式。因此接下来的思路是将\\(g(a,n)\\)写成矩阵快速幂形式，再通过矩阵快速幂进行加速计算。\r\n那么，假设这个线性递推式为\\(g(a,n)=p\\cdot\r\ng(a,n-1)+q\\cdot g(a,n-2)\\)。移项后可以写成：\r\n\\[g(a,n)-p\\cdot g(a,n-1)-q\\cdot\r\ng(a,n-2)=0\\]\r\n根据韦达定理，可以得到\r\n\\[\\left\\{\\begin{aligned}\r\n&amp;-p=-(\\lceil{\\sqrt{a}\\:\\rceil}+\\sqrt{a}\\:)-(\\lceil{\\sqrt{a}\\:\\rceil}-\\sqrt{a}\\:)\\\\\r\n&amp;-q=(\\lceil{\\sqrt{a}\\:\\rceil}+\\sqrt{a}\\:)\\cdot(\\lceil{\\sqrt{a}\\:\\rceil}-\\sqrt{a}\\:)\r\n\\end{aligned}\\right.\\]\r\n化简后也就是\r\n\\[\\left\\{\\begin{aligned}\r\n&amp;p=2\\cdot\\lceil{\\sqrt{a}\\:\\rceil}\\\\\r\n&amp;q=a-\\lceil{\\sqrt{a}\\:\\rceil}^2\r\n\\end{aligned}\\right.\\]\r\n其中，$g(a,0)=2,g(a,1)=2 $。\r\n通过写成如下矩阵形式加速计算，最终将计算出来的\\(g\\)回代到\\(f\\)中得到结果。 \\[\r\n\\begin{bmatrix}\r\ng(a,n-1)\\\\\r\ng(a,n)\r\n\\end{bmatrix}=\r\n\\begin{bmatrix}\r\n0 &amp; 1\\\\\r\na-\\lceil{\\sqrt{a}\\:\\rceil}^2 &amp; 2\\cdot\\lceil{\\sqrt{a}\\:\\rceil}\r\n\\end{bmatrix}\r\n\\cdot\r\n\\begin{bmatrix}\r\ng(a,n-2)\\\\\r\ng(a,n-1)\r\n\\end{bmatrix}\r\n\\]\r\n代码\r\n#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=5000000;ll mod=999999937;void mul_self(ll b[2][2])&#123;    ll c[2][2]=&#123;0&#125;;    for(int i=0;i&lt;2;i++)        for(int j=0;j&lt;2;j++)            for(int k=0;k&lt;2;k++)                c[i][j]=(c[i][j]+b[i][k]*b[k][j])%mod;    memcpy(b,c,sizeof(c));&#125;void mul(ll a[2],ll b[2][2])&#123;    ll c[2]=&#123;0&#125;;    for(int i=0;i&lt;2;i++)        for(int k=0;k&lt;2;k++)            c[i]=(c[i]+a[k]*b[k][i])%mod;    memcpy(a,c,sizeof(c));&#125;ll a[2],b[2][2];ll g(ll u,ll n)&#123;    ll t=ceil(sqrt(u));    a[0]=2;a[1]=t*2;    b[0][0]=0;b[1][0]=1;    b[0][1]=u-t*t;b[1][1]=t*2;    for(;n;n&gt;&gt;=1)&#123;        if(n&amp;1) mul(a,b);        mul_self(b);    &#125;    return a[0];&#125;bool isq[N+4];int main()&#123;    ll ans=0;    for(int a=1;a*a&lt;=N;a++)        isq[a*a]=1;    for(ll a=1;a&lt;=N;a++)&#123;        ans=(ans+g(a,a*a)-!isq[a]+mod)%mod;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 717","url":"/project-euler/717/","content":"\r\nProject Euler 717\r\n题目\r\nSummation of a Modular\r\nFormula\r\nFor an odd prime \\(p\\), define \\(f(p) =\r\n\\left\\lfloor\\frac{2^{(2^p)}}{p}\\right\\rfloor\\bmod{2^p}\\)\r\nFor example, when \\(p=3\\), \\(\\lfloor 2^8/3\\rfloor = 85 \\equiv 5 \\pmod\r\n8\\) and so \\(f(3) = 5\\).\r\nFurther define \\(g(p) = f(p)\\bmod\r\np\\). You are given \\(g(31) =\r\n17\\).\r\nNow define \\(G(N)\\) to be the\r\nsummation of \\(g(p)\\) for all odd\r\nprimes less than \\(N\\).\r\nYou are given \\(G(100) = 474\\) and\r\n\\(G(10^4) = 2819236\\).\r\nFind \\(G(10^7)\\)\r\n解决方案\r\n本题参考了Thread中的一些解法。\r\n令\\(r=2^{2^p}\\%p\\)，那么有\\(f(p)\\equiv\\dfrac{2^{2^p}-r}{p}\\equiv-\\dfrac{r}{p}\\pmod\r\n{2^p}\\).\r\n注意到\\(i_p=\\dfrac{(p-1)/2\\cdot\r\n2^p+1}{p}=\\dfrac{(p-1)\\cdot 2^{p-1}+1}{p}\\)是一个整数，且\\(p\\cdot\r\ni_p\\equiv1\\pmod{2^p}\\)成立。因此\\(i_p\\)确实是\\(p\\)在模\\(2^p\\)上的逆元。\r\n那么就有\\(f(p)=-r\\cdot\\dfrac{(p-1)\\cdot\r\n2^{p-1}+1}{p}\\% 2^p\\)。这个数相当于是找一个最小的整数\\(k\\)，使得\\(k\\cdot\r\n2^p-r\\cdot\\dfrac{(p-1)\\cdot 2^{p-1}+1}{p}\\ge 0\\)成立。即可有\\(k\\ge\\dfrac{r(p-1)}{2p}+\\dfrac{r}{p\\cdot\r\n2^p}\\)。由于第二个项的分母为\\(p\\cdot\r\n2^p\\)，数量级远远小于第一个项。因此仅需表明\\(k&gt;\\dfrac{r(p-1)}{2p}\\)即可。也就是有\\(k=\\left\\lfloor\\dfrac{r(p-1)}{2p}\\right\\rfloor+1\\)。\r\n接下来是计算\\(\\dfrac{(p-1)\\cdot\r\n2^{p-1}+1}{p}\\%p\\)的值，其值等于\\(\\dfrac{((p-1)\\cdot 2^{p-1}+1)\\%\r\np^2}{p}\\)。\r\n因此最终有\r\n\\(\\begin{aligned}\r\nf(p)\\%p&amp;=\\left(k\\cdot\r\n2^p-r\\cdot\\dfrac{((p-1)\\cdot2^{p-1}+1)\\%p^2}{p}\\right)\\%p\\\\\r\n&amp;=\\left(2k-r\\cdot\\dfrac{((p-1)\\cdot2^{p-1}+1)\\%p^2}{p}\\right)\\%p\\\\\r\n\\end{aligned}\\)\r\n代码\r\nfrom tools import get_primeN = 10 ** 7pr = get_prime(3, N)ans = 0for p in pr:    r = pow(2, pow(2, p, p - 1), p)    k = r * (p - 1) // (p + p) + 1    up = (p - 1) * pow(2, p - 1, p * p) + 1    x = up % p ** 2 // p    ans += (2 * k - r * x) % pprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 722","url":"/project-euler/722/","content":"\r\nProject Euler 722\r\n题目\r\nSlowly converging series\r\nFor a non-negative integer \\(k\\),\r\ndefine\r\n\\[\r\nE_k(q) = \\sum\\limits_{n = 1}^\\infty \\sigma_k(n)q^n\r\n\\]\r\nwhere \\(\\sigma_k(n) = \\sum_{d \\mid n}\r\nd^k\\) is the sum of the \\(k\\)-th\r\npowers of the positive divisors of \\(n\\).\r\nIt can be shown that, for every \\(k\\), the series \\(E_k(q)\\) converges for any \\(0 &lt; q &lt; 1\\).\r\nFor example,\r\n\\(\\begin{aligned}\r\n&amp;E_1(1 - \\frac{1}{2^4}) = \\text{3.872155809243e2}\\\\\r\n&amp;E_3(1 - \\frac{1}{2^8}) = \\text{2.767385314772e10}\\\\\r\n&amp;E_7(1 - \\frac{1}{2^{15}}) = \\text{6.725803486744e39}\r\n\\end{aligned}\\)\r\nAll the above values are given in scientific notation rounded to\r\ntwelve digits after the decimal point.\r\nFind the value of \\(E_{15}(1 -\r\n\\frac{1}{2^{25}})\\).\r\nGive the answer in scientific notation rounded to twelve digits after\r\nthe decimal point.\r\n解决方案\r\n本解决方案参考了Thread中的一些内容。\r\n题目中提到的级数是Lambert级数。它可以进行如下变换：\r\n\\[S(n)=\\sum_{n=1}^\\infty\r\na_n\\cdot\\dfrac{q^n}{1-q^n}=\\sum_{m=1}^\\infty b_m\\cdot q^m\\]\r\n其中，\\(b\\)是\\(a\\)和常函数\\(\\mathbf{1}\\)的狄利克雷卷积，即\\(b=a*\\mathbf{1}\\)，有\\(b_m=\\sum_{d\\mid m} a_m\\).\r\n根据莫比乌斯反演，有\\(a=b*\\mu.\\)代入\\(b_n=\\sigma_k(n)\\)，那么得到\\(a_n=n^k\\)。\r\n因此，原来的级数\\(E_k(q)\\)也可以写成\r\n\\[E_k(q)=\\sum_{n=1}^\\infty n^k\\cdot\\dfrac{\r\nq^n}{1-q^n}\\]\r\n使用Mathematica中的内置欧拉——麦克劳林公式进行逼近即可。\r\n根据这篇论文的式子\\((1.3)\\)，\\(E_k(q)\\)是\\(\\mathscr{L}_q(s,x)=\\sum_{n=1}^{\\infty}\r\n\\dfrac{n^sq^{nx}}{1-q^n}\\)的一个特例，可以写成：\r\n\\[E_k(q)=\\mathscr{L}_q(k,1)\\]\r\n根据这篇论文的定理\\(2.2(1)\\)，代入\\(x=1\\)，有\r\n\\[\\begin{aligned}\r\nE_k(q)&amp;=\\sum_{n=1}^\\infty n^k\\cdot\\dfrac{\r\nq^n}{1-q^n}=\\mathscr{L}_q(k,1)\\\\\r\n&amp;=\\dfrac{\\Gamma(1+k)\\zeta(1+k)}{\\left(\\log\\dfrac{1}{q}\\right)^{1+k}}-\\sum_{i=0}^{\\infty}\r\n\\dfrac{\\zeta(1-k-i)}{i!} B_i(1)(\\log q)^{i-1}\r\n\\end{aligned}\\]\r\n其中，\r\n\r\n\\(\\Gamma(n)\\)是伽马函数。当\\(n\\)为正整数时，\\(\\Gamma(n)=(n-1)!\\)。\r\n\\(\\zeta(s)\\)是黎曼\\(\\zeta\\)函数。\r\n\\(B_n(x)\\)是伯努利多项式。\r\n\r\n这两个项中后面一项的数量级远比前一项小，因此只计算前一项的值：\r\n\\[E_k(q)\\approx\\dfrac{k!\\cdot\r\n\\zeta(1+k)}{\\left(\\log \\dfrac{1}{q}\\right)^{1+k}}\\]\r\n代码\r\nNumberForm[NSum[n^15*q^n/(1-q^n), &#123;n,1,Infinity&#125;, Method -&gt; &quot;EulerMaclaurin&quot;], 13]\r\nfrom tools import facfrom sympy import zeta, logK = 15Q = 1 - 2 ** -25ans = &quot;&#123;:.12e&#125;&quot;.format(float(fac(K) * zeta(K + 1) / (log(1 / Q) ** (K + 1)))).replace(&quot;+&quot;, &quot;&quot;)print(ans)\r\n","categories":["Project Euler"],"tags":["论文"]},{"title":"Project Euler 725","url":"/project-euler/725/","content":"\r\nProject Euler 725\r\n题目\r\nDigit sum numbers\r\nA number where one digit is the sum of the other\r\ndigits is called a digit sum number or DS-number for short. For\r\nexample, \\(352, 3003\\) and \\(32812\\) are DS-numbers.\r\nWe define \\(S(n)\\) to be the sum of\r\nall DS-numbers of \\(n\\) digits or\r\nless.\r\nYou are given \\(S(3) = 63270\\) and\r\n\\(S(7) = 85499991450\\).\r\nFind \\(S(2020)\\). Give your answer\r\nmodulo \\(10^{16}\\).\r\n解决方案\r\n令\\(N=2020.\\)一个数如果是DS数，那么它的数位和是最大数位的\\(2\\)倍。这不难想到使用动态规划来做。\r\n本题的动态规划过程考虑使用“我为人人”的方法，因为本质上都是对当前状态的所有数都添加一个新的数位\\(d\\)，从而到达下一个状态。\r\n令状态\\(c(i,t,m)(1\\le i\\le N,0\\le\r\nt\\le18,0\\le m\\le9)\\)表示当前有多少个\\(i\\)位有前导0的数，其中数位之和为\\(t\\)，并且这\\(i\\)个数位中最大数位为\\(m.\\)\r\n不难知道，对于初值\\(i=1,0\\le j\\le\r\n9\\)，都有\\(c(i,j,j)=1.\\)\r\n考虑对\\(c(i,t,m)\\)中的所有数后面都拼接一个新的数位\\(0\\le d\\le 9\\)，那么可以进行转移：\r\n\\(c(i,t,m)\\rightarrow\r\nc(i+1,t+d,\\max(m,d))\\)\r\n添加一个数位\\(d\\)后，那么数位和就变成了\\(t+d\\)，最大数位也变成了\\(\\max(m,d).\\)\r\n令状态\\(s(i,t,m)(1\\le i\\le N,0\\le\r\nt\\le18,0\\le m\\le9)\\)表示\\(i\\)位有前导0并满足以下条件的所有数之和：数位之和为\\(t\\)，并且这\\(i\\)个数位中最大数位为\\(m.\\)\r\n同样不难知道，对于初值\\(i=1,0\\le j\\le\r\n9\\)，都有\\(s(i,j,j)=j.\\)\r\n考虑对\\(s(i,t,m)\\)中的所有数后面都拼接一个新的数位\\(0\\le d\\le 9\\)，那么可以进行转移：\r\n\\(10s(i,t,m)+d\\cdot c(i,t,m)\\rightarrow\r\ns(i+1,t+d,\\max(m,d))\\)\r\n添加一个数位\\(d\\)后，相当于将\\(s(i,t,m)\\)中的所有数都乘\\(10\\)，并且每一个数都多了一个数位\\(d\\)，一共有\\(c(i,t,m)\\)个。\r\n那么，题目最终所需要求的答案为：\r\n\\[\\sum_{d=0}^9s(N,2d,d)\\]\r\n代码\r\n#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=2020;const int B=9,D=2*B;ll mod=1e16;ll c[N+1][D+1][B+1],s[N+1][D+1][B+1];void add(ll &amp;x,ll y)&#123;    x=(x+y)%mod;&#125;int main()&#123;    for(int j=0;j&lt;=B;j++)&#123;        c[1][j][j]=1;        s[1][j][j]=j;    &#125;    for(int i=1;i&lt;N;i++)        for(int t=0;t&lt;=D;t++)            for(int m=0;m&lt;=B;m++)                for(int d=0;d&lt;=B&amp;&amp;t+d&lt;=D;d++)&#123;                    add(c[i+1][t+d][max(d,m)],c[i][t][m]);                    add(s[i+1][t+d][max(d,m)],s[i][t][m]*10+c[i][t][m]*d);                &#125;    ll ans=0;    for(int j=0;j&lt;=B;j++)        add(ans,s[N][j+j][j]);    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 727","url":"/project-euler/727/","content":"\r\nProject Euler 727\r\n题目\r\nTriangle of Circular Arcs\r\nLet \\(r_a\\), \\(r_b\\) and \\(r_c\\) be the radii of three circles that\r\nare mutually and externally tangent to each other. The three circles\r\nthen form a triangle of circular arcs between their tangency\r\npoints as shown for the three blue circles in the picture below.\r\n\r\nDefine the circumcircle of this triangle to be the red circle, with\r\ncentre \\(D\\), passing through their\r\ntangency points. Further define the incircle of this triangle to be the\r\ngreen circle, with centre \\(E\\), that\r\nis mutually and externally tangent to all the three blue circles. Let\r\n\\(d=\\vert DE \\vert\\) be the distance\r\nbetween the centres of the circumcircle and the incircle.\r\nLet \\(\\mathbb{E}(d)\\) be the\r\nexpected value of \\(d\\) when \\(r_a\\), \\(r_b\\) and \\(r_c\\) are integers chosen uniformly such\r\nthat \\(1\\leq r_a&lt;r_b&lt;r_c \\le\r\n100\\) and \\(\\text{gcd}(r_a,r_b,r_c)=1\\).\r\nFind \\(\\mathbb{E}(d)\\), rounded to\r\neight places after the decimal point.\r\n重心坐标(Barycentric\r\ncoordinates)\r\n重心坐标，表示三角形中的三个顶点的一组“质量”\\((t_1,t_2,t_3)\\)，这三个质量可以唯一确定这个点在平面中的位置。为了规范化，一般令这三个值满足\\(t_1+t_2+t_3=1\\)。\r\n\r\n可以看出，顶点在这个坐标系下的坐标有：\\(A_1(1,0,0),A_2(0,1,0),A_3(0,0,1)\\)\r\n解决方案\r\n在\\(\\triangle ABC\\)中，点\\(D\\)是其内心。\r\n点\\(E\\)是\\(\\odot A,\\odot B,\\odot\r\nC\\)的内索蒂圆圆心，也叫做\\(\\triangle\r\nABC\\)的Equal Detour\r\nPoint.\r\n三角形内部点\\(E\\)的位置满足：\\(|AE|+|BE|-|AB|=|AE|+|CE|-|AC|=|BE|+|CE|-|BC|\\)。\r\n设\\(|BC|=a,|AC|=b,|AB|=c\\)，那么点\\(D\\)重心坐标为\\(D(a,b,c)\\)。\r\n点\\(E\\)的重心坐标为\\(E\\left(a+{\\dfrac {\\Delta }{s-a}},b+{\\dfrac {\\Delta\r\n}{s-b}},c+{\\dfrac {\\Delta }{s-c}}\\right)\\)，其中，\\(\\Delta\\)是三角形的面积，\\(s\\)三角形的半周长。\r\n假设规范化后的两点坐标为\\(P(x_1,y_1,z_1),Q(x_2,y_2,z_2)\\)，令\\(x=x_2-x_1,y=y_2-y_1,z=z_2-z_1\\)，那么\\(\\overrightarrow {PQ}=(x,y,z)\\)。\r\n重心坐标系两点距离公式为：\\(d^2=|\\overrightarrow\r\n{PQ}|=-a^2yz-b^2zx-c^2xy\\)。直接使用此公式即可计算\\(|DE|\\)的值。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;# define mem(a,b) memset(a,b,sizeof(a))using namespace std;typedef long long ll;const int N=100;tuple&lt;double,double,double&gt; normalize(tuple&lt;double,double,double&gt; P)&#123;    double s=get&lt;0&gt;(P)+get&lt;1&gt;(P)+get&lt;2&gt;(P);    return make_tuple(get&lt;0&gt;(P)/s,get&lt;1&gt;(P)/s,get&lt;2&gt;(P)/s);&#125;/*D: 内心E：Equal detour point，三角形内一点P满足|AP|+|BP|-|AB|=|AP|+|CP|-|AC|=|BP|+|CP|-|BC|在重心坐标系下表示。重心坐标系下两点距离计算向量PQ的长度|PQ|：|PQ|^2=-a^2yz-b^2zx-c^2xy*/int main()&#123;    double ans=0,a1,b1,c1,a2,b2,c2;    int cnt=0;    for(int ra=1;ra&lt;=N;ra++)    for(int rb=ra+1;rb&lt;=N;rb++)&#123;        int g=__gcd(ra,rb);        for(int rc=rb+1;rc&lt;=N;rc++)&#123;            if(__gcd(g,rc)!=1) continue;            double a=ra+rb,b=rb+rc,c=rc+ra;            double p=(a+b+c)*0.5;            double S=sqrt(p*(p-a)*(p-b)*(p-c));            auto D=make_tuple(a,b,c);            auto E=make_tuple(a+S/(p-a),b+S/(p-b),c+S/(p-c));            tie(a1,b1,c1)=normalize(D);            tie(a2,b2,c2)=normalize(E);            double x=a2-a1,y=b2-b1,z=c2-c1;            double de2=-a*a*y*z-b*b*z*x-c*c*x*y;            ++cnt;            ans+=sqrt(de2);        &#125;    &#125;    ans/=cnt;    printf(&quot;%.8f\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 724","url":"/project-euler/724/","content":"\r\nProject Euler 724\r\n题目\r\nDrone Delivery\r\nA depot uses \\(n\\) drones to\r\ndisperse packages containing essential supplies along a long straight\r\nroad.Initially all drones are stationary, loaded with a supply\r\npackage.\r\nEvery second, the depot selects a drone at random and sends it this\r\ninstruction:\r\n\r\nIf you are stationary, start moving at one centimetre per second\r\nalong the road.\r\nIf you are moving, increase your speed by one centimetre per second\r\nalong the road without changing direction.\r\n\r\nThe road is wide enough that drones can overtake one another without\r\nrisk of collision.\r\nEventually, there will only be one drone left at the depot waiting to\r\nreceive its first instruction. As soon as that drone has flown one\r\ncentimetre along the road, all drones drop their packages and return to\r\nthe depot.\r\nLet \\(E(n)\\) be the expected\r\ndistance in centimetres from the depot that the supply packages land.\r\nFor example, \\(E(2) = \\frac{7}{2}\\),\r\n\\(E(5) = \\frac{12019}{720}\\), and \\(E(100) \\approx 1427.193470\\).\r\nFind \\(E(10^8)\\). Give your answer\r\nrounded to the nearest integer.\r\n赠券收集问题(Coupon\r\ncollector’s problem)\r\n赠券收集问题:\r\n有买东西的时候会有\\(n\\)种不同的卡片赠送，每次等概率地赠送一张，求集齐这些卡片需要购买的产品的数量的期望值。\r\n令\\(T=\\sum_{i=1}^nt_i\\)，其中\\(t_i\\)表示维持在购买了\\(i-1\\)张卡片后购买第\\(i\\)张的时间。\r\n可以知道，在已经收集到了第\\(i-1\\)向赠券的情况下，能够收集第\\(i\\)张的概率为\\(p_i=\\dfrac{n-i+1}{n}\\)，故\\(t_i\\)服从参数为\\(p_i\\)的几何分布，即\\(t_i\\sim GE(p_i)\\).\r\n故\\(E[t_i]=\\dfrac{1}{p_i},D[t_i]=\\dfrac{1-p_i}{p_i^2},E[T]=\\sum_{i=1}^nE[t_i]\\).\r\n另外，可以发现\\(t_i\\)之间都是独立的，因为抽到的新赠券的时刻和之前已经抽到的没有什么关系，故\\(D[T]=\\sum_{i=1}^nD[t_i]\\).\r\n另外可以计算出\\(E[T^2]=E^2[T]+D[T]\\).\r\n解决方案\r\n根据题意，可以得出一个信息：在第\\(i\\)秒时下达的指令，到了第\\(n\\)秒，这个指令的贡献位\\(n-i+1\\)的距离。\r\n为求出平均距离的期望，先求出距离总和的期望。根据上面的结论，如果第\\(T\\)秒结束，那么这一段时间产生的距离总和为\\(\\dfrac{T(T+1)}{2}\\).\r\n因此距离的总和期望为\\(E\\left[\\dfrac{T(T+1)}{2}\\right]=\\dfrac{1}{2}(E[T]+E[T^2])\\).\r\n可以发现，变量\\(T\\)是赠券收集问题中的变量。\r\n直接代入问题中的计算结果，可得答案为\\(e=\\dfrac{E[T]+E[T^2]}{2n}\\).\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;/*https://en.wikipedia.org/wiki/Coupon_collector%27s_problem#SolutionE[tx]表示持有x张票时持续的时间的期望。tx~E(n/(n-x+1))E[C]=E[t1]+E[t2]+...+E[tn]=n*H(n)D[C]=D[t1]+D[t2]+...+D[tn]=n^2(1+1/4+...+1/n^2)。E[C^2]=E[C]^2+D[C]。从整体上看，每次都会有一个无人机被添加速度，因此第i秒的操作在前n秒就贡献了n-i+1的距离。因此答案为E[C(C+1)/2]。平均下来就是一台无人机可以飞E[C(C+1)/2]/n。*/const int N=1e8;int main()&#123;    double ec=0,dc=0;    for(int i=1;i&lt;=N;i++)&#123;        double p=1.0*(N-i+1)/N;        ec+=1.0/p;        dc+=(1.0-p)/p/p;    &#125;    double ec2=ec*ec+dc;    double ans=0.5*(ec+ec2)/N;    printf(&quot;%.f\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["概率"]},{"title":"Project Euler 73","url":"/project-euler/73/","content":"\r\nProject Euler 73\r\n题目\r\nCounting fractions in a\r\nrange\r\nConsider the fraction, \\(\\dfrac{n}{d}\\), where n and d are positive\r\nintegers. If \\(n&lt;d\\) and \\(\\gcd(n,d)=1\\), it is called a reduced\r\nproper fraction. If we list the set of reduced proper fractions for\r\n\\(d \\leq 8\\) in ascending order of\r\nsize, we get:\r\n\\[\\dfrac{1}{8},\\dfrac{1}{7},\\dfrac{1}{6},\\dfrac{1}{5},\\dfrac{1}{4},\\dfrac{2}{7},\\dfrac{1}{3},\\mathbf{\\dfrac{3}{8},\\dfrac{2}{5},\\dfrac{3}{7}},\\dfrac{1}{2},\\dfrac{4}{7},\\dfrac{3}{5},\\dfrac{5}{8},\\dfrac{2}{3},\\dfrac{5}{7},\\dfrac{3}{4},\\dfrac{4}{5},\\dfrac{5}{6},\\dfrac{6}{7},\\dfrac{7}{8}\\]\r\nIt can be seen that there are \\(3\\)\r\nfractions between \\(\\dfrac{1}{3}\\) and\r\n\\(\\dfrac{1}{2}\\).\r\nHow many fractions lie between \\(\\dfrac{1}{3}\\) and \\(\\dfrac{1}{2}\\) in the sorted set of reduced\r\nproper fractions for \\(d \\leq\r\n12,000\\)?\r\n解决方案\r\nStern-Brocot\r\nTree，一种用来表示各种最简分数的数据结构，它的中序遍历结果就是Farey序列。\r\n主要构造方式则是基于Farey的性质（第71题提过）：对于任意的Farey序列\\(F_n\\)，其中任意连续的三个分数序列\\(\\dfrac{x_1}{y_1},\\dfrac{x_2}{y_2},\\dfrac{x_3}{y_3}\\)，满足\\(\\dfrac{x_2}{y_2}=\\dfrac{x_1+x_3}{y_1+y_3}\\)。\r\n本代码直接模拟遍历Stern-Brocot Tree，每一个节点就是一个分数的区间（也表示新生成的分数本身）。相比于直接暴力判断，优化了一个\\(\\log\\)的级别。\r\n遍历到分母大于\\(N=12000\\)就返回。\r\n本题有线性或以下的做法，奈何本人水平有限，在此不详细提及。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;const int N=12000;const int lu=1,ld=3,ru=1,rd=2;int ans=0;void dfs(int lu,int ld,int ru,int rd)&#123;    int mu=lu+ru,md=ld+rd;    if(md&gt;N) return;    ++ans;    dfs(lu,ld,mu,md);    dfs(mu,md,ru,rd);&#125;int main()&#123;    dfs(lu,ld,ru,rd);    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 731","url":"/project-euler/731/","content":"\r\nProject Euler 731\r\n题目\r\nA Stoneham Number\r\n\\[A=\\sum_{i=1}^{\\infty} \\frac{1}{3^i\r\n10^{3^i}}\\]\r\nDefine \\(A(n)\\) to be the \\(10\\) decimal digits from the \\(n\\text{th}\\) digit onward.\r\nFor example, \\(A(100) = 4938271604\\)\r\nand \\(A(10^8)=2584642393\\).\r\nFind \\(A(10^{16})\\)\r\n解决方案\r\n如果要求分数\\(\\dfrac{a}{b}\\)的第\\(n\\)位后的情况，那么相当于计算分数\\(\\dfrac{a\\cdot10^{n-1}}{b}\\)的小数情况。这相当于直接将小数点右移了\\(n-1\\)位。\r\n并且我们不需要知道分数\\(\\dfrac{a\\cdot10^{n-1}}{b}\\)的整数部分。为了方便计算，就求\\(\\dfrac{a\\cdot10^{n-1}\\%b}{b}\\)的小数部分。\r\n回到题目中，对于一个特定的分数\\(\\dfrac{1}{3^i\\cdot\r\n10^{3^i}}\\)而言，按照上面所述，转化后则变成\\(\\dfrac{10^{n-3^i-1}}{3^i}.\\)那么就相当于求\\(\\dfrac{10^{n-3^i-1}\\%3^i}{3^i}\\)的小数部分。\r\n最终将这些值相加即可。\r\n代码\r\nfrom itertools import countN = 10 ** 16M = 10f = 0for i in count(0, 1):    if N + 20 &lt; 3 ** i + 1:        break    f += pow(10, N - 3 ** i - 1, 3 ** i) / 3 ** i    f -= int(f)ans = str(f)[2:][:10]print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 733","url":"/project-euler/733/","content":"\r\nProject Euler 733\r\n题目\r\nAscending subsequences\r\nLet \\(a_i\\) be the sequence defined\r\nby \\(a_i=153^i \\bmod 10\\ 000\\ 019\\) for\r\n\\(i \\ge 1\\). The first terms of \\(a_i\\) are: \\(153,\r\n23409, 3581577, 7980255, 976697, 9434375, \\dots\\)\r\nConsider the subsequences consisting of \\(4\\) terms in ascending order. For the part\r\nof the sequence shown above, these are:\r\n\\(\\begin{aligned}\r\n&amp; 153, 23409, 3581577, 7980255\\\\\r\n&amp; 153, 23409, 3581577, 9434375\\\\\r\n&amp; 153, 23409, 7980255, 9434375\\\\\r\n&amp; 153, 23409, 976697, 9434375\\\\\r\n&amp; 153, 3581577, 7980255, 9434375\\\\\r\n&amp; 23409, 3581577, 7980255, 9434375\r\n\\end{aligned}\\).\r\nDefine \\(S(n)\\) to be the sum of the\r\nterms for all such subsequences within the first \\(n\\) terms of \\(a_i\\). Thus \\(S(6)=94513710\\). You are given that \\(S(100)=4465488724217\\).\r\nFind \\(S(10^6)\\) modulo \\(1\\ 000\\ 000\\ 007\\).\r\n解决方案\r\n上升子序列问题一般是以动态规划为基本思想的问题。本题依旧尝试使用动态规划解决。\r\n由于本题需要求的是所有严格上升子序列之和（而不是个数），因此需要维护多一个当前子序列的个数，再计算当前下标这个数的贡献次数。\r\n因此，假设这个序列为\\(a\\)，其长度为\\(m\\)。设\\(c(i,j)(1\\leq i\\leq 4,1\\leq j\\leq\r\nm)\\)为长度为\\(i\\)的严格上升子序列中，第\\(i\\)个元素为\\(a[j]\\)的子序列有多少个。\r\n可以列出以下状态转移方程：\r\n\\[\r\nc(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad  i=1 \\\\\r\n  &amp;\\sum_{1\\leq k&lt;j,a[k]&lt;a[j]} c(i-1,k) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n意思是，将之前所有末尾严格小于自身\\(a[j]\\)的子序列，末尾都添加一个\\(a[j]\\)，就变成了以\\(a[j]\\)为末尾的子序列。\r\n再设\\(s(i,j)(1\\leq i\\leq 4,1\\leq j\\leq\r\nm)\\)为长度为\\(i\\)的严格上升子序列中，第\\(j\\)个元素为\\(a[j]\\)的所有子序列之和。\r\n可以列出以下方程：\r\n\\[\r\ns(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;a[j]  &amp; &amp; \\text{if}\\quad  i=1 \\\\\r\n  &amp;c(i,j)\\cdot p[j]+\\sum_{1\\leq k&lt;j,a[k]&lt;a[j]} s(i-1,k) &amp;\r\n&amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n需要注意，这个方程使用了上面的\\(c(i,j)\\)的值。\r\n将之前所有末尾严格小于自身\\(a[j]\\)的子序列，由于末尾都添加一个\\(a[j]\\)，而子序列一共有\\(c(i,j)\\)个，因此总共的和添加了\\(c(i,j)\\times p[j]\\)。\r\n可以发现，直接按照方程进行计算的时间复杂度为\\(O(m^2)\\)，可以用树状数组进行优化。这里的用法则是将离散化后的数组值作为“键”，直接维护树状数组的值。\r\n树状数组，一个可以用\\(O(\\log\r\nm)\\)的时间复杂度单次维护前缀和的一个数据结构。\r\n最终答案为\\(\\sum _{i=1}^m\r\ns(4,i)\\)。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;# define mem(a,b) memset(a,b,sizeof(a))# define lb(x) ((x)&amp;-(x))typedef long long ll;using namespace std;const int N=1000000;int a[N+4],b[N+4],m;ll f1[N+4],f2[N+4],s1[N+4],s2[N+4],mod=1e9+7;void add(ll *s,int p,ll x)&#123;    for(int i=p;i&lt;=m;i+=lb(i))        s[i]=(s[i]+x)%mod;&#125;ll que(ll *s,int p)&#123;    ll ans=0;    for(int i=p;i;i-=lb(i))        ans=(ans+s[i])%mod;    return ans;&#125;int main()&#123;    a[1]=153;    for(int i=2;i&lt;=N;i++)        a[i]=a[i-1]*153%10000019;    for(int i=1;i&lt;=N;i++)        b[i]=f2[i]=a[i],f1[i]=1;    sort(b+1,b+N+1);    m=unique(b+1,b+N+1)-b-1;    for(int i=2;i&lt;=4;i++)&#123;        mem(s1,0);        mem(s2,0);        for(int j=1;j&lt;=m;j++)&#123;            int p=lower_bound(b+1,b+m+1,a[j])-b;            ll q1=que(s1,p-1),q2=que(s2,p-1);            add(s1,p,f1[j]);            add(s2,p,f2[j]);            f1[j]=q1;f2[j]=(q2+q1*a[j])%mod;        &#125;    &#125;    ll ans=0;    for(int i=1;i&lt;=N;i++)        ans=(ans+f2[i])%mod;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划","树状数组"]},{"title":"Project Euler 734","url":"/project-euler/734/","content":"\r\nProject Euler 734\r\n题目\r\nA bit of prime\r\nThe logical-OR of two bits is \\(0\\) if both bits are \\(0\\), otherwise it is \\(1\\).\r\nThe bitwise-OR of two positive integers performs a\r\nlogical OR operation on each pair of corresponding bits in the\r\nbinary expansion of its inputs.\r\nFor example, the bitwise-OR of \\(10\\) and \\(6\\) is \\(14\\) because \\(10\r\n= 1010_2\\), \\(6 = 0110_2\\) and\r\n\\(14 = 1110_2\\).\r\nLet \\(T(n, k)\\) be the number of\r\n\\(k\\)-tuples \\((x_1, x_2,\\cdots,x_k)\\) such that\r\n\r\nevery \\(x_i\\) is a prime \\(\\leq n\\)\r\nthe bitwise-OR of the tuple is a prime \\(\\leq n\\)\r\n\r\nFor example, \\(T(5, 2)=5\\). The five\r\n\\(2\\)-tuples are \\((2, 2), (2, 3), (3, 2), (3, 3)\\) and \\((5, 5)\\).\r\nYou are given \\(T(100, 3) = 3355\\)\r\nand \\(T(1000, 10) \\equiv 2071632\r\n\\pmod{1\\,000\\,000\\,007}\\)\r\nFind \\(T(10^6,999983)\\). Give your\r\nanswer modulo \\(1\\,000\\,000\\,007\\)\r\n解决方案\r\n令\\(N=10^6,Q=999983\\)，一开始不难想到使用动态规划解决本问题。\r\n令\\(P\\)为\\(N\\)以内的质数集合。令\\(f(i,j)(1\\le i\\le Q,j\\ge\r\n0)\\)表示当前长度为\\(i\\)的序列中，有多少种填入质数\\(p\\)的方法，使得整个序列的或运算结果为\\(j\\)。不难写出如下状态转移方程：\r\n\\[\r\nf(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1 &amp; &amp; \\text{if}\\quad  i=1\\land j\\in P \\\\\r\n  &amp;0 &amp; &amp; \\text{else if}\\quad  i=1 \\\\\r\n  &amp;\\sum_{p\\in P}\\sum_{k|p=j} f(i-1,k) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n但是，对于\\(Q\\)这种数据范围而言，直接进行转移效率非常低。\r\n如果我们已经求出了长度为\\(a\\)的序列的各种填法\\(f(a,\\cdot)\\)和长度为\\(b\\)的各种填法\\(f(b,\\cdot)\\)，不难知道我们可以通过卷积组合出\\(f(a+b,\\cdot)\\)。\r\n枚举所有的\\(f(a,i)\\)和\\(f(b,j)\\)，将这两部分值直接合并起来：\r\n\\(g(a,i)\\cdot g(b,j)\\rightarrow\r\ng(a+b,i|j)\\)\r\n直接枚举这两部分的值效率非常低，可以使用快速沃尔什变换加速计算这两部分的合并。\r\n因此，这给了我们一个方案：依次求出\\(f(2^0,\\cdot),f(2^1,\\cdot),f(2^2,\\cdot),\\dots\\)。然后针对\\(Q\\)，选择这些求出的\\(f(2^i,\\cdot)\\)进行合并即可。\r\n最终答案为\r\n\\[\\sum_{p\\in P}f(Q,p)\\]\r\n代码\r\n#include &lt;bits/stdc++.h&gt;# include &quot;tools.h&quot;using namespace std;typedef long long ll;const int N=1000000;const int M=999983;int mod = 1000000007;int pr[N/5+100],v[N+4],m=0;int main()&#123;    for(int i=2;i&lt;=N;i++)&#123;        if(v[i]==0)&#123;            pr[++m]=i;v[i]=m;        &#125;        for(int j=1;j&lt;=m;j++)&#123;            if(j&gt;v[i]||pr[j]&gt;N/i) break;            v[i*pr[j]]=j;        &#125;    &#125;    vector&lt;int&gt;b(N+1);    for(int i=1;i&lt;=m;i++)        b[pr[i]]=1;    fwt.init_mod(mod);    vector&lt;int&gt;a=fwt.powOr(b,M);    int ans=0;    for(int i=1;i&lt;=m;i++)        ans=(ans+a[pr[i]])%mod;    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["动态规划","快速沃尔什变换"]},{"title":"Project Euler 74","url":"/project-euler/74/","content":"\r\nProject Euler 74\r\n题目\r\nDigit factorial chains\r\nThe number \\(145\\) is well known for\r\nthe property that the sum of the factorial of its digits is equal to\r\n\\(145\\): \\[1! + 4! + 5! = 1 + 24 + 120 = 145\\]\r\nPerhaps less well known is \\(169\\), in\r\nthat it produces the longest chain of numbers that link back to \\(169\\); it turns out that there are only\r\nthree such loops that exist: \\[\\begin{aligned}\r\n&amp; 169 \\rightarrow 363601 \\rightarrow 1454 \\rightarrow 169 \\\\\r\n&amp; 871 \\rightarrow 45361 \\rightarrow 871\\\\\r\n&amp; 872 \\rightarrow 45362 \\rightarrow 872\r\n\\end{aligned}\\]\r\nIt is not difficult to prove that EVERY starting number will\r\neventually get stuck in a loop. For example,\r\n\\[\\begin{aligned}\r\n&amp; 69 \\rightarrow 363600 \\rightarrow 1454 \\rightarrow 169 \\rightarrow\r\n363601 (\\rightarrow 1454)\\\\\r\n&amp; 78 \\rightarrow 45360 \\rightarrow 871 \\rightarrow 45361\r\n(\\rightarrow 871)\\\\\r\n&amp; 540 \\rightarrow 145 (\\rightarrow 145)\r\n  \\end{aligned}\\]\r\nStarting with \\(69\\) produces a\r\nchain of five non-repeating terms, but the longest non-repeating chain\r\nwith a starting number below one million is sixty terms.\r\nHow many chains, with a starting number below one million, contain\r\nexactly sixty non-repeating terms?\r\n解决方案\r\n根据题目可以看到，有些数经过多次变换后，就会陷入一个循环，不会回到自身了。\r\n因此，本代码实现时，考虑了这个当前数是在环上还是在链上。如果是在环上，那么需要记录循环节和周期。如果是在链上，取下一轮迭代的结果进行加\\(1\\)即可。\r\n本代码采用了记忆化搜索，每个值的后继都只会被计算一次。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;const int N=1000000,M=60;int f[N&lt;&lt;2],fac[14];int st[N&lt;&lt;2],pos[N&lt;&lt;2];int dfs(int u,int fl)&#123;    st[fl]=u;    if(f[u]) return f[u];    if(pos[u])        return f[u]=fl-pos[u];    pos[u]=fl;    int s=0;    for(int k=u;k;k/=10)        s+=fac[k%10];    int x=dfs(s,fl+1);    pos[u]=0;    if(f[u]) return f[u];    else return f[u]=x+1;&#125;int main()&#123;    fac[0]=1;    for(int i=1;i&lt;10;i++)        fac[i]=fac[i-1]*i;    int ans=0;    for(int i=1;i&lt;=N;i++)        if(dfs(i,1)==M) ++ans;    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 743","url":"/project-euler/743/","content":"\r\nProject Euler 743\r\n题目\r\nWindow into a Matrix\r\nA window into a matrix is a contiguous sub matrix.\r\nConsider a \\(2\\times n\\) matrix\r\nwhere every entry is either \\(0\\) or\r\n\\(1\\).\r\nLet \\(A(k,n)\\) be the total number\r\nof these matrices such that the sum of the entries in every \\(2\\times k\\) window is \\(k\\).\r\nYou are given that \\(A(3,9) = 560\\)\r\nand \\(A(4,20) = 1060870\\).\r\nFind \\(A(10^8,10^{16})\\). Give your\r\nanswer modulo \\(1\\,000\\,000\\,007\\).\r\n解决方案\r\n本方案只适用于\\(k\\mid\r\nn\\)的情况。\r\n不难发现，对于\\(1\\le i\\le\r\nk\\)，第\\(i,i+k,i+2k,i+3k,\\dots\\)列中，\\(1\\)的个数是相同的。\r\n因此可以只考虑前\\(k\\)列的情况。\r\n由于前\\(2\\times\r\nk\\)个格子中，只有\\(k\\)个为\\(1\\)，因此最多只有\\(\\left\\lfloor\\dfrac{k}{2}\\right\\rfloor\\)列是拥有两个\\(1\\)。剩下的\\(1\\)中，都被分配到了一个\\(1\\)的列。\r\n枚举前\\(k\\)个格子中填充两个\\(1\\)的列的个数，那么答案为：\r\n\\[A(k,n)=\\sum_{i=0}^{\\left\\lfloor\\frac{k}{2}\\right\\rfloor}\\frac{k!}{(n-2i)!(i!)^2}2^{\\frac{n}{k}\\cdot(k-2i)}\\]\r\n如果有\\(i\\)列有两个\\(1\\)，那么有\\(i\\)列没有\\(1\\)，有\\(k-2i\\)只有一个\\(1\\)。那么，\\(1\\)的分配方式就有\\(\\dbinom{k}{i}\\cdot\\dbinom{k-i}{i}=\\dfrac{k!}{(n-2i)!(i!)^2}\\)种。整个\\(2\\times n\\)的格子中，有\\(\\dfrac{n}{k}\\cdot(k-2i)\\)列是只有一个\\(1\\)的，每一列有\\(2\\)种填法，由此得到\\(2^{\\frac{n}{k}\\cdot(k-2i)}\\)。最终通过组合得到上式。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const ll N = 1e16;const ll K = 1e8;const ll B = N/K;ll mod=1e9+7;ll qpow(ll n,ll m,ll mod)&#123;    ll ans=1;    for(;m;m&gt;&gt;=1)&#123;        if(m&amp;1) ans=ans*n%mod;        n=n*n%mod;    &#125;    return ans;&#125;ll inv(ll n,ll p)&#123;    return qpow(n,p-2,p);&#125;int fac[K + 4],finv[K + 4];int main()&#123;    fac[0]=fac[1]=1;    finv[0]=1;    for(int i=2; i &lt;= K; i++)        fac[i]=1ll*fac[i-1]*i%mod;    finv[K]=inv(fac[K], mod);    for(int i= K - 1; i &gt; 0; i--)        finv[i]=1ll*finv[i+1]*(i+1)%mod;    ll pw2B=qpow(2,B,mod);    ll invpw4B=inv(pw2B*pw2B%mod,mod);    ll now=qpow(2,N,mod);    ll ans=0;    for(int i=0;i&lt;=K/2;i++)&#123;        ans=(ans+1ll*fac[K]*finv[K-2*i]%mod*finv[i]%mod*finv[i]%mod*now)%mod;        now=now*invpw4B%mod;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 749","url":"/project-euler/749/","content":"\r\nProject Euler 749\r\n题目\r\nNear Power Sums\r\nA positive integer, \\(n\\), is a\r\nnear power sum if there exists a positive integer, \\(k\\), such that the sum of the \\(k\\text{th}\\) powers of the digits in its\r\ndecimal representation is equal to either \\(n+1\\) or \\(n-1\\). For example \\(35\\) is a near power sum number because\r\n\\(3^2+5^2 = 34\\).\r\nDefine \\(S(d)\\) to be the sum of all\r\nnear power sum numbers of \\(d\\) digits\r\nor less.\r\nThen \\(S(2) = 110\\) and \\(S(6) = 2562701\\).\r\nFind \\(S(16)\\).\r\n解决方案\r\n令\\(M=16\\)，那么不难发现，幂\\(k\\)最大只能有\\(\\lfloor M\\log_{2}10\\rfloor\\)。\r\n因此先枚举\\(k\\)值，然后从大到小枚举\\(0\\sim9\\)中每个数位可能的出现次数，并在最后计算数位幂和\\(s\\)。接下来分别判断\\(s+1\\)和\\(s-1\\)能不能由这些数位组成，如果成功，那么\\(s+1\\)与\\(s-1\\)都将是一个候选答案。\r\n还有另外一个优化：当\\(k\\)为奇数时，不可能有解。原因如下：\r\n假设当前的一个数为\\(d=d_{m-1}d_{m-2}\\dots\r\nd_1d_0\\)，那么\\(d=\\sum_{i=0}^{m-1}d_i10^i\\)，其数位幂之和为\\(\\sum_{i=0}^{m-1}d_i^k\\)。那么可以写成\\(\\sum_{i=0}^{m-1}d_i10^i=\\sum_{i=0}^{m-1}d_i^k\\pm1.\\)\r\n那么\\(\\sum_{i=0}^{m-1}(d_i^k-d_i\r\n10^i)\\%3\\neq0\\).\r\n\\(\\sum_{i=0}^{m-1}(d_i^k-d_i\r\n10^i)\\%3=\\sum_{i=0}^{m-1}(d_i^k-d_i)\\%3=\\sum_{i=0}^{m-1}(d_i^{k\\%2}-d_i)\\%3\\).\r\n因此，当\\(k\\)为奇数时，求和式的值永远为\\(0\\)，不满足题目要求。因此搜索时，可以将\\(k\\)为奇数跳过。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=16;const ll M=pow(10,N);const int O=log2(10)*N+3;ll pw[12][O];int c0[10],c1[10];int n;vector&lt;ll&gt;a;bool ok(ll x)&#123;    memcpy(c1,c0,sizeof(c1));    for(int i=0;i&lt;N;i++,x/=10)        if(--c1[x%10]&lt;0) return 0;    return x==0;&#125;void dfs(int k,int n,int p,ll s)&#123;    if(p==0)&#123;        c0[0]=n;        if(ok(s-1)) a.push_back(s-1);        if(ok(s+1)) a.push_back(s+1);        return;    &#125;    for(int i=0;i&lt;=n;i++)&#123;        if(pw[p][k]==-1) break;        c0[p]=i;        dfs(k,n-i,p-1,s+pw[p][k]*i);    &#125;&#125;int main()&#123;    memset(pw,-1,sizeof(pw));    pw[0][0]=1;    for(int j=1;j&lt;N+N;j++)        pw[0][j]=0;    for(int i=0;i&lt;10;i++)&#123;        pw[i][0]=1;        for(int j=1;j&lt;O;j++)&#123;            pw[i][j]=pw[i][j-1]*i;            if(i&gt;0&amp;&amp;pw[i][j]&gt;M/i) break;        &#125;    &#125;    for(int k=2;pw[2][k]!=-1;k+=2)        dfs(k,N,9,0);    ll ans=0;    for(ll x:a)        ans+=x;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 739","url":"/project-euler/739/","content":"\r\nProject Euler 739\r\n题目\r\nSummation of Summations\r\nTake a sequence of length \\(n\\).\r\nDiscard the first term then make a sequence of the partial summations.\r\nContinue to do this over and over until we are left with a single term.\r\nWe define this to be \\(f(n)\\).\r\nConsider the example where we start with a sequence of length \\(8\\):\r\n$\r\n\\[\\begin{array}{rrrrrrrr}\r\n1&amp;1&amp;1&amp;1&amp;1&amp;1&amp;1&amp;1\\\\\r\n&amp;1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7\\\\\r\n&amp; &amp;2&amp;5&amp;9&amp;14&amp;20&amp;27\\\\\r\n&amp; &amp; &amp;5&amp;14&amp;28&amp;48&amp;75\\\\\r\n&amp; &amp; &amp; &amp;14&amp;42&amp;90&amp;165\\\\\r\n&amp; &amp; &amp; &amp; &amp; 42&amp;132&amp;297\\\\\r\n&amp; &amp; &amp; &amp; &amp; &amp; 132&amp;429\\\\\r\n&amp; &amp; &amp; &amp; &amp; &amp; &amp;429\\\\\r\n\\end{array}\\]\r\n$\r\nThen the final number is \\(429\\), so\r\n\\(f(8) = 429\\).\r\nFor this problem we start with the sequence \\(1,3,4,7,11,18,29,47,\\ldots\\)\r\nThis is the Lucas sequence where two terms are added to get the next\r\nterm.\r\nApplying the same process as above we get \\(f(8) = 2663\\).\r\nYou are also given $f(20) = 742296999 $ modulo \\(1\\,000\\,000\\,007\\)\r\nFind \\(f(10^8)\\). Give your answer\r\nmodulo \\(1\\,000\\,000\\,007\\).\r\n解决方案\r\n不难想到，如果第一行是序列\\([a_0,a_1,a_2,\\dots,a_{n-1}]\\)，那么经过变换后，最后得出来的数必定是\\(a\\)中这些数的线性组合\\(\\sum_{k=0}^{n-1}C(n,k)\\cdot\r\na_k\\)，其中\\(C(n,k)\\)是系数。\r\n那么我们就转为求出序列\\([C(n,0),C(n,1),C(n,2),\\dots,C(n,n-1)]\\).\r\n为了暴力求出\\(C(n,k)\\)，那么就将初始化一个长度为\\(n\\)的全\\(0\\)序列，然后令第\\(k\\)个值为\\(1\\)。经过上面的迭代后，将求出的值查询OEIS，结果为A106566.找到FORMULA一栏的信息：\r\nT(n, k) = binomial(2n-k-1, n-k)*k/n for 0 &lt;= k &lt;= n with n &gt; 0; T(0, 0) = 1; T(0, k) = 0 if k &gt; 0.\r\n这直接给出了关于\\(C\\)的公式：\r\n\\[C(n+1,i)=\\dfrac{k\\cdot\r\n\\binom{2n-k-1}{n-k}}{n}\\] 由此直接计算即可。\r\n额外的发现。对于\\(n&gt;1\\)的情况下，\\(C(n,k)\\)的所有值是上面这个三角形的第\\(n-1\\)列的逆序，并且\\(0\\)还被排除了，这里参考A009766。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N = 1e8;const int M = N*2;const int n=N-1;ll mod=1e9+7;ll inv(ll n,ll p)&#123;    ll ans=1,m=p-2;    for(;m;m&gt;&gt;=1)&#123;        if(m&amp;1) ans=ans*n%mod;        n=n*n%mod;    &#125;    return ans;&#125;int *fac,*finv;int l[N+4],invn=inv(n,mod);int C(int n,int m)&#123;    return 1ll*fac[n]*finv[m]%mod*finv[n-m]%mod;&#125;int T(int n,int k)&#123;    if(n==0) return 0;    else return 1ll*C(2*n-k-1,n-k)*k%mod*invn%mod;&#125;int main()&#123;    fac = new int[M+4];    finv = new int[M+4];    fac[0]=fac[1]=1;    finv[0]=1;    for(int i=2;i&lt;=M;i++)        fac[i]=1ll*fac[i-1]*i%mod;    finv[M]=inv(fac[M],mod);    for(int i=M-1;i&gt;0;i--)        finv[i]=1ll*finv[i+1]*(i+1)%mod;    int x=1,y=3;    int ans=0;    for(int i=0;i&lt;=n;i++)&#123;        ans=(ans+1ll*T(n,i)*x)%mod;        int t=(x+y)%mod;        x=y;y=t;    &#125;    delete fac;    delete finv;    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 75","url":"/project-euler/75/","content":"\r\nProject Euler 75\r\n题目\r\nSingular integer right\r\ntriangles\r\nIt turns out that \\(12 \\text{cm}\\)\r\nis the smallest length of wire that can be bent to form an integer sided\r\nright angle triangle in exactly one way, but there are many more\r\nexamples.\r\n\\(\\begin{aligned}\r\n&amp; \\mathbf{12cm}: (3,4,5) \\\\\r\n&amp; \\mathbf{24cm}: (6,8,10) \\\\\r\n&amp; \\mathbf{30cm}: (5,12,13) \\\\\r\n&amp; \\mathbf{36cm}: (9,12,15) \\\\\r\n&amp; \\mathbf{40cm}: (8,15,17) \\\\\r\n&amp; \\mathbf{48cm}: (12,16,20)\r\n\\end{aligned}\\)\r\nIn contrast, some lengths of wire, like \\(20 \\text{cm}\\), cannot be bent to form an\r\ninteger sided right angle triangle, and other lengths allow more than\r\none solution to be found; for example, using \\(120 \\text{cm}\\) it is possible to form\r\nexactly three different integer sided right angle triangles.\r\n\\[\\mathbf{120cm}: (30,40,50), (20,48,52),\r\n(24,45,51)\\]\r\nGiven that \\(L\\) is the length of\r\nthe wire, for how many values of \\(L \\leq\r\n1,500,000\\) can exactly one integer sided right angle triangle be\r\nformed?\r\n本原勾股数组\r\n本原勾股数组，即一个正整数三元组\\((a,b,c)\\)，满足\\(a^2+b^2+c^2\\land\\gcd(a,b,c)=1\\)。\r\n通过枚举一系列的二元组\\((s,t)\\)，其中\\(s&gt;t\\geq\r\n1\\land\\gcd(s,t)=1,s,t\\)为奇数，可以不重不漏地产生本原勾股数组\\(\\left(st,\\dfrac{s^2-t^2}{2},\\dfrac{s^2+t^2}{2}\\right)\\)。\r\n解决方案\r\n使用上面的方法枚举本原勾股数组\\((a,b,c)\\)，再将其对应的非本原勾股数组\\((ka,kb,kc)(k&gt;1)\\)一一枚举出，统计对应周长下的直角三角形个数。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;const int N=1500000;int d[N+4];int main()&#123;    for(int s=1;s+s*s&lt;=N;s+=2)    for(int t=1;t&lt;s;t+=2)&#123;        if(__gcd(s,t)!=1) continue;        int a=s*t,b=(s*s-t*t)/2,c=(s*s+t*t)/2;        int s=a+b+c;        for(int k=s;k&lt;=N;k+=s)            ++d[k];    &#125;    int ans=0;    for(int i=1;i&lt;=N;i++)        ans+=(d[i]==1);    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 745","url":"/project-euler/745/","content":"\r\nProject Euler 745\r\n题目\r\nSum of Squares II\r\nFor a positive integer, \\(n\\),\r\ndefine \\(g(n)\\) to be the maximum\r\nperfect square that divides \\(n\\).\r\nFor example, \\(g(18) = 9\\), \\(g(19) = 1\\).\r\nAlso define\r\n\\[\\displaystyle S(N) = \\sum_{n=1}^N\r\ng(n)\\]\r\nFor example, \\(S(10) = 24\\) and\r\n\\(S(100) = 767\\).\r\nFind \\(S(10^{14})\\). Give your\r\nanswer modulo \\(1\\,000\\,000\\,007\\).\r\n解决方案\r\n可以知道，对于所有无平方因子数\\(n\\)，都有\\(g(nk^2)=k^2\\)，因为\\(g(nk^2)\\)只取决于平方因子\\(k^2\\)。\r\n令\\(N=10^{14}\\)，那么有\r\n\\[S(N)=\\sum_{i=1}^{\\lfloor\\sqrt{N}\\rfloor}\r\ni^2\\cdot\r\nf\\left(\\left\\lfloor\\dfrac{N}{i^2}\\right\\rfloor\\right)\\]\r\n其中\\(f(n)\\)表示\\(n\\)以内的无平方因子数个数。\r\n\\(f(n)\\)可以以\\(O(\\sqrt{n})\\)的时间复杂度计算，在193题已经有提及。那么本题计算\\(S(N)\\)的时间复杂度为\\(O(\\sqrt{N}\\log N)\\)。\r\n\\(O(\\sqrt{N})\\)的做法待补。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll N=1e14;const int M=sqrt(N);int mod=1e9+7;int pr[M/10+100],v[M+4],mu[M+4],m=0;ll cal(ll n)&#123;    ll ans=0;    for(ll i=1;i*i&lt;=n;i++)        ans+=(n/i/i)*mu[i];    return ans;&#125;int main()&#123;    mu[1]=1;    for(int i=2;i&lt;=M;i++)&#123;        if(v[i]==0)&#123;            v[i]=i;mu[i]=-1;pr[++m]=i;        &#125;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;M/i) break;            v[i*pr[j]]=pr[j];            mu[i*pr[j]]=(pr[j]==v[i]?0:-mu[i]);        &#125;    &#125;    ll ans=0;    for(int i=1;i&lt;=M;i++)        ans=(ans+cal(N/i/i)%mod*i%mod*i%mod);    ans%=mod;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["容斥原理"]},{"title":"Project Euler 751","url":"/project-euler/751/","content":"\r\nProject Euler 751\r\n题目\r\nConcatenation Coincidence\r\nA non-decreasing sequence of integers \\(a_n\\) can be generated from any positive\r\nreal value \\(\\theta\\) by the following\r\nprocedure:\r\n\\[\\begin{aligned}\r\n\\begin{split}\r\nb_1 &amp;= \\theta \\\\\r\nb_n &amp;= \\left\\lfloor b_{n-1} \\right\\rfloor \\left(b_{n-1} -\r\n\\left\\lfloor b_{n-1} \\right\\rfloor + 1\\right)~~~\\forall ~ n \\geq 2 \\\\\r\na_n &amp;= \\left\\lfloor b_{n} \\right\\rfloor\r\n\\end{split}\r\n\\end{aligned}\\]\r\nWhere \\(\\left\\lfloor .\r\n\\right\\rfloor\\) is the floor function.\r\nFor example, \\(\\theta=2.956938891377988\\dots\\) generates\r\nthe Fibonacci sequence: \\(2, 3, 5, 8, 13, 21,\r\n34, 55, 89, \\dots\\)\r\nThe concatenation of a sequence of positive integers \\(a_n\\) is a real value denoted \\(\\tau\\) constructed by concatenating the\r\nelements of the sequence after the decimal point, starting at \\(a_1\\): \\(a_1.a_2a_3a_4\\dots\\)\r\nFor example, the Fibonacci sequence constructed from \\(\\theta=2.956938891377988\\dots\\) yields the\r\nconcatenation \\(\\tau=2.3581321345589\\dots\\) Clearly, \\(\\tau \\neq \\theta\\) for this value of \\(\\theta\\).\r\nFind the only value of \\(\\theta\\)\r\nfor which the generated sequence starts at \\(a_1=2\\) and the concatenation of the\r\ngenerated sequence equals the original value: \\(\\tau = \\theta\\). Give your answer rounded\r\nto \\(24\\) places after the decimal\r\npoint.\r\n解决方案\r\n当\\(a_1=2\\)时，也就是说\\(\\theta\\)的整数部分只能是\\(2\\)，也就是说\\(2\\le\\theta&lt;3\\)。在这个范围内，在浮点数上二分算法逼近所求\\(\\theta\\)的值。虽然这个二分算法并非正确，但是它仍然输出了正确的答案。整体上\\(\\tau\\)的增长速度比\\(\\theta\\)快。\r\n代码\r\nN = 2M = 24l, r = N, N + 1for _ in range(100):    theta = 0.5 * (l + r)    b = [theta]    a = [int(theta)]    for i in range(M):        b.append(int(b[-1]) * (b[-1] - int(b[-1]) + 1))        a.append(int(b[-1]))    tau = str(a[0]) + &quot;.&quot;    for i in range(1, M):        tau += str(a[i])    tau = float(tau)    if tau &lt; theta:        r = theta    else:        l = thetaans = &quot;&#123;&#125;.&quot;.format(a[0]) + &quot;&quot;.join(str(x) for x in a[1:])[:M]print(ans)\r\n","categories":["Project Euler"],"tags":["二分"]},{"title":"Project Euler 754","url":"/project-euler/754/","content":"\r\nProject Euler 754\r\n题目\r\nProduct of Gauss Factorials\r\nThe Gauss Factorial of a number \\(n\\) is defined as the product of all\r\npositive numbers \\(\\leq n\\) that are\r\nrelatively prime to \\(n\\). For example\r\n\\(g(10)=1\\times 3\\times 7\\times 9 =\r\n189\\). Also we define \\[\\displaystyle\r\nG(n) = \\prod_{i=1}^{n}g(i)\\] You are given \\(G(10) = 23044331520000\\).\r\nFind \\(G(10^8)\\). Give your answer\r\nmodulo \\(1\\,000\\,000\\,007\\).\r\n解决方案\r\n令函数\\(f(N,n)\\)表示在\\(n&lt; i\\le N\\)这些数中，有多少个\\(i\\)满足\\(\\gcd(n,i)=1.\\)那么\\(G(N)\\)就可以写成：\r\n\\[G(N)=\\prod_{n=2}^N\r\nn^{f(N,n)}\\]\r\n其中，通过容斥原理和莫比乌斯函数\\(\\mu\\)的性质，不难写出\r\n\\[f(N,n)=\\sum_{d\\mid\r\nn}\\mu(d)\\left(\\left\\lfloor\\dfrac{N}{d}\\right\\rfloor-\\left\\lfloor\\dfrac{n}{d}\\right\\rfloor\\right)\\]\r\n注意式子后面第二项是减去\\(n\\)以内的数。\r\n最终直接进行计算即可，时间复杂度为\\(O(N\\log\r\nN)\\)。\r\n代码\r\n本代码运行超过\\(1\\)分钟（约\\(70\\)秒），我暂时没有比较好的思路来优化这道题。\r\n# include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e8;int mod=1000000007;int qpow(int n,int m)&#123;    int ans=1;    for(;m;m&gt;&gt;=1)&#123;        if(m&amp;1) ans=1ll*ans*n%mod;        n=1ll*n*n%mod;    &#125;    return ans;&#125;char mu[N+1];bool vis[N+1];int f[N+1];int pr[N/10+100],m=0;int main()&#123;    mu[1]=1;    for(int i=2;i&lt;=N;i++)&#123;        if(!vis[i])&#123;            pr[++m]=i;            vis[i]=1;mu[i]=-1;        &#125;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;N/i) break;            vis[i*pr[j]]=1;            if(i%pr[j]) mu[i*pr[j]]=-mu[i];            else&#123;                mu[i*pr[j]]=0;break;            &#125;        &#125;    &#125;    for(int d=1;d&lt;N;d++)&#123;        if(mu[d]==0) continue;        for(int n=d;n&lt;=N;n+=d)            f[n]+=mu[d]*(N/d-n/d);    &#125;    int ans=1;    for(int n=2;n&lt;=N;n++)        ans=1ll*ans*qpow(n,f[n])%mod;    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["容斥原理"]},{"title":"Project Euler 755","url":"/project-euler/755/","content":"\r\nProject Euler 755\r\n题目\r\nNot Zeckendorf\r\nConsider the Fibonacci sequence \\(\\{1,2,3,5,8,13,21,\\ldots\\}\\).\r\nWe let \\(f(n)\\) be the number of\r\nways of representing an integer \\(n\\ge\r\n0\\) as the sum of different Fibonacci numbers.\r\nFor example, \\(16 = 3+13 = 1+2+13 = 3+5+8 =\r\n1+2+5+8\\) and hence \\(f(16) =\r\n4\\). By convention \\(f(0) =\r\n1\\).\r\nFurther we define \\[\\displaystyle S(n) =\r\n\\sum_{k=0}^n f(k)\\] You are given \\(S(100) = 415\\) and \\(S(10^4) = 312807\\).\r\nFind \\(\\displaystyle\r\nS(10^{13})\\).\r\n解决方案\r\n令\\(N=10^{13}\\)。假设题目中提到的斐波那契数列为\\(F\\)，下标从\\(1\\)开始。\r\n我们考虑一个斐波那契数集合中所有数的构成方案数。考虑使用动态规划的思想进行。令状态\\(f(k,s)(k\\ge 0)\\)表示由\\(F\\)中的前\\(k\\)个数组成的集合中，能够选择多少个不同的子集，使得自己的元素和小于等于\\(s\\).那么可以写出\\(f\\)的状态转移方程：\r\n\\[\r\nf(k,s)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0  &amp; &amp; \\text{if}\\quad  s&lt;0 \\\\\r\n  &amp;1 &amp; &amp; \\text{else if}\\quad  k=0 \\\\\r\n  &amp;2^k &amp; &amp; \\text{else if}\\quad  \\sum_{i=1}^k F_i\\le N \\\\\r\n  &amp;f(k-1,s)+f(k-1,s-F_k) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n方程的倒数第二行说明，如果整个集合的元素和都不超过\\(s\\)，那么无论怎么选都可以，一共有\\(2^k\\)种选法。方程的最后一行\\(f(k-1,s)\\)说明\\(F_k\\)不被选取，进入到下一轮；\\(f(k-1,s-F_k)\\)则说明\\(F_k\\)被选取了，与此同时\\(1\\sim F_k-1\\)的拼接方法将不再考虑。\r\n那么最终答案为\\(S(N)=f(t,N)\\)，其中\\(t\\)是满足\\(F_t\\ge\r\nN\\)的最小值。\r\n如果添加上记忆化，那么求解\\(f\\)的效率将会很高。\r\n代码\r\nN = 10 ** 13f = [1, 2]while True:    w = f[-1] + f[-2]    if w &gt; N:        break    f.append(w)s = [sum(f[:i + 1]) for i in range(len(f))]mp = &#123;&#125;def dfs(fl: int, now: int):    if now &lt; 0:        return 0    if fl == 0:        return 1    elif s[fl - 1] &lt;= now:        return 1 &lt;&lt; fl    else:        if (fl, now) not in mp.keys():            mp[fl, now] = dfs(fl - 1, now) + dfs(fl - 1, now - f[fl - 1])        return mp[fl, now]print(dfs(len(f), N))\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 757","url":"/project-euler/757/","content":"\r\nProject Euler 757\r\n题目\r\nStealthy Numbers\r\nA positive integer \\(N\\) is\r\nstealthy, if there exist positive integers \\(a\\), \\(b\\), \\(c\\), \\(d\\)\r\nsuch that \\(ab = cd = N\\) and \\(a+b = c+d+1\\).\r\nFor example, \\(36 = 4\\times 9 = 6\\times\r\n6\\) is stealthy.\r\nYou are also given that there are 2851 stealthy numbers not exceeding\r\n\\(10^6\\).\r\nHow many stealthy numbers are there that don’t exceed \\(10^{14}\\)?\r\n解决方案\r\n考虑\r\n\\(\\begin{aligned}\r\na&amp;=xy\\\\\r\nb&amp;=(x+1)(y+1)\\\\\r\nc&amp;=x(y+1)\\\\\r\nd&amp;=y(x+1)\\\\\r\nN&amp;=x(x+1)y(y+1)\r\n\\end{aligned}\\)\r\n那么由\\(x\\)和\\(y\\)通过构造出所有的\\(N\\)，接下来只需要对\\(N\\)进行去重即可。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll N=1e14;int main()&#123;    vector&lt;ll&gt;v;    for(ll x=1;x*(x+1)*x*(x+1)&lt;=N;x++)        for(ll y=x;x*(x+1)*y*(y+1)&lt;=N;y++)            v.push_back(x*(x+1)*y*(y+1));    sort(v.begin(),v.end());    int ans=unique(v.begin(),v.end())-v.begin();    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 759","url":"/project-euler/759/","content":"\r\nProject Euler 759\r\n题目\r\nA squared recurrence\r\nrelation\r\nThe function \\(f\\) is defined for\r\nall positive integers as follows:\r\n\\[\\begin{aligned}\r\nf(1) &amp;=  1\\\\\r\nf(2n) &amp;= 2f(n)\\\\\r\nf(2n+1) &amp;= 2n+1 + 2f(n)+\\dfrac 1n f(n)\r\n\\end{aligned}\\]\r\nIt can be proven that \\(f(n)\\) is\r\ninteger for all values of \\(n\\).\r\nThe function \\(S(n)\\) is defined as\r\n\\(S(n) = \\displaystyle \\sum_{i=1}^n f(i)\r\n^2\\).\r\nFor example, \\(S(10)=1530\\) and\r\n\\(S(10^2)=4798445\\).\r\nFind \\(S(10^{16})\\). Give your\r\nanswer modulo \\(1\\,000\\,000\\,007\\).\r\n解决方案\r\n暴力枚举出\\(f\\)的前几项，在OEIS中查询得到结果为A245788。\r\n令\\(b(n)\\)表示\\(n\\)的二进制表示中有多少个\\(1\\)，那么按照题意，\\(f(n)=n\\cdot b(n)\\)。\r\n将\\(S\\)进行改写：\r\n\\[S(n)=\\sum_{i=1}^{\\lfloor\\log_2\r\n(n+1)\\rfloor} \\left(i^2\\cdot \\sum_{\\substack{m\\le n,b(m)=i}}\r\nm^2\\right)\\]\r\n也就是说，问题转化成枚举\\(i\\)，求\\(n\\)以内的所有数中，满足\\(b(m)=i\\)的所有\\(m^2\\)之和。\r\n将\\(n\\)写成一个长度为\\(l\\)的二进制数字符串\\(d_1d_2\\dots d_l\\)，也就是有\\(l=\\lfloor\\log_2 (n+1)\\rfloor\\)。\r\n令中间状态\\(c_1(i,j)(1\\le\r\ni\\le l,0\\le j\\le 9i)\\)分别表示如下含义：有多少个\\(i\\)位有前导0的数，其二进制有\\(j\\)个\\(1\\)，并等于由字符串\\(d_1d_2\\dots d_i\\)表示的数。令状态\\(s_1(i,j)\\)表示\\(c_1(i,j)\\)中的所有数之和。令状态\\(t_1(i,j)\\)表示\\(c_1(i,j)\\)中的所有数的平方和。\r\n不难发现，如果\\(j=\\sum_{k=1}^i\r\nd_k\\)，那么\\(c_1(i,j)=1\\)，\\(s_1(i,j)\\)的值则为\\(d_1d_2\\dots\r\nd_i\\)这一个字符串的二进制数，并且\\(t_1(i,j)=s_1(i,j)^2\\)；否则\\(c_1(i,j)=s_1(i,j)=t_1(i,j)=0\\)。\r\n状态\\(c_1,s_1,t_1\\)的意义在于规定了答案严格在界限上的情况。而接下来定义的状态\\(c_0,s_0,t_0\\)则是严格不在界限上的情况。\r\n令状态\\(c_0(i,j)\\)表示有多少个\\(i\\)位有前导0的数，其数位和为\\(j\\)，并严格小于由字符串\\(d_1d_2\\dots d_i\\)表示的数。令状态\\(s_0(i,j)\\)表示\\(c_0(i,j)\\)中的所有数之和，\\(t_0(i,j)\\)表示\\(c_0(i,j)\\)。中的所有数的平方和。\r\n那么可以先写出\\(c_0\\)的状态转移方程：\r\n\\[\r\nc_0(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1 &amp; &amp; \\text{if}\\quad  j=0 \\\\\r\n  &amp;0 &amp; &amp; \\text{else if}\\quad  i=1 \\\\\r\n  &amp;c_0(i-1,j-1)+c_0(i-1,j)+[d_i=1]\\cdot c_1(i-1,j) &amp; &amp;\r\n\\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n其中，\\([]\\)表示示性函数，如果\\([]\\)内的表达式为真，那么值为\\(1\\)，否则为\\(0\\)。方程的前两项，如果之前的状态已经是严格小于\\(d_1d_2\\dots\r\nd_{i-1}\\)的数，那么接下来无论在后面拼接一个\\(0\\)还是一个\\(1\\)，都是严格小于的；对于第三项而言，如果之前取的值都是严格等于的，那么接下来如果\\(d_i=1\\)，那么可以拼接一个\\(0\\)，从而达到严格小于的情况。\r\n根据上面的思想，不难写出\\(s_0(i,j)\\)和\\(t_0(i,j)\\)：\r\n\\[\r\ns_0(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0 &amp; &amp; \\text{if}\\quad  i=1\\lor j=0 \\\\\r\n  &amp;2\\cdot s_0(i-1,j-1)+c_0(i-1,j-1)+2\\cdot s_0(i-1,j)+\\\\\r\n  &amp; [d_i=1]\\cdot 2\\cdot s_1(i-1,j) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n\\[\r\nt_0(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0 &amp; &amp; \\text{if}\\quad  i=1\\lor j=0 \\\\\r\n  &amp;4\\cdot t_0(i-1,j-1)+4\\cdot s_0(i-1,j-1)+c_0(i-1,j-1)+4\\cdot\r\nt_0(i-1,j)+\\\\\r\n  &amp;[d_i=1]\\cdot 2\\cdot s_1(i-1,j) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n需要注意的是，对于\\(t_0\\)的状态转移方程最后一行的前三项，系数是\\(4,4,1\\)，来自于平方式\\((2n+1)^2=4n^2+4n+1\\)。\r\n计算完成后，得到最终答案为：\r\n\\[S(n)=\\sum_{i=1}^{l} i^2\\cdot\r\n(t_0(l,i)+t_1(l,i))\\]\r\n代码\r\nN = 10 ** 16mod = 1000000007d = list(map(int, list(bin(N)[2:])))l = len(d)c = [[[0, 0] for _ in range(l + 1)] for _ in range(l)]s = [[[0, 0] for _ in range(l + 1)] for _ in range(l)]t = [[[0, 0] for _ in range(l + 1)] for _ in range(l)]c[0][1][1] = s[0][1][1] = t[0][1][1] = 1c[0][0][0] = 1cnt = 1for i in range(1, l):    cnt += d[i]    c[i][cnt][1] = 1    s[i][cnt][1] = s[i - 1][cnt - d[i]][1] * 2 + d[i]    # 因为d[i]=0,1,d[i] ** 2 = d[i]    t[i][cnt][1] = t[i - 1][cnt - d[i]][1] * 4 + s[i - 1][cnt - d[i]][1] * d[i] * 4 + d[i]    c[i][0][0] = 1    s[i][0][0] = t[i][0][0] = 0    for j in range(1, l + 1):        c[i][j][0] = c[i - 1][j - 1][0] + c[i - 1][j][0]        s[i][j][0] = s[i - 1][j - 1][0] * 2 + c[i - 1][j - 1][0] + s[i - 1][j][0] * 2        t[i][j][0] = t[i - 1][j - 1][0] * 4 + s[i - 1][j - 1][0] * 4 + c[i - 1][j - 1][0] + t[i - 1][j][0] * 4        if d[i] == 1:            c[i][j][0] += c[i - 1][j][1]            s[i][j][0] += s[i - 1][j][1] * 2            t[i][j][0] += t[i - 1][j][1] * 4ans = 0for i in range(l + 1):    ans += sum(t[-1][i]) * i * ians %= modprint(ans)\r\n","categories":["Project Euler"],"tags":["动态规划","OEIS"]},{"title":"Project Euler 76","url":"/project-euler/76/","content":"\r\nProject Euler 76\r\n题目\r\nCounting summations\r\nIt is possible to write five as a sum in exactly six different\r\nways:\r\n\\(\\begin{aligned}\r\n&amp;4+1\\\\\r\n&amp;3+2\\\\\r\n&amp;3+1+1\\\\\r\n&amp;2+2+1\\\\\r\n&amp;2+1+1+1\\\\\r\n&amp;1+1+1+1+1\r\n\\end{aligned}\\)\r\nHow many different ways can one hundred be written as a sum of at\r\nleast two positive integers?\r\n解决方案\r\n本体是一个明显的动态规划。\r\n令\\(n=100\\)，记录状态\\(f(i,j)(1\\leq i\\leq n,0\\leq j\\leq\r\nn)\\)为：当前已经使用了前\\(1\\sim\r\ni\\)中所有数，可以凑得和为\\(j\\)的方案数。可写出如下状态转移方程：\r\n\\[\r\nf(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad j=0 \\lor i=1 \\\\\r\n  &amp;f(i-1,j)  &amp; &amp; \\text{else if}\\quad j&lt;i \\\\\r\n  &amp;f(i-1,j)+f(i,j-i) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n对于最后一题式子，有两种转移方式：\r\n\r\n不使用第\\(i\\)个数，直接把使用前\\(i-1\\)个数的情况记录下来。\r\n使用第\\(i\\)个数，无论之前如何，直接把\\(f(i,j-i)\\)中的所有方案都添加一个\\(i\\)，就变成了现在的方案。\r\n\r\n代码\r\nN = 100f = [0 for _ in range(N + 1)]f[0] = 1for i in range(1, N + 1):    for j in range(i, N + 1):        f[j] += f[j - i]ans = f[N] - 1print(ans)\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 776","url":"/project-euler/776/","content":"\r\nProject Euler 776\r\n题目\r\nDigit Sum Division\r\nFor a positive integer \\(n\\), \\(d(n)\\) is defined to be the sum of the\r\ndigits of \\(n\\). For example, \\(d(12345)=15\\).\r\nLet \\(\\displaystyle F(N)=\\sum_{n=1}^N \\frac\r\nn{d(n)}\\).\r\nYou are given \\(F(10)=19\\), \\(F(123)\\approx 1.187764610390e3\\) and \\(F(12345)\\approx 4.855801996238e6\\).\r\nFind \\(F(1234567890123456789)\\).\r\nWrite your answer in scientific notation rounded to twelve significant\r\ndigits after the decimal point. Use a lowercase e to separate the\r\nmantissa and the exponent.\r\n解决方案\r\n不难发现，可以将\\(F\\)进行改写：\r\n\\[F(N)=\\sum_{n=1}^{N}\\dfrac{n}{d(n)}=\\sum_{k=1}^{+\\infty}\\dfrac{1}{k}\\cdot\\left(\\sum_{n\\le\r\nN,d(n)=k}n\\right)\\]\r\n改写后，相当于将\\(1\\sim\r\nN\\)以内的所有数按照数位和分类好，再将它们求和即可，考虑使用动态规划的方法进行。\r\n令\\(N=1234567890123456789\\)。考虑将\\(N\\)写成一个长度为\\(l\\)的十进制字符串\\(N=d_1d_2d_3\\dots d_l\\)。\r\n由于\\(N\\)很小，因此总数位和不会很大。\r\n令中间状态\\(c_1(i,j)(1\\le\r\ni\\le l,0\\le j\\le 9i)\\)分别表示如下含义：有多少个\\(i\\)位有前导0的数，其数位和为\\(j\\)，并等于由字符串\\(d_1d_2\\dots d_i\\)表示的数。令状态\\(s_1(i,j)\\)表示\\(c_1(i,j)\\)中的所有数之和。\r\n不难发现，如果\\(j=\\sum_{k=1}^i\r\nd_k\\)，那么\\(c_1(i,j)=1\\)，\\(s_1(i,j)\\)的值则为\\(d_1d_2\\dots\r\nd_i\\)这一个字符串的十进制数；否则\\(c_1(i,j)=s_1(i,j)=0\\)。\r\n状态\\(c_1\\)和\\(s_1\\)的意义在于规定了答案严格在界限上的情况。而接下来定义的状态\\(c_0,s_0\\)则是严格不在界限上的情况。\r\n令状态\\(c_0(i,j)\\)表示有多少个\\(i\\)位有前导0的数，其数位和为\\(j\\)，并严格小于由字符串\\(d_1d_2\\dots d_i\\)表示的数。令状态\\(s_0(i,j)\\)表示\\(c_0(i,j)\\)中的所有数之和。\r\n那么可以先写出\\(c_0\\)的状态转移方程：\r\n\\[\r\nc_0(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad  i=1\\land j&lt;d_1 \\\\\r\n  &amp;0 &amp; &amp; \\text{else if}\\quad  i=1 \\\\\r\n  &amp;\\sum_{k=0}^{\\min(9,n)} c_0(i-1,j-k)+\\sum_{k=0}^{\\min(9,n,d_i-1)}\r\nc_1(i-1,j-k) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n方程最后一行的第一个求和项说明，如果之前的状态已经是严格小于\\(d_1d_2\\dots\r\nd_{i-1}\\)的数，那么接下来无论在后面拼接哪一个数位，都是严格小于的；对于第二个求和项而言，如果之前取的值都是严格等于的，那么接下来最多只能取到\\(d_{i-1}\\)。\r\n那么基于\\(c_0\\)的思想，同样不难写出\\(s_0\\)的状态转移方程：\r\n\\[\r\ns_0(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;j  &amp; &amp; \\text{if}\\quad  i=1\\land j&lt;d_1 \\\\\r\n  &amp;0 &amp; &amp; \\text{else if}\\quad  i=1 \\\\\r\n  &amp;\\sum_{k=0}^{\\min(9,n)} (10\\cdot s_0(i-1,j-k)+ k\\cdot\r\nc_0(i-1,j-k))+\\\\\r\n  &amp;\\sum_{k=0}^{\\min(9,n,d_i-1)} (10\\cdot s_1(i-1,j-k)+ k\\cdot\r\nc_1(i-1,j-k)) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n计算完成后，那么就可以计算\\(F(N)\\)：\r\n\\[F(N)=\\sum_{k=1}^{9l}\\dfrac{s_0(l,k)+s_1(l,k)}{k}\\]\r\n代码\r\nN = 1234567890123456789d = list(map(int, list(str(N))))l = len(d)c = [[[0, 0] for _ in range((l + 1) * 9)] for _ in range(l)]s = [[[0, 0] for _ in range((l + 1) * 9)] for _ in range(l)]c[0][d[0]][1] = 1s[0][d[0]][1] = d[0]for j in range(d[0]):    c[0][j][0] = 1    s[0][j][0] = jds = d[0]for i in range(1, l):    ds += d[i]    c[i][ds][1] = 1    s[i][ds][1] = s[i - 1][ds - d[i]][1] * 10 + d[i]    for j in range(l * 9):        for k in range(min(j, 9) + 1):            if k &lt; d[i]:                c[i][j][0] += c[i - 1][j - k][1]                s[i][j][0] += s[i - 1][j - k][1] * 10 + c[i - 1][j - k][1] * k            c[i][j][0] += c[i - 1][j - k][0]            s[i][j][0] += s[i - 1][j - k][0] * 10 + c[i - 1][j - k][0] * kans = 0for i in range(1, l * 9):    ans += sum(s[-1][i]) / ians = &quot;&#123;:.12e&#125;&quot;.format(ans).replace(&quot;e+&quot;, &quot;e&quot;).replace(&quot;e0&quot;, &quot;e&quot;)print(ans)\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 772","url":"/project-euler/772/","content":"\r\nProject Euler 772\r\n题目\r\nBalanceable \\(k\\)-bounded partitions\r\nA \\(k\\)-bounded partition of a\r\npositive integer \\(N\\) is a way of\r\nwriting \\(N\\) as a sum of positive\r\nintegers not exceeding \\(k\\).\r\nA balanceable partition is a partition that can be further divided\r\ninto two parts of equal sums.\r\nFor example, \\(3 + 2 + 2 + 2 + 2 +\r\n1\\) is a balanceable \\(3\\)-bounded partition of \\(12\\) since \\(3 +\r\n2 + 1 = 2 + 2 + 2\\). Conversely, \\(3 +\r\n3 + 3 + 1\\) is a \\(3\\)-bounded\r\npartition of \\(10\\) which is not\r\nbalanceable.\r\nLet \\(f(k)\\) be the smallest\r\npositive integer \\(N\\) all of whose\r\n\\(k\\)-bounded partitions are\r\nbalanceable. For example, \\(f(3) = 12\\)\r\nand \\(f(30) \\equiv 179092994 \\pmod\r\n{1\\,000\\,000\\,007}\\).\r\nFind \\(f(10^8)\\). Give your answer\r\nmodulo \\(1\\,000\\,000\\,007\\).\r\n解决方案\r\n暴力枚举出\\(f\\)的前几项，在OEIS中查询得到结果为A051426。\r\n标题直接给出\\(f(n)=\\text{lcm}(2,4,6,\\dots,n)=2\\cdot\\text{lcm}(1,2,3,\\dots,n)\\)\r\n那么为了计算\\(\\text{lcm}(1,2,3,\\dots,n)\\)，直接枚举出\\(n\\)以内的所有质数\\(p_i\\)，找到对应最大的\\(e_i\\)使得\\(p_i^{e_i}\\le n\\)，直接相乘即可。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=100000000;const ll mod=1000000007;int v[N+4],pr[N/5+1000],m=0;int main()&#123;    for(int i=2;i&lt;=N;i++)&#123;        if(v[i]==0)&#123;            v[i]=i;pr[++m]=i;        &#125;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;N/i) break;            v[i*pr[j]]=pr[j];        &#125;    &#125;    ll ans=2;    for(int i=1;i&lt;=m;i++)&#123;        ll q=1;        for(;q*pr[i]&lt;=N;q*=pr[i]);        ans=ans*q%mod;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["OEIS"]},{"title":"Project Euler 778","url":"/project-euler/778/","content":"\r\nProject Euler 778\r\n题目\r\nFreshman’s Product\r\nIf \\(a,b\\) are two nonnegative\r\nintegers with decimal representations \\(a=(\\dots a_2a_1a_0)\\) and \\(b=(\\dots b_2b_1b_0)\\) respectively, then\r\nthe freshman’s product of \\(a\\) and \\(b\\), denoted \\(a\\boxtimes b\\), is the integer \\(c\\) with decimal representation \\(c=(\\dots c_2c_1c_0)\\) such that \\(c_i\\) is the last digit of \\(a_i\\cdot b_i\\).\r\nFor example, \\(234 \\boxtimes 765 =\r\n480\\).\r\nLet \\(F(R,M)\\) be the sum of \\(x_1 \\boxtimes \\dots \\boxtimes x_R\\) for all\r\nsequences of integers \\((x_1,\\dots,x_R)\\) with \\(0\\leq x_i \\leq M\\).\r\nFor example, \\(F(2, 7) = 204\\), and\r\n\\(F(23, 76) \\equiv 5870548 \\pmod{\r\n1\\,000\\,000\\,009}\\).\r\nFind \\(F(234567,765432)\\), give your\r\nanswer modulo \\(1\\,000\\,000\\,009\\)\r\n解决方案\r\n需要注意的是，本题中的每一个数位都是独立的，因此我们考虑计算出每个数位。\r\n假设\\(M\\)是一个\\(l\\)位数\\(m_{l-1}m_{l-2}\\dots\r\nm_0\\)。我们考虑单独计算\\(0\\sim\r\nn\\)这些数中有多少个有前导\\(0\\)的数的第\\(k\\)个数位为\\(d\\)，记为\\(g(n,k,d)\\)。那么通过三部分考虑，可以写出\\(g\\)为：\r\n\\[\r\ng(n,k,d)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;\\left\\lfloor\\dfrac{n}{10^{k+1}}\\right\\rfloor\\cdot 10^k &amp;\r\n&amp; \\text{if}\\quad  m_k&lt;d \\\\\r\n  &amp;\\left\\lfloor\\dfrac{n}{10^{k+1}}\\right\\rfloor\\cdot 10^k + n \\%\r\n10^k+1 &amp; &amp; \\text{else if}\\quad  m_k=d \\\\\r\n  &amp;\\left\\lfloor\\dfrac{n}{10^{k+1}}\\right\\rfloor\\cdot 10^k+10^k &amp;\r\n&amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n单独考虑序列\\(x\\)中所有数的第\\(k\\)位。令状态\\(f_k(i,j)(0\\le i\\le R,0&lt; j\r\n&lt;10)\\)序列\\(x_1,x_2,\\dots,x_i\\)的第\\(k\\)位有多少种填法，使得\\(x_1\\boxtimes x_2\\boxtimes\\dots\\boxtimes\r\nx_i\\)的第\\(k\\)位为\\(j\\)。那么不难写出状态转移方程为\r\n\\[\r\nf_k(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1 &amp; &amp; \\text{if}\\quad  i=0\\land j=1 \\\\\r\n  &amp;0 &amp; &amp; \\text{else if}\\quad  i=0 \\\\\r\n  &amp;\\sum_{\\substack{0&lt;d,m&lt;10,\\\\\r\n  m\\cdot d\\%10=j}}f_k(i-1,m)\\cdot g(M,k,d)  &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n对于方程最后一行，序列\\(x_i\\)的第\\(k\\)位有\\(g(M,k,d)种填法\\)，从而将\\(f_k(i-1,j)\\)转移到\\(f_k(i,j)\\)。\r\n使用矩阵快速幂，可以将\\(f_k(R,\\cdot)\\)以\\(O(\\log R)\\)的时间复杂度计算出来。\r\n因此最终答案为：\r\n\\[F(R,M)=\\sum_{k=0}^{l-1}10^k\\cdot\\sum_{i=0}^{9}\r\ni\\cdot f_k(R,i)\\]\r\n代码\r\nfrom itertools import countR = 234567M = 765432mod = 1000000009def cal(n, pos, d):    pw = 10 ** pos    ans = n // (pw * 10) * pw    t = n // pw % 10    if t &gt; d:        ans += pw    elif t == d:        ans += n % pw + 1    return ansdef mul(a: list, b: list):    return [[sum(a[i][k] * b[k][j] for k in range(len(b))) % mod for j in range(len(b[0]))] for i in range(len(a))]ans = 0for p in count(0, 1):    if 10 ** p &gt; M:        break    a = [[0 for _ in range(10)]]    a[0][1] = 1    b = [[0 for _ in range(10)] for _ in range(10)]    for d in range(10):        k = cal(M, p, d)        for i in range(10):            b[i][i * d % 10] += k    r = R    while r:        if r &amp; 1:            a = mul(a, b)        b = mul(b, b)        r &gt;&gt;= 1    ans += sum(i * a[0][i] for i in range(10)) * (10 ** p)    ans %= modprint(ans)\r\n","categories":["Project Euler"],"tags":["动态规划","矩阵快速幂"]},{"title":"Project Euler 78","url":"/project-euler/78/","content":"\r\nProject Euler 78\r\n题目\r\nCoin partitions\r\nLet \\(p(n)\\) represent the number of\r\ndifferent ways in which \\(n\\) coins can\r\nbe separated into piles. For example, five coins can separated into\r\npiles in exactly seven different ways, so \\(p(5)=7\\).\r\nOOOOOOOOO OOOO OOOOO O OOO OO OOO O O OO O O O O\r\nFind the least value of \\(n\\) for\r\nwhich \\(p(n)\\) is divisible by one\r\nmillion.\r\n解决方案\r\n本题所使用的的状态转移方程和第76题完全一致。不过，由于本体求的是第一个\\(p(n)\\)能被\\(10^6\\)整除，因此需要更快的方法。\r\n将\\(p(n)\\)的前一些项放进OEIS查询，结果为A000041。\r\n在FORMULA一栏中可以发现以下信息：\r\na(n) - a(n-1) - a(n-2) + a(n-5) + a(n-7) - a(n-12) - a(n-15) + ... = 0, where the sum is over n-k and k is a generalized pentagonal number (A001318) &lt;= n and the sign of the k-th term is (-1)^([(k+1)/2]). See A001318 for a good way to remember this!\r\n其中，数列A001318是一种广义五边形数。\r\n另外，符号位由确定广义五边形数的自变量的绝对值决定。\r\n处理以上各种细节，最终可以得到\\(p(n)\\)的式子为：\r\n\\[\r\np(n)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad n=0  \\\\\r\n  &amp;\\sum_{|m|\\ge1,\\frac{m(3m-1)}{2}\\leq\r\nn}(-1)^{m+1}p\\left(n-\\frac{m(3m-1)}{2}\\right) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n由于广义五边形数增长是二次的，因此计算\\(p(N)\\)的时间复杂度缩减到了\\(O(N\\sqrt{N})\\)。\r\n代码\r\nfrom itertools import countmod = 10 ** 6def gen_pentagonal():    for i in count(1, 1):        yield i * (3 * i - 1) // 2        yield i * (3 * i + 1) // 2p = [1]for n in count(1, 1):    i = 0    val = 0    for m in gen_pentagonal():        if m &gt; n:            break        sgn = i &gt;&gt; 1 &amp; 1        if sgn == 0:            val = (val + p[n - m]) % mod        else:            val = (val - p[n - m] + mod) % mod        i += 1    if val == 0:        ans = n        break    p.append(val)print(ans)\r\n","categories":["Project Euler"],"tags":["OEIS"]},{"title":"Project Euler 788","url":"/project-euler/788/","content":"\r\nProject Euler 788\r\n题目\r\nDominating Numbers\r\nA dominating number is a positive integer that has more than\r\nhalf of its digits equal.\r\nFor example, \\(2022\\) is a\r\ndominating number because three of its four digits are equal to \\(2\\). But \\(2021\\) is not a dominating number.\r\nLet \\(D(N)\\) be how many dominating\r\nnumbers are less than \\(10^N\\).\r\nFor example, \\(D(4) = 603\\) and\r\n\\(D(10) = 21893256\\).\r\nFind \\(D(2022)\\). Give your answer\r\nmodulo \\(1\\,000\\,000\\,007\\).\r\n解决方案\r\n考虑一个\\(n\\)位数中，主体数位出现了\\(m\\)次的数有\\(d(n,m)\\)个。那么就有\r\n\\[D(N)=\\sum_{n=1}^N\\sum_{m=\\left\\lfloor\\frac{n}{2}\\right\\rfloor+1}^nd(n,m)\\]\r\n现在的问题则是计算\\(d(n,m).\\)\r\n当\\(n=m\\)时，不难知道\\(d(n,m)=9\\)。当\\(n\\neq m\\)时，由于最高位不能为\\(0\\)，因此分开考虑两种情况：数的最高位是否为主体数位。\r\n\r\n当最高位是主体数位时，那么主体数位只能有\\(9\\)种；其余主体数位一共有\\(\\dbinom{n-1}{m-1}\\)种分配方法；非主体数位随意可以随意填另外\\(9\\)位数，一共有\\(9^{n-m}\\)种填法。那么总共有\\(9^{n-m+1}\\cdot\r\n\\dbinom{n-1}{m-1}\\)种方法。\r\n当最高位不是主体数位时，那么还继续区分两种情况：\r\n\r\n\r\n主体数位是\\(0\\)，那么最高位可以任意填\\(9\\)种；其余主体数位一共有\\(\\dbinom{n-1}{m}\\)种分配方法；非主体数位还剩下\\(n-m-1\\)位，有\\(9^{n-m-1}\\)种填法。那么总共有\\(9^{n-m-1}\\cdot\r\n\\dbinom{n-1}{m}\\)种方法。\r\n主体数位不是\\(0\\)，那么最高位只能有\\(8\\)种填法，其余相同；主体数位有\\(9\\)种非\\(0\\)的情况。那么总共有\\(8\\cdot9\\cdot 9^{n-m-1}\\cdot\r\n\\dbinom{n-1}{m}\\)种方法。 因此，第\\(2\\)种情况总共有\\(9^{n-m+1}\\cdot\r\n\\dbinom{n-1}{m}\\)种方法。\r\n\r\n把这两种情况合并，那么就可以知道：\r\n\\[d(n,m)=9^{n-m+1}\\cdot\r\n\\dbinom{n}{m}\\]\r\n直接预处理出杨辉三角，对上式求和即可。\r\n代码\r\nfrom tools import get_pascals_triangleN = 2022mod = 10 ** 9 + 7C = get_pascals_triangle(N, mod)pw9 = [1]for _ in range(N + 1):    pw9.append(pw9[-1] * 9 % mod)ans = 0for n in range(1, N + 1):    for m in range(n // 2 + 1, n + 1):        ans = (ans + pw9[n - m + 1] * C[n][m]) % modprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 779","url":"/project-euler/779/","content":"\r\nProject Euler 779\r\n题目\r\nPrime Factor and Exponent\r\nFor a positive integer \\(n&gt;1\\),\r\nlet \\(p(n)\\) be the smallest prime\r\ndividing \\(n\\), and let \\(\\alpha(n)\\) be its \\(\\mathbf{p}\\)-adic order,\r\ni.e. the largest integer such that \\(p(n)^{\\alpha(n)}\\) divides \\(n\\).\r\nFor a positive integer \\(K\\), define\r\nthe function \\(f_K(n)\\) by:\r\n\\[\\displaystyle\r\nf_K(n)=\\frac{\\alpha(n)-1}{(p(n))^K}\\]\r\nAlso define \\(\\overline{f_K}\\)\r\nby:\r\n\\[\\displaystyle \\overline{f_K}=\\lim_{N \\to\r\n\\infty} \\frac{1}{N}\\sum_{n=2}^{N} f_K(n)\\]\r\nIt can be verified that \\(\\overline{f_1}\r\n\\approx 0.282419756159\\).\r\nFind \\(\\displaystyle\r\n\\sum_{K=1}^{\\infty}\\overline{f_K}\\). Give your answer rounded to\r\n\\(12\\) digits after the decimal\r\npoint.\r\n解决方案\r\n将\\(\\overline{f_K}\\)进行改写：\r\n\\[\\overline{f_K}=\\lim_{N \\to \\infty}\r\n\\dfrac{1}{N}\\sum_{q\\in P}\\dfrac{1}{q^K}\\cdot \\sum_{p(n)=q}\r\n(\\alpha(n)-1)\\]\r\n其中\\(P\\)表示一个质数集合。\r\n假设\\(q\\)是一个质数。在所有正整数中，\\(p(n)=q\\)的比例如下（通过容斥原理不难写出）：\r\n\\[\\dfrac{1}{q}\\cdot\\prod_{p_i\\in\r\nP,p_i&lt;q}\\left(1-\\dfrac{1}{p_i}\\right)\\]\r\n那么，在质数\\(q\\)的倍数\\(n\\)中，有\\(\\dfrac{q-1}{q}\\)的数满足\\(\\alpha(n)=1\\)，有\\(\\dfrac{1}{q}\\cdot\r\n\\dfrac{q-1}{q}\\)的数满足\\(\\alpha(n)=2\\)……有\\(\\dfrac{q-1}{q^e}\\)的数满足\\(\\alpha(n)=e\\)。因此，\\(\\overline{f_K}\\)可以进一步改写成：\r\n\\[\\overline{f_K}=\\sum_{q\\in P}\r\n\\dfrac{1}{q^K} \\cdot\\dfrac{1}{q}\\cdot \\prod_{p_i\\in P,p_i&lt;q}\r\n\\left(1-\\dfrac{1}{p_i}\\right)\\cdot \\sum_{e=1}^{\\infty} \\dfrac{q-1}{q^e}\r\n\\cdot (e-1) \\]\r\n由于\\(\\displaystyle{\\sum_{e=1}^{\\infty}\r\n\\dfrac{e-1}{q^e}=\\dfrac{1}{(q-1)^2}}\\)，因此整个式子可以化简成\r\n\\[\\overline{f_K}=\\sum_{q\\in P}\r\n\\dfrac{1}{q^K} \\cdot\\dfrac{1}{q}\\cdot \\prod_{p_i\\in P,p_i&lt;q}\r\n\\left(1-\\dfrac{1}{p_i}\\right)\\cdot \\dfrac{1}{q-1} \\]\r\n那么根据等比数列公式，有\\(\\displaystyle{\\sum_{K=1}^{\\infty}\r\n\\dfrac{1}{q^K}=\\dfrac{1}{q-1}}\\)\r\n那么最终化简后，得到\r\n\\[\\sum_{K=1}^{\\infty}\r\n\\overline{f_K}=\\sum_{q\\in P}\\dfrac{1}{q(q-1)^2} \\cdot \\prod_{p_i\\in\r\nP,p_i&lt;q} \\left(1-\\dfrac{1}{p_i}\\right) \\]\r\n直接枚举质数\\(q\\)，边枚举质数\\(q\\)，边计算第二项求积式，直到级数中某一项的值小于\\(10^{-16}\\)时停止计算。\r\n代码\r\nfrom sympy import nextprimeN = 12eps = 10 ** -(N + 4)mul = 1ans = 0p = 1while True:    p = nextprime(p)    r = mul / p / (p - 1) ** 2    if r &lt; eps:        break    ans += r    mul *= (p - 1) / pans = round(ans, N)print(ans)\r\n","categories":["Project Euler"],"tags":["容斥原理"]},{"title":"Project Euler 79","url":"/project-euler/79/","content":"\r\nProject Euler 79\r\n题目\r\nPasscode derivation\r\nA common security method used for online banking is to ask the user\r\nfor three random characters from a passcode. For example, if the\r\npasscode was \\(531278\\), they may ask\r\nfor the \\(2\\text{nd}\\), \\(3\\text{rd}\\), and \\(5\\text{th}\\) characters; the expected reply\r\nwould be: \\(317\\).\r\nThe text file, keylog.txt,\r\ncontains fifty successful login attempts.\r\nGiven that the three characters are always asked for in order,\r\nanalyse the file so as to determine the shortest possible secret\r\npasscode of unknown length.\r\n解决方案\r\n本题的解题方法依赖于这个假设：所有密码位的出现都是唯一的。\r\n因此，可以通过建立有向无环图（DAG），表示密码位的关系。（如果这不是一个DAG，那么上述事实不成立）\r\n如\\(317\\)，则将连接两条有向边\\(3\\rightarrow 1,1\\rightarrow 7\\)。\r\n对最终建成的DAG进行拓扑排序，得到的即为最终答案（如果拓扑排序失败，说明这不是一个DAG）。\r\n以下是维基百科中，关于拓扑排序算法的伪代码：\r\nL ← Empty list that will contain the sorted elementsS ← Set of all nodes with no incoming edgewhile S is not empty do    remove a node n from S    add n to L    for each node m with an edge e from n to m do        remove edge e from the graph        if m has no other incoming edges then            insert m into Sif graph has edges then    return error   (graph has at least one cycle)else     return L (a topologically sorted order)\r\n本代码中将实现两种方式：手动实现拓扑排序和使用networkx库导出。\r\n代码\r\nfrom queue import Queueg = [[] for i in range(10)]d = [0 for i in range(10)]f = [0 for i in range(10)]ls = open(&#x27;p079_keylog.txt&#x27;, &#x27;r&#x27;).readlines()for s in ls:    x = int(s[:-1])    a = x // 100    b = x // 10 % 10    c = x % 10    g[a].append(b)    g[b].append(c)    d[b] += 1    d[c] += 1    f[a] = f[b] = f[c] = 1q = Queue()for i in range(10):    if d[i] == 0 and f[i]:        q.put(i)a = []while not q.empty():    u = q.get()    a.append(u)    for v in g[u]:        d[v] -= 1        if d[v] == 0:            q.put(v)ans = &quot;&quot;.join(str(x) for x in a)print(ans)\r\nimport networkx as nxg = nx.DiGraph()for s in open(&#x27;p079_keylog.txt&#x27;, &#x27;r&#x27;).readlines():    g.add_edge(s[0], s[1])    g.add_edge(s[1], s[2])ans = &quot;&quot;.join(list(nx.topological_sort(g)))print(ans)\r\n","categories":["Project Euler"],"tags":["图论"]},{"title":"Project Euler 795","url":"/project-euler/795/","content":"\r\nProject Euler 795\r\n题目\r\nAlternating GCD Sum\r\nFor a positive integer \\(n\\), the\r\nfunction \\(g(n)\\) is defined as\r\n\\[\\displaystyle g(n)=\\sum_{i=1}^{n} (-1)^i\r\n\\gcd \\left(n,i^2\\right)\\]\r\nFor example, \\(g(4) = -\\gcd\r\n\\left(4,1^2\\right) + \\gcd \\left(4,2^2\\right) - \\gcd \\left(4,3^2\\right) +\r\n\\gcd \\left(4,4^2\\right) = -1+4-1+4=6\\). You are also given\r\n\\(g(1234)=1233\\).\r\nLet \\(\\displaystyle G(N) = \\sum_{n=1}^N\r\ng(n)\\). You are given \\(G(1234) =\r\n2194708\\).\r\nFind \\(G(12345678)\\).\r\n解决方案\r\n\\[\\begin{aligned}\r\nG(N)&amp;=\\sum_{n=1}^N\\sum_{i=1}^n(-1)^i\\gcd(n,i^2)=\\sum_{i=1}^N(-1)^i\\left(\\sum_{n=i}^N\\gcd(n,i^2)\\right)\r\n\\end{aligned}\\]\r\n其中对于右边那一块，有：\r\n\\[\\sum_{n=1}^N\\gcd(n,i^2)=\\sum_{d\\mid\r\ni^2}\\left\\lfloor\\dfrac{N}{d}\\right\\rfloor\\cdot \\left(\\sum_{e\\mid\r\nd}\\mu\\left(\\dfrac{d}{e}\\right)\\cdot e\\right)=\\sum_{d\\mid\r\ni^2}\\left\\lfloor\\dfrac{N}{d}\\right\\rfloor\\cdot\\varphi(d) \\]\r\n那么将\\(G(n)\\)可以继续重新改写，有：\r\n\\[\\begin{aligned}\r\nG(N)&amp;=\\sum_{i=1}^N(-1)^i\\left(\\sum_{d\\mid i^2}\\varphi(d)\\cdot\r\n\\left(\\left\\lfloor\\dfrac{N}{d}\\right\\rfloor-\\left\\lfloor\\dfrac{i-1}{d}\\right\\rfloor\\right)\\right)\\\\\r\n&amp;=\\sum_{d=1}^N\\varphi(d)\\left(\\sum_{d\\mid i^2}(-1)^i\\cdot\r\n\\left(\\left\\lfloor\\dfrac{N}{d}\\right\\rfloor-\\left\\lfloor\\dfrac{i-1}{d}\\right\\rfloor\\right)\\right)\r\n\\end{aligned}\\]\r\n那么通过筛法实现计算\\(G\\)即可。令\\(n\\)的分解为\\(n=\\prod_{k=1}^mp_i^{e_i}\\)，那么如果一个数\\(m\\)满足\\(n\\mid\r\nm^2\\)，那么就满足\\(n&#39;\\mid\r\nm\\)，其中\\(n&#39;=\\prod_{k=1}^mp_i^{\\left\\lceil\\frac{e_i}{2}\\right\\rceil}\\)。\r\n最终时间复杂度为\\(O(N\\log\r\nN)\\)，略慢。\r\n以后再思考如何使用亚线性算法进行优化。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=12345678;int v[N+4],phi[N+4];int pr[N/10+100],m=0;int cal(int n)&#123;    int m=1;    for(;n!=1;)&#123;        for(int c=0,p=v[n];n%p==0;n/=p,c^=1)            if(!c) m*=p;    &#125;    return m;&#125;int main()&#123;    phi[1]=1;    for(int i=2;i&lt;=N;i++)&#123;        if(v[i]==0)&#123;            pr[++m]=i;phi[i]=i-1;v[i]=i;        &#125;        for(int j=1;j&lt;=m;j++)&#123;            if(pr[j]&gt;v[i]||pr[j]&gt;N/i) break;            v[i*pr[j]]=pr[j];            phi[i*pr[j]]=phi[i]*(pr[j]==v[i]?pr[j]:pr[j]-1);        &#125;    &#125;    ll ans=0;    for(int d=1;d&lt;=N;d++)&#123;        int k=cal(d);        for(int i=k;i&lt;=N;i+=k)&#123;            if(i&amp;1) ans-=phi[d]*(N/d-(i-1)/d);            else ans+=phi[d]*(N/d-(i-1)/d);        &#125;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 793","url":"/project-euler/793/","content":"\r\nProject Euler 793\r\n题目\r\nMedian of Products\r\nLet \\(S_i\\) be an integer sequence\r\nproduced with the following pseudo-random number generator:\r\n\r\n\\(S_0 = 290797\\)\r\n\\(S_{i+1} = S_i ^2 \\bmod\r\n50515093\\)\r\n\r\nLet \\(M(n)\\) be the median of the\r\npairwise products $ S_i S_j $ for \\(0 \\le i\r\n\\lt j \\lt n\\).\r\nYou are given \\(M(3) =\r\n3878983057768\\) and \\(M(103) =\r\n492700616748525\\).\r\nFind \\(M(1\\,000\\,003)\\).\r\n解决方案\r\n满足题意的中位数，本质上是求这\\(\\dfrac{n(n+1)}{2}\\)个数中第\\(m=\\left\\lfloor\\dfrac{n(n+1)+2}{4}\\right\\rfloor\\)小的数。\r\n那么我们考虑二分法。二分答案\\(w\\)，然后统计小于等于\\(w\\)的数有多少个。如果大于等于\\(m\\)，那么说明这个数太大，否则说明这个数太小。第一个使得统计个数大于等于\\(m\\)的数就是答案。\r\n先将将\\(S\\)中的前\\(n\\)项求出来后并排序，假设排序后的数组是\\(a_0,a_1,\\dots,a_{n-1}\\).\r\n考虑当前对答案\\(w\\)进行判定，使用双指针法。左指针\\(l\\)从左到右遍历，右指针则逐渐向左移动，当\\(s[l]\\cdot s[r]\\le w\\)时停下。那么，\\(s[l]\\cdot s[i],l&lt; i\\le\r\nr\\)这一段数都小于等于\\(w\\)，产生了\\(r-l\\)的贡献。最终，两个指针相遇时停止计算。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N=1000003;ll S[N+4],m=(1ll*N*(N-1)/2+1)&gt;&gt;1;bool ok(ll x)&#123;    ll ans=0;    for(int l=0,r=N-1;l&lt;N;l++)&#123;        for(;r&gt;=l&amp;&amp;S[l]*S[r]&gt;x;r--);        if(r&lt;=l) break;        ans+=r-l;    &#125;    return ans&gt;=m;&#125;int main()&#123;    S[0]=290797;    for(int i=1;i&lt;N;i++)        S[i]=S[i-1]*S[i-1]%50515093;    sort(S,S+N);    ll l=1,r=1ll*50515093*50515093;    while(l&lt;r)&#123;        ll mid=(l+r)&gt;&gt;1;        if(ok(mid)) r=mid;        else l=mid+1;    &#125;    printf(&quot;%lld\\n&quot;,l);&#125;\r\n","categories":["Project Euler"],"tags":["双指针","二分"]},{"title":"Project Euler 798","url":"/project-euler/798/","content":"\r\nProject Euler 798\r\n题目\r\nCard Stacking Game\r\nTwo players play a game with a deck of cards which contains \\(s\\) suits with each suit containing \\(n\\) cards numbered from \\(1\\) to \\(n\\).\r\nBefore the game starts, a set of cards (which may be empty) is picked\r\nfrom the deck and placed face-up on the table, with no overlap. These\r\nare called the visible cards.\r\nThe players then make moves in turn.\r\nA move consists of choosing a card \\(X\\) from the rest of the deck and placing\r\nit face-up on top of a visible card \\(Y\\), subject to the following\r\nrestrictions:\r\n\r\n\\(X\\) and \\(Y\\) must be the same suit;\r\nthe value of \\(X\\) must be larger\r\nthan the value of \\(Y\\).\r\n\r\nThe card \\(X\\) then covers the card\r\n\\(Y\\) and replaces \\(Y\\) as a visible card.\r\nThe player unable to make a valid move loses and play stops.\r\nLet \\(C(n, s)\\) be the number of\r\ndifferent initial sets of cards for which the first player will lose\r\ngiven best play for both players.\r\nFor example, \\(C(3, 2) = 26\\) and\r\n\\(C(13, 4) \\equiv 540318329 \\pmod\r\n{1\\,000\\,000\\,007}\\).\r\nFind \\(C(10^7, 10^7)\\). Give your\r\nanswer modulo \\(1\\,000\\,000\\,007\\).\r\n解决方案\r\n本解决方案参考了Thread中的内容，一开始我是直接暴力加FWT做出本题的。\r\n令\\(N=M=10^7\\)。每一个花色可以看成是一个局面。整个游戏由多个不同花色组合而成，因此通过SG定理将最终游戏的SG函数值组合出来。由于\\(M\\)值过大，需要使用快速沃尔什变换解决异或卷积。\r\n那么对于单个花色而言，一共有\\(N\\)张牌，因此初始状态一共有\\(2^N\\)种，每种初始状态对应一个\\(\\{1,2,\\dots,N\\}\\)的子集。\r\n枚举\\(2^N\\)个子集的\\(sg\\)函数值并统计个数。那么当\\(N=1,2,\\dots,14\\)时，结果如下（从第\\(0\\)列起，第\\(j\\)列表示有多少个子集的\\(sg\\)函数值为\\(j\\)）：\r\n   2   3    1   4    3    1   6    6    3    1  10   11    6    4    1  18   20   11   10    4    1  34   37   20   21   10    5    1  66   70   37   41   21   15    5    1 130  135   70   78   41   36   15    6    1 258  264  135  148   78   77   36   21    6    1 514  521  264  283  148  155   77   57   21    7    11026 1034  521  547  283  303  155  134   57   28    7    12050 2059 1034 1068  547  586  303  289  134   85   28    8    14098 4108 2059 2102 1068 1133  586  592  289  219   85   36    8    1\r\n将每一行都逆序，并且最后一个值都减去\\(1\\)，得到\r\n11    21    3    31    3    6    51    4    6   11    91    4   10   11   20   171    5   10   21   20   37   331    5   15   21   41   37   70   651    6   15   36   41   78   70  135  1291    6   21   36   77   78  148  135  264  2571    7   21   57   77  155  148  283  264  521  5131    7   28   57  134  155  303  283  547  521 1034 10251    8   28   85  134  289  303  586  547 1068 1034 2059 20491    8   36   85  219  289  592  586 1133 1068 2102 2059 4108 4097\r\n对于每一列（除了第\\(0\\)列）而言，从下面的数开始，都是两两出现，去掉其中一个，那么可以简化成：\r\n(A) 1   1  2   1  3  3   1  4  6  5   1  5 10 11  9   1  6 15 21 20 17  1  7 21 36 41 37 33  1  8 28 57 77 78 70 65 \r\n可以发现，这个三角的产生方式和杨辉三角相同，只是边界值不一样。\r\n舍去第一行，将其右上方进行补全，得到：\r\n1  2  1  1  1  1  1  11  3  3  2  2  2  2  21  4  6  5  4  4  4  41  5 10 11  9  8  8  81  6 15 21 20 17 16 161  7 21 36 41 37 33 321  8 28 57 77 78 70 65 \r\n最终发现上面这个图形矩阵可以由杨辉三角的偏移叠加得到：\r\n 1  0  0  0  0  0  0  0 1  1  0  0  0  0  0  0 1  2  1  0  0  0  0  0  1  3  3  1  0  0  0  0  1  4  6  4  1  0  0  0  1  5 10 10  5  1  0  0  1  6 15 20 15  6  1  0 0  2  0  0  0  0  0  0 0  2  2  0  0  0  0  0 0  2  4  2  0  0  0  0 0  2  6  6  2  0  0  0 0  2  8 12  8  2  0  0 0  2 10 20 20 10  2  0 0  2 12 30 40 30 12  2 0  0  1  0  0  0  0  0 0  0  1  1  0  0  0  0 0  0  1  2  1  0  0  0 0  0  1  3  3  1  0  0 0  0  1  4  6  4  1  0 0  0  1  5 10 10  5  1 0  0  1  6 15 20 15  6 0  0  0  1  0  0  0  0 0  0  0  1  1  0  0  0 0  0  0  1  2  1  0  0 0  0  0  1  3  3  1  0 0  0  0  1  4  6  4  1 0  0  0  1  5 10 10  5 0  0  0  1  6 15 20 15...\r\n总之，\\(2^N\\)个子集中，\\(sg\\)函数值为\\(k\\)的子集个数为\\(f\\left(N-k-1,\\left\\lceil\\dfrac{k}{2}\\right\\rceil\\right)\\)，其中\\(f(x,y)\\)表示三角形数组(A)一开始在第\\(x\\)列的第一个元素，然后再往下走\\(y\\)步后的元素。（注意当\\(k=0\\)时，需要将值添加回\\(1\\)。）\r\n那么根据刚刚的思想，有\r\n\\[f(x,y)=\\dbinom{x+y-1}{y}+\\sum_{i=0}^x\r\n\\dbinom{x+y-1}{i}\\]\r\n最终，使用等式\\(C_i^j=C_{i-1}^{j-1}+C_i^j\\)这个等式，在求\\(f\\left(N-k-1,\\left\\lceil\\dfrac{k}{2}\\right\\rceil\\right)\\)时，将求和项的相邻两项合并。并且由于运算\\(\\lceil\\rceil\\)运算的存在，合并之后的结果也是连续的，通过这个现象可以\\(O(N)\\)维护出\\(f\\left(N-k-1,\\left\\lceil\\dfrac{k}{2}\\right\\rceil\\right)\\)的所有值。最终使用快速沃尔什变换计算出最终答案。\r\n代码\r\n本代码参考了Thread中的内容并重新实现。\r\n#include &lt;bits/stdc++.h&gt;#include &quot;tools.h&quot;using namespace std;typedef long long ll;const int N = 10000000;const int M = 10000000;ll mod=1000000007;ll fac[N+4],inv[N+4],finv[N+4];ll C(int n,int m)&#123;    return fac[n]*finv[m]%mod*finv[n-m]%mod;&#125;int main()&#123;    fac[0]=fac[1]=inv[1]=finv[0]=finv[1]=1;    for(int i=2;i&lt;=N;i++)&#123;        fac[i]=fac[i-1]*i%mod;        inv[i]=(mod-mod/i)*inv[mod%i]%mod;        finv[i]=finv[i-1]*inv[i]%mod;    &#125;    vector&lt;int&gt;b(N);    b[0]=1;    for(int k=1;k&lt;N;k++)&#123;        b[k]=(b[k-1]+C((N+k)/2-1,k))%mod;        if(k&gt;=2&amp;&amp;(N+k)%2==0) b[k]=(b[k]+b[k-2])%mod;    &#125;    for(int k=0;k&lt;N;k++)        b[k]=(b[k]+C((N+k)/2-1,k-1))%mod;    b[N-1]++;    reverse(b.begin(),b.end());    fwt.init_mod(mod);    int ans=fwt.powXor(b,M)[0];    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["SG定理","快速沃尔什变换"]},{"title":"Project Euler 77","url":"/project-euler/77/","content":"\r\nProject Euler 77\r\n题目\r\nPrime summations\r\nIt is possible to write ten as the sum of primes in exactly five\r\ndifferent ways:\r\n\\(\\begin{aligned}\r\n&amp;7+3\\\\\r\n&amp;5+5\\\\\r\n&amp;5+3+2\\\\\r\n&amp;3+3+2+2\\\\\r\n&amp;2+2+2+2+2\\\\\r\n\\end{aligned}\\)\r\nWhat is the first value which can be written as the sum of primes in\r\nover five thousand different ways?\r\n解决方案\r\n本体是一个明显的动态规划，与76题的做法基本上一样。\r\n从小到大枚举\\(n\\)值，直到方案数超过\\(5000\\)。\r\n令\\(m\\)为\\(n\\)以内的质数个数，数组\\(p\\)为这\\(m\\)个从小到大排序的质数。 记录状态\\(f(i,j)(1\\leq i\\leq m,0\\leq j\\leq\r\nn)\\)为：当前已经使用了前\\(i\\)种质数，可以凑得和为\\(j\\)的方案数。可写出如下状态转移方程：\r\n\\[\r\nf(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad j=0 \\lor(i=1 \\land j\\%p[1]=0)  \\\\\r\n  &amp;0  &amp; &amp; \\text{else if}\\quad i=1 \\\\\r\n  &amp;f(i-1,j)  &amp; &amp; \\text{else if}\\quad j&lt;p[i] \\\\\r\n  &amp;f(i-1,j)+f(i,j-p[i]) &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n对于最后一题式子，有两种转移方式：\r\n\r\n不使用第\\(i\\)个质数，直接把使用前\\(i-1\\)个数的情况记录下来。\r\n使用第\\(i\\)个质数数，无论之前如何，直接把\\(f(i,j-p[i])\\)中的所有方案都添加一个\\(p[i]\\)，就变成了现在的方案。\r\n\r\n代码\r\nfrom itertools import countfrom tools import is_primeN = 5000pr = []for n in count(2, 1):    if is_prime(n):        pr.append(n)    f = [0 for _ in range(n + 1)]    f[0] = 1    for x in pr:        for j in range(x, n + 1):            f[j] += f[j - x]    if f[n] &gt;= N:        ans = n        breakprint(ans)\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 8","url":"/project-euler/8/","content":"\r\nProject Euler 8\r\n题目\r\nLargest product in a series\r\nThe four adjacent digits in the \\(1000\\)-digit number that have the greatest\r\nproduct are \\(9\\times9\\times8\\times9=5832\\).\r\n\r\n73167176531330624919225119674426574742355349194934\r\n96983520312774506326239578318016984801869478851843\r\n85861560789112949495459501737958331952853208805511\r\n12540698747158523863050715693290963295227443043557\r\n66896648950445244523161731856403098711121722383113\r\n62229893423380308135336276614282806444486645238749\r\n30358907296290491560440772390713810515859307960866\r\n70172427121883998797908792274921901699720888093776\r\n65727333001053367881220235421809751254540594752243\r\n52584907711670556013604839586446706324415722155397\r\n53697817977846174064955149290862569321978468622482\r\n83972241375657056057490261407972968652414535100474\r\n82166370484403199890008895243450658541227588666881\r\n16427171479924442928230863465674813919123162824586\r\n17866458359124566529476545682848912883142607690042\r\n24219022671055626321111109370544217506941658960408\r\n07198403850962455444362981230987879927244284909188\r\n84580156166097919133875499200524063689912560717606\r\n05886116467109405077541002256983155200055935729725\r\n71636269561882670428252483600823257530420752963450\r\n\r\nFind the thirteen adjacent digits in the \\(1000\\)-digit number that have the greatest\r\nproduct. What is the value of this product?\r\n解决方案\r\n需要将这个数字字符串矩阵复制出来，然后进行拼接。\r\n最终将枚举每一个长度为\\(13\\)的子串的乘积即可。\r\n代码\r\ns = &quot;73167176531330624919225119674426574742355349194934 96983520312774506326239578318016984801869478851843 &quot; \\    &quot;85861560789112949495459501737958331952853208805511 12540698747158523863050715693290963295227443043557 &quot; \\    &quot;66896648950445244523161731856403098711121722383113 62229893423380308135336276614282806444486645238749 &quot; \\    &quot;30358907296290491560440772390713810515859307960866 70172427121883998797908792274921901699720888093776 &quot; \\    &quot;65727333001053367881220235421809751254540594752243 52584907711670556013604839586446706324415722155397 &quot; \\    &quot;53697817977846174064955149290862569321978468622482 83972241375657056057490261407972968652414535100474 &quot; \\    &quot;82166370484403199890008895243450658541227588666881 16427171479924442928230863465674813919123162824586 &quot; \\    &quot;17866458359124566529476545682848912883142607690042 24219022671055626321111109370544217506941658960408 &quot; \\    &quot;07198403850962455444362981230987879927244284909188 84580156166097919133875499200524063689912560717606 &quot; \\    &quot;05886116467109405077541002256983155200055935729725 71636269561882670428252483600823257530420752963450 &quot;a = [int(x) for x in s.replace(&quot; &quot;, &quot;&quot;)]ans = 0for i in range(len(a) - 13):    m = 1    for j in range(13):        m *= a[i + j]    ans = max(ans, m)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 800","url":"/project-euler/800/","content":"\r\nProject Euler 800\r\n题目\r\nHybrid Integers\r\nAn integer of the form \\(p^q q^p\\)\r\nwith prime numbers \\(p \\neq q\\) is\r\ncalled a hybrid-integer.\r\nFor example, \\(800 = 2^5 5^2\\) is a\r\nhybrid-integer.\r\nWe define \\(C(n)\\) to be the number\r\nof hybrid-integers less than or equal to \\(n\\).\r\nYou are given \\(C(800) = 2\\) and\r\n\\(C(800^{800}) = 10790\\)\r\nFind \\(C(800800^{800800})\\)\r\n解决方案\r\n由于题目中仅涉及求幂，乘法等运算，可以考虑取对数进行计算，避免大整数。\r\n令\\(N=P^E\\)，其中\\(P=E=800800\\)。不失一般性，假设\\(p&lt;\r\nq\\)，那么写成对数形式，就是求所有有多少质数对\\((p,q)\\)满足：\r\n\\[p\\log_2q +q\\log_2p\\le\r\nE\\log_2P\\]\r\n\\(q\\)的最大值最多能取到多少？当\\(p=2\\)时，忽略掉第一项\\(p\\log_2q\\)，可以估计\\(q\\)取得的上限为\\(E\\log_2P\\)。\r\n令\\(M=\\lceil\r\nE\\log_2P\\rceil\\)，使用线性筛枚举出\\(M\\)以内的质数，存放在数组\\(pr\\)中。\r\n使用双指针法，在第一层循环从左到右枚举左指针\\(l\\)，第二层循环右往左枚举右指针\\(r\\)，并枚举到第一个\\(pr[l] \\cdot \\log_2pr[r]+pr[r]\\cdot \\log_2pr[l]&lt;\r\nE\\log_2P\\)的最大\\(r\\)。那么，\\(r\\)左边和\\(l\\)右边的所有质数都可以和\\(pr[l]\\)组成答案，统计这一段数的数量。\r\n为避免log2函数使用次数过多降低效率，实现时先将所有对数值先计算出来。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int P = 800800,E = 800800;const int M = log2(P) * E + 4;const double max_lg = log2(P) * E;int pr[M/4+104],m=0;int v[M];double lg[M/4+104];int main() &#123;    for (int i = 2; i &lt;= M; i++) &#123;        if (v[i] == 0) &#123;            v[i] = i;            pr[++m] = i;            lg[m] = log2(pr[m]);        &#125;        for (int j = 1; j &lt;= m; j++) &#123;            if (pr[j] &gt; v[i] || pr[j] &gt; M / i) break;            v[i * pr[j]] = pr[j];        &#125;    &#125;    ll ans = 0;    for (int l = 1, r = m; l &lt;= m; l++) &#123;        for (; r &gt; l &amp;&amp; lg[l] * pr[r] + lg[r] * pr[l] &gt; max_lg; r--);        if (l == r) break;        ans += r - l;    &#125;    printf(&quot;%lld\\n&quot;, ans);&#125;\r\n","categories":["Project Euler"],"tags":["双指针"]},{"title":"Project Euler 80","url":"/project-euler/80/","content":"\r\nProject Euler 80\r\n题目\r\nSquare root digital\r\nexpansion\r\nIt is well known that if the square root of a natural number is not\r\nan integer, then it is irrational. The decimal expansion of such square\r\nroots is infinite without any repeating pattern at all.\r\nThe square root of two is \\(1.41421356237309504880\\ldots\\), and the\r\ndigital sum of the first one hundred decimal digits is \\(475\\).\r\nFor the first one hundred natural numbers, find the total of the\r\ndigital sums of the first one hundred decimal digits for all the\r\nirrational square roots.\r\n解决方案\r\n在计算机中，小数只能通过浮点数近似，不能精确表示，但是整数可以精确表示。因此本题尝试将小数部分“转移”到整数部分再计算整数上的平方根。\r\n容易发现这么一个规律：\\(10\\sqrt\r\nn=\\sqrt{100n}\\)。这说明，只要我们需要求前\\(n\\)位小数时，我们只需要将这个整数乘\\(10^{2n}\\)，再计算整数下的平方根后，原本的\\(n\\)位小数就转移到了整数部分的最后\\(n\\)位，并且能精确表示。\r\n以下面一个为例：为\\(\\sqrt{2}\\)求小数点后面\\(2\\)位，发现：\r\n\\(\\sqrt{2}=1.41421356237309504880\\ldots,\\lfloor\\sqrt{2}\\rfloor=1\\)\r\n\\(\\sqrt{20000}=141.421356237309504880\\ldots,\\lfloor\\sqrt{20000}\\rfloor=\\lfloor100\\sqrt{2}\\rfloor=141\\)\r\n本题使用了gmpy2库中的is_square函数，用于判断当前的数是否为平方数。这个函数将封装在自定义的tools工具包中。\r\n另一种方法则是使用牛顿迭代法，此处不再赘述。\r\n代码\r\nfrom gmpy2 import is_squarefrom tools import int_sqrtans = 0N = 100M = 100for i in range(2, N + 1):    if is_square(i):        continue    w = int_sqrt(i * 10 ** (2 * M))    ans += sum(int(x) for x in str(w)[:M])print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 804","url":"/project-euler/804/","content":"\r\nProject Euler 804\r\n题目\r\nBalanced Numbers\r\nLet \\(g(n)\\) denote the number of\r\nways a positive integer \\(n\\) can be\r\nrepresented in the form:\r\n\\[x^2+xy+41y^2\\]\r\nwhere \\(x\\) and \\(y\\) are integers. For example, \\(g(53)=4\\) due to \\((x,y) \\in\r\n\\{(-4,1),(-3,-1),(3,1),(4,-1)\\}\\).\r\nDefine \\(\\displaystyle\r\nT(N)=\\sum_{n=1}^{N}g(n)\\). You are given \\(T(10^3)=474\\) and \\(T(10^6)=492128\\).\r\nFind \\(T(10^{16})\\).\r\n解决方案\r\n令\\(N=10^{16},F(x,y)=x^2+xy+41y^2\\)。不难证明，\\(F(x,y)&gt;0\\)恒成立，除了\\((x,y)=(0,0)\\)。\r\n因此，\\(T(N)\\)的值就相当于有多少个非原点\\((x,y)\\)，满足\\(F(x,y)\\le N\\)。\r\n固定\\(y\\)，那么可以将\\(F(x,y)\\)写成顶点式：\r\n\\[F(x,y)=\\left(x+\\dfrac{y}{2}\\right)^2+\\dfrac{163y^2}{4}\\]\r\n枚举\\(y\\)，然后解不等式\\(F(x,y)\\le N\\)即可，直到方程无解。\r\n为了排除\\((0,0)\\)的情况，单独考虑\\(y=0\\)时的情况，这时有\\(2\\lfloor\\sqrt{N}\\rfloor\\)个解。\r\n否则，区间\\(\\left[\\dfrac{-y-\\sqrt{4N-163y^2}}{2},\\dfrac{-y+\\sqrt{4N-163y^2}}{2}\\right]\\)种的所有整数解都是答案，直接统计即可。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;# include &quot;tools.h&quot;typedef long long ll;using namespace std;const ll N=1e16;int main()&#123;    ll ans=int_sqrt(N)*2;    for(ll i=1,d2;(d2=N*4-i*i*163)&gt;=0;i++)&#123;        ll r=-i+int_sqrt(d2);        if(r&lt;0&amp;&amp;r&amp;1) --r;        r&gt;&gt;=1;        ll l=-i-r;        ans+=(r-l+1)*2;    &#125;    printf(&quot;%lld\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 81","url":"/project-euler/81/","content":"\r\nProject Euler 81\r\n题目\r\nPath sum: two ways\r\nIn the \\(5\\) by \\(5\\) matrix below, the minimal path sum from\r\nthe top left to the bottom right, by only moving to the right\r\nand down, is indicated in bold red and is equal to \\(2427\\).\r\n\\[\r\n\\begin{pmatrix}\r\n\\color{red}{131} &amp; 673 &amp; 234 &amp; 103 &amp; 18\\\\\r\n\\color{red}{201} &amp; \\color{red}{96} &amp; \\color{red}{342} &amp; 965\r\n&amp; 150\\\\\r\n630 &amp; 803 &amp; \\color{red}{746} &amp; \\color{red}{422} &amp; 111\\\\\r\n537 &amp; 699 &amp; 497 &amp; \\color{red}{121} &amp; 956\\\\\r\n805 &amp; 732 &amp; 524 &amp; \\color{red}{37} &amp; \\color{red}{331}\r\n\\end{pmatrix}\r\n\\]\r\nFind the minimal path sum, in matrix.txt (right click and\r\n“Save Link/Target As…”), a 31K text file containing a \\(80\\) by \\(80\\) matrix, from the top left to the\r\nbottom right by only moving right and down.\r\n解决方案\r\n本题是一道很明显的动态规划。\r\n令矩阵大小为\\(n\\)，记录状态\\(f(i,j)(1\\leq i,j\\leq\r\nn)\\)为：当前走到第\\(i\\)行第\\(j\\)列的数的情况下，可以得到的路径最小和是多少，用\\(a[i][j]\\)表示第\\(i\\)行第\\(j\\)列的数。\r\n那么，可以得到状态转移方程：\r\n\\[\r\nf(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;a[i][j]  &amp; &amp; \\text{if}\\quad i=j=1 \\\\\r\n  &amp;f(i-1,j)+a[i][j] &amp; &amp; \\text{else if}\\quad j=1 \\\\\r\n  &amp;f(i,j-1)+a[i][j] &amp; &amp; \\text{else if}\\quad i=1 \\\\\r\n  &amp;\\min(f(i,j-1),f(i-1,j)) + a[i][j] &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\]\r\n对于有两种到达方式的状态，无非就是从上的格子走过来，和从左边的格子走过来两种。取这两种方式的较优决策即可。\r\n最后答案为\\(f(n,n)\\).\r\n代码\r\na = []ls = open(&#x27;p081_matrix.txt&#x27;, &#x27;r&#x27;).readlines()n = len(ls)f = [[10 ** 10 for x in range(n)] for y in range(n)]for i in range(n):    b = [int(x) for x in ls[i][:-1].split(&#x27;,&#x27;)]    a.append(b)f = [[10 ** 10 for x in range(n + 1)] for y in range(n + 1)]f[0][1] = 0for i in range(1, n + 1):    for j in range(1, n + 1):        f[i][j] = min(f[i - 1][j], f[i][j - 1]) + a[i-1][j-1]print(f[n][n])\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 808","url":"/project-euler/808/","content":"\r\nProject Euler 808\r\n题目\r\nReversible prime squares\r\nBoth \\(169\\) and \\(961\\) are the square of a prime. \\(169\\) is the reverse of \\(961\\).\r\nWe call a number a reversible prime square if:\r\n\r\nIt is not a palindrome, and\r\nIt is the square of a prime, and\r\nIts reverse is also the square of a prime.\r\n\r\n\\(169\\) and \\(961\\) are not palindromes, so both are\r\nreversible prime squares.\r\nFind the sum of the first \\(50\\)\r\nreversible prime squares.\r\n解决方案\r\n直接使用sympy库中的nextprime暴力枚举质数进行判断，需要注意不要漏掉第一个条件。\r\n代码\r\nfrom tools import is_prime, is_square, int_sqrtfrom sympy import nextprimeN = 50def ok(n):    s = str(n)    t = s[::-1]    if s == t:        return False    m = int(t)    return is_prime(int_sqrt(m)) if is_square(m) else Falsep = 1ans = 0while True:    p = nextprime(p)    if ok(p * p):        ans += p * p        N -= 1        if N == 0:            breakprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 82","url":"/project-euler/82/","content":"\r\nProject Euler 82\r\n题目\r\nPath sum: three ways\r\nNOTE: This problem is a more challenging version of Problem 81.\r\nThe minimal path sum in the \\(5\\) by\r\n\\(5\\) matrix below, by starting in any\r\ncell in the left column and finishing in any cell in the right column,\r\nand only moving up, down, and right, is indicated in red and bold; the\r\nsum is equal to \\(994\\).\r\n\\[\r\n\\begin{pmatrix}\r\n131 &amp; 673 &amp; \\color{red}{234} &amp; \\color{red}{103} &amp;\r\n\\color{red}{18}\\\\\r\n\\color{red}{201} &amp; \\color{red}{96} &amp; \\color{red}{342} &amp; 965\r\n&amp; 150\\\\\r\n630 &amp; 803 &amp; 746 &amp; 422 &amp; 111\\\\\r\n537 &amp; 699 &amp; 497 &amp; 121 &amp; 956\\\\\r\n805 &amp; 732 &amp; 524 &amp; 37 &amp; 331\r\n\\end{pmatrix}\r\n\\]\r\nFind the minimal path sum from the left column to the right column in\r\nmatrix.txt (right click and\r\n“Save Link/Target As…”), a 31K text file containing an \\(80\\) by \\(80\\) matrix.\r\n解决方案\r\n本题用动态规划的思想解决。\r\n本题的动态规划可以以一列列作为阶段。因为每一条从最左列到最右列的路径，可以视为是一个个列的连续子数组拼接而成。而且由于只能向右走，路径上所处的每一列，它们的行下标都是首尾相接的。\r\n如果往上走，或者是往下走，就能够走出一个列上的子数组。\r\n以上图为例，红色路径上的列子数组从左到右分别为\\([201],[96],[342,234],[103],[18]\\)，而且它们的行下标是首尾相接的。\r\n因此，记录状态\\(f(i,j)(1\\leq i,j\\leq\r\nn)\\)为：表示当前走到第j列的情况下，在这一列以第i行为终点时路径的最小和，用\\(a[i][j]\\)表示第\\(i\\)行第\\(j\\)列的数。\r\n那么，可以得到状态转移方程：\r\n\\[\r\nf(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;a[i][j]  &amp; &amp; \\text{if}\\quad j=1 \\\\\r\n  &amp;\\min_{k=1}^n \\left\\{f(k,j-1)+\\sum_{p=\\min(i,k)}^{\\max(i,k)}\r\na[p][j]\\right\\} &amp; &amp; \\text{else}\r\n\\end{aligned}\\right.\r\n\\] 在该状态转移方程中，\\(k\\)是指当前左边那一列的“终点”，也就是本列的起点。\r\n为求列的子数组和，可以用一个前缀和预处理。\r\n最终答案为\\(\\min_{i=1}^n\\{f(i,n)\\}\\)。\r\n代码\r\na = []ls = open(&#x27;p081_matrix.txt&#x27;, &#x27;r&#x27;).readlines()n = len(ls)f = [[10 ** 10 for x in range(n)] for y in range(n)]for i in range(n):    b = [int(x) for x in ls[i][:-1].split(&#x27;,&#x27;)]    a.append(b)f = [[0 for j in range(n + 1)] for i in range(n + 1)]s = [[0 for j in range(n + 1)] for i in range(n + 1)]for i in range(1, n + 1):    for j in range(1, n + 1):        s[i][j] = s[i - 1][j] + a[i - 1][j - 1]for i in range(1, n + 1):    f[i][1] = a[i - 1][0]for j in range(2, n + 1):    for i in range(1, n + 1):        f[i][j] = min(f[k][j - 1] + s[max(i, k)][j] - s[min(i, k) - 1][j] for k in range(1, n + 1))ans = min(f[i][n] for i in range(1, n + 1))print(ans)\r\n","categories":["Project Euler"],"tags":["动态规划"]},{"title":"Project Euler 816","url":"/project-euler/816/","content":"\r\nProject Euler 816\r\n题目\r\nShortest distance among\r\npoints\r\nWe create an array of points \\(P_n\\)\r\nin a two dimensional plane using the following random number\r\ngenerator:\r\n\\(\\begin{aligned}\r\n&amp;s_0=290797\\\\\r\n&amp;s_{n+1}={s_n}^2 \\bmod 50515093\\\\\r\n&amp;P_n=(s_{2n},s_{2n+1})\r\n\\end{aligned}\\)\r\nLet \\(d(k)\\) be the shortest\r\ndistance of any two (distinct) points among \\(P_0, \\cdots, P_{k - 1}\\).\r\nE.g. \\(d(14)=546446.466846479\\)\r\nFind \\(d(2000000)\\). Give your\r\nanswer rounded to \\(9\\) places after\r\nthe decimal point.\r\n解决方案\r\n经典问题平面最近点对问题。使用分治的思想可以解决。大概的做法是：\r\n\r\n分解：将一个平面上的所有点按照\\(x\\)坐标划分成相等的两部分；\r\n结局：然后递归求解这两部分的解；\r\n合并：假设这条划分接线为\\(x=x_0\\)，那么将\\(x=x_0\\)附近的点再按照\\(y\\)轴进行排序，再枚举这些点之间距离的最小值即可。最终得到了这一部分点的最小点对长度。\r\n\r\n代码\r\n本做法的时间复杂度为\\(O(n\\log^2\r\nn)\\)，虽然不是最优，但足以应对。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=2e6;ll INF = 1e17;struct P &#123;    ll x, y;    bool operator&lt;(const P &amp;p) const &#123;        return x &lt; p.x || x == p.x &amp;&amp; y &lt; p.y;    &#125;    ll dis2(P &amp;p) const &#123;        ll dx = x - p.x, dy = y - p.y;        return dx * dx + dy * dy;    &#125;&#125;;P p[N + 4];int tp[N + 4];ll dfs(int l, int r) &#123;    if (l == r)        return INF;    if (l + 1 == r)        return p[l].dis2(p[r]);    int mid = (l + r) &gt;&gt; 1;    ll ans = min(dfs(l, mid - 1), dfs(mid, r));    int k = 0;    for (int i = l; i &lt;= r; i++) &#123;        ll dx = p[mid].x - p[i].x;        if (dx * dx &lt;= ans)            tp[++k] = i;    &#125;    sort(tp + 1, tp + k + 1, [](const int &amp;a,const int &amp;b)&#123;return p[a].y &lt; p[b].y; &#125;);    for (int i = 1; i &lt;= k; i++) &#123;        for (int j = i + 1; j &lt;= k; j++) &#123;            ll dy = p[tp[j]].y - p[tp[i]].y;            if(dy * dy &gt; ans) break;            ans = min(ans, p[tp[i]].dis2(p[tp[j]]));        &#125;    &#125;    return ans;&#125;void input(int N) &#123;    ll s = 290797;    for (int i = 1; i &lt;= N; i++) &#123;        p[i].x = s; s = s * s % 50515093;        p[i].y = s; s = s * s % 50515093;    &#125;&#125;int main()&#123;    input(N);    sort(p + 1, p + N + 1);    double ans = sqrt(dfs(1, N));    printf(&quot;%.9f\\n&quot;, ans);&#125;\r\n","categories":["Project Euler"],"tags":["分治"]},{"title":"Project Euler 813","url":"/project-euler/813/","content":"\r\nProject Euler 813\r\n题目\r\nXOR-Powers\r\nWe use \\(x\\oplus y\\) to be the\r\nbitwise XOR of \\(x\\) and \\(y\\).\r\nDefine the XOR-product of \\(x\\) and \\(y\\), denoted by \\(x \\otimes y\\), similar to a long\r\nmultiplication in base \\(2\\), except\r\nthat the intermediate results are XORed instead of the usual integer\r\naddition.\r\nFor example, \\(11 \\otimes 11 = 69\\),\r\nor in base \\(2\\), \\(1011_2 \\otimes 1011_2 = 1000101_2\\): \\[\r\n\\begin{align*}\r\n\\phantom{\\otimes 1111} 1011_2 \\\\\r\n\\otimes \\phantom{1111} 1011_2 \\\\\r\n\\hline\r\n\\phantom{\\otimes 1111} 1011_2 \\\\\r\n\\phantom{\\otimes 111} 1011_2 \\phantom{9} \\\\\r\n\\oplus \\phantom{1} 1011_2  \\phantom{999} \\\\\r\n\\hline\r\n\\phantom{\\otimes 11} 1000101_2 \\\\\r\n\\end{align*}\r\n\\] Further we define \\(P(n) =\r\n11^{\\otimes n} = \\overbrace{11\\otimes 11\\otimes \\ldots \\otimes\r\n11}^n\\). For example \\(P(2)=69\\).\r\nFind \\(P(8^{12}\\cdot 12^8)\\). Give\r\nyour answer modulo \\(10^9+7\\).\r\n解决方案\r\n令\\(n=8^{12}\\cdot 12^8\\)。\r\n将二进制数\\(1011_{2}\\)视为一个用异或加法表示的多项式\\(1\\oplus x\\oplus\r\nx^3\\)。那么可以发现，将这个多项式对自身相乘，可以得到新的多项式为\\(1\\oplus x^2\\oplus\r\nx^6\\)。将得出来的多项式\\(1\\oplus\r\nx^2\\oplus x^6\\)再与自身相乘，那么可以得到\\(1\\oplus x^4\\oplus x^{12}\\)。\r\n由此可以发现规律：\\(11^{\\otimes\r\n2^n}\\)可以表示成多项式\\(1\\oplus\r\nx^{2^n}\\oplus x^{3\\cdot 2^n}\\)。也就是说，\\(P(2^n)=1+2^{2^n}+2^{3\\cdot2^n}\\)。\r\n不难发现，函数\\(P\\)满足此性质\\(P(a+b)=P(a)\\otimes\r\nP(b)\\)。因此我们可以把\\(n\\)拆分成一个个二进制幂之和，然后再利用这个运算性质，直接将\\(P(a)\\)和\\(P(b)\\)对应的多项式直接卷积进行计算即可。\r\n代码\r\nN = 12 ** 8 * 8 ** 12mod = 10 ** 9 + 7def conv(sa, sb):    from collections import defaultdict    mp = defaultdict(int)    for x in sa:        for y in sb:            mp[x + y] ^= 1    return &#123;k for k, v in mp.items() if v&#125;su = &#123;0&#125;st = &#123;0, 1, 3&#125;while N:    if N &amp; 1:        su = conv(su, st)    st = conv(st, st)    N &gt;&gt;= 1ans = sum(pow(2, x, mod) for x in su) % modprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 820","url":"/project-euler/820/","content":"\r\nProject Euler 820\r\n题目\r\n\\(N^{\\text{th}}\\) digit of Reciprocals\r\nLet \\(d_n(x)\\) be the \\(n^{\\text{th}}\\) decimal digit of the\r\nfractional part of \\(x\\), or \\(0\\) if the fractional part has fewer than\r\n\\(n\\) digits. For example:\r\n\r\n\\(d_7 \\mathopen{}\\left( 1\r\n\\right)\\mathclose{} = d_7 \\mathopen{}\\left( \\frac 1 2\r\n\\right)\\mathclose{} = d_7 \\mathopen{}\\left( \\frac 1 4\r\n\\right)\\mathclose{} = d_7 \\mathopen{}\\left( \\frac 1 5\r\n\\right)\\mathclose{} = 0\\)\r\n\\(d_7 \\mathopen{}\\left( \\frac 1 3\r\n\\right)\\mathclose{} = 3\\) since \\(\\frac\r\n1 3 = 0.333333{\\color{red}{\\mathbf{3}}}333\\dots\\)\r\n\\(d_7 \\mathopen{}\\left( \\frac 1 6\r\n\\right)\\mathclose{} = 6\\) since \\(\\frac\r\n1 6 = 0.166666{\\color{red}{\\mathbf{6}}}666\\dots\\)\r\n\\(d_7 \\mathopen{}\\left( \\frac 1 7\r\n\\right)\\mathclose{} = 1\\) since \\(\\frac\r\n1 7 = 0.142857{\\color{red}{\\mathbf{1}}}428\\dots\\)\r\n\r\nLet \\(\\displaystyle  S(n) = \\sum_{k=1}^n\r\nd_n \\mathopen{}\\left( \\frac 1 k \\right)\\mathclose{}\\). You are\r\ngiven:\r\n\r\n\\(S(7) = 0 + 0 + 3 + 0 + 0 + 6 + 1 =\r\n10\\)\r\n\\(S(100) = 418\\)\r\n\r\nFind \\(S(10^7)\\).\r\n解决方案\r\n与第731题一样。如果要求分数\\(\\dfrac{a}{b}\\)的第\\(n\\)位后的情况，那么相当于计算分数\\(\\dfrac{a\\cdot10^{n-1}}{b}\\)的小数情况。这相当于直接将小数点右移了\\(n-1\\)位。\r\n并且我们不需要知道分数\\(\\dfrac{a\\cdot10^{n-1}}{b}\\)的整数部分。为了方便计算，就求\\(\\dfrac{a\\cdot10^{n-1}\\%b}{b}\\)的小数部分。\r\n令\\(x=\\dfrac{a\\cdot10^{n-1}\\%b}{b}\\)，那么\\(\\left\\lfloor\\dfrac{10x}{b}\\right\\rfloor\\)就是\\(\\dfrac{a}{b}\\)第\\(n\\)位的小数值。\r\n代码\r\n#include &lt;bits/stdc++.h&gt;# include &quot;tools.h&quot;using namespace std;typedef long long ll;const int N=10000000;int main()&#123;    int ans=0;    for(int k=1;k&lt;=N;k++)&#123;        int x=qpow(10,N-1,k);        ans+=x*10/k;    &#125;    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 835","url":"/project-euler/835/","content":"\r\nProject Euler 835\r\n题目\r\nSupernatural Triangles\r\nA Pythagorean triangle is called\r\nsupernatural if two of its three sides are consecutive\r\nintegers.\r\nLet \\(S(N)\\) be the sum of the\r\nperimeters of all distinct supernatural triangles with perimeters less\r\nthan or equal to \\(N\\).\r\nFor example, \\(S(100) = 258\\) and\r\n\\(S(10000) = 172004\\).\r\nFind \\(S(10^{10^{10}})\\). Give your\r\nanswer modulo \\(1234567891\\).\r\n解决方案\r\n令\\(n=10^{m}\\)，其中\\(m=10^{10}\\)。\r\n不失一般性，假设直角三角形的三条边分别为\\(x,y,z\\)，其中满足\\(x&lt; y&lt; z\\)。那么\\(z\\)是这个直角三角形的斜边。\r\n那么题目中的超自然直角三角形分两种情况进行讨论。其中一种是\\(z-y=1\\)，另一种是\\(y-x=1\\)。\r\n\\(z-y=1\\)\r\n令\\(z=y+1\\)，那么\\(x^2=(y+1)^2-y^2=2y+1\\)。也就是说，当\\(2y+1\\)是一个平方数时，对应的\\(x,y,y+1\\)就构成了一个直角三角形。\r\n令\\(x=2k-1\\)，其中\\(k=\\{2,3,4,\\dots\\}\\)，那么有\\(y=2k^2-2k,z=2k^2-2k+1\\)，那么整个三角形的周长为\\(x+y+z=2k(2k-1)\\)。\r\n令\\(f(k)=2k(2k+1)\\)，现在的任务是求最大的正整数\\(k_0\\)使得\\(f(k_0)\\le n\\)。可以解得\\(k_0\\)为：\r\n\\[k_0=\\left\\lfloor\\dfrac{1}{4} (\\sqrt{4\r\nn+1}+1)\\right\\rfloor\\]\r\n由于\\(n\\)是一个偶完全平方数，那么有\\(k_0=\\left\\lfloor\\dfrac{1}{4} (\\sqrt{4\r\nn+1}+1)\\right\\rfloor=\\left\\lfloor\\dfrac{1}{4} (\\sqrt{4\r\nn}+1)\\right\\rfloor=\\dfrac{\\sqrt{n}}{2}\\)。\r\n也就是说，\\(k_0=5\\cdot\r\n10^{m/2-1}\\)。\r\n最终这个子问题的答案为\\(\\displaystyle{S_0(k_0)=\\sum_{k=2}^{k_0}f(k)=\\dfrac{k_0(k_0+1)(4k_0-1)}{3}-2}\\)。\r\n\\(y-x=1\\)\r\n令\\(y=x+1\\)，那么有\\(x^2+(x+1)^2=z^2\\)。化简后配方，得到\\((2x+1)^2-2z^2=-1\\)，令\\(u=2x+1\\)，那么得到负佩尔方程\\((1)\\)：\r\n\\[u^2-2z^2=-1\\qquad(1)\\]\r\n并且，方程\\((1)\\)的每一对正整数解\\((u,z)\\)恰好对应着一个超自然直角三角形的周长\\(c=u+z\\)。\r\n假设负佩尔方程\\(u^2-Dz^2=-1\\)存在最小特解为\\((u_1,z_1)\\)。那么，负佩尔方程的通解\\((u_k,z_k)\\)由以下式子导出。\r\n\\[u_{k+1}+z_{k+1}\\sqrt{D}=(u_{k}+z_{k}\\sqrt{D})(u_1+z_1\\sqrt{D})^2\\]\r\n容易发现，\\(u^2-2z^2=-1\\)的最小特解为\\((1,1)\\)，代入上面的导出递推公式，得到通解递推公式：\r\n\\[\\left \\{\\begin{aligned}\r\n  &amp; u_{k+1}=3u_k+4z_k\\\\\r\n  &amp; z_{k+1}=2u_k+3z_k\r\n\\end{aligned}\\right.\r\n\\]\r\n令\\(c_k=u_k+z_k\\)，那么消去上面的递推式\\(u_k\\)，得到\r\n\\[\\left \\{\\begin{aligned}\r\n  &amp; z_{k+1}=z_k+2s_k&amp;\\qquad(2)\\\\\r\n  &amp; s_{k+1}=2z_k+5s_k&amp;\\qquad(3)\r\n\\end{aligned}\\right.\r\n\\]\r\n将\\((2)\\)代入\\((3)\\)，消去\\(z_k\\)，得到\r\n\\[s_{k+1}=2z_{k+1}+s_k\\qquad(4)\\]\r\n由\\((3)\\)得：\r\n\\[s_{k+2}=2z_{k+1}+5s_{k+1}\\qquad(5)\\]\r\n由\\((4),(5)\\)消去\\(z\\)，最终得到\r\n\\[s_{k+2}=6s_{k+1}-s_k\\qquad(6)\\]\r\n为了方便后续计算，我们通过构造函数\\(g(k)\\)来代替\\(s_k\\)，其中\\(g(k)=s_k\\)，并且\\(g\\)在\\(0\\)下有意义。\r\n构造\\(g(0)=0,g(1)=2,g(k)=6g(k-1)-g(k-2)\\)，现在的任务是求最大的正整数\\(k_1\\)使得\\(g(k_1)\\le n\\)。不难计算得出，\\(g(k)\\)的通项公式为\r\n\\[g(k)=\\dfrac{(3+2 \\sqrt{2})^k-(3-2\r\n\\sqrt{2})^k}{2 \\sqrt{2}}\\]\r\n假设\\(n\\)不在序列\\(g\\)中，当\\(k\\)非常大时，\\(\\dfrac{(3-2 \\sqrt{2})^k}{2\r\n\\sqrt{2}}\\)这一项的值非常小，因此不考虑。此时相当于求最大的\\(k_1\\)使得\\(\\dfrac{(3+2 \\sqrt{2})^{k_1}}{2 \\sqrt{2}}\\le\r\n10^{m}\\)。两边对\\(10\\)取对数，最终得到\r\n\\[k_1=\\left\\lfloor\r\n\\dfrac{m+\\log_{10}(2\\sqrt{2})}{\\log_{10}(3+2\\sqrt{2})}\\right\\rfloor\\]\r\n最终这个子问题的答案为\\(\\displaystyle{S_1(k_1)-g(1)=\\sum_{k=1}^{k_1}g(k)-g(1)}\\)。\r\n接下来的问题是求解\\(S_1(k_1)\\)。将\\(S_1(k)\\)和\\(g(k)\\)写成矩阵形式为：\r\n\\[\\begin{bmatrix}\r\n0 &amp; 1 &amp; 0\\\\\r\n-1 &amp; 6 &amp; 0\\\\\r\n0 &amp; 1 &amp; 1\\\\\r\n\\end{bmatrix}\r\n\\begin{bmatrix}\r\ng(k-1)\\\\\r\ng(k)\\\\\r\nS_1(k-1)\r\n\\end{bmatrix}\r\n=\r\n\\begin{bmatrix}\r\ng(k)\\\\\r\ng(k+1)\\\\\r\nS_1(k)\r\n\\end{bmatrix}\\]\r\n那么通过矩阵快速幂，可以以\\(O(\\log\r\nk_1)\\)的时间复杂度内求解\\(S_1(k_1)\\)。\r\n综合两个子问题，最终答案为\\(S_0(k_0)+(S_1(k_1)-2)-\\mathbf{12}\\)，注意最后一项\\(12\\)是指\\((3,4,5)\\)的直角三角形，它在两个子问题中重复计算了一次。\r\nOEIS相关信息：\\(S_0\\)在A002939中找到，\\(S_1\\)在A001542中找到。\r\n代码\r\nfrom math import log10, sqrtfrom tools import mod_inverseN = 10 ** 10mod = 1234567891def mul(a: list, b: list):    return [[sum(a[i][k] * b[k][j] for k in range(len(b))) % mod for j in range(len(b[0]))] for i in range(len(a))]n = 5 * pow(10, N // 2 - 1, mod) % moda1 = n * (n + 1) * (4 * n - 1) * mod_inverse(3, mod) % modsqt2 = sqrt(2)m = int((N + log10(2 * sqt2)) / log10(3 + 2 * sqt2))a = [[0, 2, 0]]b = [[0, -1, 0], [1, 6, 1], [0, 0, 1]]while m:    if m &amp; 1:        a = mul(a, b)    b = mul(b, b)    m &gt;&gt;= 1a2 = a[0][2]ans = (a1 + a2 - 16) % modprint(ans)\r\n","categories":["Project Euler"],"tags":["佩尔方程","矩阵快速幂"]},{"title":"Project Euler 831","url":"/project-euler/831/","content":"\r\nProject Euler 831\r\n题目\r\nTriple Product\r\nLet \\(g(m)\\) be the integer defined\r\nby the following double sum of products of binomial coefficients:\r\n\\[\\sum_{j=0}^m\\sum_{i = 0}^j\r\n(-1)^{j-i}\\binom mj \\binom ji \\binom{j+5+6i}{j+5} \\]\r\nYou are given that \\(g(10) =\r\n127278262644918\\).\r\nIts first (most significant) five digits are \\(12727\\).\r\nFind the first ten digits of \\(g(142857)\\) when written in base \\(7\\).\r\n解决方案\r\n假设\\(c[p(x),k]\\)是多项式\\(p(x)\\)中，项\\(x^k\\)的系数。可以知道，这个定义有如下性质：\r\n\\[c[p(x),k]=c\\left[\\dfrac{p(x)}{x^k},0\\right]\\]\r\n令\\(\\displaystyle{h(j)=\\sum_{i=0}^j(-1)^{j-i}\\binom ji\r\n\\binom{j+5+6i}{j+5}}\\)，那么有\\(\\displaystyle{g(m)=\\sum_{j=0}^m} \\dbinom{m}{j}\r\nh(j)\\)。\r\n首先考虑\\(h(j)\\)。可以知道\r\n\\(\\begin{aligned}\r\nh(j)&amp;=\\sum_{i=0}^j(-1)^{j-i}\\binom ji \\cdot c[(x+1)^{j+5+6i},j+5]\\\\\r\n&amp;=c\\left[(x+1)^{j+5}\\cdot\\sum_{i=0}^j\\left(\\dbinom\r\n{j}{i}\\cdot(-1)^{j-i}\\cdot(x+1)^{6i}\\right),j+5\\right]\\\\\r\n&amp;=c\\left[(x+1)^{j+5}\\cdot((x+1)^6-1)^j,j+5\\right]\\\\\r\n&amp;=c[(x+1)^5\\cdot((x+1)^7-x-1)^j,j+5]\\\\\r\n&amp;=c\\left[(x+1)^5\\cdot\\left(\\dfrac{(x+1)^7-x-1}{x}\\right)^j,5\\right]\r\n\\end{aligned}\\)\r\n那么最终得出\\(g(m)\\)有\r\n\\(\\begin{aligned}\r\ng(m)&amp;=\\sum_{j=0}^m \\dbinom{m}{j} h(j)\\\\\r\n&amp;=c\\left[(x+1)^5\\cdot\\sum_{j=0}^m\r\n\\dbinom{m}{j}\\left(\\dfrac{(x+1)^7-x-1}{x}\\right)^j,5\\right]\\\\\r\n&amp;=c\\left[(x+1)^5\\cdot\\left(\\dfrac{(x+1)^7-x-1}{x}+1\\right)^m,5\\right]\\\\\r\n&amp;=c\\left[(x+1)^5\\cdot\\left(\\dfrac{(x+1)^7-1}{x}\\right)^m,5\\right]\\\\\r\n&amp;=c[(x+1)^5\\cdot(7x^5+21x^4+35x^3+25x^2+21x+7)^m,5]&amp;\\qquad(1)\\\\\r\n&amp;=7^m\\cdot c[(x+1)^5\\cdot(x^5+3x^4+5x^3+5x^2+3x+1)^m,5]\\\\\r\n\\end{aligned}\\)\r\n其中，步骤\\((1)\\)说明我们只关心次数为\\(0\\sim\r\n5\\)中产生的结果，且并不关心更高次项的结果。\r\n接下来的问题只剩下求\\(c[(x+1)^5\\cdot(x^5+3x^4+5x^3+5x^2+3x+1)^m,5]\\)的值。方法也很简单，令\\(f(x)=(x+1)^5\\cdot(x^5+3x^4+5x^3+5x^2+3x+1)^m\\)，那么相当于计算\\(\\dfrac{f^{(5)}(0)}{5!}\\)的值。\r\n使用Mathematica的如下命令计算\\(\\dfrac{f^{(5)}(0)}{5!}\\)的值，并得到结果为\\(\\dfrac{40+474m+1835m^2+2085m^3+765m^4+81m^5}{40}\\)。\r\nf[x_] = (x+1)^5 (x^5+3x^4+5x^3+5x^2+3x+1)^mf&#x27;&#x27;&#x27;&#x27;&#x27;[x] / 120\r\n也就是说，最终得到\r\n\\[g(m)=7^m\\cdot\r\n\\dfrac{40+474m+1835m^2+2085m^3+765m^4+81m^5}{40}\\]\r\n在\\(7\\)进制下，对一个数乘以\\(7^m\\)相当于仅仅是将这个数左移了\\(m\\)位，对最高位数值没有影响，因此计算中不会考虑\\(7^m\\)这个项。\r\n代码\r\nN = 142857def base10ToBase7(x):    s = &quot;&quot;    while x:        s, x = str(x % 7) + s, x // 7    return sdef g(n):    return (81 * n ** 5 + 765 * n ** 4 + 2085 * n ** 3 + 1835 * n ** 2 + 474 * n + 40) // 40  # * 7 ** nx = base10ToBase7(g(N))ans = str(x)[:10]print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 832","url":"/project-euler/832/","content":"\r\nProject Euler 832\r\n题目\r\nMex Sequence\r\nIn this problem \\(\\oplus\\) is used\r\nto represent the bitwise exclusive or of two\r\nnumbers.\r\nStarting with blank paper repeatedly do the following:\r\n\r\nWrite down the smallest positive integer \\(a\\) which is currently not on the\r\npaper;\r\nFind the smallest positive integer \\(b\\) such that neither \\(b\\) nor \\((a\r\n\\oplus b)\\) is currently on the paper. Then write down both \\(b\\) and \\((a\r\n\\oplus b)\\).\r\n\r\nAfter the first round \\(\\{1,2,3\\}\\)\r\nwill be written on the paper. In the second round \\(a=4\\) and because \\((4 \\oplus 5),(4 \\oplus 6)\\) and \\((4 \\oplus 7)\\) are all already written\r\n\\(b\\) must be \\(8\\).\r\nAfter \\(n\\) rounds there will be\r\n\\(3n\\) numbers on the paper. Their sum\r\nis denoted by \\(M(n)\\).\r\nFor example, \\(M(10) = 642\\) and\r\n\\(M(1000) = 5432148\\).\r\nFind \\(M(10^{18})\\). Give your\r\nanswer modulo \\(1\\,000\\,000\\,007\\).\r\n解决方案\r\n使用以下程序暴力打印前面几行的规律，并得到结果：\r\nst = set()for i in range(100):    x = 1    while x in st:        x += 1    y = x + 1    while y in st or x ^ y in st:        y += 1    w = x + y + (x ^ y)    print(i, x, y, x ^ y, w)    st |= &#123;x, y, x ^ y&#125;\r\n1 1 2 3 62 4 8 12 243 5 10 15 304 6 11 13 305 7 9 14 306 16 32 48 967 17 34 51 1028 18 35 49 1029 19 33 50 10210 20 40 60 12011 21 42 63 12612 22 43 61 12613 23 41 62 12614 24 44 52 12015 25 46 55 12616 26 47 53 12617 27 45 54 12618 28 36 56 12019 29 38 59 12620 30 39 57 12621 31 37 58 12622 64 128 192 38423 65 130 195 39024 66 131 193 39025 67 129 194 39026 68 136 204 40827 69 138 207 41428 70 139 205 41429 71 137 206 41430 72 140 196 40831 73 142 199 41432 74 143 197 41433 75 141 198 41434 76 132 200 40835 77 134 203 41436 78 135 201 41437 79 133 202 414-----------------38 80 160 240 48039 81 162 243 48640 82 163 241 48641 83 161 242 48642 84 168 252 50443 85 170 255 51044 86 171 253 51045 87 169 254 51046 88 172 244 50447 89 174 247 51048 90 175 245 51049 91 173 246 51050 92 164 248 50451 93 166 251 51052 94 167 249 51053 95 165 250 510-----------------54 96 176 208 48055 97 178 211 48656 98 179 209 48657 99 177 210 48658 100 184 220 50459 101 186 223 51060 102 187 221 51061 103 185 222 51062 104 188 212 50463 105 190 215 51064 106 191 213 51065 107 189 214 51066 108 180 216 50467 109 182 219 51068 110 183 217 51069 111 181 218 510-----------------70 112 144 224 48071 113 146 227 48672 114 147 225 48673 115 145 226 48674 116 152 236 50475 117 154 239 51076 118 155 237 51077 119 153 238 51078 120 156 228 50479 121 158 231 51080 122 159 229 51081 123 157 230 51082 124 148 232 50483 125 150 235 51084 126 151 233 51085 127 149 234 51086 256 512 768 153687 257 514 771 154288 258 515 769 154289 259 513 770 1542\r\n可以观察到如下规律：\r\n所有的迭代都可以划分成阶段，其中第\\(i\\)个阶段包含了\\(4^i\\)轮的迭代。（\\(i\\)从\\(0\\)开始）。\r\n其中，第\\(i\\)个阶段有如下特点：\r\n\r\n\\(a\\in[4^i,2\\cdot 4^{i}),b\\in[2\\cdot\r\n4^{i},3\\cdot 4^i),a\\oplus b\\in[3\\cdot\r\n4^i,4^{i+1})\\)，这三个区间刚好连续且不重复地覆盖了\\([4^i,4^{i+1})\\)这个区间。\r\n对于\\(i&gt;0\\)，第\\(i\\)个阶段的所有迭代可以均匀分成\\(4\\)部分，并且这\\(4\\)部分都可以从第\\(i-1\\)阶段得出。对于这\\(4\\)部分\\(a,b,a\\oplus\r\nb\\)的关系，可以列出如下表格：\r\n\r\n\\(\\begin{array}{|c|c|c|}\r\n\\hline\r\na&amp;b&amp;a\\oplus b\\\\\r\n\\hline\r\n[4^i+0\\cdot 4^{i-1},4^i+1\\cdot 4^{i-1})&amp;[2\\cdot 4^i+0\\cdot\r\n4^{i-1},2\\cdot4^i+1\\cdot 4^{i-1})&amp;[3\\cdot 4^i+0\\cdot\r\n4^{i-1},3\\cdot4^i+1\\cdot 4^{i-1})\\\\\r\n\\hline\r\n[4^i+1\\cdot 4^{i-1},4^i+2\\cdot 4^{i-1})&amp;[2\\cdot 4^i+2\\cdot\r\n4^{i-1},2\\cdot4^i+3\\cdot 4^{i-1})&amp;[3\\cdot 4^i+3\\cdot\r\n4^{i-1},3\\cdot4^i+4\\cdot 4^{i-1})\\\\\r\n\\hline\r\n[4^i+2\\cdot 4^{i-1},4^i+3\\cdot 4^{i-1})&amp;[2\\cdot 4^i+3\\cdot\r\n4^{i-1},2\\cdot4^i+4\\cdot 4^{i-1})&amp;[3\\cdot 4^i+1\\cdot\r\n4^{i-1},3\\cdot4^i+2\\cdot 4^{i-1})\\\\\r\n\\hline\r\n[4^i+3\\cdot 4^{i-1},4^i+4\\cdot 4^{i-1})&amp;[2\\cdot 4^i+1\\cdot\r\n4^{i-1},2\\cdot4^i+2\\cdot 4^{i-1})&amp;[3\\cdot 4^i+2\\cdot\r\n4^{i-1},3\\cdot4^i+3\\cdot 4^{i-1})\\\\\r\n\\hline\r\n\\end{array}\\)\r\n并且，每一部分内部的变化量都和第\\(i-1\\)阶段相同，因此这里考虑使用分治的思想求解\\(M(n)\\)。\r\n为了方便计算\\(M(n)\\)，我们将\\(n\\)进行分块，以\\(4^j\\)为一块进行整体求和。\r\n令\\(f(n,a,b,c,m)\\)表示求三元组\\((a,b,c)\\)以及之后的\\(n\\)个项目之和，并且视作是以\\((a,b,c)\\)为开头进行的第\\(m\\)个阶段。这\\(m\\)个阶段中，所有数之和为\\(\\dfrac{(2a+4^m-1)\\cdot\r\n4^m}{2}+\\dfrac{(2b+4^m-1)\\cdot 4^m}{2}+\\dfrac{(2c+4^m-1)\\cdot\r\n4^m}{2}\\)。如果\\(n&lt;4^m\\)，那么继续将剩下的\\(n\\)个迭代分成\\(4\\)部分进行递归求解。\r\n代码\r\nN = 10 ** 18mod = 10 ** 9 + 7def f(n, a, b, c, m):    if n &lt;= 0:        return 0    pw = 1 &lt;&lt; (2 * m)    if n &gt; pw:        return (f(pw, a, b, c, m) + f(n - pw, a &lt;&lt; 2, b &lt;&lt; 2, c &lt;&lt; 2, m + 1)) % mod    elif n == pw:        return sum((x + x + pw - 1) * pw // 2 for x in [a, b, c]) %mod    else:        pw2 = pw &gt;&gt; 2        ans = f(min(n, pw2), a, b, c, m - 1)        ans += f(min(n - 1 * pw2, pw2), a + 1 * pw2, b + 2 * pw2, c + 3 * pw2, m - 1)        ans += f(min(n - 2 * pw2, pw2), a + 2 * pw2, b + 3 * pw2, c + 1 * pw2, m - 1)        ans += f(min(n - 3 * pw2, pw2), a + 3 * pw2, b + 1 * pw2, c + 2 * pw2, m - 1)        return ans % modans = f(N, 1, 2, 3, 0)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 84","url":"/project-euler/84/","content":"\r\nProject Euler 84\r\n题目\r\nMonopoly odds\r\nIn the game, Monopoly, the standard board is set up in the\r\nfollowing way:\r\n\r\nA player starts on the GO square and adds the scores on two 6-sided\r\ndice to determine the number of squares they advance in a clockwise\r\ndirection. Without any further rules we would expect to visit each\r\nsquare with equal probability: \\(2.5\\%\\). However, landing on G2J (Go To\r\nJail), CC (community chest), and CH (chance) changes this\r\ndistribution.\r\nIn addition to G2J, and one card from each of CC and CH, that orders\r\nthe player to go directly to jail, if a player rolls three consecutive\r\ndoubles, they do not advance the result of their 3rd roll. Instead they\r\nproceed directly to jail.\r\nAt the beginning of the game, the CC and CH cards are shuffled. When\r\na player lands on CC or CH they take a card from the top of the\r\nrespective pile and, after following the instructions, it is returned to\r\nthe bottom of the pile. There are sixteen cards in each pile, but for\r\nthe purpose of this problem we are only concerned with cards that order\r\na movement; any instruction not concerned with movement will be ignored\r\nand the player will remain on the CC/CH square.\r\n\r\nCommunity Chest (\\(2/16\\) cards):\r\n\r\nAdvance to GO\r\nGo to JAIL\r\n\r\nChance (10/16 cards):\r\n\r\nAdvance to GO\r\nGo to JAIL\r\nGo to C1\r\nGo to E3\r\nGo to H2\r\nGo to R1\r\nGo to next R (railway company)\r\nGo to next R\r\nGo to next U (utility company)\r\nGo back 3 squares.\r\n\r\n\r\nThe heart of this problem concerns the likelihood of visiting a\r\nparticular square. That is, the probability of finishing at that square\r\nafter a roll. For this reason it should be clear that, with the\r\nexception of G2J for which the probability of finishing on it is zero,\r\nthe CH squares will have the lowest probabilities, as 5/8 request a\r\nmovement to another square, and it is the final square that the player\r\nfinishes at on each roll that we are interested in. We shall make no\r\ndistinction between “Just Visiting” and being sent to JAIL, and we shall\r\nalso ignore the rule about requiring a double to “get out of jail”,\r\nassuming that they pay to get out on their next turn.\r\nBy starting at GO and numbering the squares sequentially from 00 to\r\n39 we can concatenate these two-digit numbers to produce strings that\r\ncorrespond with sets of squares.\r\nStatistically it can be shown that the three most popular squares, in\r\norder, are JAIL \\((6.24\\%)\\) = Square\r\n10, E3 \\((3.18\\%)\\) = Square 24, and GO\r\n\\((3.09\\%)\\) = Square 00. So these\r\nthree most popular squares can be listed with the six-digit modal\r\nstring: \\(102400\\).\r\nIf, instead of using two \\(6\\)-sided\r\ndice, two \\(4\\)-sided dice are used,\r\nfind the six-digit modal string.\r\n解决方案\r\n第一种方法直接通过随机数进行模拟整个游戏过程，模拟的过程中需要注意细节。\r\n第二种方法则是基于马尔科夫链，计算出极限分布。\r\n本题需要一个假设：虽然CC卡和CH卡一开始就是打乱的，但是在游戏过程中，每次抽取卡片的过程却是依赖上一次的抽卡结果（每次抽取的都是最上面的那一张）。为简化，这里将假设游戏过程中的抽卡也是随机的。\r\n由此，将整个马尔科夫链简化成了\\(40\\times\r\n3=120\\)个状态（\\(40\\)个位置，\\(3\\)次相同点数的次数）。\r\n只要构造出概率转移矩阵，就能够计算出极限分布（即分别在每个格子上的概率）。\r\n（基于马尔科夫链的做法和代码待补充）\r\n代码\r\nfrom random import randint, shuffleT = 10 ** 7M = 4def get_list():    ls = [x for x in range(1, 17)]    shuffle(ls)    return lsdef get_dices():    a, b = randint(1, M), randint(1, M)    return a + b, a == b# 根据地点计算下一个R。def next_rail(pos: int):    if 5 &lt;= pos &lt; 15:        return 15    elif 15 &lt;= pos &lt; 25:        return 25    elif 25 &lt;= pos &lt; 35:        return 35    else:        return 5# 根据地点计算下一个U。def next_utility(pos: int):    if 12 &lt;= pos &lt; 28:        return 28    else:        return 12cards = [-1, 0, 10, 11, 24, 39, 5]def cc(id: int, pos: int):    # 移动到指定地点的卡    if id &lt;= 2:        return cards[id]    else:        return posdef ch(id: int, pos: int):    # 移动到指定地点的卡    if id &lt;= 6:        return cards[id]    # 2张下一个R卡    elif 7 &lt;= id &lt;= 8:        return next_rail(pos)    # 1张下一个U卡    elif id == 9:        return next_utility(pos)    # 后退三格卡    elif id == 10:        pos -= 3        if pos &lt; 0:            pos += 40        return pos    else:        return poscnt = [0 for i in range(40)]# cc卡和ch卡分别用1~16的标号进行表示。ch_card = get_list()cc_card = get_list()pos = dbc = 0for i in range(T):    w, f = get_dices()    if f:        dbc += 1    else:        dbc = 0    if dbc == 3:        pos = 10        dbc = 0    else:        pos += w        if pos &gt;= 40:            pos -= 40            # 获取的是CC卡        if pos in [2, 17, 33]:            tp = cc_card.pop()            cc_card.insert(0, tp)            pos = cc(tp, pos)            # 获得的是CH卡        elif pos in [7, 22, 36]:            tp = ch_card.pop()            ch_card.insert(0, tp)            pos = ch(tp, pos)        elif pos == 30:            pos = 10        # 无论什么原因，只要到达监狱，次数就清零。        if pos == 10:            dbc = 0    cnt[pos] += 1a = [[i, cnt[i]] for i in range(40)]a.sort(key=lambda t: t[1])ans = str(a[-1][0]) + str(a[-2][0]) + str(a[-3][0])print(ans)\r\n","categories":["Project Euler"],"tags":["模拟","概率"]},{"title":"Project Euler 83","url":"/project-euler/83/","content":"\r\nProject Euler 83\r\n题目\r\nPath sum: four ways\r\nNOTE: This problem is a significantly more challenging version of Problem 81.\r\nIn the \\(5\\) by \\(5\\) matrix below, the minimal path sum from\r\nthe top left to the bottom right, by moving left, right, up, and down,\r\nis indicated in bold red and is equal to \\(2297\\).\r\n\\[\\begin{pmatrix}\r\n\\color{red}{131} &amp; 673 &amp; \\color{red}{234} &amp; \\color{red}{103}\r\n&amp; \\color{red}{18}\\\\\r\n\\color{red}{201} &amp; \\color{red}{96} &amp; \\color{red}{342} &amp; 965\r\n&amp; \\color{red}{150}\\\\\r\n630 &amp; 803 &amp; 746 &amp; \\color{red}{422} &amp; \\color{red}{111}\\\\\r\n537 &amp; 699 &amp; 497 &amp; \\color{red}{121} &amp; 956\\\\\r\n805 &amp; 732 &amp; 524 &amp; \\color{red}{37} &amp; \\color{red}{331}\r\n\\end{pmatrix}\\]\r\nFind the minimal path sum from the top left to the bottom right by\r\nmoving left, right, up, and down in matrix.txt (right click and\r\n“Save Link/Target As…”), a 31K text file containing an \\(80\\) by \\(80\\) matrix.\r\n解决方案\r\n本题不再适用于动态规划的做法，因为不能够很好地分阶段。\r\n注意到，本题求的是最小值。因此，可以将整个模型转化为图论的单源最短路去完成。\r\n令矩阵大小为\\(n\\)。把矩阵中的每一个元素视为一个节点，那么就是求节点\\((1,1)\\)到节点\\((n,n)\\)的最短路径。注意到这里使用的是有向图，边集如下构造：\r\n对于矩阵中所有元素，都有\\(4\\)条出边指向其四个方向的相邻元素，边权为指向的元素的值。\r\n最终，计算出\\((1,1)\\)到\\((n,n)\\)的最短路径长度再加上\\((1,1)\\)元素本身的值，就是最终答案。\r\n单源最短路以Dijkstra，Bellman-Ford为代表。多源最短路则以Floyd为代表。\r\n本代码实现主要使用networkx库利用Dijkstra算法导出结果。\r\n代码\r\nimport networkx as nxls = open(&#x27;p081_matrix.txt&#x27;, &#x27;r&#x27;).readlines()n = len(ls)a = []for i in range(n):    b = [int(x) for x in ls[i][:-1].split(&#x27;,&#x27;)]    a.append(b)g = nx.DiGraph()d = [[-1, 0], [1, 0], [0, -1], [0, 1]]for i in range(n):    for j in range(n):        for dx, dy in d:            x, y = i + dx, j + dy            if 0 &lt;= x &lt; n and 0 &lt;= y &lt; n:                g.add_edge((i, j), (x, y), weight=a[x][y])ans = nx.dijkstra_path_length(g, (0, 0), (n - 1, n - 1)) + a[0][0]print(ans)\r\n","categories":["Project Euler"],"tags":["图论"]},{"title":"Project Euler 86","url":"/project-euler/86/","content":"\r\nProject Euler 86\r\n题目\r\nCuboid route\r\nA spider, \\(S\\), sits in one corner\r\nof a cuboid room, measuring \\(6\\) by\r\n\\(5\\) by \\(3\\), and a fly, \\(F\\), sits in the opposite corner. By\r\ntravelling on the surfaces of the room the shortest “straight line”\r\ndistance from \\(S\\) to \\(F\\) is \\(10\\) and the path is shown on the\r\ndiagram.\r\n\r\nHowever, there are up to three “shortest” path candidates for any\r\ngiven cuboid and the shortest route doesn’t always have integer\r\nlength.\r\nIt can be shown that there are exactly \\(2060\\) distinct cuboids, ignoring\r\nrotations, with integer dimensions, up to a maximum size of \\(M\\) by \\(M\\) by \\(M\\), for which the shortest route has\r\ninteger length when \\(M = 100\\). This\r\nis the least value of \\(M\\) for which\r\nthe number of solutions first exceeds two thousand; the number of\r\nsolutions when \\(M = 99\\) is \\(1975\\).\r\nFind the least value of \\(M\\) such\r\nthat the number of solutions first exceeds one million.\r\n解决方案\r\n本题不考虑旋转。因此假设该长方体棱长分别为\\(a,b,c(a\\leq b\\leq\r\nc)\\)。通过该长方体的平面展开图，不难发现，最短距离\\(d\\)一定满足\\(d^2=(a+b)^2+c^2\\)，另外两种行走方式（指\\((a+c)^2+b^2\\)和\\((b+c)^2+a^2\\)）一定不是最短的。\r\n因此，可以先枚举\\(c\\)的值，再枚举\\(a+b\\)的值，在此过程中，判断\\((a+b)^2+c^2\\)是否为平方数即可。\r\n需要注意的是，当\\(a+b\\leq\r\nc\\)，满足\\(a\\leq b\\)的\\((a,b)\\)对数为\\(\\left\\lfloor\\dfrac{a+b}{2}\\right\\rfloor\\)。当\\(c&lt; a+b\\leq 2c\\)时，满足\\(a\\leq b\\leq c\\)的\\((a,b)\\)对数为\\(c+1-\\left\\lceil\\dfrac{a+b}{2}\\right\\rceil\\)。\r\n代码\r\nfrom itertools import countfrom tools import is_squareN = 10 ** 6cnt = 0c = 1for c in count(1, 1):    for ab in range(2, c * 2 + 1):        if is_square(ab * ab + c * c):            if ab &lt;= c:                cnt += ab // 2            else:                cnt += c - (ab + 1) // 2 + 1    if cnt &gt;= N:        ans = c        breakprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 87","url":"/project-euler/87/","content":"\r\nProject Euler 87\r\n题目\r\nPrime power triples\r\nThe smallest number expressible as the sum of a prime square, prime\r\ncube, and prime fourth power is \\(28\\).\r\nIn fact, there are exactly four numbers below fifty that can be\r\nexpressed in such a way:\r\n\\(\\begin{aligned}\r\n28 = 2^2 + 2^3 + 2^4\\\\\r\n33 = 3^2 + 2^3 + 2^4\\\\\r\n49 = 5^2 + 2^3 + 2^4\\\\\r\n47 = 2^2 + 3^3 + 2^4\r\n\\end{aligned}\\)\r\nHow many numbers below fifty million can be expressed as the sum of a\r\nprime square, prime cube, and prime fourth power?\r\n解决方案\r\n令\\(N=5\\times10^7\\)。\r\n观察到，这里的和都是质数的\\(2\\)次方及以上。因此，可以先预处理所有\\(\\sqrt N\\)以内的质数，再将这些质数的\\(2,3,4\\)次方按序存放在数组\\(a_2, a_3, a_4\\)中。\r\n直接枚举\\(3\\)个列表中每个组合，再将\\(3\\)个数的和存放进集合即可。\r\n代码\r\nfrom tools import get_prime, int_sqrtN = 5 * 10 ** 7M = int_sqrt(N)pr = get_prime(M)a2 = [x * x for x in pr]a3 = [x ** 3 for x in pr if x ** 3 &lt;= N]a4 = [x ** 4 for x in pr if x ** 4 &lt;= N]st = set()for x in a2:    for y in a3:        if x + y &gt;= N:            break        for z in a4:            if x + y + z &gt;= N:                break            st.add(x + y + z)ans = len(st)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 89","url":"/project-euler/89/","content":"\r\nProject Euler 89\r\n题目\r\nRoman numerals\r\nFor a number written in Roman numerals to be considered valid there\r\nare basic rules which must be followed. Even though the rules allow some\r\nnumbers to be expressed in more than one way there is always a “best”\r\nway of writing a particular number. For example, it would appear that\r\nthere are at least six ways of writing the number sixteen:\r\nIIIIIIIIIIIIIIII\r\nVIIIIIIIIIII\r\nVVIIIIII\r\nXIIIIIIVVVI XVI\r\nHowever, according to the rules only XIIIIII and XVI are valid, and the\r\nlast example is considered to be the most efficient, as it uses the\r\nleast number of numerals.\r\nThe 11K text file, roman.txt (right click and ‘Save\r\nLink/Target As…’), contains one thousand numbers written in valid, but\r\nnot necessarily minimal, Roman numerals; see\r\nAbout…\r\nRoman Numerals for the definitive rules for this problem.\r\nFind the number of characters saved by writing each of these in their\r\nminimal form. Note: You can assume that all the Roman numerals in the\r\nfile contain no more than four consecutive identical units.\r\n解决方案\r\n根据罗马数字的规则，可以先把所有字母对应的数直接全部用字典存。\r\n不过，罗马数字处理减法规则时可能有点麻烦。为解决这个困难，本代码使用的方案是将所有减法规则当作一个“标记”，也存在字典中。\r\n对罗马数进行解析的时候，需要先判断当前字母有没有应用到减法规则。如果有，那就和下一个字母一起计算，否则单独计算。\r\n将整数转化成罗马数的时候，对应使用贪心思想，每次取最大的进行拼接即可。\r\n代码\r\nls = open(&#x27;p089_roman.txt&#x27;, &#x27;r&#x27;).readlines()mp = &#123;    &#x27;IV&#x27;: 4, &#x27;IX&#x27;: 9, &#x27;XL&#x27;: 40, &#x27;XC&#x27;: 90, &#x27;CD&#x27;: 400, &#x27;CM&#x27;: 900,    &#x27;M&#x27;: 1000, &#x27;D&#x27;: 500, &#x27;C&#x27;: 100, &#x27;L&#x27;: 50, &#x27;X&#x27;: 10, &#x27;V&#x27;: 5, &#x27;I&#x27;: 1&#125;ln = []for x, y in mp.items():    ln.append([y, x])ln.sort()ln.reverse()# 将一个任意形式的罗马数转化为整数。def r2n(s: str):    ans = 0    while s != &quot;&quot;:        if len(s) &gt;= 2 and s[0:2] in mp.keys():            ans += mp[s[0:2]]            s = s[2:]        else:            ans += mp[s[0]]            s = s[1:]    return ans# 将一个整数转化为有效的罗马数。def n2r(n: int):    s = &quot;&quot;    for x, y in ln:        cnt = n // x        s += y * cnt        n -= x * cnt    return sans = 0for s in ls:    s = s.replace(&#x27;\\n&#x27;, &#x27;&#x27;)    ans += len(s) - len(n2r(r2n(s)))print(ans)\r\n","categories":["Project Euler"],"tags":["模拟","贪心"]},{"title":"Project Euler 85","url":"/project-euler/85/","content":"\r\nProject Euler 85\r\n题目\r\nCounting rectangles\r\nBy counting carefully it can be seen that a rectangular grid\r\nmeasuring \\(3\\) by \\(2\\) contains eighteen rectangles:\r\n\r\nAlthough there exists no rectangular grid that contains exactly two\r\nmillion rectangles, find the area of the grid with the nearest\r\nsolution.\r\n解决方案\r\n对于一个\\(n\\times\r\nm\\)的矩形，每一个小矩形对应着一个行区间的选择\\([u,d](1\\leq u\\leq d \\leq\r\nn)\\)，和一个列区间的选择\\([l,r](1\\leq\r\nl\\leq r\\leq m)\\)。\r\n注意到，这两个选择是相互独立的，行区间和列区间只要有一个不同的选择，那它就对应一个不同的的矩形。\r\n行区间的选择个数为\\(\\dfrac{n(n+1)}{2}\\)，列区间的选择个数为\\(\\dfrac{m(m+1)}{2}\\)。\r\n因此，一个\\(n\\times\r\nm\\)的矩形包含了\\(c(n,m)=\\dfrac{n(n+1)m(m+1)}{4}\\)个小矩形。\r\n直接枚举所有\\(c(n,m)\\leq\r\n2\\times10^6\\)的矩形进行判断就可以完成。\r\n代码\r\nfrom itertools import countN = 2000000def cal(n, m):    return (n * (n + 1) * m * (m + 1)) &gt;&gt; 2mx = 0for n in count(1, 1):    if cal(n, 1) &gt; N:        break    for m in count(n, 1):        w = cal(n, m)        if w &gt; N:            break        if w &gt; mx:            mx = w            ans = n * mprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 9","url":"/project-euler/9/","content":"\r\nProject Euler 9\r\n题目\r\nSpecial Pythagorean triplet\r\nA Pythagorean triplet is a set of three natural numbers, \\(a &lt; b &lt; c\\), for which,\r\n\\[a^2 + b^2 = c^2\\]\r\nFor example, \\(32 + 42 = 9 + 16 = 25 =\r\n52\\).\r\nThere exists exactly one Pythagorean triplet for which \\(a + b + c = 1000\\).\r\nFind the product \\(abc\\).\r\n解决方案\r\n设\\(n=1000\\)，并联立以下两个方程：\r\n\\[\\left \\{\r\n\\begin{aligned}\r\na^2 + b^2 &amp;= c^2\\\\\r\na+b+c &amp;=n\r\n\\end{aligned}\r\n\\right.\r\n\\] 可以得到\\(b\\)关于\\(a\\)的关系： \\[b=\\dfrac{n^2-2an}{2(n-a)}\\]\r\n因此，由\\(a\\)可以直接计算出\\(b\\)。通过判断\\(b\\)是否为整数，然后计算出\\(c\\)，再判断是否满足\\(a&lt;b&lt;c\\)即可。\r\n代码\r\nN = 1000ans = 0for a in range(1, N // 3):    if (N * N - 2 * a * N) % (2 * N - 2 * a) == 0:        b = (N * N - 2 * a * N) // (2 * N - 2 * a)        c = N - a - b        if a &lt; b &lt; c:            ans += a * b * cprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 90","url":"/project-euler/90/","content":"\r\nProject Euler 90\r\n题目\r\nCube digit pairs\r\nEach of the six faces on a cube has a different digit (\\(0\\) to \\(9\\)) written on it; the same is done to a\r\nsecond cube. By placing the two cubes side-by-side in different\r\npositions we can form a variety of \\(2\\)-digit numbers. For example, the square\r\nnumber \\(64\\) could be formed:\r\n\r\nIn fact, by carefully choosing the digits on both cubes it is\r\npossible to display all of the square numbers below one-hundred: \\(01, 04, 09, 16, 25, 36, 49, 64\\), and \\(81\\).\r\nFor example, one way this can be achieved is by placing \\(\\{0, 5, 6, 7, 8, 9\\}\\) on one cube and\r\n\\(\\{1, 2, 3, 4, 8, 9\\}\\) on the other\r\ncube.\r\nHowever, for this problem we shall allow the \\(6\\) or \\(9\\) to be turned upside-down so that an\r\narrangement like \\(\\{0, 5, 6, 7, 8,\r\n9\\}\\) and \\(\\{1, 2, 3, 4, 6,\r\n7\\}\\) allows for all nine square numbers to be displayed;\r\notherwise it would be impossible to obtain \\(09\\).\r\nIn determining a distinct arrangement we are interested in the digits\r\non each cube, not the order.\r\n\\(\\{1, 2, 3, 4, 5, 6\\}\\) is\r\nequivalent to \\(\\{3, 6, 4, 1, 2, 5\\}\\)\r\n\\(\\{1, 2, 3, 4, 5, 6\\}\\) is distinct\r\nfrom \\(\\{1, 2, 3, 4, 5, 9\\}\\)\r\nBut because we are allowing \\(6\\)\r\nand \\(9\\) to be reversed, the two\r\ndistinct sets in the last example both represent the extended set \\(\\{1, 2, 3, 4, 5, 6, 9\\}\\) for the purpose\r\nof forming \\(2\\)-digit numbers.\r\nHow many distinct arrangements of the two cubes allow for all of the\r\nsquare numbers to be displayed?\r\n解决方案\r\n每个盒子一共有\\(\\dbinom{10}{6}=210\\)种情况可以填数。两个盒子一起则有\\(\\dfrac{210\\times(210+1)}{2}=22155\\)种。\r\n此处使用itertools库的combinations产生所有组合。\r\n枚举所有的组合，然后判断平方数中的两个位是否分别在两个集合中。\r\n代码\r\nfrom itertools import combinationsx, y = [0, 0, 0, 1, 2, 3, 4, 6, 8], [1, 4, 9, 6, 5, 6, 9, 4, 1]ls = []for s in combinations([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 6):    st = set(s)    if 6 in st or 9 in st:        st.add(6)        st.add(9)    ls.append(st)ans = 0for i in range(len(ls)):    for j in range(i, len(ls)):        sa, sb = ls[i], ls[j]        ok = True        for k in range(9):            if not (x[k] in sa and y[k] in sb or x[k] in sb and y[k] in sa):                ok = False                break        ans += okprint(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 91","url":"/project-euler/91/","content":"\r\nProject Euler 91\r\n题目\r\nRight triangles with\r\ninteger coordinates\r\nThe points \\(P (x_1, y_1)\\) and\r\n\\(Q (x_2, y_2)\\) are plotted at integer\r\nco-ordinates and are joined to the origin, \\(O(0,0)\\), to form \\(\\triangle OPQ\\).\r\n\r\nThere are exactly fourteen triangles containing a right angle that\r\ncan be formed when each co-ordinate lies between \\(0\\) and \\(2\\) inclusive; that is, \\(0 \\leq x_1, y_1, x_2, y_2 \\leq 2\\).\r\n\r\nGiven that \\(0 \\leq x_1, y_1, x_2, y_2 \\leq\r\n50\\), how many right triangles can be formed?\r\n解决方案\r\n由于只有\\(51\\times\r\n51-1\\)个点，因此每次可以枚举出两个点，通过判断向量内积是否为\\(0\\)来找出直角。\r\n将枚举出来的三角形的每一条边都视为一个向量，两两做内积，就可以完成判断，找到一个直角三角形。\r\n通过查询OEIS该数列的前几项，发现结果为A155154。在PROG一栏中，发现如下信息：\r\n(PARI) a(n)=3*n^2+sum(a=1, n, sum(b = 1, n, 2*min(b*gcd(a, b)\\a, (n - a)*gcd(a, b)\\b) ) ) \\\\ Yurii Ivanov, Jun 25 2021\r\n通过这个信息，可以以\\(O(n^2\\log\r\nn)\\)计算出本题的结果：\r\n\\[3n^2+\\sum_{a=1}^n\\sum_{b=1}^n2\\min\\left(\\left\\lfloor\\frac{b\\gcd(a,b)}{a}\\right\\rfloor,\\left\\lfloor\\frac{(n-a)\\gcd(a,b)}{b}\\right\\rfloor\\right)\\]\r\n代码\r\nN = 50def ok(a: complex, b: complex):    if a.imag * b.imag + a.real * b.real == 0:        return 1    u = b - a    if u.imag * a.imag + u.real * a.real == 0:        return 1    v = a - b    if v.imag * b.imag + v.real * b.real == 0:        return 1    return 0ls = []for i in range(0, N + 1):    for j in range(0, N + 1):        if i + j &gt; 0:            ls.append(complex(i, j))ans = 0for i in range(len(ls)):    for j in range(i + 1, len(ls)):        if ok(ls[i], ls[j]):            ans += 1print(ans)\r\nfrom tools import gcdN = 50ans = 3 * N ** 2for a in range(1, N + 1):    for b in range(1, N + 1):        g = gcd(a, b)        ans += 2 * min(b * g // a, (N - a) * g // b)print(ans)\r\n","categories":["Project Euler"],"tags":["OEIS"]},{"title":"Project Euler 92","url":"/project-euler/92/","content":"\r\nProject Euler 92\r\n题目\r\nSquare digit chains\r\nA number chain is created by continuously adding the square of the\r\ndigits in a number to form a new number until it has been seen\r\nbefore.\r\nFor example,\r\n\\(\\begin{aligned}\r\n&amp;44 \\rightarrow 32 \\rightarrow 13 \\rightarrow 10 \\rightarrow\r\n\\mathbf{1} \\rightarrow \\mathbf{1}\\\\\r\n&amp;85 \\rightarrow \\mathbf{89}  \\rightarrow 145 \\rightarrow 42\r\n\\rightarrow 20 \\rightarrow 4 \\rightarrow 16 \\rightarrow 37 \\rightarrow\r\n58 \\rightarrow \\mathbf{89}\r\n\\end{aligned}\\)\r\nTherefore any chain that arrives at \\(1\\) or \\(89\\) will become stuck in an endless loop.\r\nWhat is most amazing is that EVERY starting number will eventually\r\narrive at \\(1\\) or \\(89\\).\r\nHow many starting numbers below ten million will arrive at \\(89\\)?\r\n解决方案\r\n本代码使用递归的方式。直接计算数位平方和，然后递归判断每一个数属于\\(1\\)的类还是\\(89\\)的类。\r\n本代码采用记忆化递归的方式，将每个值的计算结果存好，减少计算时间，保证每个数只被计算一次。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;const int M=10000000;char f[max(M,300)+4];char dfs(int u)&#123;    if(u==1) return 1;    else if(u==89) return 0;    else if(f[u]!=-1) return f[u];    int s=0;    for(int w=u;w;w/=10)        s+=(w%10)*(w%10);    return f[u]=dfs(s);&#125;int main()&#123;    memset(f,-1,sizeof(f));    int ans=0;    for(int i=1;i&lt;=M;i++)&#123;        if(dfs(i)==0) ++ans;    &#125;    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 93","url":"/project-euler/93/","content":"\r\nProject Euler 93\r\n题目\r\nArithmetic expressions\r\nBy using each of the digits from the set, \\(\\{1, 2, 3, 4\\}\\), exactly once, and making\r\nuse of the four arithmetic operations \\((+, −,\r\n*, /)\\) and brackets/parentheses, it is possible to form\r\ndifferent positive integer targets. For example,\r\n\\(8 = (4 *(1 + 3)) / 2\\) \\(14 = 4* (3 + 1 / 2)\\) \\(19 = 4 *(2 + 3) − 1\\) \\(36 = 3* 4 * (2 + 1)\\)\r\nNote that concatenations of the digits, like \\(12 + 34\\), are not allowed.\r\nUsing the set, \\(\\{1, 2, 3, 4\\}\\),\r\nit is possible to obtain thirty-one different target numbers of which\r\n\\(36\\) is the maximum, and each of the\r\nnumbers \\(1\\) to \\(28\\) can be obtained before encountering\r\nthe first non-expressible number.\r\nFind the set of four distinct digits, \\(a\r\n&lt; b &lt; c &lt; d\\), for which the longest set of consecutive\r\npositive integers, \\(1\\) to \\(n\\), can be obtained, giving your answer as\r\na string: \\(abcd\\).\r\n解决方案\r\n直接枚举。\r\n为了加速，先将其转为后缀表达式。可以发现，转化成后缀表达式后，一共有\\(5\\)种不同的运算顺序。\r\n遍历每个后缀表达式模板，填入枚举的数字和运算符后，再用后缀表达式直接做运算。\r\n枚举量：一共有\\(\\dbinom{9}{4}\\)个候选答案。对于每个组合，其中可以以任意顺序填入后缀表达式中，一共有\\(4!\\)种。一共要做\\(3\\)次运算，因此运算符的组合有\\(4^3\\)种。因此需要进行\\(\\dbinom{9}{4}\\times 4!\\times 4^3\\times\r\n5=967680\\)次的枚举。\r\n在此过程中，需要注意除数为\\(0\\)的情况。\r\n代码\r\nfrom itertools import permutations, product, combinations, count# value_pos_list = [p for p in set(permutations([-1, -1, -1, 1, 1, 1, 1])) if all(sum(p[:i + 1]) &gt; 0 for i in range(# len(p)))]# print(value_pos_list)op_list = list(&quot;&quot;.join(l) for l in product(&quot;+-*/&quot;, repeat=3))def cal(s: str):    ls = []    for t in s:        if t.isdigit():            ls.append(int(t))        else:            x, y = ls[-2], ls[-1]            ls.pop()            if t == &#x27;+&#x27;:                ls[-1] = x + y            elif t == &#x27;-&#x27;:                ls[-1] = x - y            elif t == &#x27;*&#x27;:                ls[-1] = x * y            elif y:                ls[-1] = x / y            else:                return 0    w = ls[0]    return round(w) if abs(w - round(w)) &lt; 1e-8 else 0def solve(values):    st = set()    for per in permutations(values):        digit = &quot;&quot;.join(str(x) for x in per)        for op in op_list:            st.add(cal(digit[:2] + op[0] + digit[2:] + op[1:]))            st.add(cal(digit[:3] + op[:2] + digit[3] + op[2]))            st.add(cal(digit[:3] + op[0] + digit[3] + op[1:]))            st.add(cal(digit + op))            st.add(cal(digit[:2] + op[0] + digit[2] + op[1] + digit[3] + op[2]))    for i in count(1, 1):        if i not in st:            return i - 1    return -1mx = 0for v in combinations(list(range(1, 10)), 4):    w = solve(v)    if w &gt; mx:        mx = w        ans = &quot;&quot;.join(str(x) for x in v)print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 94","url":"/project-euler/94/","content":"\r\nProject Euler 94\r\n题目\r\nAlmost equilateral triangles\r\nIt is easily proved that no equilateral triangle exists with integral\r\nlength sides and integral area. However, the almost equilateral triangle\r\n\\(5-5-6\\) has an area of \\(12\\) square units.\r\nWe shall define an almost equilateral triangle to be a triangle for\r\nwhich two sides are equal and the third differs by no more than one\r\nunit.\r\nFind the sum of the perimeters of all almost equilateral triangles\r\nwith integral side lengths and area and whose perimeters do not exceed\r\none billion \\((1,000,000,000)\\).\r\n解决方案\r\n\r\n如上图，根据勾股定理，可以得到\\(a^2+4h^2=4b^2\\)。\r\n又\\(a=b\\pm1\\)，得\\((b\\pm1)+4h^2=4b^2\\)，\r\n\\(3b^2-4h^2\\pm 2b-1=0\\)，\r\n\\(9b^2\\pm 6b+1-12h^2=4\\)，\r\n最终得到\\(\\left(\\dfrac{3b\\pm1}{2}\\right)^2-3h^2=1\\)。\r\n令\\(x=\\dfrac{3b\\pm1}{2},y=h\\)，即可得到佩尔方程\\(x^2-3y^2=1\\)。\r\n因此，找到该佩尔方程的整数解后，还需判断\\(b=\\dfrac{2x\\pm 1}{3}\\)是否解出为整数。\r\n使用66题中的解法，可以得到该佩尔方程的最小解为\\((2,1)\\)。\r\n那么代入66题，得到通解为\\(x_{k+1}=2x_k+3y_k,y_{k+1}=x_k+2y_k\\)。将值回代，计算出周长即可。\r\n代码\r\nfrom tools import int_sqrtN = 10 ** 9ans = 0def gen_solution():    x, y = 2, 1    yield x, y    while True:        x, y = 2 * x + 3 * y, x + 2 * y        yield x, yfor x, h in gen_solution():    if (2 * x + 1) % 3 == 0:        b = (2 * x + 1) // 3        a = int_sqrt(b * b - h * h) * 2        C = a + b + b        if C &gt; N:            break        if min(a, b) &gt; 0:            ans += Cfor x, h in gen_solution():    if (2 * x - 1) % 3 == 0:        b = (2 * x - 1) // 3        a = int_sqrt(b * b - h * h) * 2        C = a + b + b        if C &gt; N:            break        if min(a, b) &gt; 0:            ans += Cprint(ans)\r\n","categories":["Project Euler"],"tags":["佩尔方程"]},{"title":"Project Euler 96","url":"/project-euler/96/","content":"\r\nProject Euler 96\r\n题目\r\nSu Doku\r\nSu Doku (Japanese meaning number place) is the name given to a\r\npopular puzzle concept. Its origin is unclear, but credit must be\r\nattributed to Leonhard Euler who invented a similar, and much more\r\ndifficult, puzzle idea called Latin Squares. The objective of Su Doku\r\npuzzles, however, is to replace the blanks (or zeros) in a \\(9\\) by \\(9\\) grid in such that each row, column, and\r\n\\(3\\) by \\(3\\) box contains each of the digits \\(1\\) to \\(9\\). Below is an example of a typical\r\nstarting puzzle grid and its solution grid.\r\n \r\nA well constructed Su Doku puzzle has a unique solution and can be\r\nsolved by logic, although it may be necessary to employ “guess and test”\r\nmethods in order to eliminate options (there is much contested opinion\r\nover this). The complexity of the search determines the difficulty of\r\nthe puzzle; the example above is considered easy because it can be\r\nsolved by straight forward direct deduction.\r\nThe 6K text file, sudoku.txt (right click and\r\n‘Save Link/Target As…’), contains fifty different Su Doku puzzles\r\nranging in difficulty, but all with unique solutions (the first puzzle\r\nin the file is the example above).\r\nBy solving all fifty puzzles find the sum of the \\(3\\)-digit numbers found in the top left\r\ncorner of each solution grid; for example, \\(483\\) is the \\(3\\)-digit number found in the top left\r\ncorner of the solution grid above.\r\n解决方案\r\n本代码主要采用深度优先搜索解决：每次尝试寻找一个格子并填充，然后判断是否合法。\r\n使用的加速优化手段如下：\r\n\r\n使用位运算。每行/列/宫格都有一个\\(9\\)比特编码，用来表示该行/列/宫格有哪些数字已经用了。\r\n每次填数时，寻找当前可填数最少的格子进行填数。这能够确保如果一个格子没有数填了，就及时返回。\r\n使用lowbit。将与运算获得填数的候选值，通过lowbit可以直接取出，不需要再用一个for循环遍历\\(9\\)个比特。\r\n\r\n此处提及一下Dancing\r\nLinks算法，一个专门解决精准覆盖问题的算法，如本问题数独游戏。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;# define lb(x) (x &amp; -x)using namespace std;int r[10], c[10], p[10], lg2[604], cnt_bit[604], cnt = 0,INF = 0x3f3f3f3f;//r,c,p分别表示对应行/列/宫格中，数的使用情况。inline void get(int &amp; R, int &amp; C, int &amp; P, int i) &#123; R=i/9,C=i%9,P=R/3*3+C/3;&#125;inline void op(int R, int C, int P, int z)&#123;    r[R]^=1&lt;&lt;z;c[C]^=1&lt;&lt;z;p[P]^=1&lt;&lt;z;&#125;void init() &#123; for(int i=0;i&lt;10; i++) r[i]=c[i]=p[i]=(1&lt;&lt;9)-1; cnt=0; &#125;char s[100];bool dfs(int cnt)&#123;    if (!cnt) return 1;    int R,C,P,k=INF,v=0;    for (int i=0;s[i];i++)        if (s[i]==&#x27;0&#x27;)        &#123;            get(R,C,P,i);            int t=r[R]&amp;c[C]&amp;p[P];            if (!t) return 0;            if (cnt_bit[t] &lt; k)v=i, k=cnt_bit[t];        &#125;    get(R,C,P,v);    k=r[R]&amp;c[C]&amp;p[P];    while (k)    &#123;        int x=lg2[lb(k)];        s[v]=x+&#x27;1&#x27;;        op(R,C,P,x);        if (dfs(cnt-1)) return 1;        s[v] = &#x27;0&#x27;;        op(R,C,P,x);        k-=lb(k);    &#125;    return 0;&#125;int main()&#123;    freopen(&quot;p096_sudoku.txt&quot;,&quot;r&quot;,stdin);    int R, C, P;    for (int i=0;i&lt;=8;i++) lg2[1 &lt;&lt; i]=i;    for (int i=0;i&lt;600;i++)    &#123;        int t=i;        while(t)t-=lb(t),cnt_bit[i]++;    &#125;    int ans=0;    while(~scanf(&quot;%s %s&quot;,s,s))&#123;        init();        // 输入的数独直接以一个81字节的一维数组存储。        for(int i=0,off_set=0; i &lt; 9; i++, off_set+=9)            scanf(&quot;%s&quot;, s + off_set);        for(int i=0;s[i];i++)        &#123;            if (s[i]!=&#x27;0&#x27;)            &#123;                get(R,C,P,i);                op(R,C,P,s[i]-&#x27;1&#x27;);            &#125;            else cnt++;        &#125;        dfs(cnt);        ans+=100*(s[0]-&#x27;0&#x27;);        ans+=10*(s[1]-&#x27;0&#x27;);        ans+=s[2]-&#x27;0&#x27;;    &#125;    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["模拟"]},{"title":"Project Euler 97","url":"/project-euler/97/","content":"\r\nProject Euler 97\r\n题目\r\nLarge non-Mersenne prime\r\nThe first known prime found to exceed one million digits was\r\ndiscovered in \\(1999\\), and is a\r\nMersenne prime of the form \\(2^{6972593}−1\\); it contains exactly \\(2,098,960\\) digits. Subsequently other\r\nMersenne primes, of the form \\(2^p−1\\),\r\nhave been found which contain more digits.\r\nHowever, in \\(2004\\) there was found\r\na massive non-Mersenne prime which contains \\(2,357,207\\) digits: \\(28433\\times2^{7830457}+1\\).\r\nFind the last ten digits of this prime number.\r\n解决方案\r\n使用python中的pow直接计算。\r\n代码\r\na = 7830457b = 28433mod = 10 ** 10ans = (pow(2, a, mod) * b + 1) % modprint(&quot;&#123;:010&#125;&quot;.format(ans))\r\n","categories":["Project Euler"]},{"title":"Project Euler 95","url":"/project-euler/95/","content":"\r\nProject Euler 95\r\n题目\r\nAmicable chains\r\nThe proper divisors of a number are all the divisors excluding the\r\nnumber itself. For example, the proper divisors of \\(28\\) are \\(1, 2,\r\n4, 7\\), and \\(14\\). As the sum\r\nof these divisors is equal to \\(28\\),\r\nwe call it a perfect number.\r\nInterestingly the sum of the proper divisors of \\(220\\) is \\(284\\) and the sum of the proper divisors of\r\n\\(284\\) is \\(220\\), forming a chain of two numbers. For\r\nthis reason, \\(220\\) and \\(284\\) are called an amicable pair.\r\nPerhaps less well known are longer chains. For example, starting with\r\n\\(12496\\), we form a chain of five\r\nnumbers:\r\n\\[ 12496 \\rightarrow 14288 \\rightarrow\r\n15472 \\rightarrow 14536 \\rightarrow 14264 (\\rightarrow 12496 \\rightarrow\r\n\\dots)\\]\r\nSince this chain returns to its starting point, it is called an\r\namicable chain.\r\nFind the smallest member of the longest amicable chain with no\r\nelement exceeding one million.\r\n解决方案\r\n将\\(1\\sim\r\nN\\)中所有数的真因数和通过筛法计算出来，这需要\\(O(N\\log N)\\)的时间。\r\n从图论的角度上看，这是一张所有节点都只有一条出边的有向图（每个节点\\(i\\)向其真因数和的节点\\(\\text{sigma}[i]\\)连边），因此每个节点最多只属于一个环。\r\n因此本问题就变成了在这个特殊的图上找出那个最大的环。\r\n如果一个数的真因数和大于\\(N\\)，那么根据题意，将这个节点标记为无效节点（答案肯定不是这个节点的值）。可以递归地发现：如果一个节点的后继为无效节点，那么这个节点本身就是无效节点。\r\n此外，在枚举的过程中，还需要判断这个节点是否为链上，而不是在环上。\r\n本代码也使用了记忆化搜索，用来记录这些节点的状态值是无效的，在环上的长度，还是在链上。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;const int N=1000000;//f：记录答案，sigma：真因数之和，st：深搜时用来存放节点的栈，pos：节点在栈中的位置。int f[N+4],sigma[N + 4],pos[N + 4];int st[N+4];int dfs(int u,int fl)&#123;    if(f[u]) return f[u];    st[fl]=u;    //如果这个节点已经在栈中了，那么说明找到了一个环，该节点及栈中以后的节点都在这个环中。    if(pos[u])&#123;        for(int i=pos[u];i&lt;fl;i++)            f[st[i]]=fl-pos[u];        return f[u];    &#125;    pos[u]=fl;    //三种情况：无效节点，后继节点是无效节点，本节点是链上的节点。    if(sigma[u] == 0 || dfs(sigma[u], fl + 1) == -1 || f[u] == 0) return f[u]=-1;    pos[u]=0;    return f[u];&#125;int main()&#123;    for(int i=1;i&lt;=N;i++)        for(int j=i+i;j&lt;=N;j+=i)            sigma[j]+=i;    for(int i=1;i&lt;=N;i++)        if(sigma[i] &gt; N) sigma[i]=0;    int mx=0,ans=0;    for(int i=1;i&lt;=N;i++)&#123;        if(dfs(i,1)&gt;mx)&#123;            mx=f[i];            ans=i;        &#125;    &#125;    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"]},{"title":"Project Euler 98","url":"/project-euler/98/","content":"\r\nProject Euler 98\r\n题目\r\nAnagramic squares\r\nBy replacing each of the letters in the word CARE with \\(1, 2, 9\\), and \\(6\\) respectively, we form a square number:\r\n\\(1296 = 36 ^2\\). What is remarkable is\r\nthat, by using the same digital substitutions, the anagram, RACE, also\r\nforms a square number: \\(9216 = 96\r\n^2\\). We shall call CARE (and RACE) a square anagram word pair\r\nand specify further that leading zeroes are not permitted, neither may a\r\ndifferent letter have the same digital value as another letter.\r\nUsing words.txt (right\r\nclick and ‘Save Link/Target As…’), a 16K text file containing nearly\r\ntwo-thousand common English words, find all the square anagram word\r\npairs (a palindromic word is NOT considered to be an anagram of\r\nitself).\r\nWhat is the largest square number formed by any member of such a\r\npair?\r\nNOTE: All anagrams formed must be contained in the given text\r\nfile.\r\n解决方案\r\n先进行两步预处理。\r\n\r\n首先将所有同构的字符串放在一起，再将这些同构的字符串对处理出来。可以发现，数量大于\\(1\\)的类别很少。因此，经过这次预处理，同构字符串对的数量很少。\r\n将所有存在自身的排列也是平方数的平方数（如\\(144\\)和\\(441\\)）按照使用数位的情况分类进行存储。类似的，可以发现，数量大于\\(1\\)的类别也很少。\r\n\r\n这次预处理则将大量平方数和大量字符串进行排除，方便后面筛选。\r\n接下来，对所有同构的字符串对进行枚举。\r\n遍历对应长度下的所有平方数，尝试按照两个同构字符串的方式，将这个平方数映射成另外一个数。最后判断答案合法性即可。\r\n代码\r\nls = open(&#x27;p098_words.txt&#x27;, &#x27;r&#x27;).readlines()[0].split(&#x27;,&#x27;)# 判断两个字符串是否同构。def cmp(s: str, t: str):    m = len(s)    for i in range(m):        for j in range(i + 1, m):            if (s[i] == s[j]) ^ (t[i] == t[j]):                return 0    return 1# 输入一个字符串s和其同构的字符串数t，返回s依照w对t进行重排的数。def replace(s: str, t: str, w: str):    m = len(s)    my_mp = &#123;&#125;    for i in range(m):        my_mp[s[i]] = t[i]    z = &quot;&quot;    for i in range(m):        z += my_mp[w[i]]    return int(z)# 预处理出pairs，所有的重排单词对。mp, pairs = &#123;&#125;, []for s in ls:    s = s[1:-1]    u = &quot;&quot;.join((lambda x: (x.sort(), x)[1])(list(s)))    if u not in mp.keys():        mp[u] = []    mp[u].append(s)mx_str_len = 0for y in mp.values():    if len(y) &gt;= 2:        m = len(y)        for i in range(m):            mx_str_len = max(mx_str_len, len(y[i]))            for j in range(i + 1, m):                pairs.append([y[i], y[j]])# print(len(pairs))mp, mq = &#123;&#125;, &#123;&#125;i = 1while True:    x = i * i    if x &gt;= 10 ** mx_str_len:        break    s = str(x)    u = &quot;&quot;.join((lambda x: (x.sort(), x)[1])(list(s)))    if u not in mp.keys():        mp[u] = []    mp[u].append(x)    i += 1for y in mp.values():    if len(y) &gt;= 2:        for w in y:            l = len(str(w))            if l not in mq.keys():                mq[l] = set()            mq[l].add(w)ans = 0for x, y in pairs:    m = len(x)    if m not in mq.keys():        continue    for val in mq[m]:        # 不同字母必须对应不同数字。因此x和str(val)需要同构。        if cmp(x, str(val)) and replace(x, str(val), y) in mq[m]:            ans = max(ans, val, replace(x, str(val), y))print(ans)\r\n","categories":["Project Euler"]},{"title":"Project Euler 99","url":"/project-euler/99/","content":"\r\nProject Euler 99\r\n题目\r\nLargest exponential\r\nComparing two numbers written in index form like \\(2^{11}\\) and \\(3^7\\) is not difficult, as any calculator\r\nwould confirm that \\(2^{11} = 2048 &lt; 3^7 =\r\n2187\\).\r\nHowever, confirming that \\(632382^{518061}\r\n&gt; 519432^{525806}\\) would be much more difficult, as both\r\nnumbers contain over three million digits.\r\nUsing base_exp.txt\r\n(right click and ‘Save Link/Target As…’), a 22K text file containing one\r\nthousand lines with a base/exponent pair on each line, determine which\r\nline number has the greatest numerical value. NOTE: The first two lines\r\nin the file represent the numbers in the example given above.\r\n解决方案\r\n由于对数函数\\(y=\\ln x\\) 在 \\((0,+\\infty)\\)上递增。因此我们可以这些形如\\(a^b\\)的所有数全部取对数化成\\(b\\ln a\\)，它们的相对大小依然不变。\r\n因此，直接将所有数的对数值计算出即可完成比较。\r\n代码\r\nfrom math import logls = open(&#x27;p099_base_exp.txt&#x27;, &#x27;r&#x27;).readlines()ans, i, mx = 0, 0, 0for s in ls:    i += 1    s = s[:-1]    p, e = [int(x) for x in s.split(&#x27;,&#x27;)]    w = log(p) * e    if w &gt; mx:        mx = w        ans = iprint(ans)\r\n","categories":["Project Euler"]},{"url":"/project-euler/images/","content":"\r\n"},{"url":"/project-euler/resources/","content":"\r\n"},{"title":"Project Euler 88","url":"/project-euler/88/","content":"\r\nProject Euler 88\r\n题目\r\nProduct-sum numbers\r\nA natural number, \\(N\\), that can be\r\nwritten as the sum and product of a given set of at least two natural\r\nnumbers, \\(\\{a_1, a_2, ... , a_k\\}\\) is\r\ncalled a product-sum number:\r\n\\(N = a_1 + a_2 + ... + a_k = a_1 \\times\r\na_2 \\times ... \\times a_k\\).\r\nFor example, \\(6 = 1 + 2 + 3 = 1 \\times 2\r\n\\times 3\\).\r\nFor a given set of size, \\(k\\), we\r\nshall call the smallest \\(N\\) with this\r\nproperty a minimal product-sum number. The minimal product-sum numbers\r\nfor sets of size, \\(k = 2, 3, 4, 5\\),\r\nand \\(6\\) are as follows.\r\n\\(\\begin{aligned}\r\n&amp;k=2:4=2 \\times 2 = 2 + 2\\\\\r\n&amp;k=3:6=1 \\times 2 \\times 3 = 1 + 2 + 3\\\\\r\n&amp;k=4:8=1 \\times 1 \\times 2 \\times 4 = 1 + 1 + 2 + 4\\\\\r\n&amp;k=5:8=1 \\times 1 \\times 2 \\times 2 \\times 2  = 1 + 1 + 2 + 2 + 2\\\\\r\n&amp;k=6:12=1 \\times 1 \\times 1 \\times 1 \\times 2 \\times 6 = 1 + 1 + 1 +\r\n1 + 2 + 6\r\n\\end{aligned}\\)\r\nHence for \\(2\\leq k\\leq 6\\), the sum\r\nof all the minimal product-sum numbers is \\(4+6+8+12=30;\\) note that \\(8\\) is only counted once in the sum.\r\nIn fact, as the complete set of minimal product-sum numbers for \\(2\\leq k\\leq 12\\) is \\(\\{4, 6, 8, 12, 15, 16\\}\\), the sum is \\(61\\).\r\nWhat is the sum of all the minimal product-sum numbers for \\(2\\leq k\\leq12000\\)?\r\n解决方案\r\n可以知道，对于绝大多数\\(k\\)，满足题目条件的序列\\(\\{a\\}\\)中，大多数的值都是\\(1\\)，最多只有\\(m=\\lfloor\\log_2k\\rfloor\\)个数的值非\\(1\\)。\r\n因此，不失一般性，先对\\(\\{a\\}\\)（长度未知）的前\\(m\\)个的值进行枚举，那么最终可以计算出长度\\(k=\\prod_{i=1}^m-\\sum_{i=1}^ma_i+m\\)，其余\\(k-m\\)个值必定全为\\(1\\)。\r\n为了遍历所有情况，本代码遍历时，\\(a_1,a_2,...,a_m\\)可以为\\(1\\)，这是为了方便求出\\(k\\)比较小时的情况。\r\n关于在某个特定的\\(k\\)下，和积值\\(N\\)的上限。先枚举前几项出来，查询OEIS的结果为A104173。在FORMULA一栏，发现：\r\na(n) &lt;= 2n, since 1^(n-2)* 2*n = (n-2)*1 + 2 + n. - Étienne Dupuis, Dec 07 2021\r\n这说明，每个答案的上限不会超过\\(2k\\)。\r\n因此，直接搜索前\\(m\\)个值即可，途中需要记录这\\(m\\)个值的和与积，这些积值不需要超过\\(2N\\)。\r\n代码\r\n# include &lt;bits/stdc++.h&gt;using namespace std;const int N=12000;const int M=log2(1e-8+N);int f[N+4];void dfs(int fl, int pre, int mul, int sum) &#123;    if (fl == M) &#123;        int t = mul - sum + M;        if (t &lt;= N)            f[t] = min(f[t], mul);        return;    &#125;    for (int i = pre; i &lt;= N &amp;&amp; mul * i &lt;= N * 2; i++)        dfs(fl + 1, i, mul * i, sum + i);&#125;int main()&#123;    memset(f,0x3f,sizeof(f));    f[2]=4;    dfs(0,1,1,0);    unordered_set&lt;int&gt;st;    for(int i=2;i&lt;=N;i++)        st.insert(f[i]);    int ans=0;    for(int x:st)        ans+=x;    printf(&quot;%d\\n&quot;,ans);&#125;\r\n","categories":["Project Euler"],"tags":["OEIS"]},{"title":"算法导论B.2 Exercises 答案","url":"/introduction-to-algorithms/appendix-b/exercises-2/","content":"\r\nB.2-1\r\n首先需要证明\\(\\subseteq\\)满足自反性，反对称性和传递性。\r\n自反性：根据子集的定义，集合\\(S\\)的子集可以是自身，即\\(S\\subseteq S\\)，因此自反性成立。\r\n反对称性：假设现在有两个集合\\(A,B\\)。关系\\(A\\subseteq B\\)意味着\\(\\forall x\\in A,x\\in B\\)成立。关系\\(B\\subseteq A\\)意味着\\(\\forall x\\in B,x\\in A\\)成立。如果\\(A\\subseteq B,B\\subseteq\r\nA\\)成立，那么说明\\(A=B\\)，因此反对称性成立。\r\n传递性：假设现在有集合\\(A,B,C\\)满足\\(A\\subseteq B,B\\subseteq\r\nC\\)，根据子集的定义，\\(\\forall x\\in\r\nA,x\\in B\\)均成立，同时\\(\\forall x\\in\r\nB,x\\in C\\)成立。由于\\(A\\)是\\(B\\)的一部分，因此有\\(\\forall x\\in A,x\\in C\\)成立，即\\(A\\subseteq C\\)。因此传递性成立。\r\n因此\\(\\subseteq\\)是偏序。\r\n考虑\\(\\mathbb{Z}\\)上的两个子集\\(A=\\{0,1\\},B\\{1,2\\}\\)。根据子集的定义，\\(A\\subseteq B,B\\subseteq\r\nA\\)均不成立。也是就说在\\(\\subseteq\\)运算上没有定义，因此\\(\\subseteq\\)不是全序。\r\nB.2-2\r\n首先需要证明这种运算满足自反性，对称性和传递性。\r\n自反性：对于所有正整数\\(a,n,a-a=0\\cdot\r\nn\\)必定成立，因此自反性成立。\r\n对称性：对于所有正整数\\(a,b,n\\)，如果存在\\(p\\)使得\\(a-b=pn\\)成立，那么就有\\(b-a=(-p)n\\)，因此对称性成立。\r\n传递性：对于所有正整数\\(a,b,c,n\\)，如果存在\\(p,q\\)使得\\(a-b=pn,b-c=qn\\)成立，那么有\\(a-c=(p+q)n\\)成立，由此构造出了一个新整数\\(p+q\\)。因此传递性成立。\r\n这一种划分，将\\(\\mathbb{Z}\\)划分成了\\(n\\)个等价类。每个等价类中的数两两都关于模\\(n\\)同余，即差值都是\\(n\\)的倍数。\r\nB.2-3\r\na\r\n\\(S=\\{1,2,3\\},R=\\{(1,1),(2,2),(3,3),(1,2),(2,1),(1,3),(3,1)\\}\\)\r\nb\r\n\\(S=\\{1,2,3\\},R=\\{(1,1),(2,2),(3,3),(1,2),(1,3),(2,3)\\}\\)\r\nc\r\n\\(S=\\{1,2,3\\},R=\\varnothing\\)\r\nB.2-4\r\n\\(R\\)是\\(S\\times S\\)上的一个等价关系，说明\\(R\\)具有对称性。\r\n对称性说明，对于所有关系\\((a,b)\\in\r\nR\\)，都有\\((b,a)\\in R\\)。\r\n现在\\(R\\)同时具有反对称性，说明对于关系\\((a,b)\\in R\\)，都有\\(a=b\\)。\r\n这说明\\(S\\)关于\\(R\\)划分出的等价类只能是单元集。\r\nB.2-5\r\n不正确。如题目B-2.3c构造出的一组关系。因为传递性和对称性的定义都是：如果\\((?,?)\\)存在，那么\\((?,?)\\)存在。而自反性则是确认\\((x,x)\\)关系都存在。\r\n","categories":["算法导论"]},{"title":"算法导论B.3 Exercises 答案","url":"/introduction-to-algorithms/appendix-b/exercises-3/","content":"\r\nB.3-1\r\na\r\n由于函数\\(f\\)是单射的，那么对于\\(a\\neq a&#39;,f(a)\\neq\r\nf(a&#39;)\\)均成立。因此\\(|A|=|f(A)|\\)，\\(f(A)\\)是值域。对于陪域\\(B\\)，\r\n\r\n如果\\(\\exists y\\in B,\\nexists x\\in\r\nA\\)使得\\(y=f(x)\\)，那么说明\\(|f(A)|&lt;|B|\\)。\r\n否则，说明\\(|f(A)|=|B|\\)。\r\n\r\n最终有\\(|A|\\le |B|\\)。\r\nb\r\n由于函数\\(f\\)是满射的，那么对于\\(\\forall y \\in B,\\exists x \\in\r\nA,y=f(x)\\)成立。因此\\(|B|=|f(A)|\\)。对于定义域\\(A\\)，\r\n\r\n如果\\(\\exists x,x&#39;\\in A,x&#39;\\neq\r\nx,f(x)=f(x&#39;)\\)，那么说明\\(|A|&gt;|f(A)|\\)。\r\n否则，说明\\(|A|=|f(A)|\\)。\r\n\r\n最终有\\(|A|\\ge |B|\\)。\r\nB.3-2\r\n\\(f(x)=x+1\\)不是从\\(\\mathbb{N}\\)到\\(\\mathbb{N}\\)的满射，因为存在\\(0\\in \\mathbb{N}\\)，无法找到\\(x\\in \\mathbb{N}\\)使得\\(x+1=0\\)。但它是从\\(\\mathbb{Z}\\)到\\(\\mathbb{Z}\\)的满射。\r\nB.3-3\r\n给定一个二元关系\\(R\\)，那么可以定义\\((a,b)\\in R^{-1}\\)当且仅当\\((b,a)\\in R\\)。并且二元关系\\(R,R&#39;\\)的定义域和值域恰好是交换后的。\r\n\\(\\star\\)\r\nB.3-4\r\n考虑将\\(\\mathbb{Z\\times\r\nZ}\\)视为平面直角坐标系上的点，那么可以如下设计映射\\(f:\\mathbb{Z\\rightarrow Z\\times Z}\\)。\r\n假设\\(f(0)=(0,0)\\)。那么一开始先往上走\\(1\\)步，再往右走\\(1\\)步，接下来往下走\\(3\\)步，再往左走\\(3\\)步，再往上走\\(5\\)步……那么\\(\\mathbb{Z}\\)对应的是步数，\\(\\mathbb{Z\\times Z}\\)则是走到的顶点。\r\n\r\n如果对应的步数是负数，那么仅需要将点\\((x,y)\\)中心对称到\\((-x,-y)\\)则是所求的点。\r\n通过这个过程不难发现，映射\\(f\\)中，点和步数是一一对应的，也就是双射的。\r\n","categories":["算法导论"]},{"title":"算法导论B.4 Exercises 答案","url":"/introduction-to-algorithms/appendix-b/exercises-4/","content":"\r\nB.4-1\r\n假设有函数\\(f(u,v)\\)如下：如果\\(u\\)和\\(v\\)握过手，那么\\(f(u,v)=1\\)，否则\\(f(u,v)=0\\)。\r\n握手关系是对称的，不难发现\\(f(u,v)=f(v,u)\\)，因此\\(f(u,v)+f(v,u)\\in\\{0,2\\}\\)。\r\n因此有\\(\\displaystyle{\\sum_{u=1}^n\\sum_{v=1}^nf(u,v)=2|E|}\\)。\r\n根据度数的定义，有\\(\\displaystyle{\\text{degree}(u)=\\sum_{v=1}^n\r\nf(u,v)}\\)。\r\n那么最终有：\r\n\\[\\sum_{u=1}^n\r\n\\text{degree}(u)=\\sum_{u=1}^n\\sum_{v=1}^n f(u,v)=2|E|\\]\r\nB.4-2\r\n假设顶点\\(u,v\\)之间存在路径\\(\\langle v_0,v_1,v_2,\\dots,v_k\r\n\\rangle\\)，其中\\(v_0=u,v_k=v\\)，那么：\r\n如果\\(\\exists i,j,0\\le i&lt; j\\le\r\nk,v_i=v_j\\)成立，那么可以通过一次操作构造出一条新的路径：\r\n\\(\\langle\r\nv_0,v_1,v_2,\\dots,v_{i-1},v_{\\mathbf{i}},v_{\\mathbf{j+1}},v_{j+2},\\dots,,v_k\r\n\\rangle\\)\r\n可以发现，这条新路径的长度比原来缩短了\\(j-i\\)。由于路径长度的长度总是有限的，因此经过有限次操作后，将有\\(\\nexists i,j,0\\le i&lt; j\\le\r\nk,v_i=v_j\\)。那么此时也就获得了一条顶点\\(u,v\\)之间的简单路径。\r\n类似的，如果有向图中存在环\\(\\langle\r\nv_0,v_1,v_2,\\dots,v_k \\rangle\\)，其中\\(v_0=v_k\\)，那么：\r\n\r\n如果\\(\\exists i,0&lt; i&lt;\r\nk,v_i=v_0\\)成立，那么可以构造出一个新的环：\r\n\\(\\langle v_0,v_1,v_2,\\dots,v_{\\mathbf{i}}\r\n\\rangle\\)\r\n可以发现，这个新环的长度比原来缩短了\\(k-i\\)。\r\n否则，如果\\(\\exists i,j,0&lt; i&lt;\r\nj&lt; k,v_i=v_j\\)成立，那么可以构造出一个新的环：\r\n\\(\\langle\r\nv_0,v_1,v_2,\\dots,v_{i-1},v_{\\mathbf{i}},v_{\\mathbf{j+1}},v_{j+2},\\dots,,v_k\r\n\\rangle\\)\r\n可以发现，这个新环的长度比原来缩短了\\(j-i\\)。\r\n\r\n同样，由于环的长度也是有限的，因此经过有限次操作后，以上的两个如果将不复存在，那么也就得到了一个简单环。\r\nB.4-3\r\n考虑使用数学归纳法证明。\r\n假设\\(|V|=n\\)。\r\n当\\(n=1\\)时，图中不需要任何边即为连通图，因此\\(|E|\\ge |V|-1\\)成立。\r\n当\\(n&gt;1\\)时，假设此图\\(G=(V,E)\\)已经满足\\(|E|\\ge |V|-1\\)，那么考虑新图\\(G&#39;=(V\\cup\r\n\\{v_{n+1}\\},E)\\)，那么发现\\(G&#39;\\)并非是连通的。要使得\\(G&#39;\\)联通，必须要在顶点集\\(|V|\\)中，指定至少一个顶点与\\(v_{n+1}\\)关联。因此有\\(|E|+1\\ge\r\n|V+\\{v_{n+1}\\}|-1\\)成立，指定的定点数为新添加的边数。那么添加了新边后，边集\\(E&#39;\\)有\\(|E&#39;|\\ge |E|+1\\)。\r\n令\\(V&#39;=V\\cup\r\n\\{v_{n+1}\\}\\)，那么性质\\(|E&#39;|\\ge\r\n|V&#39;|-1\\)仍然保持。\r\nB.4-4\r\n首先需要证明这种“可达”关系满足自反性，对称性和传递性。\r\n自反性：对于任意一个节点，它肯定存在长度为\\(0\\)的路径（从自己走到自己）。因此满足自反性。\r\n对称性：如果从\\(u\\)到\\(v\\)存在可达路径\\(\\langle u,v_1,v_2,\\dots,v\r\n\\rangle\\)，那么从\\(v\\)到\\(u\\)也存在可达路径\\(\\langle v,v_k,v_{k-1},\\dots,u\r\n\\rangle\\)。因此满足对称性。\r\n传递性：如果从\\(u\\)到\\(v\\)存在可达路径\\(\\langle u,v_1,v_2,\\dots,v\r\n\\rangle\\)，并且从\\(v\\)到\\(w\\)存在可达路径\\(\\langle v,v_1&#39;,v_2&#39;,\\dots,w\r\n\\rangle\\)，那么从\\(u\\)到\\(w\\)也存在可达路径\\(\\langle u,v_1,v_2,\\dots,v\r\n,v_1&#39;,v_2&#39;,\\dots,w\\rangle\\)。因此满足传递性。\r\n因此，“可达”关系对于图中的顶点是等价关系。\r\n自反性，对称性和传递性都需要满足。\r\nB.4-5\r\n\r\nB.4-6\r\n假设超图的顶点集合为\\(V\\)，超边集合为\\(E\\)，考虑构造一个新图\\(G=(V\\cup\r\nE,E&#39;)\\)。那么对于任何一条超边\\(e\\in\r\nE\\)和任意一个节点\\(v \\in V,(v,e)\\in\r\nE&#39;\\)当且仅当节点\\(v\\)被\\(e\\)所关联。\r\n那么根据题目中对这个点和边关联的定义，\\(\\nexists v_1,v_2\\in V,(v_1,v_2)\\in E&#39;,\\nexists\r\ne_1,e_2\\in E,(e_1,e_2)\\in E&#39;\\)。因此\\(G\\)中的所有节点可以划分成两部分：\\(V\\)和\\(E\\)。故\\(G\\)是一个二分图。\r\n","categories":["算法导论"]},{"title":"算法导论B.1 Exercises 答案","url":"/introduction-to-algorithms/appendix-b/exercises-1/","content":"\r\nB.1-1\r\n\r\nB.1-2\r\n考虑使用数学归纳法进行证明。\r\n已知两个集合下的德摩根律\\(\\overline{B\\cap\r\nC}=\\overline{B}\\cup\\overline{C},\\overline{B\\cup C}=\\overline{B}\\cap\r\n\\overline{C}\\)是成立的。\r\n那么假设\\(\\overline{A_1\\cap\r\nA_2\\cap\\dots\\cap  A_n}=\\overline{A_1}\\cup\\overline{A_2}\\cup\\dots\\cup\\overline{A_n}\\)成立，考虑如下等式：\r\n\\(\\begin{aligned}\r\n\\overline{A_1\\cap A_2\\cap\\dots\\cap A_n\\cap\r\nA_{n+1}}&amp;=\\overline{(A_1\\cap A_2\\cap\\dots\\cap A_n)\\cap A_{n+1}}\\\\\r\n&amp;=\\overline{A_1\\cap A_2\\cap\\dots\\cap A_n}\\cup \\overline{A_{n+1}}\\\\\r\n&amp;=\\overline{A_1}\\cup\\overline{A_2}\\cup\\dots\\cup\\overline{A_n}\\cup\r\n\\overline{A_{n+1}}\r\n\\end{aligned}\\)\r\n因此对于\\(n+1\\)的情况成立。\r\n假设\\(\\overline{A_1\\cup\r\nA_2\\cup\\dots\\cup  A_n}=\\overline{A_1}\\cap\\overline{A_2}\\cap\\dots\\cap\\overline{A_n}\\)成立，考虑如下等式：\r\n\\(\\begin{aligned}\r\n\\overline{A_1\\cup A_2\\cup\\dots\\cup A_n\\cup\r\nA_{n+1}}&amp;=\\overline{(A_1\\cup A_2\\cup\\dots\\cup A_n)\\cup A_{n+1}}\\\\\r\n&amp;=\\overline{A_1\\cup A_2\\cup\\dots\\cup A_n}\\cap \\overline{A_{n+1}}\\\\\r\n&amp;=\\overline{A_1}\\cap\\overline{A_2}\\cap\\dots\\cap\\overline{A_n}\\cap\r\n\\overline{A_{n+1}}\r\n\\end{aligned}\\)\r\n因此对于\\(n+1\\)的情况同样也成立。\r\n\\(\\star\\)\r\nB.1-3\r\n此处使用一个临时符号\\(\\mathbb{N}_n^+\\)表示正整数集合\\(\\{1,2,3,\\dots,n\\}\\)。\r\n考虑使用数学归纳法证明这个定理。\r\n当\\(n=2\\)时，容斥原理\\(|A_1\\cup A_2|=|A_1|+|A_2|-|A_1\\cap\r\nA_2|\\)成立。\r\n当\\(n&gt;1\\)时，假设\\(n-1\\)的情况成立，也就是有：\r\n\\(\\displaystyle{\\left |\\bigcup_{i=1}^{n-1}\r\nA_i\\right|=\\sum_{S \\subseteq \\mathbb{N}_{n-1}^+,S\\neq \\varnothing}\r\n(-1)^{|S|+1}\\cdot \\left|\\bigcap_{i\\in S}A_i\\right|}\\)\r\n现在考虑证明\\(n\\)的情况，那么有\r\n\\(\\begin{aligned}\r\n\\left |\\bigcup_{i=1}^{n} A_i\\right|&amp;=\\left\r\n|\\left(\\bigcup_{i=1}^{n-1} A_i\\right) \\cup A_n\\right|\\\\\r\n&amp;=\\left |\\bigcup_{i=1}^{n-1} A_i\\right|+|A_n|-\\left\r\n|\\left(\\bigcup_{i=1}^{n-1} A_i\\right) \\cap A_n\\right|\\\\\r\n&amp;=\\left |\\bigcup_{i=1}^{n-1} A_i\\right|+|A_n|-\\left\r\n|\\bigcup_{i=1}^{n-1} (A_i \\cap A_n)\\right|&amp;\\qquad(A)\\\\\r\n&amp;=\\sum_{S \\subseteq \\mathbb{N}_{n-1}^+,S\\neq \\varnothing}\r\n(-1)^{|S|+1}\\cdot \\left|\\bigcap_{i\\in S}A_i\\right|+|A_n|-\\sum_{S\r\n\\subseteq \\mathbb{N}_{n-1}^+,S\\neq \\varnothing} (-1)^{|S|+1}\\cdot\r\n\\left|\\bigcap_{i\\in S\\cup\\{n\\}}A_i\\right|&amp;\\\\\r\n&amp;=\\sum_{S \\subseteq \\mathbb{N}_{n-1}^+,S\\neq \\varnothing}\\left(\r\n(-1)^{|S|+1}\\cdot \\left|\\bigcap_{i\\in S}A_i\\right|+ (-1)^{|S|+1+1}\\cdot\r\n\\left|\\bigcap_{i\\in S\\cup\\{n\\}}A_i\\right|\\right) +|A_n|\\\\\r\n&amp;=\\sum_{S \\subseteq \\mathbb{N}_{n}^+,S\\neq \\varnothing,S\\neq\r\n\\{n\\}}\\left( (-1)^{|S|+1}\\cdot \\left|\\bigcap_{i\\in S}A_i\\right|\\right)\r\n+|A_n|&amp;\\qquad(B)\\\\\r\n&amp;=\\sum_{S \\subseteq \\mathbb{N}_{n}^+,S\\neq \\varnothing}\r\n(-1)^{|S|+1}\\cdot \\left|\\bigcap_{i\\in S}A_i\\right|\r\n\\end{aligned}\\)\r\n因此\\(n\\)的情况也成立。\r\n其中，步骤\\((A)\\)使用了分配律，步骤\\((B)\\)则是将\\(\\mathbb{N}_{n-1}^{+}\\)的所有非空子集，都添加上一个元素\\(n\\)后，和原来的\\(\\mathbb{N}_{n-1}^{+}\\)的所有非空子集，共同组成\\(\\mathbb{N}_{n}^{+}\\)的所有非空子集（除了集合\\(\\{n\\}\\)）。\r\nB.1-4\r\n假设奇数集合是\\(O\\)，那么定义一个从集合\\(\\mathbb{Z}\\)到\\(O\\)的映射\\(f(k)\\)：\r\n\\(f(k)=2k+1\\)\r\n在集合\\(\\mathbb{Z}\\)中的每个元素恰好能映射到\\(O\\)中的每个元素。由于集合\\(\\mathbb{Z}\\)是可数的，因此集合\\(O\\)也是可数的。\r\nB.1-5\r\n对于一个集合\\(S\\)中的任何元素\\(x\\)，它在\\(S\\)的每一个子集中，都存在\\(2\\)个选择：出现在这个子集，或者是不出现在这个子集。\r\n对于集合\\(S\\)中的\\(|S|\\)个元素，它们都有着平等的选择。只要存在一个元素的选择不一样，那么最终产生的子集也不一样。因此，\\(S\\)的幂集的大小为\\(2^{|S|}\\)。\r\nB.1-6\r\n当\\(n=1\\)时，元组\\(b_1=(a_1)\\)。\r\n当\\(n&gt;1\\)时，元组\\(b_{n-1}=(a_1,a_2,\\dots,a_{n-1})\\)已经定义，在\\(b_{n-1}\\)后面再多添加一个元素\\(a_n\\)即可形成\\(b_n\\)，即\r\n\\(b_n=(b_{n-1},a_n)=((a_1,a_2,\\dots,a_{n-1}),a_n)=(a_1,a_2,\\dots,a_{n-1},a_n)\\)\r\n","categories":["算法导论"]},{"title":"算法导论B.5 Exercises 答案","url":"/introduction-to-algorithms/appendix-b/exercises-5/","content":"\r\nB.5-1\r\n自由树和以\\(x\\)为根的有根树如下：\r\n\r\n以\\(x\\)为根的有序树如下：\r\n\r\n以\\(x\\)为根的二叉树如下：\r\n\r\nB.5-2\r\n由于存在\\(v_0\\in V,\\forall v \\in\r\nV\\)，\\(v_0\\)到\\(v\\)都存在路径。因此\\(G\\)的无向图版本\\(G&#39;\\)是一个连通图。\r\n考虑使用反证法证明这是一棵树。假设\\(G&#39;\\)中存在一个环\\(\\langle\r\nu_0,u_1,\\dots,u_i,u_{i+1},\\dots,u_k\\rangle\\)，其中\\(u_0=u_k=u,u\\in V\\)。\r\n那么，由于\\(G\\)是DAG，从\\(v_0\\)到\\(u\\)将有一条路径。那么同样的，从\\(v_0\\)到\\(v_i,v_{i+1}\\)都有各自的路径。\r\n\r\n如图，虚线箭头\\(u\\rightarrow\r\nv\\)表示这\\(u\\)从\\(v\\)有路径可达，实线箭头则意味着有一条有向边从\\(u\\)到\\(v\\)。\r\n由于无向图\\(G&#39;\\)存在环，考虑为边\\((u_i,u_{i+1})\\)标记上箭头。可见，如果标记的是\\(u_{i+1}\\rightarrow u_i\\)，那么从\\(u\\)到\\(u_i\\)存在两条有向路径\\(\\langle\r\nv_0,\\dots,u,u_1,\\dots,u_i\\rangle\\)和\\(\\langle\r\nv_0,\\dots,u,u_{k-1},\\dots,u_{i+1},u_i\\rangle\\)，违反了路径中的唯一性；反之亦然。\r\n因此，这个连通图\\(G\\)不应该存在环，因此\\(G\\)是一棵树。\r\nB.5-3\r\n\r\n假设\\(F(T)\\)是二叉树\\(T\\)中的\\(2\\)度节点数，\\(G(T)\\)是二叉树\\(T\\)的叶子节点数。那么问题转化成证明对于所有二叉树\\(T\\)，都有\\(F(T)=G(T)-1\\)。\r\n考虑只有一个节点的树\\(O\\)，那么\\(F(O)=0,G(O)=1,F(O)=G(O)-1\\)成立。\r\n以下分别按照两种情况归纳：\r\n1\r\n由上图构造出来的树中，左子树\\(L\\)或者右子树\\(R\\)为空。不失一般性，假设非空的是\\(L\\)。那么新构造的树\\(T\\)中，多了一个\\(1\\)度节点\\(v_0\\)。此时\\(F(T)=F(L),G(T)=G(L)\\)，仍有\\(F(T)=G(T)-1\\)。\r\n2\r\n新构造出来的树中，左子树\\(L\\)或者右子树\\(R\\)都非空。那么有\\(F(L)=G(L)-1,F(R)=G(R)-1\\)。那么新构造的树\\(T\\)中，多了一个\\(2\\)度节点\\(v_0\\)。那么\\(F(T)=F(L)+F(R)+1,G(T)=G(L)+G(R)\\)。\r\n那么有：\r\n\\(F(T)=F(L)+F(R)+1=G(L)-1+G(R)-1+1=G(L)+G(R)-1=G(T)-1\\)。\r\n因此原结论成立。\r\n假设\\(I(T)\\)是满二叉树\\(T\\)的内部节点数，\\(J(T)\\)是满二叉树\\(T\\)的叶子节点数。那么问题转化成证明对于所有满二叉树\\(T\\)，都有\\(I(T)=J(T)-1\\)。\r\n考虑只有一个节点的树\\(O\\)（可以发现这是满二叉树）。那么\\(I(O)=0,J(O)=1,I(O)=J(O)-1\\)成立。\r\n如果\\(L,R\\)都是满二叉树，那么如图构造的树\\(T\\)一定也是满二叉树。\r\n目前已经满足\\(I(L)=J(L)-1,I(R)=J(R)-1\\)，考虑\\(I(T)\\)和\\(J(T)\\)的关系。\r\n不难发现，\\(v_0\\)是\\(T\\)的内部节点，因此\\(I(T)=I(L)+I(R)+1\\)。而叶子节点数直接相加即可，因此有\\(J(T)=J(L)+J(R)\\)。\r\n那么有：\r\n\\(I(T)=I(L)+I(R)+1=J(L)-1+J(R)-1+1=J(L)+J(R)-1=J(T)-1\\)。\r\n因此原结论成立。\r\nB.5-4\r\n本题将使用数学归纳法进行证明。假设构造出的\\(k\\)个叶节点的满二叉树为\\(T(k)\\)。\r\n当\\(k=1\\)时，不难发现只有\\(1\\)个节点的树为满二叉树\\(T(1)\\)，此时恰有一个叶节点。\r\n当\\(k&gt;1\\)时，假设从\\(1\\sim\r\nk-1\\)个叶节点的满二叉树都能构造出，考虑题目8.5-3中的图。令\\(L=T(1),R=T(k-1)\\)，那么节点\\(v_0\\)的度数为\\(2\\)，因此不是叶子节点。由\\(v_0,L,R\\)新构造出的树恰好维持着满二叉树的性质，并且有\\(1+(k-1)=k\\)个叶子节点。这颗新构造出来的满二叉树即为\\(T(k)\\)。\r\nB.5-5\r\n令\\(h(n)\\)为有\\(n\\)个节点的二叉树的高度的下界。也就是说，目标是证明\\(h(n)\\ge\\lfloor \\lg n\\rfloor\\)。\r\n可以发现对于\\(n&gt;1\\)，\\(h(n)\\ge\r\nh(n-1)\\)必定成立。因为节点数越多，数的深度的下界肯定越高。\r\n当树只有\\(n=1,2\\)个节点时，树的高度为恰好为\\(\\lg n\\)，原结论成立。\r\n假设对于\\(\\forall i,1\\le i\\le\r\nn\\)，原结论均成立。考虑\\(n+1\\)个节点时的树。\r\n当\\(n+1\\)不是\\(2\\)次幂时，有\\(\\lfloor \\lg n\\rfloor=\\lfloor \\lg\r\n(n+1)\\rfloor\\)。那么\\(h(n+1)\\ge h(n)\\ge\r\n\\lfloor \\lg n\\rfloor=\\lfloor \\lg (n+1)\\rfloor\\)。证明结束。\r\n否则，假设左子树有\\(k\\)个节点，那么右子树有\\((n+1)-1-k=n-k\\)个节点。\r\n那么按照题目8.5-3中的图，可以得到，\\(\\forall 1\\le k&lt; n,h(n+1)\\ge\r\n\\max(h(k),h(n-k))+1\\)成立。即：\r\n\\[h(n+1)\\ge\r\n\\min_{k=1}^{n-1}\\{\\max(h(k),h(n-k))+1\\}\\]\r\n那么当\\(k=(n+1)/2\\)时，上面的最小值能够取到。因此有\\(h(n+1)\\ge h((n+1)/2)+1 \\ge \\lfloor\\lg\r\n(n+1)-1\\rfloor+1\\ge\r\n\\lfloor\\lg(n+1)\\rfloor\\)。原结论成立，证明结束。\r\n\\(\\star\\)\r\nB.5-6\r\n本题将使用数学归纳法进行证明。\r\n假设\\(I(T)\\)是满二叉树\\(T\\)的内部节点数，\\(J(T)\\)是满二叉树\\(T\\)的叶子节点数，\\(i(T)\\)为树的内部路径，\\(e(T)\\)为树的外部路径。那么原结论化为，证明对于所有的满二叉树\\(T\\)，都有\\(i(T)-e(T)=2I(T)\\)。\r\n考虑只有一个节点的树\\(O\\)（可以发现这是满二叉树）。有\\(i(O)=e(O)=I(O)=0\\)，因此\\(i(O)-e(O)=2I(O)\\)成立。\r\n如题目8.5-3中的图所示，如果\\(L,R\\)都是满二叉树，那么构造的树\\(T\\)一定也是满二叉树。注意到，当\\(T\\)如此被构造后，原来属于子树\\(L,R\\)中所有节点的深度都增加了\\(1\\)。并且都满足\\(i(L)-e(L)=2I(L),i(R)-e(R)=2I(R)\\)。\r\n那么根据\\(i\\)的定义可以写出\\(i(T)=i(L)+i(R)+I(L)+I(R)\\)。注意后面两项产生的原因是：由于\\(T\\)构造出来后，左子树的\\(I(L)\\)个内部节点和右子树的\\(I(R)\\)个节点深度都增加了\\(1\\)。\r\n类似的，根据\\(e\\)的定义，可以写出\\(e(T)=e(L)+e(R)+J(L)+J(R)\\)。\r\n那么有：\r\n\\(\\begin{aligned}\r\ni(T)-e(T)&amp;=e(L)-i(L)+e(R)-i(R)+J(L)-I(L)+J(R)-I(R)\\\\\r\n&amp;=(e(L)-i(L))+(e(R)-i(R))+(J(L)-I(L))+(J(R)-I(R))\\\\\r\n&amp;=2I(L)+2I(R)+1+1&amp;\\qquad(A)\\\\\r\n&amp;=2(I(L)+2I(R)+1)\\\\\r\n&amp;=2I(T)&amp;\\qquad(B)\r\n\\end{aligned}\\)\r\n变换\\((A)\\)使用了题目8.5-3中的结论：\\(J(T)-I(T)=1\\)。对于变换\\((B)\\)，由于\\(v_0\\)是\\(T\\)的内部节点，因此\\(I(T)=I(L)+I(R)+1\\)。\r\n原结论成立。\r\n\\(\\star\\)\r\nB.5-7\r\n本题将使用数学归纳法进行证明。\r\n为方便描述，令\\(l(T)\\)表示树\\(T\\)中的所有叶节点。那么本题的目标则是证明\\(\\displaystyle{\\sum_{x \\in l(T)}\r\nw(x)\\le1}\\)。\r\n考虑一棵空树\\(E\\)，没有叶节点。因此\\(\\displaystyle{\\sum_{x \\in l(E)} w(x) =\r\n0\\le1}\\)，原结论成立。\r\n考虑一棵只有一个节点的树\\(O\\)，恰好有一个叶节点。因此\\(\\displaystyle{\\sum_{x \\in l(O)} w(x) =\r\n1\\le1}\\)，原结论成立。\r\n如题目8.5-3中的图所示，假设子树\\(L,R\\)都满足\\(\\displaystyle{\\sum_{x \\in l(L)} w(x) \\le1,\\sum_{x\r\n\\in l(R)} w(x) \\le1}\\)。注意到，新构造出来的树\\(T\\)中，原来属于子树\\(L,R\\)中所有节点的深度都增加了\\(1\\)。这意味着，对于\\(L,R\\)中所有的叶子节点，其新权值为旧权值的\\(\\dfrac{2^{-(d+1)}}{2^{-d}}=\\dfrac{1}{2}\\)。\r\n那么根据刚刚的假设，可以得到\\(\\displaystyle{\\sum_{x \\in l(L)} w(x) +\\sum_{x \\in\r\nl(R)} w(x) \\le2}\\)\r\n因此，有\\(\\displaystyle{\\sum_{x \\in l(T)}\r\nw(x)=\\dfrac{1}{2}\\left(\\sum_{x \\in l(L)} w(x)+\\sum_{x \\in l(L)}\r\nw(x)\\right)\\le \\dfrac{1}{2} \\cdot 2=1}\\)\r\n原结论成立。\r\n\\(\\star\\)\r\nB.5-8\r\n本题将使用反证法进行证明。\r\n假设这棵树为\\(T\\)。由于叶节点数量超过\\(2\\)。因此根据8.5-3的结论，这棵树必定存在一个内部节点\\(r\\)。考虑使用\\(r\\)节点定根，使\\(T\\)成为一棵有根树。\r\n令\\(S(u)\\)表示以\\(u\\)为根的子树中，叶节点的个数。那么按照题意有\\(S(r)=L\\)。\r\n假设不存在任何节点\\(u \\in\r\nV\\)，使得\\(\\dfrac{L}{3}\\le\r\nS(u)\\le\\dfrac{2L}{3}\\)成立。也就是说，对于所有节点\\(u\\)，要么\\(S(u)&lt;\\dfrac{L}{3}\\)，要么\\(S(u)&gt;\\dfrac{2L}{3}\\)。\r\n考虑构造树\\(T\\)中一条从根节点到某个叶子的路径\\(\\langle\r\nv_0,v_1,v_2,\\dots,v_d\\rangle\\)，其中\\(v_0=r,v_d\\)是某个叶子，即\\(S(v_d)=1\\)。对于\\(0\\le i&lt; d\\)，构造方式如下：\r\n\r\n如果\\(v_i\\)有两个子节点，设其为\\(l_i,r_i\\)。如果\\(S(l_i)\\ge S(r_i)\\)，那么\\(v_{i+1}=l_i\\)，否则\\(v_{i+1}=r_i\\)。\r\n如果\\(v_i\\)有一个子节点，那么\\(v_{i+1}\\)是\\(v_i\\)的那个唯一一个子节点。\r\n\r\n那么按照这个构造方式，\\(\\forall 0\\le i&lt;\r\nd,\\dfrac{S(v_{i+1})}{S(v_i)}\\ge\r\n\\dfrac{1}{2}\\)都成立。因此序列\\(\\{S(v_i)\\}\\)是一个不递减序列。\r\n考虑自顶向下遍历这条路径。如果当前节点\\(v_i\\)满足\\(\\dfrac{L}{3}\\le\r\nS(v_i)\\le\\dfrac{2L}{3}\\)，那么\\(v_i\\)为所求节点，证明结束。否则，如果存在某个\\(j,0&lt;j&lt;d\\)，使得\\(S(v_j)&gt;\\dfrac{2L}{3},S(v_{j+1})&lt;\\dfrac{L}{3}\\)成立，那么得到\\(\\dfrac{S(v_{j+1})}{S(v_j)}&lt;\r\n\\dfrac{1}{2}\\)，与构造的\\(\\{S(v_i)\\}\\)序列的性质矛盾。\r\n因此原结论成立。\r\n","categories":["算法导论"]},{"title":"算法导论B Problems 答案","url":"/introduction-to-algorithms/appendix-b/problems/","content":"\r\nB-1\r\na\r\n考虑使用数学归纳法证明。\r\n当\\(n=1\\)时，只有一个节点的树肯定是\\(2\\)可着色的。\r\n当\\(n&gt;1\\)时，假设对于\\(k=1,2,\\dots,n-1\\)个节点的树都是\\(2\\)可着色的。考虑将第\\(n\\)个节点\\(v_n\\)和树中的任意一个节点\\(v\\)相连，那么只需要给\\(v_n\\)染成\\(c(v_n)=1-c(v)\\)即可，\\(2\\)可着色的性质仍然保持。\r\n因此，原结论成立。\r\nb\r\n1→2\r\n由于图\\(G\\)是一个二分图，因此可以将图\\(G=(V,E)\\)中的所有点分成两个集合\\(V_0,V_1\\)，使得\\((u,v)\\in E\\)当且仅当\\(u\\in V_0,v\\in V_1\\)或者是\\(u\\in V_1,v\\in V_0\\)。因此点集\\(V_0,V_1\\)中的点两两之间没有边，令\\(\\forall u \\in V_0,c(u)=0,\\forall v \\in\r\nV_1,c(v)=1\\)。那么这个图就是\\(2\\)可染色的。\r\n2→3\r\n考虑证明逆否命题成立：如果它存在奇数环，那么它不是\\(2\\)可着色的。\r\n假设这个环是\\(v_0,v_1,v_2,v_3,\\dots,v_{2k-1},v_{2k},v_0\\)。这个环的长度为\\(2k+1\\)，这一个序列的长度为\\(2k+2\\)。这个序列首位相接，序列的\\(c(v_0)\\)都是同一个数。按照\\(2\\)可染色的定义，有\\(c(v_0)\\neq c(v_1),c(v_1)\\neq\r\nc(v_2),\\dots\\)都成立。同时有\\(\\dots,c(v_{2k-1})\\neq c(v_{2k}),c(v_{2k})\\neq\r\nc(v_0)\\)成立。因此，\\(c(v_1)=c(v_{2k}),c(v_2)=c(v_{2k-1}),\\dots\\)，最终发现有\\(c(v_k)=c(v_{k+1})\\)，即说明这相邻两个点\\(v_k,v_{k+1}\\)同时染上了同一种颜色，因此这个图不是\\(2\\)可着色的。\r\n因此，原命题成立。\r\n3→1\r\n如果图\\(G=(V,E)\\)没有环，那么\\(G\\)就是一个森林。森林是树的子集，因此森林肯定是一个二分图。\r\n如果图\\(G=(V,E)\\)仅存在偶环。\r\n假设图\\(G\\)如果存在环，那么也只能存在偶数环。遍历图\\(G=(V,E)\\)中的每个连通分量\\(C\\)，假设\\(C\\)中存在一个点\\(v_0\\)，令\\(d(v)\\)为在连通分量\\(C\\)下的点\\(v\\)与\\(v_9\\)的最短距离。并且令\\(c(v)=d(v)\\bmod 2\\)。如果\\(G\\)的两个相同颜色顶点有边，也就是说，\\(\\exists x,y \\in\r\nV_C,c(x)=c(y)\\)，那么路径\\(v_0\\rightarrow x\\rightarrow y\\rightarrow\r\nv_0\\)是一个奇数环。否则\\(\\forall v\\in\r\nV,c(v)=i\\Leftrightarrow v\\in V_i\\)，那么我们找到了一个点集\\(V_0,V_1\\)，它是一个二分图。\r\n最终，这\\(3\\)个条件都是等价的。\r\nc\r\n考虑使用数学归纳法进行证明。\r\n命题：一个\\(n\\)个节点的图某个顶点最大度数为\\(k\\)，那么这个图是\\(k+1\\)可着色的。\r\n当\\(n=k+1\\)时，假设这个\\(n\\)个节点的图中至少有一个节点的度数为\\(k\\)。这时可以用\\(k+1\\)种不同的颜色分别为这\\(n\\)个节点涂上\\(k+1\\)种不同的颜色。\r\n当\\(n&gt;k+1\\)时，假设当\\(n&#39;=k+1,k+2,\\dots,n\\)时，原结论都成立。考虑一个\\(n+1\\)个节点的图\\(G_{n+1}\\)，其最大的顶点度数仍然为\\(k\\)。删去一个特定的节点\\(v\\)，及其关联所有的边后，得到的图\\(G_n\\)有\\(n\\)个节点，最大顶点度数仍然不会超过\\(k\\)。根据假设，可以知道\\(G_n\\)存在一个\\(k+1\\)染色方案。现在补上这个节点\\(v\\)后，这个节点的度数最多为\\(k\\)，\\(v\\)关联的节点最多有\\(k\\)个，而我们现在有\\(k+1\\)种颜色可以对这个节点染上颜色，只需要选择一种和\\(v\\)关联的节点都不一样的颜色即可。故\\(G_{n+1}\\)也存在一种染色方案。\r\n因此原结论成立。\r\nd\r\n本题参考了本页面的解释。\r\n假设一个图\\(G=(V,E)\\)中，度数至少为\\(\\sqrt{|E|}\\)的节点集合为\\(V&#39;\\)。通过握手定理，可以得到有至少\\(\\dfrac{|V&#39;|\\sqrt{|E|}}{2}\\)条边关联了\\(V&#39;\\)中的节点。那么可以得到\\(\\dfrac{|V&#39;|\\sqrt{|E|}}{2}\\le\r\n|E|\\)，即\\(|V&#39;|\\le\r\n2\\sqrt{|E|}\\)。因此，我们可以先将\\(V&#39;\\)里的节点染上\\(|V&#39;|=O(\\sqrt{|E|})=O(\\sqrt{|V|})\\)种不同的颜色。\r\n那么接下来将\\(G\\)中的\\(V&#39;\\)中的所有节点及其有所关联的边全部删去，得到\\(G\\)的子图\\(G&#39;=(V-V&#39;,E&#39;)\\)。可以发现，\\(G&#39;\\)的最大节点度数至多为\\(\\sqrt{|E|}\\)。根据题目B-1-c，\\(G&#39;\\)是\\(\\sqrt{|E|}+1=O(\\sqrt{|V|})\\)可染色的。\r\n在这两轮上色都使用不同的颜色，但是它们的数量级都是\\(O(\\sqrt{|V|})\\)。因此图\\(G\\)可以用\\(O(\\sqrt{|V|})\\)中颜色进行染色。\r\nB-2\r\na\r\n对于\\(G=(V,E),|V|\\ge 2\\)，\\(\\exists u,v\\in V,u\\neq\r\nv,\\text{degree}(u)=\\text{degree}(v)\\)。\r\n证明：使用反证法证明。\r\n由于度数的取值范围是\\(0,1,\\dots,|V|-1\\)，恰好只有\\(|V|\\)个不同取值。存在一个图的度数序列是\\(0,1,\\dots,|V|-1\\)的排列，那么将会产生一对矛盾的节点：度数为\\(0\\)的节点\\(u\\)和度数为\\(|V|-1\\)的节点\\(v\\)。如果这对节点相邻，那么\\(u\\)的度数不为\\(0\\)，否则\\(v\\)的度数不为\\(|V|-1\\)。\r\n因此原结论成立。\r\nb\r\n对于\\(\\forall\r\nG=(V,E),|V|=6\\)，总存在三个不同节点\\(u,v,w\\in\r\nV\\)，使得以下其中一条结论必定成立：\r\n\r\n\\((u,v)\\in E\\land(u,w)\\in\r\nE\\land(v,w)\\in E\\)\r\n\\((u,v)\\not\\in E\\land(u,w)\\not\\in\r\nE\\land(v,w)\\not\\in E\\)\r\n\r\n证明：\r\n考虑一个完全图\\(G=(V,E&#39;)\\)。如果\\((u,v)\\in E\\)，那么\\((u,v)\\)在\\(G&#39;\\)中染成红色，否则染成蓝色，那么转化为这个完全图中必定存在一个同色三角形，即\\((u,v),(u,w),(v,w)\\)染上的是同一种颜色。\r\n对于任意\\(u\\in\r\nV\\)，根据抽屉原理，\\(v\\)的度数为\\(5\\)，那么和\\(v\\)关联的边至少\\(3\\)是同色的。因此不失一般性，假设\\((u,a),(u,b),(u,c)\\)这三条边是同色的。考虑\\(3\\)条边\\((a,b),(b,c),(a,c)\\)的颜色。如果这\\(3\\)条边的颜色和\\((u,a)\\)的颜色都不相同，那么说明\\((a,b),(b,c),(a,c)\\)这三条边构成同色三角形，原结论成立；否则，如果存在一条边（假设是\\((a,b)\\)）和\\((u,a)\\)颜色相同，那么说明\\((a,b),(u,a),(u,b)\\)这三条边构成同色三角形，原结论依然成立。\r\n因此最终结论成立。\r\nc\r\n对于无向图\\(G=(V,E)\\)，可以将\\(V\\)划分成两组\\(V_0,V_1\\)，满足：\\(\\forall v\\in v_x,x\\in\\{0,1\\}\\)，节点\\(v\\)的至少一半邻居在集合\\(V_{1-x}\\)。\r\n证明：\r\n一开始，先将\\(V\\)任意划分成两部分\\(V_0,V_1\\)。令集合\\(E&#39;=\\{(u,v)\\mid (u,v)\\in E,\\exists x\\in\r\n\\{0,1\\},u\\in V_x,v\\in\r\nV_{1-x}\\}\\)。接下来的过程需要动态维护集合\\(S\\)。\r\n对于任意\\(v\\in V_0\\)，如果发现\\(v\\)在\\(V_0\\)的邻居多于\\(V_1\\)，那么可以将\\(v\\)从\\(V_0\\)转移到\\(V_1\\)，这将会时集合\\(E&#39;\\)的大小严格增加。否则说明\\(v\\)满足条件，不需要移动。类似的，对\\(v\\in\r\nV_1\\)也进行类似的操作，这同样会使得集合\\(E&#39;\\)的大小严格增加。\r\n由于集合\\(E&#39;\\subseteq\r\nE\\)的大小是有限的。因此，这个过程将会在有限次之后停下。最终的划分将会使两个集合中的所有节点满足条件。\r\nd\r\n对于无向图\\(G=(V,E),|V|\\ge 3,\\forall v \\in\r\nV,2\\cdot\\text{degree}(v)\\ge |V|\\)均成立。那么图\\(G\\)存在一个长度为\\(|V|\\)的简单环\\(v_0,v_1,v_2,\\dots,v_{|V|-2},v_{|V|-1},v_0\\)，也就是每一个节点都经过恰好一次的环。这个定理是Dirac定理，这个环是\\(G\\)的哈密顿回路。\r\n证明：\r\n假设图\\(G=(V,E)\\)满足条件。那么首先证明\\(G\\)是连通图，这个使用反证法证明。对于特定的\\(2\\)个点\\(u,v\\)，假设它们之间没有边，并且\\(u\\)和\\(v\\)没有连通，属于两个不同的连通块。那么这个图至少有\\((\\text{degree}(u)+1)+(\\text{degree}(v)+1)=2+|V|&gt;|V|\\)个点。这是不可能的，因此图\\(G\\)必定是连通图。\r\n假设路径\\(v_1,v_2,\\dots,v_{k-1},v_k\\)是图中\\(G\\)的最长简单通路\\(P\\)，并且首尾已经不能继续延长。那么说明，\\(v_1\\)的至少\\(|V|/2\\)个的邻居都在\\(v_2,v_3,\\dots,v_{k-1},v_k\\)中；同样的，\\(v_k\\)的至少\\(|V|/2\\)个的邻居都在\\(v_1,v_2,\\dots,v_{k-2},v_{k-1}\\)中。也就是说，存在至少\\(|V|\\)个不同的\\(i\\)，使得\\((v_0,v_{i+1})\\in E\\)。那么由于\\((\\text{degree}(v_1)+1)+(\\text{degree}(v_k)+1)=2+|V|&gt;|V|\\ge\r\nk\\)，因此根据抽屉原理，\\(\\exists\r\ni,(v_0,v_{i+1})\\in E\\land (v_i,v_k)\\in E\\)成立。那么可以将\\(P\\)转化成一个简单环\\(C\\)（如图所示）：\r\n\\(v_1,v_2,\\dots,v_i,v_k,v_{k-1},v_{k-2},\\dots,v_{i+2},v_{i+1},v_1\\)\r\n\r\n如果\\(C\\)是一个哈密顿回路（也就是\\(k=n\\)），那么证明完成。否则，由于\\(G\\)是连通图，考虑\\(v_j(j\\in [1,k])\\)和\\(v_j\\)的一个不在\\(C\\)中的邻居\\(u\\)。也就是说，\\((u,v_j)\\in E,\\nexists\r\ni\\in[1,k],v_i=u\\)。那么我们根据这个环，继续构造出一条更长的简单通路\\(P&#39;\\)，并包含\\(k+1\\)个节点：\r\n\r\n再按照上面的方式进行迭代，可以将\\(k+1\\)个节点的\\(P&#39;\\)转化成\\(C&#39;\\)。因此，最终当图中没有任何一个节点时，我们就得到了一条哈密顿回路。\r\nB-3\r\na\r\n由于只需要断掉一条边，因此假设集合\\(A\\)是这棵二叉树\\(T\\)的真子树（也就是说，\\(B\\)一定包含叶节点，非空的）。那么相当于证明：对于任意二叉树\\(T\\)，存在一棵子树\\(A\\)，其节点数满足\\(|T|-\\dfrac{3}{4}|T|\\le |A|\\le\r\n\\dfrac{3}{4}|T|\\)，即\\(\\dfrac{1}{4}|T|\\le |A|\\le\r\n\\dfrac{3}{4}|T|\\)成立。假设\\(T\\)的根节点为\\(r\\)。\r\n考虑使用反证法证明。\r\n令\\(S(u)\\)表示以\\(u\\)为根的子树中的节点个数。那么按照题意有\\(S(r)=|V|\\)。\r\n假设不存在任何节点\\(u \\in\r\nV\\)，使得\\(\\dfrac{|T|}{4}\\le\r\nS(u)\\le\\dfrac{3|T|}{4}\\)成立。也就是说，对于所有节点\\(u\\)，要么\\(S(u)&lt;\\dfrac{|T|}{4}\\)，要么\\(S(u)&gt;\\dfrac{3|T|}{4}\\)。\r\n考虑构造树\\(T\\)中一条从根节点到某个叶子的路径\\(\\langle\r\nv_0,v_1,v_2,\\dots,v_d\\rangle\\)，其中\\(v_0=r,v_d\\)是某个叶子，即\\(S(v_d)=1\\)。对于\\(0\\le i&lt; d\\)，构造方式如下：\r\n\r\n如果\\(v_i\\)有两个子节点，设其为\\(l_i,r_i\\)。如果\\(S(l_i)\\ge S(r_i)\\)，那么\\(v_{i+1}=l_i\\)，否则\\(v_{i+1}=r_i\\)。\r\n如果\\(v_i\\)有一个子节点，那么\\(v_{i+1}\\)是\\(v_i\\)的那个唯一一个子节点。\r\n\r\n那么按照这个构造方式，\\(\\forall 0\\le i&lt;\r\nd,\\dfrac{S(v_{i+1})}{S(v_i)}\\ge\r\n\\dfrac{1}{3}\\)都成立。可见，只有当\\(l_i,r_i\\)都是叶节点时，这个不等式的等号才成立。因此序列\\(\\{S(v_i)\\}\\)是一个不递减序列。\r\n考虑自顶向下遍历这条路径。如果当前节点\\(v_i\\)满足\\(\\dfrac{|T|}{4}\\le\r\nS(v_i)\\le\\dfrac{3|T|}{4}\\)，那么\\(v_i\\)为所求节点，证明结束。否则，如果存在某个\\(j,0&lt;j&lt;d\\)，使得\\(S(v_j)&gt;\\dfrac{3|T|}{4},S(v_{j+1})&lt;\\dfrac{|T|}{4}\\)成立，那么得到\\(\\dfrac{S(v_{j+1})}{S(v_j)}&lt;\r\n\\dfrac{1}{3}\\)，与构造的\\(\\{S(v_i)\\}\\)序列的性质矛盾。\r\n因此原结论成立。\r\nb\r\n构造的这棵树如图所示：\r\n\r\n无论切除哪一条边，都可以将顶点集分成一个大小为\\(1\\)。一个大小为\\(3\\)的集合，使得上述定理中的等号部分成立。\r\nc\r\n对于\\(k=0,1,2,...,n-1,n\\)，考虑证明这个定理的更一般的版本：只需要移除最多\\(O(\\lg n)\\)的边，就可以将整棵树划分成有\\(k\\)个节点和\\(n-k\\)个节点的集合。\r\n当\\(n=1\\)时，原结论显然成立。\r\n当\\(n&gt;1\\)时，假设对于\\(n&#39;=1,2,3,\\dots,n-1\\)，结论都成立。假设一开始的划分是\\(A=V,B=\\varnothing\\)。那么在每一次划分时，如果\\(|A|=k\\)，那么结束划分；当\\(|A|&gt;k\\)时，考虑对集合\\(A\\)进行划分，分走\\(|A|-k\\)个元素给\\(B\\)；当\\(|A|&lt;\r\nk\\)时，考虑对集合\\(B\\)进行划分，分走\\(k-|A|\\)个元素给\\(A\\)。\r\n根据题目B-3-a的结论，对于一个大小为\\(|V|\\)的集合，进行一次删边就可以得到一个\\(\\left[\\dfrac{|V|}{4},\\dfrac{3|V|}{4}\\right]\\)范围内的划分。每次进行划分的点集都是原来至多的\\(\\dfrac{3}{4}\\)。因此划分的次数（也就是删边的次数）为\\(O(\\lg |V|)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论C.2 Exercises 答案","url":"/introduction-to-algorithms/appendix-c/exercises-2/","content":"\r\nC.2-1\r\n分别令随机变量\\(R,G\\)是Rosencrantz教授，Guildenstern教授抛出正面的次数。那么随机变量\\(R,G\\)分别有如下分布律：\r\n\\(\\begin{aligned}\r\n\\begin{array}{|l|l|l|l|}\r\n\\hline\r\nR &amp; 0 &amp; 1 &amp; 2\\\\\r\n\\hline\r\n&amp;1/4&amp;1/2&amp;1/4\\\\\r\n\\hline\r\n\\end{array}&amp;&amp;\r\n\\begin{array}{|l|l|l|}\r\n\\hline\r\nG &amp; 0 &amp; 1\\\\\r\n\\hline\r\n&amp;1/2&amp;1/2\\\\\r\n\\hline\r\n\\end{array}\r\n\\end{aligned}\\)\r\n因此，\\(\\Pr\\{R&gt;G\\}=\\dfrac{1}{2}\\cdot\\dfrac{1}{2}+\\dfrac{1}{4}\\cdot\\left(\\dfrac{1}{2}+\\dfrac{1}{2}\\right)=\\dfrac{1}{2}\\)。\r\nC.2-2\r\n考虑使用数学归纳法证明。\r\n已知仅有两个事件\\(A_1,A_2\\)时，\\(\\Pr\\{A_1\\cup A_2\\}\\le\r\n\\Pr\\{A_1\\}+\\Pr\\{A_2\\}\\)成立。\r\n假设当有\\(2,3,4,\\dots,n-1\\)个事件时，上述不等式依旧成立，那么加入第\\(n\\)个事件时，有：\r\n\\(\\begin{aligned}\r\n\\Pr\\left\\{\\bigcup_{i=1}^n\r\nA_i\\right\\}&amp;=\\Pr\\left\\{A_n\\cup\\left(\\bigcup_{i=1}^{n-1}\r\nA_i\\right)\\right\\}\\\\\r\n&amp;\\le\\Pr\\left\\{\\bigcup_{i=1}^{n-1} A_i\\right\\} + \\Pr\\{A_n\\}\\\\\r\n&amp;\\le\\Pr\\{A_n\\}+\\sum_{i=1}^{n-1} \\Pr\\{A_i\\}\\\\\r\n&amp;=\\sum_{i=1}^{n} \\Pr\\{A_i\\}\r\n\\end{aligned}\\)\r\n原结论成立。\r\nC.2-3\r\n随机地从\\(10\\)张不同的卡按轮次地抽出\\(3\\)张，每抽出一张记录当前轮次的结果，那么不同情况数量为\\(A_{10}^3=10\\times9\\times8=720\\)。\r\n随机地从\\(10\\)张不同的卡按轮次地抽出\\(3\\)张并希望保持有序，需要排除掉无序的情况，不同情况的数量为\\(\\dbinom{10}{3}=120\\)。\r\n因此有序的概率为\\(\\dfrac{120}{720}=\\dfrac{1}{6}\\)。\r\nC.2-4\r\n\\(\\begin{aligned}\r\n\\Pr\\{A|B\\}+\\Pr\\{\\overline{A}|B\\}&amp;=\\dfrac{\\Pr\\{A\\cap\r\nB\\}}{\\Pr\\{B\\}}+\\dfrac{\\Pr\\{\\overline{A}\\cap B\\}}{\\Pr\\{B\\}}\\\\\r\n&amp;=\\dfrac{\\Pr\\{(A\\cup\\overline{A})\\cap B\\}}{\\Pr\\{B\\}}\\\\\r\n&amp;=\\dfrac{\\Pr\\{B\\}}{\\Pr\\{B\\}}\\\\\r\n&amp;=1\r\n\\end{aligned}\\)\r\nC.2-5\r\n考虑使用数学归纳法证明：\\(\\displaystyle{\\Pr\\left\\{\\bigcap_{i=1}^n\r\nA_i\\right\\}}=\\Pr\\{A_1\\}\\cdot \\prod_{i=2}^n\r\n\\Pr\\left\\{A_i|\\bigcap_{j=1}^{i-1} A_j\\right\\}\\)\r\n已知仅有两个事件\\(A_1,A_2\\)时，\\(\\Pr\\{A_1\\cap A_2\\}=\r\n\\Pr\\{A_1\\}\\cdot\\Pr\\{A_2|A_1\\}\\)成立。\r\n假设当有\\(2,3,4,\\dots,k-1\\)个事件时，等式依旧成立，那么加入第\\(k\\)个事件时，有：\r\n\\(\\begin{aligned}\r\n\\Pr\\left\\{\\bigcap_{i=1}^n\r\nA_i\\right\\}&amp;=\\Pr\\left\\{\\left(\\bigcap_{i=1}^{n-1} A_i\\right)\\cap\r\nA_n\\right\\}\\\\\r\n&amp;=\\Pr\\left\\{A_n|\\bigcap_{i=1}^{n-1} A_i\\right\\} \\cdot\r\n\\Pr\\left\\{\\bigcap_{i=1}^{n-1} A_i\\right\\}\\\\\r\n&amp;=\\Pr\\left\\{A_n|\\bigcap_{i=1}^{n-1} A_i\\right\\}\\cdot\r\n\\Pr\\{A_1\\}\\cdot\\prod_{i=2}^{n-1} Pr\\left\\{A_i|\\bigcap_{j=1}^{i-1}\r\nA_j\\right\\}\\\\\r\n&amp;=\\Pr\\{A_1\\}\\cdot\\prod_{i=2}^{n} Pr\\left\\{A_i|\\bigcap_{j=1}^{i-1}\r\nA_j\\right\\}\r\n\\end{aligned}\\)\r\n原结论成立。\r\n\\(\\star\\)\r\nC.2-6\r\n本题目答案来自这个页面。\r\n构造一颗有\\(n^2\\)个面的均匀的骰子。现在有\\(n\\)种颜色，对于每一种颜色，都给这个骰子完整地涂上\\(n-1\\)面。那么还剩下\\(n^2-n(n-1)=n\\)面。在剩下的这\\(n\\)面中，其中\\(1\\)面分成\\(1/n\\)份，每一份各涂上不同的\\(n\\)种颜色。剩下的\\(n-1\\)面不涂色。\r\n那么，令事件\\(A_i(1\\le i\\le\r\nn)\\)表示进行一次投掷后，朝最上方的面中存在第\\(i\\)种颜色。\r\n可以发现，\\(\\Pr\\{A_i\\}=\\dfrac{n-1+1}{n^2}=\\dfrac{1}{n}\\)。对于\\(1\\le i&lt; j\\le n,\\Pr\\{A_i\\cap\r\nA_j\\}=\\dfrac{1}{n^2}=\\Pr\\{A_i\\}\\cdot\\Pr\\{A_j\\}\\)，因此事件\\(A_i,A_j\\)两两独立。\r\n可以发现，对于所有大小大于\\(2\\)的集合\\(S\\subseteq\\{1,2,3,\\dots,n\\}\\)，都有：\r\n\\[\\Pr\\left\\{\\bigcap_{i\\in S}\r\nA_i\\right\\}=\\dfrac{1}{n^2}\\neq\\dfrac{1}{n^{|S|}}=\\prod_{i\\in\r\nS}\\Pr\\{A_i\\}\\]\r\n这说明，不存在大于\\(2\\)的事件集合满足联合独立。\r\n\\(\\star\\)\r\nC.2-7\r\n当前有\\(2\\)枚硬币，一枚正面的概率是\\(0.6\\)，另一枚正面的概率是\\(0.3\\)。等概率地随机选择一枚硬币，然后进行两次抛掷。设事件\\(A\\)为抛掷的第一次是正面，事件\\(B\\)为抛掷的第二次是正面，事件\\(C\\)为选择的硬币是第一枚。\r\n那么在条件\\(C\\)下，场景就变成了普通的抛硬币实验：\r\n\\(\\Pr\\{A|C\\}=\\Pr\\{B|C\\}=0.6,\\Pr\\{A\\cap\r\nB|C\\}=0.36\\)\r\n如果没有条件\\(C\\)的约束，那么有：\r\n\\(\\Pr\\{A\\}=\\Pr\\{B\\}=0.5\\cdot 0.6+0.5\\cdot\r\n0.3=0.45,\\Pr\\{A\\cap B\\}=0.5\\cdot 0.6^2+0.5\\cdot 0.3^2=0.225\\)\r\n可以发现，\\(\\Pr\\{A\\}\\cdot\r\n\\Pr\\{B\\}\\neq\\Pr\\{A\\cap B\\}\\)，但是\\(\\Pr\\{A|C\\}\\cdot\\Pr\\{B|C\\}=\\Pr\\{A\\cap\r\nB|C\\}\\)。\r\n\\(\\star\\)\r\nC.2-8\r\n仍然是\\(1/3\\)。因为无论被告知Jeff挂科还是Tim挂科，都无法影响当前Carmine的形势。有如下三种情况：\r\n\r\nCarmine通过，那么Jeff和Tim挂科的消息Carmine都能等概率地听到其中的一个。\r\nJeff通过，那么Carmine就能听到Tim挂科的消息。\r\nTim通过，那么Carmine就能听到Jeff挂科的消息。\r\n\r\n总而言之，这三种情形下，教授总能回答Carmine的问题（关于这两个人谁会挂科），因此概率是\\(1/3\\)。\r\n由于Carmine通过的概率仍然是\\(1/3\\)。因此，无论Carmine得知哪一个人挂科，他必定知道另一个没被透露挂科消息的人通过的概率是\\(1-1/3=2/3\\)。在这道题下，被透露挂科的是Jeff，因此Carmine知道\r\nTim通过的概率是\\(2/3\\)。\r\n","categories":["算法导论"]},{"title":"算法导论C.1 Exercises 答案","url":"/introduction-to-algorithms/appendix-c/exercises-1/","content":"\r\nC.1-1\r\n\\[\\begin{aligned}\r\n&amp;n-k+1;\\\\\r\n&amp;\\sum_{k=1}^n(n-k+1)=\\sum_{k=1}^n k=\\dfrac{n(n+1)}{2}\r\n\\end{aligned}\\]\r\nC.1-2\r\n对于每一个输入，都有\\(2\\)个输出。由于一共有\\(2^n\\)个输入，这意味着有\\(2^{2^n}\\)个不同的布尔函数。\r\n更一般的，对于每一个输入，都有\\(2^m\\)个输出。由于一共有\\(2^n\\)个输入，这意味着有\\((2^m)^{2^n}=2^{m\\cdot\r\n2^n}\\)个不同的布尔函数。\r\nC.1-3\r\n这是一个循环排列，因此对于第\\(1\\)个被放置的物品而言，放在哪个位置都没有意义，此时仅有\\(1\\)种方法放置。第\\(1\\)个物品的位置确定后，放置第\\(2\\)个物品时，那么就有\\(n-1\\)种选择方式……放置第\\(i\\)个物品时，有\\(n-i+1\\)种方法。因此，最终的方法数量为\\(1\\times (n-1)\\times (n-2)\\times \\dots \\times\r\n1=(n-1)!\\)。\r\nC.1-4\r\n注意这里一共有\\(49\\)个偶数，\\(50\\)个奇数。为了使取出的\\(3\\)个数之和为偶数，有以下两种情况：\r\n\r\n取出的\\(3\\)个数都为偶数，有\\(\\dbinom{49}{3}\\)种取法。\r\n取出的\\(3\\)个数中，\\(1\\)个为偶数，\\(2\\)个为奇数，有\\(\\dbinom{49}{1}\\cdot\r\n\\dbinom{50}{2}\\)种取法。\r\n\r\n因此最终有\\(\\dbinom{49}{3}+\\dbinom{49}{1}\\cdot\r\n\\dbinom{50}{2}=78449\\)种取出方法。\r\nC.1-5\r\n\\(\\begin{aligned}\r\n\\dbinom{n}{k}&amp;=\\dfrac{n!}{k!\\cdot(n-k)!}\\\\\r\n&amp;=\\dfrac{n}{k}\\cdot \\dfrac{(n-1)!}{(k-1)!\\cdot(n-k)!}\\\\\r\n&amp;=\\dfrac{n}{k}\\cdot \\dfrac{(n-1)!}{(k-1)!\\cdot((n-1)-(k-1))!}\\\\\r\n&amp;=\\dfrac{n}{k}\\cdot \\dbinom{n-1}{k-1}\\\\\r\n\\end{aligned}\\)\r\nC.1-6\r\n\\(\\begin{aligned}\r\n\\dbinom{n}{k}&amp;=\\dfrac{n!}{k!\\cdot(n-k)!}\\\\\r\n&amp;=\\dfrac{n}{n-k}\\cdot \\dfrac{(n-1)!}{k!\\cdot(n-k-1)!}\\\\\r\n&amp;=\\dfrac{n}{n-k}\\cdot \\dfrac{(n-1)!}{k!\\cdot((n-1)-k)!}\\\\\r\n&amp;=\\dfrac{n}{n-k}\\cdot \\dbinom{n-1}{k}\\\\\r\n\\end{aligned}\\)\r\nC.1-7\r\n目前求解\\(\\dbinom{n}{k}\\)的递推式。考虑现在选择的是第\\(n\\)个物品，并且已经选择了\\(k\\)次。\r\n\r\n如果第\\(n\\)个物品没有被选择，那么说明前面\\(n-1\\)个物品中需要选择\\(k\\)个，有\\(\\dbinom{n-1}{k}\\)种方法。\r\n如果第\\(n\\)个物品被选择，那么说明前面\\(n-1\\)个物品中需要选择\\(k-1\\)个，有\\(\\dbinom{n-1}{k-1}\\)种方法。加上第\\(n\\)个物品就变成了从\\(n\\)个物品种选择\\(k\\)个。\r\n\r\n因此有\\(\\dbinom{n}{k}=\\dbinom{n-1}{k}+\\dbinom{n-1}{k-1}\\)。\r\nC.1-8\r\n杨辉三角前\\(7\\)行：\r\n\\[\\begin{aligned}\r\n&amp;&amp;1 \\\\\r\n&amp;&amp;1 &amp;&amp;1 \\\\\r\n&amp;&amp;1 &amp;&amp;2 &amp;&amp;1 \\\\\r\n&amp;&amp;1 &amp;&amp;3 &amp;&amp;3 &amp;&amp;1 \\\\\r\n&amp;&amp;1 &amp;&amp;4 &amp;&amp;6 &amp;&amp;4 &amp;&amp;1 \\\\\r\n&amp;&amp;1 &amp;&amp;5 &amp;&amp;10 &amp;&amp;10 &amp;&amp;5\r\n&amp;&amp;1 \\\\\r\n&amp;&amp;1 &amp;&amp;6 &amp;&amp;15 &amp;&amp;20 &amp;&amp;15\r\n&amp;&amp;6 &amp;&amp;1 \\\\\r\n\\end{aligned}\\]\r\nC.1-9\r\n序列\\(a_i=i\\)是首项为\\(1\\)，公差为\\(1\\)的等差数列。因此有\r\n\\(\\begin{aligned}\r\n\\sum_{i=1}^n i&amp;=\\dfrac{n(n+1)}{2}=\\dfrac{(n+1)!}{2!\\cdot\r\n(n-1)!}=\\dfrac{(n+1)!}{2!\\cdot ((n+1)-2)!}=\\dbinom{n+1}{2}\r\n\\end{aligned}\\)\r\nC.1-10\r\n对于\\(k\\ge\r\n1\\)，对行内相邻的两个组合数做商，得到：\r\n\\(\\dfrac{\\dbinom{n}{k}}{\\dbinom{n}{k-1}}=\\dfrac{n!}{k!(n-k!)}\\cdot\\dfrac{(k-1)!(n-k+1)!}{n!}=\\dfrac{n-k+1}{k}\\)\r\n可以发现，随着\\(k\\)值上升，\\(f(k)=\\dfrac{n-k+1}{k}\\)先递增，后递减。\r\n当\\(f(k)\\)非严格递增时，满足\\(f(k)\\ge 1\\)，也就是\\(2k\\le n+1\\)时，满足递增。此时有\\(k\\le\r\n\\dfrac{n+1}{2}=\\left\\lceil\\dfrac{n}{2}\\right\\rceil\\)。\r\n当\\(f(k)\\)非严格递减时，满足\\(f(k)\\le 1\\)，也就是\\(2k\\ge n+1\\)时，满足递增。此时有\\(k\\ge\r\n\\dfrac{n+1}{2}=\\left\\lceil\\dfrac{n}{2}\\right\\rceil\\)。\r\n因此当\\(k=\\left\\lceil\\dfrac{n}{2}\\right\\rceil\\)时，\\(\\dbinom{n}{k}\\)能取到最大值。\r\n另外由于对于所有正数\\(n\\)，\\(\\left\\lfloor\\dfrac{n}{2}\\right\\rfloor+\\left\\lceil\\dfrac{n}{2}\\right\\rceil\\)都成立。因此根据等式\\(C.3\\)，当\\(k=\\left\\lfloor\\dfrac{n}{2}\\right\\rfloor\\)时，\\(\\dbinom{n}{k}\\)也能取到最大值。\r\nC.1-11\r\n代数证明：\r\n\\(\\begin{aligned}\r\n\\dbinom{n}{j}\\cdot\r\n\\dbinom{n-j}{k}&amp;=\\dfrac{n!}{j!(n-j)!}\\cdot\\dfrac{(n-j)!}{k!(n-j-k)!}\\\\\r\n&amp;=\\dfrac{n!}{j! k!(n-j-k)!}\\\\\r\n&amp;\\ge\\dfrac{n!}{(j+k)!(n-(j+k))!}&amp;\\qquad(A)\\\\\r\n&amp;=\\dbinom{n}{j+k}\r\n\\end{aligned}\\)\r\n其中，变换\\((A)\\)使用了\\(i!\\cdot j!\\le (i+j)!\\)。\r\n直观证明：\r\n\\(\\dbinom{n}{j+k}\\)相当于直接在一个阶段下，取出了\\(j+k\\)个物品。右边等式将取物品划分成了\\(2\\)个独立的阶段，第\\(1\\)个阶段是从\\(n\\)个物品中取出\\(j\\)个，有\\(\\dbinom{n}{j}\\)种取法；第\\(2\\)个阶段是从剩下的\\(n-j\\)个物品中取出\\(k\\)个，有\\(\\dbinom{n-j}{k}\\)种取法。对于\\(\\dbinom{n}{j+k}\\)中的同一种取法，在\\(\\dbinom{n}{j}\\cdot\r\n\\dbinom{n-j}{k}\\)中，它们取出的阶段可能不同，被视为了不同的取法，因此有重复。故\\(\\dbinom{n}{j}\\cdot \\dbinom{n-j}{k}\\ge\r\n\\dbinom{n}{j+k}\\)成立。\r\n实例：\\(n=2,j=k=1\\)。此时有：\\(2=\\dbinom{2}{1}\\cdot \\dbinom{1}{1}&gt;\r\n\\dbinom{2}{1+1}=1\\)\r\n\\(\\star\\)\r\nC.1-12\r\n当\\(k=0\\)时，\\(1=\\dbinom{n}{0}\\le \\dfrac{n^n}{0^0\\cdot\r\nn^n}=1\\)，结论成立。\r\n假设对于\\(0,1,2,\\dots,k-1\\)使得\\(k\\le n/2\\)，原结论都成立。考虑\\(k+1\\)时的情况。那么有：\r\n\\(\\begin{aligned}\r\n\\dbinom{n}{k}&amp;=\\dfrac{n-k+1}{k}\\cdot \\dbinom{n}{k-1}\\\\\r\n&amp;\\le \\dfrac{n-k+1}{k} \\dfrac{n^n}{(k-1)^{k-1}(n-(k-1))^{n-(k-1)}}\\\\\r\n&amp;=\\dfrac{n^n}{k(k-1)^{k-1}(n-k+1)^{n-k}}\\\\\r\n&amp;\\le\\dfrac{n^n}{k^k(n-k)^{n-k}}&amp;\\qquad(A)\\\\\r\n\\end{aligned}\\)\r\n那么此时只需要证明变换\\((A)\\)满足\\(k(k-1)^{k-1}(n-k+1)^{n-k}\\ge\r\nk^k(n-k)^{n-k}\\)即可，即证明\r\n\\[\\left(\\dfrac{k-1}{k}\\right)^{k-1}\\ge\\left(\\dfrac{n-k}{n-k+1}\\right)^{n-k}\\]\r\n考虑函数\\(f(x)=\\left(\\dfrac{x}{x+1}\\right)^x\\)，那么\\(f&#39;(x)=\\dfrac{x^x}{(x+1)^{x+1}}\\cdot\r\n(1+(x+1)\\cdot (\\ln x-\\ln (x+1)))\\)。可以发现，当\\(x&gt;0\\)时，\\(f&#39;(x)\\le 0\\)。因此\\(f(x)\\)在区间\\([0,+\\infty)\\)上单调递减。\r\n由于\\(k\\le n/2\\)，因此\\(k-1\\le n-k\\)成立。那么\\(f(k-1)\\ge\r\nf(n-k)\\)，上面的不等式成立，证明完成。\r\n由于\\(\\dfrac{n^n}{k^k(n-k)^{n-k}}=\\dfrac{n^n}{(n-k)^{n-k}k^k}\\)，并且根据等式\\(C.3\\)，因此对于\\(0\\le k\\le n\\)，不等式均成立。\r\n\\(\\star\\)\r\nC.1-13\r\n直接代入斯特林公式，有\r\n\\(\\begin{aligned}\r\n\\dbinom{2n}{n}&amp;=\\dfrac{\\sqrt{4\\pi\r\nn}\\cdot\\left(\\dfrac{2n}{e}\\right)^{2n}\\cdot\\left(1+\\Theta\\left(\\dfrac{1}{n}\\right)\\right)}{\\left(\\sqrt{2\\pi\r\nn}\\cdot\\left(\\dfrac{n}{e}\\right)^{n}\\cdot\\left(1+\\Theta\\left(\\dfrac{1}{n}\\right)\\right)\\right)^2}\\\\\r\n&amp;=\\dfrac{2\\sqrt{\\pi\r\nn}\\cdot\\left(2n\\right)^{2n}\\cdot\\dfrac{1}{e^{2n}}}{2\\pi n\\cdot\r\nn^{2n}\\cdot \\dfrac{1}{e^{2n}}}\r\n\\cdot\\left(1+\\Theta\\left(\\dfrac{1}{n}\\right)\\right)\\\\\r\n&amp;=\\dfrac{2^{2n}}{\\sqrt{\\pi n}}\\cdot\r\n\\left(1+\\Theta\\left(\\dfrac{1}{n}\\right)\\right)\\\\\r\n&amp;=\\dfrac{2^{2n}}{\\sqrt{\\pi n}}\\cdot\r\n\\left(1+O\\left(\\dfrac{1}{n}\\right)\\right)\r\n\\end{aligned}\\)\r\n\\(\\star\\)\r\nC.1-14\r\n\\(H(\\lambda)=-\\lambda\\lg\\lambda-(1-\\lambda)\\lg(1-\\lambda)\\)\r\n那么可以求出\\(H&#39;(\\lambda)=\\dfrac{\\ln\r\n(1-\\lambda)-\\ln \\lambda}{\\ln\r\n2},H&#39;&#39;(\\lambda)=\\dfrac{1}{\\lambda(\\lambda-1)\\cdot\\ln\r\n2}\\)。\r\n由于\\(H&#39;(1/2)=0,H&#39;&#39;(1/2)=-\\dfrac{4}{\\ln\r\n2}&lt;0\\)，因此\\(H(\\lambda)\\)在\\(\\lambda=1/2\\)处取到最大值.此时最大值为\\(H(1/2)=1\\).\r\n\\(\\star\\)\r\nC.1-15\r\n根据二项式定理，有\r\n\\[(x+1)^n=\\sum_{k=0} ^n \\dbinom{n}{k}\r\nx^k\\]\r\n对此式两边对\\(x\\)进行求导（注意常数项），得到\r\n\\[n(x+1)^{n-1}=\\sum_{k=1} ^n \\dbinom{n}{k}\r\n\\cdot kx^{k-1}\\]\r\n回代\\(x=1\\)，得到\r\n\\[n2^{n-1}=\\sum_{k=1}^n\\dbinom{n}{k} \\cdot\r\nk \\]\r\n当\\(k=0\\)时，\\(\\dbinom{n}{0}\\cdot 0=0\\)，因此有\r\n\\[n2^{n-1}=\\sum_{k=0}^n\\dbinom{n}{k} \\cdot\r\nk \\]\r\n\\(\\star\\)\r\nC.1-16\r\n当\\(k=0\\)时容易验证不等式成立。当\\(n=1,2,3\\)时，通过枚举可以验证原不等式成立：\r\n\\(\\begin{array}{|l|l|l|l|}\r\n\\hline\r\nn&amp;k&amp;\\dbinom{n}{k}&amp;\\dfrac{n^k}{4k!}\\\\\r\n\\hline\r\n1&amp;1&amp;1&amp;1/4\\\\\r\n\\hline\r\n2&amp;1&amp;2&amp;1/2\\\\\r\n\\hline\r\n3&amp;1&amp;3&amp;3/4\\\\\r\n\\hline\r\n\\end{array}\\)\r\n以下将证明\\(n\\ge 4\\)时的情况。\r\n为了证明\\(\\forall k\\le\r\n\\sqrt{n},\\dbinom{n}{k} \\ge\\dfrac{n^k}{4k!}\\)成立，相当于证明\\(\\dfrac{\\prod_{i=n-k+1}^n\r\ni}{k!}\\ge\\dfrac{n^k}{4k!}\\)。\r\n化简后，相当于证明\\(\\displaystyle{\\prod_{i=n-k+1}^n \\dfrac{i}{n}}\\ge\r\n\\dfrac{1}{4}\\)成立。\r\n转换下标后，相当于证明\\(\\displaystyle{\\prod_{i=0}^{k-1}\r\n\\left(1-\\dfrac{i}{n}\\right)}\\ge\\frac{1}{4}\\)成立。\r\n那么有：\r\n\\(\\begin{aligned}\r\n\\prod_{i=0}^{k-1}\r\n\\left(1-\\dfrac{i}{n}\\right)&amp;\\ge\\prod_{i=0}^{k-1}\\left(1-\\dfrac{\\sqrt{n}}{n}\\right)\\\\\r\n&amp;\\ge\\left(1-\\dfrac{1}{\\sqrt{n}}\\right)^{\\lfloor\\sqrt{n}\\rfloor}\\\\\r\n&amp;\\ge\\left(1-\\dfrac{1}{\\sqrt{n}}\\right)^{\\sqrt{n}}\r\n\\end{aligned}\\)\r\n考虑函数\\(f(x)=\\left(1-\\dfrac{1}{x}\\right)^x\\)，那么对\\(f(x)\\)进行求导，得到\\(f&#39;(x)=\\left(1-\\dfrac{1}{x}\\right)^x\\cdot\\left(\\dfrac{1}{x-1}+\\ln\\left(\\dfrac{x-1}{x}\\right)\\right)\\)。\r\n可以发现，\\(\\forall\r\nx&gt;1,f&#39;(x)&gt;0\\)恒成立。因此，\\(\\forall x\\ge\r\n2,f(x)\\ge\\dfrac{1}{4}\\)成立。\r\n由于\\(n\\ge 4,\\sqrt{n}\\ge\r\n2\\)，因此\\(\\displaystyle{\\prod_{i=0}^{k-1}\\left(1-\\dfrac{i}{n}\\right)\\ge\\dfrac{1}{4}}\\)成立。故原结论成立。\r\n","categories":["算法导论"]},{"title":"算法导论A Problems 答案","url":"/introduction-to-algorithms/appendix-a/problems/","content":"\r\nA-1\r\na\r\n本题做法与A-1.5完全一致。\r\n由于\\(f(x)=x^r\\)是递增的，因此考虑使用式子\\((A.18)\\)进行逼近。\r\n上界：\r\n\\[\\sum_{n=1}^k k^r\\le \\int_{1}^{n+1} x^r\r\ndx=\\left.\\dfrac{x^{r+1}}{r+1}\\right\\rvert_{1}^{n+1}=\\dfrac{(n+1)^{r+1}}{r+1}-1\\]\r\n下界：\r\n\\[\\sum_{n=1}^k k^r\\ge \\int_{0}^{n} x^r\r\ndx=\\left.\\dfrac{x^{r+1}}{r+1}\\right\\rvert_{0}^{n}=\\dfrac{n^{r+1}}{r+1}\\]\r\n最终可以得到：\r\n\\[\\dfrac{n^{r+1}}{r+1}\\le\\sum_{n=1}^k\r\nk^r\\le \\dfrac{(n+1)^{r+1}}{r+1}-1\\]\r\n并且有\\(\\dfrac{n^{r+1}}{r+1}=\\Omega(n^{r+1}),\\dfrac{(n+1)^{r+1}}{r+1}-1=O(n^{r+1})\\)，因此最终有：\r\n\\[\\sum_{n=1}^k\r\nk^r=\\Theta(n^{r+1})\\]\r\nb\r\n由于\r\n\\(\\begin{aligned}\r\n\\sum_{k=1}^{n} \\lg ^s k &amp;= \\sum_{k=1}^{n/2} \\lg ^s k + \\sum_{k=\r\nn/2+1}^{n} \\lg ^s k\\\\\r\n&amp;\\ge \\sum_{k=1}^{n/2} 0 + \\sum_{k= n/2+1}^{n} \\lg ^s (n/2)\\\\\r\n&amp;=n/2\\cdot\\lg ^s(n/2)\\\\\r\n&amp;=n/2\\cdot(\\lg n-1)^s\\\\\r\n&amp;\\ge n/2\\cdot \\left(\\dfrac{\\lg n}{2}\\right)^s &amp;(A)\\\\\r\n&amp;=\\dfrac{1}{2^{s+1}}\\cdot n\\cdot \\lg^sn\r\n\\end{aligned}\\)\r\n其中步骤\\((A)\\)使用了假设\\(n\\ge 4\\)。因此有\\(\\displaystyle{\\sum_{k=1}^{n} \\lg ^s k\r\n=\\Omega(n\\lg^s n)}\\)。\r\n又因为\r\n\\(\\begin{aligned}\r\n\\sum_{k=1}^{n} \\lg ^s k &amp;\\le \\sum_{k=1}^{n} \\lg ^s n\\\\\r\n&amp;=n\\lg^sn\r\n\\end{aligned}\\)\r\n因此有\\(\\displaystyle{\\sum_{k=1}^{n} \\lg ^s\r\nk =O(n\\lg^s n)}\\)，最终有\\(\\displaystyle{\\sum_{k=1}^{n} \\lg ^s k\r\n=\\Theta(n\\lg^s n)}\\)。\r\nc\r\n与题目8-2-b类似，由于\r\n\\(\\begin{aligned}\r\n\\sum_{k=1}^{n} k^r\\lg ^s k &amp;= \\sum_{k=1}^{n/2} k^r\\lg ^s k +\r\n\\sum_{k= n/2+1}^{n} k^r\\lg ^s k\\\\\r\n&amp;\\ge \\sum_{k=1}^{n/2} 0 + \\sum_{k= n/2+1}^{n} (n/2)^r\\lg ^s (n/2)\\\\\r\n&amp;=(n/2)^{r+1}\\cdot\\lg ^s(n/2)\\\\\r\n&amp;=(n/2)^{r+1}\\cdot(\\lg n-1)^s\\\\\r\n&amp;\\ge (n/2)^{r+1}\\cdot\\left(\\dfrac{\\lg n}{2}\\right)^s &amp;(A)\\\\\r\n&amp;=\\dfrac{1}{2^{r+s+1}} \\cdot n^{r+1}\\cdot \\lg^sn\r\n\\end{aligned}\\)\r\n其中步骤\\((A)\\)使用了假设\\(n\\ge 4\\)。因此有\\(\\displaystyle{\\sum_{k=1}^{n} k^r\\lg ^s k\r\n=\\Omega(n^{r+1}\\lg^s n)}\\)。\r\n又因为\r\n\\(\\begin{aligned}\r\n\\sum_{k=1}^{n} k^r\\lg ^s k &amp;\\le \\sum_{k=1}^{n} n^r\\lg ^s n\\\\\r\n&amp;=n^{r+1}\\lg^sn\r\n\\end{aligned}\\)\r\n因此有\\(\\displaystyle{\\sum_{k=1}^{n}k^r \\lg\r\n^s k =O(n^{r+1}\\lg^s n)}\\)，最终有\\(\\displaystyle{\\sum_{k=1}^{n}k^r \\lg ^s k\r\n=\\Theta(n^{r+1}\\lg^s n)}\\)。\r\n","categories":["算法导论"]},{"title":"算法导论A.1 Exercises 答案","url":"/introduction-to-algorithms/appendix-a/exercises-1/","content":"\r\nA.1-1\r\n令\\(g_k(i)=O(f_k(i))\\)，那么根据符号\\(O\\)的定义，\\(\\exists\r\nc_1,c_2,\\dots,c_n,m_1,m_2,\\dots,c_m&gt;0,\\forall n\\ge m_k,0\\le g_k(n)\\le\r\nc_kf_k(n)\\)成立。\r\n令\\(\\displaystyle{m=\\max_{k=1}^n\r\n\\{m_k\\},c=\\max_{k=1}^n\\{c_k\\}}\\)。根据求和的线性性质，对于\\(\\forall n\\ge m\\)，如下不等式成立：\r\n\\[0\\le \\sum_{k=1}^n g_k(n)\\le\\sum_{k=1}^n\r\nc_kf_k(n)\\le \\sum_{k=1}^n cf_k(n) \\le c\\sum_{k=1}^n\r\nf_k(n)=O\\left(\\sum_{k=1}^n f_k(n)\\right)\\]\r\n因此\\(\\displaystyle{\\sum_{k=1}^n\r\nO(f_k(i))}=O\\left(\\sum_{k=1}^n f_k(n)\\right)\\)。\r\nA.1-2\r\n\\(\\begin{aligned}\r\n\\sum_{k=1}^n(2k-1)&amp;=2\\left(\\sum_{k=1}^nk\\right) -n\\\\\r\n&amp;=n(n+1)-n\\\\\r\n&amp;=n^2\r\n\\end{aligned}\\)\r\nA.1-3\r\n代入\\(x=10,n=9\\)，那么有\\(111111111=\\dfrac{10^{10}-1}{9}\\)。级数的第\\(k\\)项表示这个数十进制数下的第\\(k\\)位为\\(1\\).\r\nA.1-4\r\n令\\(f(x)=\\sum_{k=0}^{\\infty}\r\nx^k=\\dfrac{1}{1-x}\\)。可以发现，这个值是\\(f\\left(-\\dfrac{1}{2}\\right)\\)。\r\n因此，\r\n\\[1-\\dfrac{1}{2}+\\dfrac{1}{4}-\\dfrac{1}{8}+\\dots=\\dfrac{2}{3}\\]\r\nA.1-5\r\n由于\\(f(x)=x^c\\)是递增的，因此考虑使用式子\\((A.18)\\)进行逼近。\r\n上界：\r\n\\[\\sum_{n=1}^k k^c\\le \\int_{1}^{n+1} x^c\r\ndx=\\left.\\dfrac{x^{c+1}}{c+1}\\right|_{1}^{n+1}=\\dfrac{(n+1)^{c+1}-1}{c+1}\\]\r\n下界：\r\n\\[\\sum_{n=1}^k k^c\\ge \\int_{0}^{n} x^c\r\ndx=\\left.\\dfrac{x^{c+1}}{c+1}\\right|_{0}^{n}=\\dfrac{n^{c+1}}{c+1}\\]\r\n最终可以得到：\r\n\\[\\dfrac{n^{c+1}}{c+1}\\le\\sum_{n=1}^k\r\nk^c\\le \\dfrac{(n+1)^{c+1}-1}{c+1}\\]\r\n并且有\\(\\dfrac{n^{c+1}}{c+1}=\\Omega(n^{c+1}),\\dfrac{(n+1)^{c+1}-1}{c+1}=O(n^{c+1})\\)，因此最终有：\r\n\\[\\sum_{n=1}^k\r\nk^c=\\Theta(n^{c+1})\\]\r\nA.1-6\r\n等式\\((A.11)\\)已有：\r\n\\[\\sum_{k=0}^{\\infty}\r\nkx^k=\\dfrac{x}{(1-x)^2}\\]\r\n对以上式子两边进行求导，得到：\r\n\\[\\sum_{k=0}^{\\infty}\r\nk^2x^{k-1}=\\dfrac{1-x^2}{(1-x)^4}\\]\r\n两边乘上\\(x\\)后得到最终答案（并且\\(|x|&lt;1\\)）：\r\n\\[\\sum_{k=0}^{\\infty}\r\nk^2x^k=\\dfrac{x(1+x)}{(1-x)^3}\\]\r\nA.1-7\r\n上界：\r\n\\[\\begin{aligned}\r\n\\sum_{k=1}^n\\sqrt{k\\lg k}&amp;\\le \\sum_{k=1}^n \\sqrt{k \\lg n}\\\\\r\n&amp;\\le \\sqrt{\\lg n} \\sum_{k=1}^n \\sqrt{k}\\\\\r\n&amp;=\\sqrt{\\lg n}\\cdot \\Theta(n^{3/2})&amp;\\qquad(A)\\\\\r\n&amp;=O(n^{3/2}\\lg^{1/2} n)\\end{aligned}\\]\r\n其中，\\((A)\\)的变化使用了题目A-1.5的结论。\r\n下界：\r\n假设前\\(\\dfrac{n}{2}\\)项的值都放缩到\\(0\\)，后\\(\\dfrac{n}{2}\\)项的值都放缩到\\(\\dfrac{n}{2}\\lg \\dfrac{n}{2}\\)。\r\n\\[\\begin{aligned}\r\n\\sum_{k=1}^n\\sqrt{k\\lg k}&amp;= \\sum_{k=1}^{n/2-1} \\sqrt{k\\lg\r\nk}+\\sum_{k=n/2}^n\\sqrt{k\\lg k}\\\\\r\n&amp;\\ge \\sum_{k=1}^{n/2-1} 0+\\sum_{k=n/2}^n\\sqrt{\\dfrac{n}{2}\\lg\r\n\\dfrac{n}{2}}\\\\\r\n&amp;\\ge \\dfrac{n}{2}\\sqrt{\\dfrac{n}{2}\\lg \\dfrac{n}{2}}\\\\\r\n&amp;= \\dfrac{n^{3/2}}{8} \\sqrt{\\lg n-1}\\\\\r\n&amp;=\\Omega(n^{3/2}\\lg^{1/2} n)\r\n\\end{aligned}\\]\r\n因此有：\r\n\\[\\sum_{k=1}^n\\sqrt{k\\lg\r\nk}=\\Theta(n^{3/2}\\lg^{1/2} n) \\]\r\n\\(\\star\\)\r\nA.1-8\r\n可以观察出，级数\\(\\sum_{k=1}^n\\dfrac{1}{2k-1}\\)与调和数的关系满足：\r\n\\[\\sum_{k=1}^n\\dfrac{1}{2k-1}=H_n-\\dfrac{H_{n/2}}{2}\\]\r\n因此，\r\n\\(\\begin{aligned}\r\n\\sum_{k=1}^n\\dfrac{1}{2k-1}&amp;=H_n-\\dfrac{H_{n/2}}{2}\\\\\r\n&amp;=\\ln n-\\dfrac{\\ln n/2}{2}+O(1)\\\\\r\n&amp;=\\ln n-\\dfrac{\\ln n-\\ln 2}{2}+O(1)\\\\\r\n&amp;=\\dfrac{\\ln n}{2} + O(1)\\\\\r\n&amp;=\\ln(\\sqrt{n}) + O(1)\r\n\\end{aligned}\\)\r\n\\(\\star\\)\r\nA.1-9\r\n考虑使用列项相消解决，令\\(\\dfrac{ak+b}{2^k}-\\dfrac{a(k+1)+b}{2^{k+1}}=\\dfrac{k-1}{2^k}\\)，那么通过待定系数法，可以解出来：\r\n\\(a=2,b=0\\)\r\n因此，\r\n\\[\\sum_{k=0}^{\\infty}\\dfrac{k-1}{2^k}=\\sum_{k=0}^{\\infty}\r\n\\left(\\dfrac{2k}{2^k}-\\dfrac{2(k+1)}{2^{k+1}}\\right)=0-\\lim_{k\\rightarrow\\infty}\r\n\\dfrac{2(k+1)}{2^{k+1}}=0\\]\r\n\\(\\star\\)\r\nA.1-10\r\n不难发现，当\\(|x|&lt;1\\)时，级数\\(\\sum_{k=1}^{\\infty} 2k\\cdot x^{2k}\\)和\\(\\sum_{k=1}^{\\infty}\r\nx^{2k}\\)都是收敛的。\r\n分别将两部分的计算结果相加就可以得到原级数\\(\\sum_{k=1}^{\\infty} (2k+1)\\cdot\r\nx^{2k}\\)的答案。\r\n\\(\\begin{aligned}\r\n\\sum_{k=1}^{\\infty} x^{2k}&amp;=\\sum_{k=0}^{\\infty} x^{2k} -1\\\\\r\n&amp;=\\sum_{k=1}^{\\infty} (x^2)^k - 1\\\\\r\n&amp;=\\dfrac{1}{1-x^2}-1\r\n\\end{aligned}\\)\r\n\\(\\begin{aligned}\r\n\\sum_{k=1}^{\\infty} 2k\\cdot x^{2k}&amp;=\\sum_{k=0}^{\\infty} 2k\\cdot\r\nx^{2k}\\\\\r\n&amp;=2\\sum_{k=0}^{\\infty} k\\cdot (x^2)^k\\\\\r\n&amp;=\\dfrac{2x^2}{(1-x^2)^2}\r\n\\end{aligned}\\)\r\n因此最终有\r\n\\[\\sum_{k=1}^{\\infty} (2k+1)\\cdot\r\nx^{2k}=\\dfrac{1}{1-x^2}-1+\\dfrac{2x^2}{(1-x^2)^2}=\\dfrac{1+x^2}{(1-x^2)^2}-1\\]\r\n\\(\\star\\)\r\nA.1-11\r\n\\(\\begin{aligned}\r\n\\prod_{k=2}^n\\left(1-\\dfrac{1}{k^2}\\right)&amp;=\\prod_{k=2}^n\\dfrac{k-1}{k}\r\n\\cdot \\dfrac{k+1}{k}\\\\\r\n&amp;=\\dfrac{(n-1)!\\cdot (n+1)!/2}{(n!)^2}\\\\\r\n&amp;=\\dfrac{1}{n}\\cdot (n+1)\\cdot\\frac{1}{2}\\\\\r\n&amp;=\\dfrac{n+1}{2n}\r\n\\end{aligned}\\)\r\n","categories":["算法导论"]},{"title":"算法导论C.3 Exercises 答案","url":"/introduction-to-algorithms/appendix-c/exercises-3/","content":"\r\nC.3-1\r\n一颗骰子投出的期望点数为\\(\\displaystyle{\\sum_{i=1}^6 \\dfrac{1}{6}\\cdot\r\ni=\\dfrac{7}{2}}\\)。那么根据期望的线性，两颗骰子的和的期望为\\(7\\)。\r\n两颗骰子最大值的期望为\\(\\displaystyle{\\sum_{i=1}^6\\sum_{j=1}^6\r\n\\dfrac{1}{36}\\cdot \\max(i,j)=\\dfrac{161}{36}}\\)。\r\nC.3-2\r\n由于排列是等概率生成的，因此无论是最大值元素还是最小值元素，它们将等概率地出现在任何位置中。因此下标期望值为：\r\n\\[\\sum_{i=1}^n \\dfrac{1}{n}\\cdot\r\ni=\\dfrac{n+1}{2}\\]\r\nC.3-3\r\n假设随机变量\\(X\\)是单次赌局后，获得金钱的数量。那么\\(X\\)的分布律如下：\r\n\\(\\begin{array}{|l|l|}\r\n\\hline\r\nx&amp;\\Pr\\{X=x\\}\\\\\r\n\\hline\r\n-1&amp;\\dbinom{3}{0}\\left(\\dfrac{5}{6}\\right)^3\\left(\\dfrac{1}{6}\\right)^0=\\dfrac{125}{216}\\\\\r\n\\hline\r\n1&amp;\\dbinom{3}{1}\\left(\\dfrac{5}{6}\\right)^2\\left(\\dfrac{1}{6}\\right)^1=\\dfrac{75}{216}\\\\\r\n\\hline\r\n2&amp;\\dbinom{3}{2}\\left(\\dfrac{5}{6}\\right)^1\\left(\\dfrac{1}{6}\\right)^2=\\dfrac{15}{216}\\\\\r\n\\hline\r\n3&amp;\\dbinom{3}{3}\\left(\\dfrac{5}{6}\\right)^0\\left(\\dfrac{1}{6}\\right)^3=\\dfrac{1}{216}\\\\\r\n\\hline\r\n\\end{array}\\)\r\n因此计算得\\(\\displaystyle{\\sum_{x}x\\cdot\\Pr\\{X=x\\}=-\\dfrac{17}{216}}\\)。\r\nC.3-4\r\n由于随机变量\\(X,Y\\)都是非负的，因此\\(\\max(X,Y)\\le X+Y\\)都是成立的。\r\n那么有\\(E[\\max(X,Y)]\\le E[X+Y]\\le E[X] +\r\nE[Y]\\)。\r\n\\(\\star\\)\r\nC.3-5\r\n本题目的答案来自于这个页面。需要用到实变函数的内容，不过本人并不是数学专业，并不懂这些概念。本答案由此翻译而来。\r\n根据定义，\\(X,Y\\)相互独立意味着：\\(\\Pr\\{X\\le x,Y\\le y\\}=\\Pr\\{X\\le x\\}P\\{Y\\le\r\ny\\}\\)。\r\n有了这个就可以证明，对于任意波莱尔集合\\(A,B\\)，有\\(\\Pr\\{X\\in A,Y\\in B\\}=\\Pr\\{X\\in A\\}P\\{Y\\in\r\nB\\}\\)。\r\n假设\\(f,g\\)是可测函数，那么有：\r\n\\(\\begin{aligned}\r\n\\Pr\\{f(X)\\le x,g(Y)\\le y\\}&amp;= \\Pr \\{ X \\in f^{-1} (-\\infty,x], Y \\in\r\ng^{-1}(-\\infty, y] \\} \\\\\r\n&amp;=\\Pr \\{X \\in f^{-1} (-\\infty,x] \\} P \\{Y \\in g^{-1}(-\\infty, y] \\}\r\n\\\\\r\n&amp;= P \\{f(X) \\le x \\} P \\{g(Y) \\le y \\}\r\n\\end{aligned}\\)\r\n因此证得\\(f(X)\\)和\\(g(Y)\\)独立。\r\n\\(\\star\\)\r\nC.3-6\r\n不失一般性，假设\\(X\\)是离散型随机变量，样本空间为\\(S\\)。当\\(X\\)是连续型随机变量时，证明过程类似。\r\n\\(\\begin{aligned}\r\nE[X]&amp;=\\sum_{k \\in S} k\\cdot \\Pr\\{X=k\\}\\\\\r\n&amp;\\ge\\sum_{k\\in S,k&lt;t} 0\\cdot\\Pr\\{X=k\\}+\\sum_{k\\in S,k\\ge t}\r\nt\\cdot\\Pr\\{X=k\\}\\\\\r\n&amp;=t\\cdot \\Pr\\{X\\ge t\\}\r\n\\end{aligned}\\)\r\n因此有\\(\\Pr\\{X\\ge\r\nt\\}\\le\\dfrac{E[X]}{t}\\).\r\n\\(\\star\\)\r\nC.3-7\r\n重新按照定义写出\\(\\Pr\\{X\\ge\r\nt\\},\\Pr\\{X&#39;\\ge t\\}\\)：\r\n\\(\\begin{aligned}\r\n\\Pr\\{X\\ge t\\}=\\sum_{s\\in S,X(s)\\ge t} \\Pr\\{s\\}\\\\\r\n\\Pr\\{X&#39;\\ge t\\}=\\sum_{s\\in S,X&#39;(s)\\ge t} \\Pr\\{s\\}\r\n\\end{aligned}\\)\r\n可以发现，由于\\(\\forall s\\in S,X(s)\\ge\r\nX&#39;(s)\\)均成立。因此第一个式子中必定都包含了第二个式子的求和项。因此原不等式成立。\r\n式子\\(\\displaystyle{\\Pr\\{X&#39;\\ge\r\nt\\}-\\Pr\\{X\\ge t\\}=\\sum_{s\\in S,X&#39;(s)&lt; t\\le X(s)}\r\n\\Pr\\{s\\}}\\)说明，当\\(\\exists s\\in\r\nS,X&#39;(s)&lt; t\\le X(s)\\)时，大于号成立。\r\nC.3-8\r\n随机变量平方的期望比期望的平方要大。\r\n根据方差的定义重新逆推：\\(E[X^2]-E^2[X]=E[(X-E[X])^2]\\ge\r\n0\\)。由于随机变量\\((X-E[X])^2\\)恒正，由此而得。\r\nC.3-9\r\n令\\(p(x)\\)为随机遍历\\(X\\)的分布律，那么满足\\(p(0)+p(1)=1\\)。因此\\(E[X]=0\\cdot p(0)+1\\cdot p(1)=p(1)\\)。\r\n同样有\\(E[X^2]=p(1)\\)。那么有\r\n\\(\\begin{aligned}\r\n\\text{Var}[X]&amp;=E[X^2]-E^2[X]\\\\\r\n&amp;=p(1)-p^2(1)\\\\\r\n&amp;=p(1)\\cdot(1-p(1))\\\\\r\n&amp;=E[X]\\cdot(1-E[X])\\\\\r\n&amp;=E[X]\\cdot E[1-X]\r\n\\end{aligned}\\)\r\nC.3-10\r\n\\(\\begin{aligned}\r\n\\text{Var}[aX]&amp;=E[(aX-E[aX])^2]\\\\\r\n&amp;=E[a^2X^2-2aE[aX]\\cdot X+E^2[aX]]\\\\\r\n&amp;=E[a^2X^2]-E[2aE[aX]\\cdot X]+E^2[aX]\\\\\r\n&amp;=a^2E[X^2]-2aE[aX]\\cdot E[X]+a^2E^2[X]\\\\\r\n&amp;=a^2E[X^2]-2a^2E^2[X]+a^2E^2[X]\\\\\r\n&amp;=a^2E[X^2]-a^2E^2[X]\\\\\r\n&amp;=a^2(E[X^2]-E^2[X])\\\\\r\n&amp;=a^2\\text{Var}[X]\r\n\\end{aligned}\\)\r\n","categories":["算法导论"]},{"title":"算法导论C.4 Exercises 答案","url":"/introduction-to-algorithms/appendix-c/exercises-4/","content":"\r\nC.4-1\r\n\\(\\begin{aligned}\r\n\\sum_{k=1}^{\\infty}q^{k-1} p&amp;=p\\sum_{k=0}^{\\infty}q^{k}\\\\\r\n&amp;=\\dfrac{p}{1-q}\\\\\r\n&amp;=1\r\n\\end{aligned}\\)\r\nC.4-2\r\n抛掷\\(6\\)枚硬币，\\(3\\)面朝上的概率为\\(\\dbinom{6}{3}\\left(\\dfrac{1}{2}\\right)^3\\left(\\dfrac{1}{2}\\right)^3=\\dfrac{5}{16}\\)。\r\n那么令随机变量\\(X\\)表示需要抛掷的次数。可以发现，\\(X\\)服从\\(p=\\dfrac{5}{16}\\)的几何分布。因此\\(E[X]=\\dfrac{16}{5}\\)。\r\nC.4-3\r\n\\(\\begin{aligned}\r\n\\text{Var}[x]&amp;=E[X^2]-E^2[X]\\\\\r\n&amp;=\\sum_{k=1}^{\\infty} k^2q^{k-1}p-\\left(\\dfrac{1}{p}\\right)^2\\\\\r\n&amp;=\\dfrac{p}{q}\\cdot\\sum_{k=0}^{\\infty} k^2\\cdot q^k-\\dfrac{1}{p^2}\\\\\r\n&amp;=\\dfrac{p}{q}\\cdot\\dfrac{q(q+1)}{(1-q)^3}-\\dfrac{1}{p^2}&amp;\\qquad(A)\\\\\r\n&amp;=\\dfrac{q}{p^2}\r\n\\end{aligned}\\)\r\n其中，变换\\((A)\\)用到了级数\\(\\displaystyle{\\sum_{k=0}^{\\infty}\r\nk^2x^k=\\dfrac{x(1+x)}{(1-x)^3}}\\)。\r\nC.4-4\r\n\\(\\begin{aligned}\r\nb(k;n,p)&amp;=\\dbinom{n}{k} p^k(1-p)^{n-k}\\\\\r\n&amp;=\\dbinom{n}{k} (1-q)^kq^{n-k}\\\\\r\n&amp;=\\dbinom{n}{n-k} (1-q)^kq^{n-k}\\\\\r\n&amp;=\\dbinom{n}{n-k} q^{n-k}(1-q)^k\\\\\r\n&amp;=b(n-k;n,q)\r\n\\end{aligned}\\)\r\nC.4-5\r\n考虑解以下关于\\(k\\)的不等式组：\r\n\\(\\left\\{\\begin{aligned}\r\n&amp;b(k;n,p)\\ge b(k-1,n,p)\\\\\r\n&amp;b(k;n,p)\\ge b(k+1,n,p)\\\\\r\n\\end{aligned}\\right.\\)\r\n那么可以解得：\\(k\\in[(n+1)p-1,(n+1)p]\\)。也就是说，\\(k\\)的取值将会在这区间内的整数，设其为\\(K\\)。\r\n由于\\(E[X]=np\\)值在这个区间内，考虑用\\(np\\)来近似这个\\(K\\)。\r\n那么代入斯特林公式，有：\r\n\\(\\begin{aligned}\r\nb(K;n,p)&amp;=\\dfrac{n!}{K!(n-K)!}\\cdot p^Kq^{n-K}\\\\\r\n&amp;\\approx \\dfrac{\\sqrt{2\\pi n}\\cdot n^n}{e^n} \\cdot\r\n\\dfrac{e^K}{\\sqrt{2\\pi K}\\cdot K^K}\\cdot\\dfrac{e^{n-K}}{\\sqrt{2\\pi\r\n(n-K)}\\cdot (n-K)^{n-K}}\\cdot p^Kq^{n-K}\\\\\r\n&amp;=\\sqrt{\\dfrac{n}{K(n-K)\\cdot2\\pi}}\\cdot\\dfrac{n^n}{K^K\\cdot(n-K)^{n-K}}\\cdot\r\np^Kq^{n-K}\\\\\r\n&amp;\\approx\r\n\\sqrt{\\dfrac{n}{np(n-np)\\cdot2\\pi}}\\cdot\\dfrac{n^n}{(np)^{np}\\cdot(n-np)^{n-np}}\\cdot\r\np^{np}q^{n-np}\\\\\r\n&amp;=\\dfrac{1}{\\sqrt{2\\pi npq}}\\cdot\\dfrac{1}{p^{np}\\cdot q^{nq}}\\cdot\r\np^{np}\\cdot q^{nq}\\\\\r\n&amp;=\\dfrac{1}{\\sqrt{2\\pi npq}}\r\n\\end{aligned}\\)\r\n\\(\\star\\)\r\nC.4-6\r\n考虑直接计算这两个极限的值：\\(\\displaystyle{\\lim_{n\\rightarrow\\infty}b\\left(0;n,\\dfrac{1}{n}\\right),\\lim_{n\\rightarrow\\infty}b\\left(1;n,\\dfrac{1}{n}\\right)}\\)。\r\n\\(\\begin{aligned}\r\n\\lim_{n\\rightarrow\\infty}b\\left(0;n,\\dfrac{1}{n}\\right)&amp;=\\lim_{n\\rightarrow\\infty}\\dbinom{n}{0}\\left(\\dfrac{1}{n}\\right)^0\\left(1-\\dfrac{1}{n}\\right)^n\\\\\r\n&amp;=\\lim_{n\\rightarrow\\infty}\\left(1-\\dfrac{1}{n}\\right)^n\\\\\r\n&amp;=\\dfrac{1}{e}\\\\\r\n\\lim_{n\\rightarrow\\infty}b\\left(1;n,\\dfrac{1}{n}\\right)&amp;=\\lim_{n\\rightarrow\\infty}\\dbinom{n}{1}\\left(\\dfrac{1}{n}\\right)^1\\left(1-\\dfrac{1}{n}\\right)^{n-1}\\\\\r\n&amp;=\\lim_{n\\rightarrow\\infty}\\left(1-\\dfrac{1}{n}\\right)^{n-1}\\\\\r\n&amp;=\\lim_{n\\rightarrow\\infty}\\dfrac{n}{n-1}\\cdot\\left(1-\\dfrac{1}{n}\\right)^n\\\\\r\n&amp;=\\left(\\lim_{n\\rightarrow\\infty}\\dfrac{n}{n-1}\\right)\\cdot\\left(\\lim_{n\\rightarrow\\infty}\\left(1-\\dfrac{1}{n}\\right)^n\\right)\\\\\r\n&amp;=1\\cdot\\dfrac{1}{e}\\\\\r\n&amp;=\\dfrac{1}{e}\r\n\\end{aligned}\\)\r\n\\(\\star\\)\r\nC.4-7\r\n根据二项分布的定义，可以直接计算出两个人抛出正面次数的概率：\r\n\\[\\sum_{k=0}^n\\left(\\dbinom{n}{k}\\left(\\dfrac{1}{2}\\right)^k\\left(1-\\dfrac{1}{2}\\right)^{n-k}\\right)^2=\\dfrac{1}{4^n}\\cdot\\sum_{k=0}^n\r\n\\dbinom{n}{k}^2\\]\r\n将这\\(2n\\)次实验的结果（硬币）排成一排，将其分成前\\(n\\)，后\\(n\\)两个硬币序列。任意在这\\(2n\\)个硬币中选择\\(n\\)个：\r\n\r\n前\\(n\\)个硬币中，如果被选中了，那么就正面朝上，否则反面朝上。\r\n后\\(n\\)个硬币中，如果被选中了，那么就反面朝上，否则正面朝上。\r\n\r\n可以发现，经过一次选择后，前\\(n\\)个硬币中和后\\(n\\)个硬币中，正面朝上的个数总是相同的，并且每种情况都是等概率出现的。出现这种情况的概率是\\(\\dfrac{1}{2^{2n}}\\cdot\r\n\\dbinom{2n}{n}\\)。\r\n这两个概率描述的是同一件事情，因此得到等式：\r\n\\[\\sum_{k=0}^n\r\n\\dbinom{n}{k}^2=\\dbinom{2n}{n}\\]\r\n\\(\\star\\)\r\nC.4-8\r\n令\\(k=\\lambda n\\)，那么有：\r\n\\(\\begin{aligned}\r\nb\\left(k;n,\\dfrac{1}{2}\\right)&amp;=b\\left(\\lambda\r\nn;n,\\dfrac{1}{2}\\right)\\\\\r\n&amp;=\\dbinom{n}{\\lambda n}\\left(\\dfrac{1}{2}\\right)^{\\lambda\r\nn}\\left(1-\\dfrac{1}{2}\\right)^{n-\\lambda n}\\\\\r\n&amp;=\\dbinom{n}{\\lambda n}\\cdot\\dfrac{1}{2^n}\\\\\r\n&amp;\\le 2^{nH(\\lambda)} \\cdot2^{-n}&amp;\\qquad(A)\\\\\r\n&amp;=2^{nH(\\lambda)-n}\\\\\r\n&amp;=2^{nH(k/n)-n}\r\n\\end{aligned}\\)\r\n其中，变换\\((A)\\)来自不等式\\((C.7):\\dbinom{n}{k}=\\dfrac{n^n}{k^k(n-k)^{n-k}}\\)\r\n\\(\\star\\)\r\nC.4-9\r\n将\\(b(i;n,p)\\)实验分开考虑：考虑另外的\\(n\\)次独立的伯努利实验，对于\\(1\\le i\\le n\\)，第\\(i\\)次实验成功的概率为\\(p_i&#39;=p\\)。令\\(X&#39;\\)为这\\(n\\)次伯努利实验成功的次数。对于\\(1\\le i\\le n\\)，都有\\(p_i\\le p_i&#39;\\)。\r\n那么，可以得到\\(\\displaystyle{\\Pr\\{X&#39;\\le k\\}}=\\sum_{i=0}^k\r\nb(i,n,p)\\)。\r\n根据题目C.4-10的结论，有\\(\\Pr\\{X&#39;\\ge\r\nk\\}\\ge \\Pr\\{X\\ge k\\}\\)。\r\n最终，由此得到\\(\\displaystyle{\\Pr\\{X&lt;\r\nk\\}\\ge\\Pr\\{X&#39;&lt; k\\}=\\sum_{i=0}^{k-1} b(i,n,p)}\\)。\r\n\\(\\star\\)\r\nC.4-10\r\n设\\(V_1,V_2,V_3,\\dots,V_n\\)是\\(n\\)个独立同分布的随机变量，它们都服从\\([0,1]\\)上的均匀分布。\r\n那么对于\\(1\\le i\\le\r\nn\\)，令示性随机变量\\(X_i\\)表示\\(V_i\\le\r\np_i\\)，如果\\(V_i\\le\r\np_i\\)，那么\\(X_i=1\\)，否则\\(X_i=0\\)。类似的，定义示性随机变量\\(X_i&#39;\\)表示\\(V_i\\le p_i&#39;\\)。\r\n那么有\\(\\displaystyle{X&#39;=\\sum_{i=1}^n\r\nX_i&#39;,X=\\sum_{i=1}^n X_i}\\)。\r\n由于\\(p_i&#39;\\ge\r\np_i\\)，对于随机变量\\(X_i,X_i&#39;\\)的值，有如下几种情况：\r\n\r\n如果\\(V_i\\le p_i\\)，那么\\(X_i=X_i&#39;=1\\)。\r\n如果\\(p_i&lt; V_i\\le\r\np_i&#39;\\)，那么\\(X_i=0,X_i&#39;=1\\)。\r\n如果\\(p_i&#39;&lt; V_i\\)，那么\\(X_i=X_i&#39;=0\\)。\r\n\r\n也就是说，对于\\(\\forall s \\in\r\n[0,1],X_i&#39;(s)\\ge X_i(s)\\)均成立。\r\n那么对于任意从随机变量序列\\(\\{V_i\\}\\)取样得到的\\(\\{v_i\\}\\)，都有\\(X&#39;(\\{v_i\\})\\ge X(\\{v_i\\})\\)。\r\n因此根据题目C.3-7的结论，对于\\(\\forall 0\\le\r\nk\\le n\\)，都有\\(\\Pr\\{X&#39;\\ge\r\nk\\}\\ge\\Pr\\{X\\ge k\\}\\).\r\n","categories":["算法导论"]},{"title":"算法导论A.2 Exercises 答案","url":"/introduction-to-algorithms/appendix-a/exercises-2/","content":"\r\nA.2-1\r\n\\[\\begin{aligned}\r\n\\sum_{k=1}^n\\dfrac{1}{k^2}&amp;=1+\\sum_{k=2}^n\\dfrac{1}{k^2} \\\\\r\n&amp;\\le 1+\\sum_{k=2}^n\\dfrac{1}{k(k-1)}\\\\\r\n&amp;= 1+\\sum_{k=2}^n\\left(\\dfrac{1}{k-1}-\\dfrac{1}{k}\\right)\\\\\r\n&amp;=1+1-\\dfrac{1}{n}\\\\\r\n&amp;&lt;2\r\n\\end{aligned}\\]\r\n因此这个求和式有常数上界\\(2\\)。\r\nA.2-2\r\n如果\\(n=2^m\\)，并且\\(n\\)恰好是\\(2\\)次幂，那么有\r\n\\[\\sum_{k=0}^{\\lfloor\\lg n\\rfloor}\r\n\\left\\lceil\\dfrac{n}{2^k}\\right\\rceil=\\sum_{k=0}^{m}\r\n\\dfrac{n}{2^k}=\\sum_{k=0}^m 2^k=2n-1\\]\r\n那么令\\(n&#39;=2^{\\lceil\\lg\r\nn\\rceil}\\)，可以发现，\\(\\dfrac{n&#39;}{n}=2^{\\lceil\\lg n\\rceil-\\lg\r\nn}&lt;2^1=2\\)，也就是\\(n&#39;&lt;2n\\)。\r\n那么有\r\n\\[\\sum_{k=0}^{\\lfloor\\lg\r\nn\\rfloor}\\left\\lceil\\dfrac{n}{2^k}\\right\\rceil\\le\\sum_{k=0}^{\\lfloor\\lg\r\nn&#39;\\rfloor}\\left\\lceil\\dfrac{n&#39;}{2^k}\\right\\rceil=2n&#39;-1&lt;4n-1=O(n)\\]\r\nA.2-3\r\n对于级数\\(\\displaystyle{\\sum_{k=1}^n\r\n\\dfrac{1}{k}}\\)的值。考虑它前缀的一部分，也就是\\(\\displaystyle{\\sum_{k=1}^{2^{\\lfloor\\lg\r\nn\\rfloor-1}} \\dfrac{1}{k}}\\)，采用推导\\((A.17)\\)类似的做法，那么有：\r\n\\[\\begin{aligned}\r\n\\sum_{k=1}^n\\dfrac{1}{k}&amp;&gt;\\sum_{k=1}^{2^{\\lfloor\\lg\r\nn\\rfloor-1}}\\dfrac{1}{k}\\\\\r\n&amp;=\\sum_{i=0}^{\\lfloor\\lg n\\rfloor}\\sum_{j=0}^{2^i-1}\r\n\\dfrac{1}{2^i+j}\\\\\r\n&amp;&gt;\\sum_{i=0}^{\\lfloor\\lg n\\rfloor}\\sum_{j=0}^{2^i-1}\r\n\\dfrac{1}{2^{i+1}}\\\\\r\n&amp;=\\sum_{i=0}^{\\lfloor\\lg n\\rfloor}\\dfrac{1}{2}\\\\\r\n&amp;&gt;\\dfrac{1}{2}\\lfloor\\lg n\\rfloor\\\\\r\n&amp;=\\Omega(\\lg n)\r\n\\end{aligned}\\]\r\nA.2-4\r\n直接代入\\((A.18)\\)式进行逼近。\r\n上界：\r\n\\[\\sum_{n=1}^k k^3\\le \\int_{1}^{n+1} x^3\r\ndx=\\left.\\dfrac{x^4}{4}\\right|_{1}^{n+1}=\\dfrac{(n+1)^4-1}{4}\\]\r\n下界：\r\n\\[\\sum_{n=1}^k k^3\\ge \\int_{0}^{n} x^3\r\ndx=\\left.\\dfrac{x^4}{4}\\right|_{0}^{n}=\\dfrac{n^4}{4}\\]\r\n因此最终得到\\(\\sum_{k=1}^nk^3\\)的估计为：\r\n\\[\\dfrac{n^4}{4}\\le \\sum_{k=1}^n\r\nk^3\\le\\dfrac{(n+1)^4-1}{4}\\]\r\nA.2-5\r\n\\(f(x)=\\dfrac{1}{x}\\)是一个单调递减函数，考虑它的上界：\r\n\\[\\int_{0}^n \\dfrac{1}{x}dx\\]\r\n可以发现，这个积分值是无穷大。\r\n因此，用积分法估计调和级数的界限是失败的。\r\n","categories":["算法导论"]},{"title":"算法导论C Problems 答案","url":"/introduction-to-algorithms/appendix-c/problems/","content":"\r\nC-1\r\na\r\n如果坚持自己的选择，那么可以忽略后来主持人的开门操作，概率是\\(\\dfrac{1}{3}\\)。\r\n如果坚持转换，考虑如下情形：\r\n\r\n一开始选到的是车（有\\(\\dfrac{1}{3}\\)的概率），那么主持人选择一个羊的门打开后，换门将会换到的必定是羊。此时中将的概率是\\(0\\)。\r\n一开始选到的是羊（有\\(\\dfrac{2}{3}\\)的概率），那么主持人选择一个羊的门打开后，换门将会换到的必定是车。此时中将的概率是\\(1\\)。\r\n\r\n最终概率是\\(\\dfrac{1}{3}\\cdot\r\n0+\\dfrac{2}{3}\\cdot 1=\\dfrac{2}{3}\\)。\r\n最终，坚持换门的策略是更优秀的。\r\nb\r\n\\[\\begin{array}{|l|l|l|l|l|}\r\n\\hline\r\n\\text{is car} &amp; \\text{can switch} &amp; \\text{do switch} &amp; p\r\n&amp; \\text{is win}\\\\\r\n\\hline\r\n\\text{Yes}&amp;\\text{Yes}&amp;\\text{Yes} &amp; \\dfrac{1}{3}\\cdot\r\np_{\\text{right}}\\cdot p_{\\text{switch}}  &amp; \\text{No}\\\\\r\n\\hline\r\n\\text{Yes}&amp;\\text{Yes}&amp;\\text{No} &amp; \\dfrac{1}{3}\\cdot\r\np_{\\text{right}}\\cdot (1-p_{\\text{switch}})  &amp; \\text{Yes}\\\\\r\n\\hline\r\n\\text{Yes}&amp;\\text{No}&amp;\\text{No} &amp; \\dfrac{1}{3}\\cdot\r\n(1-p_{\\text{right}})  &amp; \\text{Yes}\\\\\r\n\\hline\r\n\\text{No}&amp;\\text{Yes}&amp;\\text{Yes} &amp; \\dfrac{2}{3}\\cdot\r\np_{\\text{wrong}}\\cdot p_{\\text{switch}}  &amp; \\text{Yes}\\\\\r\n\\hline\r\n\\text{No}&amp;\\text{Yes}&amp;\\text{No} &amp; \\dfrac{2}{3}\\cdot\r\np_{\\text{wrong}}\\cdot (1-p_{\\text{switch}})  &amp; \\text{No}\\\\\r\n\\hline\r\n\\text{No}&amp;\\text{No}&amp;\\text{No} &amp; \\dfrac{2}{3}\\cdot\r\n(1-p_{\\text{wrong}})  &amp; \\text{No}\\\\\r\n\\hline\r\n\\end{array}\\]\r\nc\r\n将胜利的三个事件加起来的概率即可得到：\r\n\\(F(p_{\\text{right}},p_{\\text{wrong}},p_{\\text{switch}})=\\dfrac{1}{3}\\cdot\r\np_{\\text{right}}\\cdot (1-p_{\\text{switch}})+\\dfrac{1}{3}\\cdot\r\n(1-p_{\\text{right}})+\\dfrac{2}{3}\\cdot p_{\\text{wrong}}\\cdot\r\np_{\\text{switch}}=\\dfrac{1}{3}(2 p_{\\text{wrong}}\r\np_{\\text{switch}}-p_{\\text{right}} p_{\\text{switch}} + 1)\\)\r\nd\r\n一个很直观的想法是：只要参赛者选对了就必定给他机会换，只要选错了就不给参赛者机会换。也就是说，\\(p_{\\text{right}}=1,p_{\\text{wrong}}=0\\)。\r\n从数学上的角度，相当于是让式子\\(F(p_{\\text{right}},p_{\\text{wrong}},p_{\\text{switch}})=\\dfrac{1}{3}(p_{\\text{switch}}(2\r\np_{\\text{wrong}}-p_{\\text{right}}) + 1)\\)的值最小。\r\n由于\\(p_{\\text{switch}}&gt;0\\)，因此令\\(p_{\\text{right}}=1,p_{\\text{wrong}}=0\\)，就能使这个式子的值最小。\r\ne\r\n令\\(p_{\\text{switch}}=0\\)，那么胜利的概率为\\(\\dfrac{1}{3}\\)，将含有\\(p_{\\text{right}},p_{\\text{wrong}}\\)的项都消去了。因此，无论此时主持人如何选择\\(p_{\\text{right}},p_{\\text{wrong}}\\)的值，局面都是一样的，或者是最优的。\r\nf\r\n从数学上的角度，相当于是让式子\\(F(p_{\\text{right}},p_{\\text{wrong}},p_{\\text{switch}})=\\dfrac{1}{3}(p_{\\text{switch}}(2\r\np_{\\text{wrong}}-p_{\\text{right}}) + 1)\\)的值最大。\r\n\r\n当\\(2\r\np_{\\text{wrong}}-p_{\\text{right}}&gt;0\\)时，令\\(p_{\\text{switch}}=1\\)，那么\\(F(p_{\\text{right}},p_{\\text{wrong}},p_{\\text{switch}})\\)可以得到最大值\\(\\dfrac{1}{3}(2\r\np_{\\text{wrong}}-p_{\\text{right}}+1)\\)。\r\n当\\(2\r\np_{\\text{wrong}}-p_{\\text{right}}=0\\)时，不需要考虑\\(p_{\\text{switch}}\\)的值，总有\\(F(p_{\\text{right}},p_{\\text{wrong}},p_{\\text{switch}})=\\dfrac{1}{3}\\)。\r\n当\\(2\r\np_{\\text{wrong}}-p_{\\text{right}}&lt;0\\)时，令\\(p_{\\text{switch}}=0\\)，那么\\(F(p_{\\text{right}},p_{\\text{wrong}},p_{\\text{switch}})\\)可以得到最大值\\(\\dfrac{1}{3}\\)。\r\n\r\ng\r\n由于\\(p_{\\text{wrong}}\\in[0,1],p_{\\text{right}}\\in\r\n[0,1]\\)，因此\\(2p_{\\text{wrong}}-p_{\\text{right}}\\in[-1,2]\\)。\r\n令\\(f(x)=\\dfrac{kx+1}{3}\\)，那么此问题相当于寻找一个\\(x_0\\in[0,1]\\)，使得当\\(k\\in[-1,2]\\)时，\\(f(x_0)\\)的最小值最大。\r\n由于\\(x_0\\ge 0\\)总是成立，因此\\(f(x_0)\\)的最小值在\\(k=-1\\)时取到，为\\(\\dfrac{-x_0+1}{3}\\)。为保证最大，只能取\\(x_0=0\\)。\r\n因此，令\\(p_{\\text{switch}}=0\\)，就能说明无论\\(p_{\\text{wrong}},p_{\\text{right}}\\)怎么取，\\(F(p_{\\text{right}},p_{\\text{wrong}},p_{\\text{switch}})\\)的最小值都能最大。\r\nh\r\n\\(\\begin{aligned}\r\n\\Pr\\{\\text{is win=Yes}\\mid \\text{can\r\nswitch=Yes}\\}&amp;=\\dfrac{\\Pr\\{\\text{is win=Yes}\\land \\text{can\r\nswitch=Yes}\\}}{\\Pr\\{\\text{can switch=Yes}\\}}\\\\\r\n&amp;=\\dfrac{\\dfrac{1}{3}\\cdot p_{\\text{right}}\\cdot\r\n(1-p_{\\text{switch}})+ \\dfrac{2}{3}\\cdot p_{\\text{wrong}}\\cdot\r\np_{\\text{switch}}}{\\dfrac{1}{3}\\cdot p_{\\text{right}}\\cdot\r\np_{\\text{switch}}+\\dfrac{1}{3}\\cdot p_{\\text{right}}\\cdot\r\n(1-p_{\\text{switch}})+ \\dfrac{2}{3}\\cdot p_{\\text{wrong}}\\cdot\r\np_{\\text{switch}}+\\dfrac{2}{3}\\cdot p_{\\text{wrong}}\\cdot\r\n(1-p_{\\text{switch}}) }\\\\\r\n&amp;=\\dfrac{p_{\\text{right}}-p_{\\text{right}}p_{\\text{switch}}+2p_{\\text{wrong}}p_{\\text{switch}}}{p_{\\text{right}}+2\r\np_{\\text{wrong}}}\r\n\\end{aligned}\\)\r\n由于现在主持人已经给予了机会给参赛者进行换门，因此说明\\(p_{\\text{right}}&gt;0\\lor\r\np_{\\text{wrong}}&gt;0\\)，因此有\\(p_{\\text{right}}+2\r\np_{\\text{wrong}}&gt;0\\)。\r\ni\r\n令\\(G(p_{\\text{right}},p_{\\text{wrong}},p_{\\text{switch}})=\\dfrac{p_{\\text{right}}-p_{\\text{right}}p_{\\text{switch}}+2p_{\\text{wrong}}p_{\\text{switch}}}{p_{\\text{right}}+2\r\np_{\\text{wrong}}}\\)。\r\n当\\(p_{\\text{switch}}=\\dfrac{1}{2}\\)，有\\(G(p_{\\text{right}},p_{\\text{wrong}},\\dfrac{1}{2})=\\dfrac{p_{\\text{right}}-p_{\\text{right}}\\cdot\\dfrac{1}{2}+2p_{\\text{wrong}}\\cdot\\dfrac{1}{2}}{p_{\\text{right}}+2\r\np_{\\text{wrong}}}=\\dfrac{1}{2}\\)\r\n考虑二元函数\\(f_k(x,y)=\\dfrac{x-xk+2ky}{x+2y}\\)在\\(x,y\\in[0,1]\\)时的值。\r\n可以知道，\\(f_k(1,0)=1-k,f(0,1)=k\\)。因此，只要\\(k\\neq \\dfrac{1}{2}\\)，总存在\\((x_0,y_0)\\in\\{(0,1),(1,0)\\}\\)，使得\\(f(x,y)&lt;\\dfrac{1}{2}\\)。\r\n回到题目上，这说明只要\\(p_{\\text{switch}}\\neq\r\n\\dfrac{1}{2}\\)，主持人就可以选择适当的\\(p_{\\text{wrong}},p_{\\text{right}}\\)使得\\(G(p_{\\text{right}},p_{\\text{wrong}},p_{\\text{switch}})\\)的最小值小于\\(\\dfrac{1}{2}\\)。\r\nj\r\n使用题目C-1.i的结论。在不知道主持人的策略的情况下，如果他提供了更换的机会，那么当选择\\(p_{\\text{switch}}=\r\n\\dfrac{1}{2}\\)时，无论主持人是否带有恶意，参赛者都能够以\\(\\dfrac{1}{2}\\)的概率得到汽车。如果\\(p_{\\text{switch}}\\neq\r\n\\dfrac{1}{2}\\)，只要主持人带有恶意，参赛者获得汽车的概率就不是最大的。\r\n这一道题说明，如果题目背景假设不同，那么最终得出来的答案和策略完全不一样。\r\nC-2\r\na\r\n由于没有讲究桶中的球的先后顺序，因此独立考虑每个球任意的放法。每个球都可以选择\\(n\\)个桶中的一个桶的放法。因此最终一共有\\(b^n\\)种方法。\r\nb\r\n本题讲究了桶中球的顺序。先将第\\(1\\)个桶的球按顺序拿出来，再将第\\(2\\)个桶的球按顺序放在第\\(1\\)个桶拿出来的球的后面……最后将第\\(n\\)个桶的球按顺序放在第\\(n-1\\)个桶的球的后面。如此拿出所有的球后，\\(n!\\)个不同球的排序指定了桶中球的顺序。\r\n那么现在考虑假设\\(n\\)个球都是一样的，将\\(n\\)个球放在\\(b\\)个桶中（桶可以留空）。那么可以考虑将这\\(b\\)个相同的球排成一排，然后用\\(b-1\\)个板插入到这些球的空隙，隔成了\\(b\\)份，第\\(i\\)份球投入第\\(i\\)个桶中。由于可能会有留空，这意味着可能有同一块板插入同一空隙中。这时考虑将\\(b\\)个球加进来，那么此时问题就转化成了桶不能留空的条件。这意味着当前这\\(b+n-1\\)个空隙可以分别插入\\(b-1\\)块板。此时有\\(\\dbinom{n+b-1}{b-1}\\)种插法。\r\n再考虑上球的顺序，那么最终有\\(\\dbinom{b+n-1}{b-1}\\cdot\r\nn!=\\dfrac{(b+n-1)!}{(b-1)!}\\)种方法。\r\nc\r\n本题和C-2-b题的区别在于仅需要假设球是一样的即可，不需要有序。因此有\\(\\dbinom{n+b-1}{b-1}\\)种方法。\r\nd\r\n这\\(b\\)个桶最多可以放一个球。因此可以视为从\\(b\\)个桶中选择\\(n\\)个桶来放这\\(n\\)个一样的球，因此有\\(\\dbinom{b}{n}\\)种方法。\r\ne\r\n可以考虑将这\\(b\\)个相同的球排成一排，然后用\\(b-1\\)个板插入到这些球的空隙，隔成了\\(b\\)份，第\\(i\\)份球投入第\\(i\\)个桶中。由于桶不能留空，那么同一空隙下最多插\\(1\\)块板。这意味着当前这\\(n-1\\)个空隙可以分别插入\\(b-1\\)块板。此时有\\(\\dbinom{n-1}{b-1}\\)种方法。\r\n","categories":["算法导论"]},{"title":"算法导论C.5 Exercises 答案","url":"/introduction-to-algorithms/appendix-c/exercises-5/","content":"\r\n\\(\\star\\)\r\nC.5-1\r\n可以知道，前者的概率值为\\(p_1=b\\left(n;2n,\\dfrac{1}{2}\\right)=\\dbinom{2n}{n}\\dfrac{1}{2^{2n}}\\)，后者的概率值为\\(p_2=b\\left(n;n,\\dfrac{1}{2}\\right)=\\dfrac{1}{2^n}\\)。\r\n那么有\r\n\\(\\begin{aligned}\r\n\\dfrac{p_1}{p_2}&amp;=\\dbinom{2n}{n}\\dfrac{1}{2^n}\\\\\r\n&amp;=\\dfrac{1}{2^n}\\cdot \\prod_{i=1}^n\\dfrac{n+i}{i}\\\\\r\n&amp;=\\dfrac{1}{2^n}\\cdot \\prod_{i=1}^n\\left(\\dfrac{n}{i} + 1\\right)\\\\\r\n&amp;\\ge \\dfrac{1}{2^n}\\cdot \\prod_{i=1}^n2\\\\\r\n&amp;=1\r\n\\end{aligned}\\)\r\n因此\\(p_1\\ge p_2\\)。\r\n\\(\\star\\)\r\nC.5-2\r\n推论C.6的证明如下：\r\n对于这\\(n\\)次伯努利实验\\(A\\)，我们构造出另外一组伯努利实验\\(B\\)：如果第\\(i\\)次实验的结果在\\(A\\)中视为成功，那么在\\(B\\)中视为失败；如果在\\(A\\)中视为失败，那么在\\(B\\)中视为成功。因此，如果随机变量\\(X,Y\\)分别表示在实验\\(A,B\\)中成功的次数，那么有\\(X+Y=n\\)。\r\n那么，\\(Y\\)也服从参数为\\((n,q)\\)的二项分布，即\\(\\Pr\\{Y=k\\}=b(k;n,q)=\\Pr\\{X=n-k\\}\\)。\r\n最终有\\(\\Pr\\{X&gt;k\\}=\\Pr\\{Y&lt;\r\nn-k\\}\\)。并且，由于已知\\(np&lt;k&lt;n\\)，那么有\\(0&lt; n-k&lt; nq\\)。根据定理C.4，有\r\n\\(\\begin{aligned}\r\n\\Pr\\{X&gt;k\\}&amp;=\\Pr\\{Y&lt; n-k\\}\\\\\r\n&amp;&lt;\\dfrac{(n-k)p}{nq-(n-k)}b(n-k;n,q)\\\\\r\n&amp;=\\dfrac{(n-k)p}{k-np}b(k;n,p)\\\\\r\n\\end{aligned}\\)\r\n推论C.7的证明过程将沿用证明推论C.6时的数学符号。\r\n由于已知\\((np+n)/2&lt; k&lt;\r\nn\\)成立，那么有\\(0&lt; n-k&lt;\r\nnq/2\\)。根据定理C.5，有\r\n\\(\\dfrac{\\Pr\\{X&gt;k\\}}{\\Pr\\{X&gt;k-1\\}}=\\dfrac{\\Pr\\{Y&lt;n-k\\}}{\\Pr\\{Y&lt;n-k+1\\}}&lt;\\dfrac{1}{2}\\)。\r\n\\(\\star\\)\r\nC.5-3\r\n根据定理C.4，代入\\(p=\\dfrac{a}{a+1}\\)，那么有\\(\\displaystyle{\\sum_{i=0}^{k-1}\\dbinom{n}{i}\\left(\\dfrac{a}{a+1}\\right)^i\\left(\\dfrac{1}{a+1}\\right)^{n-i}&lt;\\dfrac{k/(a+1)}{na/(a+1)-k}b\\left(k;n,\\dfrac{a}{a+1}\\right)}\\)。\r\n化简后即可得到\\(\\displaystyle{\\sum_{i=0}^{k-1}\\dbinom{n}{i}a^i&lt;(a+1)^n\\dfrac{k}{na-k(a+1)}b\\left(k;n,\\dfrac{a}{a+1}\\right)}\\)。\r\n\\(\\star\\)\r\nC.5-4\r\n\\(\\begin{aligned}\r\n\\sum_{i=0}^{k-1} p^i q^{n-i}&amp;\\le\r\n\\sum_{i=0}^{k-1}\\dbinom{n}{i}  p^iq^{n-i}\\\\\r\n&amp;=\\sum_{i=0}^{k-1} b(i,n,p)\\\\\r\n&amp;\\le \\dfrac{kq}{np-k}b(k,n,p) &amp;\\qquad(A)\\\\\r\n&amp;\\le \\dfrac{kq}{np-k}\r\n\\left(\\dfrac{np}{k}\\right)^k\\left(\\dfrac{nq}{n-k}\\right)^{n-k}\r\n&amp;\\qquad(B)\r\n\\end{aligned}\\)\r\n其中，步骤\\((A)\\)使用了定理C.4，步骤\\((B)\\)使用了定理C.1。\r\n\\(\\star\\)\r\nC.5-5\r\n对于这\\(n\\)次伯努利实验\\(A\\)，我们构造出另外一组伯努利实验\\(B\\)：如果第\\(i\\)次实验的结果在\\(A\\)中视为成功，那么在\\(B\\)中视为失败；如果在\\(A\\)中视为失败，那么在\\(B\\)中视为成功。因此，如果随机变量\\(X,Y\\)分别表示在实验\\(A,B\\)中成功的次数，那么有\\(X+Y=n,\\Pr\\{Y=k\\}=\\Pr\\{X=n-k\\}\\)。并且可以知道，实验\\(B\\)中的所有成功概率的平均值为\\(n-\\mu\\)。\r\n因此根据定理C.8，对于所有\\(r&gt;n-\\mu\\)，都有\\(\\Pr\\{Y-(n-\\mu)&gt;r\\}=\\Pr\\{Y&gt;(n-\\mu)+r\\}\\le\\left(\\dfrac{(n-\\mu)e}{r}\\right)^r\\)。\r\n那么得到\r\n\\(\\begin{aligned}\r\n\\Pr\\{\\mu -X\\ge r\\}&amp;=\\Pr\\{X\\le n-((n-\\mu)+r)\\}\\\\\r\n&amp;=\\Pr\\{Y&gt;(n-\\mu)+r\\}\\\\\r\n&amp;\\le\\left(\\dfrac{(n-\\mu)e}{r}\\right)^r\r\n\\end{aligned}\\)\r\n将以上结论代入\\(\\mu\r\n=np\\)，那么有\\(\\Pr\\{np-X\\ge\r\nr\\}\\le\\left(\\dfrac{nqe}{r}\\right)^r\\)。\r\n\\(\\star\\)\r\nC.5-6\r\n考虑先证明Hint: \\(p_ie^{\\alpha\r\nq_i}+q_ie^{-\\alpha p_i}\\le e^{\\alpha^2/2}\\)。令\\(p=p_i,q=q_i,f(\\alpha)=e^{\\alpha^2/2}-(pe^{\\alpha\r\nq}+qe^{-\\alpha p})\\)，那么相当于证明对于所有\\(x\\ge 0,f(x)\\ge 0\\)恒成立。\r\n那么有\\(f&#39;(x)=pq(e^{-px}-e^{qx})+xe^{x^2/2},f&#39;&#39;(x)=e^{x^2/2}+x^2e^{x^2/2}-pq(pe^{-px}+qe^{qx}),f&#39;(0)=0,f&#39;&#39;(0)=1-pq\\).\r\n为此，通过证明\\(f&#39;&#39;(x)&gt;0\\)恒成立，从而\\(f&#39;(x)\\)是递增的，\\(f&#39;(x)\\ge\r\nf&#39;(0)=0\\)恒成立，更进一步说明\\(f(x)\\ge\r\nf(0)=0\\)恒成立。从而完成Hint的证明。因此，为了证明\\(f&#39;&#39;(x)&gt;0\\)，可以通过证明\\(e^{x^2/2}&gt;pq(pe^{-px}+qe^{qx})\\)来完成。对\\(pq(pe^{-px}+qe^{qx})\\)更进一步进行缩放，有\r\n\\(\\begin{aligned}\r\npq(pe^{-px}+qe^{qx})&amp;\\le\r\n\\dfrac{1}{4}(pe^{-px}+qe^{qx})  &amp;\\qquad(A)\\\\\r\n&amp;\\le \\dfrac{1}{4}(pe^{qx}+qe^{qx})\\\\\r\n&amp;=\\dfrac{1}{4} e^{qx}\\\\\r\n&amp;\\le \\dfrac{1}{4} e^x &amp;\\qquad(B)\r\n\\end{aligned}\\)\r\n其中步骤\\((A)\\)是因为\\(p+q=1,p\\ge 0,q\\ge 0\\)，那么有\\(pq\\le\r\n\\dfrac{(p+q)^2}{4}=\\dfrac{1}{4}\\)；步骤\\((B)\\)使用了条件\\(q\\le 1\\)。\r\n最终证明\\(4e^{x^2/2}&gt;e^x\\)即可完成Hint证明。\r\n两边取对数，相当于证明\\(\\ln\r\n4+x^2/2&gt;x\\)，即证明\\(x^2-2x+4\\ln\r\n2&gt;0\\)。当\\(x&gt;0\\)时，这个不等式是显而易见的，那么Hint的证明完成。\r\n那么有\\(E\\left[e^{\\alpha(X_i-p_i)}\\right]=p_ie^{\\alpha\r\nq_i}+q_ie^{-\\alpha p_i}\\le e^{\\alpha^2/2}\\)。\r\n最终得到\\(\\displaystyle{E\\left[e^{\\alpha(X-\\mu)}\\right]=\\prod_{i=1}^n\r\nE\\left[e^{\\alpha(X_i-p_i)}\\right]\\le\r\ne^{n\\alpha^2/2}}\\)。因此有\r\n\\(\\begin{aligned}\r\n\\Pr\\{X-\\mu\\ge r\\}&amp;=\\Pr\\{e^{\\alpha(X-\\mu)}\\ge e^{\\alpha r}\\}\\\\\r\n&amp;=E\\left[e^{\\alpha(X-\\mu)}\\right] e^{-\\alpha r}\\\\\r\n&amp;\\le e^{n\\alpha^2/2-\\alpha r}\r\n\\end{aligned}\\)\r\n为了得到\\(\\Pr\\{X-\\mu\\ge\r\nr\\}\\)的确切下界，令\\(g(\\alpha)=n\\alpha^2/2-\\alpha\r\nr\\)。那么有\\(g&#39;(\\alpha)=n\\alpha-r,g&#39;&#39;(\\alpha)=n&gt;0\\)。令\\(g&#39;(\\alpha)=0\\)，那么有\\(\\alpha=r/n\\)。因此\\(g(\\alpha)\\)在\\(\\alpha=r/n\\)处取到最小值\\(-r^2/2n\\)。\r\n因此有\\(\\Pr\\{X-\\mu\\ge r\\}\\le\r\ne^{-r^2/2n}\\)。\r\n\\(\\star\\)\r\nC.5-7\r\n由于指数函数\\(y=e^x\\)是单调递增的，因此等式右边取到最小值，本质上是函数\\(g(\\alpha)=\\mu e^{\\alpha}-\\alpha\r\nr\\)取到最小值。\r\n那么有\\(g&#39;(\\alpha)=\\mu e^{\\alpha} -\r\nr\\)。令\\(g&#39;(\\alpha)=0\\)，可以得到\\(\\alpha=\\ln(r/\\mu)\\)。\r\n由于\\(g&#39;&#39;(\\alpha)=\\mu\r\ne^{\\alpha}&gt;0\\)恒成立，因此\\(g(\\alpha)\\)在\\(\\alpha=\\ln(r/\\mu)\\)处取到最小值，即\\(g(\\ln(r/\\mu))=r-r\\ln(r/\\mu)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论D.1 Exercises 答案","url":"/introduction-to-algorithms/appendix-d/exercises-1/","content":"\r\nD.1-1\r\n如果\\(A,B\\)是\\(n\\times n\\)对称矩阵，那么\\(\\forall 1\\le i,j\\le\r\nn,a_{ij}=a_{ji},b_{ij}=b_{ji}\\)都成立。\r\n令\\(C=A+B,D=A-B\\)，将两个式子相加或者相减，得到：\r\n\\(\\begin{aligned}\r\nc_{ij}=a_{ij}+b_{ij}=a_{ji}+b_{ji}=c_{ji}\\\\\r\nd_{ij}=a_{ij}-b_{ij}=a_{ji}-b_{ji}=d_{ji}\\\\\r\n\\end{aligned}\\)\r\n因此，矩阵\\(C,D\\)仍然是对称的。\r\nD.1-2\r\n令\\(a_{ij}^T\\)表示转置矩阵\\(A^T\\)的元素，也就是有\\(a_{ij}=a_{ji}^T\\)。同理，\\(b_{ij}^T\\)表示转置矩阵\\(B^T\\)的元素。\r\n对于\\((AB)^T\\)中的元素，有：\r\n\\(\\begin{aligned}\r\n(ab)^T_{ji}&amp;=(ab)_{ij}\\\\\r\n&amp;=\\sum_{k=1}^n a_{ik}\\cdot b_{kj}\\\\\r\n&amp;=\\sum_{k=1}^n a_{ki}^T\\cdot b_{jk}^T\\\\\r\n&amp;=\\sum_{k=1}^n b_{jk}^T\\cdot a_{ki}^T\\\\\r\n\\end{aligned}\\)\r\n可见，对于最后一行，\\(\\displaystyle{\\sum_{k=1}^n b_{jk}^T\\cdot\r\na_{ki}^T}\\)是计算\\(B^TA^T\\)矩阵乘法的单个元素的定义式。因此有\\((AB)^T=B^TA^T\\)。\r\n由\\((A^TA)^T=A^T(A^T)^T=A^TA\\)可知，\\(A^TA\\)是对称矩阵。\r\nD.1-3\r\n假设\\(A,B\\)是两个下三角矩阵。也就是说，对于\\(1\\le i&lt; j&lt; n\\)，都有\\(a_{ij}=b_{ij}=0\\)。\r\n令\\(C=AB\\)，那么有：\r\n\\(\\begin{aligned}\r\nc_{ij}&amp;=\\sum_{k=1}^n a_{ik}\\cdot b_{kj}\\\\\r\n&amp;=\\sum_{k=1}^{i-1} a_{ik}\\cdot b_{kj}+\\sum_{k=i}^{j} a_{ik}\\cdot\r\nb_{kj} + \\sum_{k=j+1}^n a_{ik}\\cdot b_{kj} \\\\\r\n&amp;=\\sum_{k=1}^{i-1} a_{ik}\\cdot 0+\\sum_{k=i}^{j} a_{ik}\\cdot b_{kj} +\r\n\\sum_{k=j+1}^n 0\\cdot b_{kj} \\\\\r\n&amp;=\\sum_{k=i}^{j} a_{ik}\\cdot b_{kj}\r\n\\end{aligned}\\)\r\n当\\(i&gt;j\\)时，剩下的求和项并不存在。因此此时\\(c_{ij}=0\\)，最终\\(C\\)为下三角矩阵。\r\nD.1-4\r\n令\\(C=PA\\)。那么有：\r\n\\[c_{ij}=\\sum_{k=1}^n p_{ik}\\cdot a_{kj}\r\n\\]\r\n如果对于某个特定的\\(1\\le k&#39;\\le\r\nn\\)，有\\(p_{ik&#39;}=1\\)，对于其他\\(k\\neq k&#39;,p_{ik}=0\\)，那么有\\(c_{ij}=a_{k&#39;j}\\)。这相当于将矩阵\\(A\\)的第\\(k&#39;\\)行的内容转移到第\\(i\\)行，列位置不变。根据排列矩阵的定义，这相当于是行变换。\r\n类似的，令\\(D=AP\\)。那么有\r\n\\[d_{ij}=\\sum_{k=1}^n a_{ik}\\cdot p_{kj}\r\n\\]\r\n如果对于某个特定的\\(1\\le k&#39;\\le\r\nn\\)，有\\(p_{k&#39;j}=1\\)，对于其他\\(k\\neq k&#39;,p_{kj}=0\\)，那么有\\(c_{ij}=a_{ik&#39;}\\)。这相当于将矩阵\\(A\\)的第\\(k&#39;\\)列的内容转移到第\\(j\\)列，行位置不变。根据排列矩阵的定义，这相当于是列变换。\r\n由于两个排列矩阵相乘，本质上是通过一个矩阵对另外一个排列进行重置，因此相乘结果仍然是排列矩阵。\r\n","categories":["算法导论"]},{"title":"算法导论D.2 Exercises 答案","url":"/introduction-to-algorithms/appendix-d/exercises-2/","content":"\r\nD.2-1\r\n由于\\(B,C\\)都是\\(A\\)的逆，因此有\\(AB=BA=I,AC=CA=I\\)。\r\n因此有\\(B=BI=B(AC)=(BA)C=C\\)。\r\nD.2-2\r\n不失一般性，假设\\(A\\)是一个下三角矩阵（对于一个上三角矩阵，将其进行转置即可），那么使用归纳法来证明行列式的值等于其主对角线上元素的乘积。\r\n\r\n当\\(A\\)是\\(1\\)下三角阶矩阵时，\\(\\det(A)=a_{11}\\)，此时\\(A\\)是下三角矩阵，原结论成立。\r\n当\\(A\\)是\\(n\\)下三角阶矩阵时，假设对于\\(1,2,3,\\dots,n-1\\)阶矩阵，原结论都成立。那么按照行列式的递归定义，有\\(\\displaystyle{\\det (A)=\\sum_{j=1}^n (-1)^{i+j}\r\na_{1j}\\det(A_{[1j]})=a_{11}\\det(A_{[11]})}\\)。\\(A[11]\\)显而易见是一个\\(n\\)阶下三角矩阵，因此有\\(\\displaystyle{\\det(A_{[11]})=\\prod_{i=2}^n\r\na_{ii}}\\)，那么有\\(\\displaystyle{\\det(A)=\\prod_{i=1}^n\r\na_{ii}}\\)。最终原结论成立。\r\n\r\n接下来证明下三角矩阵的逆仍然是下三角矩阵：\r\n令\\(P_1\\)表示将矩阵\\(A\\)的第\\(1\\)行进行变换的操作，它将\\(A\\)的第\\(1\\)行以某个倍数加到第\\(1,2,3,4,\\dots,n\\)行，最终使得\\(a_{11}=1,a_{i1}=0(i&gt;1)\\)，那么新矩阵为\\(P_1A\\)。类似的，\\(P_2\\)是将\\(P_1A\\)的第\\(2\\)行以某个倍数加到第\\(2,3,4,\\dots,n\\)行……最终，进行\\(n\\)次操作后，有\\(P_nP_{n-1}\\dots P_1A=I\\)。由于所有行\\(a_{i0}\\)都是由小于\\(i\\)的行线性表示出，因此所有\\(P_i\\)的矩阵都是下三角矩阵，因此它们的乘积\\(A^{-1}=P_nP_{n-1}\\dots\r\nP_1\\)也是下三角矩阵。\r\nD.2-3\r\n考虑使用归纳法证明\\(P\\)是可逆的，即证明\\(\\det(P)\\neq 0\\)。\r\n当\\(P\\)为\\(1\\)阶矩阵，原结论明显成立，因为\\(P=[1]\\)。\r\n当\\(P\\)为\\(n\\)阶矩阵时，假设对于\\(1,2,3,\\dots,n-1\\)阶矩阵都成立，那么根据排列矩阵的定义，令\\(p(i)\\)表示第\\(i\\)行为\\(1\\)的那个列。那么有\\(\\displaystyle{\\det (P)=\\sum_{j=1}^n (-1)^{i+j}\r\np_{1j}\\det(P_{[1j]})=(-1)^{1+p(1)}\\det(P_{[1,p(1)]})}\\)。\r\n考虑\\(n-1\\)阶矩阵\\(P_{[1,p(1)]}\\)。由于\\(P\\)的第\\(1\\)行只有第\\(p(1)\\)列元素为\\(1\\)，第\\(p(1)\\)列也只有第\\(1\\)行对的元素为\\(1\\)，因此去掉这一行和这一列后，其它元素的相对位置都不变。因此\\(P_{[1,p(1)]}\\)仍然是一个排列矩阵。那么有\\(\\det(P)=(-1)^{1+p(1)}\\det(P_{[1,p(1)]})\\neq\r\n0\\)，故\\(P\\)是可逆的。\r\n将矩阵\\(P\\)的行映射到\\(P^T\\)的列上，将\\(P\\)的列映射到\\(P^T\\)的行上，可以发现\\(P^T\\)和\\(P\\)一样，满足每一行每一列都只有一个元素\\(1\\)。因此\\(P^T\\)仍然是排列矩阵。\r\n考虑矩阵乘积\\(PP^T\\)，那么可以计算出\\(\\displaystyle{(PP^T)_{ij}=\\sum_{k=1}^k p_{ik}\\cdot\r\np^T_{k,j}=\\sum_{k=1}^k p_{ik}\\cdot\r\np_{jk}}\\)。根据排列矩阵对定义，当且仅当\\(i=j\\)时，才有\\((PP^T)_{ij}=1\\)。因此\\(PP^T=I\\)，即\\(P^T\\)是\\(P\\)的逆。\r\nD.2-4\r\n构造矩阵\\(C,D\\)。其中矩阵\\(C,D\\)满足\r\n\\[\r\n\\begin{aligned}\r\n&amp;c_{i,j}=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i=j\\lor (i=i_0\\land j=j_0) \\\\\r\n  &amp;0  &amp; &amp; \\text{otherwise}\r\n\\end{aligned}\\right.\r\n\\\\\r\n&amp;d_{i,j}=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i=j \\\\\r\n  &amp;-1  &amp; &amp; \\text{if}\\quad i=i_0\\land j=j_0 \\\\\r\n  &amp;0  &amp; &amp; \\text{otherwise}\r\n\\end{aligned}\\right.\r\n\\end{aligned}\r\n\\]\r\n那么有\\(A&#39;=CA,B&#39;=BD\\)。为证明\\(B&#39;\\)是\\(A&#39;\\)的逆矩阵，只需证明\\(A&#39;B&#39;=I\\)，即\\(CABD=C(AB)D=CD=I\\)即可。\r\n令\\(W_{i,j}\\)表示除了\\(w_{i,j}=1\\)以外，其它所有元素都为\\(0\\)的矩阵。那么有\\(CD=(I+W_{i,j})(I-W_{i,j})=I+W_{i,j}-W_{i,j}+O=I\\)，从而原题得证。\r\nD.2-5\r\n本题的主要证明之处在于，对于任何可逆非实数矩阵\\(A\\)，无法构造出可逆实数矩阵\\(B\\)，使得\\(AB=I\\)。这是显而易见的。假设\\(AB=I\\)，那么右乘一个\\(B^{-1}\\)，有\\(A=B^{-1}\\)。由于\\(I,B^{-1}\\)都是实数矩阵，而\\(A\\)是非实数矩阵，因此这个假设必定不成立。故原结论正确。\r\nD.2-6\r\n由\\((A^{-1})^{T}=(A^T)^{-1}=A^{-1}\\)可知，如果\\(A\\)是对称的，那么\\(A^{-1}\\)也是对称的。由\\((BAB^T)^T=(B^T)^TA^TB^T=BAB^T\\)可知，\\(BAB^T\\)是对称的。\r\nD.2-7\r\n通过证明这个命题的逆否命题，从而使得原命题得证。将矩阵\\(A\\)看作是一系列列向量的组合\\(A=(a_1,a_2,a_3,\\dots,a_n)\\)，如果存在一组非零向量\\(x=(x_1,x_2,x_3,\\dots,x_n)^T\\)使得\\(Ax=0\\)，那么说明\\(a_1x_1+a_2x_2+a_3x_3+\\dots+a_nx_n=0\\)。这说明这\\(n\\)个向量是线性相关的，因此\\(A\\)并不是列满秩矩阵。\r\nD.2-8\r\n将\\(n\\times m\\)大小的矩阵\\(A\\)看作是一个个列向量构成的矩阵\\(A=(a_1,a_2,a_3,\\dots,a_m)\\)，将\\(n\\times s\\)大小的矩阵\\(B\\)看成是一个系数矩阵，那么有\r\n\\[AB=\r\n(a_1,a_2,a_3,\\dots,a_m)\r\n\\begin{pmatrix}\r\nb_{11}&amp; b_{12} &amp; b_{13}&amp;\\dots&amp;b_{1s}\\\\\r\nb_{21}&amp; b_{22} &amp; b_{23}&amp;\\dots&amp;b_{2s}\\\\\r\nb_{31}&amp; b_{32} &amp; b_{33}&amp;\\dots&amp;b_{3s}\\\\\r\n\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots\\\\\r\nb_{m1}&amp; b_{m2} &amp; b_{m3}&amp;\\dots&amp;b_{ms}\\\\\r\n\\end{pmatrix}\r\n=\r\n\\begin{pmatrix}\r\na_1b_{11}+a_2b_{21}+a_3b_{31}+\\dots+a_mb_{m1}\\\\\r\na_1b_{12}+a_2b_{22}+a_3b_{32}+\\dots+a_mb_{m2}\\\\\r\na_1b_{13}+a_2b_{23}+a_3b_{33}+\\dots+a_mb_{m3}\\\\\r\na_1b_{14}+a_2b_{24}+a_3b_{34}+\\dots+a_mb_{m4}\\\\\r\na_1b_{15}+a_2b_{25}+a_3b_{35}+\\dots+a_mb_{m5}\r\n\\end{pmatrix}^T\r\n\\]\r\n那么矩阵\\(AB\\)的每一个列向量都可以由\\(A\\)中的列向量线性表出，因此\\(\\text{rank}(AB)\\le\\text{rank}(A)\\)。\r\n类似的证明方式，矩阵\\(AB\\)的每一个行向量都可以由\\(B\\)中的行向量线性表出，因此\\(\\text{rank}(AB)\\le\\text{rank}(B)\\)。\r\n因此最终有\\(\\text{rank}(AB)\\le\\min\\{\\text{rank}(A),\\text{rank}(B)\\}\\)。如果\\(A,B\\)是方阵，其中一个是非奇异的（不失一般性，假设\\(B\\)是非奇异的），那么\\(AB\\)中的极大线性无关组大小和\\(A\\)相同，此时有\\(\\text{rank}(AB)=\\text{rank}(A)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论D Problems 答案","url":"/introduction-to-algorithms/appendix-d/problems/","content":"\r\nD-1\r\n考虑使用归纳法进行证明。\r\n当\\(n=2\\)时，有\\(V(x_0,x_1)=\\begin{pmatrix} 1 &amp; x_0\\\\1 &amp;\r\nx_1\\end{pmatrix}\\)，那么有\\(\\det(V(x_0,x_1))=x_1-x_0\\)，原结论成立。\r\n当\\(n&gt;2\\)时，假设对于\\(\\displaystyle{n&#39;=1,2,3,\\dots,n-1,\\det(V(x_0,x_1,\\dots,x_{n&#39;-1}))=\\prod_{0\\le\r\nj&lt; k&lt; n&#39;}(x_k-x_j)}\\)均成立。考虑\\(\\det(V(x_0,x_1,\\dots,x_{n-1}))\\)的值，有\r\n\\(\\begin{aligned}\r\n\\det(V(x_0,x_1,\\dots,x_{n-1})) &amp;= \\left|\\begin{matrix}\r\n1&amp;x_0&amp;x_0^2&amp;\\dots&amp;x_0^{n-1}\\\\\r\n1&amp;x_1&amp;x_1^2&amp;\\dots&amp;x_1^{n-1}\\\\\r\n1&amp;x_2&amp;x_2^2&amp;\\dots&amp;x_2^{n-1}\\\\\r\n\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots\\\\\r\n1&amp;x_{n-1}&amp;x_{n-1}^2&amp;\\dots&amp;x_{n-1}^{n-1}\\\\\r\n\\end{matrix}\\right|\\\\\r\n&amp;=\\left|\\begin{matrix}\r\n1&amp;0&amp;0&amp;\\dots&amp;0\\\\\r\n1&amp;x_1-x_0&amp;x_1^2-x_1x_0&amp;\\dots&amp;x_1^{n-1}-x_1^{n-2}x_0\\\\\r\n1&amp;x_2-x_0&amp;x_2^2-x_2x_0&amp;\\dots&amp;x_2^{n-1}-x_2^{n-2}x_0\\\\\r\n\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots\\\\\r\n1&amp;x_{n-1}-x_0&amp;x_{n-1}^2-x_{n-1}x_0&amp;\\dots&amp;x_{n-1}^{n-1}-x_{n-1}^{n-2}x_0\\\\\r\n\\end{matrix}\\right|\\\\\r\n&amp;=\\left|\\begin{matrix}\r\n1&amp;0&amp;0&amp;\\dots&amp;0\\\\\r\n1&amp;x_1-x_0&amp;x_1(x_1-x_0)&amp;\\dots&amp;x_1^{n-2}(x_1-x_0)\\\\\r\n1&amp;x_2-x_0&amp;x_2(x_2-x_0)&amp;\\dots&amp;x_2^{n-2}(x_2-x_0)\\\\\r\n\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots\\\\\r\n1&amp;x_{n-1}-x_0&amp;x_{n-1}(x_{n-1}-x_0)&amp;\\dots&amp;x_{n-1}^{n-2}(x_{n-1}-x_0)\\\\\r\n\\end{matrix}\\right|\\\\\r\n&amp;=\\left|\\begin{matrix}\r\nx_1-x_0&amp;x_1(x_1-x_0)&amp;\\dots&amp;x_1^{n-2}(x_1-x_0)\\\\\r\nx_2-x_0&amp;x_2(x_2-x_0)&amp;\\dots&amp;x_2^{n-2}(x_2-x_0)\\\\\r\n\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots\\\\\r\nx_{n-1}-x_0&amp;x_{n-1}(x_{n-1}-x_0)&amp;\\dots&amp;x_{n-1}^{n-2}(x_{n-1}-x_0)\\\\\r\n\\end{matrix}\\right|\\\\\r\n&amp;=\\prod_{i=1}^{n-1}(x_i-x_0)\\cdot\\left|\\begin{matrix}\r\n1&amp;x_1&amp;\\dots&amp;x_1^{n-2}\\\\\r\n1&amp;x_2&amp;\\dots&amp;x_2^{n-2}\\\\\r\n\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots\\\\\r\n1&amp;x_{n-1}&amp;\\dots&amp;x_{n-1}^{n-2}\\\\\r\n\\end{matrix}\\right|\\\\\r\n&amp;=\\prod_{i=1}^{n-1}(x_i-x_0)\\cdot \\det(V(x_1,x_2,\\dots,x_{n-1}))\\\\\r\n&amp;=\\prod_{0\\le j&lt; k&lt; n}(x_k-x_j)\r\n\\end{aligned}\\)\r\n故原结论成立。\r\nD-2\r\na\r\n不失一般性，假设\\(A\\)大小为\\(r\\)的所有列向量的极大无关组分别为\\(a_1,a_2,a_3,\\dots,a_r\\)。\r\n那么列向量\\(a_{r+1},a_{r+2},\\dots,a_n\\)都可以由\\(a_1,a_2,a_3,\\dots,a_r\\)线性表示出。考虑向量\\(y=Ax\\)，那么\\(\\displaystyle{y_i=\\sum_{j=1}^n\r\na_{ij}x_j}=\\sum_{j=1}^ra_{ij} \\left(x_j+ \\sum_{k=r+1}^n\r\nb_{kj}x_k\\right)\\)。其中\\(b_{kj}\\)表示使用\\(a_j\\)来表示\\(a_k\\)时的系数，即\\(\\displaystyle{a_k=\\sum_{j=1}^r\r\nb_{kj}a_j}\\)，也就是说，\\(y\\)是前\\(r\\)个列向量作为线性无关组表示的结果，因此有\\(|R(A)|\\le 2^r\\)。\r\n另外，由于前\\(r\\)个向量是一个极大线性无关组，这个线性无关组的任何子集的组合结果都不相同，因此有\\(|R(A)|\\ge 2^r\\)。\r\n最终有\\(|R(A)|=2^r\\)。另外，当矩阵\\(A\\)满秩时，即\\(r=n\\)，有\\(|R(A)|=2^n\\)，此时\\(A\\)定义了一个\\(S_n\\)上的排列。\r\nb\r\n与D-2-a一样，不失一般性，假设\\(A\\)大小为\\(r\\)的所有列向量的极大无关组分别为\\(a_1,a_2,a_3,\\dots,a_r\\)。\r\n对于任意\\(y\\in R(A)\\)，\\(y\\)可以由\\(a_1,a_2,a_3,\\dots,a_r\\)线性表示出。由于列向量\\(a_{r+1},a_{r+2},\\dots,a_n\\)都可以由\\(a_1,a_2,a_3,\\dots,a_r\\)线性表示出，因此对于任意\\(T\\subseteq\r\n\\{a_{r+1},a_{r+2},\\dots,a_n\\}\\)，令\\(z=\\displaystyle{\\sum_{a\\in\r\nT}a}\\)。那么，\\(z\\)也可以由\\(a_1,a_2,a_3,\\dots,a_r\\)线性表示出，因此\\(y-z\\in\r\nR(A)\\)。也就是说，总存在唯一一个\\(0-1\\)向量\\((x_1,x_2,x_3\\dots,x_r)\\)，使得\\(a_1x_1+a_2x_2+a_3x_3+\\dots+a_rx_r=y-z\\)。由于子集\\(T\\)一共有\\(2^{n-r}\\)个，因此对于任意\\(y\\in R(A)\\)，总有\\(\\vert P(A,y)\\vert=2^{n-r}\\)。\r\nc\r\n矩阵\\(A\\)的前\\(m\\)行的变化只会影响最终计算结果\\(y=Ax\\)的低\\(m\\)比特，而不会影响\\(y\\)的剩下\\(n-m\\)比特。\\(y\\)始终在同一个大小为\\(2^m\\)的块中，因此不考虑低\\(m\\)比特的情况。\r\n由于\\(x\\)始终是在同一块中，因此不失一般性，令\\(x=(x_1,x_2,x_3,\\dots\r\nx_{m-1},x_m,c_{m+1},c_{m+2},\\dots,c_n)^T\\)，其中\\(c_i\\)是常数。\r\n那么对于\\(A\\)的右下方\\((n-m)\\times(n-m)\\)这一块，由于它们仅与\\(x\\)的高\\(n-m,\\)比特有关系，因此\\(A\\)的这部分的第\\(i\\)行对最终\\(y_i\\)的贡献值\\(\\displaystyle{\\sum_{j=m+1}^n\r\na_{ij}c_j}\\)为常数，这一部分不会对证明产生影响。\r\n因此我们只考虑左下角这\\((n-m)\\times\r\nm\\)这一块子矩阵。那么第\\(i\\)行对\\(y_i\\)的贡献值为\\(\\displaystyle{y_m&#39;=\\sum_{j=1}^m\r\na_{ij}x_j}\\)。\r\n令\\(y&#39;=(y_m&#39;,y_{m+1}&#39;,\\dots,y_n&#39;)^T\\)。接下来的证明方法与D-2-b类似。由于这部分矩阵可以看成是\\(m\\)个\\(n-m\\)维的列向量组合\\((a_1&#39;,a_2&#39;,\\dots,a_m&#39;)\\)而成，并且这一个子矩阵的秩为\\(r\\)，因此这\\(m\\)个列向量中存在一个大小为\\(r\\)的极大无关组\\(a&#39;_1,a_2&#39;,a_3&#39;,\\dots,a_r&#39;\\)。也就是说，\\(a_{r+1}&#39;,a_{r+2}&#39;,\\dots,a_n&#39;\\)都可以由\\(a_1&#39;,a_2&#39;,a_3&#39;,\\dots,a_r&#39;\\)线性表出。对于任意\\(T\\subseteq\\{a&#39;_1,a_2&#39;,a_3&#39;,\\dots,a_r&#39;\\}\\)，它们所组合出的\\(\\displaystyle{y&#39;=\\sum_{x\\in\r\nT}x}\\)都是两两不同的，因此一共有\\(2^r\\)个不同的\\(y&#39;\\)。也就是说，\\(y\\)的高\\(n-m\\)比特一共有\\(2^r\\)种不同的情况，因此按照定义，\\(|B(S&#39;,m)|=2^r\\)。对于\\(B(S&#39;,m)\\)中的任意一个块\\(b_0\\)，假设它重新对应得到的\\(y&#39;=y_0&#39;\\)，那么对于任意\\(T\\subseteq\r\n\\{a&#39;_{r+1},a_{r+2}&#39;,\\dots,a_m&#39;\\}\\)，令\\(z=\\displaystyle{\\sum_{a&#39;\\in\r\nT}a&#39;}\\)，那么\\(y_0-z\\)也可以由\\(a&#39;_1,a_2&#39;,a_3&#39;,\\dots,a_r&#39;\\)线性表出，因此总存在唯一一个\\(0-1\\)向量\\((x_1&#39;,x_2&#39;,x_3&#39;\\dots,x_r&#39;)\\)，使得\\(a_1&#39;x_1&#39;+a_2&#39;x_2&#39;+a_3&#39;x_3&#39;+\\dots+a_r&#39;x_r&#39;=y-z\\)成立。由于\\(T\\)一共有\\(2^{m-r}\\)个，因此\\(S\\)中总有\\(2^{m-r}\\)个数对应到这个块\\(b_0\\)中。\r\nd\r\n此处统计\\(n\\)阶满秩矩阵\\(A\\)的个数\\(p(n)\\)。\r\n将\\(A\\)看成是\\(n\\)个行向量的组合。为了保证\\(A\\)是满秩的，那么就需要保证第\\(i\\)个向量不能够由第\\(1,2,3,\\dots,i-1\\)个向量线性表出。因此，第\\(1\\)个行向量有\\(2^n-1\\)种选择。选择好\\(1\\)后，第\\(2\\)个行向量有\\(2^n-2\\)种选择。以此类推，第\\(i\\)个行向量有\\(2^n-2^{i-1}\\)种选择。每个行向量之间选择的数量是独立的，因此有\r\n\\[p(n)=\\prod_{i=0}^{n-1}\r\n(2^n-2^i)\\]\r\n再加上向量\\(c\\)有\\(2^n\\)种选择，那么线性排列数目\\(P(n)\\)满足\\(P(n)\\le p(n)\\cdot 2^n\\)。\r\n而\\(S_n\\)的排列数为\\(Q(n)=(2^n)!\\)。可以发现\\(Q(n)\\)是由前\\(2^n\\)个正整数构造而成的乘积，而\\(P(n)\\)的上界仅仅是这\\(2^n\\)个正整数中其中的\\(n+1\\)个，因此最终可知，\\(P(n)\\)远小于\\(Q(n)\\)。\r\ne\r\n考虑\\(n=3\\)时的情况。这个置换为\\(\\pi=(0, 1, 2, 3, 4, 5, 7, 6)\\)。由于\\(\\pi(0)=0\\)，因此向量\\(c=0\\)。由于\\(\\pi(7)=6\\)，因此\\(A\\)的后\\(2\\)行有奇数个\\(1\\)，第\\(1\\)行有\\(2\\)个\\(1\\)（如果没有\\(1\\)，那么\\(A\\)就不满秩了）。\\(\\pi(1)=1\\)说明\\(a_{11}=1\\)。考虑\\(\\pi(3)=3\\)和\\(\\pi(5)=5\\)，可以发现无论是取\\(a_{12}=1,a_{13}=0\\)还是取\\(a_{12}=0,a_{13}=1,\\pi(3)=3,\\pi(5)=5\\)不能同时成立。也就是说，符合条件的\\(A\\)并不存在，因此这个排列为所求。\r\n","categories":["算法导论"]},{"title":"算法导论10.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-10/exercises-2/","content":"\r\n10.2-1\r\n因为插入操作仅仅需要在链表\\(L\\)的头节点插入就好，将当前节点作为新的头节点，链接下一个原来的头节点。这种操作仅需要\\(O(1)\\)的时间。但是删除一个节点\\(x\\)时，由于\\(L\\)是单向链表，因此需要遍历整个\\(L\\)来查找\\(x\\)的前驱节点\\(y\\)，并且将\\(y\\)链接到原来\\(x\\)的下一个节点。因此最坏的时间开销为\\(\\Theta(n)\\)，即\\(L\\)的长度。\r\n10.2-2\r\nSTACK-EMPTY-LIST(L)  return L.head == NILPUSH(L, x)  x.next = L.head  L.head = xPOP(L)  if STACK-EMPTY-LIST(L)    error &quot;underflow&quot;  x = L.head  L.head = L.head.next  return x\r\n10.2-3\r\n需要给链表\\(L\\)需要添加一个属性tail表示链表的末节点指针。\r\n值得注意的是，这里用tail指针表示队头，用head指针表示队尾，链表和队列中指针的头和尾含义完全是“相反”的。\r\nQUEUE-EMPTY-LIST(L)  return L.head == NILENQUEUE(L, x)  if QUEUE-EMPTY-LIST(L)    L.head = x  else    L.tail.next = x  x.next = NIL  L.tail = xDEQUEUE(L, x)  if QUEUE-EMPTY-LIST(L)    error &quot;underflow&quot;  x = L.head  L.head = L.head.next  if L.head == NIL    L.tail = NIL  return x\r\n10.2-4\r\n考虑集合S1, S2分别使用带哨兵的双向链表L1, L2来存储。那么合并两个链表的操作非常简单，只需要将L1的元素放在新链表L的前面，将L2的元素放在新链表L的后面，并且顺序也不会被破坏。\r\n需要注意的是，合并后，需要将L2的哨兵去掉。\r\nUNION(L1, L2)  //去掉L2的哨兵  L1.nil.prev.next = L2.nil.next  L2.nil.next.prev = L1.nil.prev  //将L1的哨兵和L2的末节点关联  L1.nil.prev = L2.nil.prev  L2.nil.prev.next = L1.nil  return L1\r\n完成这\\(4\\)个链表操作后，得到的新链表就是集合S1, S2的并，并且仍然是一个带哨兵的双向链表。\r\n10.2-5\r\nREVERSE-LIST(L)  // a, b, c是链表上3个相邻的节点。  a = NIL  b = L.head  while b != NIL    c = b.next    b.next = a    a = b    b = c  L&#x27;.head = a  return L&#x27;\r\n\\(\\star\\)\r\n10.2-6\r\n基本思路：如果\\(A\\text{ XOR\r\n}B=C\\)，那么\\(A\\text{ XOR\r\n}C=B\\)。也就是说，对于指针np，如果知道了目前的其中一个值，那么可以求解出另一个值。\r\n考虑双向链表\\(L\\)有头哨兵指针nilhead，尾哨兵niltail。\r\n和书上介绍的双向链表有所不同，这个双向链表的头哨兵前驱指针prev被认为指向NIL，尾哨兵后继指针next被认为指向NIL。\r\nSEARCH-NP(L, k)  prev = L.nilhead  p = L.nilhead.np  while p != niltail and p.key != k    // prev是p前驱节点的指针，next是p的后继节点指针。    next = p.np XOR prev    prev = p    p = next  if p == L.niltail    return NIL  else    return pINSERT-NP(L, x)  q = NIL XOR L.nilhead.np  // 第一个XOR还原出了q的next地址。  q.np = (q.np XOR L.nilhead) XOR x  x.np = L.nilhead XOR q  L.nilhead.np = NIL XOR xDELETE-NP(L, x)  prev = L.nilhead  p = L.nilhead.np  while p != niltail    // prev是p前驱节点的指针，next是p的后继节点指针。    next = p.np XOR prev    if p == x      prev.np = (prev.np XOR p) XOR next      next.np = (next.np XOR p) XOR prev      // 注意，p节点被删除了，那么prev仍然是prev，不需要改变。      p = next    else      prev = p      p = nextREVERSE-NP(L)  swap L.nilhead with L.niltail\r\n","categories":["算法导论"]},{"title":"算法导论10.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-10/exercises-1/","content":"\r\n10.1-1\r\n可以发现，大矩阵\\(m\\times\r\nn\\)的所属块号由行坐标和列坐标的最高比特决定。由于是行坐标优先，因此转化成一维序列是，最高的两位坐标为\\(i_{\\lg m-1},j_{\\lg\r\nn-1}\\)。块内依旧行优先，因此剩下的\\(m-1\\)比特行坐标排高位，剩下的\\(n-1\\)比特行坐标排低位。因此最终答案为\r\n\\[\\langle i_{\\lg m-1},j_{\\lg n-1},i_{\\lg\r\nm-2},i_{\\lg m-3},\\dots,i_1,i_0,j_{\\lg n-2},j_{\\lg\r\nn-3},\\dots,j_1,j_0\\rangle\\]\r\n10.1-2\r\n\\(\\begin{array}{|l|}\r\n\\hline\r\n\\text{PUSH}(S, 4)\\\\\r\n\\hline\r\n\\text{PUSH}(S, 1)\\\\\r\n\\hline\r\n\\text{PUSH}(S, 3)\\\\\r\n\\hline\r\n\\text{POP}(S)\\\\\r\n\\hline\r\n\\text{PUSH}(S, 8)\\\\\r\n\\hline\r\n\\text{POP}(S)\\\\\r\n\\hline\r\n\\end{array}\r\n\\quad\r\n\\begin{array}{|l|l|l|l|l|l|}\r\n\\hline\r\n4\\\\\r\n\\hline\r\n4&amp;1\\\\\r\n\\hline\r\n4&amp;1&amp;3&amp;\\phantom{3}&amp;\\phantom{3}&amp;\\phantom{3}\\\\\r\n\\hline\r\n4&amp;1\\\\\r\n\\hline\r\n4&amp;1&amp;8\\\\\r\n\\hline\r\n4&amp;1\\\\\r\n\\hline\r\n\\end{array}\\)\r\n10.1-3\r\n数组的左边可以用于栈存储，右边也可以用于栈存储。一开始，左栈顶指针栈空时指向左外侧\\(0\\)，如果需要入栈那么将左栈顶指针右移，出栈时将左栈顶指针左移；同样的，右栈顶指针栈空时指向右外侧\\(n+1\\)，如果需要入栈那么将右栈顶指针左移，出栈时将右栈顶指针右移。当这两个栈顶指针恰好相邻时，两个栈都满了（数组\\(A\\)都占用完成）。可以发现，无论出栈入栈本质上是指针移动一个单位的操作，因此运行时间均为\\(O(1)\\)。\r\n10.1-4\r\n\\(\\begin{array}{|l|}\r\n\\hline\r\n\\text{ENQUEUE}(Q, 4)\\\\\r\n\\hline\r\n\\text{ENQUEUE}(Q, 1)\\\\\r\n\\hline\r\n\\text{ENQUEUE}(Q, 3)\\\\\r\n\\hline\r\n\\text{DEQUEUE}(Q)\\\\\r\n\\hline\r\n\\text{ENQUEUE}(Q, 8)\\\\\r\n\\hline\r\n\\text{DEQUEUE}(Q)\\\\\r\n\\hline\r\n\\end{array}\r\n\\quad\r\n\\begin{array}{|l|l|l|l|l|l|}\r\n\\hline\r\n4\\\\\r\n\\hline\r\n4&amp;1\\\\\r\n\\hline\r\n4&amp;1&amp;3&amp;\\phantom{3}&amp;\\phantom{3}&amp;\\phantom{3}\\\\\r\n\\hline\r\n&amp;1&amp;3\\\\\r\n\\hline\r\n&amp;1&amp;3&amp;8\\\\\r\n\\hline\r\n&amp; &amp;3&amp;8\\\\\r\n\\hline\r\n\\end{array}\\)\r\n10.1-5\r\nQUEUE-EMPTY(Q)  return Q.head == Q.tailQUEUE-FULL(Q)  return Q.head == Q.tail + 1 or (Q.head == 1 and Q.tail == Q.size)ENQUEUE(Q, x)  if QUEUE-FULL(Q)    error &quot;overflow&quot;  Q[Q.tail] = x  if Q.tail == Q.size    Q.tail = 1  else Q.tail = Q.tail + 1DEQUEUE(Q)  if QUEUE-EMPTY(Q)    error &quot;underflow&quot;  x = Q[Q.head]  if Q.head == Q.size    Q.head = 1  else Q.head = Q.head + 1  return x\r\n10.1-6\r\n将沿用题目10.1-5的两个子程序QUEUE-EMPTY(Q), QUEUE-FULL(Q)判断双端队列是否为空/满。\r\nHEAD-ENQUEUE(Q)  if QUEUE-FULL(Q)    error &quot;overflow&quot;  x = Q[Q.head]  if Q.head == 1    Q.head = Q.size  else Q.head = Q.head - 1  Q[Q.head] = xHEAD-DEQUEUE(Q)  if QUEUE-EMPTY(Q)    error &quot;underflow&quot;  x = Q[Q.head]  if Q.head == Q.size    Q.head = 1  else Q.head = Q.head + 1  return xTAIL-ENQUEUE(Q, x)  if QUEUE-FULL(Q)    error &quot;overflow&quot;  Q[Q.tail] = x  if Q.tail == Q.size    Q.tail = 1  else Q.tail = Q.tail + 1TAIL-DEQUEUE(Q)  if QUEUE-EMPTY(Q)    error &quot;underflow&quot;  if Q.tail == 1    Q.tail = Q.size  else Q.tail = Q.tail - 1  return Q[Q.tail]\r\n10.1-7\r\n假设有两个栈S1, S2，那么支持队列的两个操作如下进行：\r\n\r\nENQUEUE\r\n直接将元素推入栈S2中。此操作时间复杂度为\\(\\Theta(1)\\)。\r\nDEQUEUE\r\n将S1栈顶的元素弹出并返回即可。如果S1为空，那么弹出S2中的所有元素，一边弹出，一边将元素推入到S1中，再将元素弹出并返回。这种操作绝大多数时间下都是\\(O(1)\\)，如果栈S2过于庞大，那么时间开销就是S2的长度。\r\n\r\n// Q.S1和Q.S2表示队列Q内部的两个栈。ENQUEUE(Q, x)  PUSH(Q.S2, x)DEQUEUE(Q)  if STACK-EMPTY(Q.S1)    while not STACK-EMPTY(Q.S2)      x = POP(Q.S2)      PUSH(Q.S1, x)  x = POP(Q.S1)  return x\r\n10.1-8\r\n假设有两个队列Q1, Q2，那么支持栈的两个操作如下进行（一开始令\\(p=0\\)）：\r\n\r\nPUSH:\r\n在队列Qp队尾推入元素。此操作时间复杂度为\\(\\Theta(1)\\)。\r\nPOP:将队列Qp中的所有元素弹出，除了最后一个元素\\(x\\)，其它元素依次推入到队列Q(3-p)中，然后赋予p=3-p，并且将\\(x\\)返回。此操作时间复杂度为队列Sp的长度，即\\(\\Theta(n)\\)。\r\n\r\n","categories":["算法导论"]},{"title":"算法导论10.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-10/exercises-3/","content":"\r\n10.3-1\r\n\r\n10.3-2\r\nPRINT-BINARY-TREE-RECURSIVE(x)  if x == NIL    return  print x.key  PRINT-BINARY-TREE-RECURSIVE(x.left)  PRINT-BINARY-TREE-RECURSIVE(x.right)\r\n10.3-3\r\nPRINT-BINARY-TREE-NONRECURSIVE(x)  let S be a new STACK  p = x  while not STACK-EMPTY(S) or p != NIL      // 一直沿着左子节点走，如果发现走不下去，那么回退父节点，并且开始走右子节点。      while p != NIL        print p.key        PUSH(S, p)        p = p.left      if not STACK-EMPTY(S)        p = POP(S)        p = p.right\r\n10.3-4\r\nPRINT-TREE(x)  if x == NIL    return  print x.key  p = x.left-child  while p != NIL    PRINT-TREE(p)    p = p.right-sibling\r\n\\(\\star\\)\r\n10.3-5\r\n基本思想是上一次访问节点pre和当前节点q选择下一次访问的节点。\r\nPRINT-BINARY-TREE-NONRECURSIVE-CONSTANT-SPACE(x)  Let S be a new STACK.  pre = NIL  q = x  while q != NIL    if q.p == pre      // 说明上一次访问的是q的父节点，说明子树q还没被访问过。      print q.key      pre = q      // 尝试向下访问      if q.left != NIL        q = q.left      else if q.right != NIL        q = q.right      // 这是个叶节点，返回。      else        q = q.p    else if q.left == pre and q.right != NIL      // 如果左子树为空，右子树非空，可以发现不会从这里进入右子树。      pre = q      q = q.right    else      // 左右子树都访问过，返回到父节点。      pre = q      q = q.p\r\n\\(\\star\\)\r\n10.3-6\r\n这种新节点x'包含如下\\(3\\)个新属性：\r\n\r\nx'.left\r\n和原来的x.left_child语义完全相同，表示x'最左边的儿子。\r\nx'.is-right\r\n布尔值，判断x'是否为自己最右边的兄弟。也就是说，判断自己是否为父节点最右边的孩子。\r\nx'.right\r\n如果x'.is_right为False，那么x'.right链接的是自己的右边的兄弟；否则链接的是自己的父节点。\r\n\r\n遍历自己的兄弟时，如果遍历着发现x.is_right = True，那么说明回到了父节点。\r\n","categories":["算法导论"]},{"title":"算法导论11.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-11/exercises-1/","content":"\r\n11.1-1\r\n基本思想是从后往前直接查找，找到第一个值就返回当前值。哈希表为空时，将会达到最坏情况。\r\nDIRECT-ADDRESS-SEARCH(T, m)  for i = m - 1 downto 0    if T[i] != NIL      return i  return NIL\r\n11.1-2\r\n直接用一个\\(m\\)比特数组\\(T\\)来表示这个表。如果T[x] == 1，那么\\(x\\)在这个表中，否则\\(x\\)不在这个表中。\r\n可以发现这些操作都是\\(O(1)\\)的时间复杂度。\r\nBIT-ADDRESS-SEARCH(T, k)  return T[k]BIT-ADDRESS-INSERT(T, x)  T[x] = 1BIT-ADDRESS-DELETE(T, x)  T[x] = 0\r\n11.1-3\r\n\\(m\\)个槽将不再用于直接存放元素，而是存放对应链表的头节点。那么插入一个元素\\(x\\)，相当于在对应的链表T[x.key]上进行操作。\r\n\r\nINSERT: 在对应的链表上直接以\\(O(1)\\)的时间插入元素。\r\nDELETE:\r\n在对应的链表上删除元素。基于哈希表的性质，这个链表的长度非常短，可以达到\\(O(1)\\)的时间复杂度。\r\nSEARCH:\r\n直接将对应链表的表头元素返回即可。如果没有，那么直接返回NIL。整个操作仅需要\\(O(1)\\)的时间。\r\n\r\n\\(\\star\\)\r\n11.1-4\r\n基本思想是，使用一个双向链表\\(L\\)来表示这个额外的数据结构，一开始时，这个\\(L\\)为空，整个数组并不进行初始化。在整个过程中，\\(L\\)中的元素和数组\\(T\\)中的元素进行绑定，查找或者删除时会进行绑定校验。因此，每个实体必须再添加一个指针\\(p\\)，用来指向\\(L\\)中的元素。\r\n// 链表L是一个双向链表，其中的节点包含前驱指针prev，后继指针next，以及在数组A中的目标下标pos。（这里忽略对数组T进行越界检测）BIG-ADDRESS-SEARCH(T, k)  // 判断元素T[k]和L中的节点是否绑定在一起。  if T[k].p != NIL and T[k].p.pos == k    return T[k]  else    return NILBIG-ADDRESS-INSERT(T, L, x)  k = x.key  // 这个位置上原来已经包含了一个元素，绑定校验成功。  if T[k].p != NIL and T[k].p.pos == k    x.p = T[k].p    T[k] = x  else  // 否则新加入L中。    let p be new node    INSERT(L, p)    T[k] = x    T[k].p = p    p.pos = k    BIG-ADDRESS-DELETE(T, L, x)  k = x.key  // 绑定校验，避免进行非法操作。  if T[k].p != NIL and T[k].p.pos == k    DELETE(L, T[k].p)    T[k].p = NIL\r\n可以发现，每一步的操作无非都是寻址，以及双向链表上的插入和删除操作。因此，这个大哈希表\\(T\\)中支持的这三个操作的时间复杂度均为\\(O(1)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论10 Problems 答案","url":"/introduction-to-algorithms/chapter-10/problems/","content":"\r\n10-1\r\n\\(\\begin{array}{|c|c|c|c|c|}\r\n\\hline\r\n&amp;\\text{unsorted, singly linked} &amp; \\text{sorted, singly linked}\r\n&amp; \\text{unsorted, doubly linked} &amp; \\text{sorted, doubly\r\nlinked}\\\\\r\n\\hline\r\n\\text{SEARCH}&amp;\\Theta(n)&amp;\\Theta(n)&amp;\\Theta(n)&amp;\\Theta(n)\\\\\r\n\\hline\r\n\\text{INSERT}&amp;\\Theta(1)&amp;\\Theta(n)&amp;\\Theta(1)&amp;\\Theta(n)\\\\\r\n\\hline\r\n\\text{DELETE}&amp;\\Theta(n)&amp;\\Theta(n)&amp;\\Theta(n)&amp;\\Theta(n)\\\\\r\n\\hline\r\n\\text{SUCCESSOR}&amp;\\Theta(n)&amp;\\Theta(1)&amp;\\Theta(n)&amp;\\Theta(1)\\\\\r\n\\hline\r\n\\text{PREDECESSOR}&amp;\\Theta(n)&amp;\\Theta(n)&amp;\\Theta(n)&amp;\\Theta(1)\\\\\r\n\\hline\r\n\\text{MINIMUM}&amp;\\Theta(n)&amp;\\Theta(1)&amp;\\Theta(n)&amp;\\Theta(1)\\\\\r\n\\hline\r\n\\text{MAXIMUM}&amp;\\Theta(n)&amp;\\Theta(n)&amp;\\Theta(n)&amp;\\Theta(1)\\\\\r\n\\hline\r\n\\end{array}\\)\r\n为了维持整个序列有序，插入时需要查找到合适的位置才能插入，需要耗费的时间也比较大。\r\n求最大值时，它在有序单向链表上是最后一个元素，因此是\\(\\Theta(n)\\)的时间。但是，如果有序单向链表\\(L\\)多维护一个尾指针，那么也可以改成\\(\\Theta(1)\\)。\r\n10-2\r\n假设实现时\\(L\\)是一个单链表。\r\na\r\n\r\nMAKE-HEAP: 产生一个空列表，仅仅需要\\(O(1)\\)的时间。\r\nINSERT: 遍历整个链表，查找到适当的元素插入，需要\\(O(n)\\)的时间。\r\nMINIMUM, EXTRACT-MIN:\r\n直接返回头节点；如果有需要，那么返回并删除头节点，仅仅需要\\(O(1)\\)的时间。\r\nUNION:\r\n使用归并排序的合并步骤完成这两个链表的合并，需要\\(O(n)\\)的时间。\r\n\r\nb\r\n\r\nMAKE-HEAP: 产生一个空列表，仅仅需要\\(O(1)\\)的时间。\r\nINSERT: 直接在头部插入新元素，仅仅需要\\(O(1)\\)的时间。\r\nMINIMUM, EXTRACT-MIN:\r\n遍历整个链表找到值最小的节点并返回；如果有需要，那么删除这个节点，整个过程需要\\(O(n)\\)的时间。\r\nUNION:\r\n直接遍历到其中一个链表的末尾，并接上另一个链表的头部即可，整个过程需要\\(O(n)\\)的时间。\r\n\r\nc\r\n问题10-2-b中的解答没有对元素的唯一性做出限制，本题的解答和问题10-2-b的完全一致。\r\n10-3\r\na\r\n对于算法COMPACT-LIST-SEARCH，它通过多次执行跳跃来接近目标值\\(k\\)，直到达到目标直接点\\(k\\)，如果跳跃失败了，第8行的代码表明它仍然能前进；\r\n对于算法COMPACT-LIST-SEARCH'，它先执行固定次数\\(t\\)次的跳跃，然后在最后一步跳到的节点遍历链表，寻找目标值\\(k\\)。\r\n因此两个算法的功能是一致的，返回的内容将会相同。\r\n需要注意的是，算法COMPACT-LIST-SEARCH相比算法COMPACT-LIST-SEARCH'，while循环第8行代码多出了一个i = next[i]。如果算法COMPACT-LIST-SEARCH'在\\(t\\)次迭代完成后仍然找不到\\(k\\)，那么就需要依靠下面的while循环继续查找。由于已经假设了RANDOM结果在两个算法中返回的结果是一样的，也就是说，两个算法的跳跃记录都是一样的，因此算法COMPACT-LIST-SEARCH的while循环执行次数不超过算法COMPACT-LIST-SEARCH'的while, for循环执行次数之和。\r\nb\r\n算法COMPACT-LIST-SEARCH′的for循环执行了恰好\\(t\\)次，每次循环的步骤仅需花费常数时间；while循环仅需执行\\(X_t\\)次。因此算法COMPACT-LIST-SEARCH'的平均时间复杂度为\\(O(t+E[X_t])\\)。\r\nc\r\n根据C.28式，得到$ $。\r\n考虑概率值\\(\\Pr\\{X_t\\ge\r\nr\\}\\)。算法COMPACT-LIST-SEARCH'的第3行代码相当于进行\\(t\\)次重复实验，并且要求每一次抽取出来的\\(j\\)都需要满足\\(j\\)所在的节点和\\(k\\)的距离都要大于等于\\(r\\)，这样的节点一共有\\(n-r\\)个，因此进行一次实验满足这个条件的概率为\\(\\dfrac{n-r}{n}=1-\\dfrac{r}{n}\\)；如果\\(t\\)次都要满足，那么概率值为\\(\\left(1-\\dfrac{r}{n}\\right)^t\\)，即\\(\\Pr\\{X_t\\ge\r\nr\\}=\\left(1-\\dfrac{r}{n}\\right)^t\\)。\r\n因此，最终有\\(\\displaystyle{E[X_t]=\\sum_{r=1}^n\\left(1-\\dfrac{r}{n}\\right)^t}\\)。\r\n实际上，个人认为这个题目并不严谨，应该是\\(\\displaystyle{E[X_t]\\le\\sum_{r=1}^n\\left(1-\\dfrac{r}{n}\\right)^t}\\)才正确。因为节点\\(k\\)并不总是会在链表的最后一个节点。\r\nd\r\n由于\\(t&gt;0\\)，因此函数\\(f(r)=r^t\\)在\\(r\\ge0\\)处是单调递增的。那么根据A.18式，有\r\n\\[\\sum_{r=0}^{n-1} r^t\\le \\int_{0}^{n} r^t\r\ndr=\\left.\\dfrac{r^{t+1}}{t+1}\\right|_{0}^{n}=\\dfrac{n^{t+1}}{t+1}\\]\r\ne\r\n\\(\\begin{aligned}\r\nE[X_t]&amp;=\\sum_{r=1}^n\\left(1-\\dfrac{r}{n}\\right)^t\\\\\r\n&amp;=\\dfrac{1}{n^t}\\sum_{r=1}^n (n-r)^t\\\\\r\n&amp;=\\dfrac{1}{n^t}\\sum_{s=0}^{n-1} s^t &amp; \\qquad (A)\\\\\r\n&amp;\\le \\dfrac{1}{n^t} \\cdot \\dfrac{n^{t+1}}{t+1} \\\\\r\n&amp;=\\dfrac{n}{t+1}\r\n\\end{aligned}\\)\r\n其中，步骤\\((A)\\)则是由等式A.13而来，仅仅将索引进行了变换。\r\nf\r\n由于\\(E[X_t]\\le\\dfrac{n}{t+1}\\le\r\n\\dfrac{n}{t}\\)，那么再根据题目10-3-b的结论就可以得到算法t COMPACT-LIST-SEARCH'的时间复杂度为\\(O(t+n/t)\\)。\r\ng\r\n当\\(t=\\sqrt{n}\\)时，算法COMPACT-LIST-SEARCH'的时间复杂度为\\(O(\\sqrt{n})\\)。并且根据题目10-3-a的结论，算法COMPACT-LIST-SEARCH'的循环次数超过了算法COMPACT-LIST-SEARCH，因此算法COMPACT-LIST-SEARCH的时间复杂度同样为\\(O(\\sqrt{n})\\)。\r\nh\r\n如果元素并不满足唯一性，那么当算法COMPACT-LIST-SEARCH开始随机选择下一跳时，它将不能够选择和自身相同的值（否则，有可能会跳到之前的节点），为此，和当前节点键相等的后续一些节点将会被跳过，这违背了后续节点被均匀选择的假设，因此题目10-3-c的结果将不再适用。\r\n","categories":["算法导论"]},{"title":"算法导论11.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-11/exercises-2/","content":"\r\n11.2-1\r\n考虑使用示性随机变量\\(X_{i,j}\\)表示\\(k_i\\)和\\(k_j\\)发生了哈希碰撞。那么有\r\n\\(\\displaystyle{E[X_{i,j}]=\\sum_{x=0}^{m-1}\\Pr\\{h(k_i)=x\\land\r\nh(k_j)=x\\}=m\\cdot \\dfrac{1}{m^2}=\\dfrac{1}{m}}\\)\r\n假设随机变量\\(Y\\)表示产生的碰撞数，也就是题目中所求值，即有\\(\\displaystyle{Y=\\sum_{i=1}^{n-1}\\sum_{j=i+1}^nX_{i,j}}\\)，那么有\r\n\\(\\displaystyle{E[Y]=E\\left[\\sum_{i=1}^{n-1}\\sum_{j=i+1}^nX_{i,j}\\right]=\\sum_{i=1}^{n-1}\\sum_{j=i+1}^nE[X_{i,j}]=\\dfrac{n(n-1)}{2}\\cdot\\dfrac{1}{m}=\\dfrac{n(n-1)}{2m}}\\)\r\n11.2-2\r\n最终将会变成如下形式，因为后来的元素先插入链表头部。\r\n\\(\\begin{array}{|l|l|} \\hline\r\nh(k) &amp;\\text{keys}\\\\\r\n\\hline\r\n0&amp;\\\\\r\n\\hline\r\n1&amp;10,19,28\\\\\r\n\\hline\r\n2&amp;20\\\\\r\n\\hline\r\n3&amp;12\\\\\r\n\\hline\r\n4&amp;\\\\\r\n\\hline\r\n5&amp;5\\\\\r\n\\hline\r\n6&amp;33,15\\\\\r\n\\hline\r\n7&amp;\\\\\r\n\\hline\r\n8&amp;17\\\\\r\n\\hline\r\n\\end{array}\\)\r\n11.2-3\r\n成功查找：基本没有影响，仍然是\\(O(1+\\alpha)\\)。\r\n不成功查找：如果查找的第一个key超过了所要查找的key，那么可以立刻返回查找失败。虽然快了一些，不过时间复杂度仍然是\\(O(1+\\alpha)\\)。\r\n插入：插入操作是先找到小于当前key的最大值节点后面再进行插入。因此时间复杂度和成功查找时基本一致，为\\(O(1+\\alpha)\\)。\r\n删除：如果维护的链表是双向链表，那么删除操作的时间复杂度为\\(O(1)\\)；如果是单项链表，那么还需要查找到这个节点的前驱节点，与成功查找操作一样，为\\(O(1+\\alpha)\\)。\r\n11.2-4\r\n这个哈希表内部的自由链表使用了一个双向链表来实现。这个哈希表中，它们都有一个占用标志变量，表示这个槽位是否被占用。如果槽位被占用，那么就有一个元素指向对应的链表。此外，槽位还有两个方向的指针用来维护这个自由链表。\r\n\r\nINSERT:\r\n在对应的链表T[x.key]上直接以\\(O(1)\\)的时间插入元素。如果槽位T[x.key]标志变量为\\(0\\)，那么将其置\\(1\\)，新建一个自由节点并插入这个自由链表中，然后让这个自由节点的元素指向一个初始化的空链表，再将这个元素插入到这个链表中。\r\nDELETE:\r\n在对应的链表T[x.key]上删除元素。如果删除完后，这个链表为空，那么槽位T[x.key]的标志变量置为\\(0\\)，并且将自由节点从这个自由链表上删去。由于自由链表是双向链表，因此删除操作可以达到\\(O(1)\\)。\r\nSEARCH:\r\n直接将对应链表的表头元素返回即可。如果没有，那么直接返回NIL。整个操作仅需要\\(O(1)\\)的时间。\r\n\r\n如果使用的是单向链表，那么删除操作并不能达到\\(O(1)\\)，而是\\(O(1+\\alpha)\\)。因此只能使用双向链表。\r\n11.2-5\r\n当这\\(|U|\\)个不同的键均匀地分配到每个槽中时，包含了最多键的那个槽的大小\\(\\displaystyle{t=\\max_{i=0}^{m-1}\\{|T(i)|\\}}\\)才能最小化。那么有\\(t\\ge\r\n\\left\\lceil\\dfrac{|U|}{m}\\right\\rceil&gt;\\dfrac{(n-1)m}{m}=n-1\\)。这说明，包含最多键的那个槽至少会包含\\(n\\)个键。由这个槽里的所有键可以构造出一个大小为\\(n\\)的集合\\(S\\)，里面的所有键将会哈希到这一个槽中。\r\n11.2-6\r\n随机选择操作由算法RANDOM-HASH-TABLE-SELECT(T)给出。\r\nRANDOM-HASH-TABLE-SELECT(T)  while True    k = RANDOM(0, T.m - 1)    p = RANDOM(1, K)    if 1 &lt;= p and p &lt;= T[k].size      return the p-th element of list T[k]\r\n在一次随机选择中，每个元素被中的概率为\\(\\dfrac{1}{mL}\\)。由于哈希表\\(T\\)中有\\(n\\)个元素，因此在一次随机选择中有\\(\\dfrac{n}{mL}=\\dfrac{\\alpha}{L}\\)概率选中哈希表的元素并返回。\r\n令随机变量\\(X\\)表示这个算法的while循环迭代次数。那么按照上面的结论，\\(X\\)服从参数为\\(\\dfrac{\\alpha}{L}\\)的几何分布。因此，\\(X\\)的期望值为\\(\\dfrac{L}{\\alpha}\\)。\r\n找到了一个元素的下标后，还需要遍历链表才能够真正找到这个元素。由于链表的最大长度为\\(L\\)，因此遍历的时间最多为\\(L\\)。\r\n最终，算法的平均时间复杂度为\\(O\\left(L+\\dfrac{L}{\\alpha}\\right)=O\\left(L\\cdot\\left(1+\\dfrac{1}{\\alpha}\\right)\\right)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论11.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-11/exercises-3/","content":"\r\n11.3-1\r\n优点在于，如果字符串的哈希值已经预先计算了出来，那么为了判断两个字符串是否相等，可以以\\(O(1)\\)的时间复杂度判断哈希值是否相等来完成。如果是为了将字符串插入哈希表，那么就不需要直接以\\(O(n)\\)的时间对字符串进行比对，从而可以快速判断两个字符串是否相等。对于哈希表而言，则可以通过哈希值快速定位到槽，而不需要直接为这个字符串划分一个槽。\r\n11.3-2\r\n这个计算哈希值的过程由下面的算法CAL-HASH给出。\r\nCAL-HASH(S, r, m)  h = 0  for i = 1 to r    // 将字符S[i]看成是一个无符号7比特数。    h = (h * 128 + S[i]) mod m  return h\r\n变量\\(h\\)表示这个字符串的哈希值。由于\\(S\\)可以看成是一个\\(r\\)位\\(128\\)进制数，那么以\\(i\\)个字符为前缀的字符串哈希值\\(h_i\\)可以由\\(h_{i-1}\\)计算出，即\\(h_i=(128h_{i-1}+S[i])\\bmod m\\)，最终\\(h_n\\)是这个字符串的哈希值。\r\n11.3-3\r\n按照题目11.3-2的算法，以\\(i\\)个字符为前缀的字符串哈希值\\(h_i\\)可以由\\(h_{i-1}\\)计算出，即\\(h_i=(2^p\\cdot h_{i-1}+S[i])\\bmod\r\n(2^p-1)=(h_{i-1}+S[i])\\bmod(2^p-1)\\)。\r\n按照上面的算法，可以得知空字符串的哈希值\\(h_0=0\\)。因此\\(\\displaystyle{h_i=\\left(\\sum_{j=1}^i\r\nS[i]\\right)\\bmod\r\n(2^p-1)}\\)。也就是说，这个哈希算法计算出的哈希值是所有\\(p\\)位二进制数之和对\\(2^p-1\\)取模的值，失去了对\\(S\\)中字符的顺序的特征。因此，如果字符串\\(x\\)是字符串\\(y\\)的一个置换，那么它们的哈希值相同，因为使用的字母是完全相同的。\r\n例如字符串\\(x=[245,148,15,159],y=[148,159,245,15],p=8\\)。两个字符串计算出来的哈希值均为\\(57\\)。\r\n11.3-4\r\n\\(\\begin{aligned}\r\nh(61)&amp;=\\left\\lfloor 1000\r\n\\cdot\\left(61\\cdot\\dfrac{\\sqrt{5}-1}{2}\\bmod\r\n1\\right)\\right\\rfloor&amp;=700\\\\\r\nh(62)&amp;=\\left\\lfloor 1000\r\n\\cdot\\left(62\\cdot\\dfrac{\\sqrt{5}-1}{2}\\bmod\r\n1\\right)\\right\\rfloor&amp;=318\\\\\r\nh(63)&amp;=\\left\\lfloor 1000\r\n\\cdot\\left(63\\cdot\\dfrac{\\sqrt{5}-1}{2}\\bmod\r\n1\\right)\\right\\rfloor&amp;=936\\\\\r\nh(64)&amp;=\\left\\lfloor 1000\r\n\\cdot\\left(64\\cdot\\dfrac{\\sqrt{5}-1}{2}\\bmod\r\n1\\right)\\right\\rfloor&amp;=554\\\\\r\nh(65)&amp;=\\left\\lfloor 1000\r\n\\cdot\\left(65\\cdot\\dfrac{\\sqrt{5}-1}{2}\\bmod\r\n1\\right)\\right\\rfloor&amp;=172\\\\\r\n\\end{aligned}\\)\r\n11.3-5\r\n由于函数簇\\(\\mathscr{H}\\)是\\(\\epsilon\\)-全域的，因此对于所有\\(a,b\\in U,a&lt; b\\)，都有\\(\\Pr\\{h(a)=h(b)\\}\\le \\epsilon\\)。\r\n假设\\(n(a,b),a,b\\in U\\)表示元素\\(a\\)和\\(b\\)在\\(\\mathscr{H}\\)中发生的碰撞次数，那么有\\(\\displaystyle{n(a,b) =\\sum_{h\\in\r\n\\mathscr{H}}[h(a)=h(b)]\\le \\epsilon\\cdot\r\n|\\mathscr{H}|}\\)。其中\\([]\\)为示性函数，如果里面的表达式值为真，那么为\\(1\\)，否则为\\(0\\)。\r\n那么对于所有不同的元素对\\((a,b),a&lt;\r\nb\\)，在\\(\\mathscr{H}\\)中的总碰撞次数为\\(C\\)，那么有\r\n\\[C=\\sum_{a,b\\in U,a&lt;b} n(a,b)\\le\r\n\\epsilon\\cdot |\\mathscr{H}|\\cdot\r\n\\dfrac{|U|\\cdot(|U|-1)}{2}\\le\\epsilon\\cdot |\\mathscr{H}|\\cdot\r\n\\dfrac{|U|^2}{2}\\qquad(1)\\]\r\n令\\(c(h)\\)表示在函数\\(h\\in\\mathscr{H}\\)中发生碰撞的元素对数，那么有\\(\\displaystyle{c(h)}=\\sum_{a,b\\in U,a&lt;\r\nb}[h(a)=h(b)]\\)。根据\\(C\\)的定义，同样有\\(\\displaystyle{C=\\sum_{h\\in\\mathscr{H}}\r\nc(h)}\\)。\r\n对于某个哈希函数\\(h\\in\r\n\\mathscr{H}\\)，只有当\\(|U|\\)个\\(U\\)中的键尽量均匀地映射到\\(Q\\)时，总碰撞次数才最小。这相当于将\\(|U|\\)个元素划分成\\(|Q|\\)个集合，并且尽可能均匀的划分。\r\n令\\(|U|=k\\cdot |Q|+b,k\\ge\r\n0,b\\in\\{1,2,3,\\dots,|Q|\\}\\)。在最均匀的划分情况下，一共有\\(b\\)个集合，这些集合的大小为\\(k+1\\)，其余\\(|Q|-b\\)个集合，每个大小为\\(k\\)。那么不难计算出\\(c(h)\\)的下界，有\r\n\\(\\begin{aligned}\r\nc(h)&amp;\\ge b\\cdot \\dbinom{k+1}{2}+(|Q|-b)\\cdot\\dbinom{k}{2}\\\\\r\n&amp;=\\dfrac{(k-1)k}{2}\\cdot |Q|+kb\\\\\r\n&amp;=\\dfrac{(|U|-b)(|U|-|Q|+b)}{2} &amp;\\qquad(A)\\\\\r\n&amp;=\\dfrac{b(|Q|-b)}{2|Q|}+\\left(\\dfrac{|U|^2}{2|Q|}-\\dfrac{|U|}{2}\\right)\\\\\r\n&amp;\\ge \\dfrac{|U|^2}{2|Q|}-\\dfrac{|U|}{2}\r\n\\end{aligned}\\)\r\n其中步骤\\((A)\\)代入了\\(k=\\dfrac{|U|-b}{|Q|}\\)。根据\\(c(h)\\)的值，有\r\n\\[C=\\sum_{h\\in\\mathscr{H}} c(h)\\ge\r\n|\\mathscr{H}|\\cdot\r\n\\left(\\dfrac{|U|^2}{2|Q|}-\\dfrac{|U|}{2}\\right)\\qquad(2)\\]\r\n结合\\((1),(2)\\)两个不等式，得到\\(|\\mathscr{H}|\\cdot\r\n\\left(\\dfrac{|U|^2}{2|Q|}-\\dfrac{|U|}{2}\\right)\\le \\epsilon\\cdot\r\n|\\mathscr{H}|\\cdot \\dfrac{|U|^2}{2}\\)，最终化简得到\\(\\epsilon\\ge\\dfrac{1}{|Q|}-\\dfrac{1}{|U|}\\)。\r\n那么得到不等式$$\r\n\\(\\star\\)\r\n11.3-6\r\n假设这任意不同的两个\\(d\\)元组为\\(a=\\langle\r\na_0,a_1,\\dots,a_{d-1}\\rangle,a&#39;=\\langle\r\na_0&#39;,a_1&#39;,\\dots,a_{d-1}&#39;\\rangle\\)，其中，不同是指\\(\\exist i\\in[0,d),a_i\\neq\r\na_i&#39;\\)）。令\\(F(b)=(h_b(a)-h_b(a&#39;)) \\bmod\r\np\\)，那么有\r\n\\[F(b)=\\left(\\sum_{i=0}^{d-1}(a_i-a_i&#39;)b^i\\right)\\bmod\r\np\\]\r\n可以看出，\\(F(b)\\)仍然是一个至多为\\(d-1\\)次项的多项式。考虑方程\\(F(b)=0\\)的解，根据题目31.4-4的结论，这个方程最多有\\(d-1\\)个不同的解。也就是说，最多有\\(t-1\\)个不同的\\(b\\in \\mathbb{Z}_p\\)，使得\\(h_b(a)=h_b(a&#39;)\\)成立。\r\n那么，由于函数簇\\(\\mathscr{H}\\)一共有\\(p\\)个函数，即\\(b\\)取遍集合\\(\\mathbb{Z}_p\\)的值，因此，对于所有不同的\\(d\\)元组对\\(a,a&#39;\\)，有\\(\\Pr\\{h_b(a)=h_b(a&#39;)\\}\\le\r\n\\dfrac{d-1}{p}\\)。因此函数簇\\(\\mathscr{H}\\)是\\(\\dfrac{d-1}{p}\\)-全域的。\r\n","categories":["算法导论"]},{"title":"算法导论11.4 Exercises 答案","url":"/introduction-to-algorithms/chapter-11/exercises-4/","content":"\r\n11.4-1\r\n线性探测的过程如下：\r\n\\(\\begin{array}{c}\r\n0:\\\\1:\\\\2:\\\\3:\\\\4:\\\\5:\\\\6:\\\\7:\\\\8:\\\\9:\\\\10:\\\\\r\n\\end{array}\r\n\\begin{array}{|c|}\r\n\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\r\n10\\\\\\hline\r\n\\end{array}\r\n\\rightarrow\r\n\\begin{array}{|c|}\r\n\\hline22\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\r\n10\\\\\\hline\r\n\\end{array}\r\n\\rightarrow\r\n\\begin{array}{|c|}\r\n\\hline22\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline31\\\\\\hline\r\n10\\\\\\hline\r\n\\end{array}\r\n\\rightarrow\r\n\\begin{array}{|c|}\r\n\\hline22\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline4\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline31\\\\\\hline\r\n10\\\\\\hline\r\n\\end{array}\r\n\\rightarrow\r\n\\begin{array}{|c|}\r\n\\hline22\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline4\\\\\\hline15\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline31\\\\\\hline\r\n10\\\\\\hline\r\n\\end{array}\r\n\\rightarrow\r\n\\begin{array}{|c|}\r\n\\hline22\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline4\\\\\\hline15\\\\\\hline28\\\\\\hline\\\\\\hline\\\\\\hline31\\\\\\hline\r\n10\\\\\\hline\r\n\\end{array}\r\n\\rightarrow\r\n\\begin{array}{|c|}\r\n\\hline22\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline4\\\\\\hline15\\\\\\hline28\\\\\\hline17\\\\\\hline\\\\\\hline31\\\\\\hline\r\n10\\\\\\hline\r\n\\end{array}\r\n\\rightarrow\r\n\\begin{array}{|c|}\r\n\\hline22\\\\\\hline88\\\\\\hline\\\\\\hline\\\\\\hline4\\\\\\hline15\\\\\\hline28\\\\\\hline17\\\\\\hline\\\\\\hline31\\\\\\hline\r\n10\\\\\\hline\r\n\\end{array}\r\n\\rightarrow\r\n\\begin{array}{|c|}\r\n\\hline22\\\\\\hline88\\\\\\hline\\\\\\hline\\\\\\hline4\\\\\\hline15\\\\\\hline28\\\\\\hline17\\\\\\hline59\\\\\\hline31\\\\\\hline\r\n10\\\\\\hline\r\n\\end{array}\\)\r\n二次探测的过程如下：\r\n\\(\\begin{array}{c}\r\n0:\\\\1:\\\\2:\\\\3:\\\\4:\\\\5:\\\\6:\\\\7:\\\\8:\\\\9:\\\\10:\\\\\r\n\\end{array}\r\n\\begin{array}{|c|}\r\n\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\r\n10\\\\\\hline\r\n\\end{array}\r\n\\rightarrow\r\n\\begin{array}{|c|}\r\n\\hline22\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\r\n10\\\\\\hline\r\n\\end{array}\r\n\\rightarrow\r\n\\begin{array}{|c|}\r\n\\hline22\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline31\\\\\\hline\r\n10\\\\\\hline\r\n\\end{array}\r\n\\rightarrow\r\n\\begin{array}{|c|}\r\n\\hline22\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline4\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline31\\\\\\hline\r\n10\\\\\\hline\r\n\\end{array}\r\n\\rightarrow\r\n\\begin{array}{|c|}\r\n\\hline22\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline4\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline15\\\\\\hline31\\\\\\hline\r\n10\\\\\\hline\r\n\\end{array}\r\n\\rightarrow\r\n\\begin{array}{|c|}\r\n\\hline22\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline4\\\\\\hline\\\\\\hline28\\\\\\hline\\\\\\hline15\\\\\\hline31\\\\\\hline\r\n10\\\\\\hline\r\n\\end{array}\r\n\\rightarrow\r\n\\begin{array}{|c|}\r\n\\hline22\\\\\\hline\\\\\\hline\\\\\\hline17\\\\\\hline4\\\\\\hline\\\\\\hline28\\\\\\hline\\\\\\hline15\\\\\\hline31\\\\\\hline\r\n10\\\\\\hline\r\n\\end{array}\r\n\\rightarrow\r\n\\begin{array}{|c|}\r\n\\hline22\\\\\\hline\\\\\\hline88\\\\\\hline17\\\\\\hline4\\\\\\hline\\\\\\hline28\\\\\\hline\\\\\\hline15\\\\\\hline31\\\\\\hline\r\n10\\\\\\hline\r\n\\end{array}\r\n\\rightarrow\r\n\\begin{array}{|c|}\r\n\\hline22\\\\\\hline\\\\\\hline88\\\\\\hline17\\\\\\hline4\\\\\\hline\\\\\\hline28\\\\\\hline59\\\\\\hline15\\\\\\hline31\\\\\\hline\r\n10\\\\\\hline\r\n\\end{array}\\)\r\n双重散列的过程如下：\r\n\\(\\begin{array}{c}\r\n0:\\\\1:\\\\2:\\\\3:\\\\4:\\\\5:\\\\6:\\\\7:\\\\8:\\\\9:\\\\10:\\\\\r\n\\end{array}\r\n\\begin{array}{|c|}\r\n\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\r\n10\\\\\\hline\r\n\\end{array}\r\n\\rightarrow\r\n\\begin{array}{|c|}\r\n\\hline22\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\r\n10\\\\\\hline\r\n\\end{array}\r\n\\rightarrow\r\n\\begin{array}{|c|}\r\n\\hline22\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline31\\\\\\hline\r\n10\\\\\\hline\r\n\\end{array}\r\n\\rightarrow\r\n\\begin{array}{|c|}\r\n\\hline22\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline4\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline31\\\\\\hline\r\n10\\\\\\hline\r\n\\end{array}\r\n\\rightarrow\r\n\\begin{array}{|c|}\r\n\\hline22\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline4\\\\\\hline15\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline31\\\\\\hline\r\n10\\\\\\hline\r\n\\end{array}\r\n\\rightarrow\r\n\\begin{array}{|c|}\r\n\\hline22\\\\\\hline\\\\\\hline\\\\\\hline\\\\\\hline4\\\\\\hline15\\\\\\hline28\\\\\\hline\\\\\\hline\\\\\\hline31\\\\\\hline\r\n10\\\\\\hline\r\n\\end{array}\r\n\\rightarrow\r\n\\begin{array}{|c|}\r\n\\hline22\\\\\\hline\\\\\\hline\\\\\\hline17\\\\\\hline4\\\\\\hline15\\\\\\hline28\\\\\\hline\\\\\\hline\\\\\\hline31\\\\\\hline\r\n10\\\\\\hline\r\n\\end{array}\r\n\\rightarrow\r\n\\begin{array}{|c|}\r\n\\hline22\\\\\\hline\\\\\\hline\\\\\\hline17\\\\\\hline4\\\\\\hline15\\\\\\hline28\\\\\\hline88\\\\\\hline\\\\\\hline31\\\\\\hline\r\n10\\\\\\hline\r\n\\end{array}\r\n\\rightarrow\r\n\\begin{array}{|c|}\r\n\\hline22\\\\\\hline\\\\\\hline59\\\\\\hline17\\\\\\hline4\\\\\\hline15\\\\\\hline28\\\\\\hline88\\\\\\hline\\\\\\hline31\\\\\\hline\r\n10\\\\\\hline\r\n\\end{array}\\)\r\n11.4-2\r\n为了支持删除操作，需要对HASH-SEARCH, HASH-INSERT进行修改。另外删除操作由算法HASH-DELETE'给出。\r\nHASH-INSERT&#x27;(T, k)  i = 0  repeat    q = h(k, i)    if T[q] == NIL or T[q] == DELETED      T[q] = k      return q    else i = i + 1  until i == m  error “hash table overflow”// 也就是说，查找并不需要进行任何修改。HASH-SEARCH&#x27;(T, k)  return HASH-SEARCH(T, k)HASH-DELETE&#x27;(T, k)  q = HASH-INSERT&#x27;(T, k)  T[q] = DELETED\r\n11.4-3\r\n\\(\\begin{array}{|c|c|c|}\r\n\\hline\r\n\\alpha &amp; \\texttt{unsuccessful}(E[\\alpha]\\le \\dfrac{1}{1-\\alpha})\r\n&amp; \\texttt{successful}(E[\\alpha]\\le \\dfrac{1}{\\alpha} \\ln\r\n\\dfrac{1}{1-\\alpha})\\\\\r\n\\hline\r\n\\dfrac{3}{4} &amp; 4 &amp; \\dfrac{4 \\ln 4}{3} \\approx 1.84839\\\\\r\n\\hline\r\n\\dfrac{7}{8} &amp; 8 &amp; \\dfrac{8 \\ln 8}{7} \\approx 2.73650\\\\\r\n\\hline\r\n\\end{array}\\)\r\n11.4-4\r\n令随机变量\\(X_i\\)表示第\\(i\\)个键插入所期望的时间，令随机变量\\(S\\)表示查找一次所期望的时间，假设每个键被查询的概率是相同的，并且插入的键各不相同，那么有\\(\\displaystyle{E[S]=E\\left[\\dfrac{1}{m}\\sum_{n=1}^m\r\nX_n\\right]=\\dfrac{1}{m}\\sum_{n=1}^m\r\nE[X_n]}\\)。并且可以知道，一次查询键\\(k\\)的时间和当初插入键\\(k\\)的时间相等，而当初插入键\\(k\\)的时间就相当于插入\\(k\\)前一次不成功查找的时间。因此，令随机变量\\(Y_n\\)表示当填充因子为\\(\\dfrac{n}{m}(0\\le n&lt;\r\nm)\\)时，进行一次不成功查找的时间。可以知道\\(Y_{n}=X_{n+1}\\)。根据定理11.6的结果，有\\(E[Y_n]\\le\r\n\\dfrac{1}{1-n/m}=\\dfrac{m}{m-n}\\)。\r\n最终计算\\(E[S]\\)的值，有\r\n\\(\\begin{aligned}\r\nE[S]&amp;=\\dfrac{1}{m}\\sum_{n=1}^m E[X_n]\\\\\r\n&amp;=\\dfrac{1}{m}\\sum_{n=0}^{m-1} E[Y_n]\\\\\r\n&amp;\\le \\dfrac{1}{m}\\sum_{n=0}^{m-1}\\dfrac{m}{m-n}\\\\\r\n&amp;= \\sum_{n=0}^{m-1}\\dfrac{1}{m-n}\\\\\r\n&amp;= \\sum_{n=1}^{m}\\dfrac{1}{n}\\\\\r\n&amp;= H_m\r\n\\end{aligned}\\)\r\n\\(\\star\\)\r\n11.4-5\r\n令集合\\(S=\\{h(k,i)|i\\in\r\n\\mathbb{Z}_m\\}\\)。那么在一次不成功的查找中，它需要探测\\(t=|S|\\)个槽。因此，此时我们考虑集合\\(S\\)的大小\\(t\\)。根据同余的性质，可知\\(t=|(\\{h_1(k)+i\\cdot h_2(k))\\bmod m|i\\in\r\n\\mathbb{Z}_m\\}|=|\\{i\\cdot h_2(k)\\bmod m|i\\in\r\n\\mathbb{Z}_m\\}|\\)。令\\(S&#39;=\\{i\\cdot\r\nh_2(k)\\bmod m|i\\in \\mathbb{Z}_m\\}\\)。\r\n如果一个数\\(v\\in\r\nS&#39;\\)，当且仅当关于\\(i\\)的同余方程\\(i\\cdot h_2(i)\\equiv v\\pmod\r\nm\\)有解，根据推论31.21，有\\(d\\mid\r\nv\\)。因此，\\(t=\\dfrac{m}{d}\\)。\r\n也就是说，在这一次不成功的查找中，将会有\\(\\dfrac{1}{d}\\)的槽会被探测。当\\(d=1\\)时，所有的槽都将会被探测。\r\n\\(\\star\\)\r\n11.4-6\r\n令\\(\\alpha\\)为装填因子。进行一次不成功查找的期望探测次数的上界为\\(\\dfrac{1}{1-\\alpha}\\)，进行一次成功查找的期望探测次数的上界为\\(\\dfrac{1}{\\alpha} \\ln\r\n\\dfrac{1}{1-\\alpha}\\)。如果不成功查找的期望探测次数为成功时的两倍，通过上界估计，可以列出方程：\r\n\\[\\dfrac{1}{1-\\alpha}=2\\cdot\r\n\\dfrac{1}{\\alpha} \\ln \\dfrac{1}{1-\\alpha}\\]\r\n这个方程无法手动求解。考虑使用Mathematica代码NSolve[1/(1 - x) == 2/x*Log[1/(1 - x)], x]进行计算，最终得到结果\\(\\alpha \\approx 0.715332\\)。\r\n","categories":["算法导论"]},{"title":"算法导论11.5 Exercises 答案","url":"/introduction-to-algorithms/chapter-11/exercises-5/","content":"\r\n\\(\\star\\)\r\n11.5-1\r\n令\\(g_a(k)=(2k^2+ak)\\bmod\r\n2^w\\)。使用反证法证明函数\\(g_a(w)\\)是双射的。\r\n假设\\(\\exists x,y\\in\\mathbb{Z}_{2^w},x\\neq\r\ny,g_a(x)=g_a(y)\\)，那么可以列出如下同余等式：\r\n\\[2x^2+ax\\equiv\r\n2y^2+ay\\pmod{2^w}\\]\r\n经过化简后，得到\\((x-y)(2(x+y)+a)\\equiv\r\n0\\pmod{2^w}\\)。这说明\\(2^w\\mid\r\n(x-y)(2(x+y)+a)\\)。然而，\\(a\\)是奇数，因此其中一个因子\\(2(x+y)+a\\)必定是奇数，\\(2^w\\)不可能整除这个因子，由此引出矛盾。因此\\(g_a(k)\\)是一个单射函数。由于\\(g_a(k)\\)是从\\(\\mathbb{Z}_{2^w}\\)映射到\\(\\mathbb{Z}_{2^w}\\)的，那么可以说明函数\\(g_a(k)\\)是双射的。\r\n不难说明\\(f_a(k)=\\text{swap}(g_a(k))\\)是双射的。假设\\(y\\in\\mathbb{Z}_{2^w},y&#39;=\\text{swap}(y)\\)，令\\(x,x&#39;\\)是满足\\(g_a(x)=y,g_a(x&#39;)=y&#39;\\)的两个值，那么有\\(f_a(x)=y&#39;,f_a(x&#39;)=y\\)。\\(g\\)到\\(f\\)对操作无非是将\\(x,x&#39;\\)的函数值进行交换，因此\\(f_a(k)=\\text{swap}(g_a(k))\\)仍然是双射的。\r\n接下来使用归纳法说明\\(f_a^{(r)}=f(f_a^{(r-1)})\\)是双射的。当\\(r=1\\)时，\\(f_a^{(1)}=f_a\\)是双射函数；当\\(r&gt;1\\)时，假设\\(f_a^{(r-1)}\\)是双射函数，由于外层的嵌套\\(f_a(\\cdot)\\)是双射函数，因此这个操作也仅仅是对原来的输出重新进行了一次置换。最终\\(f_a^{(r)}\\)是双射函数。\r\n\\(\\star\\)\r\n11.5-2\r\n根据随机预言机的定义，对于每个询问的\\(x\\in\r\nU\\)，如果之前从未询问过，那么从\\(\\mathbb{Z}_m\\)中均匀随机选择一个特定值存储下来并返回；否则直接返回之前存储下来随机选过的值。\r\n由于第一次询问时是从\\(\\mathbb{Z}_m\\)中均匀随机选择的，因此对于\\(\\forall x\\in U,y\\in\r\n\\mathbb{Z}_m,\\Pr\\{h(x)=y\\}=\\dfrac{1}{m}\\)。\r\n随机预言机中，为\\(x\\)选择一个\\(y\\)的操作与其它的\\(x&#39;\\in\r\nU\\)选择值没有关系，因此对于所有\\(x\\in\r\nU\\)，它们都是相互独立的，即\\(\\displaystyle{\\Pr\\left\\{\\bigwedge_{x\\in U}\r\nh(x)=y_x\\right\\}}=\\dfrac{1}{m^{|D|}}\\)。因此随机预言机是\\(|U|\\)-独立的。在高层次上的\\(|U|\\)-独立性都成立，那么在低层次上，随机预言机是\\(5\\)-独立的。\r\n\\(\\star\\)\r\n11.5-3\r\n本题考察的是函数\\(f_a^{(r)}\\)的雪崩效应。\r\n如图所示，当选择的比特\\(k_i\\)满足\\(i&gt;\\dfrac{w}{2}\\)时，至少需要进行\\(3\\)轮的迭代才会使所有比特可能都产生反转；否则只需要\\(2\\)轮就可以使所有比特可能都产生反转。\r\n图中\\(3\\)种情况分别对应\\(i&gt;\\dfrac{w}{2},i=\\dfrac{w}{2},i&lt;\\dfrac{w}{2}\\)时的一般情况。\r\n\r\n","categories":["算法导论"]},{"title":"算法导论13.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-13/exercises-3/","content":"\r\n13.3-1\r\n因为使用黑色节点进行处理会破坏性质5。假设\\(T\\)的根节点为\\(r\\)，新增的黑色节点\\(z\\)的父节点是\\(p\\)，那么从\\(r\\)到\\(p\\)这条路径中，左右子树的黑高都不一致，极难维护。\r\n13.3-2\r\n如下是按顺序插入的红黑树形态。\r\n\r\n\\(41\\)\r\n\r\ngraph TD  41((41))  classDef red-node fill:red, color:white;  classDef black-node fill:black, color:white;  class 41 black-node;\r\n\r\n\\(38\\)\r\n\r\ngraph TD  41((41));38((38));  A(( ));  classDef red-node fill:red, color:white;  classDef black-node fill:black, color:white;  class 41 black-node;  class 38 red-node;  41---38;  41---A;  style A fill:#f100,stroke-width:0px  linkStyle 1 stroke:#0ff,stroke-width:0px\r\n\r\n\\(31\\)\r\n\r\ngraph TD  41((41));38((38));31((31));  classDef red-node fill:red, color:white;  classDef black-node fill:black, color:white;  class 38 black-node;  class 31,41 red-node;  38---31;38---41;\r\n\r\n\\(31\\)\r\n\r\ngraph TD  41((41));38((38));31((31));12((12));  A(( ));  classDef red-node fill:red, color:white;  classDef black-node fill:black, color:white;  class 38,31,41 black-node;  class 12 red-node;  38---31;38---41;31---12;  31---A;  style A fill:#f100,stroke-width:0px  linkStyle 3 stroke:#0ff,stroke-width:0px\r\n\r\n\\(19\\)\r\n\r\ngraph TD  41((41));38((38));19((19));12((12));  31((31));  classDef red-node fill:red, color:white;  classDef black-node fill:black, color:white;  class 38,19,41 black-node;  class 12,31 red-node;  38---19;38---41;19---12;19---31;\r\n\r\n\\(8\\)\r\n\r\ngraph TD  41((41));38((38));19((19));12((12));  31((31));8((8));  A(( ));  classDef red-node fill:red, color:white;  classDef black-node fill:black, color:white;  class 12,31,38,41 black-node;  class 8,19 red-node;  38---19;38---41;19---12;19---31;  12---8;  12---A;  style A fill:#f100,stroke-width:0px  linkStyle 5 stroke:#0ff,stroke-width:0px\r\n13.3-3\r\n以下图示中，\\(v/k\\)表示节点\\(v\\)的黑高为\\(k\\)。\r\n下图是对图13.5(a)的标记，可以看出，变化前和变化后，节点\\(C\\)的父节点（如果存在）黑高仍然是\\(k+1\\)，并没有改变。\r\ngraph TD    A((A/k));B((B/k));C((C/k));D((D/k))    a[α/k];b[β/k];c[γ/k];d[δ/k];e[ε/k];    Z(( ))    classDef hide-appearance fill:transparent, stroke:transparent;    classDef hide-node display:none;    classDef red-node fill:red, color:white;    classDef black-node fill:black, color:white;    class C black-node;    class A,B,D red-node;    class a,b,c,d,e hide-appearance;    class Z hide-node;    Z---C;C---A;C---D;    A---B;B---a;B---b;A---c;D---d;    D---e;\r\ngraph TD    A&#x27;((A/k));B&#x27;((B/k));C&#x27;((C/k+1));D&#x27;((D/k))    a&#x27;[α/k];b&#x27;[β/k];c&#x27;[γ/k];d&#x27;[δ/k];e&#x27;[ε/k];    Z&#x27;(( ))    classDef hide-appearance fill:transparent, stroke:transparent;    classDef hide-node display:none;    classDef red-node fill:red, color:white;    classDef black-node fill:black, color:white;    class A&#x27;,D&#x27; black-node;    class C&#x27;,B&#x27; red-node;    class a&#x27;,b&#x27;,c&#x27;,d&#x27;,e&#x27; hide-appearance;    class Z&#x27; hide-node;    Z&#x27;---C&#x27;;C&#x27;---A&#x27;;C&#x27;---D&#x27;;A&#x27;---B&#x27;;    B&#x27;---a&#x27;;B&#x27;---b&#x27;;A&#x27;---c&#x27;;D&#x27;---d&#x27;;    D&#x27;---e&#x27;;\r\n下图是对图13.5(b)的标记。与图13.5(a)的情形类似。\r\ngraph TD    A((A/k));B((B/k));C((C/k));D((D/k))    a[α/k];b[β/k];c[γ/k];d[δ/k];e[ε/k];    Z(( ))    classDef hide-appearance fill:transparent, stroke:transparent;    classDef hide-node display:none;    classDef red-node fill:red, color:white;    classDef black-node fill:black, color:white;    class C black-node;    class A,B,D red-node;    class a,b,c,d,e hide-appearance;    class Z hide-node;    Z---C;C---B;B---A;C---D;A---a;    A---b;B---c;D---d;    D---e;\r\ngraph TD    A&#x27;((A/k));B&#x27;((B/k));C&#x27;((C/k+1));D&#x27;((D/k))    a&#x27;[α/k];b&#x27;[β/k];c&#x27;[γ/k];d&#x27;[δ/k];e&#x27;[ε/k];    Z&#x27;(( ))    classDef hide-appearance fill:transparent, stroke:transparent;    classDef hide-node display:none;    classDef red-node fill:red, color:white;    classDef black-node fill:black, color:white;    class B&#x27;,D&#x27; black-node;    class C&#x27;,A&#x27; red-node;    class a&#x27;,b&#x27;,c&#x27;,d&#x27;,e&#x27; hide-appearance;    class Z&#x27; hide-node;    Z&#x27;---C&#x27;;C&#x27;---B&#x27;;B&#x27;---A&#x27;;C&#x27;---D&#x27;;A&#x27;---a&#x27;;    A&#x27;---b&#x27;;B&#x27;---c&#x27;;D&#x27;---d&#x27;;    D&#x27;---e&#x27;;\r\n下图是对图13.6的标记，可以看出，\\(3\\)种变化形式下，节点\\(C\\)的父节点（如果存在）黑高仍然是\\(k+1\\)，并没有改变。\r\ngraph TD    A((A/k));B((B/k));C((C/k));    a[α/k];b[β/k];c[γ/k];d[δ/k];    Z(( ))    classDef hide-appearance fill:transparent, stroke:transparent;    classDef hide-node display:none;    classDef red-node fill:red, color:white;    classDef black-node fill:black, color:white;    class C black-node;    class A,B red-node;    class a,b,c,d hide-appearance;    class Z hide-node;    Z---C;C---A;A---a;A---B;    B---b;B---c;C---d;\r\ngraph TD    A&#x27;((A/k));B&#x27;((B/k));C&#x27;((C/k));    a&#x27;[α/k];b&#x27;[β/k];c&#x27;[γ/k];d&#x27;[δ/k];    Z&#x27;(( ))    classDef hide-appearance fill:transparent, stroke:transparent;    classDef hide-node display:none;    classDef red-node fill:red, color:white;    classDef black-node fill:black, color:white;    class C&#x27; black-node;    class A&#x27;,B&#x27; red-node;    class a&#x27;,b&#x27;,c&#x27;,d&#x27; hide-appearance;    class Z&#x27; hide-node;    Z&#x27;---C&#x27;;C&#x27;---B&#x27;;A&#x27;---a&#x27;;A&#x27;---b&#x27;;    B&#x27;---A&#x27;;B&#x27;---c&#x27;;C&#x27;---d&#x27;;\r\ngraph TD    A&#x27;&#x27;((A/k));B&#x27;&#x27;((B/k));C&#x27;&#x27;((C/k));    a&#x27;&#x27;[α/k];b&#x27;&#x27;[β/k];c&#x27;&#x27;[γ/k];d&#x27;&#x27;[δ/k];    Z&#x27;&#x27;(( ))    classDef hide-appearance fill:transparent, stroke:transparent;    classDef hide-node display:none;    classDef red-node fill:red, color:white;    classDef black-node fill:black, color:white;    class B&#x27;&#x27; black-node;    class A&#x27;&#x27;,C&#x27;&#x27; red-node;    class a&#x27;&#x27;,b&#x27;&#x27;,c&#x27;&#x27;,d&#x27;&#x27; hide-appearance;    class Z&#x27;&#x27; hide-node;    Z&#x27;&#x27;---B&#x27;&#x27;;B&#x27;&#x27;---A&#x27;&#x27;;B&#x27;&#x27;---C&#x27;&#x27;;A&#x27;&#x27;---a&#x27;&#x27;;    A&#x27;&#x27;---b&#x27;&#x27;;C&#x27;&#x27;---c&#x27;&#x27;;C&#x27;&#x27;---d&#x27;&#x27;;\r\n13.3-4\r\n当\\(z\\)是根节点时，由于\\(z.p=T.nil\\)，并且\\(T.nil\\)是黑色的，因此它在while循环的判断就会失败，此时循环直接跳出，并将根节点\\(z\\)改成黑色。\r\n它并不会对\\(T.nil\\)进行任何操作，因此这个担心是多余的。\r\n13.3-5\r\n由于节点数\\(n&gt;1\\)，因此第二次插入的节点\\(z\\)一开始所在位置必定不在根中。类似的，我们只考虑\\(z.p==z.p.p.left\\)时的一种情形（另一种是对称的，证明方法相同，此处忽略）。考虑这两种情况：\r\n\r\nWHILE循环体的内部没有被执行过。这说明新加入\\(z\\)节点后，整棵树的形态没有发生变化（哪怕原来的树全部节点都是黑色）。由于\\(z\\)不是根节点，因此第RB-INSERT第30行的代码不可能是对\\(z\\)染成黑色。因此这种情况下，\\(z\\)是在这棵树中存在的红色节点，原结论成立。\r\nWHILE循环体的内部有被执行过。那么先考虑Case\r\n1，由于当前的叔节点是红色，因此\\(z\\)的父节点\\(z.p\\)和其兄弟节点被染成黑色后，其祖父节点\\(z.p.p\\)染成红色。后续只处理\\(z.p.p\\)及其祖先上的情况，这时的\\(z\\)仍然是树中的一个红色节点，因此原结论成立。接下来同时考虑Case\r\n2和3，由于Case 2包含在Case 3中，因此只考虑Case 3的情况。在对\\(z.p.p\\)进行右旋后，\\(z.p\\)被染成黑色，此时WHILE循环终止，\\(z\\)节点仍然是红色。这个\\(z\\)节点说明树中仍存在红色节点，原结论成立。\r\n\r\n综上所述，原结论是正确的。\r\n13.3-6\r\n首先旋转操作都需要提供父节点来保证父节点可以指向正确的儿子，改动后的旋转算法为LEFT-ROTATE'和RIGHT-ROTATE'所示：\r\nLEFT-ROTATE&#x27;(T, p, x)  y = x.right  x.right = y.left  if p == T.nil    T.root = y  else if p.left == x    p.left = y  else    p.right = y  y.left = xRIGHT-ROTATE&#x27;(T, p, y)  x = y.left  y.left = x.right  if p == T.nil    T.root = x  else if p.left == y    p.left = x  else    p.right = x  x.right = y\r\n那么由于没有了父节点指针，在普通的插入过程中，我们需要记录插入时遍历所遍历出来的一条路径，并且在FIXUP操作过程中，逆序遍历这条路径并且进行对应的操作。整个算法分别由RB-INSERT'和RB-INSERT-FIXUP'给出。因此，整个完整的插入过程的时间复杂度为\\(O(\\lg n)\\)。\r\nRB-INSERT&#x27;(T, z)  // P是从T.root到z的一条路径。  let P be new array  INSERT(P, T.nil)  x = T.root  y = T.nil  while x ≠ T.nil    INSERT(P, x)    y = x    if z.key &lt; x.key      x = x.left    else      x = x.right  if y == T.nil    T.root = z  else if z.key &lt; y.key    y.left = z  else     y.right = z  z.left = T.nil  z.right = T.nil  z.color = RED  INSERT(P, z)  RB-INSERT-FIXUP&#x27;(T, P)// P是从T.root到z中路径的所有节点RB-INSERT-FIXUP&#x27;(T, P)  i = P.size - 1  while i &gt; 0 and P[i - 1].color == RED    if P[i - 1] == P[i - 2].left      y = P[i - 2].right      if y.color == RED        P[i - 1].color = BLACK        y.color = BLACK        P[i - 2].color = RED        i = i - 2      else        if P[i] == P[i - 1].right          LEFT-ROTATE&#x27;(T, P[i - 2], P[i - 1])          exchange P[i] with P[i - 1]        P[i - 1].color = BLACK        P[i - 2].color = RED        RIGHT-ROTATE&#x27;(T, P[i - 3], P[i - 2])        // 此时路径序列已经改变，不过也没有所谓，因为之后由于P[i - 1].color == BLACK使得这个循环被跳出。    else      y = P[i - 2].left      if y.color == RED        P[i - 1].color = BLACK        y.color = BLACK        P[i - 2].color = RED        i = i - 2      else        if P[i] == P[i - 1].left          RIGHT-ROTATE&#x27;(T, P[i - 2], P[i - 1])          exchange P[i] with P[i - 1]        P[i - 1].color = BLACK        P[i - 2].color = RED        LEFT-ROTATE&#x27;(T, P[i - 3], P[i - 2])\r\n","categories":["算法导论"]},{"title":"算法导论11 Problems 答案","url":"/introduction-to-algorithms/chapter-11/problems/","content":"\r\n11-1\r\na\r\n令随机变量\\(X_i\\)表示第\\(i\\)个键插入所期望的时间。在第\\(i\\)次插入时，哈希表中已经有\\(i-1\\)个键，执行一次插入操作相当于执行了一次不成功查找。令随机变量\\(Y_i\\)表示当填充因子为\\(\\dfrac{i}{m}(0\\le i&lt;\r\nm)\\)时，进行一次不成功查找的时间，那么可以知道\\(X_i=Y_{i+1}\\)。考虑计算\\(\\Pr\\{Y_i&gt;p\\}\\)的值，根据定理11.6，有\r\n\\(\\begin{aligned}\r\n\\Pr\\{Y_i&gt;p\\} &amp;= \\Pr\\{Y_i\\ge p+1\\}\\\\\r\n&amp;\\le \\left(\\dfrac{n}{m}\\right)^p\\\\\r\n&amp;\\le 2^{-p} &amp;\\qquad(A)\r\n\\end{aligned}\\)\r\n其中步骤\\((A)\\)使用了假设\\(n\\le m/2\\)。\r\n那么，进行一次插入操作时使用了严格多于\\(p\\)次探测的概率为\\(\\Pr\\{X_i&gt;p\\}=\\Pr\\{Y_{i+1}&gt;p\\}=2^{-p}\\)。\r\nb\r\n考虑计算\\(\\Pr\\{Y_i&gt;p\\}\\)的值，根据定理11.6，有\r\n\\(\\begin{aligned}\r\n\\Pr\\{Y_i&gt;2\\lg n\\} &amp;= \\Pr\\{Y_i\\ge 2\\lg n+1\\}\\\\\r\n&amp;\\le \\left(\\dfrac{n}{m}\\right)^{2\\lg n}\\\\\r\n&amp;\\le \\left(\\dfrac{1}{2}\\right)^{2\\lg n}\\\\\r\n&amp;=\\dfrac{1}{n^2}\r\n\\end{aligned}\\)\r\n因此有\\(\\Pr\\{X_i&gt;2\\lg\r\nn\\}=\\Pr\\{Y_{i+1}&gt;2\\lg n\\}=O(1/n^2)\\)。\r\nc\r\n令事件\\(A_i\\)表示\\(X_i&gt;2\\lg n\\)。那么有\r\n\\(\\begin{aligned}\r\n\\Pr\\{X&gt;2\\lg n\\} &amp;= \\Pr\\left\\{\\max_{i=1}^n X_i&gt;2\\lg n\\right\\}\\\\\r\n&amp;=\\Pr\\left\\{\\bigcup_{i=1}^n A_i\\right\\}\\\\\r\n&amp;\\le \\sum_{i=1}^n \\Pr\\{A_i\\}\\\\\r\n&amp;= \\sum_{i=1}^n \\Pr\\{X_i&gt;2\\lg n\\}\\\\\r\n&amp;\\le n\\cdot \\dfrac{1}{n^2}\\\\\r\n&amp;= \\dfrac{1}{n}\r\n\\end{aligned}\\)\r\n因此有\\(\\Pr\\{X&gt;2\\lg\r\nn\\}=O(1/n)\\)。\r\nd\r\n\\(\\begin{aligned}\r\nE[X] &amp;= \\sum_{i=1}^{\\infty} \\Pr\\{X\\ge i\\}\\\\\r\n&amp;=\\sum_{i=1}^{2\\lg n} \\Pr\\{X\\ge i\\}+\\sum_{i=2\\lg n+1}^{n} \\Pr\\{X\\ge\r\ni\\}+\\sum_{i=n+1}^{\\infty} \\Pr\\{X\\ge i\\}\\\\\r\n&amp;\\le\\sum_{i=1}^{2\\lg n} 1+\\sum_{i=2\\lg n+1}^{n} \\dfrac{1}{n}+0\\\\\r\n&amp;\\le\\sum_{i=1}^{2\\lg n} 1+\\sum_{i=1}^{n} \\dfrac{1}{n}\\\\\r\n&amp;=2\\lg n+1\\\\\r\n&amp;\\le 3\\lg n &amp;\\qquad(A)\r\n\\end{aligned}\\)\r\n其中，步骤\\((A)\\)假设了\\(n&gt; 1\\)，那么有\\(\\lg n\\ge 1\\)。因此有\\(E[X]=O(\\lg n)\\)。\r\n11-2\r\na\r\n离线操作：将所有元素先进行排序，需要\\(O(n\\lg n)\\)的运行时间。\r\n在线操作：使用二分法可以在\\(O(\\lg\r\nn)\\)的时间内查找一个数是否在这个有序序列中，由算法ORDERED-SEAECH给出。\r\nORDERED-SEAECH(A, n, k)  l = 1  r = n  while l &lt; r    mid = ⌊(l + r) / 2⌋    if A[mid] &gt;= k      l = mid    else      r = mid - 1  return l &lt;= n and A[l] == k\r\nb\r\n令随机变量\\(X\\)表示进行一次不成功的查找时，所需要进行探测次数的期望值。根据定理11.6，有\\(E[X]\\le\r\n\\dfrac{1}{1-\\alpha}=\\dfrac{m}{m-n}\\)。\r\n如果使用开放寻址法的运行事件至少和题目11-2-a的效率一致，那么考虑解方程\\(\\dfrac{m}{m-n}\\le c\\lg n\\)，最终得到\\(m\\ge \\dfrac{n\\lg n}{\\lg n - 1}-n\\)。\r\n经过变换，得到\\(m-n\\ge \\dfrac{n}{\\lg n -\r\n1}\\ge \\dfrac{n}{2\\lg n}\\)。\r\n因此，最终只有当额外的空间满足\\(m-n=\\Omega(n/\\lg\r\nn)\\)时，使用开放寻址法的效率才会接近二分法。\r\n11-3\r\na\r\n对于某一特定槽而言，一个键被插入该槽的概率为\\(\\dfrac{1}{n}\\)，不被插入该槽的概率为\\(1-\\dfrac{1}{n}\\)。这\\(n\\)个键的插入过程都是独立的，某一键插入该槽的情况可以看作是做一次概率为\\(\\dfrac{1}{n}\\)的伯努利实验，那么这\\(n\\)个键对该槽插入的情况相当于是做\\(n\\)次相同的伯努利实验。因此\\(k\\)服从参数为\\(n,\\dfrac{1}{n}\\)的二项分布，即\r\n\\[Q_k=b\\left(k,n,\\dfrac{1}{n}\\right)=\\left(\\dfrac{1}{n}\\right)^k\\left(1-\\dfrac{1}{n}\\right)^{n-k}\\dbinom{n}{k}\\]\r\nb\r\n令随机变量\\(X_i\\)表示第\\(i\\)个槽中的链的长度。令事件\\(A_i\\)表示\\(X_i=k\\)，事件\\(A=\\displaystyle{\\bigcap_{i=1}^n\r\nA_i}\\)。那么有\r\n\\(\\begin{aligned}\r\nP_k&amp;\\le \\Pr\\{A\\} &amp;\\qquad(A)\\\\\r\n&amp;=\\Pr\\left\\{\\bigcap_{i=1}^n A_i\\right\\}\\\\\r\n&amp;\\le \\sum_{i=1}^n \\Pr\\{A_i\\}\\\\\r\n&amp;= \\sum_{i=1}^n Q_k\\\\\r\n&amp;= nQ_k\r\n\\end{aligned}\\)\r\n其中，步骤\\(A\\)扩大了事件所代表的空间：\\(\\{X_i\\}\\)的最大值为\\(k\\)，可以推出所有随机变量中存在一个随机变量取值为\\(k\\)，而不能反向推出。\r\nc\r\n使用不等式C.6：\\(\\dbinom{n}{k}\\le\r\n\\left(\\dfrac{en}{k}\\right)^k\\)，有\r\n\\(\\begin{aligned}\r\nQ_k&amp;=\\left(\\dfrac{1}{n}\\right)^k\\left(\\dfrac{n-1}{n}\\right)^{n-k}\\dbinom{n}{k}\\\\\r\n&amp;\\le \\dfrac{(n-1)^{n-k}}{n^n} \\cdot \\dfrac{e^kn^k}{k^k}\\\\\r\n&amp;&lt; \\dfrac{n^{n-k}}{n^n} \\cdot \\dfrac{e^kn^k}{k^k}\\\\\r\n&amp;=\\dfrac{e^k}{k^k}\r\n\\end{aligned}\\)\r\nd\r\n考虑求满足条件的\\(k_0\\)使得\\(\\dfrac{e^{k_0}}{k_0^{k_0}}&lt;\\dfrac{1}{n^3}\\).两边对\\(2\\)取对数，移项后得到\r\n\\[3\\lg n&lt;k_0(\\lg k_0-\\lg\r\ne)\\]\r\n代入\\(k_0=\\dfrac{c\\lg n}{\\lg\\lg\r\nn}\\)，那么得到\\(3\\lg n&lt;\\dfrac{c\\lg\r\nn}{\\lg \\lg n}\\left(\\lg \\dfrac{c\\lg n}{\\lg\\lg n}-\\lg\r\ne\\right)\\)。\r\n假设\\(n&gt;2\\)，更进一步，可以化简到\\(\\dfrac{c}{\\lg\\lg n}\\left(\\lg c-\\lg\\lg\\lg n-\\lg\r\ne\\right)+c&gt;3\\)。\r\n令\\(g(n)=\\dfrac{c}{\\lg\\lg n}\\left(\\lg\r\nc-\\lg\\lg\\lg n-\\lg e\\right)+c\\)，可以发现\\(\\displaystyle{\\lim_{n\\rightarrow\\infty}g(n)=c}\\)。如果\\(c=4\\)，\\(\\exists\r\nn_0&gt;3,\\forall n\\ge n_0,g(n)&gt;3\\)恒成立。当\\(n&lt; n_0\\)时，令\\(c(n)\\)是满足\\(g(n)&gt;3\\)的最小\\(c\\)。那么构造出\\(c=\\displaystyle{\\max\\left\\{4,\\max_{n=3}^{n-1}\\{h(i)\\}\\right\\}}\\)。此时对于\\(\\forall n\\ge 3,g(n)&gt; 3\\)都将成立。\r\n按照如上方式，我们构造出了一个\\(c\\)，使得\\(\\forall n\\ge 3\\)，令\\(k_0=\\dfrac{c\\lg n}{\\lg\\lg\r\nn},Q_{k_0}&lt;\\dfrac{1}{n^3}\\)总成立。\r\n由于\\(c&gt;1,n&gt;2\\)，那么可以知道\\(k_0\\ge 1\\)。根据等式C.45，可以得知当\\(k\\ge k_0\\)时，\\(Q_k\\)是一个递减函数，因此\\(\\forall k\\ge\r\nk_0,Q_k&lt;\\dfrac{1}{n^3}\\)均成立。因此按照题目11-3-b的结论，\\(\\forall k\\ge k_0,P_{k_0}&lt;\r\nnQ_{k_0}&lt;\\dfrac{1}{n^2}\\)均成立。\r\ne\r\n\\(\\begin{aligned}\r\nE[M]&amp;=\\sum_{k=1}^n k\\cdot P_k\\\\\r\n&amp;=\\sum_{k=1}^{k_0} k\\cdot P_k+\\sum_{k=k_0+1}^n k\\cdot P_k\\\\\r\n&amp;\\le\\sum_{k=1}^{k_0} k_0\\cdot P_k+\\sum_{k=k_0+1}^n n\\cdot P_k\\\\\r\n&amp;=\\Pr\\{M\\le k_0\\}\\cdot k_0 + \\Pr\\{M&gt;k_0\\}\\cdot n\r\n\\end{aligned}\\)\r\n令\\(k_0=\\dfrac{c\\lg n}{\\lg\\lg\r\nn}\\)，得证关于\\(E[M]\\)的表达式。\r\n考虑计算\\(\\Pr\\{M&gt;k_0\\}\\)的上限，有\\(\\displaystyle{\\Pr\\{M&gt;k_0\\}=\\sum_{i=k_0+1}^nP_k\\le\\sum_{i=k_0+1}^n\\dfrac{1}{n^2}}\\le\r\nn\\cdot \\dfrac{1}{n^2}=\\dfrac{1}{n}\\)\r\n\\(\\begin{aligned}\r\nE[M]&amp;\\le \\Pr\\{M\\le k_0\\}\\cdot k_0 + \\Pr\\{M&gt;k_0\\}\\cdot n\\\\\r\n&amp;\\le 1\\cdot k_0+\\dfrac{1}{n}\\cdot n\\\\\r\n&amp;=k_0+1\r\n\\end{aligned}\\)\r\n因此有\\(E[M]=O\\left(\\dfrac{\\lg n}{\\lg\\lg\r\nn}\\right)\\)。\r\n11-4\r\na\r\n由于函数簇\\(\\mathscr{H}\\)是\\(2\\)-独立的，因此对任意不同的\\(k_1,k_2\\in U,\\forall d_1,d_2\\in\r\n\\mathbb{Z}_m,\\Pr\\{h(k_1)=d_1\\land\r\nh(k_2)=d_2\\}=\\dfrac{1}{m^2}\\)。\r\n那么\\(\\displaystyle{\\Pr\\{h(k_1)=h(k_2)\\}=\\sum_{d\\in\\mathbb{Z}_m}\\Pr\\{h(k_1)=d\\land\r\nh(k_2)=d\\}=m\\cdot \\dfrac{1}{m^2}=\\dfrac{1}{m}}\\)。因此函数簇\\(\\mathscr{H}\\)是全域的。\r\nb\r\n对于\\(x,y\\in U,x\\neq y\\)，考虑\\(h_a(x)=h_a(y)\\)的概率\\(\\Pr\\{h_a(x)=h_a(y)\\}\\)，即\\(\\displaystyle{\\sum_{i=0}^{n-1}a_ix_i\\equiv\\sum_{i=0}^{n-1}a_iy_i\r\n\\pmod p}\\)的概率。\r\n令\\(\\displaystyle{f(a)=\\left(\\sum_{i=0}^{n-1}a_i(x_i-y_i)\\right)\\bmod{p}}\\)。由于\\(x\\neq y\\)，因此\\(\\exists k\\in\\{0,1,2,\\dots,n-1\\},x_k\\not\\equiv y_k\r\n\\pmod p\\)成立。令\\(c=a_k(x_k-y_k)\\bmod\r\np\\)，随机变量\\(X=(f(a)-c)\\bmod\r\np,Y=f(a)\\)。\r\n考虑随机变量\\(Y\\)的分布。无论\\(X\\)的分布如何，可知有\\(\\displaystyle{\\sum_{i=0}^{p-1}\r\n\\Pr\\{X=i\\}=1}\\)。由于\\(a\\)向量是从\\(U\\)中均匀随机选择的，因此\\(a_k\\)和\\(a\\)中的其它值相互独立，并且\\(a_k\\)取到\\(\\mathbb{Z}_p\\)中的数也是等概率的。由于\\((x_k-y_k)\\)是一个固定的非零整数，并且\\(p\\)是质数，那么\\(\\gcd(p,x_k-y_k)=1\\)，因此如果\\(a_k\\)取遍\\(\\mathbb{Z}_p\\)中的所有数，\\(c\\)也会取便\\(\\mathbb{Z}_p\\)中的所有数。也就是说，\\(\\forall i\\in\r\n\\mathbb{Z}_p,\\Pr\\{c=i\\}=\\dfrac{1}{p}\\)。\r\n那么考虑计算\\(\\Pr\\{Y=j\\}\\)的值，其中\\(j\\in \\mathbb{Z}_p\\)：\r\n\\(\\begin{aligned}\r\n\\Pr\\{Y=j\\}&amp;=\\sum_{i=0}^{p-1} \\Pr\\{X=(j-i)\\bmod p\\land c=i\\}\\\\\r\n&amp;=\\sum_{i=0}^{p-1} \\Pr\\{X=(j-i)\\bmod p\\}\\cdot \\Pr\\{c=i\\}\\\\\r\n&amp;=\\sum_{i=0}^{p-1} \\Pr\\{X=(j-i)\\bmod p\\}\\cdot \\dfrac{1}{p}\\\\\r\n&amp;=\\dfrac{1}{p} \\sum_{i=0}^{p-1} \\Pr\\{X=i\\}\\\\\r\n&amp;=\\dfrac{1}{p}\r\n\\end{aligned}\\)\r\n注意在整个步骤中，\\(X\\)的分布是什么并不关心。那么得到\\(\\Pr\\{Y=0\\}=\\dfrac{1}{p}\\)，也就是说，\\(\\Pr\\{h_a(x)=h_a(y)\\}=\\Pr\\{Y=0\\}=\\dfrac{1}{p}\\)。\r\n因此，函数簇\\(\\mathscr{H}\\)是全域的。\r\n当\\(x\\)是一个全\\(0\\)元组\\(x_z\\)时，\\(\\mathscr{H}\\)不再是\\(2\\)-独立的。因为无论\\(n\\)元组\\(a\\)如何取值，\\(h_a(x_z)=0\\)总是成立的。那么对于任意\\(x&#39;\\in U-\\{x_z\\},d_1\\in\r\n\\mathbb{Z}_p-\\{0\\},d_2\\in\\mathbb{Z}_p\\)，都有\\(\\Pr\\{h(x_z)=d_1\\land\r\nh(x&#39;)=d_2\\}=0\\neq\\dfrac{1}{m^2}\\)。因此函数簇\\(\\mathscr{H}\\)不满足\\(2\\)-独立性。\r\nc\r\n可以看出，函数簇\\(\\mathscr{H}&#39;\\)一共有\\(p^{n+1}\\)个函数。\r\n令\\(x,y\\in U,x\\neq\r\ny\\)。那么对于任意\\(d_x,d_y\\in\r\n\\mathbb{Z_p}\\)，可以列出一个\\(n+1\\)元方程组：\r\n\\(\\left \\{\\begin{aligned}\r\n  &amp; \\sum_{i=0}^{n-1}a_ix_i+b\\equiv d_x\\pmod p\\\\\r\n  &amp; \\sum_{i=0}^{n-1}a_iy_i+b\\equiv d_y \\pmod p\\\\\r\n\\end{aligned}\\right.\\)\r\n这个线性方程组一共只有两个方程，并且\\(a_i,b\\)都是未知数。由于\\(x\\neq\r\ny\\)，因此这个方程组对应的系数矩阵对值的秩和增广矩阵的秩相等，均为\\(2\\)。因此，这个线性方程组有\\(n-1\\)个自由元，也就是说，有\\(p^{n-1}\\)个解。即\\(\\mathscr{H}&#39;\\)中有\\(p^{n-1}\\)个函数使得\\(h_{ab}&#39;(x)=d_x\\land\r\nh_{ab}&#39;(y)=d_{y}\\).\r\n因此\\(\\Pr\\{h_{ab}&#39;(x)=d_x\\land\r\nh_{ab}&#39;(y)=d_{y}\\}=\\dfrac{p^{n-1}}{p^{n+1}}=\\dfrac{1}{p^2}\\)。\r\n可以看出，函数簇\\(\\mathscr{H}&#39;\\)满足\\(2\\)-独立性。\r\nd\r\n由于函数簇\\(\\mathscr{H}\\)满足\\(2\\)-独立性，因此对于任意一对不同消息\\(\\langle\r\nm,m&#39;\\rangle\\)，它们出现成对的标签\\(\\langle\r\nt,t&#39;\\rangle\\)在统计上的概率都是相同的，为\\(\\dfrac{1}{p^2}\\)，由于\\(t\\)是固定的，标签\\(t&#39;\\)是\\(\\mathbb{Z}_p\\)中等可能的任意一个，因此最多只能以\\(\\dfrac{1}{p}\\)的概率伪造出来。\r\n","categories":["算法导论"]},{"title":"算法导论13.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-13/exercises-1/","content":"\r\n13.1-1\r\n这棵高度为\\(3\\)的完全二叉搜索树如下：\r\ngraph TD  1((1));2((2));3((3));4((4));  5((5));6((6));7((7));8((8));  9((9));10((10));11((11));12((12));  13((13));14((14));15((15))  8---4;8---12;4---2;4---6;  12---10;12---14;2---1;2---3;  6---5;6---7;10---9;10---11;  14---13;14---15\r\n如下是一棵黑高为\\(2\\)的红黑树。\r\ngraph TD  1((1));2((2));3((3));4((4));  5((5));6((6));7((7));8((8));  9((9));10((10));11((11));12((12));  13((13));14((14));15((15))  A[NIL];B[NIL];C[NIL];D[NIL];  E[NIL];F[NIL];G[NIL];H[NIL];  I[NIL];J[NIL];K[NIL];L[NIL];  M[NIL];N[NIL];O[NIL];P[NIL];  8---4;8---12;4---2;4---6;  12---10;12---14;2---1;2---3;  6---5;6---7;10---9;10---11;  14---13;14---15;  1---A;1---B;3---C;3---D;  5---E;5---F;7---G;7---H;  9---I;9---J;11---K;11---L;  13---M;13---N;15---O;15---P;  classDef red-node fill:red, color:white;  classDef black-node fill:black, color:white;  class 1,3,5,7,9,11,13,15,4,12 red-node;  class 2,6,10,14,8,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P black-node;\r\n如下是一棵黑高为\\(3\\)的红黑树。\r\ngraph TD  1((1));2((2));3((3));4((4));  5((5));6((6));7((7));8((8));  9((9));10((10));11((11));12((12));  13((13));14((14));15((15))  A[NIL];B[NIL];C[NIL];D[NIL];  E[NIL];F[NIL];G[NIL];H[NIL];  I[NIL];J[NIL];K[NIL];L[NIL];  M[NIL];N[NIL];O[NIL];P[NIL];  8---4;8---12;4---2;4---6;  12---10;12---14;2---1;2---3;  6---5;6---7;10---9;10---11;  14---13;14---15;  1---A;1---B;3---C;3---D;  5---E;5---F;7---G;7---H;  9---I;9---J;11---K;11---L;  13---M;13---N;15---O;15---P;  classDef red-node fill:red, color:white;  classDef black-node fill:black, color:white;  class 4,12 red-node;  class 1,3,5,7,9,11,13,15,2,6,10,14,8,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P black-node;\r\n如下是一棵黑高为\\(4\\)的红黑树。\r\ngraph TD  1((1));2((2));3((3));4((4));  5((5));6((6));7((7));8((8));  9((9));10((10));11((11));12((12));  13((13));14((14));15((15))  A[NIL];B[NIL];C[NIL];D[NIL];  E[NIL];F[NIL];G[NIL];H[NIL];  I[NIL];J[NIL];K[NIL];L[NIL];  M[NIL];N[NIL];O[NIL];P[NIL];  8---4;8---12;4---2;4---6;  12---10;12---14;2---1;2---3;  6---5;6---7;10---9;10---11;  14---13;14---15;  1---A;1---B;3---C;3---D;  5---E;5---F;7---G;7---H;  9---I;9---J;11---K;11---L;  13---M;13---N;15---O;15---P;  classDef black-node fill:black, color:white;  class 4,12,1,3,5,7,9,11,13,15,2,6,10,14,8,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P black-node;\r\n13.1-2\r\n使用TREE-INSERT插入节点36后的整棵树如图所示。\r\ngraph TD  26((26));17((17));41((41));14((14));  21((21));30((30));47((47));10((10));  16((16));19((19));23((23));28((28));  38((38));7((7));12((12));15((15));  20((20));35((35));39((39));3((3));  36((36));  A[NIL];B[NIL];C[NIL];D[NIL];  E[NIL];F[NIL];G[NIL];H[NIL];  I[NIL];J[NIL];K[NIL];L[NIL];  M[NIL];N[NIL];O[NIL];P[NIL];  Q[NIL];R[NIL];S[NIL];T[NIL];  U[NIL];V[NIL];  26---17;26---41;17---14;17---21;  41---30;41---47;14---10;14---16;  21---19;21---23;30---28;30---38;  10---7;10---12;16---15;19---I;19---20;  38---35;38---39;7---3;  3---A;3---B;7---C;12---D;12---E;  15---F;15---G;16---H;20---J;  20---K;23---L;23---M;28---N;  28---O;35---P;35---36;36---Q;36---V;39---R;  39---S;47---T;47---U;  classDef red-node fill:red, color:white;  classDef black-node fill:black, color:white;  classDef grey-node fill:grey, color:white;  class 3,17,30,10,15,20,35,39 red-node;  class 26,41,14,21,47,16,19,23,28,38,7,12,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V black-node;  class 36 grey-node;\r\n节点36不可以染成红色，因为节点35是红色节点，不满足性质4。同时，节点36也不可以染成黑色，因为节点35的左子树黑高为\\(0\\)，右子树黑高为\\(1\\)，两棵子树黑高不相同，不满足性质5。\r\n因此，无论将节点36染成什么颜色，它都不是一棵红黑树。\r\n13.1-3\r\n仍然是一棵红黑树。以下是说明对应5个性质仍然保持的原因：\r\n\r\n因为它只是将根节点从红色染成黑色，而不是染成其它颜色。\r\n因为根节点按照这个操作染成黑色了。\r\n因为这个过程没有对NIL节点进行任何操作，它们仍然是黑色的。\r\n一开始这棵树的根节点是红色，那么它的两个子节点必定是黑色，现在根节点染成黑色后，就不需要对子节点的颜色做出限制了。\r\n因为变化前到变化后，从根节点到每个叶节点的黑色节点数都恰好多了\\(1\\)，因为包括上了叶节点。\r\n\r\n13.1-4\r\n当吸收操作完成后，一个黑色子节点的度数可能会变成\\(1,2,3,4,5\\)。对应如下情况：\r\n\r\n当前节点是一个NIL节点，它不会有任何变化。\r\n收缩前根节点具有\\(2\\)个黑色子节点，那么收缩后仍然有\\(2\\)个子节点。\r\n收缩前根节点具有\\(1\\)个红色子节点，\\(1\\)个黑色子节点，那么收缩后有\\(3\\)个子节点；非根节点具有\\(2\\)个黑色子节点，收缩后将会有\\(2\\)个子节点和\\(1\\)个父节点。\r\n收缩前根节点具有\\(2\\)个红色子节点，那么收缩后有\\(4\\)个子节点；非根节点具有\\(1\\)个红色子节点，\\(1\\)个黑色子节点，收缩后将会有\\(3\\)个子节点和\\(1\\)个父节点。\r\n非根节点具有\\(2\\)个红色子节点，收缩后将会有\\(4\\)个子节点和\\(1\\)个父节点。\r\n\r\n此外，收缩后，一棵树的高度至少为原来的一半，因为最好的情况下是一棵完全二叉树中，奇数层是红色节点，偶数层是黑色节点。如此吸收所有红色节点后，树高只剩下一半。\r\n13.1-5\r\n令\\(bh(x)\\)为以\\(x\\)为根节点的子树的黑高，\\(h(x)\\)为以\\(x\\)为根节点的子树的高。那么按照定义，必有\\(h(x)\\ge bh(x)\\)。根据性质\\(4\\)，从\\(x\\)到任意叶节点的路径如果包含了一个红色节点，那么这个节点下一个必定是黑色节点，这说明了来自根\\(x\\)的任意路径上，红色节点的数量一定不超过黑色节点，因此有\\(h(x)\\le\r\n2bh(x)\\)。因此从根到叶子节点的路径中，最长的路径长度至多为最短的\\(2\\)倍。\r\n13.1-6\r\n当这棵树的节点每一层是红黑交间时，内部节点数最大。这时这棵树是一棵\\(2k\\)层的完全二叉树，其中偶数层是黑色节点，奇数层是红色节点，一共有\\(2^{2k}-1\\)个节点。\r\n当这棵树都是黑色节点时，内部节点数最小。这时这棵树是一棵\\(k\\)层的完全二叉树，一共有\\(2^{k}-1\\)个节点。\r\n13.1-7\r\n当一棵树所有节点都是黑色时，这个比值最小，为\\(0\\)。\r\n如果存在正整数\\(k\\)，使得\\(n=2^{2k}-1\\)成立，那么这棵高度为\\(2k\\)的二叉完全树为所求，其中偶数层是黑色节点，奇数层是红色节点。此时将达到最大比值\\(2\\)。因为每个黑色节点都有\\(2\\)个红色子节点。\r\n13.1-8\r\n考虑使用反证法证明。不失一般性，假设某个红色子节点的左子节点为NIL，那么左子树黑高为\\(0\\)。如果右子树不为空，那么根据性质4，右子树的根节点是一个黑色节点，向下遍历，最终这棵子树也会有空子节点NIL，因此右子树黑高一定大于\\(0\\)。由于左子树和右子树黑高不一致，因此不满足性质5，这棵树必定不是一棵红黑树，最终原结论成立。\r\n","categories":["算法导论"]},{"title":"算法导论13.4 Exercises 答案","url":"/introduction-to-algorithms/chapter-13/exercises-4/","content":"\r\n13.4-1\r\n首先考虑RB-DELETE的第1-8行代码，这个时候\\(y=z\\)。令\\(p=y.p\\)，由于删除的节点是\\(y\\)是一个红色节点，拼接上去的是其唯一一个儿子\\(son\\)（要么是\\(left\\)，要么是\\(right\\)）的子树，因此\\(p\\)的右子树和\\(son\\)相同，黑高保持不变，那么就与左子树的黑高相同。因此，原结论成立。\r\n13.4-2\r\n由于情况1可以转换成情况2,3,4，并且情况3还可以转换成情况4，因此此处证明仅讨论情况2和情况4来解决（同样的，这里只考虑\\(x\\)是它父亲的左儿子的情况）：\r\n\r\n情况2不会改变父节点的位置，也不会改变父节点的颜色，因此只要向上迭代，父节点的颜色永远不会发生改变。因此，由于\\(T\\)在之前根节点就是黑色的，因此在之后仍然是黑色的，原结论成立。\r\n情况4有两种情况需要考虑：如果\\(x\\)的父节点是根节点，那么经过左旋后，根节点成为\\(x\\)原来的兄弟节点\\(w\\)，由于\\(w\\)是黑色节点，因此根节点也将会染成黑色节点，原结论成立；如果\\(x\\)的父节点不是根节点，那么根节点不会进行任何改变，保持原来的颜色，故原结论成立。\r\n\r\n13.4-3\r\n这种情况只会发生在\\(z\\)具有两个儿子的情况。删除\\(y\\)前，\\(y\\)的父节点\\(p=x.p\\)为红色，且\\(x\\)也为红色；删除\\(y\\)后，\\(y\\)原本的父节点\\(p\\)成为了\\(x\\)的父节点，这时RB-DELETE-FIXUP被调用。\r\n根据算法RB-DELETE-FIXUP的第一行，由于\\(x\\)是红色，因此WHILE循环不被执行，被跳过。在第44行，\\(x\\)被修改成黑色。由于\\(p\\)原本是红色节点，因此\\(x\\)的兄弟节点必定是黑色。这时\\(p\\)的两个子节点都为黑色，性质4保持成立。\r\n13.4-4\r\n一开始整棵的形状如下：\r\ngraph TD  41((41));38((38));19((19));12((12));  31((31));8((8));  A(( ));  classDef red-node fill:red, color:white;  classDef black-node fill:black, color:white;  class 12,31,38,41 black-node;  class 8,19 red-node;  38---19;38---41;19---12;19---31;  12---8;  12---A;  style A fill:#f100,stroke-width:0px  linkStyle 5 stroke:#0ff,stroke-width:0px\r\n如下是按顺序删除每个节点后得到的红黑树：\r\n\r\n\\(8\\)\r\n\r\ngraph TD  41((41));38((38));19((19));12((12));  31((31));  classDef red-node fill:red, color:white;  classDef black-node fill:black, color:white;  class 12,31,38,41 black-node;  class 19 red-node;  38---19;38---41;19---12;19---31;\r\n\r\n\\(12\\)\r\n\r\ngraph TD  41((41));38((38));19((19));31((31));  A(( ));  classDef red-node fill:red, color:white;  classDef black-node fill:black, color:white;  class 31,38,41 black-node;  class 19 red-node;  38---19;38---41;19---A;19---31;  style A fill:#f100,stroke-width:0px  linkStyle 2 stroke:#0ff,stroke-width:0px\r\n\r\n\\(19\\)\r\n\r\ngraph TD  41((41));38((38));31((31));  classDef red-node fill:red, color:white;  classDef black-node fill:black, color:white;  class 31,38,41 black-node;  38---31;38---41;\r\n\r\n\\(38\\)\r\n\r\ngraph TD  41((41));38((38));  A(( ));  classDef red-node fill:red, color:white;  classDef black-node fill:black, color:white;  class 31,38 black-node;  class 41 red-node;  38---A;38---41;  style A fill:#f100,stroke-width:0px  linkStyle 0 stroke:#0ff,stroke-width:0px\r\n\r\n\\(38\\)\r\n\r\ngraph TD  41((41));  classDef red-node fill:red, color:white;  classDef black-node fill:black, color:white;  class 41 black-node;\r\n\r\n\\(41\\)\r\n\r\ngraph TD  A[NIL]  classDef red-node fill:red, color:white;  classDef black-node fill:black, color:white;  class A black-node;\r\n13.4-5\r\n前文提到，由于RB-DELETE-FIXUP传入的参数\\(x\\)可能是\\(T.nil\\)，因此节点\\(x\\)被访问或修改的代码都符合要求。例如第1行就检查了哨兵的颜色，第2行就检查了当前哨兵节点\\(x\\)是否为\\(x.p\\)的左子节点。\r\n当最后一个节点从\\(T\\)被删除时，\\(T\\)为空，WHILE循环会被跳过，第44行代码会对哨兵赋予了一次黑色。\r\n13.4-6\r\n以下图示中，\\(v/k\\)表示从根节点到子树\\(\\omega\\)之间有\\(k\\)个黑色节点（包括多重的黑色节点）。它们分别代表a,b,c,d这\\(4\\)种情况。\r\na\r\ngraph TD    A((A));B((B));C((C));D((D));E((E));    a[a/3];b[β/3];c[γ/2];d[δ/2];e[ε/2];f[ζ/2]    Z(( ));Z2(( ));    classDef hide-appearance fill:transparent, stroke:transparent;    classDef hide-node display:none;    classDef red-node fill:red, color:white;    classDef black-node fill:black, color:white;    class A,B,C,E black-node;    class D red-node;    class a,b,c,d,e,f hide-appearance;    class Z,Z2 hide-node;    Z---B;B---A;B---D;    D---C;D---E;a---Z2;    A---a;A---b;C---c;C---d;    E---e;E---f;    linkStyle 5 stroke:#0ff,stroke-width:0px\r\ngraph TD    A&#x27;((A));B&#x27;((B));C&#x27;((C));D&#x27;((D));E&#x27;((E));    a&#x27;[α/3];b&#x27;[β/3];c&#x27;[γ/2];d&#x27;[δ/2];e&#x27;[ε/2];f&#x27;[ζ/2]    Z&#x27;(( ));    classDef hide-appearance fill:transparent, stroke:transparent;    classDef hide-node display:none;    classDef red-node fill:red, color:white;    classDef black-node fill:black, color:white;    class A&#x27;,D&#x27;,C&#x27;,E&#x27; black-node;    class B&#x27; red-node;    class a&#x27;,b&#x27;,c&#x27;,d&#x27;,e&#x27;,f&#x27; hide-appearance;    class Z&#x27; hide-node;    Z&#x27;---D&#x27;;D&#x27;---B&#x27;;D&#x27;---E&#x27;;B&#x27;---A&#x27;;B&#x27;---C&#x27;;    A&#x27;---a&#x27;;A&#x27;---b&#x27;;C&#x27;---c&#x27;;C&#x27;---d&#x27;;    E&#x27;---e&#x27;;E&#x27;---f&#x27;\r\nb\r\ngraph TD    A((A));B((B));C((C));D((D));E((E));    a[&quot;α/2+count(c)&quot;];b[&quot;β/2+count(c)&quot;];c[&quot;γ/2+count(c)&quot;];d[&quot;δ/2+count(c)&quot;];e[&quot;ε/2+count(c)&quot;];f[&quot;ζ/2+count(c)&quot;]    Z(( ));Z2(( ));    classDef hide-appearance fill:transparent, stroke:transparent, stroke-width:21px;    classDef hide-node display:none;    classDef red-node fill:red, color:white;    classDef black-node fill:black, color:white;    classDef brown-node fill:#bc987e, color:white;    class A,D,C,E black-node;    %% class D red-node;    class B brown-node;    class a,b,c,d,e,f hide-appearance;    class Z,Z2 hide-node;    Z---B;B---A;B---D;    D---C;D---E;a---Z2;    A---a;A---b;C---c;C---d;    E---e;E---f;    linkStyle 5 stroke:#0ff,stroke-width:0px\r\ngraph TD    A&#x27;((A));B&#x27;((B));C&#x27;((C));D&#x27;((D));E&#x27;((E));    a&#x27;[&quot;α/1+count(c)&quot;];b&#x27;[&quot;β/1+count(c)&quot;];c&#x27;[&quot;γ/1+count(c)&quot;];d&#x27;[&quot;δ/1+count(c)&quot;];e&#x27;[&quot;ε/1+count(c)&quot;];f&#x27;[&quot;ζ/1+count(c)&quot;]    Z&#x27;(( ));Z2&#x27;(( ));    classDef hide-appearance fill:transparent, stroke:transparent, stroke-width:21px;    classDef hide-node display:none;    classDef red-node fill:red, color:white;    classDef black-node fill:black, color:white;    classDef brown-node fill:#bc987e, color:white;    class A&#x27;,C&#x27;,E&#x27; black-node;    class D&#x27; red-node;    class B&#x27; brown-node;    class a&#x27;,b&#x27;,c&#x27;,d&#x27;,e&#x27;,f&#x27; hide-appearance;    class Z&#x27;,Z2&#x27; hide-node;    Z&#x27;---B&#x27;;B&#x27;---A&#x27;;B&#x27;---D&#x27;;    D&#x27;---C&#x27;;D&#x27;---E&#x27;;a&#x27;---Z2&#x27;;    A&#x27;---a&#x27;;A&#x27;---b&#x27;;C&#x27;---c&#x27;;C&#x27;---d&#x27;;    E&#x27;---e&#x27;;E&#x27;---f&#x27;;    linkStyle 5 stroke:#0ff,stroke-width:0px\r\nc\r\ngraph TD    A((A));B((B));C((C));D((D));E((E));    a[&quot;α/2+count(c)&quot;];b[&quot;β/2+count(c)&quot;];c[&quot;γ/1+count(c)&quot;];d[&quot;δ/1+count(c)&quot;];e[&quot;ε/2+count(c)&quot;];f[&quot;ζ/2+count(c)&quot;]    Z(( ));Z2(( ));    classDef hide-appearance fill:transparent, stroke:transparent, stroke-width:21px;    classDef hide-node display:none;    classDef red-node fill:red, color:white;    classDef black-node fill:black, color:white;    classDef brown-node fill:#bc987e, color:white;    class A,D,E black-node;    class C,D red-node;    class B brown-node;    class a,b,c,d,e,f hide-appearance;    class Z,Z2 hide-node;    Z---B;B---A;B---D;    D---C;D---E;a---Z2;    A---a;A---b;C---c;C---d;    E---e;E---f;    linkStyle 5 stroke:#0ff,stroke-width:0px\r\ngraph TD    A&#x27;((A));B&#x27;((B));C&#x27;((C));D&#x27;((D));E&#x27;((E));    a&#x27;[&quot;α/2+count(c)&quot;];b&#x27;[&quot;β/2+count(c)&quot;];c&#x27;[&quot;γ/1+count(c)&quot;];d&#x27;[&quot;δ/1+count(c)&quot;];e&#x27;[&quot;ε/2+count(c)&quot;];f&#x27;[&quot;ζ/2+count(c)&quot;]    Z&#x27;(( ));Z2&#x27;(( ));    classDef hide-appearance fill:transparent, stroke:transparent, stroke-width:21px;    classDef hide-node display:none;    classDef red-node fill:red, color:white;    classDef black-node fill:black, color:white;    classDef brown-node fill:#bc987e, color:white;    class A&#x27;,C&#x27;,E&#x27; black-node;    class D&#x27; red-node;    class B&#x27; brown-node;    class a&#x27;,b&#x27;,c&#x27;,d&#x27;,e&#x27;,f&#x27; hide-appearance;    class Z&#x27;,Z2&#x27; hide-node;    Z&#x27;---B&#x27;;B&#x27;---A&#x27;;B&#x27;---C&#x27;;    A&#x27;---a&#x27;;A&#x27;---b&#x27;;C&#x27;---c&#x27;;C&#x27;---D&#x27;;    D&#x27;---d&#x27;;D&#x27;---E&#x27;;E&#x27;---e&#x27;;E&#x27;---f&#x27;;    %% linkStyle 17 stroke:#0ff,stroke-width:0px\r\nd\r\ngraph TD    A((A));B((B));C((C));D((D));E((E));a[&quot;α/2+count(c)&quot;];b[&quot;β/2+count(c)&quot;];c[&quot;γ/1+count(c)+count(c&#x27;)&quot;];d[&quot;δ/1+count(c)+count(c&#x27;)&quot;];e[&quot;ε/2+count(c)&quot;];f[&quot;ζ/2+count(c)&quot;]    Z(( ));Z2(( ));    classDef hide-appearance fill:transparent, stroke:transparent;    classDef hide-node display:none;    classDef red-node fill:red, color:white;    classDef black-node fill:black, color:white;    classDef brown-node fill:#bc987e, color:white;    class A,D black-node;    class E red-node;    class B,C brown-node;    class a,b,c,d,e,f hide-appearance;    class Z,Z2 hide-node;    Z---B;B---A;B---D;    D---C;D---E;a---Z2;    A---a;A---b;C---c;C---d;    E---e;E---f;    linkStyle 5 stroke:#0ff,stroke-width:0px\r\ngraph TD    A&#x27;((A));B&#x27;((B));C&#x27;((C));D&#x27;((D));E&#x27;((E));a&#x27;[&quot;α/2+count(c)&quot;];b&#x27;[&quot;β/2+count(c)&quot;];c&#x27;[&quot;γ/1+count(c)+count(c&#x27;)&quot;];d&#x27;[&quot;δ/1+count(c)+count(c&#x27;)&quot;];e&#x27;[&quot;ε/2+count(c)&quot;];f&#x27;[&quot;ζ/2+count(c)&quot;]    Z&#x27;(( ));    classDef hide-appearance fill:transparent, stroke:transparent;    classDef hide-node display:none;    classDef red-node fill:red, color:white;    classDef black-node fill:black, color:white;    classDef brown-node fill:#bc987e, color:white;    class A&#x27;,B&#x27;,E&#x27; black-node;    %% class B&#x27; red-node;    class a&#x27;,b&#x27;,c&#x27;,d&#x27;,e&#x27;,f&#x27; hide-appearance;    class Z&#x27; hide-node;    class C&#x27;,D&#x27; brown-node;    Z&#x27;---D&#x27;;D&#x27;---B&#x27;;D&#x27;---E&#x27;;B&#x27;---A&#x27;;B&#x27;---C&#x27;;    A&#x27;---a&#x27;;A&#x27;---b&#x27;;C&#x27;---c&#x27;;C&#x27;---d&#x27;;    E&#x27;---e&#x27;;E&#x27;---f&#x27;\r\n13.4-7\r\n考虑使用反证法来证明。可见，\\(w\\)节点是\\(x\\)的兄弟叶节点，也就是说，\\(w.p=x.p\\)。如果进入了情况1，那么意味着节点\\(w\\)是红色。如果\\(x.p\\)也是红色，那么这将违反红黑树的性质4。这说明，节点\\(w\\)和\\(w.p\\)的颜色在调用RB-DELETE-FIXUP之前都是红色，这说明\\(T\\)此前就不是一棵红黑树，这是不可能的。因此不需要担心\\(x.p\\)是红色，因为\\(T\\)此前是一棵红黑树。\r\n13.4-8\r\n不是。考虑如下\\(4\\)步操作。一开始\\(T\\)是一棵空树。\r\n\r\n插入\\(1\\)\r\n\r\ngraph TD  1((1))  classDef red-node fill:red, color:white;  classDef black-node fill:black, color:white;  class 1 black-node;\r\n\r\n插入\\(2\\)\r\n\r\ngraph TD  1((1));2((2));  A(( ));  classDef red-node fill:red, color:white;  classDef black-node fill:black, color:white;  class 1 black-node;  class 2 red-node;  1---A;1---2;  style A fill:#f100,stroke-width:0px  linkStyle 0 stroke:#0ff,stroke-width:0px\r\n\r\n插入\\(3\\)\r\n\r\ngraph TD  1((1));2((2));3((3));  classDef red-node fill:red, color:white;  classDef black-node fill:black, color:white;  class 1,3 black-node;  class 2 red-node;  2---1;2---3;\r\n\r\n删除\\(3\\)\r\n\r\ngraph TD  1((1));2((2));  A(( ));  classDef red-node fill:red, color:white;  classDef black-node fill:black, color:white;  class 2 black-node;  class 1 red-node;  2---1;2---A;  style A fill:#f100,stroke-width:0px  linkStyle 1 stroke:#0ff,stroke-width:0px\r\n由此可见，添加一个节点后再立刻删除它，并不能使红黑树恢复成原样。\r\n\\(\\star\\)\r\n13.4-9\r\n代入题目12.2-8的结论，\\(h=\\Theta(\\lg\r\nn)\\)，那么可以知道依次遍历\\(x\\)的第\\(1,2,\\dots,m\\)个后继，可以以\\(\\Theta(m+\\lg n)\\)的时间求解出来。\r\n一个简单的做法是找到第一个大于等于\\(a\\)的节点，不断地求后继并输出，直到这个后继为T.nil或者是超出了所求范围。我们将设计RB-LOWER-BOUND算法用于求解最小的大于等于某个值的节点，以及BR-SUCCESSOR算法求解某个节点的后继的后继，其中使用到的子程序RB-MINIUM用于求解子树\\(r\\)中的最小节点。\r\n由于现在是求取子树\\(r\\)中，满足\\(a\\le k\\le b\\)的所有节点，但是\\([a,b]\\)所覆盖的范围有可能覆盖了子树\\(T\\)以外的节点。因此在这一步中，我们需要将右边界\\(b\\)缩小，以保证最大值恰好在子树\\(r\\)内，在红黑树上求解子树\\(r\\)的最大节点由RB-MAXIMUM给出，它和TREE-MAXIMUM非常类似：\r\n这些程序的代码如下所示：\r\nRB-MINIMUM(T, x)  while x.left ≠ T.nil    x = x.left  return xRB-MAXIMUM(T, x)  while x.right ≠ T.nil    x = x.right  return xBR-SUCCESSOR(T, x)  if x.right ≠ T.nil    return BR-MINIMUM(T, x.right)  else    y = x.p    while y ≠ T.nil and x == y.right      x = y      y = y.p    return y// 求解以x为子树中，第一个大于等于a的节点。BR-LOWER-BOUND(T, x, a)  result = T.nil  while x != T.nil    if x.key &gt;= a      result = x      x = x.left    else      x = x.right  return result\r\n那么接下来则是对RB-ENUMERATE的实现，这种实现考虑了\\(a,b\\)不在树\\(T\\)中的情形。\r\nRB-ENUMERATE(T, r, a, b)  t = RB-MAXIMUM(T, r)  b = min&#123;b, r.key&#125;  x = BR-LOWER-BOUND(T, x, a)  while x != T.nil and x.key &lt;= b    print x.key    x = BR-SUCCESSOR(T, x)\r\n由于对RB-MAXIMUM和BR-LOWER-BOUND的调用仅有\\(1\\)次，再加上迭代求解\\(x\\)的后继（假设有\\(m\\)个），因此整个算法的时间复杂度为\\(\\Theta(m+\\lg n)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论13 Problems 答案","url":"/introduction-to-algorithms/chapter-13/problems/","content":"\r\n13-1\r\na\r\n如果插入一个节点\\(z\\)，插入完成后，\\(z\\)中的所有祖先都需要进行一遍记录。\r\n如果删除一个节点\\(z\\)，那么如果\\(z\\)只有一个孩子，那么只需要将\\(z\\)的所有祖先都进行一次记录；否则，求解\\(z\\)的后继\\(y\\)，此时是删除节点\\(y\\)，那么将\\(y\\)的所有祖先节点都记录。\r\nb\r\nPERSISTENT-TREE-INSERT(T, z)  Let T&#x27; be a new tree  if T.root == NIL    T&#x27;.root = z    return T&#x27;  y = NIL  x = COPY-NODE(T.root)  T&#x27;.root = x  while x != NIL    y = x    if z.key &lt; x.key      x = x.left      if x != NIL        x = COPY-NODE(x)        y.left = x    else      x = x.right      if x != NIL        x = COPY-NODE(x)        y.right = x  if z.key &lt; y.key    y.left = z  else    y.right = z  return T&#x27;\r\nc\r\n算法PERSISTENT-TREE-INSERT只是将遍历过的所有节点都克隆一遍，整个过程和TREE-INSERT都是一致的，因此其时间复杂度和TREE-INSERT一致，为\\(O(h)\\)；由于遍历了\\(O(h)\\)个节点，新生成了\\(O(h)\\)了节点，因此其空间复杂度为\\(O(h)\\)。\r\nd\r\n如果需要维护父亲指针，那么自顶向下考虑这个维护过程。首先，需要克隆新版本的根节点，因此新版本的二叉搜索树中，两个子节点的父亲指针需要指向新的父亲指针，这说明这些子节点也需要克隆出一份新的，这些子节点的子节点的父亲指针也需要更新……最终，整棵树的所有结点都被克隆了一遍，因此维护父亲指针的持久二叉搜索树算法的时间复杂度是\\(\\Omega(n)\\)。\r\ne\r\n由题目13.3-6可以知道，其所有操作仅仅是对插入节点\\(z\\)的祖先进行了操作，非\\(z\\)祖先的节点不会受到影响，因此只需要将\\(y\\)的全部祖先及其涉及到相关的节点都克隆一次，再按照题目13.3-6的算法将它们改成持久算法即可。此外，删除操作也类似。因此整个时间复杂度为\\(O(\\lg n)\\)。\r\n如下给出算法PERSISTENT-RB-INSERT和PERSISTENT-RB-INSER-FIXUP，它们是RB-INSERT'和RB-INSERT-FIXUP的持久化版本。\r\nPERSISTENT-RB-INSERT(T, z)  // P是从T.root到z的一条路径。并且这里对T&#x27;.nil和T.nil不做区分。  Let T&#x27; be a new tree  if T.root == T.nil    T&#x27;.root = z    return T&#x27;  y = T.nil  x = COPY-NODE(T.root)  T&#x27;.root = x  let P be new array  INSERT(P, T&#x27;.nil)  INSERT(P, T&#x27;.root)  while x != T.nil    y = x    if z.key &lt; x.key      x = x.left      if x != NIL        x = COPY-NODE(x)        y.left = x        INSERT(P, x)    else      x = x.right      if x != NIL        x = COPY-NODE(x)        y.right = x        INSERT(P, x)  if z.key &lt; y.key    y.left = z  else    y.right = z  z.left = T&#x27;.nil  z.right = T&#x27;.nil  z.color = RED  INSERT(P, z)  PERSISTENT-RB-INSERT-FIXUP(T&#x27;, P)  return T&#x27;// P是从T.root到z中路径的所有节点PERSISTENT-RB-INSERT-FIXUP(T, P)  i = P.size - 1  while i &gt; 0 and P[i - 1].color == RED    if P[i - 1] == P[i - 2].left      y = P[i - 2].right      if y.color == RED        P[i - 1].color = BLACK        // 兄弟节点y不在路径上，它是原来的节点，需要被克隆。        y = COPY-NODE(y)        y.color = BLACK        P[i - 2].color = RED        P[i - 2].right = y        i = i - 2      else        if P[i] == P[i - 1].right          LEFT-ROTATE&#x27;(T, P[i - 2], P[i - 1])          exchange P[i] with P[i - 1]        P[i - 1].color = BLACK        P[i - 2].color = RED        RIGHT-ROTATE&#x27;(T, P[i - 3], P[i - 2])        // 此时路径序列已经改变，不过也没有所谓，因为之后由于P[i - 1].color == BLACK使得这个循环被跳出。    else      y = P[i - 2].left      if y.color == RED        P[i - 1].color = BLACK        y = COPY-NODE(y)        y.color = BLACK        P[i - 2].color = RED        P[i - 2].right = y        i = i - 2      else        if P[i] == P[i - 1].left          RIGHT-ROTATE&#x27;(T, P[i - 2], P[i - 1])          exchange P[i] with P[i - 1]        P[i - 1].color = BLACK        P[i - 2].color = RED        LEFT-ROTATE&#x27;(T, P[i - 3], P[i - 2])\r\n按照类似的思路，可以写出如下持久红黑树删除的算法PERSISTENT-RB-DELETE和PERSISTENT-RB-DELETE-FIXUP，它们是RB-DELETE'和RB-DELETE-FIXUP的持久化版本。其中，RB-TRANSPLANT'同样是将节点赋值到另一个位置，但是忽略了对属性\\(p\\)的维护，因此，RB-TRANSPLANT'要比RB-TRANSPLANT多一个参数；ITERATIVE-SEARCH-PARENT是求解某个节点在红黑树中的父亲节点，它由算法ITERATIVE-TREE-SEARCH改造而来，最终整个算法的时间复杂度为\\(O(\\lg n)\\)。\r\nITERATIVE-SEARCH-PARENT(T, k)  x = T.root  y = T.nil  while x != T.nil and k != x.key    y = x    if k &lt; x.key      x = x.left    else      x = x.right  return y// p是u的父亲节点RB-TRANSPLANT&#x27;(T, p, u, v)  if T.root == u    T.root = v  else if p.left == u    p.left = v  else    p.right = vPERSISTENT-RB-DELETE(T, z)  Let T&#x27; be new tree  Let P be new array  x = T.root  x = COPY-NODE(x)  INSERT(P, T&#x27;.nil)  INSERT(P, x)  p = T.nil  while x.key != z.key    p = x    if z.key &lt; x.key      x = x.left      x = COPY-NODE(x)      p.left = x    else      x = x.right      x = COPY-NODE(x)      p.right = y    INSERT(P, x)  // 目前P中存储了从T.root到z的路径，这其中的所有节点都被克隆。当前x是z的克隆版本。  z = x  y = z  y-original-color = y.color  parent-z = ITERATIVE-SEARCH-PARENT(T&#x27;, z)  if z.left == T&#x27;.nil    x = z.right    RB-TRANSPLANT&#x27;(T&#x27;, parent-z, z, z.right)    INSERT(P, x)  else if z.right == T.nil    x = z.left    RB-TRANSPLANT&#x27;(T&#x27;, parent-z, z, z.left)    INSERT(P, x)  else     // y = TREE-MINIMUM(z.right)    // 继续往下补充，补充从z到x的路径，同样的是，x只需要是旧版即可。    y = z    p = z.right    while p != T.nil      p = COPY-NODE(p)      INSERT(P, p)      y = p      p = p.left    y-original-color = y.color    x = y.right    INSERT(P, x)    if y ≠ z.right      parent-y = ITERATIVE-SEARCH-PARENT(T, y)      RB-TRANSPLANT(T&#x27;, parent-y, y, y.right)      y.right = z.right    RB-TRANSPLANT(T&#x27;, parent-z, z, y)    y.left = z.left    y.color = z.color  if y-original-color == BLACK    PERSISTENT-RB-DELETE-FIXUP(T&#x27;, P)  return T&#x27;// P是从T.root到x中路径的所有节点PERSISTENT-RB-DELETE-FIXUP(T, P)  i = P.size - 1  while i &gt; 1 and P[i].color == BLACK    if P[i] == P[i - 1].left      w = P[i - 1].right      // Case 1      if w.color == RED        w = COPY-NODE(w)        P[i - 1].right = w        w.color = BLACK        P[i - 1].color = RED        LEFT-ROTATE&#x27;(T, P[i - 2], P[i - 1])        P[i - 1] = w        if i == P.size - 1          INSERT(P, P[i])        else          P[i + 1] = P[i]        P[i] = P[i - 1]        P[i - 1] = w        i = i + 1        w = P[i - 1].right      // Case 2      if w.left.color == BLACK and w.right.color == BLACK        w = COPY-NODE(w)        P[i - 1].right = w        w.color = RED        i = i - 1      else      // Case 3        if w.right.color == BLACK          w = COPY-NODE(w)          P[i - 1].right = w          v = w.left          v = COPY-NODE(v)          w.left = v          v.color = BLACK          w.color = RED          RIGHT-ROTATE&#x27;(T, P[i - 1], w)          w = P[i - 1].right      // Case 4        w = COPY-NODE(w)        P[i - 1].right = w        v = w.right        v = COPY-NODE(v)        w.right = v        w.color = P[i - 1].color        P[i - 1].color = BLACK        v.color = BLACK        LEFT-ROTATE&#x27;(T, P[i - 2], P[i - 1])        i = 0    else      w = P[i - 1].left      // Case 1      if w.color == RED        w = COPY-NODE(w)        P[i - 1].right = w        w.color = BLACK        P[i - 1].color = RED        RIGHT-ROTATE&#x27;(T, P[i - 2], P[i - 1])        P[i - 1] = w        if i == P.size - 1          INSERT(P, P[i])        else          P[i + 1] = P[i]        P[i] = P[i - 1]        P[i - 1] = w        i = i + 1        w = P[i - 1].right      // Case 2      if w.left.color == BLACK and w.right.color == BLACK        w = COPY-NODE(w)        P[i - 1].right = w        w.color = RED        i = i - 1      else      // Case 3        if w.left.color == BLACK          w = COPY-NODE(w)          P[i - 1].right = w          v = w.right          v = COPY-NODE(v)          w.left = v          v.color = BLACK          w.color = RED          LEFT-ROTATE&#x27;(T, P[i - 1], w)          w = P[i - 1].left      // Case 4        w = COPY-NODE(w)        P[i - 1].left = w        v = w.left        v = COPY-NODE(v)        w.left = v        w.color = P[i - 1].color        P[i - 1].color = BLACK        v.color = BLACK        RIGHT-ROTATE&#x27;(T, P[i - 2], P[i - 1])        i = 0\r\n13-2\r\na\r\n由于红黑树进行一次RB-INSERT或者是RB-DELETE的时间复杂度为\\(O(\\lg\r\nn)\\)。完成一次这类操作后，我们可以随机选择一个叶子节点（红黑树的性质5保证了结果必定是相同的），从根到它进行访问，并计算经过的黑色节点数，得到\\(T.bh\\)的值。这个过程的时间复杂度同样是\\(O(\\lg\r\nn)\\)，它将不会增加这个时间，因此仅凭RB-INSERT和RB-DELETE内部即可维护好\\(T.bh\\)这个值。当计算出\\(T.bh\\)值后，考虑对\\(T\\)进行深度优先搜索，当遇到一个黑色节点时，搜索变量\\(d\\)需要减去\\(1\\)，否则不进行任何操作，那么\\(d\\)就代表了当前节点的黑高。深度优先搜索开始前，会将\\(d\\)值初始化成\\(dT.bh+1\\)。由此，每个节点可以以\\(O(1)\\)的时间求出黑高\r\nb\r\n只要黑高相同，那么在树中的位置越靠右，其值越大。因此，令\\(r\\)为\\(T\\)中的最大节点（即最右叶节点），从\\(T.root\\)到\\(r\\)这条路径中，黑高为\\(T_2.bh\\)的黑色节点即为所求。算法由CAL-MAX-NODE-EQ-BLACK-HEIGHT给出。由于只是遍历了红黑树中一条从根到叶子节点的路径，因此其时间复杂度为\\(O(\\lg n)\\)。\r\nCAL-MAX-NODE-EQ-BLACK-HEIGHT(T1, T2)  k = T1.bh - T2.bh  y = T1.root  while y != T1.nil    if y.color == BLACK      if k == 0        break      else        k = k - 1    y = y.right  return y\r\nc\r\n令\\(T\\)为所求的树，那么令\\(T.root=x,x.left=T_y.root,x.right=T_2.root,T_y.root.p=T_2.root=p\\)即可。由于\\(T_y\\)中的所有值都比\\(x\\)小，并且\\(T_2\\)中的所有值都比\\(x\\)大，因此\\(T\\)仍然是一棵二叉搜索树。\r\nd\r\n将\\(x\\)染成红色即可。按照题目13-2-b的算法，在\\(T_1\\)中找到一个黑高为\\(T_2.bh\\)的最大节点\\(y\\)，并且按照题目\\(c\\)的方式，构造出了一棵黑高为\\(T_2.bh\\)的松弛红黑树\\(T=T_y\\cup \\{x\\}\\cup T_2\\)（注意\\(T\\)的根节点\\(x\\)是红色的），接下来调用RB-TRANSPLANT(T1, y, x)将树\\(T\\)的根\\(x\\)覆盖在树\\(T_1\\)在\\(y\\)这个位置上。那么在拼接前\\(y\\)的父节点\\(y.p\\)看来，左右两边的子树的黑高都是\\(T_2.bh\\)，因此性质5仍然成立；由于叶子节点\\(T.nil\\)并未有任何的修改，因此性质3仍然成立；性质1也仍然成立。\r\n如果\\(y\\)是\\(T_1\\)的根节点，那么上述操作会违反性质2，因为红节点\\(x\\)成为了\\(T_1\\)的新节点。如果原本的\\(y\\)的父节点\\(y.p\\)是红色，那么拼接之后\\(x\\)和\\(x.p\\)都是红色，它们违反了性质4。因此，可以通过调用子程序RB-INSERT-FIXUP(T1, x)来解决，这只花费\\(O(\\lg n)\\)的时间解决。\r\ne\r\n如果\\(T_2.bh\\ge\r\nT_1.bh\\)，按照题目13-2-b的思想，可以在\\(T_2\\)找到一个最小的黑高为\\(T_1.bh\\)的节点\\(z\\)；令\\(T_z\\)是\\(T_2\\)中以\\(z\\)为根的子树，按照题目13-2-c的思想，可以拼接出树\\(T=T_1\\cup\\{x\\}\\cup\r\nT_z\\)；按照题目13-3-d的思想，将\\(T\\)的根\\(x\\)覆盖在树\\(T_2\\)在\\(z\\)这个位置上即可，之后同样需要调用子程序RB-INSERT-FIXUP(T2, x)来解决性质2和性质4被违背的问题。\r\nf\r\n如下是RB-JOIN的伪代码：\r\nCAL-MIN-NODE-EQ-BLACK-HEIGHT(T1, T2)  k = T2.bh - T1.bh  z = T2.root  while z != T2.nil    if z.color == BLACK      if k == 0        break      else        k = k - 1    z = z.left  return zRB-JOIN(T1, x, T2)  if T1.bh &gt;= T2.bh    y = CAL-MAX-NODE-EQ-BLACK-HEIGHT(T1, T2)    x.left = y    x.right = T2.root    y.p = x    T2.root.p = x    RB-TRANSPLANT(T1, y, x)    RB-INSERT-FIXUP(T1, x)  else    z = CAL-MAX-NODE-EQ-BLACK-HEIGHT(T1, T2)    x.left = T1.root    x.right = z    T1.root.p = x    z.p = x    RB-TRANSPLANT(T2, z, x)    RB-INSERT-FIXUP(T2, x)\r\n注意，RB-JOIN算法的前8行和后8行是完全对称的，此处仅分析第1-8行代码的时间复杂度。第2行求解\\(T_1\\)中黑高为\\(T_2.bh\\)消耗的时间为\\(O(\\lg\r\nn)\\)，第8行修正性质2和4的操作所消耗的时间同样为\\(O(\\lg n)\\)，其它操作的时间复杂度均为\\(O(1)\\)，因此算法RB-JOIN的时间复杂度为\\(O(\\lg n)\\)。\r\n13-3\r\na\r\n令\\(T(h)\\)表示高度为\\(h\\)的AVL树中最少的节点数。由于这是一棵AVL树，并且我们希望节点数尽量少，因此其较高的子树的高度为\\(h-1\\)，较矮的子树的高度为\\(h-2\\)，并且这些子树的节点数也应该尽量少（分别达到\\(T(h-1),T(h-2)\\)）。因此，可以写出\\(T\\)的递推式为\r\n\\[T(h)=T(h-1)+T(h-2)+1\\]\r\n其中，\\(T(0)=0,T(1)=1\\)，并且\\(+1\\)是算上了当前AVL树的根节点。\r\n按照题目31-3-a的分析，可以知道\\(T(h)=\\Theta(\\phi^h)\\)。又因为\\(T(h)\\le n\\)，因此可以得知\\(h=O(\\log_{\\phi} n)\\)，即\\(h=O(\\lg n)\\)。\r\nb\r\n判断两棵子树的高度，然后对根节点\\(x\\)进行旋转即可，其单次操作的时间复杂度为\\(O(1)\\)。为了方便，假设NIL节点为T.nil，其高度为\\(-1\\)。\r\n// 平衡后，返回新的根。BALANCE(x)  if x.right.h == x.left.h + 2    y = x.right    LEFT-ROTATE(x)    x.h = max&#123;x.left.h, x.right.h&#125; + 1    y = max&#123;x.h, y.right.h&#125; + 1    return y  else if x.left.h == x.right + 2    y = x.left    RIGHT-ROTATE(x)    x.h = max&#123;x.left.h, x.right.h&#125; + 1    y.h = max&#123;x.h, y.left.h&#125; + 1    return y\r\nc\r\n与题目13-3-b一样，为了方便，假设NIL节点为T.nil，其高度为\\(-1\\)。插入的过程和普通的二叉搜索树插入过程一样，但是之后需要对路径上的节点进行旋转，以保证两棵子树高度一致。\r\nAVL-INSERT(T, z)  x = T.root  y = T.nil  while x ≠ T.nil    y = x    if z.key &lt; x.key      x = x.left    else      x = x.right  z.p = y  if y == T.nil    T.root = z  else if z.key &lt; y.key    y.left = z  else y.right = z  z.h = 0  x = z.p  // 自底向上保持平衡，并且旋转后，$y.h$将会被正确计算出来。  while |x.left.h - x.right.h| &gt; 1    y = BALANCE(x)    x = y.p  \r\nd\r\n由于树的高度为\\(h=O(\\lg\r\nn)\\)，因此AVL-INSERT中的while循环至多执行\\(h=O(\\lg\r\nn)\\)次，每次循环将会执行一次BALANCE，因此循环也会执行\\(O(\\lg\r\nn)\\)次。因此，总体上AVL-INSERT的时间复杂度为\\(O(\\lg n)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论14.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-14/exercises-3/","content":"\r\n14.3-1\r\n调用程序RECURSIVE-MATRIX-CHAIN要比直接枚举括号序列优秀。\r\n假设枚举括号序列时也涉及到了第\\(k\\)个位置的划分，那么相当于将左半部分的所有解和右半部分的所有解一一组合，和最终答案比较。\r\n而调用程序RECURSIVE-MATRIX-CHAIN仅仅将左半部分的最优解和右半部分的最优解进行组合，效率相对有所提升。\r\n14.3-2\r\nMERGE-SORT的递归树如图所示：\r\ngraph TD  A[1:16];B[1:8];C[9:16];D[1:4];E[5:8];F[9:12];G[13:16];H[1:2];  I[3:4];J[5:6];K[7:8];L[9:10];M[11:12];N[13:14];O[15:16];a[1:1];  b[2:2];c[3:3];d[4:4];e[5:5];f[6:6];g[7:7];h[8:8];i[9:9];  j[10:10];k[11:11];l[12:12];m[13:13];n[14:14];o[15:15];p[16:16];A--&gt;B;  A--&gt;C;B--&gt;D;B--&gt;E;C--&gt;F;C--&gt;G;D--&gt;H;D--&gt;I;E--&gt;J;  E--&gt;K;F--&gt;L;F--&gt;M;G--&gt;N;G--&gt;O;H--&gt;a;H--&gt;b;I--&gt;c;  I--&gt;d;J--&gt;e;J--&gt;f;K--&gt;g;K--&gt;h;L--&gt;i;L--&gt;j;M--&gt;k;  M--&gt;l;N--&gt;m;N--&gt;n;O--&gt;o;O--&gt;p;\r\n归并排序时对于一个区间\\([l:r]\\)而言，MERGE-SORT递归地使用\\([l,(l+r)/2],[(l+r)/2+1]\\)这两个区间的子问题结果。但是这两个子问题并不重叠，因此记忆化并不能够有效改进分值算法的效率，如归并排序。\r\n14.3-3\r\n如果是最大化矩阵链乘的开销，这个问题仍然具有最优子结构：对于矩阵\\(A_iA_{i+1}A_{i+2}\\dots\r\nA_j\\)的链乘，它的最大开销一定是存在某个\\(k\\)，来自\\(A_iA_{i+1}A_{i+2}\\dots A_k\\)和\\(A_{k+1}A_{k+2}\\dots\r\nA_j\\)的最大开销之和，并且组合起来。\r\n14.3-4\r\n考虑\\(n=3\\)，并且\\(\\langle\r\np_0,p_1,p_2,p_3\\rangle=\\langle5,7,6,3\\rangle\\)。\r\n按照这个贪心思想，那么实际上这个矩阵的运算顺序是\\(((A_1A_2)A_3)\\)，总开销为\\(5\\times 7\\times 6+5\\times 6\\times\r\n3=300\\)。因为在求解\\(m[1,3]\\)时，有\\(p_2&lt; p_1\\)。\r\n实际上，最优的运算顺序为\\((A_1(A_2A_3))\\)，总开销为\\(7\\times 6\\times 3+5\\times 7\\times\r\n3=231\\)，比这种贪心策略优秀。\r\n14.3-5\r\n不成立。最优子结构要求我们不关心以前做出的决策。但是以前做出的决策中，可能以前做出的决策是已经出来了\\(l_i\\)根长度为\\(i\\)的钢条，如果现在继续以\\(i\\)作为决策，那么就会违反题目条件。也就是说，前面的决策会影响后面的决策进行。\r\n","categories":["算法导论"]},{"title":"算法导论14.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-14/exercises-1/","content":"\r\n14.1-1\r\n使用数学归纳法证明。\r\n当\\(n=0\\)时，结论显然成立：\\(T(0)=2^0=1\\)。\r\n当\\(n&gt;0\\)时，假设结论对\\(k=0,1,2,\\dots,n-1\\)时都成立，那么\r\n\\[T(n)=1+\\sum_{k=0}^{n-1}=1+\\sum_{k=0}^{n-1}\r\n2^k=1+2^n-1=2^n\\]\r\n原结论仍然成立。\r\n14.1-2\r\n当\\(n=4\\)，考虑下表情况：\r\n\\(\\begin{array}{|l|l|l|l|l|}\r\n\\hline\r\ni&amp;1&amp;2&amp;3&amp;4\\\\\r\n\\hline\r\np_i&amp;1&amp;12&amp;21&amp;24\\\\\r\n\\hline\r\np_i/i&amp;1&amp;6&amp;7&amp;6\\\\\r\n\\hline\r\n\\end{array}\\)\r\n按照这个贪心策略，那么先切掉一根长度为\\(3\\)的棍子（密度为\\(7\\)，最大），然后剩下长度为\\(1\\)的棍子，总价值为\\(22\\)。而实际上不切除反而更好，直接可以卖出\\(24\\)。\r\n14.1-3\r\nBOTTOM-UP-CUT-ROD-WITH-COST(p, n, c)  let r[0 : n] be a new array // will remember solution values in r  r[0] = 0  for j = 1 to n // for increasing rod length j    q = p[j] // 不切除钢条，也是一种策略，    for i = 1 to j - 1 // 此时钢条必须被切除一次，因此当前切割长度i不能循环到达j。      q = max &#123;q, p[i] + r[j − i] - c&#125;    r[j] = q // remember the solution value for length j  return r[n]\r\n14.1-4\r\nCUT-ROD(p, n)  if n == 0    return 0  q = −∞  for i = 1 to ⌊n/2⌋    q = max &#123;q, p[i] + CUT-ROD(p, n − i)&#125;    if i + i != n      q = max &#123;q, p[n - i] + CUT-ROD(p, i)&#125;    return qMEMOIZED-CUT-ROD-AUX(p, n, r)  if r[n] ≥ 0 // already have a solution for length n?    return r[n]  if n == 0    q = 0  else q = −∞  for i = 1 to ⌊n/2⌋ // i is the position of the first cut    q = max &#123;q, p[i] + MEMOIZED-CUT-ROD-AUX(p, n − i, r)&#125;    if i + i != n      q = max &#123;q, p[n - i] + MEMOIZED-CUT-ROD-AUX(p, i, r)&#125;  r[n] = q // remember the solution value for length n  return q\r\n改成了这种方式后，产生的递归子问题集合仍然和修改前的一样，因此对运行时间没有显著改变。\r\n14.1-5\r\nMEMOIZED-CUT-ROD-SOLUTION(p, n)  let r[0 : n] and s[0 : n] be a new array // will remember solution values in r  for i = 0 to n    r[i] = −∞  q = MEMOIZED-CUT-ROD-AUX-SOLUTION(p, n, r, s)  return q and sMEMOIZED-CUT-ROD-AUX-SOLUTION(p, n, r, s)  if r[n] ≥ 0 // already have a solution for length n?    return r[n]  if n == 0    q = 0  else q = −∞  for i = 1 to n // i is the position of the first cut    t = p[i] + MEMOIZED-CUT-ROD-AUX-SOLUTION(p, n − i, r, s)    if t &gt; q      q = t      s[n] = i  r[n] = q // remember the solution value for length n  return qPRINT-MEMOIZED-CUT-ROD-SOLUTION(p, n)  (q, s) = MEMOIZED-CUT-ROD-SOLUTION(p, n)  while n &gt; 0    print s[n] // cut location for length n    n = n − s[n]\r\n14.1-6\r\nFIB(n)  let fib[0 : n] be a new array  fib[0] = fib[1] = 1  for i = 2 to n    fib[i] = fib[i - 1] + fib[i - 2]  return fib[n]\r\n以\\(n=7\\)为例，可以画出如下子问题图：\r\n\r\n可以发现，这个图中一共有\\(n+1\\)个节点，分别为\\(v_0,v_1,v_2,\\dots,v_{n-1},v_n\\)。\r\n其中，对于\\(\\forall k\\ge 2\\)，\\(v_k\\)都有两条出边，因此整个图一共有\\(2(n-1)\\)条边。\r\n","categories":["算法导论"]},{"title":"算法导论13.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-13/exercises-2/","content":"\r\n13.2-1\r\n算法的伪代码由RIGHT-ROTATE给出，其和LEFT-ROTATE非常类似。\r\nRIGHT-ROTATE(T, y)  x = y.left  y.left = x.right  if x.right != T.nil    x.right.p = y  x.p = y.p  if y.p == T.nil    T.root = x  else if y == y.p.left    y.p.left = x  else    y.p.right = x  x.right = y  y.p = x\r\n13.2-2\r\n对于任意一个节点\\(x\\)，如果它有右子节点\\(r\\)，那么可以进行左旋，从而将\\(r\\)旋转到\\(x\\)的位置；如果它有左子节点\\(l\\)，那么可以进行右旋，将\\(l\\)旋转到\\(x\\)的位置。\r\n可见，如果当前节点\\(x\\)能够进行旋转，关键在于看它是否包含左/右子节点。只要包含一个子节点就能进行一次旋转。如果\\(x\\)拥有一个子节点，那么\\(x\\)恰好就需要一条边连接着它，这恰好对应了某一个旋转方案。\r\n由于\\(T\\)中一共有\\(n-1\\)条边，因此\\(T\\)中有\\(n-1\\)种不同的旋转方式。\r\n13.2-3\r\n由图可以得知，\\(a\\)的深度增加了\\(1\\)；\\(b\\)的深度保持不变；\\(c\\)的深度减少了\\(1\\)。\r\n13.2-4\r\n对于任意一棵树\\(T\\)，考虑按照如下策略将其旋转成一条向右伸展的链\\(R\\)：从根节点出发，一直访问右子节点，直到最右侧的节点，得到一条路径\\(P=(v_1,v_2,\\dots,v_m)\\)。如果这条路径上存在一个节点\\(x\\)，其左子节点非空，那么对\\(x\\)进行一次右旋，那么路径\\(P\\)将会增加一个节点。\r\n当路径\\(P\\)包含了全部节点时，上述右旋过程结束。由于进行一次右旋操作，\\(P\\)就会增加一个节点，并且\\(T\\)中最多只有\\(n\\)个节点，因此最多\\(n-1\\)次右旋操作就可以将\\(T\\)旋转成\\(R\\)。\r\n此外，由于右旋的操作是可逆的（对应一次左旋），因此从\\(R\\)旋转成任意一棵树同样至多只需要\\(n-1\\)次左旋操作。\r\n那么，假设现在需要从\\(T\\)通过旋转操作变成\\(T&#39;\\)，那么从\\(T\\)变换到\\(R\\)需要\\(c_1\\)次操作，从\\(R\\)变换到\\(T&#39;\\)需要\\(c_2\\)次操作。那么总操作次数\\(c\\)满足\\(c\\le\r\nc_1+c_2\\le 2n-2\\)。因此\\(c=O(n)\\)，原结论成立。\r\n\\(\\star\\)\r\n13.2-5\r\n如下如所示，左边的\\(T_1\\)无法通过右旋操作转化为\\(T_2\\)。\r\ngraph TD  1((1))  2((2))  3(( ))  4((1))  5((2))  6(( ))  style 3 fill:#f100,stroke-width:0px  style 6 fill:#f100,stroke-width:0px  1---3  1---2  5---4  5---6  linkStyle 0 stroke:#0ff,stroke-width:0px   linkStyle 3 stroke:#0ff,stroke-width:0px\r\n如果\\(T_1\\)能够只通过右旋操作转换成\\(T_2\\)，那么考虑进行递归操作。\\(T_2\\)的根节点必定在\\(T_1\\)中最左的路径上（即从根节点出发，一直访问左子节点，直到最左侧的叶节点，得到一条路径\\(P=(v_1,v_2,\\dots,v_m)\\)）。因此，使用\\(O(n)\\)次的操作可以将这个根节点旋转到根的位置。那么接下来对这棵树的子树递归进行这种旋转操作。由于这棵树一共有\\(n\\)个节点，因此所需要的操作次数最多为\\(n\\cdot O(n)=O(n^2)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论14.5 Exercises 答案","url":"/introduction-to-algorithms/chapter-14/exercises-5/","content":"\r\n14.5-1\r\nCONSTRUCT-OPTIMAL-BST(root, i, j, fa)  if i == j - 1    name = &quot;d&quot; + i  else    name = &quot;k&quot; + root[i, j]  if fa == 0    print name + &quot;is the root&quot;  else if j &lt; fa    print name + &quot;is the left child of&quot; + &quot; k&quot; + fa  else    print name + &quot;is the right child of&quot; + &quot; k&quot; + fa  if j &gt;= i    CONSTRUCT-OPTIMAL-BST(root, i, root[i, j] - 1, root[i, j])    CONSTRUCT-OPTIMAL-BST(root, root[i, j] + 1, j, root[i, j])\r\n14.5-2\r\n这棵树的结构如图所示，最终最优开销为\\(3.12\\)。\r\n\r\n14.5-3\r\n如果直接计算\\(w(i,j)\\)，那么可以发现需要进行\\(j-i+1\\)次循环才能完成。\r\n因此，计算总和次数为\r\n\\(\\begin{aligned}\r\n\\sum_{l=1}^n\\sum_{i=1}^{n-l+1} (i+l-1)-i+1 &amp;=\r\n\\sum_{l=1}^n\\sum_{i=1}^{n-l+1} l\\\\\r\n&amp;=\\sum_{l=1}^n l\\cdot(n-l+1)\\\\\r\n&amp;=\\Theta(n^3)\r\n\\end{aligned}\\)\r\n最终，程序OPTIMAL-BST的时间复杂度仍然为\\(\\Theta(n^3)\\)，只是常数有所增大而已。\r\n\\(\\star\\)\r\n14.5-4\r\nOPTIMAL-BST(p, q, n)  let e[1 : n + 1, 0 : n], w[1 : n + 1, 0 : n], and root[1 : n, 1 : n] be new tables  for i = 1 to n + 1 // base cases    e[i, i − 1] = qi−1 // equation (14.14)    w[i, i − 1] = qi−1  // 为了避免出错，只有一个非根节点时同样单独处理。  for i = 1 to n    e[i, i] = qi-1 + pi + qi    w[i, i] = e[i, i] + qi-1 + qi    root[i, i] = i  for l = 2 to n    for i = 1 to n − l + 1      j = i + l − 1      e[i, j] = ∞      w[i, j] = w[i, j − 1] + pj + qj // equation (14.15)      // 修改之处。      for r = root[i, j - 1] to root[i + 1, j] // try all possible roots r        t = e[i, r − 1] + e[r + 1, j] + w[i, j] // equation (14.14)        if t &lt; e[i, j] // new minimum?          e[i, j] = t          root[i, j] = r  return e and root\r\n对于修改之处的for循环，当求取\\(w[i,j]\\)的值时，\\(r\\)取遍的值在区间\\([\\text{root}[i,j-1],\\text{root}[i+1,j]]\\)。到了下一轮迭代，也就是求取\\(w[i+1,j+1]\\)时，那么此时\\(r\\)取遍的区间在于\\([\\text{root}[i+1,j],\\text{root}[i+2,j]]\\)。可以发现这两个区间，恰好是首尾相接的，只有\\(\\text{root}[i,j+1]\\)被使用了两次。\r\n因此，关于\\(i\\)的for循环，其内部关于\\(r\\)的for循环区间是两两首位相接的，因此关于\\(i\\)的for循环的时间复杂度为\\(\\Theta(n)\\)。再算上外部关于\\(l\\)的for循环，最终这个程序的时间复杂度为\\(\\Theta(n^2)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论14 Problems 答案","url":"/introduction-to-algorithms/chapter-14/problems/","content":"\r\n14-1\r\n如果从节点\\(s\\)取\\(t\\)的路径最长化，那么子问题就相当于从\\(s\\)的后继节点\\(u\\)去到\\(t\\)的路径最长化，并且再添加上从\\(s\\)到\\(v\\)的路径。\r\n子问题图就是\\((V-\\{s\\},E-\\{(s,v,w)\\mid v\r\n\\in V\\})\\).\r\n令\\(d(G,s,t)\\)表示从图\\(G=(V,E)\\)中的\\(s\\)点到\\(t\\)点的最长路径，那么可以写出状态转移方程：\r\n\\[d(G,s,t)=\\max_{(s,v,w) \\in\r\nE}\\{d((V-\\{s\\},E-\\{(s,v,w)\\mid v \\in V\\}),v,t)+w\\}\\]\r\n其中，\\(d(G,t,t)=0\\)，因为不需要移动。\r\n由于删除的点的集合数量是幂指增长的，并且可能每个顶点都有出边，因此这个算法的时间复杂度为\\(O(2^{|V|}\\cdot |E|)\\)。\r\n可以使用拓扑排序，优化上述状态转移方程，将其降低至\\(O(|V|+|E|)\\)的时间复杂度。此时不需要涉及对图的操作。\r\n14-2\r\n如果一个回文字符串两边拼上两个相同的字符，那么得到了一个新的回文字符串，其长度增加了\\(2\\)；如果一个字符串两边的字符串不相同，那么它的最长回文子序列一定是来自内部的子字符串。因此，\\(w[i,j]\\)的最优子结构是\\(w[i+1,j-1],w[i+1,j],w[i,j-1]\\)。令\\(w[i,j]\\)表示子字符串\\(X[i:j]\\)的最长回文子序列。那么可以写出\\(w\\)的状态转移方程：\r\n\\(w[i,j]=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0 &amp; &amp; \\text{if}\\quad  i&gt;j \\\\\r\n  &amp;1 &amp; &amp; \\text{if}\\quad  i=j \\\\\r\n  &amp;w[i+1,j-1]+2 &amp; &amp; \\text{if}\\quad  i&lt;j\\land  X[i]=X[j]\\\\\r\n  &amp;\\max(w[i+1,j],w[i,j-1]) &amp; &amp;\r\n\\text{if}\\quad  i&lt;j\\land  X[i]\\neq X[j]\\\\\r\n\\end{aligned}\\right.\\)\r\n计算出表\\(w\\)的所有值即可。根据第4,\r\n5行的2个嵌套循环不难得知，这个算法的时间复杂度为\\(\\Theta(n^2)\\)。\r\nLPS-SOLUTION(X, m)  let w[1 : m, 1 : m] be new table  for l = 1 to m    w[i, i] = 1  for l = 2 to m    for i = 1 to m - l + 1      j = i + l - 1      if X[i] == X[j]        w[i, j] = w[i - 1, j + 1] + 2      else        w[i, j] = max&#123;w[i - 1, j], w[i + 1, j]&#125;  n = w[1, m]  let a[1 : n] be new array  lp = 1  rp = m  lq = 1  rq = n  while lp &lt;= rp    if X[lp] == X[rp]      a[lq] = a[rq] = X[lp]      lq = lq + 1      rq = rq - 1      lp = lp + 1      rp = rp - 1    else if w[lp, rp] == w[lp + 1, rp]      lp = lp + 1    else      rp = rp - 1  return n and a\r\n14-3\r\n首先需要对这些点的\\(x\\)坐标进行排序，那么我们可以考虑把这一些点拆分成两部分，组成两条不相交的有向路径，但是公用起点和终点。那么令\\(d[i,\r\nj]\\)表示这两条不相交路径的终点分别为\\(i\\)和\\(j\\)时（假设\\(i&gt; j\\)），从起点到点\\(i\\)和从起点到点\\(j\\)这两条路径的最短长度之和。\r\n那么对于状态\\(d[i,j]\\)而言，考虑每次添加一个右边的点\\(i+1\\)进来。添加时，这个点可以添加到\\(i\\)后面，那么变成状态\\(d[i+1,j]\\)，也可以添加到\\(j\\)后面，变成状态\\(d[i+1,i]\\)。\r\n那么，可以写出\\(d\\)的状态转移方程：\r\n\\(d[i,j]=\r\n\\left \\{\\begin{aligned}\r\n  &amp;\\text{dis}(p_i,p_j) &amp; &amp; \\text{if}\\quad  i=2\\land j=1 \\\\\r\n  &amp;d[i-1,j] + \\text{dis}(p_i,p_j) &amp; &amp; \\text{if}\\quad  i &gt;\r\n2\\land j &lt; i - 1 \\\\\r\n  &amp;\\min_{k=1}^{i-2} \\{d[i-1,k] + \\text{dis}(p_k,p_j)\\} &amp; &amp;\r\n\\text{if}\\quad  i &gt; 2\\land j = i - 1 \\\\\r\n\\end{aligned}\\right.\\)\r\n因此，最终还需要使两条路线指定相同的终点，那么最终答案为\r\n\\[\\min_{i=1}^{n-2}\\{d[n-1,i]+\\text{dis}(p_n,p_{n-1})+\\text{dis}(p_n,p_i)\\}\\]\r\n子程序POINT-DISTANCE(A, B)用于计算两个点的欧几里得距离，此处忽略实现过程。\r\n假设计算两点间距离POINT-DISTANCE(A, B)的时间复杂度为\\(O(1)\\)。观察程序BITONIC-TSP第6行的嵌套循环不难得知，这个程序的时间复杂度为\\(\\Theta(n^2)\\)。\r\nBITONIC-TSP(p, n)  sort p by their x coordinate  let d[1 : n - 1, 1 : n - 1] be new table  d[2, 1] = POINT-DISTANCE(p[2], p[1])  if n == 2    return d[2, 1] * 2   for i = 3 to n - 1    for j = 1 to i - 2      d[i, j] = d[i - 1, j] + POINT-DISTANCE(p[i - 1], p[i])    d[i, i - 1] = ∞    for j = 1 to i - 2      d[i, i - 1] = min&#123;d[i - 1, j] + POINT-DISTANCE(p[j], p[i])&#125;  min-dis = ∞  for i = 1 to n - 2    min-dis = min&#123;min-dis, d[n - 1][i] + POINT-DISTANCE(p[n - 1], p[n]) + POINT-DISTANCE(p[i], p[n])&#125;  return min-dis\r\n14-4\r\n由于最后一行字符并不考虑后面的空格，因此我们考虑从后往前进行考虑。那么最优子问题就是将单词序列\\(l_i,l_{i+1},\\dots,l_n\\)打印出来需要的额外空格立方之和。\r\n如果后面这些单词只需要一行打印出来，那么就没有额外的空格（因为第一行就是最后一行）。否则，枚举\\(j\\ge i\\)，并且单词序列\\(l_i,l_{i+1},\\dots,l_j\\)都能在一行打印出来，余下的空格数立方和与打印\\(l_{j+1},l_{j+2},\\dots,l_n\\)时的最优决策时的值相加即可。\r\n令状态\\(f[i]\\)表示将单词序列\\(l_i,l_{i+1},\\dots,l_n\\)打印出来需要的额外空格立方之和，其中\\(\\displaystyle{s[i,j]=j-i+\\sum_{k=i}^j\r\nl_k}\\)表示如果打印单词序列\\(l_i,l_{i+1},\\dots,l_j\\)时所需要的字符数。那么可以写出状态转移方程\\(f\\)：\r\n\\(f[i]=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0 &amp; &amp; \\text{if}\\quad s[i,n]\\le M  \\\\\r\n  &amp;\\min_{i\\le j\\le n, s[i,j]\\le m}\\{ (M-s[i,j])^3+f[j+1]\\} &amp;\r\n&amp; \\text{if}\\quad s[i,n]\\le M  \\\\\r\n\\end{aligned}\\right.\\)\r\n如果\\(s[i,j]\\)的任意值可以以\\(\\Theta(1)\\)的时间计算出来，那么根据程序PRINTING-NEATLY-SOLUTION的第5行循环，可以观察出这个算法的时间复杂度为\\(\\Theta(n^2)\\)。\r\nCAL-CHARACTERS(l, r, S)  return S[r] - S[l - 1] + r - lPRINTING-NEATLY-SOLUTION(L, n, M)  let f[1 : n], s[0 : n], c[0 : n] be new arrays  s[0] = 0  for i = 1 to n    s[i] = s[i - 1] + L[i]  for i = n downto 1    if CAL-CHARACTERS(i, n, S)      f[i] = 0      c[i] = ∞    else      f[i] = ∞      for j = i to n        w = CAL-CHARACTERS(i, j, S)        if w &lt;= M          if f[j + 1] + (M - w) ^ 3 &lt; f[i]            f[i] = f[j + 1] + (M - w) ^ 3            c[i] = j + 1  let p be new array  i = 1  while i &lt;= n    INSERT(p, i)    i = c[i]  return f[1] and c\r\n14-5\r\na\r\n这里的子问题设计成：已经处理完了字符串\\(X[1:i],Y[1:j]\\)时所需要的最小花费。\r\n按照这6种操作的定义，直接从前往后转移即可。\r\nEDIT-DISTANCE(X, Y, m, n, QC, QR, QD, QI, QT, QK)  let d[0 : m, 0 : n] be new table with ∞  d[0, 0] = 0  for i = 0 to m    for j = 0 to n      c1 = c2 = c3 = c4 = c5 = ∞      if i &gt; 0 and j &gt; 0        // 复制        if X[i] == Y[j]          c1 = d[i - 1, j - 1] + QC        // 替换        c2 = d[i - 1, j - 1] + QR      // 删除      if i &gt; 0        c3 = d[i - 1, j] + QD      // 插入      if j &gt; 0        c4 = d[i, j - 1] + QI      // 旋转      if i &gt;= 2 and j &gt;= 2 and X[i] == Y[j - 1] and Y[j] == X[i - 1]        c5 = d[i - 2, j - 2] + QT      d[i, j] = min&#123;c1, c2, c3, c4, c5&#125;  // 终止  for i = 0 to m - 1    d[m, n] = min&#123;d[m, n], d[i, n] + QK&#125;  return d[m, n]\r\nb\r\n禁用旋转和终止操作，也就是令\\(Q_T=Q_K=+\\infty\\)。\r\n仅仅使用剩下四个操作，有\\(Q_C = -1,Q_I= Q_D\r\n= 2,Q_R = 1\\)。\r\n其中，插入和删除操作对应两个字符含有空格的规则；复制对应两个字符相同的规则；替换对应两个字符不相同的规则。\r\n最终，如下调用- EDIT-DISTANCE(X, Y, m, n, -1, 1, 2, 2, QT, QK)这个程序即可得到最大的分数，注意前面有一个负号。\r\n14-6\r\n对于每一个员工\\(x\\)，他可以进行两种决策：要么出席，要么缺席。以\\(x\\)为子树的所有员工决策满足最优子结构性质。以\\(x\\)为子树的出席最优决策，取决于\\(x\\)的所有孩子的子树的最优决策。\r\n如果\\(x\\)出席，那么\\(x\\)的下属都不出席；如果\\(x\\)不出席，那么\\(x\\)的下属出不出席并没有限制，那么选择其中最优的一个选择即可。\r\n因此，分别令\\(f_{\\text{attend}}(x),f_{\\text{absent}}(x)\\)表示当\\(x\\)出席/缺席时，以\\(x\\)为子树能够获得的最大分数和。那么不难写出状态转移方程为：\r\n\\(\\begin{aligned}\r\n&amp;f_{\\text{attend}}(x)=\\sum_{y \\text{ is child of }x}\r\nf_{\\text{absent}}(y)\\\\\r\n&amp;f_{\\text{absent}}(x)=x.\\texttt{rating}+\\sum_{y \\text{ is child of\r\n}x} \\max\\{f_{\\text{absent}}(y),f_{\\text{attend}}(y)\\}\\\\\r\n\\end{aligned}\\)\r\n因此如果根节点为\\(r\\)，最终结果为根节点\\(\\max\\{f_{\\text{absent}}(r),f_{\\text{attend}}(r)\\}\\)。\r\n由于每个节点恰好都被遍历了一次，并且其余操作都是常数操作，因此整个算法的时间复杂度为\\(\\Theta(n)\\)。\r\nPLANNING-A-COMPANY-PARTY(x)  attend, absent = PLANNING-NOW(x)  m = max&#123;attend, absent&#125;  let A be new array  PLANNING-GET-SOLUTION(x, A, m == attend)  return m and A PLANNING-NOW(x)  if x == NIL    return 0 and 0  attend = x.rating  absent = 0  p = x.left-child  while p != NIL    x, y = PLANNING-NOW(p)    attend = attend + y    absent = absent + max&#123;x, y&#125;    p = p.right-sibling  x.attend = attend  x.absent = absent  return attend and absentPLANNING-GET-SOLUTION(x, A, isattend)  if x == NIL    return   if isattend    INSERT(A, x)  p = x.left-child  while p != NIL    if isattend == True      PLANNING-GET-SOLUTION(p, A, False)    else      PLANNING-GET-SOLUTION(p, A, p.attend &gt;= p.absent)\r\n14-7\r\na\r\n考虑状态\\(d[i,j]\\)表示是否存在一条从\\(v_0\\)开始，长度为\\(i\\)，最终到达节点\\(j\\)的路径。并且，这一条路径的权值和sigma[1 : i]完全匹配。如果长度为\\(i-1\\)的路径是匹配的，并且符号相同，那么长度为\\(i\\)的路径也必定是匹配的。\r\n那么不难写出关于\\(d\\)的状态转移方程：\r\n\\(d[i,j]=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1 &amp; &amp; \\text{if}\\quad i=0 \\land j=v_0\\lor i&gt;0\\land\r\n(\\exists u\\in V,(u,j)\\in E\\land\\sigma(u,j)=\\sigma_i\\land d[i-1,u]=1) \\\\\r\n  &amp;0 &amp; &amp; \\text{if}\\quad i=0 \\land j\\neq v_0\\lor\r\ni&gt;0\\land\\lnot (\\exists u\\in V,(u,j)\\in\r\nE\\land\\sigma(u,j)=\\sigma_i\\land d[i-1,u]=1) \\\\\r\n\\end{aligned}\\right.\\)\r\n最终，如果\\(G\\)是采用邻接表实现的，那么为了方便转移，此时使用图\\(G\\)的转置\\(G^T\\)进行转移。那么根据程序VITERBI-PATH第5行的内循环可以得知，进行一次的时间为\\(\\Theta(|E|)\\)，外加外循环\\(\\Theta(k)\\)，最终整个算法的时间复杂度为\\(\\Theta(k\\cdot |E|)\\)。\r\nVITERBI-PATH(G, v0, sigma, k)  let d[0 : k, 1 : |V|], prev[0 : k, 1 : |V|] be new tables with 0  let GT be transpose graph of G  d[0, v0] = 1  for i = 1 to k    for u = 1 to |V|      for each v in GT.Adj[u]        if d[i - 1, v] == 1 and GT.sigma(u, v) == sigma[i]          d[i, u] = 1          prev[i, u] = v  for q = 1 to |V|    if d[k, q] == 1      let sol[0, k] be new array      sol[0] = v0      for i = k downto 1        sol[i] = q        q = prev[i][q]      return sol  return NO-SUCH-PATH\r\nb\r\n只需要多记录一个状态参数prob[i, j]，表示这条路径如果存在的最大概率，转移时只需要顺带维护状态值即可。\r\n由于只是多新建了一个表，单次转移的过程仍然是\\(\\Theta(1)\\)，因此整个算法的时间复杂度仍为\\(\\Theta(k\\cdot |E|)\\)。\r\nVITERBI-PATH&#x27;(G, v0, sigma, k)  let d[0 : k, 1 : |V|], prev[0 : k, 1 : |V|], prob[0 : k, 1 : |V|] be new tables with 0  let GT be transpose graph of G  d[0, v0] = 1  prob[0, v0] = 1  for i = 1 to k    for u = 1 to |V|      for each v in GT.Adj[u]        if d[i - 1, v] == 1 and GT.sigma(u, v) == sigma[i]          d[i, u] = 1          if prob[i - 1, v] * GT.p(u, v) &gt; prob[i, u]               prob[i, u] = prob[i - 1, v] * GT.p(u, v)            prev[i, u] = v  for q = 1 to |V|    if d[k, q] == 1      let sol[0, k] be new array      sol[0] = v0      for i = k downto 1        sol[i] = q        q = prev[i][q]      return sol  return NO-SUCH-PATH\r\n14-8\r\na\r\n由于\\(n&gt;1\\)，因此如果在第\\(1\\)列，有两个选项朝下方选择：正下方或者是右下方；如果是在第\\(n\\)列，那么可以选择正下方或者是左下方；否则，左下方，正下方，右下方都可以选择。无论在哪一行哪一列，都至少有\\(2\\)个选项选择，因此一个图像的接缝数的渐进增长满足\\(\\Omega(2^m)\\)，即指数级别。\r\nb\r\n令状态\\(f[i,j]\\)表示已经删除了前\\(i\\)行的一个像素，其中删除的第\\(i\\)行的像素为\\(j\\)时，已经累积的破坏度。\r\n那么按照题意，每一个状态仅能从\\(f[i-1,j-1],f[i-1,j],f[i-1,j+1]\\)三个之一转移而来，不难写出状态转移方程：\r\n\\(f[i,j]=\r\n\\left \\{\\begin{aligned}\r\n  &amp;d[i,j] &amp; &amp; \\text{if}\\quad i=1 \\\\\r\n  &amp;\\min\\{f[i-1,j],f[i-1,j+1]\\}+d[i,j] &amp; &amp; \\text{if}\\quad\r\ni&gt;1 \\land j = 1\\\\\r\n  &amp;\\min\\{f[i-1,j-1],f[i-1,j]\\}+d[i,j] &amp; &amp; \\text{if}\\quad\r\ni&gt;1 \\land j = m\\\\\r\n  &amp;\\min\\{f[i-1,j-1],f[i-1,j],f[i-1,j+1]\\}+d[i,j] &amp; &amp;\r\n\\text{if}\\quad i&gt;1 \\land 1 &lt; j &lt; m\\\\\r\n\\end{aligned}\\right.\\)\r\n删完最后一行的像素后，得到最终结果：\r\n\\[\\min_{j=1}^n\\{f[m,j]\\}\\]\r\n由于可以转移的状态最多为\\(3\\)个，因此根据第5,\r\n6行的嵌套循环可知算法IMAGE-COMPRESSION的时间复杂度为\\(\\Theta(n,m)\\)。\r\nIMAGE-COMPRESSION(A, d, m, n)  let f[0 : k, 1 : |V|], prev[0 : k, 1 : |V|] be new tables  for j = 1 to n    f[1, j] = d[1, j]    prev[1, j] = j  for i = 2 to m    for j = 1 to n      c1 = c2 = c3 = ∞      if j &gt; 1        c1 = f[i - 1, j - 1] + d[i, j]      c2 = f[i - 1, j] + d[i, j]      if j &lt; m        c3 = f[i - 1, j + 1] + d[i, j]      c = min&#123;c1, c2, c3&#125;      f[i, j] = c      if c == c1        prev[i, j] = j - 1      else if c == c2        prev[i, j] = j      else        prev[i, j] = j + 1  q = 1  for j = 1 to n    if f[m, j] &lt; f[m, q]      q = j  let sol[1 : m] be new array  for j = m downto 1    sol[j] = q    q = prev[m, q]  return f[m, q] and sol\r\n14-9\r\n为了方便描述和编写这个算法，数组\\(L\\)末端会添加一个新元素\\(n\\)，也就是字符串\\(s\\)的长度。\r\n这个问题的子问题是将字符串\\(s[L[i-1]+1:L[j]]\\)按照\\(L[i:j]\\)所展示的那样划分，如果这个划分是最优的，那么由最优子结构的问题组合成的原问题也是最优的。\r\n令\\(f[i,j]\\)表示将\\(s[L[i-1]+1:L[j]]\\)按照\\(L[i:j]\\)划分时，所需要的最小代价。那么考虑从\\([i,j)\\)中间某个点\\(k\\)进行切分。可以写出关于\\(f\\)状态转移方程：\r\n\\(f[i,j]=\r\n\\left \\{\\begin{aligned}\r\n  &amp;d[i,j] &amp; &amp; \\text{if}\\quad i=j \\\\\r\n  &amp;\\min_{k=i}^{j-1}\\{f[i,k]+f[k+1,j]\\}+L[j]-L[i-1] &amp; &amp;\r\n\\text{if}\\quad i&lt;j\\\\\r\n\\end{aligned}\\right.\\)\r\n那么最终将整个字符串划分的最小代价为\\(f[1,m]\\)。\r\nBREAKING-STRING-GEN-SOL(sol, prev, i, j)  if i == j    return  INSERT(sol, prev[i, j])  BREAKING-STRING-GEN-SOL(sol, prev, i, prev[i, j])  BREAKING-STRING-GEN-SOL(sol, prev, prev[i, j] + 1, j)BREAKING-STRING(S, L, n, m)  //为了方便，在下标m+1处多添加一个元素n，虽然已经溢出了。   L[m + 1] = n  let f[1 : k, 1 : m + 1] be new table with ∞  let prev[1 : k, 1 : m + 1] be new table  m += 1  for i = 1 to m    f[i, i] = 0  for l = 2 to m    for i = 1 to m - l + 1      j = i + l - 1      tmp = ∞      q = i      for k = i to j - 1        if f[i, k] + f[k + 1, j] + L[j] - L[i - 1] &lt; tmp          tmp = f[i, k] + f[k + 1, j] + L[j] - L[i - 1]          q = k      f[i, j] = tmp      prev[i, j] = q  let sol be a new array  BREAKING-STRING-GEN-SOL(sol, prev, 1, m)\r\n14-10\r\n这道题的题意似乎并不太清晰，需要多添加另外\\(2\\)个假设：\r\n\r\n每一年投资得到的利息，不能用于下一次投资。也就是说，每一年投资额恒为\\(10000\\)美元。\r\n每年年末支付\\(f_1,f_2\\)时，是额外支付的，并不从投资的本金中支付。\r\n\r\na\r\n假设存在一个最优的投资计划，并且第\\(y_1\\)到第\\(y_2\\)年中，该投资计划保持不变。那么假设第\\(y_1\\)年开始前，对第\\(i\\)个投资投资了\\(d_i\\)美元，那么到第\\(y_2\\)年结束时，得到的钱为\\(\\displaystyle{\\sum_{i=1}^n\\sum_{j=y_1}^{y_2} d_i\r\nr_{ij}}\\)。\r\n可以知道\\(\\exists 1\\le p\\le n,\\forall 1\\le\r\ni\\le n\\)，使得\\(\\displaystyle{\\sum_{j=y_1}^{y_2}\r\nr_{pj}\\ge\\sum_{j=y_1}^{y_2} r_{ij}}\\)均成立。\r\n因此，将这个投资计划的投给第\\(i\\)个投资产品的钱转移到投给第\\(p\\)个投资产品，那么在第\\(y_1\\)年到第\\(y_2\\)年得到的钱将会更多。\r\n也就是有：\r\n\\[\\sum_{i=1}^n\\sum_{j=y_1}^{y_2} d_i\r\nr_{ij}\\le \\sum_{i=1}^n\\sum_{j=y_1}^{y_2} d_i\r\nr_{pj}=d\\sum_{j=y_1}^{y_2}  r_{pj}\\]\r\n最终，如果存在一种最优的方案是投资多个产品，那么通过上述剪切-粘贴技术可以将这个投资方案转化成一个更优的单一投资产品方案。\r\nb\r\n按照题目14-10-a的结论，如果今年的投资方案是最优的，要么就是从上一年同一个投资产品最优的方案转移而来，此时仅产生少量的费用\\(f_1\\)，要么是从投资其它产品的最优方案直接迁移所有资金到当前产品，此时产生同样的资金转移费用。因此，单一状态\\(f[i,j]\\)的最优解来自于这\\(n\\)个子问题的最优解。\r\nc\r\n令\\(f[i,j]\\)表示第\\(i\\)年结束时（假设第\\(i+1\\)年不继续，那么就不付手续费），最终得到的钱的总数（其中\\(d=10000\\)）。\r\n那么不难写出状态转移方程：\r\n\\(f[i,j]=\r\n\\left \\{\\begin{aligned}\r\n  &amp;d\\cdot r_{j1}  &amp; &amp; \\text{if}\\quad i=1 \\\\\r\n  &amp;\\max\\{f[i-1,j]-f_1,\\max_{k=1}^n\\{f[i-1,k]\\}-f_2\\} +d\\cdot\r\nr_{ji}&amp; &amp; \\text{if} \\quad i&gt;1\\\\\r\n\\end{aligned}\\right.\\)\r\n由此可得到最终答案为\r\n\\[\\max_{j=1}^{n} \\{f[10,j]\\}\\]\r\n那么可以写出如下算法INVESTMENT-STRATEGY，注意到第4行的嵌套循环是一个二重循环，因此可以知道整个算法的时间复杂度为\\(\\Theta(n\\cdot y)\\)。\r\nINVESTMENT-STRATEGY(r, n, d = 10000, y = 10)  let f[1 : y, 1 : n], prev[1 : y][1 : n] be new table with 0  for j = 1 to n    f[1, j] = d * r[j, 1]  for i = 2 to y    pt = 1    for j = 1 to n      if f[i - 1, j] &gt; f[i - 1, pt]        pt = j    for j = 1 to n      if f[i - 1, j] - f1 &gt; f[i - 1, pt] - f2        f[i, j] = f[i - 1, j] - f1 + d * r[j, i]        prev[i, j] = j      else        f[i, j] = f[i - 1, pt] - f2 + d * r[j, i]        prev[i, j] = pt  pt = 1  for j = 1 to n    if f[y, j] &gt; f[y, pt]      pt = j  let sol[1, y] be new array  q = pt  for i = y downto 1    sol[i] = q    q = prev[i, q]  return f[y, pt] and sol\r\nd\r\n如果添加了这个限制，那么对于当前状态\\(f[i,j]\\)，如果一开始投资的金额超过了\\(15000\\)的美元，那么需要涉及到资金分拆的问题，新生成的子问题将会涉及到多个使用分拆后的资金进行投资的问题，由此子问题数量将会急剧上升，原来我们所设计的最优子结构将不会再成立。\r\n14-11\r\n考虑将每一个月的月终视为动态规划的一个阶段，子问题则是上一个月剩下的机器数量。\r\n令\\(f[i, j]\\)表示第\\(i\\)个月结束后，在仓库内部剩下的机器数量为\\(j\\)时，所需要交付出的最少成本。\r\n对于每个状态\\(f[i,\r\nj]\\)，它可以从\\(0 \\sim j +\r\nd_i\\)这些状态转移而来，因为就算不生产，为达到当前数量，上限只能会是\\(j+d_i\\)。\r\n那么不难写出状态转移方程：\r\n\\(f[i,j]=\r\n\\left \\{\\begin{aligned}\r\n  &amp;\\text{cost}(j+d_i,m,c) &amp; &amp; \\text{if}\\quad i=1 \\\\\r\n  &amp;\\min_{k=0}^{\\min\\{j+d_i,D\\}}\r\n\\{f[i-1,k]+\\text{cost}(j-k+d_i,m,c)\\}&amp; &amp; \\text{if} \\quad\r\ni&gt;1\\\\\r\n\\end{aligned}\\right.\\)\r\n其中，\\(\\text{cost}(n,m,c)=\\max\\{n-m,0\\}\\cdot\r\nc\\)表示这个月生产\\(n\\)个机器时带来的额外成本。\r\n由此可得到最终答案为\r\n\\[\\min_{j=1}^{D} \\{f[n,j]\\}\\]\r\n那么可以写出如下算法INVENTORY-PLANNING，注意到第5, 6,\r\n7行的嵌套循环，其中第\\(6\\)个循环的循环上限最大为\\(D\\)，因此可以知道整个算法的时间复杂度为\\(O(nD^2)\\)。\r\nCOST(n, m, c)  return max&#123;n - m, 0&#125; * cINVENTORY-PLANNING(d, n, m, c, h)  D = sum(d)  let f[1 : n, 0 : D] be new table with ∞  for j = 0 to D    f[1, j] = cal(j + d[1], m, c) + h[j]  for i = 2 to n    for j = 0 to D      for k = 0 to min&#123;j + d[i], D&#125;        f[i, j] = min&#123;f[i, j], f[i - 1, k] + COST(j - k + d[i], m, c) + h[j]&#125;  return min&#123;f[n, 0], f[n, 1], ..., f[n, D]&#125;\r\n14-12\r\n考虑将每一个位置视作是动态规划的一个阶段。\r\n令\\(f[i,\r\nj]\\)表示已经考虑签约了前\\(j\\)个位置的球员，已经花费了\\(j\\)，得到的最大VORP之和。\r\n对于每个状态\\(f[i, j]\\)，一共有\\(P+1\\)个策略：分别从\\(P\\)个球员中选择一个；或者是在这个位置上不招球员。\r\n那么可以写出状态转移方程：\r\n\\(f[i,j]=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0 &amp; &amp; \\text{if}\\quad i=0\\land j=0 \\\\\r\n  &amp;\\max\\{f[i-1,j],\\max_{1\\le k\\le P,\\text{cost}[i,k]\\le j}\r\n\\{f[i-1,j-\\text{cost}[i,k]]+\\text{vorp}[i,k]\\}\\} &amp; &amp;\r\n\\text{if}\\quad 1\\le i\\le n \\\\\r\n  &amp;-\\infty &amp; &amp; \\text{otherwise} \\\\\r\n\\end{aligned}\\right.\\)\r\n可以得到最终答案为\r\n\\[\\max_{j=1}^{X} f[N,j]\\]\r\n那么可以写出如下算法SIGNING-FREE-AGENT-BASEBALL-PLAYERS，注意到第4,\r\n5, 7行的嵌套循环，循环大小分别恒为\\(N,X+1,P\\)，因此整个程序的时间复杂度为\\(\\Theta(NXP)\\)。\r\n// 这里同样假设X是10万的整数，并且cost[i, j], vorp[i, j]表示第i个位置第j个人的信息。// 这两个表的下标范围为cost[1 : N, 1 : P], vorp[1 : N, 1 : P]。SIGNING-FREE-AGENT-BASEBALL-PLAYERS(cost, vorp, N, P, X)  let f[0 : N, 0 : X] be new table with -∞  let prev[0 : N][0 : X] be new table with 0  f[0, 0] = 0  for i = 1 to N    for j = 0 to X      f[i, j] = f[i - 1, j]      for k = 1 to P        if cost[i, k] &lt;= j and f[i - 1,j - cost[i, k]] + vorp[i, k] &gt; f[i, j]          f[i, j] = f[i - 1,j - cost[i, k]] + vorp[i, k]          prev[i, j] = k  max_vorp = -∞  now_cost = 0  for j = 0 to X    if f[N, j] &gt; max_vorp      max_vorp = f[N, j]      now_cost = j  let sol be new array  j = now_cost  for i = N downto 1    if prev[i, j] != 0      INSERT(sol, (i, k))      j = j - cost[i, k]  return max_vorp, now_cost and sol \r\n","categories":["算法导论"]},{"title":"算法导论14.4 Exercises 答案","url":"/introduction-to-algorithms/chapter-14/exercises-4/","content":"\r\n14.4-1\r\n实际上，一共有\\(8\\)个符合要求的子序列，这些子序列的长度为\\(6\\)。\r\n\\(\\begin{aligned}\r\n\\langle0,0,1,0,1,0\\rangle \\\\\r\n\\langle0,0,1,0,1,1\\rangle \\\\\r\n\\langle0,0,1,1,0,1\\rangle \\\\\r\n\\langle0,1,0,1,0,1\\rangle \\\\\r\n\\langle1,0,0,1,1,0\\rangle \\\\\r\n\\langle1,0,1,0,1,0\\rangle \\\\\r\n\\langle1,0,1,0,1,1\\rangle \\\\\r\n\\langle1,0,1,1,0,1\\rangle \\\\\r\n\\end{aligned}\\)\r\n14.4-2\r\nRECONSTRUCT-LCS(c, X, Y, m, n)  k = c[m, n]  let l[1 : k] be a new array  while m &gt; 0 and n &gt; 0    if X[m] == Y[n]      l[c[m, n]] = X[m]      m = m - 1      n = n - 1    else if c[m, n] == c[m - 1, n]      m = m - 1    else      n = n - 1  return l\r\n14.4-3\r\nMEMOIZED-LCS-LENGTH(X, Y, i, j, b, c)  if i == 0 or j == 0    c[i, j] = 0    return 0  else if c[i, j] != -1    return c[i, j]  else    if X[i] == Y[j]      c[i, j] = MEMOIZED-LCS-LENGTH(X, Y, i - 1, j - 1, b, c) + 1      b[i, j] = &quot;↖&quot;    else      u = MEMOIZED-LCS-LENGTH(X, Y, i - 1, j, b, c)      l = MEMOIZED-LCS-LENGTH(X, Y, i, j - 1, b, c)      if u &gt;= l        c[i, j] = u        b[i, j] = &quot;↑&quot;      else        c[i, j] = l        b[i, j] = &quot;←&quot;    return c[i, j]\r\n14.4-4\r\n为了尽量减少元素使用量，如果\\(m&lt;\r\nn\\)，那么交换字符串\\(X,Y\\)再运行程序。这并不影响它们的LCS长度。\r\n可以发现，由于\\(c[i,j]\\)只从\\(c[i-1,j],c[i-1,j-1],c[i,j-1]\\)中的一个状态转移过来，这些状态只从在当前行或者上一行，因此我们只需要保存两行的\\(c\\)表即可。\r\n计算\\(c[i,j]\\)时，如果只希望保存一行元素，那么针对上一行的元素两个元素\\(c[i-1,j-1],c[i-1,j]\\)分别进行如下处理：\r\n\r\n用一个临时遍历临时存储\\(c[i-1,j-1]\\)。\r\n\\(c[i-1,j]\\)的值仍然未被覆盖，可以直接使用。\r\n\r\n这两个版本的伪代码如下：\r\nLCS-LENGTH1(X, Y, m, n)  if m &lt; n    swap X with Y    swap m with n  let c[0 : 2, 0 : n] be new table  for j = 0 to n    c[0, j] = 0  c[1, 0] = 0  for i = 1 to m    for j = 1 to n      if X[i] == Y[j]        c[i mod 2, j] = c[1 - (i mod 2), j - 1] + 1      else        c[i mod 2, j] = max&#123;c[i mod 2, j - 1], c[1 - (i mod 2), j]&#125;  return c[m mod 2, n]LCS-LENGTH2(X, Y, m, n)  if m &lt; n    swap X with Y    swap m with n  let c[0 : n] be new array  for j = 0 to n    c[j] = 0  for i = 1 to m    prev = c[0]    for j = 1 to n      temp = c[j]      if X[i] == Y[j]        c[j] = p + 1      else        c[j] = max&#123;c[j - 1], c[j]&#125;      prev = temp  return c[n]\r\n14.4-5\r\n假设\\(X[0]=-\\infty\\)，以使得所有\\(X[i]\\)都可以接在它后面，实际上，\\(X[0]\\)并不存在。对于每一个数\\(X[i]\\)，如果\\(j&lt; i\\)并且\\(X[j]\\le X[i]\\)，那么如果一个序列以\\(X[j]\\)为结尾，添加上\\(X[i]\\)后，那么变成了以\\(X[i]\\)为结尾的序列，并且长度增加了\\(1\\)。令\\(c[i]\\)为以\\(X[i]\\)为结尾的子序列的最长长度，那么根据最优子结构，可以写出如下状态转移方程：\r\n\\(c[i]=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0 &amp; &amp; \\text{if}\\quad  i=0 \\\\\r\n  &amp;\\max_{0\\le j&lt;i,X[j]\\le X[i]}\\{ f[j]+1\\}&amp; &amp;\r\n\\text{if}\\quad  i&gt;0 \\\\\r\n\\end{aligned}\\right.\\)\r\n按照这个状态转移方程可以写出子程序LIS-LENGTH：\r\nLIS-LENGTH(X, m)  let c[0 : m] be new array  X[0] = −∞  for i = 0 to m    f[i] = 0    for j = 0 to i - 1      if X[j] &lt;= X[i]        f[i] = max&#123;f[i], f[j] + 1&#125;  q = 0  for i = 1 to m    q = max&#123;q, f[i]&#125;  return q\r\n\\(\\star\\)\r\n14.4-6\r\nLIS-LENGTH(X, m)  let a[1 : m] be new array  n = 0  for i = 1 to m:    if n == 0 or X[i] &gt;= a[n]      n += 1      a[n] = X[i]    else      let j ∈ [1, 2, ..., n] be the largest index s.t. a[j] &gt; X[i]      a[j] = X[i]  return n\r\n基本思想：如果我们得到了一个不下降子序列，那么我们希望最后一个数尽可能的小，以使以后转移时当前状态有更大的机会。数组\\(a[i]\\)表示长度为\\(i\\)的最长上升子序列中，第\\(i\\)个数能达到的最小值。如第8行中的代码，如果找到了符合条件的\\(j\\)，那么说明\\(a[j-1]\\le X[i]\\)，那么\\(X[i]\\)可以拼接在\\(a[j-1]\\)的后面，从而得到一个长度为\\(j\\)的不下降子序列。\r\n迭代完成后，\\(n\\)就是能够得到最长的不下降子序列长度。由于数组\\(a\\)一直是单调递增的，因此第8行代码在寻找j的过程可以以\\(\\Theta(\\lg n)\\)的时间完成。\r\n最终，整个算法的时间复杂度为\\(O(n \\lg\r\nn)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论12.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-12/exercises-1/","content":"\r\n12.1-1\r\n对于键的集合\\(\\{1, 4, 5, 10, 16, 17,\r\n21\\}\\)，高度为\\(2,3,4,5,6\\)的树分别如图所示：\r\n\r\n12.1-2\r\n区别在于，二叉搜索树要求右子树所有的关键字都大于当前节点，而左子树的关键字都小于当前节点，这个定义是针对子树的；而最小堆仅要求两个子节点的关键字都大于当前节点，这个定义是针对子节点的。最小堆的两个子节点在定义上并没有先后的区别，因此如果要设计以\\(O(n)\\)的时间遍历最小堆按序打印关键字的算法，将会无法做出先遍历左子节点还是右子节点的选择。最终，这个算法无法设计出来。\r\n12.1-3\r\nNONRECURSIVE-INORDER-TREE-WALK(x)  let S be a new STACK  p = x  while not STACK-EMPTY(S) or p != NIL    while p != NIL      PUSH(S, p)      p = p.left    if STACK-EMPTY(S)      p = POP(S)      print p.key      p = p.right  \r\n12.1-4\r\nPREORDER-TREE-WALK(x)  if x ≠ NIL    print x.key    PREORDER-TREE-WALK(x.left)    PREORDER-TREE-WALK(x.right)POSTORDER-TREE-WALK(x)  if x ≠ NIL    POSTORDER-TREE-WALK(x.left)    POSTORDER-TREE-WALK(x.right)    print x.key\r\n12.1-5\r\n考虑使用反证法证明：如果通过任意一个序列构造一棵二叉搜索树的时间复杂度为\\(o(n\\lg\r\nn)\\)，那么通过中序遍历这棵二叉搜索树，可以以\\(\\Theta(n)\\)的时间复杂度导出一个有序序列，整个过程的时间复杂度为\\(o(n\\lg n)+\\Theta(n)=o(n\\lg\r\nn)\\)，这和原题目条件中基于比较排序的运行时间为\\(\\Omega(n\\lg\r\nn)\\)矛盾。因此构造任意一个序列的二叉搜索树的时间复杂度为\\(\\Omega(n\\lg n)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论12.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-12/exercises-2/","content":"\r\n12.2-1\r\n随着遍历过程的进行，潜在的最大值和最小值区间逐渐减小。如果某个序列中的值不在这个区间里，那么这个检查序列是非法的。\r\na\r\n\\(\\begin{aligned}\r\n2&amp;\\in[1,1000]\\\\\r\n252&amp;\\in[3,1000]\\\\\r\n401&amp;\\in[253,1000]\\\\\r\n330&amp;\\in[253,400]\\\\\r\n398&amp;\\in[331,400]\\\\\r\n344&amp;\\in[331,397]\\\\\r\n363&amp;\\in[345,397]\r\n\\end{aligned}\\)\r\n因此本题是一个合法的检查序列。\r\nb\r\n\\(\\begin{aligned}\r\n924&amp;\\in[1,1000]\\\\\r\n220&amp;\\in[1,923]\\\\\r\n911&amp;\\in[221,923]\\\\\r\n244&amp;\\in[211,910]\\\\\r\n898&amp;\\in[245,910]\\\\\r\n258&amp;\\in[245,897]\\\\\r\n362&amp;\\in[259,897]\\\\\r\n363&amp;\\in[364,897]\r\n\\end{aligned}\\)\r\n因此本题是一个合法的检查序列。\r\nc\r\n\\(\\begin{aligned}\r\n925&amp;\\in[1,1000]\\\\\r\n202&amp;\\in[1,924]\\\\\r\n911&amp;\\in[203,924]\\\\\r\n240&amp;\\in[203,910]\\\\\r\n912&amp;\\not\\in[241,910]\\\\\r\n\\end{aligned}\\)\r\n因此本题不是一个合法的检查序列。\r\nd\r\n\\(\\begin{aligned}\r\n2&amp;\\in[1,1000]\\\\\r\n399&amp;\\in[3,1000]\\\\\r\n387&amp;\\in[3,398]\\\\\r\n219&amp;\\in[3,386]\\\\\r\n266&amp;\\in[220,386]\\\\\r\n382&amp;\\in[267,386]\\\\\r\n381&amp;\\in[267,381]\\\\\r\n278&amp;\\in[237,380]\\\\\r\n363&amp;\\in[279,380]\r\n\\end{aligned}\\)\r\n因此本题是一个合法的检查序列。\r\ne\r\n\\(\\begin{aligned}\r\n935&amp;\\in[1,1000]\\\\\r\n278&amp;\\in[1,934]\\\\\r\n347&amp;\\in[279,934]\\\\\r\n621&amp;\\in[348,934]\\\\\r\n299&amp;\\not\\in[348,620]\\\\\r\n\\end{aligned}\\)\r\n因此本题不是一个合法的检查序列。\r\n12.2-2\r\nTREE-MINIMUM(x)  if x == NIL    return -1  else if x.left != NIL    return TREE-MINIMUM(x.left)  else return xTREE-MAXIMUM(x)  if x == NIL    return 0  else if x.right != NIL    return TREE-MAXIMUM(x.right)  else return x\r\n12.2-3\r\nTREE-PREDECESSOR(x)  if x.left != NIL    return TREE-MAXIMUM(x.left)  else    y = x.p    while y != NIL and x == y.left      x = y      y = y.p    return y\r\n12.2-4\r\n\r\n如图所示，路径为\\(\\{1,2,4\\}\\)，那么有\\(A=\\{3\\},B=\\{1,2,4\\},C=\\varnothing\\)。\r\n令\\(a=3,b=1,a\\in A,b\\in\r\nB\\)，但是\\(a&gt;b\\)。故原结论不成立。\r\n12.2-5\r\n如果一个节点\\(p\\)有两个子节点，那么按照算法TREE-SUCCESSOR的第二行，\\(p\\)的后继节点是其右子树的最小节点\\(t\\)。如果这个最小节点具有左子节点\\(t.left\\)，\\(p\\)的后继节点将是\\(t.left\\)，因为\\(t.left\\)的键比\\(t\\)还小，因此\\(t\\)必定没有左子节点。可以通过类似的证明，知道\\(p\\)的前驱节点是其左子树的最大节点\\(u\\)，并且\\(u\\)没有右子节点。\r\n12.2-6\r\n第一步是证明\\(x\\)的后继节点\\(y\\)是\\(x\\)的祖先。假设\\(x\\)不是\\(y\\)的祖先，令\\(z\\)是\\(x,y\\)的最近公共祖先。根据二叉搜索树的性质，\\(x&lt; z&lt; y\\)必定成立，因为\\(x\\)在\\(z\\)的左子树中，\\(y\\)在\\(z\\)的右子树中。\\(z\\)比\\(y\\)小，仍依旧比\\(x\\)大，因此\\(y\\)不可能是\\(x\\)的后继节点。因此\\(y\\)是\\(x\\)的祖先节点。\r\n第二步是证明原题目的结论。考虑从根节点\\(r\\)到\\(x\\)的路径\\(P\\)。如果节点\\(q\\)和其右子节点\\(q.right\\)都在\\(P\\)上，那么\\(x\\)在\\(q\\)的右子树中，有\\(q&lt; x\\)，因此\\(q\\)不可能是\\(x\\)的后继节点。对于路径上任意两个节点\\(p,q\\)，并且\\(p.left,q.left\\)都在\\(P\\)上，并且\\(p\\)的深度大于\\(q\\)的深度，那么有\\(x&lt; p&lt; q\\)，因为\\(p\\)在\\(q\\)的左子树中，\\(x\\)在\\(p\\)的左子树中，\\(q\\)不可能是\\(x\\)的后继。\r\n最终，如果\\(x\\)没有右子节点，那么其后继节点是最深的节点\\(p\\)，满足\\(p,p.left\\)都在从\\(r\\)到\\(x\\)的路径中。\r\n12.2-7\r\n此处通过证明二叉搜索树\\(T\\)中的每一条边最多只需要遍历\\(2\\)次，总共最多需要遍历\\(2n-2\\)条边，从而得知这个算法的时间复杂度为\\(O(n)\\)。\r\n对于任意一个非根节点\\(x,x.p\\)和\\(x\\)之间都会有一条边\\(e\\)。假设\\(x\\)子树的最小值为\\(m\\)，最大值为\\(M\\)，那么两次遍历到边\\(e\\)的情况分别是：\\(m\\)的前驱求取它的后继，\\(M\\)求取它的后继。因为\\(m\\)的前驱小于\\(x\\)，因此从\\(m\\)的前驱遍历到\\(M\\)必须经过边\\(e\\)；类似的，\\(r\\)的后继大于\\(x\\)，从\\(M\\)求取它的后继必须经过边\\(e\\)。最终每条边最多只经过\\(2\\)次。\r\n由于输入的树规模为\\(n\\)，因此时间复杂度为\\(\\Omega(n)\\)，最终时间复杂度为\\(\\Theta(n)\\)。\r\n12.2-8\r\n令\\(y\\)是\\(x\\)的第\\(k\\)个后继，考虑从\\(x\\)到\\(z\\)的路径为\\(P\\)。令\\(z\\)是\\(x,y\\)的最近公共祖先，那么\\(z\\in P\\)。由于树的高度为\\(h\\)，因此路径\\(P\\)的长度最长只有\\(2h\\)，因此遍历这一条路径至少需要\\(O(h)\\)的时间。\r\n令节点集合\\(S\\)为\\(x\\)的第\\(\\{1,2,\\dots,k\\}\\)个后继，包括\\(x\\)本身。令路径\\(P_l\\)为从\\(x\\)到\\(z.left\\)的所有节点，令路径\\(P_r\\)为从\\(z.right\\)到\\(y\\)的所有子节点。\r\n根据二叉搜索树的定义，\\(P_l\\)上的所有节点的右子树的节点\\(u\\)都满足\\(x&lt;\r\nu&lt;p,P_r\\)上的所有节点的左子树的节点\\(v\\) 都满足\\(p&lt;\r\nv&lt; y\\)。也就是说，这些节点恰好构成了集合\\(S\\)。因此，集合\\(S\\)中的节点可以看成是由一系列二叉搜索子树通过一条链串成。根据题目12.2-7的结论，遍历这一系列子树的运行时间之和为\\(O(k)\\)。\r\n因此这个算法的总时间复杂度为\\(O(h+k)\\)。\r\n12.2-9\r\n简化题意后，对于叶节点\\(x\\)，其父节点\\(y\\)要么是\\(x\\)的前驱，要么是\\(x\\)的后继。\r\n\r\n当\\(x\\)是\\(y\\)的左子节点时，有\\(x&lt; y\\)。由于\\(x\\)没有右子树，因此\\(\\nexists v\\in T,x&lt; v &lt;\r\ny\\)成立，因此\\(y\\)是\\(x\\)的后继。\r\n当\\(x\\)是\\(y\\)的右子节点时，有\\(y&lt; x\\)。由于\\(x\\)没有左子树，因此\\(\\nexists v\\in T,y&lt; v &lt;\r\nx\\)成立，因此\\(y\\)是\\(x\\)的前驱。\r\n\r\n故原结论成立。\r\n","categories":["算法导论"]},{"title":"算法导论14.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-14/exercises-2/","content":"\r\n14.2-1\r\n假设这六个矩阵分别为\\(A_1,A_2,\\dots,A_6\\)，那么这\\(6\\)个矩阵的最优链乘方式为：\r\n\\[(A_1A_2)((A_3A_4)(A_5A_6))\\]\r\n仅需进行\\(2010\\)次乘法。\r\n14.2-2\r\nMATRIX-CHAIN-MULTIPLY(A, s, i, j)  if i == j    return A[i]  if i + 1 == j    return RECTANGULAR-MATRIX-MULTIPLY(A[i], A[j])  a = MATRIX-CHAIN-MULTIPLY(A, s, i, s[i, j])  b = MATRIX-CHAIN-MULTIPLY(A, s, s[i, j] + 1, j)  return RECTANGULAR-MATRIX-MULTIPLY(a, b)\r\n14.2-3\r\n假设\\(\\exists c\\ge 0,P(n)\\ge c\\cdot\r\n2^n\\)，那么有\r\n\\(\\begin{aligned}\r\nP(n)&amp;=\\sum_{k=1}^{n-1} P(k) \\cdot P(n-k)\\\\\r\n&amp;\\ge \\sum_{k=1}^{n-1} c2^k \\cdot c2^{n-k}\\\\\r\n&amp;=\\sum_{k=1}^{n-1} c^22^n\\\\\r\n&amp;=(n-1)c^2 2^n\\\\\r\n&amp;\\ge c\\cdot 2^n\r\n\\end{aligned}\\)\r\n因此有\\(P(n)=\\Omega(2^n)\\)。\r\n14.2-4\r\n将每个子问题视为图上的顶点：\\(\\forall 1\\le\r\ni\\le j\\le n,v_{i,j}\\)。那么这些顶点个数一共有\\(\\dfrac{n(n+1)}{2}\\)个。\r\n考虑所有节点\\(v_{i,j}\\)，那么有\r\n\r\n如果\\(i=j\\)，那么这时\\(v_{i,j}\\)没有出边，因为没有子问题。\r\n如果\\(i&lt; j\\)，那么这时\\(\\forall k,i\\le k&lt;\r\nj\\)，我们都需要解决子问题\\((i,k),(k+1,j)\\)时的情况，因此各有两条有向边：\\((v_{i,j},v_{i,k}),(v_{i,j},v_{k+1,j})\\)。\r\n\r\n最终，这个子问题图的边数为：\r\n\\[\\sum_{i=1}^n\\sum_{j=i}^n\r\n2(j-i)=\\dfrac{n^3-n}{3}\\]\r\n14.2-5\r\n由于这里是计算\\(R(i,j)\\)的总和次数，那么我们可以换另外一种角度思考：计算\\(m[i&#39;,j&#39;]\\)时，有多少个其它表项被访问过，可以设其为\\(S(i&#39;,j&#39;)\\)？\r\n如果计算\\(m[a,b]\\)时访问了表项\\(m[c,d]\\)，那么这次访问为\\(R(c,d)\\)贡献了\\(1\\)，为\\(S(a,b)\\)也贡献了\\(1\\)，两者是对等的。因此有\r\n\\[\\sum_{i=1}^n\\sum_{j=i}^n\r\nR(i,j)=\\sum_{i&#39;=1}^n\\sum_{j&#39;=i&#39;}^n\r\nS(i&#39;,j&#39;)\\]\r\n简化了问题后，摘录MATRIX-CHAIN-ORDER的代码，可以看到只有在第\\(9\\)行访问了两次非m[i, j]的元素：m[i, k], m[k + 1,]。\r\nMATRIX-CHAIN-ORDER(p, n)  let m[1 : n, 1 : n] and s[1 : n − 1, 2 : n] be new tables  for i = 1 to n // chain length 1    m[i, i] = 0  for l = 2 to n // l is the chain length    for i = 1 to n − l + 1 // chain begins at Ai      j = i + l − 1 // chain ends at Aj      m[i, j] = ∞      for k = i to j − 1 // try Ai:kAk+1:j        q = m[i, k] + m[k + 1, j] + pi−1pk pj        if q &lt; m[i, j]        m[i, j] = q // remember this cost        s[i, j] = k // remember this index  return m and s\r\n因此，有\r\n\\(\\begin{aligned}\r\n\\sum_{i=1}^n\\sum_{j=i}^n\r\nR(i,j)&amp;=\\sum_{i&#39;=1}^n\\sum_{j&#39;=i&#39;}^n S(i&#39;,j&#39;)\\\\\r\n&amp;=\\sum_{l=2}^n\\sum_{i=1}^{n-l+1} 2\\cdot((i+l-1)-1-i+1)\\\\\r\n&amp;=\\sum_{l=2}^n\\sum_{i=1}^{n-l+1} 2(l-1)\\\\\r\n&amp;=\\sum_{l=2}^n(n-l+1)\\cdot 2(l-1)\\\\\r\n&amp;=\\dfrac{n^3-n}{3}\r\n\\end{aligned}\\)\r\n14.2-6\r\n考虑使用归纳法证明。\r\n\r\n当\\(n=1\\)时，不需要括号来对表达式进行括号化，原结论成立。\r\n当\\(n=2\\)时，仅需要一对括号才能将表达式\\(A_1A_2\\)完全括号化，得到\\((A_1A_2)\\)。\r\n当\\(n&gt;2\\)时，假设对于\\(k=1,2,\\dots,n-1\\)均成立。那么我们可以将元素表达式\\(A_1,A_2,A_3,\\dots,A_{n-1},A_n\\)分成两个不为空的表达式：\\(A_1A_2,\\dots,A_k\\)和\\(A_{k+1},A_{k+2},\\dots,A_n\\)。那么按照假设，前一部分需要\\(k-1\\)个括号，后一部分需要\\(n-k-1\\)个括号。那么接下来再将这两部分元素进行括号化，仍然需要一个括号。因此最终需要\\((k-1)+(n-k-1)+1=n-1\\)个括号。\r\n\r\n因此，原结论成立。\r\n","categories":["算法导论"]},{"title":"算法导论12.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-12/exercises-3/","content":"\r\n12.3-1\r\n该过程由算法TREE-INSERT-RECURSIVE给出。\r\nINSERT-RECURSIVE(x, p, z)  if x == NIL    z.p = p    if z.key &lt; p.key      p.left = z    else      p.right = z  else if z.key &lt; x.key    INSERT-RECURSIVE(x.left, x, z)  else    INSERT-RECURSIVE(x.right, x, z)TREE-INSERT-RECURSIVE(T, z)  if T.root == NIL    T.root = z  else INSERT-RECURSIVE(T.root, NIL, z)\r\n12.3-2\r\nITERATIVE-TREE-SEARCH(x, k)  while x ≠ NIL and k ≠ x.key    if k &lt; x.key      x = x.left    else x = x.right  return xTREE-INSERT(T, z)  x = T.root // node being compared with z  y = NIL // y will be parent of z  while x ≠ NIL // descend until reaching a leaf    y = x    if z.key &lt; x.key      x = x.left    else x = x.right  z.p = y // found the location—insert z with parent y  if y == NIL    T.root = z // tree T was empty  elseif z.key &lt; y.key    y.left = z  else y.right = z\r\n对比算法ITERATIVE-TREE-SEARCH和TREE-INSERT，可以发现while循环完全一致。原因也很简单：插入和查询节点时，遍历二叉搜索树的路径基本相同，区别仅在于查询路径比插入路径多了一个节点\\(k\\)，也就是自身。因此查询节点的次数比插入时多了\\(1\\)。\r\n12.3-3\r\n最好情况：\\(n\\)个节点构成的树足够平衡，此时所有节点的高度都不超过\\(O(\\lg\r\nn)\\)。因此在这种情况下，这个排序算法的时间复杂度为\\(n\\cdot O(\\lg n)=O(n\\lg n)\\)。\r\n最坏情况：\\(n\\)个数有序插入，此时整棵树仅通过左子节点（或右子节点）串联成一棵高度为\\(n\\)的树。第\\(i\\)个节点需要遍历\\(i-1\\)个节点才能插入，那么整个排序算法总共需要遍历\\(\\dfrac{n(n-1)}{2}\\)次的节点，这种情况下的排序算法的时间复杂度为\\(\\Theta(n^2)\\)。\r\n12.3-4\r\n\r\n当\\(z\\)是一个叶子节点的时候，算法TREE-DELETE的第2行的第3个参数z.right为NIL。\r\n当\\(z\\)有右子节点，并且\\(z\\)的后继\\(y\\)不是\\(z\\)的右子节点时，如果\\(y\\)没有右子节点，算法TREE-DELETE的第7行的第3个参数y.right为NIL。\r\n\r\n12.3-5\r\n不正确，考虑如下二叉搜索树删除\\(1,2\\)的区别。\r\n\r\n最终得到的二叉树形态并不一样，因此这个说法是错误的。原因在于前4行代码，如果其中删除的节点的其中1个儿子为空，那么直接将另一个子树移到这个节点上，而不会再去找将要删除节点的后继。\r\n12.3-6\r\n算法PARENT的代码和插入INSERT非常相似，只是由判断空指针变成了判断是否当前键。\r\nPARENT(T, z)  x = T.root  y = NIL  while x != NIL and x.key != z.key    y = x    if z.key &lt; x.key      x = x.left    else      x = x.right  if x == NIL    return NIL  return yINSERT(T, z)  x = T.root  y = NIL  // pre是z的前驱节点。由于z是叶子节点，因此z的前驱必定在从根节点r到z的路径上。  pre = NIL  while x != NIL    y = x    if z.key &lt; x.key      x = x.left    else      pre = x      x = x.right  if y == NIL    T.root = z  else if z.key &lt; y.key    y.left = z    // z是叶子节点，没有右孩子，因此其后继就是y。    z.succ = y    if pre != NIL      pre.succ = z  else    y.right = z    z.succ = y.succ    y.succ = zTRANSPLANT&#x27;(T, u, v)  p = PARENT(T, u)  if p == NIL      T.root = v  else if u == p.left      p.left = v  else      p.right = v  // 相比于TRANSPLANT，算法TRANSPLANT&#x27;不再考虑父节点指针的指向。//此为求取z的前驱节点的算法。PREDECESSOR(T, z)  if z.left != NIL    return TREE-MAXIMUM(x.left)  x = T.root  // 此时前驱节点pre必定在从根节点r到z的路径上。  pre = NIL  while x != NIL and x.key != z.key    if z.key &lt; x.key      x = x.left    else      pre = x      x = x.right  return preDELETE(T, z)  pre = PREDECESSOR(T, z)  if pre != NIL    pre.succ = z.succ  if z.left == NIL    TRANSPLANT(T, z, z.right)  else if z.right == NIL    TRANSPLANT(T, z, z.left)  else    y = TREE-MIMIMUM(z.right)    if PARENT(T, y) != z.right      TRANSPLANT(T, y, y.right)      y.right = z.right    TRANSPLANT(T, z, y)    y.left = z.left    \r\n12.3-6\r\n这种新的删除算法由TREE-DELETE'给出，对它的修改仅仅是第6行求\\(z\\)的后继变成了求\\(z\\)的前驱，并且子节点指针都从left改成right，right改成left。\r\n为了保证这种前驱和后继地位的平等性，可以考虑使用随机算法。每次执行删除一个节点\\(z\\)，如果\\(z\\)有两个子节点，那么随机选择前驱或者是后继来覆盖当前节点。更形象的，这个算法由TREE-DELETE-FAIR给出。\r\nTREE-DELETE&#x27;(T, z)  if z.left == NIL    TRANSPLANT(T, z, z.right)   else if z.right == NIL    TRANSPLANT(T, z, z.left)  else     y = TREE-MAXIMUM(z.left)    if y ≠ z.left      TRANSPLANT(T, y, y.left)      y.left = z.left      y.left.p = y    TRANSPLANT(T, z, y)    y.right = z.right    y.right.p = yTREE-DELETE-FAIR(T, z)  r = RANDOM(0, 1)  if r == 0    TREE-DELETE&#x27;(T, z)  else    TREE-DELETE(T, z)\r\n","categories":["算法导论"]},{"title":"算法导论12 Problems 答案","url":"/introduction-to-algorithms/chapter-12/problems/","content":"\r\n12-1\r\na\r\n根据算法TREE-INSERT可知，每个相同的键都将会查到当前最深子节点的右儿子，因此第\\(i\\)次插入需要遍历\\(i-1\\)个节点。整个过程总共需要遍历\\(\\dfrac{n(n-1)}{2}\\)次的节点，这种情况下总运行时间为\\(\\Theta(n^2)\\)。\r\nb\r\n对于树中任意一个节点，每次插入一个新节点时，选择向左传递和向右传递这个节点是交替的，因此对于任意一个节点而言，左子树比右子树的大小至多大\\(1\\)，这确保了整棵树的高度为\\(\\lg n\\)，最终总插入时间为\\(O(n\\lg n)\\)。\r\nc\r\n所有相同键的节点都汇集到一个超级节点\\(x\\)中，整个插入过程最多只需要遍历一个节点，因此每次插入时只需要花费\\(O(1)\\)的时间，总时间为\\(O(n)\\)。\r\nd\r\n在最坏情况下，每一次插入都随机选择到同一侧的子节点，此时总时间复杂度将会达到\\(O(n^2)\\)。\r\n在平均情况下，每一个节点的左右子节点都有同样的选择机会，最终整棵树的期望高度为\\(\\lg n\\)，总插入时间为\\(O(n\\lg n)\\)。\r\n12-2\r\n假设每个节点都有\\(3\\)个属性：左子节点left，右子节点right，以及从根节点到当前节点路径所代表的字符串的个数count。\r\n这个基数树本质上可以看成是一个只有\\(2\\)个字符的字典树，并且整个排序过程视为是在字典树上进行遍历。\r\nINSERT-TRIE(T, s)  if T.root == NIL    let T.root be a new node  p = T.root  for i = 1 to s.size    if s[i] == &#x27;0&#x27;      if p.left == NIL        let p.left be a new node      p = p.left    else      if p.left == NIL        let p.right be a new node      p = p.right  p.count = p.count + 1INORDER-TREE-WALK-SORT(p, B, S)  if p == NIL    return  // 第2种情况：如果一个字符串s是另外一个字符串的前缀s&#x27;，那么s会比s&#x27;更先插入到B中，因为s所代表的节点深度更浅。  for i = 1 to p.count    parse S into a string and insert it in B  // 第1种情况：由于先进入左节点，因此可以满足第1种情况的比较。  PUSH(S, &#x27;0&#x27;)  INORDER-TREE-WALK-SORT(p.left, B, S)  POP(S, &#x27;0&#x27;)  PUSH(S, &#x27;1&#x27;)  INORDER-TREE-WALK-SORT(p.right, B, S)  POP(S, &#x27;1&#x27;)// 字符串数组ASORT-BY-RADIX-TRIE(A)  let T be a new tree  // 在基数树中插入每个字符串。  for each s in A    INSERT-TRIE(T, s)  let B be a new array  let S be a new STACK  INORDER-TREE-WALK-SORT(T.root, B, S)  return B\r\n插入单个字符串的算法INSERT-TRIE的时间复杂度为\\(|s|\\)，因为for循环无非就是遍历了整个字符串，而其它新建节点的操作可以视为是\\(O(1)\\)的操作，因此所有操作的运行时间之和为\\(O(n)\\)。\r\n假设基数树为\\(T\\)，那么按照插入算法的第7,\r\n11行可以发现节点数\\(|T|\\)必定满足\\(|T|&lt; n\\)，遍历树\\(T\\)的时间复杂度为\\(O(|T|)\\)。第3行将栈转化为字符串的操作为\\(O(n)\\)。最终时间复杂度为\\(O(|T|)+O(n)=O(n)\\)。\r\n整个过程的时间复杂度为\\(O(n)\\)。由于输入规模为\\(n\\)，因此整个过程的时间复杂度也满足\\(\\Omega(n)\\)，最终为\\(\\Theta(n)\\)。\r\n12-3\r\na\r\n所有节点的深度的平均值为它们节点之和与节点数的商，即\\(\\displaystyle{\\dfrac{1}{n}\\sum_{v\\in\r\nV}d(x,T)=\\dfrac{1}{n}P(T)}\\)。\r\nb\r\n左子树\\(T_L\\)内部节点的深度之和为\\(P(T_L)\\)，右子树\\(T_R\\)内部节点的深度之和为\\(T_R\\)。两棵子树使用一个根节点\\(r\\)连接后，\\(T\\)中所有非根节点的深度都增加了\\(1\\)；由于\\(T_L\\)和\\(T_R\\)一共有\\(n-1\\)个节点，因此最终有\r\n\\(\\begin{aligned}\r\nP(T)&amp;=\\sum_{x\\in T} d(x,T)\\\\\r\n&amp;=d(r,T)+\\sum_{x\\in T_L} d(x,T)+\\sum_{x\\in T_R}d(x,T)\\\\\r\n&amp;=0+\\sum_{x\\in T_L} (d(x,T_L)+1)+\\sum_{x\\in T_R}(d(x,T_R)+1)\\\\\r\n&amp;=\\sum_{x\\in T_L} d(x,T_L)+\\sum_{x\\in T_R}d(x,T_R)+n-1\\\\\r\n&amp;=P(T_L)+P(T_R)+n-1\r\n\\end{aligned}\\)\r\nc\r\n令树的集合\\(T_n\\)表示由\\(n!\\)个不同排列分别产生的\\(n!\\)个二叉搜索树。\r\n根据题目的定义，有\\(P(n)=E[P(T_n)]\\)。那么可以写出\r\n\\(\\begin{aligned}\r\nE[P(T_n)] &amp;= \\dfrac{1}{n!} \\sum_{T\\text{ have } n \\text{ nodes}}\r\nP(T)\\\\\r\n&amp;=\\dfrac{1}{n!} \\left(\\sum_{k=0}^{n-1}\\sum_{\\substack{T_L\\text{ have\r\n} k \\text{ nodes}\\\\T_R\\text{ have } n-k-1 \\text{ nodes}}} (P(T_L)\r\n+P(T_R)+n-1)\\right)\\\\\r\n&amp;=\\dfrac{1}{n!} \\left(\\sum_{k=0}^{n-1}\\sum_{\\substack{T_L\\text{ have\r\n} k \\text{ nodes}\\\\T_R\\text{ have } n-k-1 \\text{ nodes}}} P(T_L)\r\n+P(T_R)\\right) +n-1\\\\\r\n&amp;=\\dfrac{1}{n!} \\left(\\sum_{k=0}^{n-1}(n-k-1)!\\cdot\\sum_{T_L\\text{\r\nhave } k \\text{ nodes}}P(T_L)+k!\\cdot\\sum_{T_R\\text{ have } n-k-1 \\text{\r\nnodes}}P(T_R)\\right)+n-1\\\\\r\n&amp;=\\dfrac{1}{n!}\r\n\\left(\\sum_{k=0}^{n-1}(n-1)!\\cdot\\dfrac{1}{k!}\\cdot\\sum_{T_L\\text{ have\r\n} k \\text{\r\nnodes}}P(T_L)+(n-1)!\\cdot\\dfrac{1}{(n-k-1)!}\\cdot\\sum_{T_R\\text{ have }\r\nn-k-1 \\text{ nodes}}P(T_R)\\right)+n-1\\\\\r\n&amp;=\\dfrac{1}{n!} \\left(\\sum_{k=0}^{n-1}(n-1)!\\cdot\r\nE[T_{k}]+(n-1)!\\cdot E[T_{n-k-1}]\\right)+n-1\\\\\r\n&amp;=\\dfrac{1}{n} \\left(\\sum_{k=0}^{n-1}P(k)+P(n-k-1)\\right)+n-1\\\\\r\n&amp;=\\dfrac{1}{n} (\\sum_{k=0}^{n-1}P(k)+P(n-k-1)+n-1)\r\n\\end{aligned}\\)\r\nd\r\n\\(\\begin{aligned}\r\nP(n)&amp;=\\dfrac{1}{n}\\sum_{i=0}^{n-1}(P(i)+P(n-i-1)+n-1)\\\\\r\n&amp;=\\dfrac{1}{n}\\sum_{i=0}^{n-1}(P(i)+P(n-i-1))+n-1\\\\\r\n&amp;=\\dfrac{1}{n}\\sum_{i=0}^{n-1}P(i)+\\dfrac{1}{n}\\sum_{i=0}^{n-1}P(n-i-1)+n-1\\\\\r\n&amp;=\\dfrac{2}{n}\\sum_{i=0}^{n-1}P(i)+n-1\\\\\r\n&amp;=\\dfrac{2}{n}\\sum_{i=0}^{n-1}P(i)+\\Theta(n)\\\\\r\n&amp;=\\dfrac{2}{n}\\sum_{i=1}^{n-1}P(i)+\\Theta(n)&amp;\\qquad(A)\\\\\r\n\\end{aligned}\\)\r\n步骤\\((A)\\)应用了\\(P(0)=0\\)，即一棵空树的高度为\\(0\\)。\r\ne\r\n根据题目12-3-d导出的关于\\(P(n)\\)的递推式，发现和题目7-3-c导出的关于\\(T(n)\\)的递推式完全相同。因此根据题目7-3-e的结论，有\\(P(n)=O(n\\lg n)\\)。\r\nf\r\n可以发现，第一个元素是插入到空树的根当中，往后的所有元素都将会和当前这个元素进行比较。因此在这个新的快速排序算法中，我们选择第一个元素作为支点，这个元素同样将会和数组中的所有元素进行比较。为了确保递归后的比较次数和插入二叉树的比较次数相同，划分后的数组必须保证这一次划分过后，除了支点，其它比支点小的数和比支点大的数相对顺序不变。保证下一次的递归过程是正确的。这个算法由QUICKSORT-EQ-BST给出。\r\nQUICKSORT-EQ-BST(A, p, r)  x = A[p]  let B be new array  for j = p + 1 to r    if A[j] &lt; x      i = i + 1      A[j] = A[i]    else      INSERT(B, A[j])  i = i + 1  j = i  A[i] = x  for each x in B    i = i + 1    A[i] = x  QUICKSORT-EQ-BST(A, p, j - 1)  QUICKSORT-EQ-BST(A, j + 1, r)\r\n12-4\r\na\r\n考虑使用动态规划的思想进行思考。\r\n对于当前一棵\\(n\\)个节点的二叉树，如果左子树有\\(k\\)个节点，那么右子树有\\(n-1-k\\)个节点。并且左子树的形状和右子树的形状无关。因此，如果左子树有\\(b_k\\)种形状，那么右子树有\\(b_{n-1-k}\\)种形状。此时整棵树有\\(b_kb_{n-1-k}\\)种形状。\r\n因此，枚举左子树的节点树\\(k\\)，有\\(\\displaystyle{b_n=\\sum_{k=0}^{n-1}\r\nb_kb_{n-k-1}}\\)。\r\nb\r\n\\(\\begin{aligned}\r\nxB(x)^2+1&amp;=x\\left(\\sum_{n=0}^{\\infty}b_nx^n\\right)^2 +1\\\\\r\n&amp;=x\\sum_{n=0}^{\\infty}x^n\\left(\\sum_{k=0}^nb_kb_{n-k}\\right) +1\\\\\r\n&amp;=\\sum_{n=0}^{\\infty}x^{n+1}\\left(\\sum_{k=0}^nb_kb_{n-k}\\right) +1\\\\\r\n&amp;=\\sum_{n=1}^{\\infty}x^{n}\\left(\\sum_{k=0}^{n-1}b_kb_{n-1-k}\\right)\r\n+1\\\\\r\n&amp;=\\sum_{n=1}^{\\infty}b_nx^{n} +b_0x^0\\\\\r\n&amp;=\\sum_{n=0}^{\\infty}b_nx^{n}\\\\\r\n&amp;=B(x)\r\n\\end{aligned}\\)\r\n将\\(xB(x)^2+1=B(x)\\)看成是关于\\(B(x)\\)的一元二次方程\\(xB(x)^2-B(x)+1=0\\)，可以解得\\(B(x)=\\dfrac{1\\pm\\sqrt{1-4x}}{2x}\\)，去掉正号后得到\\(B(x)=\\dfrac{1-\\sqrt{1-4x}}{2x}\\)。\r\nc\r\n令\\(f(x)=\\sqrt{1-4x}\\)。根据规律可以发现，\\(f^{(n)}(x)\\)的表达式可以写成：\r\n\\(\\begin{aligned}\r\nf^{(n)}(x) &amp;= -\\dfrac{1}{(1-4x)^{(2n-1)/2}}\\cdot(2\\times (1\\times\r\n2)\\times(3\\times 2)\\times\\dots\\times((2n-3)\\times 2))\\\\\r\n&amp;= -\\dfrac{1}{(1-4x)^{(2n-1)/2}}\\cdot 2^n\\cdot(1\\times\r\n3\\times\\dots\\times (2n-3))\\\\\r\n&amp;= -\\dfrac{1}{(1-4x)^{(2n-1)/2}}\\cdot\r\n2^n\\cdot\\dfrac{(2n-2)!}{2\\times 4\\times 6\\times \\dots\\times(2n-2)}\\\\\r\n&amp;= -\\dfrac{1}{(1-4x)^{(2n-1)/2}}\\cdot\\dfrac{2\\cdot(2n-2)!}{(n-1)!}\\\\\r\n\\end{aligned}\\)\r\n可以得知\\(f^{(n)}(0)=-\\dfrac{2\\cdot(2n-2)!}{(n-1)!}\\)。将\\(f(x)\\)在\\(x=0\\)处泰勒展开，可以写成\\(\\displaystyle{f(x)=1-\\sum_{n=1}^{\\infty}\\dfrac{2\\cdot(2n-2)!}{(n-1)!n!}x^n}\\)。将\\(B(x)\\)在\\(x=0\\)处代入\\(f(x)\\)的展开式，有\r\n\\(\\begin{aligned}\r\nB(x)&amp;=\\dfrac{1-f(x)}{2x}\\\\\r\n&amp;=\\dfrac{1}{2x}\r\n\\sum_{n=1}^{\\infty}\\dfrac{2\\cdot(2n-2)!}{(n-1)!n!}x^n\\\\\r\n&amp;=\\sum_{n=1}^{\\infty}\\dfrac{(2n-2)!}{(n-1)!n!}x^{n-1}\\\\\r\n&amp;=\\sum_{n=0}^{\\infty}\\dfrac{(2n)!}{n!(n+1)!}x^{n}\\\\\r\n&amp;=\\sum_{n=0}^{\\infty}\\dfrac{1}{n+1}\\dfrac{(2n)!}{n!n!}x^{n}\\\\\r\n&amp;=\\sum_{n=0}^{\\infty}\\dfrac{1}{n+1}\\dbinom{2n}{n}x^{n}\\\\\r\n\\end{aligned}\\)\r\n因此有\\(b_n=\\dfrac{1}{n+1}\\dbinom{2n}{n}\\)。\r\nd\r\n\\(\\begin{aligned}\r\nb_n&amp;=\\dfrac{1}{n+1}\\dbinom{2n}{n}\\\\\r\n&amp;=\\dfrac{1}{n+1}\\cdot \\dfrac{\\sqrt{4\\pi\r\nn}\\cdot\\left(\\dfrac{2n}{e}\\right)^{2n}\\cdot\\left(1+\\Theta\\left(\\dfrac{1}{n}\\right)\\right)}{\\left(\\sqrt{2\\pi\r\nn}\\cdot\\left(\\dfrac{n}{e}\\right)^{n}\\cdot\\left(1+\\Theta\\left(\\dfrac{1}{n}\\right)\\right)\\right)^2}\\\\\r\n&amp;=\\dfrac{1}{n+1}\\cdot\\dfrac{2\\sqrt{\\pi\r\nn}\\cdot\\left(2n\\right)^{2n}\\cdot\\dfrac{1}{e^{2n}}}{2\\pi n\\cdot\r\nn^{2n}\\cdot \\dfrac{1}{e^{2n}}}\r\n\\cdot\\left(1+\\Theta\\left(\\dfrac{1}{n}\\right)\\right)\\\\\r\n&amp;=\\dfrac{1}{n+1}\\cdot\\dfrac{2^{2n}}{\\sqrt{\\pi n}}\\cdot\r\n\\left(1+\\Theta\\left(\\dfrac{1}{n}\\right)\\right)\\\\\r\n&amp;=\\dfrac{1}{n+1}\\cdot \\dfrac{2^{2n}}{\\sqrt{\\pi n}}\\cdot\r\n\\left(1+O\\left(\\dfrac{1}{n}\\right)\\right)\\\\\r\n&amp;=\\dfrac{1}{n}\\cdot \\dfrac{2^{2n}}{\\sqrt{\\pi n}}\\cdot\r\n\\left(1+O\\left(\\dfrac{1}{n}\\right)\\right)\\\\\r\n&amp;=\\dfrac{4^{n}}{\\sqrt{\\pi}n^{3/2}}\\cdot\r\n\\left(1+O\\left(\\dfrac{1}{n}\\right)\\right)\r\n\\end{aligned}\\)\r\n","categories":["算法导论"]},{"title":"算法导论16.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-16/exercises-1/","content":"\r\n16.1-1\r\n相比于MULTIPOP操作，MULTIPUSH操作总是需要遍历完\\(k\\)个元素进行插入，它不能像MULTIPOP那样及时终止循环。总共插入的元素个数在\\(n\\)个操作以内可以达到\\(\\omega(n)\\)的数量（如果\\(k=\\omega(n)\\)），因此摊分下来的花费不能达到\\(O(1)\\)。\r\n16.1-2\r\n在最坏情况下，如果计数器的低\\(k-1\\)个比特全\\(0\\)，最高位比特为\\(1\\)，并且\\(k\\)个操作按照DECREMENT,\r\nINCREMENT, DECREMENT, …\r\n的操作交替执行，那么每一次操作都会使得全部比特翻转，此时总运行时间恰好为\\(\\Theta(nk)\\)。\r\n16.1-3\r\n令\\(T(n)\\)表示这\\(n\\)次操作之和，那么分开考虑\\(i\\)是\\(2\\)的幂和\\(i\\)不是\\(2\\)的幂这两项，有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=\\sum_{i=0}^{\\lfloor\\lg n\\rfloor} 2^i +\\sum_{1\\le i\\le\r\nn,\\nexists k\\in \\mathbb{Z} \\text{ s.t. }2^k=1} 1\\\\\r\n&amp;=2^{\\lfloor\\lg n\\rfloor+1} -1+\\sum_{1\\le i\\le n,\\nexists k\\in\r\n\\mathbb{Z} \\text{ s.t. }2^k=1} 1\\\\\r\n&amp;\\le 2^{\\lg n+1}-1+\\sum_{i=1}^n 1\\\\\r\n&amp;=2n-1+n\\\\\r\n&amp;\\le 3n\r\n\\end{aligned}\\)\r\n因此有\\(T(n)=O(n)\\)，平均每次操作的时间复杂度为\\(\\dfrac{T(n)}{n}=O(1)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论16.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-16/exercises-2/","content":"\r\n16.2-1\r\n执行PUSH操作时，需要花费\\(1\\)美元，此外还要额外预支\\(1\\)美元，这\\(1\\)美元是为后续的复制操作中充当信用。执行POP操作时，同样需要花费\\(1\\)美元，同样的，需要额外\\(1\\)美元为后面的复制操作充当信用。当真正执行复制操作时，PUSH和POP已经总共执行了\\(k\\)次元素，累积了\\(k\\)美元的预支，由于元素最多不超过\\(k\\)个，因此复制操作所需要的代价不超过\\(k\\)，所累积的信用足够支撑这次操作。因此，总共需要最多\\(2n\\)美元就能够完成这\\(n\\)次操作，因此每次操作的平均时间复杂度为\\(O(1)\\)。\r\n16.2-2\r\n令实际代价\\(c_i\\)为\r\n\\(c_i=\r\n\\left \\{\\begin{aligned}\r\n  &amp;i &amp; &amp; \\text{if}\\quad  \\exists n\\in \\mathbb{N},i=2^n \\\\\r\n  &amp;1 &amp; &amp; \\text{otherwise}\r\n\\end{aligned}\\right.\\)\r\n这个时候的摊分策略是：每一次操作都需要支付\\(3\\)美元。也就是说，当\\(i\\)不是\\(2\\)的幂次的时候，还需要额外多支付\\(2\\)美元。\r\n当\\(i=1\\)时，支付\\(3\\)美元足以支撑起这个操作，因为\\(c_1=1\\)；当\\(i=2^n\\)是一个\\(2\\)次幂时，我们证明\\(2^{n-1}+1\\sim\r\n2^n\\)中所有预支的代价总和可以支撑的起第\\(i\\)次实际操作的代价。\\(2^{n-1}+1\\sim 2^n-1\\)这一部分都给\\(i\\)预支了\\(2\\)美元，总共预支了\\((2\\cdot\r\n2^{n-1}-1)=2^n-2\\)美元；再加上当前\\(i=2^n\\)所给的\\(3\\)美元，一共有\\(2^n+1\\)美元，这些支付的金额之和支撑得起第\\(i\\)次操作。因此，这种摊分方式是正确的，即\\(\\forall i\\ge 1,\\widehat{c_i}=3\\)。\r\n那么，实际代价之和满足\\(\\displaystyle{T(n)=\\sum_{i=1}^n c_i\\le\r\n\\sum_{i=1}^n \\widehat{c_i} =\r\n3n}\\)。平均每次操作的时间复杂度为\\(\\dfrac{T(n)}{n}=O(1)\\)。\r\n16.2-3\r\nINCREMENT(A, k)  i = 0  while i &lt; k and A[i] == 1    A[i] = 0    i = i + 1  if i &lt; k    A[i] = 1    if i &gt; A.p      A.p = i  else    A.p = -1// 假设数组A还有一个对象p，用于保存最高位的位置。RESET(A)  for i = 0 to A.p    A[i] = 0  A.p = -1\r\n当执行INCREMENT时，只有循环结束时的一位才会发生从\\(0\\)变成\\(1\\)，这只会执行\\(1\\)次。这时将支付\\(1\\)美元。此外，也给这一位预支\\(1\\)美元，以保证此后这一位从\\(1\\)变成\\(0\\)；然后再多预支\\(1\\)美元，为将来执行RESET操作预支。此后执行INCREMENT时，某一位从\\(1\\)变成\\(0\\)不用支付任何开销。然后执行RESET时，之前预支过的每一位都将会设置成\\(0\\)。因此，所有操作的耗费总共不会超过\\(3n\\)美元，因此这\\(n\\)次操作的时间复杂度为\\(O(n)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论16.4 Exercises 答案","url":"/introduction-to-algorithms/chapter-16/exercises-4/","content":"\r\n16.4-1\r\n在本次操作中，实际代价\\(c_1=1\\)，因为实际上只开放并处理了\\(1\\)个位置。\r\n在第一个操作前，整个表都是空的，也没有位置存放，因此有\\(num_0=size_0=0\\)。\r\n当存入第\\(1\\)个元素后，程序为其开辟了一个空间并将元素存入，因此有\\(num_1=size_1=1\\)。\r\n根据方程16.4，可以给出\\(\\Phi_0=0,\\Phi_1=1\\)，故有\\(\\Delta \\Phi_1=\\Phi_1-\\Phi_0=1\\)。\r\n因此第一次插入的均摊代价为\\(\\widehat{c_1}=c_1+\\Delta\\Phi_1=2\\)。\r\n16.4-2\r\n因为定理和推论11.6-8说明，当装载因子\\(\\alpha\\)无限趋近于\\(1\\)时，无论是单次插入一个元素还是查找一个元素，它们的探测次数期望都趋向于无穷大，此时无法用一个常数来限定查找次数的期望。为此，设计哈希表时，如果装载元素的个数比率到达某个小于\\(1\\)的上限值时，就将哈希表进行扩张。\r\nTABLE-INSERT&#x27;(H, x)  if H.size == 0    allocate H.table with 1 slot    H.size = 1  // H.c是哈希表H装载因子的上限值，为一个常数。  if H.num &gt;= H.size * H.c    allocate new-table with 2 ⋅ H.size slots    insert all items in Table into new-table    free H.table    H.table = new-table    H.size = 2 · H.size  insert x into H.table  H.num = H.num + 1\r\n动态哈希表插入算法TABLE-INSERT'和动态变长数组插入算法TABLE-INSERT基本相同，均摊时间复杂度为\\(O(1)\\)。至于单次操作不一定是\\(O(1)\\)的原因是当第\\(2\\)个if满足时，算法将会为哈希表\\(H\\)开拓新的空间，并且将所有元素插入到新的哈希表中，此时单次操作的时间复杂度为线性。\r\n16.4-3\r\n当\\(\\alpha&lt;\\dfrac{1}{2}\\)时，\r\n\r\n如果进行插入操作，直接支付\\(1\\)美元用于插入，不需要预支；\r\n如果进行删除操作，那么支付\\(2\\)美元，其中\\(1\\)美元用于支付当前元素的删除，另\\(1\\)美元进行预支，用于第\\(size_i/2-num_i+1\\)个元素在收缩转移时的预支。如果引起了收缩，那么由于每个元素在之前都进行了\\(1\\)美元的预支，因此将它们进行转移并不需要额外支付代价。\r\n\r\n当\\(\\alpha\\ge\\dfrac{1}{2}\\)时，\r\n\r\n如果进行插入操作，那么支付\\(3\\)美元，其中\\(1\\)美元用于直接插入。剩下\\(2\\)美元进行预支，其中\\(1\\)美元用于当前元素在扩张转移时的预支，另外\\(1\\)美元用于第\\(num_i-size_i/2+1\\)个元素在扩张转移时的预支。如果引起了扩张，那么由于每个元素在之前都进行了\\(1\\)美元的预支，因此将它们进行转移并不需要额外支付代价。\r\n如果进行删除操作，直接支付\\(1\\)美元用于删除，不需要预支；\r\n\r\n由于所有操作中，每次支付的代价都不超过\\(3\\)美元，因每个操作均摊后的代价为\\(O(1)\\)。\r\n16.4-4\r\n分别进行\\(3\\)种情况的考虑，假设第\\(i\\)个操作为删除操作。\r\n\r\n当\\(\\alpha&gt;\\dfrac{1}{2}\\)时，\\(\\Phi_{i-1}=2num_{i-1}-size_{i-1},\\Phi_i=2(num_{i-1}-1)-size_i\\)。\r\n\r\n由于没有发生收缩操作，因此\\(size_i=size_{i-1},c_i=1\\)。最终有\r\n\\(\\begin{aligned}\r\n\\widehat{c_i}&amp;=c_i+\\Phi_i-\\Phi_{i-1}\\\\\r\n&amp;=1+(2(num_{i-1}-1)-size_i)-(2num_{i-1}-size_{i-1})\\\\\r\n&amp;=-1\r\n\\end{aligned}\\)\r\n\r\n当\\(\\dfrac{1}{3}&lt;\\alpha\\le\r\n\\dfrac{1}{2}\\)时，\\(\\Phi_{i-1}=size_{i-1}-2num_{i-1},\\Phi_i=size_i-2(num_{i-1}-1)\\)。\r\n\r\n由于没有发生收缩操作，因此\\(size_i=size_{i-1},c_i=1\\)。最终有\r\n\\(\\begin{aligned}\r\n\\widehat{c_i}&amp;=c_i+\\Phi_i-\\Phi_{i-1}\\\\\r\n&amp;=1+(size_i-2(num_{i-1}-1))-(size_{i-1}-2num_{i-1})\\\\\r\n&amp;=3\r\n\\end{aligned}\\)\r\n\r\n当\\(\\dfrac{1}{3}&lt;\\alpha\\le\r\n\\dfrac{1}{2}\\)时，\\(\\Phi_{i-1}=size_{i-1}-2num_{i-1},\\Phi_i=size_i-2(num_{i-1}-1)\\)。\r\n\r\n由于发生了收缩操作，因此\\(size_i=\\dfrac{2}{3}\\cdot\r\nsize_{i-1}\\)。这个过程复制了\\(\\dfrac{1}{3}\\cdot\r\nsize_{i-1}\\)个元素，因此\\(c_i=\\dfrac{1}{3}\\cdot\r\nsize_{i-1}\\)。最终有\r\n\\(\\begin{aligned}\r\n\\widehat{c_i}&amp;=c_i+\\Phi_i-\\Phi_{i-1}\\\\\r\n&amp;=c_i+(size_i-2(num_{i-1}-1))-(size_{i-1}-2num_{i-1})\\\\\r\n&amp;=c_i+size_i-size_{i-1}\\\\\r\n&amp;=\\dfrac{1}{3}\\cdot size_{i-1}+\\dfrac{2}{3}\\cdot\r\nsize_{i-1}-size_{i-1}+2\\\\\r\n&amp;=2\r\n\\end{aligned}\\)\r\n最终，无论哪种操作，它们的均摊代价最多不超过\\(3\\)，因此操作TABLE-DELETE的均摊代价有着常数上限。\r\n","categories":["算法导论"]},{"title":"算法导论15.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-15/exercises-1/","content":"\r\n15.1-1\r\n直接使用pre数组记录当下所有状态的转移过程。\r\n算法DYNAMIC-PROGRAMMING-ACTIVITY-SELECTOR使用了一个三重嵌套循环，其时间复杂度为\\(O(n^3)\\)，而\r\n算法GREEDY-ACTIVITY-SELECTOR的时间复杂度为\\(\\Theta(n)\\)。\r\nGEN-SOLUTION(pre, C, i, j)  if C[i, j] == 0    return ∅  else    return &#123;a_k&#125; ∪ GEN-SOLUTION(pre, C, i, k) ∪ GEN-SOLUTION(pre, C, k, j)DYNAMIC-PROGRAMMING-ACTIVITY-SELECTOR(s, f, n)  // pre 表示状态转移到何处。  let pre[0 : n + 1, 0 : n + 1] and c[0 : n + 1, 0 : n + 1] be new tablges  INSERT(s, +∞)  for i = 0 to n    c[i, i] = 0    c[i, i + 1] = 0  c[n + 1, n + 1] = 0  for l = 2 to n + 1    for i = 0 to n + 2 - l      j = i + l - 1        k = i + 1        while k &lt; j and f[k] &lt;= s[j]          if f[i] &lt;= s[k] and c[i, k] + c[k, j] + 1 &gt; c[i, j]            c[i, j] = c[i, k] + c[k, j] + 1            pre[i, j] = k           k = k + 1  return GEN-SOLUTION(pre, C, 0, n + 1)\r\n15.1-2\r\n假设现在关于活动的开始时间\\(s&#39;\\)和结束时间\\(t&#39;\\)是按照开始时间进行排序的。\r\n令\\(S&#39;_k=\\{a_i\\in S:s_i&#39;\\le\r\nf_k&#39;\\}\\)。考虑证明：如果\\(a&#39;_m\\)子问题是\\(S_k&#39;\\)中最晚开始的活动，那么必定存在一个最优解\\(A_k&#39;\\)，并且满足\\(a&#39;_m\\in A_k&#39;\\)。\r\n如果\\(a_m&#39;\\in\r\nA_k&#39;\\)，那么不证自明；否则令\\(a_n&#39;\\)是\\(A_k&#39;\\)中最晚开始的活动，那么有\\(s_n&#39;\\le s_m&#39;\\)。令\\(B_k&#39;=A_k&#39;-\\{a_n&#39;\\}\\cup\r\n\\{a_m&#39;\\}\\)，由于\\(a_n&#39;\\)和上一个活动不会产生交集，那么\\(a_m&#39;\\)也不会和上一个活动产生交集，因此\\(B_k&#39;\\)也是一个最优解。\r\n因此，每次选择最晚开始的活动，这种贪心策略也是成立的。\r\n15.1-3\r\n当\\(s=[1,8,10],f=[10,12,20]\\)时，可以知道这种贪心策略是不正确的。使用这种贪心策略只能选择第\\(2\\)个活动，即\\(\\{8,12\\}\\)，因为这个活动的时间最短。而使用正确的贪心策略则会选择第\\(1\\)和\\(3\\)个活动。\r\n15.1-4\r\n首先假设所有活动已经按结束时间排序好。基本的贪心思想是，在保证当前活动按时召开的情况下，选择一个当前最晚结束的厅，将当前活动接入到这个厅即可，并更新这个厅最晚的结束时间。如果实在找不到满足条件的厅，那么就新开一个。\r\nACTIVITY-ARRANGER(s, f, n)  let A be a new array  count = 0  // 使用一个二叉查找树T来存储三元组(f, hall)，分别代表编号为hall的厅中，最后一个活动的结束时间为f，这个二叉查找树将以f作为键。  let T be a new ordered-set  for i = 1 to n    // 找到最晚能够早于s[i]结束的一个厅。    get the greatest node x in T such that x.f &lt;= s[i]    // 找不到这样的厅，需要新开。    if x == NIL      INSERT(A, ∅)      count = count + 1      A[count] = A[count] ∪ &#123;a_i&#125;      let p be a new node, p.f = f[i], p.hall = count      INSERT(T, p)    else      DELETE(T, x)      A[x.hall] = A[x.hall] ∪ &#123;a_i&#125;      x.f = f[i]      INSERT(T, x)  return count, A\r\n15.1-5\r\n可以使用一个非常直接的动态规划算法来解决本问题。按照题目原本的要求，一个活动\\(i\\)可以接在一个活动\\(j\\)的后面当且仅当\\(f[j]\\le\r\ns[i]\\)。那么以当前活动作为最后一个活动，以此作为动态规划的阶段。令状态\\(g[i]\\)表示以\\(i\\)为最后一个活动时，这样的安排可以得到最大的活动权值之和。考虑能够接在活动\\(i\\)前面每一个活动\\(j\\)的情况，可以写出\\(g\\)的状态转移方程：\r\n\\(g[i]=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0 &amp; &amp; \\text{if}\\quad i=0 \\\\\r\n  &amp;\\max_{0\\le j&lt; i,f[j]\\le s[i]} \\{g[j]+v[i]\\} &amp; &amp;\r\n\\text{if}\\quad i\\neq 0\\\\\r\n\\end{aligned}\\right.\\)\r\n算法ACTIVITY-SELECTOR-VALUE'给出了具体的伪代码。由第6-8行的嵌套循环可知，这个算法的时间复杂度为\\(O(n^2)\\)。\r\n// a_0 = (0, 0, 0)，即第0个活动是没有价值的。ACTIVITY-SELECTOR-VALUE&#x27;(s, f, v, n)  // 已经假设所有活动按结束时间f进行排序。  let g[0 : n], pre[1 : n] be new arrays  g[0] = 0  // p是取得最大值的下标。  p = 0  for i = 1 to n    g[i] = 0    j = 0    while j &lt; i and f[j] &lt;= s[i]      if f[j] &lt;= s[i] and g[j] + v[i] &gt; g[i]         g[i] = g[j] + v[i]        pre[i] = j      j = j + 1    if g[i] &gt; g[p]      p = i  A = &#123;a_p&#125;  q = p  while pre[p] != 0    A = A ∪ &#123;A_pre[p]&#125;    p = pre[p]  return g[q], A\r\n","categories":["算法导论"]},{"title":"算法导论16.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-16/exercises-3/","content":"\r\n16.3-1\r\n构造\\(\\Phi&#39;(D_i)=\\Phi(D_i)-\\Phi(D_0)\\)。那么有\\(\\Phi&#39;(D_i)=0\\)。由于\\(\\forall i\\ge\r\n0,\\Phi(D_i)\\ge\\Phi(D_0)\\)均成立，因此\\(\\Phi&#39;(D_i)\\ge\r\n0=\\Phi&#39;(D_0)\\)均成立。\r\n使用\\(\\Phi\\)原来的方式计算摊分价值，有\r\n\\(\\begin{aligned}\r\n\\widehat{c_i} &amp;=  c_i +\\Phi(D_i)-\\Phi(D_{i-1})\\\\\r\n&amp;= c_i +(\\Phi(D_i)-\\Phi(D_0))-(\\Phi(D_{i-1})-\\Phi(D_0))\\\\\r\n&amp;= c_i +\\Phi&#39;(D_i)-\\Phi&#39;(D_{i-1})\\\\\r\n\\end{aligned}\\)\r\n因此构造出的\\(\\Phi&#39;\\)同样也可以正确地计算摊分费用。\r\n16.3-2\r\n按照如下方式构造势函数\\(\\Phi\\)：\r\n\\(\\Phi(D_i)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0 &amp; &amp; \\text{if}\\quad  i=0 \\\\\r\n  &amp;\\lfloor\\lg i\\rfloor+3+2(i-2^{\\lfloor\\lg i\\rfloor}) &amp; &amp;\r\n\\text{otherwise}\r\n\\end{aligned}\\right.\\)\r\n不难证明\\(\\Phi(D_i)\\ge\r\n0\\)恒成立。\r\n考虑如下两种情况：\r\n\r\n当\\(\\nexists n\\in\r\n\\mathbb{N},i=2^n\\)时，\\(\\Phi(D_i)-\\Phi(D_{i-1})=2\\)。\r\n当\\(\\exists n\\in\r\n\\mathbb{N},i=2^n\\)时，\\(\\Phi(D_i)-\\Phi(D_{i-1})=(n+3)-(n+2+2(i-1-i/2))=3-i\\)。\r\n\r\n无论哪种情况，都有\\(\\widehat{c_i}=c_i+\\Phi(D_i)-\\Phi(D_{i-1})=3\\)。\r\n最终有实际代价之和\\(\\displaystyle{T(n)=\\sum_{i=1}^n c_i=\\sum_{i=1}^n\r\n\\widehat{c_i}-\\Phi(D_n)+\\Phi(D_0)=\\sum_{i=1}^n 3-\\Phi(D_n)+0\\le\r\n3n}\\)。平均每次操作的时间复杂度为\\(\\dfrac{T(n)}{n}=O(1)\\)。\r\n16.3-3\r\n堆的EXTRACT-MIN操作分成两个步骤：\r\n\r\n弹出一个元素，这个操作的时间为\\(O(1)\\)。\r\n将堆中最后一个元素放置堆顶，然后将这个元素向下移动，这个操作需要\\(O(\\lg\r\nn)\\)的时间。假设这个过程的时间上限为\\(c\\lg n\\)，那么\\(c_i-O(1)\\le c\\lg n\\)。\r\n\r\n令势函数\\(\\Phi(D_m)\\)为\r\n\\[\\Phi(D_m)=\\sum_{i=1}^n c\\lg\r\ni\\]\r\n其中\\(n\\)是数据结构\\(D_m\\)的元素个数。\r\n对于一个INSERT操作，有\\(\\widehat{c_i}=c_i+\\Phi(D_i)-\\Phi(D_{i-1})=c_i+c\\lg\r\nn\\)。由于INSERT操作的实际花费\\(c_i=O(\\lg n)\\)，因此摊分后的代价仍然为\\(O(\\lg n)\\)。\r\n对于一个POP操作，有\\(\\widehat{c_i}=c_i+\\Phi(D_i)-\\Phi(D_{i-1})=c_i-c\\lg\r\nn=O(1)\\)。\r\n16.3-4\r\n根据本节正文，势函数\\(\\Phi(D_i)\\)的定义为栈中元素的个数。所有操作的实际代价之和为\\(\\displaystyle{T(n)=\\sum_{i=1}^n c_i=\\sum_{i=1}^n\r\n\\widehat{c_i}-\\Phi(D_n)+\\Phi(D_0)}\\)。令\\(\\Phi(D_n)=s_n,\\Phi(D_0)=s_0\\)，那么有\\(T(n)\\le\r\n2n-s_n+s_0\\)。因此在这个情况下，所有操作的运行时间之和为\\(O(n-s_n+s_0)\\)。\r\n16.3-5\r\n实现方式和练习10.1-7完全一致：\r\n假设有两个栈S1, S2，那么支持队列的两个操作如下进行：\r\n\r\nENQUEUE\r\n直接将元素推入栈S2中。此操作时间复杂度为\\(\\Theta(1)\\)。\r\nDEQUEUE\r\n将S1栈顶的元素弹出并返回即可。如果S1为空，那么弹出S2中的所有元素，一边弹出，一边将元素推入到S1中，再将元素弹出并返回。这种操作绝大多数时间下都是\\(O(1)\\)，如果栈S2过于庞大，那么时间开销就是S2的长度。\r\n\r\n// Q.S1和Q.S2表示队列Q内部的两个栈。ENQUEUE(Q, x)  PUSH(Q.S2, x)DEQUEUE(Q)  if STACK-EMPTY(Q.S1)    while not STACK-EMPTY(Q.S2)      x = POP(Q.S2)      PUSH(Q.S1, x)  x = POP(Q.S1)  return x\r\n此处使用核算法来说明整个过程。对于每个进入队列的元素\\(x\\)，一共需要花费\\(3\\)美元。\\(1\\)美元代表着入栈Q.S2操作；剩下的\\(2\\)美元用于预支之后的出队操作：\\(1\\)美元用于将元素从栈Q.S2转移到Q.S1，\\(1\\)美元用于将元素从栈Q.S1弹出。\r\n因此，所有操作支付的代价之和为\\(3n\\)美元，所有ENQUEUE和DEQUEUE操作的平均代价为\\(\\dfrac{O(n)}{n}=O(1)\\)。\r\n16.3-6\r\n算法DELETE-LARGER-HALF的基本实现思路是，使用算法RANDOMIZED-SELECT以\\(O(n)\\)的时间求出第\\(\\lceil n/2\\rceil\\)数\\(x\\)后，这个数右边的所有数都将比\\(x\\)大，将这些数全部返回并从\\(S\\)中删除即可。\r\n由于算法RANDOMIZED-SELECT的时间复杂度为\\(O(n)\\)，那么算法RANDOMIZED-SELECT的运行时间也是\\(O(n)\\)，假设其一次运行时间上界为\\(cn\\)。这里使用记账法来证明。假设将\\(x\\)插入\\(S\\)后，\\(S\\)中目前有\\(m\\)个元素，那么对第\\(m\\)个元素记账\\(2c+1\\)美元，其中\\(1\\)美元是插入所需要的代价，而\\(2c\\)美元是预支，用于DELETE-LARGER-HALF算法。由于每调用一次DELETE-LARGER-HALF后，\\(S\\)中的每一个元素都以\\(c\\)的代价被遍历，然后有一半的元素被排除出去，因此每个元素预支\\(2c\\)恰好能弥补某些元素被多次遍历的亏损。\r\n最终，所有操作的代价之和不超过\\((2c+1)n\\)美元，因此平均到每个操作后，它们的时间复杂度为\\(O(1)\\)。\r\n//将S视为一个数组，INSERT(S, x)算法可以简单地将x插入到S的最后一个元素。DELETE-LARGER-HALF(S)  n = S.size  p = RANDOMIZED-SELECT(S, 1, n, ⌈n / 2⌉)  B = S[p : n]  remove S[p : n] from S  return BPRINT(S)  for each u in S    print u\r\n","categories":["算法导论"]},{"title":"算法导论15.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-15/exercises-2/","content":"\r\n15.2-1\r\n令\\(m\\)为当前满足\\(\\dfrac{v_m}{w_m}\\)最大的物品编号，假设存在一个最优解其解向量\\(x\\)满足如下条件：\\(\\exists j,1\\le j\\le n,j\\neq\r\nm\\)，并且有\\(x_j&gt;0\\land x_m&lt;\r\nw_j\\)，那么构造一个新的解向量\\(x&#39;\\)，其中\\(x_m&#39;=x_m+\\min\\{x_j,w_m-x_m\\},x_j&#39;=x_j-\\min\\{x_j,w_m-x_m\\}\\)，那么解\\(x\\)相对解\\(x&#39;\\)所增加的价值为\r\n\\(\\begin{aligned}\r\n\\Delta &amp;=\r\n(x_m&#39;-x_m)\\cdot\\dfrac{v_m}{w_m}+(x_j&#39;-x_j)\\cdot\\dfrac{v_j}{w_j}\\\\\r\n&amp;=\\min\\{x_j,w_m-x_m\\}\\cdot\\left(\\dfrac{v_m}{w_m}-\\dfrac{v_j}{w_j}\\right)\\\\\r\n&amp;&gt;0\r\n\\end{aligned}\\)\r\n那么由\\(x&#39;\\)构造出了一个更优的解\\(x\\)，因此这个问题满足贪心选择性质。\r\n15.2-2\r\n令状态\\(f[i, j]\\)表示前\\(i\\)个物品至多重量和为\\(j\\)时，最大的总价值。对于当前状态，第\\(i\\)个物品有两种决策：取或者是不取。如果不取，那么相当于从状态\\(f[i-1,j]\\)转移而来；如果取，那么相当于从\\(f[i-1,j-w_i]\\)处取一个物品\\(i\\)转移而来，并且从中择优转移。因此不难写出如下状态转移方程：\r\n\\(f[i,j]=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0  &amp; &amp; \\text{if}\\quad i=0 \\\\\r\n  &amp;f[i-1,j]&amp; &amp; \\text{if} \\quad i&gt;0 \\land j&lt; w_i\\\\\r\n  &amp;\\max\\{f[i-1,j],f[i-1,j-w_i]+v_i\\}&amp; &amp; \\text{if} \\quad\r\ni&gt;0 \\land j\\ge w_i\\\\\r\n\\end{aligned}\\right.\\)\r\n因此最终答案为\\(f[n,W]\\)。\r\n算法0-1-KNAPSACK-PROBLEM给出了具体的实现过程。第2-3行的嵌套循环说明这个算法的时间复杂度为\\(O(n\\cdot W)\\)。\r\n0-1-KNAPSACK-PROBLEM(w, v, n, W)  let f[0 : W] be a new array by 0  for i = 1 to n    for j = W down to w[i]      f[j] = max&#123;f[j], f[j - w[i]] + v[i]&#125;  return f[W]\r\n15.2-3\r\n直接贪心选择价值最大的物品即可，算法0-1-KNAPSACK-PROBLEM'给出了具体的过程。\r\n证明，假设一个解\\(S\\)包含了物品\\((w_j,v_j)\\)，并且不包含物品\\((w_i,v_i)(i&lt; j)\\)，那么构造一组解\\(S&#39;=S-\\{(w_j,v_j)\\}\\cup\r\n\\{(w_i,v_i)\\}\\)。可以发现这个解的价值比\\(S\\)更大，因为价值增加了\\(v_i-v_j\\)，而且重量还减少了 \\(w_j-w_i\\)，这说明这个解更优，并且仍然是满足条件的。\r\n由此，这个贪心算法是成立的。\r\n// 假设物品已经按照重量从小到大排序，此时价值是从大到小排序的。0-1-KNAPSACK-PROBLEM&#x27;(w, v, n, W)  f = 0  for i = 1 to n    if w[i] &gt; W      break    W = W - w[i]    f = f + v[i]  return f\r\n15.2-4\r\n假设整条路的情况用一个长度为\\(n+1\\)的数组\\(X\\)表示。道路上有\\(n\\)个补给点以及起点和终点，\\(X[1]\\)表示起点和下一个补给点的距离，\\(X[n +\r\n1]\\)表示终点和最后一个补给点的距离，其余\\(n-1\\)个元素表示\\(n-1\\)对元素间的距离。\r\n这道题使用的贪心思想是：尝试尽量到达下一个补给点（或者是终点），直到发现以当前水量不足以达下一个点了，才开始装水。\r\n当选定好一个补给点\\(p\\)后，接下来的所有路可以视为一个同样的子问题。令子问题表示\\(S_i=X[i:n+1]\\)，那么原问题为\\(S_1\\)。\r\n假设问题\\(S_1\\)的一个最优解为选择补给点\\(T=\\{x_1,x_2,x_3,\\dots,x_m\\}\\)，按顺序列出，并且距离起点最远不超过\\(m\\)的补给点为\\(y_1\\)，并且有\\(x_1&lt;\r\ny_1\\)。那么考虑证明可以构造出一个最优解，使得\\(y_1\\)是第\\(1\\)个选择的补给点。考虑如此证明：如果\\(x_1=y_1\\)，那么证明完成；否则，构造解\\(T&#39;=\\{y_1,x_2,x_3,\\dots,x_m\\}\\)，可以发现\\(T&#39;\\)和\\(T\\)的集合大小相同。一方面，由于\\(y_1&gt;x_1\\)，从\\(y_1\\)出发可以更快的到达\\(x_2\\)，因此这个解是成立的；另一方面，子问题\\(S_{y_1}\\)也是\\(S_{x_1}\\)的一个子问题，因此\\(S_{x_1}\\)求出的解必定不会严格优于\\(S_{y_1}\\)的解。因此整个贪心算法是成立的，具体实现由算法GEN-STOP-POINT给出。\r\nGEN-STOP-POINT(X, n, m)  A = ∅  rest = m  for i = 1 to n + 1    if X[i] &gt; m      return ∅    if X[i] &gt; rest      A = A ∪ &#123;i - 1&#125;      rest = m - X[i]    else      rest = rest - X[i]  return A\r\n15.2-5\r\n假设这些点\\(x_i\\)已经按照顺序排好序。那么证明：这个问题的一个最优解\\(S\\)满足：\\(S\\)中的所有区间的左端点是\\(\\{x\\}\\)中的某些点。\r\n假设解\\(S\\)中的一个区间\\([l_j,l_j+1]\\)满足\\(x_{i-1}&lt;l_j&lt;x_i\\)，考虑区间\\([x_i,x_i+1]\\)与其相比。可以知道，区间\\([l_j,x_i)\\)并没有覆盖到任何点。考虑区间\\((l_j+1,x_j+1]\\)，如果这个区间上没有点，那么区间\\([x_i,x_i+1]\\) 和\\([l_j,l_j+1]\\)覆盖的点是完全一样的；如果这个区间上有点，那么区间\\([x_i,x_i+1]\\)不仅覆盖了\\([l_j,l_j+1]\\)已经覆盖的所有点，还多覆盖了一部分点。因此无论那种情况，区间\\([x_i,x_i+1]\\)都是比\\([l_j,l_j+1]\\)更好的选择。故原结论成立。\r\n并且，不难证明\\(S\\)中的所有区间两两不相交。因此我们可以给出一种算法：将最左边的点作为起点，向右延长一个单位。然后删除这个区间内的所有点，再在剩下的点中进行同样的操作。算法GEN-INTERVALS给出了详细过程。\r\n// 由于所有区间的长度都是1，因此仅返回所有区间的左端点。GEN-INTERVALS(X, n)  RANDOMIZED-QUICKSORT(X, 1, n)  left = -∞  let A be a new array  for i = 1 to n    if left + 1 &lt; X[i]      left = X[i]      INSERT(A, X[i])  return A\r\n\\(\\star\\)\r\n15.2-6\r\n本题的做法和问题9-3相似。假设数组\\(A\\)表示物品的列表，\\(A[i].w\\)与\\(A[i].v\\)分别表示第\\(i\\)个物品的重量和价值，那么按照值\\(\\dfrac{A[i].v}{A[i].w}\\)作为关键字，将\\(A[i].w\\)作为权值，对数组\\(A\\)进行划分。最终的划分结果得出了一个下标\\(p\\)，在\\(p\\)右边的物品可以全部取完，物品\\(p\\)则按重量取完，在\\(p\\)左边的物品不取。\r\n因此，算法FRACTION-KNAPSACK-PROBLEM2的行为和问题9-3-c的算法MEDIAN-WEIGHT一致，它们都是以\\(O(n)\\)的时间复杂度用来求解一个划分。\r\n// 判断物品q的单位价值是否比p大。ITEM-LE(p, q)  return p.v * q.w &lt; p.w * q.vITEM-PARTITION-WEIGHTED(A, p, r)  s = 0  x = A[r]  i = p – 1  for j = p to r – 1    if ITEM-LE(A[j], x)      i = i + 1      exchange A[i] with A[j]    else      s = s + A[j].w  exchange A[i + 1] with A[r]  return i + 1, s + A[i + 1].wITEM-RANDOMIZED-PARTITION-WEIGHTED(A, p, r)  i = RANDOM(p, r)  exchange A[r] with A[i]  return ITEM-PARTITION-WEIGHTED(A, p, r)// 假设数组A中的每个元素都包含属性w和v，分别代表重量和价值，与原来的一致。FRACTION-KNAPSACK-PROBLEM2(A, n, W)  p = 1  r = n  while p &lt; r    q, nw = RANDOMIZED-PARTITION(A, p, r)    if nw &gt;= W      p = q    else      r = q - 1      W = W - nw  sum = nw * (A[p].v / A[p].w)  for i = p + 1 to n    sum = sum + A[p].v  return sum\r\n15.2-7\r\n算法CAL-PAYOFF给出了整个过程，基本思想是将两个数组排序，然后直接计算值\\(\\displaystyle{M=\\prod_{i=1}^n\r\na_i^{b_i}}\\)并返回即可。\r\n正确性说明：由于此时求的\\(M\\)值是乘积，那么对\\(M\\)求对数后，相当于是求\\(\\displaystyle{S=\\lg M=\\sum_{i=1}^n b_i\\lg\r\na_i}\\)的最大值。由于\\(a_i\\)是正数，因此\\(\\lg a_i\\)是非负的，令\\(a_i&#39;=\\lg a_i\\)。\r\n假设一个解\\(A\\)中，\\(a_i&#39;\\)和\\(b_i\\)配对，\\(a_j&#39;\\)和\\(b_j\\)配对，并且有\\(a_i&#39;&lt;a_j&#39;,b_i&gt;b_j\\)，那么此时这两对数对\\(A\\)的贡献为\\(a_i&#39;b_i+a_j&#39;b_j\\)。考虑将这两对数中的\\(b\\)交换，得到一个新解\\(A&#39;\\)，此时这两队数的贡献为\\(a_i&#39;b_j+a_j&#39;b_i\\)。\r\n可以发现，解\\(A&#39;\\)相比解\\(A\\)的花费变化为\\(a_i&#39;b_j+a_j&#39;b_i-a_i&#39;b_i-a_j&#39;b_j=(a&#39;_j-a_i&#39;)(b_i-b_j)&gt;0\\)。这说明解\\(A&#39;\\)比解\\(A\\)更优。因此，这种贪心方法是正确的。\r\n// 假设物品已经按照重量从小到大排序，此时价值是从大到小排序的。CAL-PAYOFF(A, B, n)  RANDOMIZED-QUICKSORT(A, 1, n)  RANDOMIZED-QUICKSORT(B, 1, n)  payoff = 1  for i = 1 to n    payoff = payoff * POW(A[i], B[i])  return payoff\r\n","categories":["算法导论"]},{"title":"算法导论16 Problems 答案","url":"/introduction-to-algorithms/chapter-16/problems/","content":"\r\n16-1\r\na\r\n定义二进制反射格雷码序列\\(a_k\\)的差分序列为\\(d(a_k)=\\langle a_{k,1}\\text{ xor\r\n}a_{k,0},a_{k,2}\\text{ xor }a_{k,1}\\,a_{k,3}\\text{ xor\r\n}a_{k,2},\\dots,a_{k,2^k-1}\\text{ xor\r\n}a_{k,2^k-2}\\rangle\\)。也就是说，\\(d(a_k)\\)的长度为\\(2^k-1\\)。\r\n现在证明，\\(\\forall k\\ge\r\n1,d(a_k)\\)是一个对称的序列。\r\n当\\(k=1\\)时，可以知道\\(d(a_1)=\\langle1\\rangle\\)。这是一个对称的序列。\r\n当\\(k&gt;1\\)时，按照从\\(a_{k-1}\\)到\\(a_{k}\\)的构造可以发现，\\(d(a_k)\\)的前\\(2^{k-1}-1\\)个元素和\\(d(a_{k-1})\\)完全相同，而\\(d(a_k)\\)的后\\(2^{k-1}-1\\)个元素恰好是\\(d(a_{k-1})\\)的逆序\\(\\text{rev}(d(a_{k-1}))\\)，\\(d(a_k)\\)中间那个元素的值为\\(2^{k-1}\\)。也就是说，\\(d(a_{k})=d(a_{k-1})\\Vert\\langle\r\n2^{k-1}\\rangle\\Vert\\text{rev}(d(a_{k-1}))\\)。因此，\\(d(a_k)\\)仍然是对称的。\r\n可以发现，\\(d(a_k)\\)的第\\(i\\)个元素表示的是最大的整数\\(x\\)使得\\(2^x\\mid\r\ni\\)。那么这个程序的设计和算法INCREMENT非常类似。这个过程将由DETERMINE-FLIP给出。\r\n// I表示这个下标二进制数组，k表示这个数组的大小。DETERMINE-FLIP(I, k)  i = 0  while i &lt; k and I[i] == 0    i = i + 1  return i\r\nb\r\n算法GEN-BINARY-REFLECTED-GRAY-CODE给出了产生一个长度为\\(2^k\\)的\\(k\\)位反射格雷码算法。这个算法的特点是在第4行执行了\\(2^k\\)次子程序INCREMENT'。按照前文的分析，这\\(2^k\\)次执行INCREMENT'的运行时间之和为\\(\\Theta(2^k)\\)。如果for循环中的其它所有单次操作的时间均有常数上限，那么算法GEN-BINARY-REFLECTED-GRAY-CODE的运行时间之和为\\(\\Theta(2^k)\\)。\r\n// 假设算法INCREMENT&#x27;的过程和INCREMENT完全相同，区别在于INCREMENT&#x27;会在最后将i值返回。GEN-BINARY-REFLECTED-GRAY-CODE(k)  let I[0 : k], J[0 : k] be new array by 0  m = pow(2, k)  for s = 1 to m    parse J as k-bit binary reflected Gray code and show it    i = INCREMENT&#x27;(I, k)    // 按照题目条件，这个步骤是常数花费的。    if i &lt; k      J[i] ^= 1\r\n16-2\r\na\r\n直接遍历这\\(k\\)个数组，每个数组\\(A_i\\)执行一次二分查找，如果查找到了及时返回，否则继续查找下一个数组。因此在最坏情况下，每个数组都为满且进行了一次查找，因此在最坏情况下这个算法的时间复杂度为\\(O\\displaystyle{\\left(\\sum_{i=0}^{k-1} \\lg\r\n2^i\\right)}\\)，即\\(O(k^2)=O(\\lg^2n)\\)。\r\nb\r\n首先简单地将数插入到\\(A_0\\)，这时只需要花费\\(O(1)\\)的代价。如果\\(A_0\\)原本就已满，那么就复制到\\(A_1\\)中，如果\\(A_1\\)也是满的，那么有序合并\\(A_0,A_1\\)，并复制到\\(A_2\\)中，以此类推，从低级别的数组转移到高级别数组。如果当前有\\(n=2^k-1\\)个元素，并且再执行一次插入操作，那么就会达到最坏情况。此时数组\\(A_0,A_1,A_2\\dots,A_{k-1}\\)中的所有数都需要清空，合并后放到\\(A_{k}\\)中。由于合并两个有序数组的开销是线性的，这时将会达到最坏的时间复杂度\\(O(2^k)\\)，即\\(O(n)\\)。\r\n考虑INSERT操作的均摊代价。每次操作支付\\(1\\)美元，用于当前的插入操作，并且预支\\(k-1\\)美元，用于后续将这个元素从低级数组转移到高级数组。由于这个\\(n\\)元集合最多只有\\(k\\)个数组，并且所有元素只会从低级数组转移到高级数组，因此这些操作足以不产生任何的欠费。因此，无论是否处于最坏情况，一个INSERT操作均摊后只需要花费\\(O(k)\\)的代价，即\\(O(\\lg n)\\)。\r\nc\r\n令\\(p\\)为最小的整数使得数组\\(A_p\\)不为空。如果所要删除的元素\\(x\\)在\\(A_p\\)，那么删除\\(x\\)，并以\\(O(2^p)\\)的时间将\\(A_p\\)剩余的元素全部转入\\(A_0,A_1,\\dots,A_{p-1}\\)中。否则，假设\\(x\\)在\\(A_q(q&gt;p)\\)中，那么从\\(A_q\\)中删除元素\\(x\\)，并且从\\(A_p\\)中挑选一个元素\\(x\\)放到\\(q\\)中，以\\(O(2^q)\\)的时间使序列\\(A_q\\)有序，接下来就和之前一样，继续将\\(A_p\\)剩下的所有元素全部转入\\(A_0,A_1,\\dots,A_{p-1}\\)中。\r\n因此，DELETE的单次操作的时间复杂度为\\(O(2^q)=O(n)\\)。当元素个数恰好为\\(2^x-1\\)时，轮流进行INSERT, DELETE, INSERT, DELETE, ...操作时将会达到最坏情况，每次产生\\(O(n)\\)个元素的位置变化，此时均摊分析失效。\r\n最终，单次操作的平均运行时间为\\(O(n)\\)。\r\n16-3\r\na\r\n重构出一棵\\(\\dfrac{1}{2}\\)平衡二叉树由算法REBUILD-BALANCED-TREE给出。它先将原本树\\(T\\)的中序遍历结果求出，使用\\(O(T.root.size)\\)的空间存储这个结果。然后再以这个中序遍历的结果的中点作为根节点，然后左半部分和右半部分分别进行递归。划分出中点后，左半部分和右半部分的子节点数最多相差\\(1\\)，因此是满足\\(\\dfrac{1}{2}\\)平衡的条件的。\r\n在算法REBUILD-RUN中，一个中序遍历的结果被均匀划分成两半。令\\(T(n)\\)表示用长度为\\(n\\)的序列构造出一棵\\(\\dfrac{1}{2}\\)平衡的二叉树的运行时间，那么有\\(T(n)=2T(n/2)+1\\)，最终不难得出\\(T(n)=\\Theta(n)\\)。\r\nREBUILD-RUN(L, p, r)  if p &gt; r    return NIL  m = ⌊(p + r) / 2⌋  l = REBUILD(L, p, m - 1)  r = REBUILD(L, m + 1, r)  L[m].left = l  L[m].right = r  return L[m]REBUILD-BALANCED-TREE(T)  // 将T的中序遍历结果存放在L中。  generate inorder traversal list L of T  T.root = REBUILD-RUN(L, 1, n)  n = L.size  return T\r\nb\r\n令\\(U(n)\\)表示在一棵\\(\\alpha\\)平衡二叉树中进行查找的时间。根据\\(\\alpha\\)平衡的定义，如果当前树的节点个数为\\(n\\)，那么它的两个子树的节点数都不超过\\(\\alpha n\\)。因此有\\(U(n)\\le U(\\alpha n)+1\\)。由于\\(\\alpha&lt;1\\)，根据主定理，可以得到\\(U(n)=O(\\lg n)\\)。\r\nc\r\n由于\\(\\Delta(x)\\)的定义最外部有一个绝对值符号，因此\\(\\Delta(x)\\ge 0\\)必定成立。也就是说，\\(\\Phi(T)\\ge 0\\)必定成立。\r\n如果一棵树是\\(T\\)满足\\(\\Phi(T)=0\\)，那么相当于\\(\\forall x\\in T,\\Delta(x)\\le\r\n1\\)均成立。如果一个节点的两棵子树的节点树相等，那么这个节点必定是一个\\(\\dfrac{1}{2}\\)平衡节点；如果一棵子树的节点子树的节点数相差\\(1\\)，假设左子树为\\(x\\)，右子树为\\(x+1\\)，整棵树一共有\\(x+x+1+1=2x+2\\)个节点，右子树的节点数占比数仍然不超过\\(\\dfrac{1}{2}\\)。因此，如果一棵二叉树\\(T\\)是一个\\(\\dfrac{1}{2}\\)平衡二叉树，那么\\(\\Phi(T)=0\\)。\r\nd\r\n不失一般性，假设子树\\(T\\)中的某个节点\\(x_0\\in T\\)不满足\\(\\alpha\\)平衡的情况。那么有\\(x_0.left.size&gt;\\alpha x_0.size\\)。\r\n那么可以推出\\(x_0.right.size&lt;\r\nx_0.size-\\alpha x_0.size-1&lt;(1-\\alpha)x_0.size\\)。\r\n在这种情况下，有\\(\\Delta(x_0)=x_0.left.size-x_0.right.size&gt;(2\\alpha-1)x_0.size\\)。\r\n不考虑\\(T\\)中的其它节点的情况，可以知道，\\(\\displaystyle{\\Phi(T)=c\\sum_{x\\in T:\\Delta(x)\\ge\r\n2}\\Delta(x)&gt;c\\Delta(x_0)=c(2\\alpha-1)x_0.size}\\)。\r\n如果\\(x.size\\)个单位的势能够支付重建\\(x.size\\)个节点子树的代价，那么有\\(\\Phi(T)&gt;x_0.size\\)，并且每个节点平均只会摊分了常数代价。为了保证此式成立，令\\(c(2\\alpha-1)x_0.size&gt;x_0.size\\)，最终得到\\(c&gt;\\dfrac{1}{2\\alpha}\\)。\r\ne\r\n继续进行16-3-d的讨论。每个节点的均摊成本为常数。\r\n由于这棵树是\\(\\alpha\\)平衡的，根据题目16-3-b的结论，无论进行一次插入操作还是进行一次删除操作，都只需要\\(O(\\lg\r\nn)\\)的运行时间。需要注意的是，无论是哪种操作，本质上都是在一棵树上的某个节点\\(x\\)进行操作。操作完成后，只有从根节点\\(T.root\\)到\\(x\\)这条路径之间的所有节点都需要进行\\(\\alpha\\)平衡性判断，这条路径上一共有\\(O(\\lg\r\nn)\\)个节点。一次操作完成后，如果有多个节点不再满足\\(\\alpha\\)平衡性质，那么就选择深度最浅的那个节点\\(p\\)进行重构。这次操作导致了路径\\(p\\)到\\(x\\)中，所有的\\(\\Delta\\)值都发生了改变。由于这些节点至多有\\(O(\\lg\r\nn)\\)个，每个节点的均摊成本为常数，因此进行一次操作的均摊成本为\\(O(\\lg n)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论15.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-15/exercises-3/","content":"\r\n15.3-1\r\n由于\\(x.freq\\le y.freq\\)，因此\\(x.freq\\)是\\(C\\)中频率的最小值，此时\\(y.freq\\)是\\(C\\)中频率的次小值。由于\\(a.freq\\le b.freq\\)，并且有\\(x.freq=b.freq\\)，那么有\\(x.freq=a.freq\\)。由于\\(y.freq\\)是\\(C\\)中的次小值，并且\\(C\\)中已经有\\(3\\)个频率值是最小且相等的，因此\\(y.freq=b.freq\\)。最终有\\(x.freq=y.freq=a.freq=b.freq\\)。\r\n15.3-2\r\n令\\(T\\)为这一棵非满二叉树，并且\\(u\\)是某一个只包含一个子节点的节点，那么考虑删除节点\\(u\\)，并将\\(u\\)的这个儿子拼接到其父节点中，得到一棵新树\\(T&#39;\\)。这棵树\\(T&#39;\\)将会比\\(T\\)更加优秀，证明过程是考虑比较\\(B(T)\\)和\\(B(T&#39;)\\)的大小。\r\n注意到，由于\\(u\\)节点被删除，此时以\\(u\\)为子树的所有节点的深度都减少了\\(1\\)。那么有\r\n\\(\\begin{aligned}\r\nB(T&#39;)&amp;=\\sum_{c\\in C} c.freq\\cdot d_{T&#39;}(x)\\\\\r\n&amp;=\\sum_{u\\text{ is an ancestor of }x} x.freq\\cdot\r\nd_{T&#39;}(x)+\\sum_{u\\text{ isn&#39;t an ancestor of }x} x.freq\\cdot\r\nd_{T&#39;}(x)\\\\\r\n&amp;=\\sum_{u\\text{ is an ancestor of }x} x.freq\\cdot\r\nd_{T}(x)+\\sum_{u\\text{ isn&#39;t an ancestor of }x} x.freq\\cdot\r\n(d_{T}(x)-1)\\\\\r\n&amp;&lt;\\sum_{u\\text{ is an ancestor of }x} x.freq\\cdot\r\nd_{T}(x)+\\sum_{u\\text{ isn&#39;t an ancestor of }x} x.freq\\cdot\r\nd_{T}(x)\\\\\r\n&amp;=B(T)\r\n\\end{aligned}\\)\r\n由此可知，我们构造出了一棵更优秀的树\\(T&#39;\\)。因此一个非满二叉树必定不可能对应一个最优无前缀编码。\r\n15.3-3\r\n由此可以产生出如下的哈夫曼树。\r\ngraph TD  A[a:1]  B[b:1]  C[c:2]  D[d:3]  E[e:5]  F[f:8]  G[g:13]  H[h:21]  ab((2))  ac((4))  ad((7))  ae((12))  af((20))  ag((33))  ah((54))  ah--0---H  ah--1---ag  ab--0---B  ab--1---A  ac--0---C  ac--1---ab  ad--0---D  ad--1---ac  ae--0---E  ae--1---ad  af--0---F  af--1---ae  ag--0---G  ag--1---af  \r\n由此可以构造出哈夫曼编码：\r\n\\(\\begin{array}{|l|l|}\r\n\\hline\r\na &amp; 1111111\\\\\r\n\\hline\r\nb &amp; 1111110\\\\\r\n\\hline\r\nc &amp; 111110\\\\\r\n\\hline\r\nd &amp; 11110\\\\\r\n\\hline\r\ne &amp; 1110\\\\\r\n\\hline\r\nf &amp; 110\\\\\r\n\\hline\r\ng &amp; 10\\\\\r\n\\hline\r\nh &amp; 0\\\\\r\n\\hline\r\n\\end{array}\\)\r\n对于一般情况而言，如果现在有\\(n\\)个字符，第\\(n\\)个字符的频率为\\(f_n(f_1=f_2=1,f_n=f_{n-1}+f_{n-2})\\)，那么可以按照如下构造哈夫曼编码：第\\(1\\)个字符的哈夫曼编码为\\(1^{n-1}\\)，对于第\\(m(m&gt;1)\\)个字符，其哈夫曼编码为\\(1^{n-m} \\mid\\mid 0\\)。\r\n接下来通过说明算法HUFFMAN的运行结果说明这个结论是正确的。\r\n首先证明：\\(\\displaystyle{F_n=\\sum_{i=1}^n\r\nf_i = f_{i+2}-1}\\)。考虑使用数学归纳法进行证明。\r\n\r\n当\\(n=1\\)时，\\(F_1=f_3-1=2-1=1\\)，成立。\r\n当\\(n&gt;1\\)时，假设对于\\(m=1,2,\\dots,m-1\\)，\\(F_m=f_{m+2}-1\\)都成立。那么有\\(F_n=F_{n-1}+f_n=f_{n+1}-1+f_n=f_{n+2}-1\\)。结论仍然成立。\r\n\r\n因此，\\(F_n=f_{n+2}-1\\)成立。\r\n接下来证明循环不变量：最小优先队列中的关键字按顺序总是\\(\\{f_i,F_{i-1},f_{i+2},f_{i+3},\\dots,f_n\\}\\)，并且用\\(F\\)表示的关键字\\(F_{i-1}\\)要么是最小值，要么是次小值。这个序列已经有序的原因是，当\\(i\\ge 2\\)时，\\(F_{i-1}=f_{i+1}-1=f_i+(f_{i-1}-1)\\ge\r\nf_i,F_{i-1}=f_{i+1}-1&lt;f_{i+2}\\)。\r\n因此，算法HUFFMAN总是弹出\\(Q\\)中用\\(F\\)表示的那个关键字，最终变成了一个新关键字\\(F_i=F_{i-1}+f_i\\)。最终产生的编码如上述结论。\r\n初始化：\\(Q\\)中的元素一开始为\\(\\{f_2,f_1,f_3,\\dots,f_n\\}\\)，将\\(f_1\\)用\\(F_1\\)代替后，循环不变量成立。\r\n保持：若\\(Q\\)中的元素当前为\\(\\{f_i,F_{i-1},f_{i+1},f_{i+2},\\dots,f_n\\}\\)，那么弹出最小的两个元素\\(f_i,F_{i-1}\\)，构造出新元素\\(F_i=F_{i-1}+f_i\\)后，再添加进\\(Q\\)中，得到\\(\\{f_{i+1},F_{i},f_{i+2},f_{i+3},\\dots,f_n\\}\\)，根据上面的结论可知，这个序列仍然是有序的。在这个保持过程中，用\\(F\\)表示的那个关键字被弹出来，这个用\\(F\\)表示的关键字添加进\\(Q\\)后，仍然是\\(Q\\)中最小或者是次小的数，在下一次仍然会被弹出。\r\n终止：\\(Q\\)中只剩下一个元素\\(F_n\\)，整个序列仍然是有序的。\r\n因此，用\\(F\\)表示的关键字不断被弹出、加入，最终构造出的哈夫曼树的所有内部节点至少都有一个叶子节点，因此构造出来的哈夫曼编码如上结论所述。\r\n15.3-4\r\n令\\(L(T)\\)表示满二叉树\\(T\\)的叶子节点的频率之和，\\(t(u)\\)表示以\\(u\\)为根节点的子树，\\(l(T),r(T)\\)分别为\\(T\\)的左子树和右子树。\r\n题目相当于证明\\(\\displaystyle{B(T)=\\sum_{u\\in T}\r\nL(l(t(u)))+L(r(t(u)))}\\)。对于\\(T\\)中的一个内部节点\\(u\\)而言，\\(L(l(t(u)))+L(r(t(u)))\\)相当于是以\\(u\\)为根节点的子树的叶节点频率之和，即\\(L(t(u))\\)；对于一个叶节点\\(l\\)，由于左右子节点都为空，因此\\(L(l(t(u)))+L(r(t(u)))\\)的值为\\(0\\)。\r\n最终转化成证明\\(\\displaystyle{B(T)=\\sum_{u\\in T}\r\nL(t(u))-L(T)}\\)。考虑使用归纳法证明这个式子。\r\n对于一棵只有\\(1\\)个节点的二叉树\\(E\\)，注意\\(E\\)也是一个满二叉树，那么根据\\(B(E)\\)的定义，可知\\(B(E)=L(E)-L(E)=0\\)，原结论成立。\r\n对于任意一棵\\(n\\)个节点的满二叉树树\\(T\\)，设其根节点为\\(x\\)。假设对于\\(1,2,3,\\dots\r\nn-1\\)个节点的满二叉树，上面的结论都成立，那么其左子树\\(l(t(x))\\)和右子树\\(r(t(x))\\)都满足这个条件。由于\\(T\\)可以视为是由根节点\\(x\\)，左子树\\(l(t(x))\\)和右子树\\(r(t(x))\\)构成，因此相对于\\(T,l(t(x))\\)和\\(r(t(x))\\)无论是根节点还是叶子节点，深度都增加了\\(1\\)，因此总体代价都增加了\\(L(l(t(x)))+L(r(t(x)))=L(T)\\)。那么有\r\n\\(\\begin{aligned}\r\nB(T)&amp;=B(l(x))+B(r(x))+L(T)\\\\\r\n&amp;= \\sum_{u\\in l(x)} L(t(u))-L(l(x))+\\sum_{u\\in r(x)} L(t(u))-L(r(x))\r\n+ L(T)\\\\\r\n&amp;= \\sum_{u\\in l(x)} L(t(u))+\\sum_{u\\in r(x)} L(t(u))\\\\\r\n&amp;= \\sum_{u\\in T-\\{x\\}} L(t(u))\\\\\r\n&amp;= \\sum_{u\\in T} L(t(u))-L(T)\\\\\r\n\\end{aligned}\\)\r\n故原结论成立。\r\n15.3-5\r\n首先，每一个字符都需要用\\(\\lceil\\lg\r\nn\\rceil\\)位二进制编码表示，最终需要\\(n\\lceil\\lg\r\nn\\rceil\\)位的编码表示这个从编码映射到字符的字典。另外的\\(2n-1\\)个字符则用来表示这棵哈夫曼树的结构。这棵树一共有\\(2n-1\\)个节点，我们用\\(0\\)表示内部节点，用\\(1\\)来表示叶子节点，然后先序遍历整棵树，得到一个\\(2n-1\\)比特的序列。由于满二叉树每个内部节点必定有两个子节点，回溯到原来的节点再继续遍历时直接从另外一个子节点往下走即可，因此这个比特序列一定能够还原出原来的满二叉树结构。\r\n具体的过程由REBUILD-CODING给出。\r\n// S是这个n ⌈lg n⌉ + 2n - 1长度的字符串；D表示编码规则的转换（可以抽象地理解成一个哈希表），将⌈lg n⌉位比特转换成一个字符。// S是一个位字符串，假设其有一个子程序READ，READ(x)表示继续往下读取x比特，并返回这个长度为x的比特串；S还有一个方法FINISH，用于判断S的字符串是否读完。REBUILD-TABLE(S, D, n)  let S1 and S2 be new STACKS  let T be a new HASH-TABLE  c = S.READ(1)  if c == 1    error &quot;illegal code&quot;  PUSH(S1, 0)  while not S.FINISH()    while NOT-EMPTY(S1)      // 当前节点已经都被向下遍历了2次，应该回溯。      if S1[S1.size] == 2        POP(S1)        POP(S2)      else        break    // S1[S1.size]即为栈顶的值，它要么为0，要么为1，表示它是左子节点还是右子节点。    PUSH(S2, S1[S1.size])    S1[S1.size] = S1[S1.size] + 1    PUSH(S1, 0)    c = S.READ(1)    if c == 1      s = S.read(⌈lg n⌉)      parse S2 into a string t      T[D[s]] = t      POP(S2)      POP(S1)  return T  \r\n15.3-6\r\n先插入频率为\\(0\\)的哑节点，使得最小优先队列\\(Q\\)的大小模\\(3\\)的值为\\(1\\)。与构建二元哈夫曼树时的情况相同，每次取出\\(3\\)个节点，并且新生成一个节点\\(q\\)的频率是这\\(3\\)个节点的频率之和，并将\\(q\\)连接到这\\(3\\)个节点。具体过程由算法HUFFMAN3给出。\r\nHUFFMAN3(C)  Q = C  while Q.size mod 2 != 1    let p be a new node    p.freq = 0    p.left = NIL    p.right = NIL    // 将哑节点p插入最小优先队列Q中。    INSERT(Q, p)  while Q.size &gt; 1    let q be a new node    x = EXTRACT-MIN(Q)    y = EXTRACT-MIN(Q)    z = EXTRACT-MIN(Q)    第i个子节点用p[i]表示。    q.p[0] = x    q.p[1] = y    q.p[2] = z    INSERT(Q, q)  return EXTRACT-MIN(Q)\r\n贪心选择性和最优子结构证明和二叉的情况几乎完全相同。最优子结构的证明过程是替换一个三叉节点，贪心选择性证明则考虑频率最小的\\(3\\)个节点和深度最深的\\(3\\)个节点。\r\n15.3-7\r\n令\\(n=8\\)，序列\\(\\{f_1,f_2,\\dots,f_{2^n}\\}\\)表示所有字符的频率之和，并且已经排好序。按照题目定义，还满足\\(2f_1\\ge f_{2^n}\\)。\r\n按照HUFFMAN算法，可以知道之后插入的新节点\\(F_1=f_1+f_2\\ge\r\nf_{2^n}\\)，可以视为经过了\\(2^{n-1}-1\\)次FOR循环后，节点\\(F_1\\)才有机会再弹出。那么在这\\(2^{n-1}\\)次迭代中，\\(f\\)的所有元素都将被第5-6行弹出了一次，并且构建成了一个长度为\\(F_{2^{n-1}}\\)的有序序列。可以证明仍然满足\\(2F_1\\ge F_{2^n-1}\\)，因为\\(2F_1=2f_1+2f_2\\ge\r\nf_{2^{n}-1}+f_{2^{n}}=F_{2^{n-1}}\\)。\r\n最终由于同一层下的节点每次都恰好被遍历，因此构建出来的哈夫曼树是一个满二叉树，每一个字符都用一个\\(n\\)比特编码来表示。因此在这种情况下，哈夫曼编码并不比定长编码有效。\r\n15.3-8\r\n可以知道，大小为\\(n\\)比特的不同文件一共有\\(2^n\\)。一个无损压缩器为了区分这\\(2^n\\)个文件，压缩产生的结果必定也是\\(2^n\\)个不同的编码。如果使用小于\\(n\\)比特的所有位串来区分这些文件，那么一共有\\(2^0+2^1+\\dots+2^{n-1}=2^n-1\\)种方法，但是仍然还有\\(1\\)个文件不能用小于\\(n\\)比特的编码表示。因此不存在一个无损压缩器可以对所有文件，都能产生有效的压缩。\r\n","categories":["算法导论"]},{"title":"算法导论15.4 Exercises 答案","url":"/introduction-to-algorithms/chapter-15/exercises-4/","content":"\r\n15.4-1\r\nFURTHEST-IN-FUTURE(C, k, B, i, n)  // T是一个字典，将一个数映射成它在B的所有下标的列表。  let T be a new HASH-MAP  // Q是一个支持以O(lg n)的时间复杂度进行增加，删除，查询，修改的有序数据结构，以key作为排序关键字。  let Q be a new ORDERED-SET  //如果T不存在关键字B[j]，INSERT方法将会为其创建并且初始化出一个对应的空列表。  for j = i to n    INSERT(T[B[j]], j)  for each b in C    INSERT(T[b], +∞)    let p be a new node    p.key = T[b][1]    p.ID = b    INSERT(Q, p)  for j = i to n    if SEARCH(S, B[i])      print b_i: a cache hit    else      print b_i: a cache miss      if Q.size == k        // MAX用于获取Q中的最大值。        p = MAX(Q)        DELETE(Q, p)        print p.ID is evicted      let p be a new node      p.ID = B[i]      p.key is the smallest number x in T[B[i]] such that x &gt; i or +∞ if T[B[i]] isn&#x27;t existed      INSERT(Q, p)  \r\n15.4-2\r\n假设请求序列为\\(b=[1,2,3,4,5,1,2,3]\\)，缓存快\\(C\\)的大小\\(k=3\\)，那么按照LRU算法和FF算法的定义，可以列出下表：\r\n\\(\\begin{array}{|c|c|c|c|c|}\r\n\\hline\r\nb&amp;C_\\text{LRU}&amp;\\text{LRU cache miss occured}&amp; C_\\text{FF}\r\n&amp; \\text{FF cache miss occured}\\\\\r\n\\hline\r\n1&amp;[1]&amp;\\texttt{YES}&amp;[1]&amp;\\texttt{YES}\\\\\r\n\\hline\r\n2&amp;[2,1]&amp;\\texttt{YES}&amp;[1,2]&amp;\\texttt{YES}\\\\\r\n\\hline\r\n3&amp;[3,2,1]&amp;\\texttt{YES}&amp;[1,2,3]&amp;\\texttt{YES}\\\\\r\n\\hline\r\n4&amp;[4,3,2]&amp;\\texttt{YES}&amp;[1,2,4]&amp;\\texttt{YES}\\\\\r\n\\hline\r\n5&amp;[5,4,3]&amp;\\texttt{YES}&amp;[1,2,5]&amp;\\texttt{YES}\\\\\r\n\\hline\r\n1&amp;[1,5,4]&amp;\\texttt{YES}&amp;[1,2,5]&amp;\\texttt{NO}\\\\\r\n\\hline\r\n2&amp;[2,1,5]&amp;\\texttt{YES}&amp;[1,2,5]&amp;\\texttt{NO}\\\\\r\n\\hline\r\n3&amp;[3,2,1]&amp;\\texttt{YES}&amp;[1,2,3]&amp;\\texttt{YES}\\\\\r\n\\hline\r\n\\end{array}\\)\r\n可以发现，LRU算法在整个过程中总是在发生缓存缺失，而FF算法命中了\\(2\\)次。因此这个例子说明LRU算法并非是离线缓存算法中最优的。\r\n15.4-3\r\n\\(x\\)是\\(b_i\\)被请求时\\(C\\)中被替换的块，\\(y\\)是\\(b_j\\)被请求时被替换的块。如果换成这种方式，那么在请求\\(b_i\\)和\\(b_j\\)替换掉的块是同一个块，这种证明忽略了最优策略下，分别请求\\(b_i\\)和\\(b_j\\)所替换的块不一定相同的事实。\r\n15.4-4\r\n假设当前处在第\\(i\\)个访问序列，在原问题（最多只能有一个块进入缓存）的最优策略\\(S\\)下，此时的缓存配置为\\(C_{S,i}\\)（如果缓存未充满数据，为方便证明，假设\\(C\\)未充满的一部分都是永远不会被用到的过期数据）。按照这个最优策略\\(S\\)，在从\\(i\\)到\\(j(j&gt;i)\\)的过程中，替换掉的总是属于\\(C_{S,i}\\)的旧数据（假设一共发生了\\(m\\)次，也就是说，从\\(i\\)到\\(j\\)的这\\(m\\)次缓存缺失，最优策略采取的都是从\\(C_{S,i}\\)中选择块进行替换，在这个过程中，新替换进来的块都不会被替换掉。那么假设替换进来的\\(m\\)个块为\\(I\\)，被替换的\\(m\\)个块为\\(D\\)），那么在新问题中（可以多个块同时进入缓存）的最优解\\(S&#39;\\)，访问\\(b_i\\)时，这单次请求就可以直接从\\(C_{S&#39;,i}\\)（注意\\(C_{S,i}=C_{S&#39;,i}\\)）中属于\\(D\\)的\\(m\\)个块，替换成属于\\(I\\)的\\(m\\)个块。只要\\(m\\ge\r\n1\\)，这种预先加载多个块的效率不差于只加载一个块的效率。\r\n","categories":["算法导论"]},{"title":"算法导论17.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-17/exercises-1/","content":"\r\n17.1-1\r\n一开始\\(x\\)在根节点\\(T.root,i=10\\)。\r\n\r\n现在计算出\\(r=x.left.size+1=12+1=13&gt;i\\)，因此将从\\(x\\)转移到左子节点\\(x.left\\)；此时\\(x.key=17\\)。\r\n现在计算出\\(r=x.left.size+1=7+1=8&lt;i\\)，因此将从\\(x\\)转移到右子节点\\(x.right\\)，并从\\(i\\)减去\\(r\\)，得到\\(i=2\\)；此时\\(x.key=21\\)。\r\n现在计算出\\(r=x.left.size+1=2+1=3&gt;i\\)，因此将从\\(x\\)转移到左子节点\\(x.left\\)；此时\\(x.key=19\\)。\r\n现在计算出\\(r=x.left.size+1=0+1=1&lt;i\\)，因此将从\\(x\\)转移到右子节点\\(x.right\\)，并从\\(i\\)减去\\(r\\)，得到\\(i=1\\)；此时\\(x.key=20\\)。\r\n现在计算出\\(r=x.left.size+1=0+1=1=i\\)，这说明\\(x\\)节点为所求，算法结束。\r\n\r\n17.1-2\r\n一开始\\(y\\)指向\\(x\\)，并且\\(r=x.left.size+1=0+1=1\\)。\r\n\r\n由于目前\\(x==x.p.left\\)，因此不做任何操作，并将\\(x\\)指向它的父节点；此时\\(x.key=38\\)。\r\n由于目前\\(x==x.p.right\\)，因此对\\(r\\)添加\\(r.left.size+1\\)，得到\\(r=1+1+1=3\\)，并将\\(x\\)指向它的父节点；此时\\(x.key=30\\)。\r\n由于目前\\(x==x.p.left\\)，因此不做任何操作，并将\\(x\\)指向它的父节点；此时\\(x.key=41\\)。\r\n由于目前\\(x==x.p.right\\)，因此对\\(r\\)添加\\(r.left.size+1\\)，得到\\(r=3+12+1=16\\)，并将\\(x\\)指向它的父节点；此时\\(x.key=26\\)，并且算法终止。\r\n\r\n17.1-3\r\n算法OS-SELECT的非递归版本如下：\r\nOS-SELECT-NONRECURSIVE(T, i)  while True    r = x.left.size + 1    if i == r      return x    else if i &lt; r      x = x.left    else      x = x.right      i = i - r\r\n17.1-4\r\n如下是OS-KEY-RANK的伪代码，它是自顶向下实现的。\r\nOS-KEY-RANK(T, k)  x = T.root  rk = 0  while x != T.nil    r = x.left.size + 1    if x.key &lt; k      rk = rk + r      x = x.right    else if x.key == k      rk = rk + r      return rk    else      x = x.left  // k不在T中，那么有rk个比k小的键。  return rk + 1\r\n17.1-5\r\n先求出节点\\(x\\)的排名\\(r\\)，再查找排名为\\(r+i\\)的节点，即为\\(x\\)的第\\(i\\)个后继，具体过程由算法ITH-SUCCESSOR给出，由于它仅仅是调用了一次OS-SELECT和一次OS-RANK，因此其时间复杂度仅为\\(O(\\lg n)\\)。\r\nITH-SUCCESSOR(T, x, i)  r = OS-RANK(T, x)  y = OS-SELECT(T, r + i)  return y\r\n17.1-6\r\n令属性\\(x.rank&#39;\\)表示以\\(x\\)为根节点的子树中，节点\\(x\\)所在这棵子树的排名。因此可以发现，\\(x.rank&#39;\\)和\\(x.size\\)的关系满足\\(x.rank&#39;=x.left.size+1\\)。考虑直接维护属性\\(rank&#39;\\)的值。\r\n那么对于一次插入节点\\(z\\)的操作，如果\\(z\\)在\\(x\\)的左子树，那么\\(x\\)的排名需要增加\\(1\\)（因为\\(x.key&gt;z.key\\)）。完成插入操作后，只需要执行平常的FIXUP操作即可，插入算法由OS-INSERT'给出。其中，OS-INSERT-FIXUP'操作和RB-INSERT-FIXUP基本相同，它的区别仅仅是旋转子程序将使用后面编写的OS-LEFT-ROTATE'和OS-RIGHT-ROTATE'，之后子程序OS-DELETE-FIXUP'和RB-DELETE-FIXUP的区别同样与此相同。\r\nOS-INSERT&#x27;(T, z)  x = T.root  y = T.nil  while x != T.nil    y = x    if z.key &lt; x.key      x.rank&#x27; = x.rank&#x27; + 1      x = x.left    else      x = x.right  z.p = y  if y == T.nil    T.root = z  else if z.key &lt; y.key    y.left = z  else    y.right = z  z.left = T.nil  z.right = T.nil  z.color = RED  z.rank&#x27; = 1  OS-INSERT-FIXUP&#x27;(T, z)\r\n删除算法由OS-DELTTE'给出。对于即将被删除的\\(y\\)节点的唯一一个儿子\\(x\\)，自底向上遍历其所有祖先\\(p\\)，如果\\(x\\)在\\(p\\)的左子树，那么需要对\\(p\\)的排名减去\\(1\\)。此外，他这里使用的是子程序RB-TRANSPLANT，因为这个操作并不会对原来的节点的排名\\(rank&#39;\\)产生任何改变。\r\nOS-DELETE&#x27;(T, z)  y = z  y-original-color = y.color  if z.left == T.nil    x = z.right    RB-TRANSPLANT(T, z, z.right)  else if z.right == T.nil    x = z.left    RB-TRANSPLANT(T, z, z.left)  else    y = RB-MINIMUM(T, z.right)    y-original-color = y.color    x = y.right    if y != z.right      RB-TRANSPLANT(T, y, y.right)      y.right = z.right      y.right.p = y         else       x.p = y    RB-TRANSPLANT(T, z, y)    y.left = z.left    y.rank&#x27; = z.rank&#x27;    y.left.p = y    y.color = z.color  w = x  while w != T.root    if w == w.p.left      w.p.rank&#x27; = w.p.rank&#x27; - 1    w = w.p  if y-original-color == BLACK    OS-DELETE-FIXUP&#x27;(T, x)\r\n其中，OS-INDERT-FIXUP'和OS-DELETE-FIXUP'所使用的两种旋转操作如下：\r\nOS-LEFT-ROTATE&#x27;(T, x)  y = x.right  x.right = y.left  if y.left != T.nill    y.left.p = x  y.p = x.p  if x.p == T.nil    T.root = y  else if x == x.p.left    x.p.left = y  else    x.p.right = y  y.left = x  x.p = y  y.rank&#x27; = y.rank&#x27; + x.rank&#x27;OS-RIGHT-ROTATE&#x27;(T, y)  x = y.left  y.left = x.right  if x.right != T.nil    x.right.p = y  x.p = y.p  if y.p == T.nil    T.root = x  else if y == y.p.left    y.p.left = x  else    y.p.right = x  x.right = y  y.p = x  y.rank&#x27; = y.rank&#x27; - x.rank&#x27;\r\n17.1-7\r\n对于序列\\(A\\)的第\\(i\\)个数\\(A[i]\\)，满足\\(j&lt;i\\land A[j]&gt;A[i]\\)的\\(j\\)的个数相当于是\\(i\\)减去\\(A[i]\\)在以\\(A[1:i]\\)中构成的红黑树的排名\\(r\\)，因为数组\\(A[1:i]\\)中，有\\(i-r\\)个数大于\\(A[i]\\)，因此，计算逆序数的算法由程序CAL-INVERSION'给出。每轮迭代都需要进行两个操作：加入一个节点和进行一次查询，它们都需要\\(O(\\lg\r\nn)\\)的时间复杂度，因此整个算法的时间复杂度为\\(O(n\\lg n)\\)。\r\nCAL-INVERSION&#x27;(A, n)  let T be a new red-black tree that support size attribute.  inversion = 0  for i = 1 to n    Let p be a new node    p.key = A[i]    p.left = T.nil    P.right = T.nil    OS-INSERT(T, p)    inversion = inversion + (i - OS-RANK(T, p))\r\n\\(\\star\\)\r\n17.1-8\r\n假设所有输入是区间\\([0,2\\pi)\\)中的一个数。那么对于任意一条弦\\(C_i=(l_i,r_i),l_i\\le r_i\\)，如果弦\\(C_j\\)和\\(C_i\\)相交，那么\\(l_j\\)和\\(r_j\\)有且仅有一个节点在区间\\((l_i,r_i)\\)中。不是一般性，假设满足\\(l_i&lt;l_j\\)当且仅当\\(i&lt;j\\)，那么\\(C_i\\)和\\(C_j\\)相交此时满足\\(l_j&lt;r_i&lt;r_j\\)。\r\n为此，我们可以提出如下算法：首先对弦按照左端点进行排序，接下来依次枚举每条弦\\(C_j\\)，计算出此前已经有多少个\\(r_i\\)在区间\\((l_j,r_j)\\)中，之后再将\\(r_j\\)插入红黑树中即可。具体算法由CAL-PAIRS-INTERSECT给出。\r\n// 计算树中有多少个键小于kOS-LT-OR-LE-COUNT(T, k, op)  x = T.root  count = 0  while x != T.nil    r = x.left.size + 1    if (op == LT and x.key &lt; k) or (op == LE and x.key &lt;= k)      count = count + r      x = x.right    else      x = x.left  return countCAL-PAIRS-INTERSECT(C, n)  let T be a new red-black tree that support size attribute.  for i = 1 to n    if C[i].left &gt; C[i].right      exchange C[i].left with C[i].right  sort C by C[i].left nondecreasingly  pairs-cnt = 0  for i = 1 to n    t = OS-LT-OR-LE-COUNT(T, C[i].right, LT) - OS-LT-OR-LE-COUNT(T, C[i].right, LE)    pairs = pairs + t    Let p be a new node    p.key = C[i].right    p.left = T.nil    P.right = T.nil    OS-INSERT(T, p)  return pairs\r\n子程序OS-LT-OR-LE-COUNT是从根节点遍历到某一个叶节点，因此其时间复杂度为树高\\(O(\\lg\r\nn)\\)。程序CAL-PAIRS-INTERSECT一开始先对所有弦进行排序，花费了\\(O(n\\lg\r\nn)\\)的时间。之后每次迭代中，进行了两次OS-LT-OR-LE-COUNT询问和一次插入节点，总共需要花费\\(O(\\lg\r\nn)\\)的时间，因此这个算法的总体运行时间为\\(O(n\\lg n)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论17.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-17/exercises-2/","content":"\r\n17.2-1\r\n对每个节点添加一个\\(prec\\)和\\(succ\\)属性，那么我们考虑维护这两个属性值。不难发现，属性\\(prec\\)和\\(succ\\)构成了一个双向链表，为了方便，我们可以用\\(T.nil\\)作为这个双向链表的头部节点。\r\n对于插入操作，我们对\\(z\\)完成普通的红黑树插入操作后，直接求取\\(z\\)的后继\\(s\\)，并且通过节点\\(s\\)的\\(prev\\)得到\\(z\\)的前驱，然后直接更新\\(p.succ=z,s.prev=z\\)即可。\r\n对于删除操作，我们先直接求出\\(z\\)的后继\\(s=z.succ\\)和前驱\\(p=z.prev\\)，然后直接更新\\(p.succ=s,s.prev=p\\)即可。\r\n这两种操作的修改没有改变红黑树的渐进增长时间，同时也将题目所需要的操作的时间复杂度改进到\\(O(1)\\)。这些算法的改动由如下程序给出。\r\nRB&#x27;-MINIMUM(T)  return T.nil.succRB&#x27;-MAXIMUM(T)  return T.nil.prevRB&#x27;-PREDECESSOR(z)  return z.prevRB&#x27;-SUCCESSOR(z)  return z.succRB&#x27;-INSERT(T, z)  RB-INSERT(T, z)  x = z  y = x.p  while y != T.nil and z == x.right    x = y    y = y.p  s = y  p = s.prev  p.succ = z  s.prev = zRB&#x27;-DELETE(T, z)  p = z.prev  s = z.succ  p.succ = s  s.prev = p  RB-DELETE(T, z)\r\n17.2-2\r\n维护节点的黑高可以做到不改变红黑树插入和删除的渐进时间。在整个过程中，我们只需要在FIXUP阶段计算好子节点的黑高后再计算当前节点的黑高即可（子节点可以任意选择，因为按照性质5，左子树和右子树的黑高是一样的，这里选择左子树即可）。\r\n如下是程序RB-INSERT-FIXUP-BH和RB-INSERT-FIXUP-BH，来维护插入或删除某个节点后调整整棵树，并计算每个节点的黑高。插入算法的主程序是RB-INSERT-BH，它和RB-INSERT的区别在于最后一行调用的是RB-INSERT-FIXUP-BH而不是RB-INSERT-FIXUP；删除算法的主程序是RB-DELETE-BH，它和RB-DELETE的区别在于最后一行调用的是RB-DELETE-FIXUP-BH而不是RB-DELETE-FIXUP。\r\nRB-UPDATE-BH(z)  if z.color == BLACK    z.black-height = z.left.black-height + 1  else    z.black-height = z.left.black-heightRB-INSERT-FIXUP-BH(T, z)  while z.p.color == RED    if z.p == z.p.p.left      y = z.p.p.right      if y.color == RED        z.p.color = BLACK        y.color = BLACK        z.p.p.color = RED        z = z.p.p        RB-UPDATE-BH(z.left)        RB-UPDATE-BH(z.right)        RB-UPDATE-BH(z)      else        if z == z.p.right          z = z.p          LEFT-ROTATE(T, z)        z.p.color = BLACK        z.p.p.color = RED        RIGHT-ROTATE(T, z.p.p)        RB-UPDATE-BH(z.p.right)        RB-UPDATE-BH(z.p)    else      y = z.p.p.left      if y.color == RED        z.p.color = BLACK        y.color = BLACK        z.p.p.color = RED        z = z.p.p        RB-UPDATE-BH(z.left)        RB-UPDATE-BH(z.right)        RB-UPDATE-BH(z)      else        if z == z.p.right          z = z.p          RIGHT-ROTATE(T, z)        z.p.color = BLACK        z.p.p.color = RED        RIGHT-ROTATE(T, z.p.p)        RB-UPDATE-BH(z.p.left)        RB-UPDATE-BH(z.p)  T.root.color = BLACKRB-DELETE-FIXUP-BH(T, x)  while x != T.root and x.color == BLACK    if x == x.p.left      w = x.p.right      if w.color == RED        w.color = BLACK        x.p.color = RED        LEFT-ROTATE(T, x.p)        w = x.p.right        RB-UPDATE-BH(x.p)        RB-UPDATE-BH(x.p.p)      if w.left.color == BLACK and w.right.color == BLACK        w.color = RED        x = x.p        RB-UPDATE-BH(x.right)        RB-UPDATE-BH(x)      else        if w.right.color == BLACK          w.left.color = BLACK          w.color = RED          RIGHT-ROTATE(T, w)          w = x.p.right          RB-UPDATE-BH(w.right)          RB-UPDATE-BH(w)        w.color = x.p.color        x.p.color = BLACK        w.right.color = BLACK        LEFT-ROTATE(T, x.p)        RB-UPDATE-BH(x)        RB-UPDATE-BH(w.right)        RB-UPDATE-BH(w)        x = T.root    else      w = x.p.left      if w.color == RED        w.color = BLACK        x.p.color = RED        RIGHT-ROTATE(T, x.p)        w = x.p.left        RB-UPDATE-BH(x.p)        RB-UPDATE-BH(x.p.p)      if w.left.color == BLACK and w.right.color == BLACK        w.color = RED        x = x.p        RB-UPDATE-BH(x.left)        RB-UPDATE-BH(x)      else        if w.left.color == BLACK          w.right.color = BLACK          w.color = RED          LEFT-ROTATE(T, w)          w = x.p.left          RB-UPDATE-BH(w.left)          RB-UPDATE-BH(w)        w.color = x.p.color        x.p.color = BLACK        w.left.color = BLACK        RIGHT-ROTATE(T, x.p)        RB-UPDATE-BH(x)        RB-UPDATE-BH(w.right)        RB-UPDATE-BH(w)        x = T.root  x.color = BLACK\r\n维护节点的深度无法做到不改变红黑树插入和删除的渐进时间，因为插入和删除涉及到旋转操作。旋转操作会将某些子树的所有节点都增加\\(1\\)或者是减少\\(1\\)，这是无法在\\(O(\\lg n)\\)的时间内完成的。\r\n17.2-3\r\n由于属性\\(f\\)是可结合的，因此\\(x.f\\)可以写成\\(x.left.f\\otimes x.a\\otimes\r\nx.right.f\\)。\r\n对于旋转操作导致\\(f\\)值更新，其基本更新操作如下：\r\nOS-LEFT-ROTATE-UPDATE-F(T, x)  y = x.right  x.right = y.left  if y.left != T.nill    y.left.p = x  y.p = x.p  if x.p == T.nil    T.root = y  else if x == x.p.left    x.p.left = y  else    x.p.right = y  y.left = x  x.p = y  y.f = x.f  x.f = x.left.f ⊗ x.a ⊗ x.right.fOS-RIGHT-ROTATE-UPDATE-F(T, y)  x = y.left  y.left = x.right  if x.right != T.nil    x.right.p = y  x.p = y.p  if y.p == T.nil    T.root = x  else if y == y.p.left    y.p.left = x  else    y.p.right = x  x.right = y  y.p = x  x.f = y.f  y.f = y.left.f ⊗ y.a ⊗ y.right.f\r\n最终，将上述代码的\\(f\\)替换成\\(size\\)，\\(\\otimes\\)替换成\\(+\\)，\\(x.a\\)和\\(y.a\\)替换成\\(1\\)，就成为了更新子树大小的代码。\r\n","categories":["算法导论"]},{"title":"算法导论17 Problems 答案","url":"/introduction-to-algorithms/chapter-17/problems/","content":"\r\n17-1\r\na\r\n令\\(z\\)是当前被所有区间覆盖得最多次数的一个点。我们可以将\\(z\\)稍微向右移动，只要不接触到某条线段的端点，那么覆盖到\\(p\\)的线段次数就不会改变；只要移出了某条线段的右端点，它的覆盖次数才会被改变。因此，我们只需要将点\\(p\\)移动到覆盖到它的所有线段的最小右端点\\(p&#39;\\)，它仍然是其中一个最优解。因此，题目所求的最大覆盖点中，某条线段的右端点一定是一个最优解。\r\nb\r\n这道题的静态做法是，将每条线段的每个端点取出来进行排序，左端点对应值\\(+1\\)，右端点对应值\\(-1\\)，并且如果端点值相同，那么\\(+1\\)的端点应该在\\(-1\\)的端点的左边，对于端点\\(p\\)，它的属性\\(t\\)表示它的类型，\\(x\\)表示它的坐标。假设排好序后，其顺序\\(p_1,p_2,\\dots,p_{2n}\\)，那么我们需要求的是\\(\\displaystyle{\\max_{i=1}^{2n}\\left\\{\\sum_{j=1}^i\r\np_j.t\\right\\}}\\)，这是一个非常标准的前缀和问题。\r\n考虑使用这个思路将这个静态的做法转成动态的。如果往数据结构插入一个区间，那么就相当于向红黑树插入了两个节点（表示左端点和右端点的坐标）。每个节点\\(x\\)有三个属性\\(t,s,m\\)，它们分别表示节点\\(x\\)的权值（要么为\\(-1\\)，要么为\\(1\\)）；以节点\\(x\\)为根的子树权值\\(t\\)之和；以节点\\(x\\)为根的子树中，\\(t\\)的中序的前缀权值最大和，此外还可以添加一个属性\\(p\\)，表示以\\(x\\)为根的子树中，达到\\(t\\)的中序前缀最大和\\(x.m\\)的节点。我们可以写出\\(s,m\\)的关系：\r\n\r\n\\(x.s=x.left.s+x.t+x.right.s\\)\r\n\\(x.m=\\max\\{x.left.m,x.left.s+x.t,x.left.s+x.t+x.right.m\\}\\)\r\n\r\n在旋转的过程中，只需要维护好属性\\(s,m\\)的值即可。对于空节点\\(T.nil\\)，其\\(t,s,m\\)属性值均为\\(0\\)，\\(p\\)属性值指向自身，即\\(T.nil\\)。\r\nRB-UPDATE-M-AND-S(z)  z.s = z.left.s + z.t + z.right.s  z.m = z.left.m  z.p = z.left.p  if z.left.s + z.t &gt; z.m    z.m = z.left.s + z.t    z.p = z  if z.left.s + z.t + z.right.m &gt; z.m    z.m = z.left.s + z.t + z.right.m    z.p = z.right.p// 节点p, q必须存储在x的属性中，以便删除调用。INTERVAL-INSERT-OVERLAP(T, x)  let p, q be new nodes  x.p = p  x.q = q  p.key = x.int.low  p.t = 1  q.key = x.int.high  q.t = -1  RB-INSERT-M-AND-S(T, p)  RB-INSERT-M-AND-S(T, q)INTERVAL-DELETE-OVERLAP(T, x)  RB-DELETE-M-AND-S(T, x.p)  RB-DELETE-M-AND-S(T, x.q)FIND-POM(T)  return T.root.p\r\n上面的代码中，\\(T\\)是一棵支持属性\\(s,m,p,a\\)的树。按照如上改动之后，FIND-POM方法可以在\\(O(1)\\)的时间内返回最大覆盖点\\(T.root.p\\)，插入操作INTERVAL-INSERT-OVERLAP/删除操作INTERVAL-DELETE-OVERLAP则是调用了两次红黑树内部的插入/删除操作，其时间复杂度为\\(O(n\\lg\r\nn)\\)。对于子程序RB-INSERT-M-AND-S和内部调用的RB-INSERT-FIXUP-M-AND-S，以及子程序RB-DELETE-M-AND-S和内部调用的RB-DELETE-FIXUP-M-AND-S，其形式和题目17.3-5基本相同，区别在于题目17.3-5所调用的更新节点值子程序是RB-UPDATE-MINGAP，而这里的更新节点值子程序是RB-UPDATE-M-AND-S。\r\n17-2\r\na\r\n先初始化一个双向链表\\(L\\)，首尾相接。在第\\(i\\)轮中，迭代链表\\(m\\bmod(n-i+1)\\)次，找到这个节点后记录号码并且删除即可。如果这是一个双向链表，还可以考虑通过比较\\(m\\bmod(n-i+1)\\)和\\((n-i+1)-m\\bmod\r\n(n-i+1)\\)的大小，从而决定正向迭代还是反向迭代。\r\n这种暴力的算法的时间复杂度为\\(O(nm)\\)，由于\\(m\\)是一个常数，因此其时间复杂度可以简化为\\(O(n)\\)。\r\nb\r\n如果\\(m\\)是不定值，那么先将从\\(1\\)到\\(n\\)这\\(n\\)个数插入到红黑树中。假设节点\\(x\\)被删除之前，其排名值为\\(r\\)，那么删除后，接下来就是删除排名为\\(r+m_i-1\\bmod (n-i+1)+1\\)的节点。由于\\(n\\)轮迭代中，每轮搜索了一次节点和和删除一次节点，它们都是\\(O(n\\lg\r\nn)\\)的操作，因此其总体时间复杂度为\\(O(n\\lg\r\nn)\\)。这个算法由程序JOSEPHUS-UNCONSTANT-M给出。\r\nJOSEPHUS-UNCONSTANT-M(M, n)  let T be a new red-black tree that support size attribute.  let A be a new array  for i = 1 to n    OS-INSERT(T, i)  r = M[1]  INSERT(A, r)  OS-DELETE(T, OS-SELECT(T, r))  for i = 2 to n    r = (r + M[i] - 1) % (n - i + 1) + 1    x = OS-SELECT(r)    INSERT(A, x.key)    OS-DELETE(T, x)\r\n","categories":["算法导论"]},{"title":"算法导论18.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-18/exercises-1/","content":"\r\n18.1-1\r\n当\\(t=1\\)时，每个内部节点都将有\\(t=1\\)个键，这意味着它每个内部节点都有\\(2\\)个子节点，这说明此时\\(T\\)必须是一个满二叉树。令\\(n\\)表示这棵树的节点数，如果\\(\\nexists k\\)使得\\(n=2^k-1\\)成立，这说明\\(T\\)的所有叶子节点都不在同一层（否则必须是一棵完美二叉树），从而违反了性质4。因此必须满足\\(t&gt;1\\)。\r\n18.1-2\r\n可以看出，图18.1中的非根节点中的关键字数量从\\(2\\)到\\(3\\)不等。如果\\(t=2\\)，那么关键字数量的范围是\\(\\{1,2,3\\}\\)；如果\\(t=3\\)，那么关键字数量的范围是\\(\\{2,3,4,5\\}\\)；如果\\(t=4\\)，那么关键字数量的范围是\\(\\{3,4,5,6,7\\}\\)，此后\\(t\\)再大也不符合要求。因此\\(t\\)的值可能是\\(2\\)或\\(3\\)。\r\n18.1-3\r\n如下是所有满足要求的树。\r\ngraph TD  A1[2];B1[1];C1[&quot;3 4 5&quot;];  A1---B1;A1---C1;  A2[3];B2[&quot;1 2&quot;];C2[&quot;4 5&quot;];  A2---B2;A2---C2;  A3[4];B3[&quot;1 2 3&quot;];C3[&quot;5&quot;];  A3---B3;A3---C3;  A4[&quot;2 4&quot;];B4[&quot;1&quot;];C4[&quot;3&quot;];D4[&quot;5&quot;];  A4---B4;A4---C4;A4---D4;\r\n18.1-4\r\n可见，高度为\\(h\\)的\\(B\\)树在第\\(0\\)层只有\\(1\\)个节点，在第\\(1\\)层最多有\\(2t\\)个节点，在第\\(2\\)层最多有\\((2t)^2\\)个节点……因此，高度为\\(h\\)的最小度数为\\(t\\)的\\(B\\)树最多可以有\\(\\displaystyle{\\sum_{i=0}^h(2t)^i=\\dfrac{(2t)^{h+1}-1}{2t-1}}\\)个节点。那么这棵树可以存储\\(\\dfrac{(2t)^{h+1}-1}{2t-1}\\times(2t-1)=(2t)^{h+1}-1\\)个关键字。\r\n18.1-5\r\n最终会得到一个\\(t=2\\)的B树，并且这棵树的叶子节点都相同，为原来B树的黑高。每个黑色节点包含的关键字数为其原来在红黑树上的红色子节点数再加上\\(1\\)。更具体地说，对于一个黑色节点\\(x\\)，可以分为如下\\(4\\)种情况：\r\n\r\n如果\\(x\\)的\\(2\\)个子节点都是黑色，那么吸收后所得到的\\(x\\)仍然和原来一样，如下图所示：\r\n\r\ngraph TD    A((A));    a[α];b[β];    Z(( ))    classDef hide-appearance fill:transparent, stroke:transparent;    classDef hide-node display:none;    classDef red-node fill:red, color:white;    classDef black-node fill:black, color:white;    class A black-node;    class a,b hide-appearance;    class Z hide-node;    Z---A;A---a;A---b;        A&#x27;[A];    a&#x27;[α];b&#x27;[β];    Z&#x27;(( ))    class a&#x27;,b&#x27; hide-appearance;    class Z&#x27; hide-node;    Z&#x27;---A&#x27;;A&#x27;---a&#x27;;A&#x27;---b&#x27;;\r\n\r\n如果\\(x\\)的左子节点是红色，右子节点是黑色，那么吸收后当前节点将会有\\(2\\)个键，从左到右依次为\\(x.left.key,x.key\\)，如下图所示：\r\n\r\ngraph TD    A((A));B((B));    a[α];b[β];c[γ];    Z(( ))    classDef hide-appearance fill:transparent, stroke:transparent;    classDef hide-node display:none;    classDef red-node fill:red, color:white;    classDef black-node fill:black, color:white;    class B black-node;    class A,C red-node;    class a,b,c,d hide-appearance;    class Z hide-node;    Z---B;B---A;B---c;A---a;A---b;    A&#x27;[&quot;A B&quot;]    a&#x27;[α];b&#x27;[β];c&#x27;[γ];    Z&#x27;(( ))    class A,C red-node;    class a&#x27;,b&#x27;,c&#x27; hide-appearance;    class Z&#x27; hide-node;    Z&#x27;---A&#x27;;A&#x27;---a&#x27;;A&#x27;---b&#x27;;A&#x27;---c&#x27;;\r\n\r\n如果\\(x\\)的左子节点是黑色，右子节点是红色，那么吸收后当前色节点将会有\\(2\\)个键，从左到右依次为\\(x.key,x.right.key\\)，如下图所示：\r\n\r\ngraph TD    B((B));C((C));    a[α];b[β];c[γ];    Z(( ))    3(( ))    6(( ))    classDef hide-appearance fill:transparent, stroke:transparent;    classDef hide-node display:none;    classDef red-node fill:red, color:white;    classDef black-node fill:black, color:white;    class B black-node;    class A,C red-node;    class a,b,c,d hide-appearance;    class Z,3,6 hide-node;    Z---B;B---a;a---3;a---6;    B---C;C---b;C---c;    linkStyle 2,3 stroke:#0ff,stroke-width:0px     A&#x27;[&quot;B C&quot;]    a&#x27;[α];b&#x27;[β];c&#x27;[γ];    Z&#x27;(( ))    class A,C red-node;    class a&#x27;,b&#x27;,c&#x27; hide-appearance;    class Z&#x27; hide-node;    Z&#x27;---A&#x27;;A&#x27;---a&#x27;;A&#x27;---b&#x27;;A&#x27;---c&#x27;;\r\n\r\n如果\\(x\\)的\\(2\\)个子节点都是红色，那么吸收后当前节点将会有\\(3\\)个键，从左到右依次为\\(下x.left.key,x.key,x.right.key\\)，如下图所示：\r\n\r\ngraph TD    A((A));B((B));C((C));    a[α];b[β];c[γ];d[δ];    Z(( ))    classDef hide-appearance fill:transparent, stroke:transparent;    classDef hide-node display:none;    classDef red-node fill:red, color:white;    classDef black-node fill:black, color:white;    class B black-node;    class A,C red-node;    class a,b,c,d hide-appearance;    class Z hide-node;    Z---B;B---A;B---C;A---a;    A---b;C---c;C---d;    A&#x27;[&quot;A B C&quot;]    a&#x27;[α];b&#x27;[β];c&#x27;[γ];d&#x27;[δ];    Z&#x27;(( ))    class A,C red-node;    class a&#x27;,b&#x27;,c&#x27;,d&#x27; hide-appearance;    class Z&#x27; hide-node;    Z&#x27;---A&#x27;;A&#x27;---a&#x27;;A&#x27;---b&#x27;;A&#x27;---c&#x27;;    A&#x27;---d&#x27;;\r\n","categories":["算法导论"]},{"title":"算法导论17.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-17/exercises-3/","content":"\r\n17.3-1\r\n如下是左旋算法的改写版本INTERVAL-LEFT-ROTATE，它可以\\(O(1)\\)来维护每个节点的\\(max\\)属性。\r\nINTERVAL-LEFT-ROTATE(T, x)  y = x.right  x.right = y.left  if y.left != T.nill    y.left.p = x  y.p = x.p  if x.p == T.nil    T.root = y  else if x == x.p.left    x.p.left = y  else    x.p.right = y  y.left = x  x.p = y  y.max = x.max  x.max = max&#123;x.left.max, x.int.high, x.right.max&#125;\r\n17.3-2\r\n与算法INTERVAL-SEARCH相比，将要设计的算法INTERVAL-SEARCH'将不会搜索到就停止，而是不停地递归寻找节点，直到遇到空节点T.nil才结束。\r\nINTERVAL-SEARCH&#x27;(T, i)  y = T.nil  x = T.root  while x != T.nil    if i overlap x.int      y = x      // 更优秀的只会在x的左子树中。      x = x.left    else if x.left != T.nil and x.left.max &gt;= i.low      x = x.left    else      x = x.right\r\n17.3-3\r\n这个遍历所有覆盖区间的算法由程序INTERVAL-ENUMERATE-OVERLAP给出。由于子程序GEN-INTERVAL可以视作是对\\(T\\)进行有条件的前序遍历，每个节点只会被遍历一次；此外，对于\\(k\\)个可以输出的区间，这些区间至多分布在从根节点到各个叶节点的不同\\(k\\)条路径中，遍历这些所有路径需要\\(O(k\\lg\r\nn)\\)的时间。因此，INTERVAL-ENUMERATE-OVERLAP的时间复杂度为\\(O(\\min\\{n,k\\lg n\\})\\)。\r\nGEN-INTERVAL(T, x, i)  if i overlap x.int    INSERT(L, x.int)  if x.left != T.nil and x.left.max &gt;= i.low    GEN-INTERVAL(T, x.left, x)  if x.right != T.nil and x.int.low &lt;= i.high and x.right.max &gt;= i.low    GEN-INTERVAL(T, x.right, x)   INTERVAL-ENUMERATE-OVERLAP(T, i)  // L是一个全局变量，用来存储所有被遍历的区间。  Let L be an array  GEN-INTERVAL(T, T.root, i)  return L\r\n17.3-4\r\n为了保证程序能够找到正确的区间，我们假设如果区间的左端点相同，那么区间的中序顺序按照右端点的大小来决定。基于这个假设，查找算法退化成普通的查找算法，由INTERVAL-SEARCH-EXACTLY给出，因此其时间复杂度取决于树高，即\\(O(\\lg n)\\)。\r\nINTERVAL-SEARCH-EXACTLY(T, i)  x = T.root  while x != T.nil and not(i.low == x.int.low and i.high == x.int.high)    if i.low &lt; x.int.low or (i.low == x.int.low and i.high &lt; x.int.high)      x = x.left    else      x = x.right  return x\r\n17.3-5\r\n在题目12.7-1的基础上，我们再增加一个属性\\(x.mingap\\)来表示以\\(x\\)为根的子树中，最接近的两个数的差值。对于所有叶节点\\(l\\)，都有\\(l.mingap=\\infty\\)。\r\n那么，对于所有非叶节点，\\(mingap\\)属性满足\r\n\\[x.mingap=min\\{x.left.mingap,\r\nx.key-x.prev.key,x.succ.key-x.key,x.right.mingap\\}\\]\r\n因此，根据这个更新策略，可以在树上自底向上地更新。我们可以写出插入算法RB-INSERT-MINGAP和删除算法RB-DELETE-MINGAP的代码：\r\nRB-UPDATE-MINGAP(T, z)  z.mingap = min&#123;z.left.mingap, z.right.mingap&#125;  if z.prev != T.nil    z.mingap = z.key - z.prec.key  if z.succ != T.nil    z.mingap = min&#123;z.mingap, z.succ.key - z.key&#125;RB-INSERT-MINGAP(T, z)  x = T.root  y = T.nil  while x != T.nil    y = x    if z.key &lt; x.key      x = x.left    else      x = x.right  z.p = y  if y == T.nil    T.root = z  else if z.key &lt; y.key    y.left = z  else    y.right = z  z.left = T.nil  z.right = T.nil  z.color = RED  z.mingap = ∞  // 先维护好其前驱和后继  x = z  y = x.p  while y != T.nil and z == x.right    x = y    y = y.p  s = y  p = s.prev  p.succ = z  s.prev = z  w = z  while w != T.nil    RB-UPDATE-MINGAP(T, w)    w = w.p  OS-INSERT-FIXUP-MINGAP(T, w)OS-DELETE-MINGAP(T, z)  y = z  y-original-color = y.color  if z.left == T.nil    x = z.right    RB-TRANSPLANT(T, z, z.right)  else if z.right == T.nil    x = z.left    RB-TRANSPLANT(T, z, z.left)  else    y = RB-MINIMUM(T, z.right)    y-original-color = y.color    x = y.right    if y != z.right      RB-TRANSPLANT(T, y, y.right)      y.right = z.right      y.right.p = y         else       x.p = y    RB-TRANSPLANT(T, z, y)    y.left = z.left    y.rank&#x27; = z.rank&#x27;    y.left.p = y    y.color = z.color  w = x  while w != T.nil    RB-UPDATE-MINGAP(T, w)    w = w.p  if y-original-color == BLACK    OS-DELETE-FIXUP-MINGAP(T, x)\r\n其中，子程序OS-INSERT-FIXUP-MINGAP和题目17.2-2的OS-INSERT-FIXUP-BH基本相同，除了更新节点使用的是RB-UPDATE-MINGAP而不是RB-UPDATE-MINGAP；类似的，子程序OS-DELETE-FIXUP-MINGAP和题目17.2-2的OS-DELETE-FIXUP-BH有着相同的区别。\r\n\\(\\star\\)\r\n17.3-6\r\n令矩形数组是存储在\\(R\\)中，并且每个矩形具有4\\(个属性\\)x,X,y,Y\\(，分别表示\\)x\\(坐标的最小值和最大值；\\)y$坐标的最小值和最大值。\r\n那么考虑有一条平行于\\(y\\)轴的直线从左到右扫描整个图形。如果直线检测到有两条矩形的边界相交，那么说明这两个矩形相交。\r\n因此，具体做法是，先将所有矩形的左右边界按\\(x\\)坐标排序好，接下来从左到右枚举每条左右边界。如果遇到的是左边界，那么就需要判断树中有没有和当前边界相交，并将这条边界添加到区间树中；如果遇到的是有边界，那么就从树中删除掉这条边界。\r\n算法的具体过程由CHECK-RECTANGLE-INTERSEC给出。由于每个矩形的左右边界都总共需要\\(3\\)次\\(O(\\lg\r\nn)\\)的处理，再加上排序的时间，因此其总体时间复杂度为\\(O(n\\lg n)\\)。\r\nCHECK-RECTANGLE-INTERSEC(R, n)  let E be a new array  for i = 1 to n    if C[i].x &gt; C[i].X      exchange C[i].x with C[i].X    if C[i].y &gt; C[i].Y      exchange C[i].y with C[i].Y    let e, e&#x27; be new edges    let z be a new node    z.int.low = C[i].y    z.int.high = C[i].Y    e.x, e.z, e.type = C[i].x, z, 1    e&#x27;.x, e&#x27;.z, e&#x27;.type = C[i].X, z, -1    INSERT(E, e)    INSERT(E, e&#x27;)  sort E using this rule : e.x &lt; e&#x27;.x or (e.x == e&#x27;.x and e.type &lt; e&#x27;.eype)  Let T be a new interval tree  for e in E    if e.type == 1      if INTERVAL-SEARCH(T, x.int) != T.nil        return True      else        INTERVAL-INSERT(T, x)    else      INTERVAL-DELETE(T, x)  return False\r\n","categories":["算法导论"]},{"title":"算法导论18.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-18/exercises-2/","content":"\r\n18.2-1\r\n如下是在\\(t=2\\)的B树中，按序插入这些字母的姿态变化过程。\r\n\r\nF\r\n\r\ngraph TD  A[F];\r\n\r\nS\r\n\r\ngraph TD  A[F S];\r\n\r\nQ\r\n\r\ngraph TD  A[F Q S];\r\n\r\nK\r\n\r\ngraph TD  A[Q];B[F K];C[S];  A---B;A---C;\r\n\r\nC\r\n\r\ngraph TD  A[Q];B[C F K];C[S];  A---B;A---C;\r\n\r\nL\r\n\r\ngraph TD  A[F Q];B[C];C[K L];D[S];  A---B;A---C;A---D;\r\n\r\nH\r\n\r\ngraph TD  A[F Q];B[C];C[H K L];D[S];  A---B;A---C;A---D;\r\n\r\nT\r\n\r\ngraph TD  A[F Q];B[C];C[H K L];D[S T];  A---B;A---C;A---D;\r\n\r\nV\r\n\r\ngraph TD  A[F Q];B[C];C[H K L];D[S T V];  A---B;A---C;A---D;\r\n\r\nW\r\n\r\ngraph TD  A[F Q T];B[C];C[H K L];D[S];  E[V W]  A---B;A---C;A---D;A---E;\r\n\r\nM\r\n\r\ngraph TD  A[Q];B[F K];C[T];D[C];  E[H];F[L M];G[S];H[V W];  A---B;A---C;B---D;B---E;  B---F;C---G;C---H;\r\n\r\nR\r\n\r\ngraph TD  A[Q];B[F K];C[T];D[C];  E[H];F[L M];G[R S];H[V W];  A---B;A---C;B---D;B---E;  B---F;C---G;C---H;\r\n\r\nN\r\n\r\ngraph TD  A[Q];B[F K];C[T];D[C];  E[H];F[L M N];G[R S];H[V W];  A---B;A---C;B---D;B---E;  B---F;C---G;C---H;\r\n\r\nP\r\n\r\ngraph TD  A[Q];B[F K M];C[T];D[C];  E[H];F[N P];G[R S];H[V W];  I[L];  A---B;A---C;B---D;B---E;  B---I;B---F;C---G;C---H;\r\n\r\nA\r\n\r\ngraph TD  A[Q];B[F K M];C[T];D[A C];  E[H];F[N P];G[R S];H[V W];  I[L];  A---B;A---C;B---D;B---E;  B---I;B---F;C---G;C---H;\r\n\r\nB\r\n\r\ngraph TD  A[Q];B[F K M];C[T];D[A B C];  E[H];F[N P];G[R S];H[V W];  I[L];  A---B;A---C;B---D;B---E;  B---I;B---F;C---G;C---H;\r\n\r\nX\r\n\r\ngraph TD  A[Q];B[F K M];C[T];D[A B C];  E[H];F[N P];G[R S];H[V W X];  I[L];  A---B;A---C;B---D;B---E;  B---I;B---F;C---G;C---H;\r\n\r\nY\r\n\r\ngraph TD  A[Q];B[F K M];C[T W];D[A B C];  E[H];F[N P];G[R S];H[X Y];  I[L];J[V];  A---B;A---C;B---D;B---E;  B---I;B---F;C---G;C---J;  C---H;\r\n\r\nD\r\n\r\ngraph TD  A[K Q];B[B F];C[M];D[T W];  E[A];F[C D];G[H];H[L];  I[N P];J[R S];K[V];L[X Y];  A---B;A---C;A---D;B---E;  B---F;B---G;C---H;C---I;  D---J;D---K;D---L;\r\n\r\nZ\r\n\r\ngraph TD  A[K Q];B[B F];C[M];D[T W];  E[A];F[C D];G[H];H[L];  I[N P];J[R S];K[V];L[X Y Z];  A---B;A---C;A---D;B---E;  B---F;B---G;C---H;C---I;  D---J;D---K;D---L;\r\n\r\nE\r\n\r\ngraph TD  A[K Q];B[B F];C[M];D[T W];  E[A];F[C D E];G[H];H[L];  I[N P];J[R S];K[V];L[X Y Z];  A---B;A---C;A---D;B---E;  B---F;B---G;C---H;C---I;  D---J;D---K;D---L;\r\n18.2-2\r\n\r\n考虑算法B-TREE-SEARCH的DISK-READ。由于这个DISK-READ每次都是读取当前节点的子节点信息，因此一路向下查找并不会造成读取冗余。\r\n考虑算法B-TREE-CREATE的DISK-WRITE。树\\(T\\)只会被建立一次，因此这里只会写入一次节点，没有写入冗余。\r\n考虑算法B-TREE-SPLIT-CHILD第16-18行的DISK-WRITE。节点\\(x\\)添加了一个关键字和一个子节点指针；\\(y\\)节点挪去了一半的关键字和子节点指针到新节点\\(z\\)。也就是说，\\(x,y,z\\)都进行了相应的变化，需要更新，因此这里没有写入冗余。\r\n考虑B-TREE-INSERT-NONFULL的DISK-READ和DISK-WRITE。DISK-READ的分析和B-TREE-SEARCH一致，它都是只读取当前节点的某一个子节点的信息，向下查找不会造成读取冗余。DISK-WRITE只是对叶节点进行了一次写入（因为插入了一个元素），因此DISK-WRITE操作也不是冗余的。\r\n\r\n总而言之，无论是DISK-READ还是DISK-WRITE操作，都没有冗余。\r\n18.2-3\r\n可以注意到，如下图这棵B树目前每一个节点都是满的，它的高度达到了最小高度\\(2\\)。\r\ngraph TD  A[4 8 12];B[1 2 3];C[5 6 7];D[9 10 11];  E[13 14 15]  A---B;A---C;A---D;A---E;\r\n这棵B树不可能是某一个插入操作序列所得到的一棵B树。不失一般性，假设它的根节点为\\(r\\)。在插入这\\(15\\)个关键字的最后一个关键字之前的B树\\(T&#39;\\)，它只有\\(2\\)层，考虑两种情况：\r\n\r\n存在某个叶子节点\\(l\\)不是满的，那么根节点\\(r\\)必定是满的。当进行这个插入操作时，先检测到根节点\\(r\\)是满的，那么根节点\\(r\\)必定需要拆分，从而导致这棵树的树高增加。\r\n所有叶子节点都是满的，只有根节点不是满的。这种情况是不可能出现的，如果根节点非满，那这棵B树最多只有\\(4\\)个节点，最多存储满\\(3\\times3+2=11\\)个关键字，不到\\(15\\)个。\r\n\r\n因此哪怕只有\\(14\\)个关键字且高度为\\(2\\)的B树，按照上面的论证，插入一个关键字后，树必定会增高，因此不存在某种插入序列使得这棵B树保持最小的高度，也就是\\(2\\)。\r\n\\(\\star\\)\r\n18.2-4\r\n首先，每次插入操作都保证了每个节点包含至少一个关键字，因此第\\(n\\)次操作的节点数\\(N(n)\\)不超过\\(n\\)，因此有\\(N(n)=O(n)\\)。同时，每个节点最多只能包含\\(3\\)个关键字，因此\\(N(n)\\ge n/3\\)，因此可以得到\\(N(n)=\\Omega(n)\\)。最终可以得知\\(N(n)=\\Theta(n)\\)。\r\n更进一步的分析是，由于每次插入的关键字都比之前的大，因此插入算法B-TREE-INSERT-NONFULL只会遍历最右边的子节点。并且，每次分裂算法执行后，左边的子节点都只剩下一个元素，此后这些节点再也不会被遍历到。也就是说，只有从\\(r\\)到最右边的叶子节点路径上的所有节点才有可能有多个关键字。因此接下来我们只考虑这条路径上的所有节点。\r\n可以观察得到，这条路径上有\\(f(n)\\)个节点，其中\\(f(n)=j\\)当且仅当满足\\(2^{j}+j\\le n+2\\le 2^{j+1}+j\\)。\r\n此外，还可以得到这条路径上，倒数第\\(i\\)个节点的关键字个数具有一定的规律，只要路径长度开始超过\\(i\\)，那么从第\\(2\\)个值起（第\\(1\\)个值是特殊的，为\\(1\\)），其节点数是一个周期为\\(2^i\\)的循环节，先是\\(2^{i-1}-1\\)个\\(1\\)，再是\\(2^{i-1}\\)个\\(2\\)，然后是一个\\(3\\)。总而言之，这条路径上的关键字总数\\(g(n)\\)不超过\\(3n\\)。\r\n因此\\(N(n)=n-g(n)+f(n)\\)，其中\\(g(n)=\\Theta(f(n))\\)，因此\\(N(n)=\\Theta(n)\\)。以下表的第\\(n\\)行第\\(i\\)个值表示最右路径中，插入关键字\\(n\\)后，倒数第\\(i\\)个节点的关键字个数。\r\n1232 13 12 23 22 33 1 12 2 13 2 12 3 13 1 22 2 23 2 22 3 23 1 32 2 1 13 2 1 12 3 1 13 1 2 12 2 2 13 2 2 12 3 2 13 1 3 12 2 1 23 2 1 22 3 1 23 1 2 22 2 2 23 2 2 22 3 2 23 1 3 22 2 1 33 2 1 1 12 3 1 1 13 1 2 1 12 2 2 1 13 2 2 1 12 3 2 1 13 1 3 1 12 2 1 2 13 2 1 2 12 3 1 2 13 1 2 2 12 2 2 2 13 2 2 2 12 3 2 2 13 1 3 2 12 2 1 3 13 2 1 1 22 3 1 1 23 1 2 1 22 2 2 1 23 2 2 1 22 3 2 1 23 1 3 1 22 2 1 2 23 2 1 2 22 3 1 2 23 1 2 2 22 2 2 2 23 2 2 2 22 3 2 2 23 1 3 2 22 2 1 3 23 2 1 1 32 3 1 1 1 13 1 2 1 1 12 2 2 1 1 13 2 2 1 1 12 3 2 1 1 13 1 3 1 1 12 2 1 2 1 13 2 1 2 1 12 3 1 2 1 13 1 2 2 1 12 2 2 2 1 13 2 2 2 1 12 3 2 2 1 13 1 3 2 1 12 2 1 3 1 13 2 1 1 2 12 3 1 1 2 13 1 2 1 2 12 2 2 1 2 13 2 2 1 2 12 3 2 1 2 13 1 3 1 2 12 2 1 2 2 13 2 1 2 2 12 3 1 2 2 13 1 2 2 2 12 2 2 2 2 13 2 2 2 2 12 3 2 2 2 13 1 3 2 2 12 2 1 3 2 13 2 1 1 3 12 3 1 1 1 23 1 2 1 1 22 2 2 1 1 23 2 2 1 1 2\r\n18.2-5\r\n只需要判断当且节点是不是一个叶子节点即可。如果是叶子节点，那么使用另一个最小度数\\(t&#39;\\)然后再对这个叶子节点进行相同的分割操作即可。\r\n如下是对插入算法和节点拆分算法B-TREE-SPLIT-CHILD的改写：\r\nCAL-T(x)  if x.leaf == True    return t&#x27;  else    return tB-TREE-SPLIT-CHILD&#x27;(x, i)  y = x.c_&#123;i&#125;  z = ALLOCATE-NODE()  z.leaf = y.leaf  z.n = CAL-T(z) - 1  for j = 1 to CAL-T(z) - 1    z.key_&#123;j&#125; = y.key_&#123;j+t&#125;  if not y.leaf    for j = 1 to t      z.c_&#123;j&#125; = y.c_&#123;j+t&#125;  y.n = CAL-T(y) - 1  for j = x.n + 1 downto i + 1    x.c_&#123;j+1&#125; = x.c_&#123;j&#125;  x.c_&#123;j+1&#125; = z  for j = x.n downto i    x.key_&#123;j+1&#125; = x.key_&#123;j&#125;  x.key_&#123;i&#125; = y.key_&#123;CAL-T(y)&#125;  x.n = x.n + 1  DISK-WRITE(y)  DISK-WRITE(z)  DISK-WRITE(x)B-TREE-INSERT&#x27;(T, k)  r = T.root  if r == 2 * CAL-T(r) - 1    s = B-TREE-SPLIT-ROOT(T)    B-TREE-INSERT-NONFULL(s, k)  else B-TREE-INSERT-NONFULL(r, k)B-TREE-INSERT-NONFULL&#x27;(x, k)  i = x.n  if x.leaf    while i &gt;= 1 and k &lt; x.key_&#123;i&#125;      x.key_&#123;i + 1&#125; = x.key_&#123;i&#125;      i = i - 1    x.key_&#123;i + 1&#125; = k    x.n = x.n + 1    DISK-WRITE(x)  else    while i &gt;= 1 and k &lt; x.key_&#123;i&#125;      i = i - 1    i = i + 1    DISK-READ(x, c_&#123;i&#125;)    if x.c_&#123;i&#125;.n == 2 * CAL-T(x.c_&#123;i&#125;) - 1      B-TREE-SPLIT-CHILD&#x27;(x, i)      if k &gt; x.key_&#123;i&#125;        i = i + 1    B-TREE-INSERT-NONFULL&#x27;(x.c_&#123;i&#125;, k)\r\n18.2-6\r\n由于单个节点中有\\(O(t)\\)个关键字，因此节点内部进行一次二分查找需要\\(O(\\lg t)\\)的时间。由于整棵树的高度为\\(O(\\log_t\r\nn)\\)，因此在B树中进行一次元素查找需要\\(O(\\lg t\\cdot \\log_t n)=O(\\lg\r\nn)\\)的时间，这种查找方式最终将时间复杂度中的\\(t\\)消去了。\r\n18.2-7\r\n由于进行一次查找操作需要\\(h=O(\\log_t{n})\\)次的读取，因此花费在磁盘读取上面的时间为\\(h\\cdot (a+bt)=O((a+bt)\\log_{t}n)\\)。\r\n令\\(f(t)=(a+bt)\\log_t n=\\dfrac{\\ln n}{\\ln\r\nt}(a+bt)\\)。可以求得\\(f&#39;(t)=\\ln\r\nn\\left(\\dfrac{b}{\\ln t}-\\dfrac{a+bt}{t\\ln^2 t}\\right)\\)。\r\n令\\(f&#39;(t)=0\\)，可以化简得到\\(b=\\dfrac{a+bt}{t\\ln t}\\)。\r\n代入\\(a=5,b=10\\)，使用Mathematica求解这个方程，可以得到\\(t\\approx 3.18097\\)。由于\\(t\\)为整数，且\\(f(3)&lt;f(4)\\)，因此取\\(t=3\\)是一个最优值。\r\n","categories":["算法导论"]},{"title":"算法导论18.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-18/exercises-3/","content":"\r\n18.3-1\r\n如下是整棵树的初始状态：\r\ngraph TD    A[E L P T X];B[A C];C[J K];D[N O];    E[Q R S];F[U V];G[Y Z];    A---B;A---C;A---D;A---E;    A---F;A---G;\r\n\r\nC\r\n\r\ngraph TD    A[L P T X];B[A E J K];D[N O];    E[Q R S];F[U V];G[Y Z];    A---B;A---D;A---E;    A---F;A---G;\r\n\r\nC\r\n\r\ngraph TD    A[L P T X];B[A E J K];D[N O];    E[Q R S];F[U V];G[Y Z];    A---B;A---D;A---E;    A---F;A---G;\r\n\r\nP\r\n\r\ngraph TD    A[L Q T X];B[A E J K];D[N O];    E[R S];F[U V];G[Y Z];    A---B;A---D;A---E;    A---F;A---G;\r\n\r\nV\r\n\r\ngraph TD    A[L Q X];B[A E J K];D[N O];    E[R S T U];G[Y Z];    A---B;A---D;A---E;    A---G;\r\n18.3-2\r\n首先写出两个子程序：B-TREE-PREDECESSOR-INTERNAL-NODE和B-TREE-SUCCESSOR-INTERNAL-NODE，用于求解某个内部节点\\(x\\)的第\\(i\\)个键\\(x.key_i\\)的前驱和后继。\r\nB-TREE-PREDECESSOR-INTERNAL-NODE(z, i)  x = z.c_&#123;i&#125;  while not x.leaf  DISK-READ(x.c_&#123;x.n + 1&#125;)    x = x.c_&#123;x.n + 1&#125;  return x.key_&#123;x.n&#125;B-TREE-SUCCESSOR-INTERNAL-NODE(z, i)  x = z.c_&#123;i + 1&#125;  while not x.leaf    DISK-READ(x.c[1])    x = x.c_&#123;1&#125;  return x.key_&#123;1&#125;\r\n那么我们接下来可以按照每个步骤写出B-TREE-DELETE的过程。\r\n// 节点x的第i个键和它的两个子节点x.c_&#123;i&#125;，x.c_&#123;i + 1&#125;合并（需要保证这两个子节点的键数都为t-1）。B-TREE-PUSHDOWN(T, x, i)  y = x.c_&#123;i&#125;  z = x.c_&#123;i + 1&#125;  // 将z合并到y，并插入k  y.key_&#123;t&#125; = k  for j = 1 to t - 1    y.key_&#123;t + j&#125; = z.key_&#123;j&#125;  for j = 1 to t    y.c_&#123;t + j&#125; = z.c_&#123;j&#125;  // 从x中删去z和k。  for j = i + 1 to x.n    x.key_&#123;j - 1&#125; = x.key_&#123;j&#125;  for j = i + 2 to x.n + 1    x.c_&#123;j - 1&#125; = x.c_&#123;j&#125;  x.n = x.n - 1  if x.n &gt; 0    DISK-WRITE(x)  else    // 如果x被删光了，那么y成为新的根节点。    T.root = y  DISK-WRITE(y)B-TREE-DELETE(T, k)  x = T.root  if x == T.nil    error &quot;not find key: &quot; k  DISK-READ(x)  while not x.leaf    i = 1    while i &lt;= x.n and x.key_&#123;i&#125; &lt; k      i = i + 1    if i &lt;= x.n and x.key_&#123;i&#125; == k      //进入Case 2      //Case 2a      DISK-READ(x.c_&#123;i&#125;)      y = x.c_&#123;i&#125;      if y.n &gt;= t        k&#x27; = B-TREE-PREDECESSOR-INTERNAL-NODE(x, i)        x.key_&#123;i&#125; = k&#x27;        DISK-WRITE(x)        k = k&#x27;        x = y      else         //Case 2b        DISK-READ(x.c_&#123;i + 1&#125;)        z = x.c_&#123;i + 1&#125;        if z.n &gt;= t          k&#x27; = B-TREE-SUCCESSOR-INTERNAL-NODE(x, i)          x.key_&#123;i&#125; = k&#x27;          DISK-WRITE(x)          k = k&#x27;          x = z        //Case 2c        else          B-TREE-PUSHDOWN(T, x, i)    else      //进入Case 3，此时x.c_&#123;i&#125;为k所在子树。      DISK-READ(x.c_&#123;i&#125;)      y = x.c_&#123;i&#125;      if y.n == t - 1        if i &gt; 1          l = x.c_&#123;i - 1&#125;          DISK-READ(l)        if i &lt;= x.n          r = x.c_&#123;i + 1&#125;          DISK-READ(r)        // Case 3a        if i &gt; 1 and l.n &gt;= t          k&#x27; = l.key_&#123;l.n&#125;          t&#x27; = l.c_&#123;l.n + 1&#125;          l.n = l.n - 1          for j = y.n downto 1            y.key_&#123;j + 1&#125; = y.key_&#123;j&#125;          for j = y.n + 1 downto 1            y.c_&#123;j + 1&#125; = y.c_&#123;j&#125;          y.key_&#123;1&#125; = k&#x27;          y.c_&#123;1&#125; = t&#x27;          y.n = y.n + 1          DISK-READ(x)          DISK-READ(l)          DISK-READ(y)        else if i &lt;= x.n and r.n &gt;= t          k&#x27; = r.key_&#123;1&#125;          t&#x27; = r.c_&#123;1&#125;          for j = 2 to r.n            r.key_&#123;j - 1&#125; = r.key_&#123;j&#125;          for j = 2 to r.n + 1            r.c_&#123;j - 1&#125; = r.c_&#123;j&#125;          r.n = r.n - 1          y.key_&#123;y.n + 1&#125; = x.key_&#123;i&#125;          y.c_&#123;y.n + 2&#125; = t&#x27;          x.key_&#123;i&#125; = k&#x27;          y.n = y.n + 1          DISK-READ(x)          DISK-READ(r)          DISK-READ(y)        // Case 3b        else          if i == x.n + 1            i = i - 1          B-TREE-PUSHDOWN(T, x, i)      else        x = y  //目前x是某个叶子叶子节点，即Case 1，并且保证了x.n &gt;= t。  i = -1  for j = 1 to x.n    if x.key_&#123;j&#125; == k      i = j  if i == -1    error &quot;not find key: &quot; k  else    for j = i + 1 to x.n      x.key_&#123;j - 1&#125; = x.key_&#123;j&#125;    x.n = x.n - 1    DISK-WRITE(x)\r\n","categories":["算法导论"]},{"title":"算法导论1.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-1/exercises-1/","content":"\r\n1.1-1\r\n\r\nB站上一系列的视频所需要根据播放时长、播放量等等一些参数进行排序。\r\n百度地图等等寻找最优路径的系统。一般寻找物理路径长度最短或者是到达时间最少的路径。\r\n\r\n1.1-2\r\n内存空间。如果是涉及到需要通信的算法，那么还需要考虑通信量，通信开销等等。如果涉及浮点数运算，那么还要考虑精度。\r\n1.1-3\r\n以链表和顺序表进行对比。链表相比顺序表的优点是，删除操作和插入操作都可以达到\\(O(1)\\)的时间复杂度，但是链表的缺点是它不支持随机访问，必须一个个元素进行遍历。\r\n1.1-4\r\n最短路径问题和TSP问题的相似之处在于它们的最终目标都是求出一条最优的路径用于解决问题。不同之处在于，最短路径有明确的起点和终点，TSP问题没有；最短路径问题所求路径并非必须经过图上所有点，而TSP问题所求路径必须经过图上所有点。\r\n1.1-5\r\n其实这个问题似乎仅仅取决于问题的严谨程度。\r\n以字符串匹配为例，如果是字符串的数量非常小，那么直接通过字符串本身匹配就能得到精准的结果；如果数量字符串的数量非常大，那么就考虑使用哈希值进行更高效的匹配。虽然由于哈希冲突，可能导致原本不匹配的两个字符串匹配上了，但是这个概率很微小，这种方法近似于最优的精准匹配。\r\n1.1-6\r\nHangman猜词游戏：\r\n一开始时，玩家A掌握一个单词\\(s\\)，并留下和单词长度对应数量的空白和下划线。\r\n玩家B负责猜测这个单词是否含有某一个字母\\(c\\)，如果猜测正确，那么A将在所有对应的位置上填上字母\\(c\\)。否则使用一次猜测错误的机会。B最多有\\(7\\)次猜测错误的机会。\r\n目标是玩家B是否能猜测出整个单词，这个问题的目的是帮助B猜出这个单词。\r\n","categories":["算法导论"]},{"title":"算法导论15 Problems 答案","url":"/introduction-to-algorithms/chapter-15/problems/","content":"\r\n15-1\r\na\r\nCOIN-CHANGING-SPECIAL(n)  A = [25, 10, 5, 1]  B = &#123;&#125;  for each m in A    k = ⌊n / m⌋    // 使用k个价值为m的硬币    B = B ∪ &#123;m&#125; × k    n = n - k * m  return B\r\n在最优情况下，\\(25\\)分硬币可以由\\(2\\)个\\(10\\)分硬币和\\(1\\)个\\(5\\)分硬币表示出；类似的，\\(10=5\\times 2,5=1\\times 5\\)。\r\n不难证明这个问题满足最优子结构，如果一个拼凑\\(n\\)分硬币的最优解\\(S\\)的子集\\(S&#39;\\)不是拼凑\\(m\\)分硬币的最优解，那么存在一个最优解\\(S&#39;&#39;\\)是拼凑\\(m\\)枚硬币的最优解，从而构造出一个拼凑\\(n\\)分硬币的最优解\\((S-S&#39;)\\cup\r\nS&#39;&#39;\\)，引出了矛盾。因此这个问题满足最优子结构。\r\n不难发现这个问题满足贪心选择性质。在一个最优解中，最终\\(10\\)分硬币必定最多\\(2\\)个，\\(5\\)分硬币最多为\\(1\\)个。对于每个大面额硬币\\(n\\)，它总能由多个小面额硬币表示出来。因此如果一个解没有贪心地使用大硬币来表示，那么以这个大硬币额度为子问题的解必定不是最优的。因此满足贪心选择性质。\r\nb\r\n最优子结构的证明过程与问题15-1-a相同。\r\n假设一个最优解为\\(S=(s_0,s_1,\\dots,s_k)\\)。那么\\(\\forall i &lt; k,s_i&lt;\r\nc\\)总是成立的。因为如果\\(\\exists j&lt;\r\nk,s_j\\ge c\\)，那么可以考虑用\\(1\\)枚价值为\\(c^{j+1}\\)的硬币代替这\\(c\\)枚价值为\\(c^{j}\\)的硬币，从而减少了\\(c-1\\)枚硬币。\r\n假设一个解\\(S&#39;\\)没有贪心选择尽可能大的硬币，也就是说，一个超过价值\\(c^j\\)的子问题却没有用价值为\\(c^j\\)的硬币拼凑，那么哪怕\\(\\forall j&lt; i\\)，每一种价值为\\(c^{j}\\)的硬币都使用\\(c-1\\)个，都只能凑出\\((c-1)(c^0+c^1+c^2+\\dots+c^{i-1})=c^i-1\\)的价值。因此在此情况下，必定存在一个\\(j&lt; i,s_j&#39;\\ge\r\nc\\)成立，和最优解成立的条件矛盾。因此这个问题下满足贪心选择性质。\r\n故这个算法的贪心策略是正确的。\r\nc\r\n如果硬币币种为\\([1,4,6]\\)，需要拼凑的值为\\(8\\)，那么贪心算法下的解为\\([1,1,6]\\)，但是最优解为\\([4,4]\\)。\r\nd\r\n考虑使用动态规划算法来解决本题。这个问题和完全背包问题一样，每种硬币的币值视为物品的“重量”，价值视为\\(1\\)，区别仅在于这里求的是必定装满重量\\(k\\)后，价值之和的最小值。\r\n令状态\\(f[i, j]\\)表示前\\(i\\)种物品凑出的重量和为\\(j\\)时，最小的总价值。对于当前状态，第\\(i\\)种物品有两种决策：取或者是不取。如果不取，那么相当于从状态\\(f[i-1,j]\\)转移而来；如果取，那么相当于从\\(f[i,j-w_i]\\)处取一个物品\\(i\\)转移而来，并且从中择优转移。因此不难写出如下状态转移方程：\r\n\\(f[i,j]=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0  &amp; &amp; \\text{if}\\quad i=0\\land j=0 \\\\\r\n  &amp;+\\infty  &amp; &amp; \\text{if}\\quad i=0\\land j\\neq0 \\\\\r\n  &amp;f[i-1,j]&amp; &amp; \\text{if} \\quad i&gt;0 \\land j&lt; w_i\\\\\r\n  &amp;\\in\\{f[i-1,j],f[i,j-w_i]+1\\}&amp; &amp; \\text{if} \\quad i&gt;0\r\n\\land j\\ge w_i\\\\\r\n\\end{aligned}\\right.\\)\r\n因此最终答案为\\(f[n,k]\\)。\r\n算法CHANGE-PROBLEM给出了具体的实现过程。第2-3行的嵌套循环说明这个算法的时间复杂度为\\(O(nk)\\)。\r\nCHANGE-PROBLEM(w, n, k)  let f[0 : k] be a new array by +∞  let pre[0 : k] be a new array  f[0] = 0  for i = 1 to n    for j = w[i] to k      if f[j - w[i]] + 1 &lt; f[i]        pre[j] = i        f[i] = f[j - w[i]] + 1  B = &#123;&#125;  j = k  while k &gt; 0    x = w[pre[k]]    B = B ∪ &#123;x&#125;    k = k - x  return f[W]\r\n15-2\r\na\r\n将每个任务\\(a_i\\)按照运行时间升序排序，然后按这个顺序执行每个任务即可。\r\n最优子结构的证明：对于一个最优解\\(S\\)，完成了\\(i\\)个任务后，子问题则为剩下的\\(n-i\\)个任务，如果这\\(n-i\\)不是按照最优的方式进行的，那么存在一个更优的解\\(S&#39;\\)进行这\\(n-i\\)个任务。那么由于两个步骤是独立的，将\\(S\\)的关于前\\(i\\)个任务的解和\\(S&#39;\\)组合就能得出一个比\\(S\\)更优秀的解\\(S&#39;&#39;\\)，这与\\(S\\)是最优秀的矛盾。\r\n接下来证明贪心选择性质。\r\n假设任务为\\(\\{b_1,b_2,\\dots,b_n\\}\\)，那么有\\(\\displaystyle{C_{b_i}=\\sum_{j=1}^i\r\np_{b_j}}\\)。平均时间\\(\\overline{C}\\)可以如下计算：\r\n\\(\\begin{aligned}\r\n\\overline{C} &amp;= \\dfrac{1}{n}\\sum_{i=1}^n C_{b_i}\\\\\r\n&amp;=\\dfrac{1}{n} \\sum_{i=1}^n\\sum_{j=1}^i p_{b_j}\\\\\r\n&amp;=\\dfrac{1}{n}\\sum_{j=1}^n(n-j+1) p_{b_j}\r\n\\end{aligned}\\)\r\n令序列\\(\\{a\\}\\)为\\(a_j=n-j+1,\\{c\\}\\)则是\\(p\\)的一个置换，可以发现\\(a\\)是降序的。那么为了最小化\\(\\overline{C}\\)的值，\\(\\{c\\}\\)必须是升序的。对于一个解\\(S\\)，如果\\(\\exists i&lt;\r\nj,c_i&gt;c_j\\)成立，那么考虑构造出一个解\\(S&#39;\\)，它是将解\\(S\\)中的\\(c_i\\)与\\(c_j\\)交换，那么交换前后的平均完成时间的变化为\\(\\dfrac{1}{n}(a_jb_i+a_ib_j)-\\dfrac{1}{n}(a_jb_j+a_ib_i)=-\\dfrac{(a_j-a_i)(b_j-b_i)}{n}&lt;0\\)。从而说明解\\(S&#39;&#39;\\)比\\(S\\)更优。由此证明贪心选择性质成立。\r\n因此这个贪心策略是正确的。算法的整个过程主要在于为\\(\\{p\\}\\)排序，时间复杂度为\\(O(n\\lg n)\\)。\r\nb\r\n这个贪心算法是，处理器总是优先处理剩余运行时间最短的任务。也就是说，如果当前任务\\(a_1\\)剩下的运行时间为\\(p_1\\)，但是随后插入一个运行时间为\\(p_2\\)的任务\\(a_2\\)，且\\(p_2&lt; p_1\\)，那么就挂起任务\\(a_1\\)去运行\\(a_2\\)。\r\n考虑如此场景：假设为当前时刻为\\(t=r_2\\)，任务\\(a_1\\)正在被执行，剩余时间为\\(p_1\\)，此时插入一个任务\\(a_2\\)，剩余时间为\\(p_2(p_2&lt; p_1)\\)。令决策\\(S&#39;\\)表示不立刻挂起\\(a_1\\)，令\\(P_t\\)表示从\\(t\\)时刻开始，决策\\(S&#39;\\)下执行任务\\(a_1\\)或者是\\(a_2\\)的时间片，也就是说，\\(|P|=p_1+p_2\\)。那么可以发现，无论是\\(a_1\\)后执行完还是\\(a_2\\)后执行完，并不影响\\(P_t\\)中的最大值，因此我们需要其中一个任务尽快执行完。那么，只有当\\(P_t\\)中的前面的一段连续时间片分给\\(a_1\\)或者是\\(a_2\\)时，才能够保证这两个任务之一才能执行完，从而保证这两个任务的执行总时间最小化。由于\\(p_2&lt;p_1\\)，因此将\\(P_t\\)中的前\\(p_2\\)个时间片分给\\(a_2\\)才是最优的。由此构造出决策\\(S\\)。由于对\\(P_t\\)中第一个时间片中处理不同，因此\\(S\\)和\\(S&#39;\\)是不一样的。因此我们从\\(S&#39;\\)得到了一个更优秀的\\(S\\)。因此贪心选择性质成立。\r\n最终，这个算法的贪心策略是正确的。使用最小优先队列维护每个任务的加入和完成时间可以以\\(O(n\\lg\r\nn)\\)的时间复杂度计算出结果。具体过程由算法GEN-SCHEDULE给出。因为使用了最小优先队列，整个过程的时间复杂度为\\(O(n\\lg n)\\)。\r\n// 假设所有任务已经按释放时间r排好序。GEN-SCHEDULE(r, p, n)  // 优先队列的排序关键字为time，也就是剩余运行时间，卫星数据为ID，也就是当前任务编号。  let Q be a new MIN-PRIORITY  l = 1  r = 1  // 上一次处理的时刻。  pre-time = 0  while l &lt;= n    time = r[i] - pre-time        while not PRIORITY-EMPTY(Q) and time &gt; 0      p = EXTRACT-MIN(Q)      w = min&#123;time, p.time&#125;      time = time - w      print run task p.ID w time       p.time = p.time - w      if p.time == 0        print task p.ID finish       else        INSERT(Q, p)    while r &lt;= n      let p be a new node      p.time = p[i]      p.ID = r[i]      INSERT(Q, p)      r = r + 1    l = r  while not PRIORITY-EMPTY(Q)    p = EXTRACT-MIN(Q)    print run task p.ID p.time time units    print task p.ID finish \r\n","categories":["算法导论"]},{"title":"算法导论18 Problems 答案","url":"/introduction-to-algorithms/chapter-18/problems/","content":"\r\n18-1\r\na\r\n在最坏情况下是\\(n\\)个操作都是PUSH操作，这意味着每次操作都会引起一个页的磁盘存取。也就是说，总共引起\\(n\\)次磁盘存取，所花费的CPU时间为\\(\\Theta(nm)\\)。\r\nb\r\n在这种情况下，只有\\(m\\)个PUSH操作才能够填充满一个页。这\\(n\\)个操作一共产生了\\(\\left\\lceil\\dfrac{n}{m}\\right\\rceil\\)个不同的页，因此其磁盘存取次数为\\(\\left\\lceil\\dfrac{n}{m}\\right\\rceil\\)，所花费的CPU时间为\\(\\left\\lceil\\dfrac{n}{m}\\right\\rceil\\cdot\\Theta(m)=\\Theta(n)\\)。\r\nc\r\n首先将执行\\(m\\)次PUSH操作，这时整个页面都会被占满。然后剩下的\\(n-m\\)次操作中，循环执行PUSH, POP, POP, PUSH这\\(4\\)个操作，每一个周期的第\\(1\\)个PUSH操作和第\\(3\\)个POP操作都会进行一次磁盘读取操作。因此，最终所需要的磁盘读取次数为\\(\\Theta(n)\\)次，所花费的CPU时间为\\(\\Theta(nm)\\)。\r\nd\r\n考虑如下场景：快速主存中只有\\(2\\)个页面，它们用于存储磁盘中的两个相邻的页面\\(p,q=p+1\\)。完整的PUSH操作和POP操作如下：\r\n\r\nPUSH操作：如果这\\(2\\)个页面已经是满的，那么再进行一次PUSH操作后，将第\\(p\\)个磁盘页面所对应的主存页面写入磁盘，并且将另一个主存页面挪到当前的主存页面（也就是将指针\\(p\\)加上\\(1\\)。当然也可以不挪，可以应用类似于循环队列的思想进行管理）。之后再将这个字写入这个内存的字即可。否则直接写入内存的这个字，不执行磁盘存取操作。\r\nPOP操作：如果这\\(2\\)个页面都已经是空的，那么将第\\(p-1\\)个磁盘页面读入主存（也就是将指针\\(p\\)减去\\(1\\)），然后再将栈指针减去\\(1\\)。否则，仅仅是将栈指针减去\\(1\\)，不执行磁盘存取操作。\r\n\r\n那么接下来将证明这个操作的均摊CPU时间为\\(O(1)\\)，从而证明可以得到均摊的磁盘存取次数为\\(O(1/m)\\)。\r\n令\\(c_i\\)表示第\\(i\\)个操作的实际CPU时间，\\(\\widehat{c_i}\\)表示均摊后的CPU时间。由于一次存取操作花费的CPU时间是\\(\\Theta(m)\\)，因此假设其至多花费的时间为\\(cm\\)，其中\\(c\\)是一个常数。令\\(\\Phi(T_i)\\)表示第\\(i\\)次操作后，主存的两个页面中总共包含的字的个数的\\(c\\)倍，那么有\\(0\\le \\Phi(T_i)\\le 2cm\\)。\r\n一开始主存的这两个页面都为空，因此\\(\\Phi(T_0)=0\\)，由于字的个数必定是一个非负整数，因此\\(\\forall i\\in[0,n],\\Phi(T_i)\\ge\r\n\\Phi(T_0)\\)必定成立，因此\\(\\Phi\\)是一个合适的势函数。对于\\(i\\in[1,n]\\)，令\\(\\Delta\r\n\\Phi_i=\\Phi(T_i)-\\Phi(T_{i-1})\\)，那么有\\(\\widehat{c_i}=c_i+\\Delta\\Phi_{i}\\)，接下来考虑这两个操作的均摊时间。\r\n\r\nPUSH操作：如果这\\(2\\)个页面已经是满的，那么这个时候需要花费的CPU时间为\\(cm\\)。此时\\(\\Phi(T_{i-1})=2cm,\\Phi(T_i)=c(m+1)\\)，因此\\(\\widehat{c_i}=c_i+\\Delta\\Phi_i\\le\r\ncm+c((m+1)-2m)=c\\)；否则，\\(\\Delta\\Phi_i=c\\cdot\r\n1=c,c_i=0\\)，此时有\\(\\widehat{c_i}=c_i+\\Delta\\Phi_i=c\\)，因此总有\\(\\widehat{c_i}\\le c\\)成立。\r\nPOP操作：如果这\\(2\\)个页面已经是空的，那么这个时候需要花费的CPU时间为\\(cm\\)。此时\\(\\Phi(T_{i-1})=c\\cdot\r\n0=0,\\Phi(T_i)=c(m-1)\\)，因此\\(\\widehat{c_i}=c_i+\\Delta\\Phi_i\\le\r\ncm+c(0-(m-1))=c\\)；否则，\\(\\Delta\\Phi_i=c\\cdot\r\n-1=-c,c_i=0\\)，此时有\\(\\widehat{c_i}=c_i+\\Delta\\Phi_i=-c\\)，因此仍总有\\(\\widehat{c_i}\\le c\\)成立。\r\n\r\n也就是说，\\(\\forall\r\ni\\in[1,n],\\widehat{c_i}\\le c\\)均成立。那么根据\\(\\displaystyle{\\sum_{i=1}^n\r\n\\widehat{c_i}=\\sum_{i=1}^n\r\nc_i+\\Phi(T_n)-\\Phi(T_0)}\\)，那么得到\\(\\displaystyle{\\sum_{i=1}^n c_i =\\sum_{i=1}^n\r\n\\widehat{c_i}-\\Phi(T_n)+\\Phi(T_0)\\le\\sum_{i=1}^n\r\n\\widehat{c_i}=cn}\\)。\r\n也就是说，每一个栈操作的平均运行时间不超过\\(c\\)，因此其均摊时间复杂度为\\(O(1)\\)，原结论成立。\r\n18-2\r\na\r\n维护整棵2-3-4树的所有节点的\\(heigh\\)属性只有在插入操作中的分裂节点所需要；由于维护\\(height\\)属性的过程中不会影响树的形态，因此并不会改变查找、插入和删除的属性，如下是维护\\(height\\)属性的伪代码：\r\n2-3-4-TREE-CREATE-H(T)  x = ALLOCATE-NODE()  x.leaf = TRUE  x.height = 0        // 只有一个节点的树的高度为0。  x.n = 0  DISK-WRITE(x)  T.root = x2-3-4-TREE-SPLIT-CHILD-H(x, i)  y = x.c_&#123;i&#125;  z = ALLOCATE-NODE()  z.leaf = y.leaf  z.n = t - 1  for j = 1 to t - 1    z.key_&#123;j&#125; = y.key_&#123;j+t&#125;  if not y.leaf    for j = 1 to t      z.c_&#123;j&#125; = y.c_&#123;j+t&#125;  y.n = t - 1  for j = x.n + 1 downto i + 1    x.c_&#123;j+1&#125; = x.c_&#123;j&#125;  x.c_&#123;i+1&#125; = z  for j = x.n downto i    x.key_&#123;j+1&#125; = x.key_&#123;j&#125;  x.key_&#123;i&#125; = y.key_&#123;t&#125;  x.n = x.n + 1  DISK-WRITE(y)  DISK-WRITE(z)  DISK-WRITE(x)  z.height = y.height   // 由于是从兄弟节点分裂而来，因此根据B树的性质4，这两棵子树的高度相等。2-3-4-TREE-INSERT-H(T, k)  r = T.root  if r.n == 2 * t - 1    s = 2-3-4-TREE-SPLIT-ROOT-H(T)    2-3-4-TREE-INSERT-NONFULL-H(s, k)  else 2-3-4-TREE-INSERT-NONFULL-H(r, k)2-3-4-TREE-SPLIT-ROOT-H(T)  s = ALLOCATE-NODE()  s.leaf = FALSE  s.n = 0  s.c_&#123;1&#125; = T.root  s.height = T.root.height + 1  T.root = s  2-3-4-TREE-SPLIT-CHILD-H(s, 1)  return s\r\n其中，对于主插入程序2-3-4-TREE-INSERT-H，它和B-TREE-INSERT基本相同，区别在于使用了子程序2-3-4-TREE-SPLIT-ROOT-H来代替B-TREE-SPLIT-ROOT；使用了2-3-4-TREE-INSERT-NONFULL-H来代替B-TREE-INSERT-NONFULL。对于非满插入程序2-3-4-TREE-INSERT-NONFULL-H，它和B-TREE-INSERT-NONFULL基本相同，区别在于使用了子程序2-3-4-TREE-SPLIT-CHILD-H来代替B-TREE-SPLIT-CHILD；以及最后一行递归调用的也是自身。\r\n由于删除操作只是将两个同层的节点合并了（有时是把根节点去掉），查询操作并不影响树的形态，因此查询和删除操作不需要维护\\(height\\)属性。\r\nb\r\n不失一般性，假设\\(T&#39;.root.height&gt;\r\nT&#39;&#39;.root.height\\)，那么求解\\(T&#39;\\)中属性\\(height\\)为\\(T&#39;&#39;.root.height+1\\)最右边的节点，设其为\\(r\\)，那么对节点\\(r\\)右边添加键\\(k\\)，并且键\\(k\\)的右儿子将指向\\(T&#39;&#39;.root\\)，即可得到\\(T.root\\)。\r\n如果\\(T&#39;.root=T&#39;&#39;.root\\)，那么将键\\(k\\)独立作为一个节点\\(z\\)，其中\\(T&#39;.root\\)是\\(z\\)的第一棵子树\\(z.c_1，T&#39;&#39;.root\\)是\\(z\\)的第二棵子树\\(z.c_2\\)。\r\n更具体的过程由2-3-4-TREE-JOIN给出。可以发现，for循环的迭代次数只取决于\\(|h&#39;-h&#39;&#39;|\\)的值，因此其时间复杂度为\\(O(1+|h&#39;-h&#39;&#39;|)\\)。\r\n// 假设全局变量值是t = 2。2-3-4-TREE-JOIN(T&#x27;, k, T&#x27;&#x27;)  Let T be a new 2-3-4-tree  if T&#x27;.root.n == 2 * t - 1    2-3-4-TREE-SPLIT-ROOT-H(T&#x27;)  if T&#x27;&#x27;.root.n == 2 * t - 1    2-3-4-TREE-SPLIT-ROOT-H(T&#x27;&#x27;)  if T&#x27;.root.height == T&#x27;&#x27;.root.height    z = ALLOCATE-NODE()    z.leaf = False    z.c_&#123;1&#125; = T&#x27;.root    z.c_&#123;2&#125; = T&#x27;&#x27;.root    z.n = 1    z.key_&#123;1&#125; = k    z.height = T&#x27;.root.height + 1    T.root = z  else if T&#x27;.root.height &gt; T&#x27;&#x27;.root.height    d = T&#x27;.root.height - T&#x27;&#x27;.root.height - 1    z = T&#x27;.root    for i = 1 to d      DISK-READ(z, z.c_&#123;z.n&#125;)      if z.c_&#123;z.n&#125; == 2 * t - 1        2-3-4-TREE-SPLIT-CHILD-H(z, z.n)      z = z.c_&#123;z.n&#125;    z.n = z.n + 1    z.key_&#123;z.n&#125; = k    z.c_&#123;z.n + 1&#125; = T&#x27;&#x27;.root    T.root = T&#x27;.root  else    d = T&#x27;&#x27;.root.height - T&#x27;.root.height - 1    z = T&#x27;&#x27;.root    for i = 1 to d      DISK-READ(z, 1)      if z.c_&#123;1&#125; == 2 * t - 1        2-3-4-TREE-SPLIT-CHILD-H(z, 1)      z = z.c_&#123;1&#125;      // 所有子节点指针和关键字都向后挪一步      for i = z.n downto 1        z.key_&#123;i + 1&#125; = z.key_&#123;i&#125;      for i = z.n + 1 downto 1          z.c_&#123;i + 1&#125; = z.c_&#123;i&#125;      z.key_&#123;1&#125; = k      z.c_&#123;1&#125; = T&#x27;.root    T.root = T&#x27;&#x27;.root  return T\r\nc\r\n令节点\\(x\\)是关键字\\(k\\)所在的节点，\\(v_1,v_2,\\dots,v_n\\)是题目中所提到的路径\\(p\\)，其中\\(v_1=T.root,v_n=x\\)。目前先考虑\\(S&#39;\\)中的关键字，对于\\(\\forall i\\in [1,n]\\)，如果\\(\\exists j:v_i.key_{j}\\le k\\)，那么令\\(l_i\\)为满足最大条件的\\(j\\)，此时可以将节点\\(v_i\\)的键分裂成两部分：\\(v_{i}.key_{1},v_{i}.key_{2},\\dots,v_{i}.key_{l_i-1};v_{i}.key_{l_i}\\)，并且第一部分的关键字及其相邻的子节点切割成一个新的节点，以其为根的子树作为\\(T&#39;_{j-1}\\)的一部分，并且\\(k&#39;_j=v_i.key_{l_i}\\)，继续朝向第\\(v_{i+1}=v_i.c_{l_i+1}\\)棵子树递归操作；如果\\(l_i\\)不存在，那么直接访问\\(v_{i+1}=v_i.c_{1}\\)。当到了第\\(n\\)层时，切割完节点后终止程序（不用再取\\(k&#39;\\)）。因此对于\\(\\forall i\\in[1,m]\\)，都有\\(T&#39;_{i-1}.height\\ge\r\nT_{i}&#39;.height\\)。\r\n对于\\(S&#39;&#39;\\)，其操作过程类似，对于\\(\\forall i\\in [1,n]\\)，如果\\(\\exists j:v_i.key_{j}\\ge k\\)，那么令\\(r_i\\)为满足条件最小的\\(j\\)，此时可以将节点\\(v_i\\)的键分裂成两部分：\\(v_{i}.key_{l_i};v_{i}.key_{l_i+1},v_{i}.key_{l_i+2},\\dots,v_{i}.key_{l_i}\\)，第二部分的关键字及其相邻的子节点切割成一个新的节点，以其为根的子树作为\\(T&#39;&#39;_{j-1}\\)的一部分，并且\\(k&#39;&#39;_j=v_i.key_{r_i}\\)，继续朝向第\\(v_{i+1}=v_i.c_{r_i}\\)棵子树递归操作；如果\\(r_i\\)不存在，那么直接访问\\(v_{i+1}=v_i.c_{v_i.n+1}\\)，并且不做任何操作。当到了第\\(n\\)层时，切割完节点后终止程序（不用再取\\(k&#39;\\)）。\r\n整个过程由2-3-4-TREE-GEN-S'和2-3-4-TREE-GEN-S''给出，由于单个节点的关键字的个数上限为常数，并且它们仅仅是自顶向下找出一条通往叶子节点的路径，因此它们的时间复杂度为\\(O(\\lg n)\\)。\r\n2-3-4-TREE-GEN-S&#x27;(T, k)  let t be 0-index array, K be 1-index array  x = T.root  while True    DISK-READ(x)    l = 1    while l &lt;= x.n and x.key_&#123;l&#125; &lt; k      l = l + 1    // 不存在l_i的情况。    if l == 1 and x.key_&#123;1&#125; &gt; k      x = x.c_&#123;1&#125;    else      is-end = (l &lt;= x.n and x.key_&#123;l&#125; == k)      if x.leaf and not is-end        // 在叶节点仍然找不到关键字，那么报错。        error &quot;not find key: &quot; k       if not is-end        INSERT(K, k.key)        // x.key_&#123;l&#125; = k，不能进入T[m]，需要去掉。        l = l - 1      Let T1 be new tree       if l == 0        T1.root = NIL      else        y = ALLOCATE-NODE()        y.leaf = x.leaf        y.n = l        for i = 1 to l          y.key_&#123;i&#125; = x.key_&#123;i&#125;        if not y.leaf          for i = 1 to l + 1            y.c_&#123;i&#125; = x.c_&#123;i&#125;        T1.root = y        DISK-WRITE(y)      INSERT(t, T1)      if is-end        break      x = x.c_&#123;l + 1&#125;  return t, K&#x27;, K&#x27;.size2-3-4-TREE-GEN-S&#x27;&#x27;(T, k)  let t be 0-index array, K be 1-index array  x = T.root  while True    DISK-READ(x)    r = x.n    while r &gt;= 1 and x.key_&#123;r&#125; &gt; k      r = r - 1    // 不存在r_i的情况。    if r == n and x.key_&#123;r&#125; &lt; k      x = x.c_&#123;x.n + 1&#125;    else      is-end = (r &gt;= 1 and x.key_&#123;r&#125; == k)      if x.leaf and not is-end        // 在叶节点仍然找不到关键字，那么报错。        error &quot;not find key: &quot; k       if not is-end        INSERT(K, k.key)        // x.key_&#123;r&#125; = k，需要去掉。        r = r + 1      Let T1 be new tree       if r == x.n + 1        T1.root = NIL      else        y = ALLOCATE-NODE()        y.leaf = x.leaf        y.n = x.n - r + 1        for i = r to x.n          y.key_&#123;i - r + 1&#125; = x.key_&#123;i&#125;        if not y.leaf          for i = r to x.n + 1            y.c_&#123;i - r + 1&#125; = x.c_&#123;i&#125;          T1.root = y        DISK-WRITE(y)      INSERT(t, T1)      if is-end        break      x = x.c_&#123;l + 1&#125;  return t, K&#x27;, K&#x27;.size\r\nd\r\n根据题目18-2-c的结论，集合\\(S&#39;\\)通过节点\\(m\\)被划分成了\\(m+1\\)块。并且\\(\\forall i\\in[0,m],\r\nT&#39;_i\\)都是一棵2-3-4树，并且\\(\\forall i\\in[1,m]:\\forall x\\in T&#39;_{i-1},y\\in\r\nT&#39;_i,x&lt;k&#39;_i&lt;y,T&#39;_{i-1}.height\\ge\r\nT&#39;_{i-1}.height\\)均成立。那么使用2-3-4-TREE-JOIN算法，从后往前依次将这些树拼接起来，即可得到一个以\\(S&#39;\\)中的所有节点构成的2-3-4树。对于集合\\(S&#39;&#39;\\)操作也类似。具体过程由2-3-4-TREE-SPLIT-AUX-S'和2-3-4-TREE-SPLIT-AUX-S''分别给出。这些程序使用了子程序2-3-4-TREE-JOIN来拼接。因此，只要按照从低到高进行拼接，那么就能做到时间复杂度为\\(O(\\lg n)\\)。\r\n2-3-4-TREE-SPLIT-AUX-S&#x27;(t&#x27;, k&#x27;, m)  T&#x27; = t&#x27;[m]  for i = m downto 1    T&#x27; = 2-3-4-TREE-JOIN(t&#x27;[i - 1], k&#x27;[i], T&#x27;)  return T&#x27;2-3-4-TREE-SPLIT-AUX-S&#x27;&#x27;(t&#x27;&#x27;, k&#x27;&#x27;, m)  T&#x27;&#x27; = t&#x27;&#x27;[0]  for i = 1 to m    T&#x27;&#x27; = 2-3-4-TREE-JOIN(T&#x27;&#x27;, k&#x27;&#x27;[i], t&#x27;&#x27;[i])  return T&#x27;&#x27;2-3-4-TREE-SPLIT(T, k)  t&#x27;, k&#x27;, m&#x27; = 2-3-4-TREE-GEN-S&#x27;(T, k)  t&#x27;&#x27;, k&#x27;&#x27;, m&#x27;&#x27; = 2-3-4-TREE-GEN-S&#x27;&#x27;(T, k)  T&#x27; = 2-3-4-TREE-SPLIT-AUX-S&#x27;(t&#x27;, k&#x27;, m)  T&#x27;&#x27; = 2-3-4-TREE-SPLIT-AUX-S&#x27;&#x27;(t&#x27;&#x27;, k&#x27;&#x27;, m)  return T&#x27;, T&#x27;&#x27;\r\n","categories":["算法导论"]},{"title":"算法导论1 Problems 答案","url":"/introduction-to-algorithms/chapter-1/problems/","content":"\r\n1-1\r\n以每月\\(30\\)天，每年有\\(365\\)天，一个世纪有\\(36525\\)天计算。\r\n\\(\\begin{array}{|c|c|c|c|c|c|c|c|}\r\n\\hline\r\n&amp;\\text{1 second}&amp;\\text{1 minute}&amp;\\text{1 hour}&amp;\\text{1\r\nday}&amp;\\text{1 month}&amp;\\text{1 year}&amp;\\text{1 century}\\\\\r\n\\hline\r\n\\lg n&amp;2^{10^6}&amp;2^{6\\times 10^7}&amp;2^{3.6\\times\r\n10^9}&amp;2^{8.64\\times\r\n10^{10}}&amp;2^{2.592\\times10^{12}}&amp;2^{3.1104\\times\r\n10^{13}}&amp;2^{3.15576\\times 10^{15}}\\\\\r\n\\hline\r\n\\sqrt{n}&amp;10^{12}&amp;3.6\\times 10^{15}&amp;1.296\\times\r\n10^{19}&amp;7.46496\\times 10^{21}&amp;\\approx 6.71846\\times\r\n10^{24}&amp;\\approx 9.67459\\times 10^{26}&amp;\\approx 9.96882\\times\r\n10^{30}\\\\\r\n\\hline\r\nn&amp;10^6&amp;6\\times 10^7&amp;3.6\\times 10^9&amp;8.64\\times\r\n10^{10}&amp;2.592\\times10^{12}&amp;3.1104\\times\r\n10^{13}&amp;3.15576\\times 10^{15}\\\\\r\n\\hline\r\nn\\lg\r\nn&amp;62746&amp;\\approx2.80142\\times10^{6}&amp;\\approx1.33378\\times10^{8}&amp;\\approx2.75515\\times10^{9}&amp;\\approx7.18709\\times10^{10}&amp;\\approx7.87090\\times10^{11}&amp;\\approx6.86565\\times10^{13}\\\\\r\n\\hline\r\nn^2&amp;1000&amp;\\approx 7745&amp;6000&amp;\\approx 293938&amp;\\approx\r\n1.60997\\times 10^6&amp;\\approx 5.57710\\times 10^6&amp;\\approx\r\n5.61762\\times 10^7\\\\\r\n\\hline\r\nn^3&amp;100&amp;391&amp;1532&amp;4420&amp;13736&amp;31448&amp;146679\\\\\r\n\\hline\r\n2^n&amp;19&amp;25&amp;31&amp;36&amp;41&amp;44&amp;51\\\\\r\n\\hline\r\nn!&amp;9&amp;11&amp;12&amp;13&amp;15&amp;16&amp;17\\\\\r\n\\hline\r\n\\end{array}\\)\r\n","categories":["算法导论"]},{"title":"算法导论1.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-1/exercises-2/","content":"\r\n1.2-1\r\n布隆过滤器：用于检索一个元素是否在一个集合中。\r\n具体场景：现在有一个非常大的黑名单URL集合。但是这些URL的长度都是固定的。现在需要过滤网站，判断网页的URL是否是否在黑名单上。允许有微小的判断失误率。并且要求使用的空间有限。\r\n1.2-2\r\n不难发现，这题是求\\(n\\)使得\\(8n^2&gt;64n\\lg n\\)。得到满足的\\(n\\)满足\\(1&lt;\r\nn&lt; 44\\)。\r\n1.2-3\r\n不难发现，这题是求最小的\\(n\\)使得\\(100n^2&lt;2^n\\)，得到满足的\\(n\\)值为\\(15\\)。\r\n","categories":["算法导论"]},{"title":"算法导论2.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-2/exercises-1/","content":"\r\n2.1-1\r\n\\(\\begin{aligned}\r\n&amp;[],[31,41,59,26,41,58]\\\\\r\n&amp;[\\underline{31}],[41,59,26,41,58]\\\\\r\n&amp;[31,\\underline{41}],[59,26,41,58]\\\\\r\n&amp;[31,41,\\underline{59}],[26,41,58]\\\\\r\n&amp;[\\underline{26},31,41,59],[41,58]\\\\\r\n&amp;[26,31,41,\\underline{41},59],[58]\\\\\r\n&amp;[26,31,41,41,\\underline{58},59],[]\r\n\\end{aligned}\\)\r\n2.1-2\r\n初始化：一开始时求了前\\(0\\)个元素的和，也就是说不包含任何数。\r\n保持：在迭代到第\\(i\\)个元素时，\\(sum\\)是数组\\(A[1:i-1]\\)的元素之和。添加上\\(A[i]\\)后，\\(sum\\)就成为了数组\\(A[1:i]\\)的元素之和。\r\n终止：最终，通过下标\\(i\\)迭代了每一个元素，只要超过了长度\\(n\\)，循环终止。因此整个算法是正确的。此时就有\\(sum=A[1:n]\\)。\r\n2.1-3\r\nINSERTION-SORT(A, n)  for i = 2 to n    key = A[i]    j = i – 1    while j &gt; 0 and A[j] &lt; key      A[j + 1] = A[j]      j = j – 1    A[j + 1] = key\r\n这时候在插入的元素的位置，右边全是比它小的，左边全是比它大的。\r\n2.1-4\r\nLINEAR-SEARCH(A, n, x)  for i = 1 to n    if A[i] == x      return i  return NIL\r\n循环不变量：\\(A[1:i-1]\\)中都不包含数\\(x\\)。\r\n初始化：迭代开始前处理的是空数组，并没有发现和\\(x\\)的元素。\r\n保持：在数组\\(A[1:i-1]\\)没有发现\\(x\\)的基础上，判断\\(A[i]\\)是否和\\(x\\)相等。如果相等，那么及时返回下标\\(i\\)，循环不变量\\(A[1:i-1]\\)依旧不包含\\(x\\)；否则说明数组\\(A[1:i]\\)也没有发现\\(x\\)。\r\n终止：如果找到了一个\\(i\\)使得\\(A[i]=x\\)，那么算法立刻返回当前下标，算法提前结束。当直到循环结束时，下标\\(i\\)的值已经为\\(n+1\\)，这说明数组\\(A[1,n]\\)并没有发现\\(x\\)，故返回NIL，算法正确结束。\r\n2.1-5\r\nADD-BINARY-INTEGERS(A, B, n)  let C[0 : n] be new arrays  carry = 0  for i = 0 to n - 1    sum = carry + A[i] + B[i]    C[i] = sum % 2    carry = floor(sum / 2)  C[n] = carry  return C\r\n","categories":["算法导论"]},{"title":"算法导论2.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-2/exercises-3/","content":"\r\n2.3-1\r\n\\(\\begin{aligned}\r\n&amp;[3,41,52,26,38,57,9,49]\\\\\r\n&amp;[3,41,52,26]\\quad[38,57,9,49]\\\\\r\n&amp;[3,41]\\quad[52,26]\\quad[38,57]\\quad[9,49]\\\\\r\n&amp;[3]\\quad[41]\\quad[52]\\quad[26]\\quad[38]\\quad[57]\\quad[9]\\quad[49]\\\\\r\n&amp;[3,41]\\quad[26,52]\\quad[38,57]\\quad[9,49]\\\\\r\n&amp;[3,26,41,52]\\quad[9,38,49,57]\\\\\r\n&amp;[3,9,26,38,41,49,52,57]\r\n\\end{aligned}\\)\r\n2.3-2\r\n如果\\(r-p+1=1\\)，说明恰好触发了\\(r=p\\)的条件。MERGE-SORT算法终止。\r\n假设\\(n&gt;2\\)，一开始调用MERGE-SORT(A,1,n)就已经意味着\\(1=p&lt; r=n\\)。\r\n令\\(q=\\left\\lfloor\\dfrac{p+r}{2}\\right\\rfloor\\)，由于\\(r&gt;p\\)，因此必定保证\\(p\\le q\\)。\r\n考虑\\(q+1\\)和\\(r\\)的关系：如果\\(r-p+1\\le 2\\)，那么\\(q+1=r\\)。如果\\(r-p+1&gt;2\\)，那么\\(q+1&lt; r\\)。因此\\(q+1\\le r\\)总能保证。\r\n最终，只要调用时已经保证\\(p&lt;\r\nr\\)，那么接下来的两次调用参数总满足\\(p\\le q,q+1\\le r\\)。假设新调用的参数为\\(p&#39;,r&#39;\\)，那么也就是只会满足\\(p&#39;\\le r&#39;\\)，不会出现\\(p&#39;&gt;r&#39;\\)的情况。\r\n2.3-3\r\n循环不变量：数组\\(L[i:n_L-1]\\)和\\(R[j:n_R-1]\\)保持有序。\r\n初始化：一开始数组\\(A[p:r]\\)是空的，视为已经排序。\r\n保持：在第\\(i+j\\)次迭代前，由于数组\\(L,R\\)已经排序，因此\\(L[i]\\)是数组\\(L[i:n_L-1]\\)的最小值，\\(R[j]\\)是数组\\(R[j:n_R-1]\\)的最小值。当前的\\(k\\)值要么满足\\(k=p\\)，要么满足\\(A[k-1]\\le \\min(L[i],R[j])\\)。因此取出\\(L[i]\\)和\\(R[j]\\)中的最小值，并复制给\\(A[k]\\)。不失一般性，假设赋给\\(A[k]\\)的值是\\(L[i]\\)，那么迭代完成后，\\(L[i+1]\\)仍然是数组\\(L[i+1:n_R-1]\\)的最小值。由于\\(i&lt;i+1\\)，因此\\(A[k]\\le L[i+1]\\)；由于选择的是\\(L[i]\\)，因此\\(A[k]\\le R[j]\\)，那么\\(A[k]\\le\r\n\\min(L[i+1],R[j])\\)依旧保持着，直到第12-18行的代码的循环结束。\r\n终止：终止条件要么是\\(i=n_L\\)，要么是\\(j=n_R\\)。不失一般性，假设此时已经满足\\(i=n_L\\)，那么说明\\(j&lt; n_R\\)。由于\\(L[n_L-1]\\)先被选择，因此满足\\(A[k-1]=L[n_L-1]\\le R[j]\\)。由于数组\\(R\\)是有序的。因此$L[n_L-1]R[j]R[j-1]R[n_R-1]\r\n$保持有序，直接通过循环将这一段剩下的序列复制到重点即可。\r\n2.3-4\r\n令\\(f(m)=T(2^m)\\)，那么代入递推式\\(T(n)\\)，\r\n\\(f(m)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;2  &amp; &amp; \\text{if}\\quad m=1 \\\\\r\n  &amp;2f(m-1)+2^m &amp; &amp; \\text{if}\\quad m&gt;1 \\\\\r\n\\end{aligned}\\right.\\)\r\n第二行递推式可以改写成\\(\\dfrac{f(m)}{2^m}=\\dfrac{f(m-1)}{2^{m-1}}+1\\)，可以发现数列\\(\\dfrac{f(m)}{2^m}\\)是首项、公差均为\\(1\\)的等差数列，因此有\\(\\dfrac{f(m)}{2^m}=m\\)，也就是说\\(f(m)=m\\cdot 2^m\\)。\r\n最终回代\\(f(m)=T(2^m)\\)，得到\\(T(n)=n\\cdot \\lg n\\)。\r\n2.3-5\r\nINSERTION-SORT(A, n)  if n == 1:    return  INSERTION-SORT(A, n - 1)  key = A[n]  j = n – 1  while j &gt; 0 and A[j] &lt; key    A[j + 1] = A[j]    j = j – 1    A[j + 1] = key\r\n在最坏情况下，while循环体最多会执行\\(n\\)次，因此可以写出如下\\(T(n)\\)的递推式：\r\n\\(T(n)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad n=1 \\\\\r\n  &amp;T(n-1)+n &amp; &amp; \\text{if}\\quad n&gt;1 \\\\\r\n\\end{aligned}\\right.\\)\r\n2.3-6\r\n// 数组A长度为n，寻找值x。BINARY-SEARCH(A, n, x)  l = 1  r = n  while l &lt;= r    mid = floor((l + r) / 2)    if A[mid] == x      return mid    else if A[mid] &lt; x      l = mid + 1    else      r = mid - 1  return NIL\r\n在最差的情况下，循环不会从return mid中结束。因此，在每一次迭代过程中，\\(r-l+1\\)的大小将会被缩减一半。不难写出递推式\\(T(n)=T(n/2)+\\Theta(1)\\)，从而得到\\(T(n)=\\Theta(\\lg n)\\)\r\n2.3-7\r\n使用二分搜索并不能优化插入排序。二分搜索只能以\\(\\Theta(\\lg\r\nn)\\)的时间复杂度定位到元素应该插入到哪个位置，但是将比当前key大的所有数往后移动一个下标，依然需要\\(\\Theta(n)\\)的时间。\r\n2.3-8\r\n// 输入集合S，集合的大小n，题中所求x。// 返回1表示符合条件，否则返回0.SEARCH-SUM-X(S, n, x)  A = to_array(S)  MERGE-SORT(A, 1, n)  l = 1  r = n  while l &lt; r    if A[l] + A[r] == x      return 1    else if A[l] + A[r] &gt; x      r = r - 1    else      l = l + 1  return 0\r\n","categories":["算法导论"]},{"title":"算法导论2 Problems 答案","url":"/introduction-to-algorithms/chapter-2/problems/","content":"\r\n2-1\r\na\r\n插入排序的时间复杂度为\\(\\Theta(k^2)\\)，这个长度为\\(n\\)的数组中，有\\(\\dfrac{n}{k}\\)个长度为\\(k\\)的数组。因此插入排序部分的时间复杂度为\\(\\Theta(k^2)\\cdot\r\n\\dfrac{n}{k}=\\Theta(nk)\\)。\r\nb\r\n先两两将长度为\\(k\\)的数组合并成长度为\\(2k\\)的，再两两将每个\\(2k\\)的数组合并成\\(4k\\)的……可以发现这个合并过程是一颗树，整棵树的高度是\\(\\Theta\\left(\\lg\r\n\\dfrac{n}{k}\\right)\\)。并且，在每一层的合并过程中，整个数组中的所有数恰好都被遍历了一次，花费的时间复杂度总和为\\(\\Theta(n)\\)。因此，最坏情况下合并这\\(k\\)个数组的时间复杂度为\\(\\Theta\\left(n\\cdot \\lg\r\n\\dfrac{n}{k}\\right)\\)。\r\nc\r\n修改后的归并排序算法为\\(\\Theta\\left(nk + n\r\n\\lg\\dfrac{n}{k}\\right)\\)，也就是\\(\\Theta(nk+n\\lg n-n\\lg\r\nk)\\)。继续进行如下变换：\r\n\\(\\begin{aligned}\r\n\\Theta\\left(nk + n \\lg\\dfrac{n}{k}\\right)&amp;=\\Theta(nk+n\\lg n-n\\lg\r\nk)\\\\\r\n&amp;=\\Theta(n(k-\\lg k)+n\\lg n)\\\\\r\n&amp;=\\Theta(nk+n\\lg n)\r\n\\end{aligned}\\)\r\n不难发现\\(\\Theta(k-\\lg\r\nk)=\\Theta(k)\\)。\r\n按照上面的式子不难看出，只有当\\(k=\\Theta(\\lg\r\nn)\\)时，改进后的归并排序算法才能够达到\\(\\Theta(n\\lg n)\\)。\r\nd\r\n根据机器性能多次检验后，\\(k\\)将在\\(\\Theta(\\lg n)\\)附近的值中选择。\r\n2-2\r\na\r\n还需要证明\\(A&#39;\\)是\\(A\\)的一个置换（也就是说，\\(A&#39;\\)的元素都来自于\\(A\\)）。\r\nb\r\n循环不变量：\\(A[j]\\)是数组\\(A[j:n]\\)中的最小值。\r\n初始化：一开始只有一个元素\\(A[n]\\)，一个元素的数组的最小值肯定是它自身。\r\n保持：在迭代轮次\\(j\\)前，\\(A[j]\\)是数组\\(A[j:n]\\)的最小值。如果\\(A[j-1]\\le A[j]\\)，那么\\(A[j-1]\\)是数组\\(A[j-1:n]\\)的最小值；否则，\\(A[j]&lt;A[j-1]\\)，交换\\(A[j]\\)和\\(A[j-1]\\)后，\\(A[j-1]\\)就变成了数组\\(A[j-1:n]\\)的最小值。\r\n终止：当\\(j=i\\)时循环终止。根据循环不变量，\\(A[i]\\)就是数组\\(A[i:n]\\)的最小值。\r\nc\r\n循环不变量：数组\\(A[1:i-1]\\)是由数组的前\\(i-1\\)小的元素升序排列。\r\n初始化：一开始数组是空的，因此是有序的。\r\n保持：在第\\(i\\)次循环前，数组\\(A[1:i-1]\\)是前\\(i-1\\)小的元素升序排列。根据内循环的循环不变量，第\\(i\\)次循环完成后，\\(A[i]\\)是数组\\(A[i:n]\\)的最小值，那么\\(A[i]\\)是数组中第\\(i\\)小的元素。最终，数组\\(A[1:i]\\)是前\\(i\\)小的元素升序排列。\r\n终止：最终\\(i=n+1\\)，算法终止。根据循环不变量，此时数组\\(A[1:n]\\)是由数组的前\\(n\\)小的元素升序排列。\r\nd\r\n可以发现，在第\\(i\\)次迭代中，内循环总是进行了\\(n-i\\)次。最终外循环结束后，总共的运行时间为\\(\\Theta(n^2)\\)（无论是平均情况还是最坏情况），这与插入排序最坏情况相同。\r\n2-3\r\na\r\n\\[\\Theta(n)\\]\r\nb\r\nHORNER-NAIVE(A, n, x)  p = 0  for i = 0 to n    pow_x = 1    for j = 1 to i      pow_x = pow_x * x    p = p + pow_x * A[i]  return p\r\n在第\\(i\\)次迭代中，内循环迭代了\\(i\\)次，因此整个算法的运行时间为\\(\\Theta(n^2)\\)，相比原算法慢了很多。\r\nc\r\n令\\(\\displaystyle{p(i)=\\sum_{k=0}^{n-(i+1)}\r\nA[k+i+1]\\cdot x^k}\\)\r\n初始化：容易发现\\(p(n)=0\\)，因为此时求和式的上限值为\\(-1\\)，与定义相同。\r\n保持：在第\\(i\\)次循环前，\\(p\\)的值为\\(p(i)\\)。那么在\\(p(i)\\)次循环完成后，数值已经变成\\(p(i)\\cdot x+A[i]\\)。进行以下恒等变换：\r\n\\(\\begin{aligned}\r\n\\left(x\\cdot \\sum_{k=0}^{n-(i+1)} A[k+i+1]\\cdot x^k\\right) +\r\nA[i]&amp;=\\left( \\sum_{k=0}^{n-(i+1)} A[k+i+1]\\cdot x^{k+1}\\right) +\r\nA[i]\\\\\r\n&amp;=\\left( \\sum_{k=1}^{n-i} A[k+i]\\cdot x^k\\right) +A[i]\\cdot x^0\\\\\r\n&amp;=\\sum_{k=0}^{n-i} A[k+i]\\cdot x^k\\\\\r\n&amp;=\\sum_{k=0}^{n-((i-1)+1)} A[k+(i-1)+1]\\cdot x^k\\\\\r\n&amp;=p(i-1)\r\n\\end{aligned}\\)\r\n那么可以发现，完成一次迭代后，\\(p\\)的值从\\(p(i)\\)转换成\\(p(i-1)\\)，循环不变量相同。\r\n终止：当\\(i=-1\\)时，循环终止。那么可以发现\\(\\displaystyle{p(-1)=\\sum_{k=0}^{n} A[k]\\cdot\r\nx^k}\\)，与最终目标所求值一致，因此算法时正确的。\r\n2-4\r\na\r\n\\([(1,5),(2,5),(3,4),(3,5),(4,5)]\\)\r\nb\r\n置换\\(\\langle\r\nn,n-1,n-2,\\dots,1\\rangle\\)能够得到最多的逆序数（每一对都包含），其值为\\(n-1+n-2+\\dots + 0=\\dfrac{n(n-1)}{2}\\)。\r\nc\r\n以下是插入排序算法的代码：\r\nINSERTION-SORT(A, n)  for i = 2 to n    key = A[i]    j = i – 1    while j &gt; 0 and A[j] &gt; key      A[j + 1] = A[j]      j = j – 1    A[j + 1] = key\r\n假设\\(f(i)\\)的含义是：对于下标元素\\(A[i]\\)，满足\\(j&lt; i, A[j]&gt;A[i]\\)的下标\\(j\\)的数量。数组\\(A\\)的逆序数就为\\(\\sum_{i=1}^n f(i)\\)。\r\n那么，程序的运行时间和值\\(\\sum_{i=1}^n\r\nf(i)\\)线性相关。对于第\\(i\\)次循环，while循环体内做的事情恰好是将比所有比\\(A[i]\\)大的数向右边移动。最终整个程序的运行时间和这个逆序数线性相关。\r\nd\r\n程序CAL-INVERSION(A, p, r)：计算数组\\(A[p:r]\\)中的逆序数，并且对\\(A[p:r]\\)进行归并排序。\r\nCAL-INVERSION(A, p, r)  if p &gt;= r    return 0  q = floor((p + r) / 2)  left_inversion = CAL-INVERSION(A, p, q)  right_inversion = CAL-INVERSION(A, q + 1, q)  new_inversion = MERGE(A, p, q)  return left_inversion + right_inversion + new_inversion\r\n程序MERGE2(A, p, q, r)：数组\\(A[p:q],A[q+1:r]\\)已经有序。将这两个有序数组合并时产生的逆序数。这个程序由程序MERGE(A, p, q, r)修改而来。\r\nMERGE2(A, p, q, r)  inversion_count = 0  nL = q – p + 1 // length of A[p : q]  nR = r – q // length of A[q + 1 : r]  let L[0 : nL – 1] and R[0 : nR – 1] be new arrays  for i = 0 to nL – 1 // copy A[p : q] into L[0 : nL – 1]    L[i] = A[p + i]  for j = 0 to nR – 1 // copy A[q + 1 : r] into R[0 : nR – 1]    R[j] = A[q + j + 1]  i = 0 // i indexes the smallest remaining element in L  j = 0 // j indexes the smallest remaining element in R  k = p // k indexes the location in A to fill  // As long as each of the arrays L and R contains an unmerged element,  // copy the smallest unmerged element back into A[p : r].  while i &lt; nL and j &lt; nR    if L[i] ≤ R[j]      A[k] = L[i]      i = i + 1    else A[k] = R[j]      inversion_count = inversion_count + nL - i      // 这说明L中还有nL-i个数大于R[j]，这些数对R[j]贡献了逆序数。      j = j + 1    k = k + 1  // Having gone through one of L and R entirely, copy the  // remainder of the other to the end of A[p : r].  while i &lt; nL    A[k] = L[i]    i = i + 1    k = k + 1  while j &lt; nR    A[k] = R[j]    j = j + 1    k = k + 1  return inversion_count\r\n","categories":["算法导论"]},{"title":"算法导论19.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-19/exercises-1/","content":"\r\n19.1-1\r\n仿照图19.1(b)，并查集的整个合并过程如下：\r\n\\(\\begin{array}{l|lllllllllll}\r\n\\text{Edge processed}\\\\\\hline\r\n\\text{initial sets}\r\n&amp;\\{a\\}&amp;\\{b\\}&amp;\\{c\\}&amp;\\{d\\}&amp;\\{e\\}&amp;\\{f\\}&amp;\\{g\\}&amp;\\{h\\}&amp;\\{i\\}&amp;\\{j\\}&amp;\\{k\\}\\\\\r\n(d,i)\r\n&amp;\\{a\\}&amp;\\{b\\}&amp;\\{c\\}&amp;\\{d,i\\}&amp;\\{e\\}&amp;\\{f\\}&amp;\\{g\\}&amp;\\{h\\}&amp;&amp;\\{j\\}\\\\\r\n(f,k)\r\n&amp;\\{a\\}&amp;\\{b\\}&amp;\\{c\\}&amp;\\{d,i\\}&amp;\\{e\\}&amp;\\{f,k\\}&amp;\\{g\\}&amp;\\{h\\}&amp;&amp;\\{j\\}\\\\\r\n(g,i)\r\n&amp;\\{a\\}&amp;\\{b\\}&amp;\\{c\\}&amp;\\{d,g,i\\}&amp;\\{e\\}&amp;\\{f,k\\}&amp;&amp;\\{h\\}&amp;&amp;\\{j\\}\\\\\r\n(b,g)\r\n&amp;\\{a\\}&amp;\\{b,d,g,i\\}&amp;\\{c\\}&amp;&amp;\\{e\\}&amp;\\{f,k\\}&amp;&amp;\\{h\\}&amp;&amp;\\{j\\}\\\\\r\n(a,h)\r\n&amp;\\{a,h\\}&amp;\\{b,d,g,i\\}&amp;\\{c\\}&amp;&amp;\\{e\\}&amp;\\{f,k\\}&amp;&amp;&amp;&amp;\\{j\\}\\\\\r\n(i,j)\r\n&amp;\\{a,h\\}&amp;\\{b,d,g,i,j\\}&amp;\\{c\\}&amp;&amp;\\{e\\}&amp;\\{f,k\\}&amp;&amp;&amp;&amp;\\\\\r\n(d,k)\r\n&amp;\\{a,h\\}&amp;\\{b,d,f,g,i,j,k\\}&amp;\\{c\\}&amp;&amp;\\{e\\}&amp;&amp;&amp;&amp;&amp;\\\\\r\n(b,j)\r\n&amp;\\{a,h\\}&amp;\\{b,d,f,g,i,j,k\\}&amp;\\{c\\}&amp;&amp;\\{e\\}&amp;&amp;&amp;&amp;&amp;\\\\\r\n(d,f)\r\n&amp;\\{a,h\\}&amp;\\{b,d,f,g,i,j,k\\}&amp;\\{c\\}&amp;&amp;\\{e\\}&amp;&amp;&amp;&amp;&amp;\\\\\r\n(g,j)\r\n&amp;\\{a,h\\}&amp;\\{b,d,f,g,i,j,k\\}&amp;\\{c\\}&amp;&amp;\\{e\\}&amp;&amp;&amp;&amp;&amp;\\\\\r\n(a,e)\r\n&amp;\\{a,e,h\\}&amp;\\{b,d,f,g,i,j,k\\}&amp;\\{c\\}&amp;&amp;&amp;&amp;&amp;&amp;&amp;\\\\\r\n\\end{array}\\)\r\n由此最终产生了三个连通块：\\(\\{a,e,h\\},\\{b,d,f,g,i,j,k\\},\\{c\\}\\)。\r\n19.1-2\r\n充分性：假设节点\\(x,y\\)在无向图中属于同一连通分量，那么意味着从\\(x\\)到\\(y\\)中有一条路径\\(v_1,v_2,\\dots,v_k\\)，其中\\(v_1=x,v_k=y\\)。随着过程CONNECTED-COMPONENTS的进行，这条路径上相邻的两个节点都被合并到一个集合中，因此最终\\(x\\)和\\(y\\)同属一个集合。\r\n必要性：在一开始时，\\(x,y\\)属于各自的集合。假设对某条边\\((u,v)\\)进行了UNION操作后，\\(x,y\\)从不属于一个集合到属于一个集合，那么记录下边\\((u,v)\\)。不失一般性，假设对边\\((u,v)\\)进行UNION操作前，\\(x,u\\)同属一个集合，\\(y,v\\)同属令一个集合，对这两个集合递归进行。由于一开始每个节点所在集合只有自己，因此由此记录下来的边是一条从\\(x\\)到\\(y\\)的路径，因此\\(x\\)和\\(y\\)在同一连通分量中。\r\n19.1-3\r\n由于每条边都需要进行两次FIND-SET操作，因此整个调用过程一共需要\\(2|E|\\)次FIND-SET操作。一开始整个图有\\(|V|\\)个不同的集合，由于它具有\\(k\\)个连通分量，因此根据题目19.1-2的结论，CONNECTED-COMPONENTS结束后一共有\\(k\\)个不相交集合；每进行一次UNION操作，不相交集合个数减少\\(1\\)，因此UNION操作的个数为\\(|V|-k\\)。\r\n","categories":["算法导论"]},{"title":"算法导论19.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-19/exercises-2/","content":"\r\n19.2-1\r\n每个链表\\(L\\)由三个属性决定：\\(head,tail,size\\)，分别表示链表\\(L\\)的头节点，尾节点和节点个数，每个链表节点\\(z\\)都由两个属性来决定：\\(next,r\\)，前者用途和普通链表一致，后者代表其所属链表，即指向链表本身的指针。那么可以写出如下关于算法MAKE-SET，FIND-SET和UNION-SET的代码：\r\nMAKE-SET(z)  Let L be a new link list  L.head = z  L.tail = z  L.size = 1  z.next = NIL  z.r = LFIND-SET(z)  return z.rUNION(x, y)  L1 = x.r  L2 = y.r  if L1.size &gt; L2.size    exchange L1 with L2  // 此时保证了L1.size &lt;= L2.size  L2.size = L2.size + L1.size  p = L1.head  // 先让L1中的所有节点的r属性指向L2  while p != NIL    p.r = L2    p = p.next  L2.tail.next = L1.head  L2.tail = L1.tail  //销毁已经没用的头节点  Destroy link list L1  return L2\r\n19.2-2\r\n在第1-2行初始化完成后，有如下链表和元素（为了方便，使用表达式来表示）：\r\n\\(\\begin{aligned}\r\nS_{1}&amp;=\\langle x_{1}\\rangle\\\\\r\nS_{2}&amp;=\\langle x_{2}\\rangle\\\\\r\nS_{3}&amp;=\\langle x_{3}\\rangle\\\\\r\nS_{4}&amp;=\\langle x_{4}\\rangle\\\\\r\nS_{5}&amp;=\\langle x_{5}\\rangle\\\\\r\nS_{6}&amp;=\\langle x_{6}\\rangle\\\\\r\nS_{7}&amp;=\\langle x_{7}\\rangle\\\\\r\nS_{8}&amp;=\\langle x_{8}\\rangle\\\\\r\nS_{9}&amp;=\\langle x_{9}\\rangle\\\\\r\nS_{10}&amp;=\\langle x_{10}\\rangle\\\\\r\nS_{11}&amp;=\\langle x_{11}\\rangle\\\\\r\nS_{12}&amp;=\\langle x_{12}\\rangle\\\\\r\nS_{13}&amp;=\\langle x_{13}\\rangle\\\\\r\nS_{14}&amp;=\\langle x_{14}\\rangle\\\\\r\nS_{15}&amp;=\\langle x_{15}\\rangle\\\\\r\nS_{16}&amp;=\\langle x_{16}\\rangle\\\\\r\n\\end{aligned}\\)\r\n在第3-4行的循环完成后，有：\r\n\\(\\begin{aligned}\r\nS_{1}&amp;=\\langle x_{1}, x_{2}\\rangle\\\\\r\nS_{3}&amp;=\\langle x_{3}, x_{4}\\rangle\\\\\r\nS_{5}&amp;=\\langle x_{5}, x_{6}\\rangle\\\\\r\nS_{7}&amp;=\\langle x_{7}, x_{8}\\rangle\\\\\r\nS_{9}&amp;=\\langle x_{9}, x_{10}\\rangle\\\\\r\nS_{11}&amp;=\\langle x_{11}, x_{12}\\rangle\\\\\r\nS_{13}&amp;=\\langle x_{13}, x_{14}\\rangle\\\\\r\nS_{15}&amp;=\\langle x_{15}, x_{16}\\rangle\\\\\r\n\\end{aligned}\\)\r\n在第5-6行的循环完成后，有：\r\n\\(\\begin{aligned}\r\nS_{1}&amp;=\\langle x_{1}, x_{2}, x_{3}, x_{4}\\rangle\\\\\r\nS_{5}&amp;=\\langle x_{5}, x_{6}, x_{7}, x_{8}\\rangle\\\\\r\nS_{9}&amp;=\\langle x_{9}, x_{10}, x_{11}, x_{12}\\rangle\\\\\r\nS_{13}&amp;=\\langle x_{13}, x_{14}, x_{15}, x_{16}\\rangle\\\\\r\n\\end{aligned}\\)\r\n第7行完成后为：\r\n\\(\\begin{aligned}\r\nS_{1}&amp;=\\langle x_{1}, x_{2}, x_{3}, x_{4},x_{5}, x_{6}, x_{7},\r\nx_{8}\\rangle\\\\\r\nS_{9}&amp;=\\langle x_{9}, x_{10}, x_{11}, x_{12}\\rangle\\\\\r\nS_{13}&amp;=\\langle x_{13}, x_{14}, x_{15}, x_{16}\\rangle\\\\\r\n\\end{aligned}\\)\r\n第8行完成后为：\r\n\\(\\begin{aligned}\r\nS_{1}&amp;=\\langle x_{1}, x_{2}, x_{3}, x_{4},x_{5}, x_{6}, x_{7},\r\nx_{8}\\rangle\\\\\r\nS_{9}&amp;=\\langle x_{9}, x_{10}, x_{11}, x_{12},x_{13}, x_{14}, x_{15},\r\nx_{16}\\rangle\\\\\r\n\\end{aligned}\\)\r\n第9行完成后为：\r\n\\(\\begin{aligned}\r\nS_{1}&amp;=\\langle x_{1}, x_{2}, x_{3}, x_{4},x_{5}, x_{6}, x_{7},\r\nx_{8}, x_{9}, x_{10}, x_{11}, x_{12},x_{13}, x_{14}, x_{15},\r\nx_{16}\\rangle\\\\\r\n\\end{aligned}\\)\r\n因此第10行和第11行的返回结果均为\\(S_1\\)。\r\n19.2-3\r\n考虑目前总共有\\(m\\)个操作，其中有\\(a(a&lt; n)\\)个UNION操作，\\(b\\)个FIND-SET操作以及\\(m-a-b\\)个MAKE-SET操作。\r\n令\\(c_i\\)表示第\\(i\\)个操作的代价，\\(\\widehat{c_i}\\)为第\\(i\\)个操作的均摊代价。按照定理19.1的分析，对于某一个元素而言，只要对它更新到一个新的集合，那么新的集合的大小至少为当前集合的\\(2\\)倍。由于只有\\(a\\)个UNION操作，因此这部分时间的总和为\\(O(a\\lg n)\\)。最终，存在正常数\\(c\\)，使得\\(\\displaystyle{\\sum_{i=1}^m c_i\\le cm+ca\\lg\r\nn}\\)成立。\r\n假设MAKE-SET和FIND-SET的均摊代价为\\(c\\)，UNION的均摊代价为\\(c(\\lg n+1)\\)，那么其总均摊代价为\\(\\displaystyle{\\sum_{i=1}^m\\widehat{c_i}=cb+c(m-a-b)+ca(\\lg\r\nn+1)=cm+ca\\lg n}\\)。即可有\\(\\displaystyle{\\sum_{i=1}^m\\widehat{c_i}\\ge\r\n\\sum_{i=1}^mc_i}\\)，均摊代价足够。\r\n因此可知，MAKE-SET和FIND-SET的均摊代价为\\(O(1)\\)，UNION的均摊代价为\\(O(\\lg n)\\)。\r\n19.2-4\r\n前\\(n\\)个MAKE-SET操作的时间复杂度保持，仍然为\\(O(1)\\)。对于后面的\\(n-1\\)个UNION操作，第\\(i\\)个操作是将\\(1\\)个元素所代表的集合合并到\\(n-1\\)个元素所代表的集合中。由于使用了启发式合并策略，较小的集合总是只有\\(1\\)个元素，因此一次UNION操作只需要\\(O(1)\\)的时间。因此图19-3的运行时间为\\((2n-1)\\cdot O(1)=O(n)\\)。\r\n19.2-5\r\n考虑如下改造：这时每个链表的最后一个节点成为了代表元素，每个节点的属性\\(r\\)将不会再链接到某个链表，取而代之的是指向链表的最后一个节点\\(z\\)，并且链表\\(L\\)舍去了属性\\(tail\\)，只保留属性\\(head\\)。此外，\\(L\\)中的所有节点将会和\\(L\\)自身构成一个循环链表，也就是说，\\(z.next\\)将指向\\(L\\)。\r\n改写后的算法MAKE-SET'和UNION'的代码如下所示。可以发现，UNION'操作均摊后的时间复杂度仍然为\\(O(\\lg n)\\)。\r\nMAKE-SET&#x27;(z)  Let L be a new link list  L.head = z  L.size = 1  z.next = L  z.r = zUNION&#x27;(x, y)  L1 = x.r.next  L2 = y.r.next  if L1.size &gt; L2.size    exchange L1 with L2  // 此时保证了L1.size &lt;= L2.size  // 这个操作是将链表L1接在了L2前面    L1.size = L2.size + L1.size  p = L1.head  // 先让L1中的所有节点的r属性指向L2的tail  while p != T1    p.r = L2.head.r    p = p.next  // L1.head.r是L1.tail  L1.head.r.next = L2.head  L2.head.r.next = L1  L2.tail = L1.tail  //销毁已经没用的头节点  Destroy link list L2  return L1\r\n19.2-6\r\n考虑同时使用两个指针在链表\\(L_1,L_2\\)上进行遍历，并且随着遍历过程进行，这两个链表逐渐被一个接一个地合并在一起，直到其中一个链表到达终点，最终将这些链表的代表节点重新进行标记即可。在这种情况下，每个节点的\\(r\\)属性可以指向链表自身。改写后的算法MAKE-SET''和UNION''的代码如下所示。\r\nMAKE-SET&#x27;&#x27;(z)  Let L be a new link list  L.head = z  z.r = L  z.next = NILUNION&#x27;&#x27;(x, y)  L1 = x.r  L2 = y.r  p = L1.head.next  q = L2.head.next  head = L1.head  head.next = L2.head  o = head.next  while p != NIL and q != NIL    o.next = p    o.next.next = q    p = p.next    q = q.next    o = o.next.next  o.next = NIL  s = head  if p != NIL    while s != NIL      s.r = T1      s = s.next    T1.head = r    Destroy link list L2    return T1  else    while s != NIL      s.r = T2      s = s.next    T2.head = r    Destroy link list L1    return T2\r\n","categories":["算法导论"]},{"title":"算法导论19.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-19/exercises-3/","content":"\r\n19.3-1\r\n为了方便，此处作图忽略了箭头和自环。\r\n一开始，所有树的\\(rank\\)都为\\(0\\)。\r\ngraph TBA((1));B((2));C((3));D((4));E((5));F((6));G((7));H((8));I((9));J((10));K((11));L((12));M((13));N((14));O((15));P((16));\r\n在第3-4行的循环完成后，所有的树的\\(rank\\)变成了\\(1\\)。\r\ngraph TBA((1));B((2));C((3));D((4));E((5));F((6));G((7));H((8));I((9));J((10));K((11));L((12));M((13));N((14));O((15));P((16));A---B;C---D;E---F;G---H;I---J;K---L;M---N;O---P;\r\n在第5-6行的循环完成后，所有的树的\\(rank\\)变成了\\(2\\)。\r\ngraph TBA((1));B((2));C((3));D((4));E((5));F((6));G((7));H((8));I((9));J((10));K((11));L((12));M((13));N((14));O((15));P((16));D---B;D---C;B---A;H---F;H---G;F---E;L---J;L---K;J---I;P---N;P---O;N---M;\r\n第7行完成后如下，其中第一棵树的\\(rank\\)为\\(3\\)，其余的\\(rank\\)为\\(2\\)。\r\ngraph TBA((1));B((2));C((3));D((4));E((5));F((6));G((7));H((8));I((9));J((10));K((11));L((12));M((13));N((14));O((15));P((16));H---D;H---E;H---F;H---G;D---A;D---B;D---C;L---J;L---K;J---I;P---N;P---O;N---M;\r\n第8行完成后如下，两棵树的\\(rank\\)都是\\(3\\).\r\ngraph TBA((1));B((2));C((3));D((4));E((5));F((6));G((7));H((8));I((9));J((10));K((11));L((12));M((13));N((14));O((15));P((16));H---D;H---E;H---F;H---G;D---A;D---B;D---C;P---L;P---M;P---N;P---O;L---J;L---K;J---I\r\n第9行完成后如下，这棵树的\\(rank\\)为\\(4\\)。\r\ngraph TBA((1));B((2));C((3));D((4));E((5));F((6));G((7));H((8));I((9));J((10));K((11));L((12));M((13));N((14));O((15));P((16));H---D;H---E;H---F;H---G;H---A;D---B;D---C;P---H;P---L;P---M;P---N;P---O;P---J;L---K;J---I\r\n第10行完成后如下，这棵树的\\(rank\\)为\\(4\\)。\r\ngraph TBA((1));B((2));C((3));D((4));E((5));F((6));G((7));H((8));I((9));J((10));K((11));L((12));M((13));N((14));O((15));P((16));P---B;P---D;H---A;H---E;H---F;H---G;D---C;P---H;P---J;P---L;P---M;P---N;P---O;L---K;J---I\r\n第11行完成后如下，这棵树的\\(rank\\)为\\(4\\)。\r\ngraph TBA((1));B((2));C((3));D((4));E((5));F((6));G((7));H((8));I((9));J((10));K((11));L((12));M((13));N((14));O((15));P((16));P---B;P---D;H---A;H---E;H---F;H---G;D---C;P---H;P---I;P---J;P---L;P---M;P---N;P---O;L---K;\r\n19.3-2\r\nFIND-SET-ITERATIVE(x)  let A be new array  while x != x.p    INSERT(A, x)    x = x.p  for each y in A    y.p = x  return x\r\n19.3-3\r\n当\\(m\\)足够大时（也就是有\\(m\\ge 2n-1\\)），我们只需要构造一个\\(m\\)个操作序列，从而证明其总共所需要的操作时间为\\(\\Omega(n\\lg\r\nm)\\)即可。这个操作序列如下：\r\nUNION-SEQUENCE(n, m)  for i = 1 to n    MAKE-SET(x_&#123;i&#125;)  k = 2  while k &lt;= n    for i = k / 2 to n by k      UNION(x_&#123;i - k / 2&#125;, x_&#123;i&#125;)  for i = 1 to m - (2 * n - 1)    FIND-SET(x_&#123;1&#125;)\r\n在这个序列中，可以知道while循环最多可以迭代\\(\\lceil\\lg (n+1)\\rceil\\)轮，其中当\\(k\\)为某个\\(2\\)的幂时，内部的for循环恰好会执行\\(\\lfloor n/k\\rfloor\\)次。可以发现，\\(\\displaystyle{\\sum_{i=1}^{\\infty}\\left\\lfloor\\dfrac{n}{2^i}\\right\\rfloor=n-1}\\)，也就是说，这\\(n-1\\)个操作将所有集合合并在了一起。考虑第\\(i(i\\ge 1)\\)轮操作，其中\\(k=2^i\\)。那么在第\\(i\\)轮合并开始前，每\\(2^{i-1}\\)个元素都会合并在一起，它们所在树的秩都是一样的（除了最后一棵可能不足）；合并后，每\\(2^i\\)个元素都会合并在一起，它们所在树的秩仍然都是一样的（除了最后一棵可能不足），相比之前，这些树的秩都增加了\\(1\\)。因此，最终经过这\\(n-1\\)次操作后，这棵树的高度为\\(\\Omega(\\lg n)\\)。\r\n在这\\(m\\)次操作中，有\\(n\\)次MAKE-SET操作，\\(n-1\\)次UNION操作，其余\\(m-(2n-1)\\)次都是FIND操作。由于每次UNION操作都会调用\\(2\\)次FIND-SET操作，因此这个操作序列中总共进行了\\(m-1\\)次FIND-SET操作。如果每次FIND-SET操作都是取秩大的那棵树下最深的点，那么一次FIND-SET操作需要花费的时间为\\(\\Omega(\\lg\r\nn)\\)，最终全部操作所需要花费的时间为\\(\\Omega(m\\lg n)\\)。\r\n19.3-4\r\n添加一个参数\\(next\\)即可。将这些节点使用一个循环链表组织起来，在进行一次合并操作时，就将这两个循环链表断开并合并即可。打印时，只需要遍历这一整个循环链表即可。\r\n只需要修改MAKE-SET和UNION操作，不需要修改FIND-SET操作。此后将连通PRINT-SET操作一同给出：\r\nMAKE-SET2(x)  x.p = x  x.rank = 0  x.next = xUNION2(x, y)  LINK(FIND-SET(x), FIND-SET(y))  p = x.next  x.next = y.next  y.next = pPRINT-SET(x)  print x  p = x.next  while p != x    print p\r\n\\(\\star\\)\r\n19.3-5\r\n注意到每次LINK操作只需要花费\\(O(1)\\)的时间，并且它的LINK操作所输入的参数都是每棵树的根节点。\r\n由于所有LINK操作都在FIND-SET操作的前面，因此在第一个FIND-SET操作执行前，整个森林的结构已经确定好了。\r\n考虑使用核算法证明这个长度为\\(m\\)的操作序列的时间复杂度为\\(O(m)\\)：\r\n\r\n每个MAKE-SET操作均摊\\(2\\)美元，其中\\(1\\)美元用于自身节点的创建，另\\(1\\)美元用于信用预支，在FIND-SET操作中使用。\r\n每个LINK操作均摊\\(1\\)美元，这类操作仅仅用于将一棵树的根指向另外一棵树的根。\r\n每个FIND-SET操作均摊\\(1\\)美元。分别考虑两种情况：如果节点\\(x\\)曾经被FIND-SET调用过，那么直接返回\\(x.p\\)即可，\\(1\\)美元支撑此开销；否则，预支的\\(1\\)美元用于寻找\\(x.p\\)的祖先。考虑从\\(x\\)到它的根\\(r\\)这一条路径\\(v_1,v_2,\\dots,v_k\\)，其中\\(v_1=x,v_{k}=r\\)。那么对于\\(i=1,2,\\dots,k-2\\)，节点\\(v_i\\)必定未被调用过FIND-SET（否则，\\(v_i\\)的下一个节点必定是\\(r\\)）。因此，这些节点的预支的\\(1\\)美元仍未被使用，这总共\\(k-2\\)美元的预支都将帮助到\\(v_1,v_2v\\dots,v_{k-2}\\)指向根节点。接下来，只需要花费\\(1\\)美元将\\(x.p\\)返回即可。\r\n\r\n由于所有操作中，单个操作需要不超过\\(2\\)美元即可。因此，这\\(m\\)个操作总共需要花费的时间为\\(O(m)\\)。\r\n如果再添加上按秩合并，并不影响它仍然只需要\\(O(m)\\)的时间，因为LINK操作的花费仍然是常数。\r\n","categories":["算法导论"]},{"title":"算法导论19.4 Exercises 答案","url":"/introduction-to-algorithms/chapter-19/exercises-4/","content":"\r\n19.4-1\r\n正如MAKE-SET操作的第2行所示，一个节点的\\(rank\\)属性会被初始化为\\(0\\)。\r\n当节点\\(x\\)是其所在的树的根时，按照定义，有\\(x=x.p\\)，因此有\\(x.rank=x.p.rank\\)。原来的不等式成立。\r\n当节点\\(x\\)不是其所在的子树的根时，那么有\\(x\\neq x.p\\)，令\\(y=x.p\\)。不难发现，\\(y\\)是有两种途经得到的：调用LINK，根节点\\(x\\)被链接到根节点\\(y\\)下；或者是调用FIND后，经过路径压缩得到\\(x.p=y\\)。\r\n首先讨论第1种情况。可见，在LINK操作中，必定有\\(x.rank\\le\r\ny.rank\\)（否则，LINK操作之后不会有\\(x.p=y\\)）。如果在LINK操作执行前，有\\(x.rank&lt;y.rank\\)，那么执行之后不会改变两个节点的\\(rank\\)属性；如果有\\(x.rank=y.rank\\)，那么按照\\(y.rank\\)的值会提升\\(1\\)，从而保证操作结束仍然满足\\(x.rank&lt;y.rank\\)。\r\n对于第2种情况，在对\\(x\\)执行FIND操作前，有一条从\\(x\\)到\\(y\\)的路径\\(v_1,v_2,\\dots,v_k\\)，其中\\(v_1=x,v_k=y\\)，根据第1种情况的结论，有\\(v_1.rank&lt;v_2.rank&lt;\\dots&lt;v_k.rank\\)，因此\\(v_1.rank&lt;v_2.rank\\)，路径压缩完成后，有\\(x.rank&lt;y.rank\\)，原结论仍然成立。\r\n因此，由于\\(x.p\\neq\r\nx\\)，小于号是严格成立的。\r\n\\(rank\\)的变化只发生在LINK操作中。当\\(x\\neq x.p\\)时，\\(x\\)不是其所在子树的根，因此\\(x\\)从此不会作为LINK的参数，即\\(x.rank\\)不会再变化。此外，根据LINK代码的第5行可知，\\(rank\\)属性不会下降，因为它只会在某次满足if条件的操作中对其进行加\\(1\\)。\r\n19.4-2\r\n考虑使用归纳法来进行证明这个结论。\r\n当\\(n=1\\)时，无需进行任何UNION操作，也就是说，最大\\(rank\\)属性有\\(\\lfloor\\lg\r\n1\\rfloor=0\\)，因此原结论成立。\r\n当\\(n&gt;1\\)时，假设对于\\(k=1,2,\\dots,n-1\\)，\\(rank\\)属性的最大值均为\\(\\lfloor\\lg k\\rfloor\\)。那么考虑\\(k=n\\)时的情况，假设现在有两棵非空的子树，大小分别为\\(a,b\\)（满足\\(a+b=n\\)，不失一般性，假设\\(1\\le a\\le\r\nb&lt;n\\)），那么考虑如下两种情况：\r\n\r\n两棵树的最大\\(rank\\)属性\\(\\lfloor\\lg a\\rfloor\\)和\\(\\lfloor\\lg b\\rfloor\\)满足\\(\\lfloor\\lg a\\rfloor\\neq\\lfloor\\lg\r\nb\\rfloor\\)。那么对这两棵树进行LINK操作时，第4行代码判断必定为FALSE，最终合并后的树的\\(rank\\)属性为\\(\\lfloor\\lg b\\rfloor\\le \\lfloor\\lg\r\nn\\rfloor\\)，原结论成立。\r\n\\(\\lfloor\\lg a\\rfloor\\)和\\(\\lfloor\\lg b\\rfloor\\)满足\\(\\lfloor\\lg a\\rfloor=\\lfloor\\lg\r\nb\\rfloor\\)。那么对这两棵树进行LINK操作时，第4行代码判断必定为TRUE，最终合并后的树的\\(rank\\)属性为\\(\\lfloor\\lg a\\rfloor+1\\)。由于\\(1\\le a\\le b&lt;n\\)，这意味着\\(a\\le n/2\\)，因此有\\(\\lfloor\\lg a\\rfloor+1\\le\\lfloor1+\\lg\r\n(n/2)\\rfloor=\\lfloor\\lg n\\rfloor\\)。因此原结论成立。\r\n\r\n最终，原结论得证。\r\n19.4-3\r\n根据题目19.4-3可知，\\(rank\\)属性的最大值为\\(\\lfloor\\lg n\\rfloor\\)。为了保证从\\(0\\)到\\(m\\)中的所有整数都被正确表示，需要\\(\\lceil\\lg(m+1)\\rceil\\)比特才能正确表示。因此最终答案为\\(\\lceil\\lg(\\lfloor\\lg\r\nn\\rfloor+1)\\rceil\\)。\r\n19.4-4\r\n假设一个长度为\\(m(m\\ge\r\nn)\\)的操作序列中，包含了\\(n\\)次MAKE-SET操作，\\(a(a&lt;n)\\)次UNION操作，其余为FIND-SET操作。每一次MAKE-SET操作仅仅是将节点信息初始化，花费\\(O(1)\\)的时间。每一次UNION操作可以分解成两次FIND-SET和一次\\(O(1)\\)时间的LINK操作。最终，这个长度为\\(m\\)的序列可以视为是\\(a+n\\)次的\\(O(1)\\)操作和\\(m-n-a+2a=m-n+a&lt;m\\)次FIND-SET操作。由于整棵树的深度最多为\\(\\lfloor\\lg n\\rfloor\\)，因此这\\(m\\)次的时间开销为\\(m\\cdot O(\\lg n)+2n\\cdot O(1)=O(m\\lg\r\nn)\\)。\r\n19.4-5\r\n不正确。考虑从\\(x\\)起的向根方向的三个节点\\(x,y,z\\)，并且有\\(x.rank=1,y.rank=4,z.rank=5\\)。那么可以得知，\\(A_2(1)=7&gt;4,A_1(1)=3\\le 4\\)，因此有\\(\\text{level}(x)=1\\)同时可以得知\\(A_1(4)=9&gt;5,A_0(4)=5\\)，因此有\\(\\text{level}(y)=0\\)。\r\n也就是说，\\(\\text{level}\\)值并非是自底向上单调递增的，因此原结论错误。\r\n19.4-6\r\n对于一次FIND-SET操作，假设除去递归调用所消耗的时间，其单次调用所产生的开销最多为常数\\(c\\)。那么令\\(\\phi_q&#39;(x)=c\\cdot\\phi_q(x),\\Phi_q&#39;=c\\cdot\\Phi_q\\)，引理19.8和推论19.9,\r\n19.10和19.14的推理使用\\(\\phi&#39;_q\\)，都需要对它们的系数都要乘上\\(c\\)。\r\n对于19.14的最后一步推理，对这\\(s\\)个节点的实际花费为\\(\\displaystyle{\\sum_{i=1}^s w_i\\le\r\ncs}\\)。此外，由于其至少有\\(s-(\\alpha(n)+2)\\)的势\\(\\phi&#39;_q\\)至少下降了\\(c\\)（因为当初\\(\\phi_q\\)至少下降了\\(1\\)），因此这次的FIND-SET操作的均摊开销为：\r\n\\(\\begin{aligned}\r\n\\sum_{i=1}^s\\widehat{w_i}&amp;=\\sum_{i=1}^sw_i+\\Delta\\Phi&#39;_q\\\\\r\n&amp;\\le cs+\\Delta\\Phi&#39;_q\\\\\r\n&amp;\\le cs-c\\cdot(s-\\alpha(n)+2)\\\\\r\n&amp;=c\\cdot\\alpha(n)-2c\\\\\r\n&amp;\\le c\\cdot\\alpha(n)\r\n\\end{aligned}\\)\r\n由于\\(c\\)为常数，因此这次FIND-SET操作的均摊开销为\\(O(\\alpha(n))\\)。\r\n\\(\\star\\)\r\n19.4-7\r\n按照定义，有\\(\\alpha&#39;(n)=\\alpha(\\lg(n+1))\\)。\r\n如果\\(\\alpha&#39;(n)\\le\r\n3\\)，那么意味着\\(\\alpha(\\lg(n+1))\\le\r\n3\\)，根据\\(\\alpha\\)的范围定义，可以得出\\(\\lg(n+1)\\le 2047\\)，也就是\\(n\\le\r\n2^{2047}-1\\)，这已经远远超过了我们所需要的实际值范围。因此对于\\(n\\)的所有实际值，均有\\(\\alpha&#39;(n)\\le 3\\)。\r\n接下来证明这\\(m\\)个操作序列的时间复杂度可以达到\\(O(m\\alpha&#39;(n))\\)。我们可以进一步证明：\\(\\text{level}(x)&lt;\\alpha&#39;(n)\\)，这是因为：\r\n\\(\\begin{aligned}\r\nA_{\\alpha&#39;(n)}(x.rank)&amp;\\ge A_{\\alpha&#39;(n)}(1)\\\\\r\n&amp;\\ge \\lg(n+1)\\\\\r\n&amp;&gt; \\lfloor\\lg n\\rfloor\\\\\r\n&amp;\\ge x.p.rank&amp;\\qquad(A)\r\n\\end{aligned}\\)\r\n其中步骤\\((A)\\)是根据题目19.4-2得出的。因此有\\(\\text{level}(x)&lt;\\alpha&#39;(n)\\)。\r\n此外，对于等式19.7，我们构造出类似的势函数\\(\\phi_q&#39;(x)\\)：\r\n\\(\\phi&#39;_q(x)= \\left\r\n\\{\\begin{aligned}  &amp;\\alpha&#39;(n)\\cdot x.rank &amp; &amp; \\text{if\r\n} x\\text{ is a root or }x.rank=0 \\\\\r\n&amp;(\\alpha&#39;(n)-\\text{level}(x))\\cdot x.rank-\\text{iter}(x)&amp;\r\n&amp; \\text{if } x\\text{ is not a root and }x.rank&gt;1\r\n\\\\\\end{aligned}\\right.\\)\r\n那么，引理19.8相当于是证明\\(0\\le\r\n\\phi&#39;_q(x)\\le \\alpha&#39;(n)\\cdot\r\nx.rank\\)，证明过程和原版完全一致，由此可以因此类似的推论19.9：对于一个非根节点\\(x\\)并且\\(x.rank&gt;1\\)，有\\(\\phi_q&#39;(x)&lt;\\alpha&#39;(n)\\cdot\r\nx.rank\\)。引理19.10, 19.11, 19.12,\r\n19.13的证明过程和原版一致，最终得到这\\(m\\)个操作序列的总时间复杂度为\\(O(m\\alpha&#39;(n))\\)。\r\n","categories":["算法导论"]},{"title":"算法导论20.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-20/exercises-1/","content":"\r\n20.1-1\r\n我们只需要遍历整个邻接表，并且遍历这个节点下的邻接表即可计算出这个链表的大小，也就是这个点的出度。因此计算所有节点的出度的开销为\\(\\Theta(|V|+|E|)\\)。\r\n至于入度，我们仅需要维护一个大小为\\(|V|\\)的计数器，并且遍历邻接表中，某个节点被其它节点指向的个数即可。因此计算所有节点的入读的开销仍然为\\(\\Theta(|V|+|E|)\\)。\r\n20.1-2\r\n假设这棵完全二叉树的形状如下：\r\n\r\n那么这个图的邻接表和邻接矩阵分别为：\r\n\\[\\begin{aligned}\r\n&amp;1:2\\rightarrow 3\\\\\r\n&amp;2:1\\rightarrow4\\rightarrow5\\\\\r\n&amp;3:1\\rightarrow6\\rightarrow7\\\\\r\n&amp;4:2\\\\\r\n&amp;5:2\\\\\r\n&amp;6:3\\\\\r\n&amp;7:3\r\n\\end{aligned}\\qquad\\begin{array}{l|llllll}\r\n&amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7\\\\\r\n\\hline\r\n1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\\\\r\n2 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0  \\\\\r\n3 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1  \\\\\r\n4 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\\\\r\n5 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\\\\r\n6 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\\\\r\n7 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\\\\r\n\\end{array}\\]\r\n20.1-3\r\n邻接表：\r\nADJACENCY-LIST-TRANSPOSE(G)  令GT为一个新图。  GT.V = G.V  for each u in G.V    for each v in G.Adj[u]      ENLIST(GT.Adj[v], u)  return GT\r\n这个算法外循环遍历了每个节点，所有内循环的总和恰好遍历了每一条有向边，因此运行时间为\\(\\Theta(|V|+|E|)\\)。\r\n邻接矩阵：\r\nADJACENCY-MATRIX-TRANSPOSE(G)  令GT为一个新图。  GT.V = G.V  for each u in G.V    for each v in G.V      GT.a[u,v] = G.a[v,u]  return GT\r\n这个算法的两重循环遍历了每个节点，因此运行时间为\\(\\Theta(|V|^2)\\)。\r\n20.1-4\r\nEQUIVALENT-UNDIRECTED-GRAPH(G)  令G&#x27;为一个新图。  // 数组vis是一个长度为|V|的数组，所有值初始化为-1。  G&#x27;.V = G.V  for each u in G.V    for each v in G.Adj[u]      if u != v and vis[v] != u        ENLIST(G&#x27;.Adj[u],v)        vis[v] = u  return G&#x27;\r\n在节点为\\(u\\)的外循环中，当节点\\(v\\)已经被访问过，那么有vis[v] == u，否则这条边还不存在，可以添加。\r\n外循环恰好遍历了图\\(G\\)中的所有节点，内循环恰好遍历了图中的所有边，而if语句内的程序都可以通过常数时间完成。因此整个程序EQUIVALENT-UNDIRECTED-GRAPH的运行时间为\\(\\Theta(|V|+|E|)\\)。\r\n20.1-5\r\n邻接表：\r\nfADJACENCY-LIST-SQUARE(G)  令G&#x27;为一个新图。  for each u in G.V    for each v in G.Adj[u]      ENLIST(G&#x27;.Adj[u], v)      for each w in G.Adj[v]        ENLIST(G&#x27;.Adj[u], w)  return EQUIVALENT-UNDIRECTED-GRAPH(G&#x27;)\r\n前两个循环恰好遍历了图中的每个节点和每条边。可以知道，第三重循环的上界是每个节点\\(v\\)都存在G.Adj[v]中。因此前6行的程序的运行时间为\\(O(|V||E|)\\)，第7行程序则将题目20.1-4的程序作为子程序运行，运行时间为\\(O(|V|+|V||E|)\\)。因此将所有运行时间相加，最终得到ADJACENCY-LIST-SQUARE(G)的运行时间为\\(O(|V||E|)\\)。\r\n邻接矩阵：\r\nfADJACENCY-MATRIX-SQUARE(G)  令G&#x27;为一个新图。  G&#x27;.V = G.V  B = Strassen2(G.A,G.A,|V|)  Let C be a new n × n matrix.  for each u in G.V    for each v in G.V      G&#x27;.A[u,v] = min(1, C[u,v] + G.A[u,v])  return G&#x27;\r\n其中，子程序Strassen2是可以计算任意方形矩阵乘法的算法（使用Strassen了算法），因此第3行的时间复杂度为\\(\\Theta(|V|^{\\lg\r\n7})\\)。此后，第4-6行的程序是考虑有直接相连的边，这3行程序的时间复杂度为\\(\\Theta(|V|^2)\\)。因此总时间复杂度为\\(\\Theta(|V|^{\\lg 7})\\)。\r\n20.1-6\r\n题目本质上是通过\\(O(n)\\)的时间复杂度，判断一个01矩阵\\(A\\)是否存在一个\\(k\\)，使得对于所有\\(i\\neq k,a_{ki}=0,a_{ik}=1\\)均成立。\r\n可以写出如下程序判断\\(G\\)是否含有汇点：\r\nIS-CONTAIN-UNIVERSAL-SINK(G)  i = j = 1  while i &lt; |G.V| and j &lt; |G.V|    if G.a[i,j] == 1      i = i + 1    else       j = j + 1  return IS-SINK(G, i) or IS-SINK(G, |V|)IS-SINK(G, k)  for i in 1 to |G.V|    if i != k and not (G.a[k,i] == 0 and G.a[i,k] == 1)      return 0  return 1\r\n其中，主程序IS-CONTAIN-UNIVERSAL-SINK用于判断图\\(G\\)是否有汇点；子程序IS-SINK则用于判断节点\\(k\\)是否为\\(G\\)的汇点。\r\n可以发现，IS-CONTAIN-UNIVERSAL-SINK中的while循环最多只会执行\\(2|V|-2\\)次，判断汇点的时间复杂度是\\(\\Theta(|V|)\\)，因此整个算法的时间复杂度是\\(O(V)\\)。\r\n正确性：由于\\(a_{ii}=0\\)，因此在迭代的过程中，变量\\(i,j\\)总满足\\(i\\le\r\nj\\)。在while循环结束时，必定有\\(i&lt; j\\)，因此需要额外判断节点\\(|V|\\)是否为汇点。当while循环停下时，对于\\(k\\in\r\n[1,i)\\)，它们被第4行的代码遍历过，也就是说，这些节点有出边，因此不可能是汇点。对于\\(k\\in (i,|V|]\\)，都有\\(a_{ki}=0\\)，这些节点没有来自\\(i\\)的入边，因此不可能是汇点，因此只需要对节点\\(i\\)进行判断即可。\r\n20.1-7\r\n可以得到\r\n\\(\\begin{aligned}\r\n(bb^T)_{ij}=\\sum_{e=1}^{|E|} b_{ie} \\cdot b_{ej}^T=\\sum_{e=1}^{|E|}\r\nb_{ie}\\cdot b_{je}\r\n\\end{aligned}\\)\r\n那么，\r\n\r\n当\\(i=j\\)时，\\(b_{ii}=\\displaystyle{\\sum_{e=1}^{|E|}\r\nb_{ie}^2=\\sum_{e=1}^{|E|} |b_{ie}|}\\)，那么\\(b_{ii}\\)是节点\\(i\\)的出度和入度之和。\r\n当\\(i\\neq\r\nj\\)时，如果这是一条有向边\\((i,j)\\)，那么\\(b_{ie}b_{je}=-1\\)，否则\\(b_{ie}b_{je}=0\\)。因此\\(b_{ij}\\)是有向边\\((i,j)\\)的条数的负数。\r\n\r\n20.1-8\r\n期望的查询时间复杂度为\\(O(1)\\)。缺陷在于如果散列表设计不佳，有可能一次查询就达到了最坏的时间复杂度\\(O(|V|)\\)。\r\n在添加完所有边后，可以考虑用一个向量存储G.Adj[u]并排序，并且使用二分查找来进行判断节点\\(v\\)是否在其中。缺点如下：\r\n\r\n这种做法的期望时间复杂度为\\(O(\\lg\r\nn)\\)，高于使用散列表时的\\(O(1)\\)。\r\n如果这张图是动态变化的，那么添加一条新边时开销很大（使用插入排序的思想进行插入）。为了解决这个问题，可以使用树结构解决。\r\n\r\n","categories":["算法导论"]},{"title":"算法导论19 Problems 答案","url":"/introduction-to-algorithms/chapter-19/problems/","content":"\r\n19-1\r\na\r\n随着操作进行，集合\\(T\\)和数组\\(extracted\\)的变化如下：\r\n\\(\\begin{array}{|l|l|l|}\\hline\r\nS&amp;T&amp;extracted\\\\\\hline\r\n4&amp;4&amp;\\\\\\hline\r\n8&amp;4,8&amp;\\\\\\hline\r\nE&amp;8&amp;4\\\\\\hline\r\n3&amp;3,8&amp;4\\\\\\hline\r\nE&amp;8&amp;4,3\\\\\\hline\r\n9&amp;8,9&amp;4,3\\\\\\hline\r\n2&amp;2,8,9&amp;4,3\\\\\\hline\r\n6&amp;2,6,8,9&amp;4,3\\\\\\hline\r\nE&amp;6,8,9&amp;4,3,2\\\\\\hline\r\nE&amp;8,9&amp;4,3,2,6\\\\\\hline\r\nE&amp;9&amp;4,3,2,6,8\\\\\\hline\r\n1&amp;1,9&amp;4,3,2,6,8\\\\\\hline\r\n7&amp;1,7,9&amp;4,3,2,6,8\\\\\\hline\r\nE&amp;7,9&amp;4,3,2,6,8,1\\\\\\hline\r\n5&amp;5,7,9&amp;4,3,2,6,8,1\\\\\\hline\r\n\\end{array}\\)\r\nb\r\n当某一个数\\(i\\)在OFFLINE-MINIMUM的第2行被确认位置后，此后再也不需要再访问它，因此可以认为\\(i\\)从这些集合\\(\\{K_j\\}\\)中被删除了（符合EXTRACTED-MIN的定义）。我们从小到大枚举数\\(i\\)，并且确认了\\(i\\)的位置\\(j\\)后，\\(extract[j]\\)被填上了\\(i\\)，此后集合\\(K_j\\)中的所有元素被合并到了比\\(j\\)大的仍然存在的一个集合\\(K_l\\)中，并且集合\\(j\\)被销毁。因此，随着每一步的进行，对于\\(p\\in[1,m]\\)，要么\\(extract[p]\\)未被填充；要么\\(K_p\\)被销毁，每次\\(K_p\\)被销毁，它总是会将这些数转移到下一个潜在的最优集合中。因此整个算法的正确性是成立的。\r\nc\r\n直接使用并查集，并在其中维护一些信息即可。初始化一个长度为\\(m\\)的链表\\(L\\)，用于表示哪些集合被删除了。随着合并过程的进行，\\(L\\)中的节点将被删除。\r\nOFFLINE-MINIMUM&#x27;(m, n, K)  let L be a new doublie link list  let P[1 : m + 1] be a new array  let extracted[1 : m] be a new array  for i = 1 to m + 1    Let p be a new list node    p.key = i    P[i] = p    LIST-INSERT&#x27;(L, p)    // 链表节点的q属性是指属于这个集合的某个元素。    if K[i].size &gt; 0      p.q = K[i][1]    else      p.q = NIL  // 每个节点（关键字）都会多一个属性g，表示在哪一个组里。  for i = 1 to m + 1    for each x in K[i]      MAKE-SET(x, i)      x.g = i  for i = 1 to n    j = i.g    if j != m + 1      extracted[j] = i      z = P[i]      z = z.next      LIST-DELETE&#x27;(L, P[i])      if z.q != NIL        UNION(i, z.q)      x = FIND-SET(i)      x.g = z.key  return extracted\r\n由于OFFLINE-MINIMUM'中的所有过程都只是调用了\\(n\\)次MAKE-SET，至多\\(m-1\\)次UNION操作和FIND-SET操作（\\(m&lt;n\\)），其余操作都是常数开销的操作，因此整个OFFLINE-MINIUM'算法的时间复杂度为\\(O(n\\alpha(n))\\)。\r\n19-2\r\na\r\n考虑如下\\(m\\)个操作序列：前\\(m/3\\)个操作为MAKE-TREE操作，它们创建了\\(m/3\\)棵包含唯一节点的树，所需要花费的时间总共为\\(O(m)\\)；之后的\\(m/3-1\\)个为GRAFT操作，将前面的\\(m/3\\)个节点首尾相接串联了起来，所需要花费的时间总共为\\(O(m)\\)；剩下的\\(m/3+1\\)个操作是FIND-DEPTH操作，每次调用的都是这棵树的叶子节点，每次所需要花费的时间为\\(\\Theta(m)\\)（因为需要上升到根），那么最终，这\\(m/3+1\\)次操作花费了\\(\\Theta(m^2)\\)的时间来完成。\r\n因此，如上构造的操作序列需要花费\\(\\Theta(m^2)\\)的时间来完成，原结论成立。\r\nb\r\n这个实现仅仅是多添加了一个属性\\(d\\)，并且将其初始化成\\(0\\)。\r\nMAKE-TREE(x)  MAKE-SET(x)  // 一开始节点x并没有祖先  x.d = 0\r\nc\r\n修正后给出的是FIND-SET'算法，先从当前节点到根节点求出一条路径，求出这条路径后，再自顶向下更新伪距离值，从而成为真实距离。当\\(x.p\\)的真实距离被求出后，加上当前\\(x\\)的伪距离\\(x.d\\)就成为了\\(x\\)的真实距离，在这个过程中，路径也被压缩。\r\nFIND-SET&#x27;(x)  if x != x.p    q = FIND-SET&#x27;(x.p)    x.d = x.p.d + x.d    x.p = q  return x.pFIND-DEPTH(x)  FIND-SET&#x27;(x)  // 此时确保了x直接连上了根，并且d属性已经被更新好  return x.d\r\nd\r\n为了方便操作，我们将类似LINK操作合并到了UNION操作中。假设\\(r\\)所在不相交集合\\(S_i\\)的根为\\(x\\)，\\(v\\)所在不相交集合\\(S_j\\)为的根为\\(y\\)。需要注意的是，当\\(S_j\\)被合并入\\(S_i\\)时，如果直接合并，那么\\(y\\)从没有父节点，到变成了多出一个父节点\\(x\\)，其伪距离值为\\(x.d\\)。但实际上，\\(S_j\\)所在子树的深度并没有增加，因此需要对\\(y.d\\)减去\\(x.d\\)，以保证伪距离仍然正确。\r\nGRAFT(r, v)  x = FIND-SET&#x27;(r)  y = FIND-SET&#x27;(v)  if x.rank &gt; y.rank    y.p = x    // 也就是说，以x为根的所有子树的深度都增加了v.d + 1    x.d = x.d + v.d + 1    // 但是y.p = x意味着y多了一个父节点x，以y为子树的深度增加了x.p + 1。按照差分的思想，需要减回去。    y.d = y.d - x.d  else    // 此时y没有受到影响，故不需要改变。    x.p = y    x.d = x.d + v.d + 1    if x.rank == y.rank      y.rank = y.rank + 1\r\ne\r\n由于MAKE-TREE操作和并查集的MAKE-SET类似，FIND-DEPTH操作以并查集的一次FIND-SET操作为子程序，GRAFT操作类似UNION，它们和并查集中对应的操作均摊时间都是紧逼的。因此长度为\\(m\\)的序列的操作序列时间复杂度与并查集一致，为\\(O(m\\alpha(n))\\)。\r\n19-3\r\na\r\n由于\\(T\\)是一棵有根树，根据第3行对\\(u\\)的孩子\\(v\\)进行遍历，第4行对孩子节点\\(v\\)进行递归调用，可见算法LCA是对整棵树进行DFS，每个节点\\(u\\)都会被遍历一次。\r\n在第8行，遍历对象是将满足\\((u,\\cdot)\\)或者是\\((\\cdot,u)\\)的所有询问节点对都进行一次遍历。对于一个询问对\\(p=\\{u,v\\}\\)，接下来证明要么是以\\((u,v)\\)的形式进入到第10行，要么是以\\((v,u)\\)的形式进入第10行。考虑两种情况：\r\n\r\n\\(u,v\\)具有祖孙关系。不失一般性，假设\\(u\\)是\\(v\\)的祖先，那么处于调用LCA(v)时，\\(v\\)在第7行已被染色，并在第9行访问到询问对\\(p\\)时，\\(u\\)仍然是白色，因此无法到达第10行。回溯到调用LCA(u)时，第3行的for循环已经结束，\\(u\\)的所有子孙节点都被染成黑色，\\(u\\)自己才被染成黑色，此时在第9行访问到询问对\\(p\\)时，由于\\(v\\)已经被染成黑色，因此进入第10行，询问对\\(p\\)正式被访问，此后节点\\(u,v\\)不再被访问，因此询问对\\(p\\)只被访问了一次。\r\n\\(u,v\\)不具有子孙关系，那么令\\(l\\)为\\(u,v\\)的最近公共祖先。在访问\\(l\\)的子树时，不失一般性，先访问\\(u\\)所在的子树，再访问\\(v\\)所在的子树。那么调用LCA(u)时，到了第9行，询问对\\(p\\)的另一个节点\\(v\\)仍然是白色，因此无法到达第10行，此时\\(u\\)已经被染成黑色。之后调用LCA(v)时，询问对\\(p\\)的另一个节点\\(u\\)此前已经被染成黑色，因此可以进入第10行，询问对\\(p\\)正式被访问，此后节点\\(u,v\\)不再被访问，因此询问对\\(p\\)只被访问了一次。\r\n\r\n最终，原结论成立。\r\nb\r\n我们考虑证明：只有在刚调用LCA(u)时，森林中集合的个数恰好等于\\(u\\)的深度。\r\n当LCA(T.root)被调用时，MAKE-SET操作还没完成，因此森林中共有\\(0\\)个不相交的集合，原结论成立。假设刚调用\\(u\\)时，森林中恰好有\\(u.d\\)（这里属性\\(d\\)表示节点的深度），那么我们将证明对于\\(u\\)的每一个孩子\\(v\\)，使得刚调用LCA(v)时，都有不相交集合个数为\\(v.d=u.d+1\\)。\r\n接下来首先使用归纳法证明：当LCA(u)的调用结束时，以\\(u\\)为子树的所有节点都被合并成了一个不相交集合。当\\(u\\)是一个叶子节点时，LCA(u)调用完成后恰好只有\\(u\\)节点所在的一个集合。当\\(u\\)不是一个叶子节点时，假设遍历完\\(u\\)的某个子节点\\(v\\)被调用了LCA(v)后，以\\(v\\)中的所有节点都被合并成一个不相交集合，那么在第5行将节点\\(u\\)所在的集合和节点\\(v\\)所在的集合进行合并。最终，for循环结束后，以\\(u\\)为子树的所有节点都处于同一个集合中。\r\n回到原来的证明，假设目前已经调用LCA(u)，那么执行第1行后，不相交集合个数增加了\\(1\\)。那么在第3行枚举第\\(1\\)个儿子\\(v_1\\)时，此时不相交集合个数为\\(u.d+1\\)，接下来调用LCA(v_1)，此时原结论成立。当LCA(v_1)调用完成后（注意遍历LCA(v_1)后，按照上面的结论，只多产生了一个不相交集合），第5行将节点\\(u\\)和\\(v_1\\)所在的集合进行合并，因此第5行结束后，不相交集合的个数仍然位产生变化，因此当遍历第\\(2\\)个儿子\\(v_2\\)时，结论仍然成立，此后进行UNION操作后仍然保持集合数不变……也就是说，这个结论适用于\\(u\\)的所有子节点。\r\n因此逐层向下推理，可知原结论成立。\r\nc\r\n按照\\(u,v\\)是否具有祖孙关系，考虑如下两种情况：\r\n\r\n\\(u,v\\)具有祖孙关系。不失一般性，假设\\(u\\)是\\(v\\)的祖先，那么处于调用LCA(v)时，\\(u\\)仍未被染色，因此第8行的for循环中，询问对\\(\\{u,v\\}\\)不被处理。当回溯到LCA(u)时，\\(v\\)已经被染成黑色，此时第3行for循环结束后，\\(u\\)所在集合的所有祖先都是\\(u\\)，此时在第8行的for循环中，询问对\\(\\{u,v\\}\\)被处理，其结果为\\(v\\)所在的树的根的祖先\\(ancestor\\)，也就是\\(u\\)，因此该算法正确。\r\n\\(u,v\\)不具有祖孙关系。令\\(w\\)是它们的最近公共祖先，这意味着\\(u,v\\)分别处在\\(w\\)的不同子树中。因此不失一般性，假设\\(u\\)所在的子树先被遍历。那么调用LCA(u)时，此时节点\\(v\\)仍然是白色的，因此第8行的for循环中，询问对\\(\\{u,v\\}\\)不被处理。当\\(u\\)所在的子树被遍历完成后，回到了节点\\(w\\)，那么到了第5行\\(u\\)所在子树和\\(w\\)所在的节点被合并了，在第6行，这些节点的祖先被设置成了\\(w\\)，此后未被修改。当调用LCA(v)时，\\(u\\)已经被染成黑色，那么此时在第8行的for循环中，询问对\\(\\{u,v\\}\\)被处理，其结果为\\(v\\)所在的树的根的祖先\\(ancestor\\)，也就是\\(w\\)，因此该算法正确。\r\n\r\n最终可以得知，算法LCA是正确的。\r\nd\r\n在每次LCA(u)的调用过程中，都调用了一次MAKE-SET操作。接下来枚举\\(u\\)的每个子节点\\(v\\)，都进行了一次UNION操作和一次FIND-SET操作。\r\n因此整个过程中，总共调用了\\(|V|\\)次MAKE-SET操作，\\(|V|-1\\)次UNION操作和\\(|V|-1\\)次FIND-SET操作。因此整个过程总共有\\(3|V|-1\\)次操作的时间复杂度为\\(O(|V|\\alpha(|V|))\\)。。由于每个询问对都被访问了两次，因此第8-10行的for循环在整个过程中运行了\\(2\\)次，其花费的时间为\\(O(|P|)\\)。\r\n故整个过程的运行时间为\\(O(|V|\\alpha(|V|)+|P|)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论20.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-20/exercises-2/","content":"\r\n20.2-1\r\n\\(\\begin{aligned}\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\n1&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\n2&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\n3&amp;0&amp;\\text{NIL}\\\\\\hline\r\n4&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\n5&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\n6&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\n\\end{array}\r\n\\underrightarrow{(3,6)}\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\n1&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\n2&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\n3&amp;0&amp;\\text{NIL}\\\\\\hline\r\n4&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\n5&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\n6&amp;1&amp;3\\\\\\hline\r\n\\end{array}\r\n\\underrightarrow{(3,5)}\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\n1&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\n2&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\n3&amp;0&amp;\\text{NIL}\\\\\\hline\r\n4&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\n5&amp;1&amp;3\\\\\\hline\r\n6&amp;1&amp;3\\\\\\hline\r\n\\end{array}\r\n\\underrightarrow{(5,4)}\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\n1&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\n2&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\n3&amp;0&amp;\\text{NIL}\\\\\\hline\r\n4&amp;2&amp;5\\\\\\hline\r\n5&amp;1&amp;3\\\\\\hline\r\n6&amp;1&amp;3\\\\\\hline\r\n\\end{array}\r\n\\underrightarrow{(4,2)}\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\n1&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\n2&amp;3&amp;4\\\\\\hline\r\n3&amp;0&amp;\\text{NIL}\\\\\\hline\r\n4&amp;2&amp;5\\\\\\hline\r\n5&amp;1&amp;3\\\\\\hline\r\n6&amp;1&amp;3\\\\\\hline\r\n\\end{array}\r\n\\end{aligned}\\)\r\n20.2-2\r\n\\(\\begin{aligned}\r\n&amp;\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\nr&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\ns&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nt&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nu&amp;0&amp;\\text{NIL}\\\\\\hline\r\nv&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nw&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nx&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\ny&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nz&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\n\\end{array}\r\n\\underrightarrow{(u,s)}\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\nr&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\ns&amp;1&amp;u\\\\\\hline\r\nt&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nu&amp;0&amp;\\text{NIL}\\\\\\hline\r\nv&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nw&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nx&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\ny&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nz&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\n\\end{array}\r\n\\underrightarrow{(u,t)}\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\nr&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\ns&amp;1&amp;u\\\\\\hline\r\nt&amp;1&amp;u\\\\\\hline\r\nu&amp;0&amp;\\text{NIL}\\\\\\hline\r\nv&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nw&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nx&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\ny&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nz&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\n\\end{array}\r\n\\underrightarrow{(u,y)}\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\nr&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\ns&amp;1&amp;u\\\\\\hline\r\nt&amp;1&amp;u\\\\\\hline\r\nu&amp;0&amp;\\text{NIL}\\\\\\hline\r\nv&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nw&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nx&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\ny&amp;1&amp;u\\\\\\hline\r\nz&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\n\\end{array}\r\n\\underrightarrow{(s,r)}\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\nr&amp;2&amp;s\\\\\\hline\r\ns&amp;1&amp;u\\\\\\hline\r\nt&amp;1&amp;u\\\\\\hline\r\nu&amp;0&amp;\\text{NIL}\\\\\\hline\r\nv&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nw&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nx&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\ny&amp;1&amp;u\\\\\\hline\r\nz&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\n\\end{array}\r\n\\underrightarrow{(s,v)}\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\nr&amp;2&amp;s\\\\\\hline\r\ns&amp;1&amp;u\\\\\\hline\r\nt&amp;1&amp;u\\\\\\hline\r\nu&amp;0&amp;\\text{NIL}\\\\\\hline\r\nv&amp;2&amp;s\\\\\\hline\r\nw&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nx&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\ny&amp;1&amp;u\\\\\\hline\r\nz&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\n\\end{array}\\\\\r\n\\underrightarrow{(y,x)}&amp;\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\nr&amp;2&amp;s\\\\\\hline\r\ns&amp;1&amp;u\\\\\\hline\r\nt&amp;1&amp;u\\\\\\hline\r\nu&amp;0&amp;\\text{NIL}\\\\\\hline\r\nv&amp;2&amp;s\\\\\\hline\r\nw&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nx&amp;2&amp;x\\\\\\hline\r\ny&amp;1&amp;u\\\\\\hline\r\nz&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\n\\end{array}\r\n\\underrightarrow{(r,w)}\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\nr&amp;2&amp;s\\\\\\hline\r\ns&amp;1&amp;u\\\\\\hline\r\nt&amp;1&amp;u\\\\\\hline\r\nu&amp;0&amp;\\text{NIL}\\\\\\hline\r\nv&amp;2&amp;s\\\\\\hline\r\nw&amp;3&amp;r\\\\\\hline\r\nx&amp;2&amp;y\\\\\\hline\r\ny&amp;1&amp;u\\\\\\hline\r\nz&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\n\\end{array}\r\n\\underrightarrow{(x,z)}\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\nr&amp;2&amp;s\\\\\\hline\r\ns&amp;1&amp;u\\\\\\hline\r\nt&amp;1&amp;u\\\\\\hline\r\nu&amp;0&amp;\\text{NIL}\\\\\\hline\r\nv&amp;2&amp;s\\\\\\hline\r\nw&amp;3&amp;r\\\\\\hline\r\nx&amp;2&amp;y\\\\\\hline\r\ny&amp;1&amp;u\\\\\\hline\r\nz&amp;3&amp;x\\\\\\hline\r\n\\end{array}\r\n\\end{aligned}\\)\r\n20.2-3\r\n由于点的颜色仅仅用于判断点的状态，只要进了队列之后，那么当前点的颜色就没有用处了。因此黑色和灰色状态可以合并，与白色状态一起，我们就可以只使用\\(1\\)比特来表示点的状态。\r\n接下来将消除点的颜色。一个点如果曾经在队列中生存过，那么它的距离值不应该是\\(\\infty\\)，而是一个具体的整数，因此我们可以通过这个来判断点是否进入过队列。修改后的伪代码如下：\r\nBFS&#x27;(G, s)  for each vertex u ∈ G.V - &#123;s&#125;    u.d = ∞    u.π = NIL  s.d = 0  s.π = NIL  Q = ∅  ENQUEUE(Q, s)  while Q != ∅     u = DEQUEUE(Q)    for each vertex v in G.Adj[u]     // search the neighbors of u      if v.d == ∞                     // is v being discovered now?        v.d = u.d + 1        v.π = u        ENQUEUE(Q, v)                  // v is now on the frontier\r\n20.2-4\r\n运行时间从\\(O(V+E)\\)变成\\(O(V^2)\\)，因为对于每个刚刚出队的节点\\(u\\)，所有节点\\(v\\in V\\)都要被访问一遍，以判断\\((u,v)\\)是否在\\(E\\)中。这种结构下的伪代码为：\r\nBFS&#x27;&#x27;(G, s)  for each vertex u ∈ G.V - &#123;s&#125;    u.d = ∞    u.π = NIL    u.color = WHITE  s.d = 0  s.π = NIL  s.color = GREY  Q = ∅  ENQUEUE(Q, s)  while Q != ∅     u = DEQUEUE(Q)    for each vertex v in V:               // search the neighbors of u      if G.a[u, v] == true and v.d == ∞   // is v being discovered now?        v.d = u.d + 1        v.π = u        v.color = GREY        ENQUEUE(Q, v)                     // v is now on the frontier    u.color = BLACK                       // u is now behind the frontier\r\n20.2-5\r\n首先我们说明邻接表的顺序和\\(s,u\\)两点之间的距离\\(\\delta(s,u)\\)是独立的。直观上，从\\(s\\)到\\(u\\)的距离\\(\\delta(s,u)\\)是这个图本身固有的属性，而与\\(G\\)的存储结构没有任何关系。此外，定理20.5则证明了广度优先算法BFS的正确性，且并没有通过邻接表的顺序性来论证算法BFS能够计算出\\(u.d=\\delta(s,u)\\)，因此原来的结论是成立的。\r\n不过虽然\\(u.d\\)的值不依赖于邻接表的遍历顺序，但是\\(u.\\pi\\)却依赖于邻接表的顺序。图20.3遍历\\(s\\)节点的相邻节点顺序是\\(r,u,v\\)，因此\\(r\\)先入队，\\(r\\)会先比\\(u\\)出队。此时\\(r\\)则会扩展出节点\\(t\\)，因此\\(t.\\pi\r\n=r\\)。相反，如果遍历\\(s\\)节点的相邻节点顺序是\\(u,r,v\\)，那么\\(u\\)会先比\\(r\\)出队。此时\\(u\\)则会扩展出节点\\(t\\)，那么\\(t.\\pi\r\n=u\\)。因此\\(\\pi\\)值和邻接表顺序相关。\r\n20.2-6\r\n\\(G=(V,E),V=\\{1,2,3,4,5\\},E=\\{(1,2),(1,3),(2,4),(2,5),(3,4),(3,5)\\}\\)，\\(G\\)如图所示：\r\n\r\n如果源点\\(s=1\\)，那么无论按照那种遍历方式，如下的BF树不可能由算法BFS产生：\r\n\r\n因为如果节点\\(2\\)比节点\\(3\\)先进入队列，那么它将会完成对\\(4\\)和\\(5\\)的扩展；反之依然，总而言之，\\(2,3\\)这两个节点之一将会一次性将节点\\(4,5\\)进行扩展，不可能由上图那样，节点\\(2\\)扩展一个\\(4\\)，节点\\(3\\)扩展出一个\\(5\\)。\r\n20.2-7\r\n本质上是判断这个图是不是一个二分图，我们可以直接使用广度优先搜索直接为相邻的两个节点打上不同的标签，如果发现有的节点已经打上了标签并且和当前点的标签相同，那么说明这个列表是无法构造成功的。\r\nDETERMINE-WRESTLERS(G)  for each vertex u in G.V    u.type = NIL  for each vertex s in G.V    if s.type == NIL      s.type = babyface      Q = ∅      ENQUEUE(Q, s)      while Q != ∅         u = DEQUEUE(Q)          for each vertex v in G.Adj[u]           if v.type == NIL            if u.type == babyface              v.type = heel            else              v.type = babyface            ENQUEUE(Q, s)          else if v.type == u.type            return NIL                  // 分配失败  return G.V      \r\n\\(\\star\\)\r\n20.2-8\r\n这个算法的基本流程比较简单，只需要进行两次BFS即可。伪代码如下：\r\nGEN-DIAMETER(T)  select u ∈ T.V randomly  BFS(T, u)  select s ∈ T.V such that s.d = max&#123;v.d | v in T.V&#125;  BFS(T, s)  select t ∈ T.V such that t.d = max&#123;v.d | v in T.V&#125;  PRINT-PATH(G, s, t)\r\n第一次找到一个最远端点（叶节点）\\(s\\)，第二次从\\(s\\)搜索找到另一个最远叶子节点\\(t\\)，那么路径\\(s-t\\)就是\\(T\\)的一个直径。\r\n由于树的边数\\(|E|=\\Theta(V)\\)，因此算法GEN-DIAMETER的时间复杂度为\\(\\Theta(V)\\)。\r\n这个算法的正确性证明过程如下：\r\n如果\\(s\\)是其中一条直径的端点，那么通过第二次BFS得到的最远节点\\(t\\)是直径的另一个端点，这是显而易见的。因此我们的主要是使用反证法证明：第一次通过对\\(u\\)进行BFS得到的\\(s\\)是直径的一个端点。\r\n我们使用\\(a-b-\\dots-c-d\\)表示一条从\\(a\\)到\\(d\\)的简单路径，并且中途还经过了\\(b\\)和\\(c\\)等点。此处分两种情况进行证明：\r\n\\(u\\)在直径上\r\n那么假设直径是\\(a-u-b\\)，并且\\(a,b\\)为这两个端点。不妨假设\\(\\delta(u,a)\\ge \\delta(u,b)\\)。\r\n那么，对于任意\\(v\\in V\\)，路径\\(u-v\\)只能和\\(u-a\\)与\\(u-b\\)其中一条会有除\\(u\\)之外的公共点。那么必定会有\\(\\delta(u,v)\\le \\delta(u,a)\\)。如果\\(\\delta(u,v)&gt;\\delta(u,a)\\)，考虑如下两种情况：\r\n\r\n如果 \\((u-a\\cap\r\nu-v)-\\{u\\}=\\varnothing\\)，那么路径\\(v-u-a\\)是一条比原直径更长的路径。\r\n如果 \\((u-a\\cap\r\nu-v)-\\{u\\}\\neq\\varnothing\\)，那么路径\\(v-u-b\\)是一条比原直径更长的路径。\r\n\r\n无论那种情况都将证明\\(a-u-b\\)不是直径，因此必定满足\\(\\forall v\\in V,\\delta(u,v)\\le\r\n\\delta(u,a)\\)，也就是有\\(d(u,s)=d(u,a)\\)。\r\n下图则对应了这两种情况（其中前两副图对应了第1种情况的两种形式，第三幅图则对应第2种情况）\r\n\r\n\\(u\\)不在直径上\r\n那么假设直径是\\(a-w-b\\)，并且\\(a,b\\)为这两个端点。不妨假设\\(\\delta(u,a)\\ge \\delta(u,b)\\)，且\\(w\\)是有向路径\\(u\\rightarrow a\\)出现在路径\\(a-b\\)上的第一个点。那么我们可以知道，第一次BFS算法得到的\\(s\\)必定满足路径\\(u-s\\)和直径\\(a-b\\)相交，这个可以用反证法来说明：否则，按照定义，有\\(\\delta(u,s)\\ge \\delta(u,a)\\)。由于\\(u\\neq w\\)，并且有\\(\\delta(w,a)=\\delta(u,a)-\\delta(u,w),\\delta(w,s)=\\delta(u,s)+\\delta(u,w)\\)，从而得到\\(\\delta(w,s)&gt;\\delta(w,a)\\)，这说明\\(s-w-b\\)是一条比原直径更长的路径。如下图所示。\r\n\r\n因此，路径\\(u-s\\)应该和\\(a-b\\)相交。假设\\(u-s\\)和\\(a-b\\)所相交的一段路径为\\(w-x\\)。\r\n\r\n如果\\(x\\)在路径\\(w-a\\)中，那么路径\\(s-x-w-b\\)是一条比原直径更长的路径。为此，只能有\\(x=s=a\\)。\r\n如果\\(x\\)在路径\\(w-b\\)中，那么路径\\(s-x-w-a\\)是一条比原直径更长的路径。为此，只能有\\(x=s=b\\)。\r\n\r\n下图则对应了这两种情况。\r\n\r\n最终完成全过程的证明。\r\n","categories":["算法导论"]},{"title":"算法导论20.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-20/exercises-3/","content":"\r\n20.3-1\r\n如下是有向图的情形。\r\n\\(\\begin{array}{|l|l|l|l|}\\hline\r\n\\texttt{FROM}\\backslash \\texttt{TO}&amp;W&amp;G&amp;B\\\\\r\n\\hline\r\nW&amp;\\texttt{TBFC}&amp;\\texttt{BC}&amp;\\texttt{C}\\\\\r\n\\hline\r\nG&amp;\\texttt{TF}&amp;\\texttt{TFB}&amp;\\texttt{TFC}\\\\\r\n\\hline\r\nB&amp;&amp;\\texttt{B}&amp;\\texttt{TBFC}\\\\\r\n\\hline\r\n\\end{array}\\)\r\n其中，\\(\\texttt{T}\\)表示树边，\\(\\texttt{B}\\)表示后向边，\\(\\texttt{F}\\)表示前向边，\\(\\texttt{C}\\)表示横跨边。\r\n如下是无向图的情形，去除了横跨边和前向边的情况。\r\n\\(\\begin{array}{|l|l|l|l|}\\hline\r\n\\texttt{FROM}\\backslash \\texttt{TO}&amp;W&amp;G&amp;B\\\\\r\n\\hline\r\nW&amp;\\texttt{TB}&amp;\\texttt{TB}&amp;\\\\\r\n\\hline\r\nG&amp;\\texttt{TB}&amp;\\texttt{TB}&amp;\\texttt{TB}\\\\\r\n\\hline\r\nB&amp;&amp;\\texttt{TB}&amp;\\texttt{TB}\\\\\r\n\\hline\r\n\\end{array}\\)\r\n20.3-2\r\n\\(G\\)中的每个节点\\(v\\)的发现时间\\(v.d\\)和完成时间\\(v.f\\)如下表所示：\r\n\\(\\begin{array}{|l|l|l|}\\hline\r\nv&amp;v.d&amp;v.f\\\\\r\n\\hline\r\nq&amp;1&amp;16\\\\\r\n\\hline\r\nr&amp;17&amp;20\\\\\r\n\\hline\r\ns&amp;2&amp;7\\\\\r\n\\hline\r\nt&amp;8&amp;15\\\\\r\n\\hline\r\nu&amp;18&amp;19\\\\\r\n\\hline\r\nv&amp;3&amp;6\\\\\r\n\\hline\r\nw&amp;4&amp;5\\\\\r\n\\hline\r\nx&amp;9&amp;12\\\\\r\n\\hline\r\ny&amp;13&amp;14\\\\\r\n\\hline\r\nz&amp;10&amp;11\\\\\r\n\\hline\r\n\\end{array}\\)\r\n\\(G\\)中的每条边分类如下：\r\n\r\n树边: \\((q, s),(s, v),(v, w),(q, t),(t,\r\nx),(x, z),(t, y),(r, u)\\)\r\n后向边: \\((w, s),(y, q),(z,\r\nx)\\)\r\n前向边: \\((q, w)\\)\r\n横向边: \\((u, y),(r, y)\\)\r\n\r\n20.3-3\r\n\\((u(v(y(xx)y)v)u)(w(zz)w)\\)\r\n20.3-4\r\n点的颜色仅仅用于判断点的状态，只要当前节点已经被深度优先算法访问过了，那么当前点的颜色就没有用处了。因此黑色和灰色状态可以合并，与白色状态一起，我们就可以只使用\\(1\\)比特来表示点的状态。因此最终的做法是，将算法DFS-VISIT的第3行修改成u.color=BLACK，并将第8行删去。\r\n20.3-5\r\na\r\n充分性：无论是树边还是前向边，\\(v\\)都是\\(u\\)在DF树上的子节点。根据定理20.7的第三部分，有\\(u.d&lt;v.d&lt;v.f&lt;u.f\\)。\r\n必要性：根据推论20.8，可以知道满足\\(u.d&lt;v.d&lt;v.f&lt;u.f\\)时，必须满足\\(v\\)是\\(u\\)的后代。此时边\\((u,v)\\)要么是树边，要么是前向边。\r\nb\r\n充分性：由于\\((u,v)\\)是后向边，因此\\(u\\)是\\(v\\)的后代。因此，如果\\(u=v\\)，那么\\(v.d=u.d&lt;u.f=v.f\\)，原结论成立。如果\\(u\\neq\r\nc\\)，那么根据定理20.7的第二部分，有\\(v.d&lt;u.d&lt;u.f&lt;v.f\\)。因此原结论成立。\r\n必要性：当\\(u=v\\)时，有\\(v.d=u.d&lt;u.f=v.f\\)。因此\\((u,v)\\)是自环，而自环将会被归类到有向边中。当\\(u\\neq v\\)时，有\\(v.d&lt;u.d&lt;u.f&lt;v.f\\)，此时根据定理20.7的第2部分，可以知道\\(v\\)是\\(u\\)的祖先。因此边\\((u,v)\\)是后向边。\r\nc\r\n充分性：由于\\((u,v)\\)是横向边，因此\\(u\\)和\\(v\\)并不互为祖孙关系，因此根据定理20.7的第一条，将会有\\(u.d &lt; u.f &lt; v.d &lt; v.f\\)和\\(v.d &lt; v.f &lt; u.d &lt;\r\nu.f\\)这两种情况之一，我们将通过反证法证明前者是错误的。假设\\(u.d&lt;\r\nv.d\\)成立，那么根据定理20.9，在时刻\\(u.d\\)，将会有一条从\\(u\\)到\\(v\\)的白色路径，那么此时\\(v\\)必定是\\(u\\)的后代，与横向边的定义不符合。因此必定有\\(v.d &lt; v.f &lt; u.d &lt; u.f\\)。\r\n必要性：由于\\(v.d &lt; v.f &lt; u.d &lt;\r\nu.f\\)，根据定理20.7的第一部分，\\(u,v\\)并不就有祖孙关系，因此\\((u,v)\\)是横向边。\r\n20.3-6\r\n为了保证递归时上下文能够保存，我们设计非递归算法时，同样需要设计一个方法GET-NEXT-WHITE-VERTEX(G, u)，它的功能是多次被调用时，返回邻接表G.Adj[u]的第一个白色节点（如果没有，那么返回NIL）。通过均摊分析，这个方法的平均时间复杂度可以达到\\(O(1)\\)，此处我们不讨论GET-NEXT-WHITE-VERTEX的实现细节。\r\n其余细节则和递归时的情形相近。\r\nDFS&#x27;(G)  for each vertex u ∈ G.V    u.color = WHITE    u.π = NIL  time = 0  for each vertex u ∈ G.V    if u.color == WHITE      DFS-VISIT&#x27;(G, u)// TOP(S)表示返回S的栈顶元素，POP(S)表示弹出S的栈顶元素。DFS-VISIT&#x27;(G, u)  S = Ø  PUSH(S, u)  time = time + 1           // white vertex u has just been discovered  u.d = time  u.color = GRAY  while S ≠ Ø    u = TOP(S)    v = GET-NEXT-WHITE-VERTEX(G, u)    time = time + 1    if v == NIL      POP(S)      u.f = time      u.color = BLACK       // blacken u; it is finished    else      v.π = u      v.d = time      v.color = GRAY      PUSH(S, v)\r\n20.3-7\r\n令\\(V=\\{a,b,c\\},E=\\{(a,b),(b,a),(b,c)\\},G=(V,E)\\)，那么从\\(b\\)到\\(c\\)就会有路径\\(b\\rightarrow a\\rightarrow\r\nc\\)。但是如果按照从\\(b\\rightarrow\r\na\\rightarrow b \\rightarrow c\\)的顺序访问各个节点，那么就会有\\(b.d=1,a.d=2,c.d=4\\)，并且树边集合为\\(E_{\\pi}=\\{(b,a),(b,c)\\}\\)，此时\\(c\\)不是\\(a\\)的后代。\\(G\\)如下图所示。\r\n\r\n20.3-8\r\n本例子重用题目20.3-7所提出来的图。如果按照从\\(b\\rightarrow a\\rightarrow b \\rightarrow\r\nc\\)的顺序访问各个节点，由于从\\(b\\)到\\(c\\)就会有路径\\(b\\rightarrow a\\rightarrow\r\nc\\)，并且按照从\\(b\\rightarrow\r\na\\rightarrow b \\rightarrow c\\)的顺序访问各个节点，那么有\\(c.d=4,a.f=3\\)，这是不满足条件\\(c.d\\le a.f\\)的。\r\n20.3-9\r\n综合\\(4\\)种有向边的定义，可以设计出算法DFS''来打印有向图\\(G\\)中的每条有向边的种类。\r\nDFS&#x27;&#x27;(G)  for each vertex u ∈ G.V    u.color = WHITE    u.π = NIL  time = 0  for each vertex u ∈ G.V    if u.color == WHITE      DFS-VISIT&#x27;&#x27;(G, u)DFS-VISIT&#x27;&#x27;(G, u)  time = time + 1                 // white vertex u has just been discovered  u.d = time  u.color = GRAY  for each vertex v in G.Adj[u]   // explore each edge (u, v)    if v.color == WHITE      print (u, v) is a tree edge      v.π = u      DFS-VISIT&#x27;&#x27;(G, v)    else if v.color == GRAY      print (u, v) is a back edge    else if u.d &lt; v.d      print (u, v) is a forward edge    else      print (u, v) is a cross edge  time = time + 1  u.f = time  u.color = BLACK                 // blacken u; it is finished\r\n如果\\(G\\)是一个无向图，那么直接删去判断前向边和横向边的判断即可，代码如下：\r\nDFS-U(G)  for each vertex u ∈ G.V    u.color = WHITE    u.π = NIL  time = 0  for each vertex u ∈ G.V    if u.color == WHITE      DFS-VISIT-U(G, u, NIL)// 第三个参数是为了避免父节点被作为子节点遍历。DFS-VISIT-U(G, u, fa)  time = time + 1                 // white vertex u has just been discovered  u.d = time  u.color = GRAY  for each vertex v in G.Adj[u]   // explore each edge (u, v)    if v.color == WHITE      print (u, v) is a tree edge      v.π = u      DFS-VISIT-U(G, v, u)    else if v != fa and v.color == GRAY      print (u, v) is a back edge  time = time + 1  u.f = time  u.color = BLACK                 // blacken u; it is finished\r\n20.3-10\r\n如果一个节点\\(u\\)在一棵DF森林中是一个孤立节点，那么只需要做到以下要求即可：\r\n\r\n\\(u\\)的所有后继节点都先被访问。\r\n接下来\\(u\\)被访问，那么\\(u\\)的所有出边都不是树边。\r\n接下来\\(u\\)的前驱节点被访问，由于\\(u\\)已经被访问过，因此所有\\(u\\)的入边都不可能是树边。\r\n\r\n从而，\\(u\\)在这棵DF森林就是一个孤立节点，示意图如下所示。\r\n\r\n其中，和\\(u\\)关联的所有节点旁边的数字表示它们被访问的其中一个相对时间戳。\r\n20.3-11\r\n无向图中的边仅仅有树边和后向边这两种，那么对树边，进行真实的遍历，并记录下来；而对于后向边，只需要往返跳跃一次即可，同样记下这个跳跃记录，算法由DFS-U'给出。\r\nDFS-U&#x27;(G)  for each vertex u ∈ G.V    u.color = WHITE    u.π = NIL  select u ∈ G.V randomly  time = 0  let path be new array           // path 表示一个全局变量，用来存储这条路径。  INSERT(path, u)  DFS-VISIT-U&#x27;(G, u)  return pathDFS-VISIT-U&#x27;(G, u)  time = time + 1                 // white vertex u has just been discovered  u.d = time  u.color = GRAY  for each vertex v in G.Adj[u]   // explore each edge (u, v)    if v.color == WHITE      INSERT(path, v)             // 正向      v.π = u      DFS-VISIT-U&#x27;(G, v)      INSERT(path, u)             // 反向    else      INSERT(path, v)             // 正向      INSERT(path, u)             // 反向  time = time + 1  u.f = time  u.color = BLACK                 // blacken u; it is finished\r\n20.3-12\r\n和原版dfs的方案类似，多维护一个全局变量component，用来表示当前遍历图\\(G\\)时的连通分量编号。这个值在遍历每一个连通分量之前就已经维护好，遍历过程中只需要赋值即可。算法由DFS-U''给出。\r\nDFS-U&#x27;&#x27;(G)  for each vertex u ∈ G.V    u.color = WHITE    u.π = NIL  time = 0  component = 0  for each vertex u ∈ G.V    if u.color == WHITE      component = component + 1      DFS-U&#x27;&#x27;(G, u)DFS-VISIT-U&#x27;&#x27;(G, u)  time = time + 1                 // white vertex u has just been discovered  u.d = time  u.color = GRAY  u.cc = component  for each vertex v in G.Adj[u]   // explore each edge (u, v)    if v.color == WHITE      v.π = u      DFS-VISIT-U&#x27;&#x27;(G, v)  time = time + 1  u.f = time  u.color = BLACK                 // blacken u; it is finished\r\n\\(\\star\\)\r\n20.3-13\r\n以下是一个比较暴力的做法，其期望时间复杂度为\\(O(VE)\\)。\r\n\r\n使用tarjan算法对图\\(G\\)进行缩点，得到\\(G\\)的所有边双连通分量，以及这些双连通分量之间的关系图\\(G&#39;\\)。注意\\(G&#39;\\)是一个有向无环图。这个步骤需要花费\\(O(V+E)\\)的时间。\r\n枚举\\(G\\)中的所有双连通分量，判断这些双连通分量是否存在超过\\(1\\)个环。如果存在一个双连通分量超过\\(1\\)个环，那么\\(G\\)不是单连通图，算法结束。这个步骤需要花费\\(O(V+E)\\)的时间。\r\n对\\(G&#39;\\)中的每个入度为\\(0\\)的节点进向后进行搜索。在单次搜索中，如果存在一个节点\\(v\\)被访问了两次或以上，那么说明从\\(u\\)至\\(v\\)有两条路径，原图\\(G\\)不是单连通图。否则\\(G\\)是单连通图。这个步骤需要花费\\(O(VE)\\)的时间。\r\n\r\n因此，总共需要\\(O(VE)\\)的时间判断\\(G\\)是否为单连通图。\r\n","categories":["算法导论"]},{"title":"算法导论20.4 Exercises 答案","url":"/introduction-to-algorithms/chapter-20/exercises-4/","content":"\r\n20.4-1\r\n可以得出上图\\(G\\)的所有节点信息如下：\r\n\\(\\begin{array}{|l|l|l|l|}\\hline\r\nv&amp;v.d&amp;v.f&amp;v.\\pi\\\\\\hline\r\nm&amp;1&amp;20&amp;\\text{NIL}\\\\\\hline\r\nq&amp;2&amp;5&amp;m\\\\\\hline\r\nt&amp;3&amp;4&amp;q\\\\\\hline\r\nr&amp;6&amp;19&amp;m\\\\\\hline\r\nu&amp;7&amp;8&amp;r\\\\\\hline\r\ny&amp;9&amp;18&amp;r\\\\\\hline\r\nv&amp;10&amp;17&amp;y\\\\\\hline\r\nw&amp;11&amp;14&amp;v\\\\\\hline\r\nz&amp;12&amp;13&amp;w\\\\\\hline\r\nx&amp;15&amp;16&amp;v\\\\\\hline\r\nn&amp;21&amp;26&amp;\\text{NIL}\\\\\\hline\r\no&amp;22&amp;25&amp;n\\\\\\hline\r\ns&amp;23&amp;24&amp;o\\\\\\hline\r\np&amp;27&amp;28&amp;\\text{NIL}\\\\\\hline\r\n\\end{array}\\)\r\n因此，按照\\(v.f\\)从大到小的顺序列出所有\\(v\\)，即可得到\\(G\\)的其中一个拓扑序列：\r\n\\[p\\rightarrow n\\rightarrow o\\rightarrow\r\ns\\rightarrow m\\rightarrow r\\rightarrow y\\rightarrow v\\rightarrow\r\nx\\rightarrow w\\rightarrow z\\rightarrow u\\rightarrow q\\rightarrow\r\nt\\]\r\n20.4-2\r\n考虑使用动态规划的思想来解决本题。\r\n令\\(f_G(s,t)\\)表示在有向无环图\\(G\\)，从\\(s\\)到\\(t\\)的路径条数。那么可以写出如下状态转移方程：\r\n\\(f_G(s,t)= \\left \\{\\begin{aligned}\r\n&amp;1 &amp; &amp; \\text{if}\\quad s=t \\\\\r\n&amp;\\sum_{u\\in G.Adj[s]} f_G(u,t) &amp; &amp; \\text{if}\\quad s\\neq t\\\r\n\\end{aligned}\\right.\\)\r\n方程的第二行说明，从\\(s\\)到\\(t\\)的所有路径，可以看作是\\(s\\)的后继节点\\(w\\)到\\(t\\)的所有路径前面再添加一个\\(s\\)即可。由于\\(G\\)是一个有向无环图，\\(f_G\\)并不会形成循环。我们可以考虑从\\(G\\)的拓扑序列上实现计算\\(f_G\\)的过程。计算\\(f_G(u,v)\\)的算法由CAL-PATHS过程给出。\r\nCAL-PATHS(G, s, t)  order = TOPOLOGICAL-SORT(G)  REVERSE(order)                // 对拓扑系列order进行逆序  for each u in order    if u == t      u.paths = 1    else      u.paths = 0        for each v in G.Adj[u]          u.paths = u.paths + v.paths  return s.paths\r\n20.4-3\r\n根据定理B.2的第5条和第6条可以得知，如果无向图\\(G\\)有超过\\(|V|-1\\)条边，那么\\(G\\)必定是有环的，我们不遍历整个图并直接返回结果。否则，遍历图\\(G\\)中的每个连通分量，并判断每个连通分量是否有环即可。算法由HAVE-CYCLE给出，由于\\(|E|\\le |V|-1\\)，因此其时间复杂度为\\(O(|V|)\\)。\r\nDFS-C(G, u, fa)  u.vis = True  for each v in G.Adj[u]    if v != fa      if v.vis == True        return True  return FalseHAVE-CYCLE(G)  if |G.E| ≥ |G.V|    return True  for each u in G.V    u.vis = False  for each u in G.V    if u.vis == False      if DFS-C(G, u, NIL)        return True  return False\r\n20.4-4\r\n算法TOPOLOGICAL-SORT生成的节点序列中，不能保证坏边的数量最少。\r\n令有向图\\(G=(V,E),V=\\{a,b,c,d\\},E\\{(a,b),(b,c),(a,d),(d,c),(c,a)\\}\\)。如下图所示：\r\n\r\n如果按照\\(c,a,b,d\\)的顺序发现\\(G\\)中的所有节点，那么每个节点的时间戳如图所示，最终产生的拓扑序列为\\((c,d,a,b)\\)，它将会产生\\(2\\)条坏边\\((b,c),(d,c)\\)。然而序列\\((a,b,d,c)\\)只产生\\(1\\)条坏边（如右图所示）。\r\n20.4-5\r\n我们将使用队列保存所有入度为\\(0\\)的节点。队列每弹出一个节点，那么就将这个节点的所有出边删除，如果后续节点有的入度变成了\\(0\\)，那么将这个节点加入队列中。整个算法由TOPOLOGICAL-SORT-BFS给出。\r\nTOPOLOGICAL-SORT-BFS(G)  let order be new array  Q = ∅  for each u in G.V    u.deg = G.Adj[u].size    if u.deg == 0        ENQUEUE(Q, u)  while Q != ∅     u = DEQUEUE(Q)    INSERT(order, u)    for each v in G.Adj[u]      v.deg = v.deg - 1      if v.deg == 0        ENQUEUE(Q, v)  if order.size != |G.V|    return NIL  else    return order\r\n给定的其中一个拓扑序列即为节点的出队序列。由于每个节点最多只会入队，出队一次，因此第11-14行的循环每个节点只会被运行一次，最终算法TOPOLOGICAL-SORT-BFS的时间复杂度为\\(O(V+E)\\)。\r\n当\\(G\\)中存在环时，环中的所有节点将会无法进入队列。因此，第8行的while循环执行次数将会小于\\(|V|\\)。最终构造出来的侯选序列order大小也不等于\\(|V|\\)，由此这个图没有对应的拓扑序列。\r\n","categories":["算法导论"]},{"title":"算法导论2.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-2/exercises-2/","content":"\r\n2.2-1\r\n\\[\\Theta(n^3)\\]\r\n2.2-2\r\nSELECTION-SORT(A, n)  for i = 1 to n - 1    minpos = i    for j = i + 1 to n      if A[j] &lt; A[minpos]        minpos = j      swap(a[i], a[minpos])\r\n循环不变量：到了第\\(i\\)次迭代前，\\(A[1:i-1]\\)已经保持有序，并且是数组\\(A\\)中前\\(i-1\\)小的数。第\\(i\\)次迭代完成后，\\(minpos\\)所指向的数必定是数组\\(A\\)中第\\(i\\)小的数。交换\\(A[i],A[minpos]\\)后，\\(A[1:i]\\)仍然保持有序，并且是数组\\(A\\)中前\\(i\\)小的数。\r\n2.2-3\r\n如下是抄自2.1-4中LINEAR-SEARCH算法的伪代码。\r\nLINEAR-SEARCH(A, n, x)  for i = 1 to n    if A[i] == x      return i  return NIL\r\n假设数组\\(A\\)中每个元素相互独立，它们各自等于\\(x\\)的概率分别为\\(p\\)。\r\n那么，循环最终在第\\(i\\)次迭代结束的概率为\\(p(1-p)^{i-1}\\)。那么最终算法找不到元素\\(x\\)的概率为\\((1-p)^n\\)。\r\n可以看出，随着\\(n\\)增大，\\(i\\)的分布律和几何分布\\(GE(p)\\)类似，考虑使用几何分布对这个分布律进行近似。几何分布的期望值为\\(np\\)，那么平均需要检查的元素个数为\\(np\\)，也就是\\(\\Theta(n)\\)。最坏情况下全部\\(n\\)个元素都检查完，也就是\\(\\Theta(n)\\)。\r\n平均情况下的运行时间：第一行代码和第二行代码都会运行\\(np\\)次，第三行和第四行其中只有一个会被执行，因此平均运行时间为\\(c_1np+c_2np+(1-p)^nc_4+(1-(1-p)^n)c_3\\)，也就是\\(\\Theta(n)\\)。\r\n最坏情况下的运行时间：找不到元素。因此第一行代码运行\\(n+1\\)次，第二行代码运行\\(n\\)次，第四行代码运行\\(1\\)次，因此运行时间为\\(c_1(n+1)+c_2n+c_4\\)，也就是\\(\\Theta(n)\\)。\r\n2.2-4\r\n\r\n在排序算法执行前先判断数组是否有序，如果有序那么提前返回结果，否则照样执行排序算法。\r\n使用一些随机算法先将原来的数组乱序。\r\n\r\n","categories":["算法导论"]},{"title":"算法导论20.5 Exercises 答案","url":"/introduction-to-algorithms/chapter-20/exercises-5/","content":"\r\n20.5-1\r\n增加一条边会使得图\\(G\\)中的强连通数量减少或者不变。\r\n不变时有\\(3\\)种情况：\r\n\r\n这条边被加在了强连通分量内部。\r\n\\(u\\in C_i,v\\in C_j\\)，并且从\\(u\\)到\\(v\\)已经有一条路径。\r\n\\(u\\in C_i,v\\in C_j\\)，并且\\(C_i\\)和\\(C_j\\)在\\(G^{SCC}\\)对应的\\(v_i,v_j\\)没有特定的拓扑序。\r\n\r\n减少时有\\(1\\)种情况：\r\n\\(u\\in C_i,v\\in C_j\\)，并且\\(C_j\\)中的所有点都可以到达\\(C_i\\)。这条边被加入后，从\\(C_i\\)到\\(C_j\\)中的所有强连通分量都会被合并成一个强连通分量。\r\n20.5-2\r\n题目20.3-2给出了如下关于图\\(G\\)的遍历信息：\r\n\\(\\begin{array}{|l|l|l|}\\hline\r\nv&amp;v.d&amp;v.f\\\\\r\n\\hline\r\nq&amp;1&amp;16\\\\\r\n\\hline\r\nr&amp;17&amp;20\\\\\r\n\\hline\r\ns&amp;2&amp;7\\\\\r\n\\hline\r\nt&amp;8&amp;15\\\\\r\n\\hline\r\nu&amp;18&amp;19\\\\\r\n\\hline\r\nv&amp;3&amp;6\\\\\r\n\\hline\r\nw&amp;4&amp;5\\\\\r\n\\hline\r\nx&amp;9&amp;12\\\\\r\n\\hline\r\ny&amp;13&amp;14\\\\\r\n\\hline\r\nz&amp;10&amp;11\\\\\r\n\\hline\r\n\\end{array}\\)\r\n到此完成了算法STRONGLY-CONNECTED-COMPONENTS的第\\(1\\)行。接下来则是按照完成时间从大到小遍历\\(G^T\\)的每个强连通分量：\\((r),(u),(q,y,t),(x,z),(s,w,v)\\)。\r\n20.5-3\r\n如果\\(G\\)中有两个强连通\\(C_1,C_2\\)，并且\\(C_1\\)中的节点有通过\\(C_2\\)的节点，那么如果遍历时\\(C_1\\)中有节点已经完成，那么在第二次DFS的过程将会导致\\(C_1\\)与\\(C_2\\)被合并在一起。\r\n具体而言，令\\(G=(V,E),V=\\{a,b,c\\},E=\\{(a,b),(b,a),(b,c)\\}\\)，可以知道两个强连通分量分别为\\((a,b),(c)\\)。如图所示：\r\n\r\n如果第1次DFS按照\\(b,a,c\\)的顺序遍历这个图，那么\\(a\\)最先完成。在第二次DFS中，强连通分量\\(\\{a,b\\}\\)最先被遍历，由于\\(\\{c\\}\\)仍未遍历，因此第2次DFS将会合并这2个强连通分量，从而得出错误的解。\r\n20.5-4\r\n对于两个图\\(G\\)和其转置\\(G^T\\)，按照SCC的定义，\\(u,v\\)同属一个强连通分量当且仅当\\(u,v\\)相互可达，这在两个图中是显而易见的，因此有\\((V^T)^{GCC}=V^{GCC}\\)。转置操作不会影响点集的变化，因此有\\(((V^T)^{GCC})^T=V^{GCC}\\)。\r\n接下来证明\\(((E^T)^{GCC})^T=E^{GCC}\\)，对于\\(\\forall\r\n(v_i,v_j)\\in((E^T)^{GCC})^T\\)，可以知道\\((v_j,v_i)\\in\r\n(E^T)^{GCC}\\)。也就是说，如果\\(v\\in C_j\r\n,u\\in C_i\\)，那么有\\((v,u)\\in\r\nE^T\\)，也就是有\\((u,v)\\in\r\nE\\)。因此有\\((v_i,v_j)\\in\r\nE^{GCC}\\)，即\\(((E^T)^{GCC})^T=E^{GCC}\\)。\r\n因此可以得出，\\(((G^T)^{GCC})^T=G^{GCC}\\)。\r\n20.5-5\r\n最简便的做法是，先使用算法STRONGLY-CONNECTED-COMPONENTS'为图\\(G\\)的每个节点\\(u\\)生成一个scc属性，表示\\(u\\)所在的强连通分量。然后再枚举\\(E\\)中的每一条边\\(e\\)，通过scc属性转化成边\\(e_{SCC}\\)，再将其存在一个集合中即可（基于哈希表实现）。整个过程将会达到\\(O(V+E)\\)的时间复杂度。这个算法由GEN-COMPONENT-GRAPH给出。\r\n// 假设算法STRONGLY-CONNECTED-COMPONENTS&#x27;(G) 对图$G$中的所有节点都附带上了一个属性scc，表示它所属的强连通分量。GEN-COMPONENT-GRAPH(G)  STRONGLY-CONNECTED-COMPONENTS&#x27;(G)  let V, E be hash-sets  for each u in G.V    for each v in G.Adj[u]      if u.scc != v.scc        INSERT(E, (u.scc, v.scc))    INSERT(V, u.scc)  return V, E\r\n20.5-6\r\n本题的做法与20.5-5类似。为了保证最少的边数，对于强连通分量内部的所有边，先进行删除，然后将内部所有一共\\(n\\)个节点首尾相接成一个环。而强连通分量之间的边和20.5-5一样，仅保留一条（在\\(G\\)上保留\\(E\\)中的边）。这个算法由程序GEN-COMPONENT-GRAPH给出，时间复杂度为\\(O(V+E)\\)。\r\n// 该算法将L中（强连通分量内部C的所有点串接成一个环，并插入数组E中）GEN-CYCLE(E, C)  n = C.size  for i = 0 to n - 1    INSERT(E, (C[i], C[(i + 1) % n])) // L是强连通分量内部的所有节点。GEN-COMPONENT-GRAPH(G)  STRONGLY-CONNECTED-COMPONENTS&#x27;(G)  let edges be hash-set  let vscc be hash-map  let E be new array  for each u in G.V    INSERT(vscc[u.scc], u)    for each v in G.Adj[u]      if u.scc != v.scc        if (u.scc, v.scc) not in edges          INSERT(edges, (u.scc, v.scc))          INSERT(E, (u, v))  for each key, value in vscc    GEN-CYCLE(E, value)  return G.V, E\r\n20.5-7\r\n我们首先将求出\\(G\\)的分量图\\(G^{SCC}\\)，再判断\\(G^{SCC}\\)是否半连通即可。因为强连通分量内部的所有节点都是相互可达的，内部节点可以视作一个整体。由于\\(G^{SCC}\\)是一个有向无环图，因此如果它也是一个半连通图，那么\\(V^{SCC}\\)中的所有节点必须处在同一条“链”上，也就是说，拓扑序列是唯一的。因此我们求出\\(G^{SCC}\\)的拓扑序列后，判断拓扑序列的相邻两个节点所得到的边是否在\\(E^{SCC}\\)中即可。这个算法由程序IS-SEMICONNECTED给出，整个过程的时间复杂度为\\(O(V+E)\\)。\r\nIS-SEMICONNECTED(G)  H = GEN-COMPONENT-GRAPH(G)  order = TOPOLOGICAL-SORT(H)  n = order.size  for i = 0 to n - 2    if (order[i], order[i + 1]) not in H.E      return False  return True\r\n20.5-8\r\n我们首先将求出\\(G\\)的分量图\\(G^{SCC}\\)。由于强连通分量内部节点相互可达，因此只保留强连通分量内部的最大值和最小值，也就是\\(\\displaystyle{v_{k\\max}=\\max_{u\\in\r\nC_k}\\{l(u)\\},v_{k\\min}=\\min_{u\\in C_k}\\{l(u)\\}}\\)。\r\n那么使用动态规划算法即可完成本题。考虑状态\\(f_G(v_k)\\)表示在\\(G^{SCC}\\)中，对于所有能够到达节点\\(v_k\\)的\\(v_{i\r\n\\min}\\)的最小值。那么可以写出\\(f_G(v_k)\\)的状态转移方程：\r\n\\[f_G(v_k)=\\min\\{v_{k\\min},\\min_{(v_i,v_k)\\in\r\nE^{SCC}}\\{f_G(v_l)\\}\\}\\]\r\n在计算\\(f_G(v_k)\\)时，需要先处理好\\(G^{SCC}\\)的拓扑序列。\r\n那么，最终问题的答案为\r\n\\[\\max_{v_k\\in\r\nV^{SCC}}\\{v_{k\\max}-f_G(v_k)\\}\\]\r\n整个问题的算法由CAL-MAX-DELTA-L程序给出，其时间复杂度为\\(O(V+E)\\)。\r\nCAL-MAX-DELTA-L(G)  H = GEN-COMPONENT-GRAPH(G)  for each u in H.V    u.max-l = max&#123;l(v) | v ∈ G.V, v.scc = u&#125;    u.f = u.min-l = min&#123;l(v) | v ∈ G.V, v.scc = u&#125;  ans = -∞  order = TOPOLOGICAL-SORT(H)  for u in order    ans = max&#123;ans, u.max-l - u.f&#125;    for v in H.Adj[u]      v.f = min&#123;v.f, u.f&#125;  return ans\r\n","categories":["算法导论"]},{"title":"算法导论22.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-22/exercises-1/","content":"\r\n22.1-1\r\n第一个问题的迭代过程如下：\r\n\\(\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\ns&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nt&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nx&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\ny&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nz&amp;0&amp;\\text{NIL}\\\\\\hline\r\n\\end{array}\r\n\\longrightarrow\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\ns&amp;2&amp;z\\\\\\hline\r\nt&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nx&amp;7&amp;z\\\\\\hline\r\ny&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nz&amp;0&amp;\\text{NIL}\\\\\\hline\r\n\\end{array}\r\n\\longrightarrow\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\ns&amp;2&amp;z\\\\\\hline\r\nt&amp;5&amp;x\\\\\\hline\r\nx&amp;7&amp;z\\\\\\hline\r\ny&amp;9&amp;s\\\\\\hline\r\nz&amp;0&amp;\\text{NIL}\\\\\\hline\r\n\\end{array}\r\n\\longrightarrow\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\ns&amp;2&amp;z\\\\\\hline\r\nt&amp;5&amp;x\\\\\\hline\r\nx&amp;6&amp;y\\\\\\hline\r\ny&amp;9&amp;s\\\\\\hline\r\nz&amp;0&amp;\\text{NIL}\\\\\\hline\r\n\\end{array}\r\n\\longrightarrow\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\ns&amp;2&amp;z\\\\\\hline\r\nt&amp;4&amp;x\\\\\\hline\r\nx&amp;6&amp;y\\\\\\hline\r\ny&amp;9&amp;s\\\\\\hline\r\nz&amp;0&amp;\\text{NIL}\\\\\\hline\r\n\\end{array}\\)\r\n第二个问题的迭代过程如下：\r\n\\(\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\ns&amp;0&amp;\\text{NIL}\\\\\\hline\r\nt&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nx&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\ny&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nz&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\n\\end{array}\r\n\\longrightarrow\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\ns&amp;0&amp;\\text{NIL}\\\\\\hline\r\nt&amp;6&amp;s\\\\\\hline\r\nx&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\ny&amp;7&amp;s\\\\\\hline\r\nz&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\n\\end{array}\r\n\\longrightarrow\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\ns&amp;0&amp;\\text{NIL}\\\\\\hline\r\nt&amp;6&amp;s\\\\\\hline\r\nx&amp;4&amp;y\\\\\\hline\r\ny&amp;7&amp;s\\\\\\hline\r\nz&amp;2&amp;t\\\\\\hline\r\n\\end{array}\r\n\\longrightarrow\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\ns&amp;0&amp;\\text{NIL}\\\\\\hline\r\nt&amp;2&amp;x\\\\\\hline\r\nx&amp;4&amp;y\\\\\\hline\r\ny&amp;7&amp;s\\\\\\hline\r\nz&amp;2&amp;t\\\\\\hline\r\n\\end{array}\r\n\\longrightarrow\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\ns&amp;0&amp;\\text{NIL}\\\\\\hline\r\nt&amp;2&amp;s\\\\\\hline\r\nx&amp;4&amp;y\\\\\\hline\r\ny&amp;7&amp;s\\\\\\hline\r\nz&amp;-2&amp;t\\\\\\hline\r\n\\end{array}\\)\r\n注意到第二个问题中的图有负环，算法BELLMAN-FORD将会返回FALSE。\r\n22.1-2\r\n充分性：根据引理22.2，执行完Bellman-ford算法后，有\\(v.d=\\delta(s,v)。\\)由于从\\(s\\)到\\(v\\)中存在路径，那么必定存在一条最短路径，使得\\(\\delta(s,v)&lt;\\infty\\)，因此有\\(v.d&lt;\\infty\\)。\r\n必要性：由于\\(v.d&lt;\\infty\\)，这说明节点\\(v\\)被松驰过，并且节点的\\(\\pi\\)属性记录着这条路径的上一个节点。那么我们可以递归访问路径上其前驱节点。由于其前驱子图\\(G_\\pi\\)是一棵以\\(s\\)为根的树，因此我们最终可以递归访问到\\(s\\)节点，这说明从\\(s\\)到\\(v\\)存在一条路径。\r\n22.1-3\r\n如果所有边都不再被松弛，那么说明整个算法可以结束了。因此我们使用一个布尔遍历来记录第\\(i\\)轮迭代是否发生了松弛，如果没有发生松弛那么可以及时结束整个算法。改进后的程序为BELLMAN-FORD'：\r\nRELAX&#x27;(u, v, w)  if v.d &gt; u.d + w(u, v)    v.d = u.d + w(u, v)    v.π = u    return TRUE  return FALSEBELLMAN-FORD&#x27;(G, w, s)  INITIALIZE-SINGLE-SOURCE(G, s)  for i = 1 to |G.V| − 1    relax-appear = FALSE    for each edge (u, v) ∈ G.E      if RELAX&#x27;(u, v, w) == TRUE        relax-appear = TRUE    if relax-appear == FALSE      break  for each edge (u, v) ∈ G.E    if v.d &gt; u.d + w(u, v)      return FALSE  return TRUE\r\n22.1-4\r\n如果在第\\(|V|\\)轮迭代中，一条边\\((u,v)\\)仍然进行了一次松弛操作，那么说明\\(v\\)存在于某个负环中。这说明，从\\(v\\)开始可达的节点，都不存在最短路径。因此我们标记上这些节点，然后通过DFS访问这些节点所有的可达节点，并将它们标记上\\(-\\infty\\)即可。这个算法由BELLMAN-FORD''给出，其时间复杂度仍然为\\(O(V^2+VE)\\)，因为标记节点所需要的开销远远低于BELLMAN-FORD算法本身的执行过程。\r\nDFS-VISIT-BELLMAN-FORD(G, u)  if u.d != -∞    u.d = -∞    for each vertex v in G.Adj[u]      DFS-VISIT(G, v)BELLMAN-FORD&#x27;&#x27;(G, w, s)  INITIALIZE-SINGLE-SOURCE(G, s)  for i = 1 to |G.V| − 1    for each edge (u, v) ∈ G.E      RELAX(u, v, w)  for each edge (u, v) ∈ G.E    if v.d &gt; u.d + w(u, v)      DFS-VISIT-BELLMAN-FORD(G, v)\r\n22.1-5\r\n如果边集\\(E\\)是直接按照一个列表给定的，那么就不必再在每次迭代中遍历每个节点，再访问其对应的边。直接访问这个列表中的边进行松弛操作即可，把时间复杂度从\\(O(V^2+VE)\\)降到\\(O(VE)\\)，这在图非常稀疏时是有效的，这个算法由程序BELLMAN-FORD'''给出。\r\nBELLMAN-FORD&#x27;&#x27;&#x27;(G, s)  INITIALIZE-SINGLE-SOURCE(G, s)  for i = 1 to |G.V| − 1    for each edge (u, v, w) ∈ G.E      if u.d + w &lt; v.d        v.d = w + u.d        v.π = u  for each edge (u, v, w) ∈ G.E    if v.d &gt; u.d + w      return FALSE  return TRUE\r\n22.1-6\r\n也就是说，\\(\\delta^{\\ast}(v)\\)是图\\(G=(V,E)\\)中，\\(V\\)中所有节点到\\(v\\)的最短距离。那么所有节点的\\(v.d\\)的初始化值为\\(0\\)，因为初始化时\\(d=0\\)意味着从其它节点到自身距离当前的最小值。整个算法由程序CAL-DELTA-STAR给出，除了初始化步骤不相同，其它步骤都一样，此外还使用了题目22.1-4中的子程序DFS-VISIT-BELLMAN-FORD用来填充\\(-\\infty\\)。因此最终其时间复杂度为\\(O(VE)\\)。\r\nCAL-DELTA-STAR(G, w)  for each vertex v ∈ G.V    v.d = 0  for i = 1 to |G.V| − 1    for each edge (u, v) ∈ G.E      RELAX(u, v, w)  for each edge (u, v) ∈ G.E    if v.d &gt; u.d + w(u, v)      DFS-VISIT-BELLMAN-FORD(G, v)\r\n另外一个看待这一道题目的角度是，构造一个超级原点\\(s\\)，令\\(G&#39;=\\left(V\\cup\\{s\\},E\\cup\\bigcup_{v\\in\r\nV}(s,v)\\right)\\)。并且\\(\\forall v\\in\r\nV,w(s,v)=0\\)。那么我们可以对超级原点\\(s\\)进行Bellman-Ford算法。其结果和程序CAL-DELTA-STAR一致。因为\\(s\\)相当于是将\\(V\\)中的所有节点集合在一起，形成一个新的起点。\r\n22.1-7\r\n进行完\\(|V|-1\\)轮的松弛操作后，如果仍然发现有\\(v.d &gt; u.d + w(u, v)\\)，那么说明点\\(v\\)必定出现在了某一个负环\\(C\\)中。事实上，由于负环中的每条边都进行了反复松弛，那么\\(v\\)的前驱节点\\(v.\\pi\\)也会在\\(C\\)中。迭代访问\\(v\\)的\\(\\pi\\)属性，最终可以将一个整个环\\(C\\)处理出来。\r\n整个算法由过程GET-NEG-CYCLE给出，与过程BELLMAN-FORD类似，其时间复杂度为\\(O(V^2+VE)\\)。\r\nGET-NEG-CYCLE(G, w, s)  INITIALIZE-SINGLE-SOURCE(G, s)  for i = 1 to |G.V| − 1    for each (u, v) ∈ G.E      RELAX(u, v, w)  for each u ∈ G.V    u.mark = FALSE  for each edge (u, v) ∈ G.E    if v.d &gt; u.d + w(u, v)      Let C be new array      v.mark = TRUE      x = v      while x.mark == FALSE        INSERT(C, x)        x.mark = TRUE        x = x.π      INSERT(C, v)        return C  return NIL\r\n","categories":["算法导论"]},{"title":"算法导论22.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-22/exercises-2/","content":"\r\n22.2-1\r\n整个迭代过程如下：\r\n\\(\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\nr&amp;0&amp;\\text{NIL}\\\\\\hline\r\ns&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nt&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nx&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\ny&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nz&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\n\\end{array}\r\n\\longrightarrow\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\nr&amp;0&amp;\\text{NIL}\\\\\\hline\r\ns&amp;5&amp;r\\\\\\hline\r\nt&amp;3&amp;r\\\\\\hline\r\nx&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\ny&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nz&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\n\\end{array}\r\n\\longrightarrow\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\nr&amp;0&amp;\\text{NIL}\\\\\\hline\r\ns&amp;5&amp;r\\\\\\hline\r\nt&amp;3&amp;r\\\\\\hline\r\nx&amp;11&amp;s\\\\\\hline\r\ny&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nz&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\n\\end{array}\r\n\\longrightarrow\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\nr&amp;0&amp;\\text{NIL}\\\\\\hline\r\ns&amp;5&amp;r\\\\\\hline\r\nt&amp;3&amp;r\\\\\\hline\r\nx&amp;10&amp;t\\\\\\hline\r\ny&amp;7&amp;t\\\\\\hline\r\nz&amp;5&amp;t\\\\\\hline\r\n\\end{array}\r\n\\longrightarrow\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\nr&amp;0&amp;\\text{NIL}\\\\\\hline\r\ns&amp;5&amp;r\\\\\\hline\r\nt&amp;3&amp;r\\\\\\hline\r\nx&amp;10&amp;t\\\\\\hline\r\ny&amp;7&amp;t\\\\\\hline\r\nz&amp;5&amp;t\\\\\\hline\r\n\\end{array}\r\n\\longrightarrow\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\nr&amp;0&amp;\\text{NIL}\\\\\\hline\r\ns&amp;5&amp;r\\\\\\hline\r\nt&amp;3&amp;r\\\\\\hline\r\nx&amp;10&amp;t\\\\\\hline\r\ny&amp;7&amp;t\\\\\\hline\r\nz&amp;5&amp;t\\\\\\hline\r\n\\end{array}\\)\r\n22.2-2\r\n令\\(z\\)是这个拓扑序列的最后一个节点。我们首先证明\\(z\\)在图\\(G\\)中没有出边。如果\\(z\\)有出边，假设这条出边指向的节点是\\(u\\)，那么在拓扑序列\\(u\\)应该在\\(z\\)后面，这和\\(z\\)是最后一个节点是矛盾的。因此\\(z\\)没有出边。\r\n既然\\(z\\)没有出边，那么它对应的邻接表的槽则是空的，那么自然不需要去遍历\\(z\\)所对应的槽，因此原结论成立。\r\n22.2-3\r\n改造后的算法如程序DAG-LONGEST-PATHS'所示。为了方便构造出一条路径，避免每个节点都运行一次算法，我们将构造一个虚拟原点\\(s\\)，它作为所有任务的前驱，最先被执行，并且不需要完成时间。\\(E\\)中的每一条边\\((u,v)\\)的边权都相当于是任务\\(v\\)的完成时间\\(T[v]\\)。在这里，\\(v.d\\)是指完成节点\\(v\\)时的最长时间。最终满足\\(v.d\\)最大的\\(v\\)，\\(v.\\pi\\)也同样构成一条关键路径。\r\n// 假设数组T[u]表示完成任务u的时间。DAG-LONGEST-PATHS&#x27;(G, T)  topologically sort the vertices of G  // 初始化  let s be a source node  INSERT(G.V, s)  for each u ∈ G.V - &#123;s&#125;    u.d = -∞    u.π = NIL    INSERT(G.Adj[s], u)  s.d = 0  s.π = NIL  for each vertex u ∈ G.V, taken in topologically sorted order    for each vertex v in G.Adj[u]      if v.d &lt; u.d + T[v]        v.d = u.d + T[v]        v.π = u\r\n另外一种构造思路则是将每个任务节点\\(u\\)拆分成两个状态：进入状态\\(u_i\\)和完成状态\\(u_o\\)，并且连入一条边\\((u_i,u_o),w(u_i,u_o)=T[u]\\)。对于外部的任务依赖过程，则不需要花费时间。更正式的定义一个新图\\(G&#39;=(V&#39;,E&#39;)\\)，包含以下两种边：\r\n\r\n\\(\\forall u\\in V,u_i\\in V&#39;,u_o\\in\r\nV&#39;,(u_i,u_o)\\in E&#39;,w&#39;(u_i,u_o)=T[u]\\)。\r\n\\(\\forall (u,v)\\in E,(u_o,v_i)\\in\r\nE&#39;,w&#39;(u_o,v_i)=0\\)。\r\n\r\n那么对图\\(G&#39;\\)进行DAG-LONGEST-PATHS也可以求出一条关键路径，不过构造关键路径时，只记录边权大于\\(0\\)的边。\r\n\\(\\star\\)\r\n22.2-4\r\n和题目20.4-2类似，考虑使用动态规划的思想来解决本题。\r\n令\\(f_G(v)\\)表示在有向无环图\\(G\\)，终点为\\(v\\)的路径条数。那么可以写出如下状态转移方程：\r\n\\(\\displaystyle{f_G(v)=1+\\sum_{u\\in\r\nV;(u,v)\\in E} f_G(u)}\\)\r\n这个方程的意思是，对于所有到达\\(u\\)的路径，拼接一条边\\((u,v)\\)就能让它们都到达\\(v\\)，由于最后一条路径是不同的，因此不会重复计数。\r\n由于\\(G\\)是一个有向无环图，\\(f_G\\)并不会形成循环。我们可以考虑从\\(G\\)的拓扑序列上实现计算\\(f_G\\)的过程。计算\\(f_G(v)\\)的算法由CAL-PATHS'过程给出。\r\n因此，整道题目的最终答案为\\(\\displaystyle{\\sum_{u\\in V} f_G(v)}\\)。\r\nCAL-PATHS&#x27;(G)  topologically sort the vertices of G  // 初始化  for each u ∈ G.V    u.paths = 1  for each vertex u ∈ G.V, taken in topologically sorted order    for each vertex v in G.Adj[u]      v.paths = v.paths + u.paths  paths = 0  for each u ∈ G.V    paths = paths + u.paths = 1  return paths\r\n","categories":["算法导论"]},{"title":"算法导论20 Problems 答案","url":"/introduction-to-algorithms/chapter-20/problems/","content":"\r\n20-1\r\na\r\n1\r\n在无向图中进行BFS，如果从节点\\(u\\)访问到了节点\\(v\\)，并且这是一条后向边，说明\\(v\\)在BFS树中是\\(u\\)的祖先。也就是\\(v.d&lt; u.d\\)。如果\\(v.d=u.d-1\\)，那么说明\\((u,v)\\)我们反向遍历了这条树边，否则就说明了BF树上从\\(v\\)到\\(u\\)有两条路径；而\\(v.d&lt;\r\nu.d-1\\)这种情况不会存在。因此后向边不存在。\r\n前向边也不可能存在。如果从节点\\(u\\)访问到了节点\\(v\\)，并且这是一条前向边，那么\\(v\\)是\\(u\\)的后代，并且\\(v\\)已经被访问过。然而在BF树中，节点\\(u\\)的后代只有可能在BF树创立新节点时才会被访问到。这两者是冲突的。\r\n2\r\n如果从已访问节点\\(u\\)去访问未访问的白色节点\\(v\\)，那么BF树就会创造一条树边，使得\\(v.d=u.d+1\\)。这和BF树中对\\(d,\\pi\\)这两个属性的定义是一致的。\r\n3\r\n横向边是除去以上\\(3\\)种情况的其他边。根据引理20.1和属性\\(d\\)的计算正确性\\(v.d=\\delta(s,v)\\)，有\\(|u.d-v.d|\\le 1\\)。因此横向边要么满足\\(v.d=u.d\\)，要么满足\\(v.d=u.d+1\\)。\r\nb\r\n1\r\n前向边不可能存在。和无向图论证的方式类似，如果\\((u,v)\\)是一条前向边，那么说明在BF树中\\(v\\)是\\(u\\)的后代，在访问\\(u\\)时，\\(v\\)已经访问过。但是在BFS中，只有拓展新节点时才会访问到自己的后代。因此前向边不可能存在。\r\n2\r\n和无向图的情形类似。如果从已访问节点\\(u\\)通过边\\((u,v)\\)去访问未访问的白色节点\\(v\\)，那么BF树就会创造一条树边，使得\\(v.d=u.d+1\\)。如果\\(v\\)已经被处理，那么\\((u,v)\\)就不会是树边。\r\n3\r\n当\\(v.d\\le\r\nu.d\\)时，这种情况非常普遍。由于\\(u,v\\)在BF树中没有祖孙关系，并且在访问\\(u\\)时，\\(v\\)已经被访问过。\r\n当\\(v.d=u.d+1\\)时，这和BFS的顺序有关系。此时\\(v\\)首先被另一个同层的父节点\\(u&#39;\\)产生，由于\\((u&#39;,v)\\)是树边，那么\\((u,v)\\)就是横向边。\r\n4\r\n如果\\((u,v)\\)是一条后向边，这意味着在BF树中\\(v\\)是\\(u\\)的祖先。那么BF树中将会有一条有向路径\\(v,v_1,v_2,v_3,\\dots,v_{m-1},v_m,u\\)，并且这一条路径中的\\(d\\)属性都是按深度增加的，即\\(u.d=v_m.d+1=v_{m-1}.d+2=\\dots=v_1.d+m=v.d+m+1\\)，也就是有\\(v.d&lt;\r\nu.d\\)，我们证明了比题目更强的条件。\r\n20-2\r\na\r\n令\\(r\\)是\\(G_\\pi\\)的根节点。\r\n必要性：如果\\(r\\)在\\(G_{\\pi}\\)只有一个孩子，那么在\\(G_{\\pi}\\)删除\\(r\\)后，\\(G_{\\pi}\\)剩下的\\(|V|-1\\)个节点之间仍然是连通的，这说明图\\(G\\)删去\\(r\\)后也是连通的。因此，只有\\(r\\)有至少\\(2\\)个孩子，\\(r\\)才是割点。\r\n充分性：由于\\(r\\)是割点，因此\\(G\\)中存在两个点\\(u,v\\)，它们之间的所有路径都是经过\\(r\\)的。如果删除了这个节点，\\(u\\)和\\(v\\)不能相互可达。那么令从\\(u\\)到\\(v\\)的一条路径为\\((u,\\dots,a,r,b,\\dots,v)\\)。如果\\(a=b\\)，那么删去\\(r\\)后，将会使得\\(u\\)到\\(v\\)仍然可达，因为有路径\\((u,\\dots,a,\\dots,v)\\)，这不符合\\(r\\)是割点，因此\\(a\\neq b\\)。那么也就是说，从\\(a\\)不能不经过\\(r\\)才能到达\\(b\\)。因此构造DF树时，以\\(r,a\\)的顺序开始进行遍历，不通过\\(r\\)并不能访问\\(b\\)。因此\\(G_\\pi\\)中的\\(r\\)至少有两个不同的子节点\\(a,b\\)。\r\nb\r\n必要性：使用反证法证明。如果对于所有\\(v\\)的后代\\(s\\)，都存在从\\(s\\)的某个后代\\(s&#39;\\)指向\\(v\\)的真祖先\\(v&#39;\\)的后向边\\(e&#39;=(s&#39;,v&#39;)\\)，那么去掉节点\\(s\\)后，所有的\\(e&#39;\\)边都将会连通\\(s\\)所在的连通块和图\\(G\\)的主干连通块（也就是\\(v&#39;\\)所在的连通块），因此\\(v\\)节点被删去后，并不影响整个图的连通性，此时\\(v\\)不是割点，引出矛盾。\r\n充分性：如果\\(v\\)是割点，那么对于子树\\(s\\)中的某个\\(u\\)，与非\\(s\\)子树中的某个节点\\(v\\)之间的所有路径都需要经过\\(r\\)。去除\\(r\\)后，那么\\(u,v\\)不互通。因此子树\\(u\\)中的所有节点也不可能和\\(v\\)的真祖先有任何边，否则会导致去除\\(v\\)后的图仍然连通。\r\nc\r\n对于一个节点\\(u\\)，求它的\\(low\\)属性可以从其子节点转移而来（而不必直接枚举\\(u\\)的所有子节点。因此，题中对\\(u.low\\)的计算可以进一步修改成如下形式：\r\n\\(u.low=\\min\r\n\\left \\{\\begin{aligned}\r\n  &amp;u.d\\\\\r\n  &amp;v.d :&amp;(u,v) \\text{ is a back edge of }v\\\\\r\n  &amp;v.low : &amp;(u,v) \\text{ is a tree edge of }v\\\\\r\n\\end{aligned}\\right.\\)\r\n计算\\(low\\)属性的算法由程序DFS-GEN-LOW-U给出，它由DFS改造而来，并且没有枚举图中的所有节点，因此时间复杂度为\\(O(E)\\)。\r\nDFS-GEN-LOW-U(G)  for each vertex u ∈ G.V    u.color = WHITE    u.π = NIL  select r ∈ G.V randomly  DFS-GEN-LOW-VIS-U(G, r, NIL)// 第三个参数是为了避免父节点被作为子节点遍历。DFS-GEN-LOW-VIS-U(G, u, fa)  time = time + 1                 // white vertex u has just been discovered  u.d = time  u.color = GRAY  u.low = u.d  for each vertex v in G.Adj[u]   // explore each edge (u, v)    if v != fa      if v.color == WHITE        // 树边        v.π = u        DFS-VISIT-U(G, v, u)        u.low = min&#123;u.low, v.low&#125;      else if v != fa and v.color == GRAY        // 后向边        u.low = min&#123;u.low, v.d&#125;  time = time + 1  u.f = time  u.color = BLACK                 // blacken u; it is finished\r\nd\r\n\r\n根据题目20-2-a的结论，根节点\\(r\\)是割点当且仅当\\(r\\)在\\(G_\\pi\\)中有至少两个儿子。\r\n根据题目20-2-b的结论和20-2-c计算\\(low\\)属性的过程，非根节点\\(u\\)是割点当且仅当\\(u.low=u.d\\)，因为后代的所有节点没有后向边指向\\(u\\)的真祖先，也就是满足比\\(u.d\\)更小的节点。\r\n\r\n因此通过修改算法DFS-GEN-LOW-U，我们可以得到一个获得所有割点的程序GEN-ARTICULATION-POINTS，并且其时间复杂度为\\(O(E)\\)。\r\nGEN-ARTICULATION-POINTS(G)  for each vertex u ∈ G.V    u.color = WHITE    u.π = NIL  select r ∈ G.V randomly  // A是一个全局变量，用来存放G的所有割点。  let A be new array  GEN-ARTICULATION-POINTS-VIS(G, r, r, NIL)  return AGEN-ARTICULATION-POINTS-VIS(G, r, u, fa)  time = time + 1                 // white vertex u has just been discovered  u.d = time  u.color = GRAY  u.low = u.d  // deg表示当前节点在DF树中有多少条出边（度数）。  deg = 0  for each vertex v in G.Adj[u]   // explore each edge (u, v)    if v != fa      if v.color == WHITE        // 树边        deg = deg + 1        v.π = u        GEN-ARTICULATION-POINTS-VIS(G, r, v, u)        u.low = min&#123;u.low, v.low&#125;      else if v != fa and v.color == GRAY        // 后向边        u.low = min&#123;u.low, v.d&#125;  time = time + 1  u.f = time  u.color = BLACK                 // blacken u; it is finished  // 遍历结束，接下来判断u是不是割点  if (u == r and deg &gt;= 2) or (u != r and u.d == u.low)    INSERT(A, u)\r\ne\r\n充分性：如果\\((u,v)\\in E\\)是\\(G\\)的桥，那么\\((u,v)\\)之间有且只有一条简单通路。而任意一个简单回路中的任意两点间至少有两条不同简单通路，因此桥\\((u,v)\\)不属于\\(G\\)中的任何简单回路。\r\n必要性：如果\\((u,v)\\)属于某条简单回路\\((u,v,a,\\dots ,b,u)\\)，那么去除边\\((u,v)\\)后，\\((u,v)\\)之间依然有简单通路\\((v,a,\\dots,b,u)\\)，这说明\\(u\\)和\\(v\\)之间仍然是连通的，这与桥的定义矛盾。\r\nf\r\n根据题目20-2-e的结论和20-2-c计算\\(low\\)属性的过程，边\\((u,v)\\)是桥当且仅当\\(u.d&lt;v.low\\)，因为\\((u,v)\\)不属于任意一个简单回路，否则\\(v\\)可以和\\(G_\\pi\\)中非\\(u\\)子树的一部分有另外一条通路，导致\\(u.d\\ge v.low\\)。\r\n和题目20-2-d类似，因此通过修改算法DFS-GEN-LOW-U，我们可以得到一个获得所有桥的程序GEN-BRIDGES，并且其时间复杂度为\\(O(E)\\)。需要注意的是，只有树边才有可能是桥。\r\nGEN-BRIDGES(G)  for each vertex u ∈ G.V    u.color = WHITE    u.π = NIL  select r ∈ G.V randomly  // B是一个全局变量，用来存放G的所有桥。  let B be new array  GEN-BRIDGES-VIS(G, r, NIL)  return BGEN-BRIDGES-VIS(G, u, fa)  time = time + 1                 // white vertex u has just been discovered  u.d = time  u.color = GRAY  u.low = u.d  for each vertex v in G.Adj[u]   // explore each edge (u, v)    if v != fa      if v.color == WHITE        // 树边        v.π = u        GEN-BRIDGES-VIS(G, v, u)        u.low = min&#123;u.low, v.low&#125;        // 判断(u, v)是不是桥        if u.d &lt; v.low          INSERT(B, (u, v))      else if v != fa and v.color == GRAY        // 后向边        u.low = min&#123;u.low, v.d&#125;  time = time + 1  u.f = time  u.color = BLACK                 // blacken u; it is finished\r\ng\r\n在无向图中，每一个桥都连接着两条不同的双连通分量，那么我们需要证明其它边都是属于某个单一的双连通分量中。我们使用反证法来证明两个不同的双连通分量\\(C_1,C_2\\)没有公共边。假设\\(C_1\\)和\\(C_2\\)之间有一条公共边\\((u,v)\\)。那么\\(C_1\\)中必定会有一条边\\((a,b)\\)和\\((u,v)\\)构成环，即\\((a,b,u_1,u_2\\dots\r\nu_k,u,v,v_{k+1},v_{k+2},\\dots,v_m,a)\\)，同样的，\\(C_2\\)中也会有一条边\\((x,y)\\)和\\((u,v)\\)构成环，即\\((x,y,v_1,v_2\\dots\r\nv_{k&#39;},u,v,v_{k&#39;+1},v_{k&#39;+2},\\dots,v_m&#39;,x)\\)。将这两个环合并，得到一个新环\\((a,b,u_1,u_2,\\dots,v,v_{k&#39;},v_{k&#39;-1},\\dots,v_1,y,x,v_{m&#39;},v_{m&#39;-1},\\dots,v,\\dots\r\na)\\)，这说明\\(C_1\\)和\\(C_2\\)属于同一个双连通分量，和原结论矛盾。\r\n因此，所有桥将\\(E\\)中的所有非桥边进行了一个划分，每个非桥边属于某一个双连通分量。\r\nh\r\n我们首先把图中\\(G\\)中的所有桥都删除，得到新图\\(G&#39;\\)，那么\\(G&#39;\\)的每一个连通块内部所连接的边在图\\(G\\)中都属于一个双连通分量。因此，我们可以考虑禁止访问图\\(G\\)中的所有桥，并且遍历\\(G\\)中的所有其它边，从而保证\\(G&#39;\\)中的连通块和\\(G\\)中的双连通分量是一致的。\r\nGEN-BCC(G)  //算法GEN-BRIDGES&#x27;也是用于求桥，和GEN-BRIDGES不同的是，将每一条边(u, v)都添加了一个属性is-bridge用来表示该边是否为桥。  GEN-BRIDGES&#x27;(G)  for each vertex u ∈ G.V    u.color = WHITE  count = 0 // count是一个全局变量，用于表示当前双连通分量的编号  countb = |E| // 用来给桥进行标号的全局变量。  for each vertex u ∈ G.V    if u.color == WHITE      count = count + 1      GEN-BCC-VIS(G, u, NIL)  GEN-BCC-VIS(G, u, fa)  u.color = GRAY  for each vertex v in G.Adj[u]    if v != fa      if (u, v).is_bridge == False        if v.color == WHITE          GEN-BRIDGES-VIS(G, v, u)        (u, v).bcc = count      else        // 给桥标上一个和其它边无关的数字。        (u, v).bcc = countb        countb = countb + 1  u.color = BLACK\r\n20-3\r\na\r\n充分性：由于\\(G\\)有一条欧拉回路\\(C\\)，因此在\\(C\\)中，当有一条入边进入节点\\(v\\)，总有一条出边离开节点\\(v\\)（重复经过节点\\(v\\)的边是不同的）。由于这些边恰好包含了\\(E\\)中所有的边各一次，只要\\(v\\)在\\(C\\)上出现了\\(k_v\\)次，那么就有\\(k_v\\)条不同的入边，\\(k_v\\)条不同的出边。因此对于\\(\\forall v\\in\r\nV,\\text{in-degree}(v)=\\text{out-degree}(v)=k_v\\)均成立。\r\n必要性：对于任意一条从\\(s\\)出发的一条路径\\(P\\)，它必定能回到\\(s\\)，使用反证法证明这个结论。如果从\\(s\\)出发存在一条路径它不能回到\\(s\\)，也就是说，有一条路径\\(P&#39;\\)是\\(s\\rightarrow v_1\\rightarrow v_2\r\n\\rightarrow\\dots\\rightarrow v_k\\)，并且\\(v_k\\neq s\\)，并且从\\(v_k\\)之后所有已经没有出边可走。那么令\\(v=v_k\\)，统计路径\\(P&#39;\\)得到\\(v\\)的出现次数为\\(k\\)，那么可以知道\\(v\\)的出度为\\(k-1\\)（因为已经没有边走出来了），而\\(v\\)的入度至少为\\(k\\)，这和\\(\\text{in-degree}(v)=\\text{out-degree}(v)\\)是矛盾的，因此\\(P\\)必定是一条回路。那么，接下来我们找出\\(G\\)的其中一条回路\\(C_1\\)，那么如果\\(C_1\\)是一条欧拉回路，那么完成；否则，去除\\(C_1\\)中的所有边，入度和出度相等的性质仍然保持不变，由于\\(G\\)是强连通图，那么可以找到另一条和\\(C_1\\)点相交，边不相交的回路\\(C_2\\)，并且将交点一处整合成一条回路\\(C\\)（如下图所示），直到所有的边都已经被使用。\r\n\r\n如图所示，我们已经找到了两个环\\(C_1:b\\rightarrow d\\rightarrow a\\rightarrow\r\nb\\)和\\(C_2: b\\rightarrow e\\rightarrow\r\nc\\rightarrow b\\)，那么我们可以整合成回路\\(C:b\\rightarrow d\\rightarrow a\\rightarrow b\r\n\\rightarrow c\\rightarrow e\\rightarrow b\\)。\r\nb\r\n构造欧拉回路的算法由程序EULER-CYCLE给出。由于EULER-CYCLE-DFS每遍历一条边后便会进行删除，并且没有对图中所有节点进行遍历，因此其时间复杂度为\\(O(E)\\)。\r\n这个算法的基本思想是，如果当前节点没有出路，那么说明这个节点是当前欧拉路径的终点，否则说明这个节点仍然不会是终点，继续查找之后的路径。\r\n最终，搜索结果的逆序是其中一条欧拉回路。\r\nEULER-CYCLE-DFS(G, A, u)  while G.Adj[u] != ∅    select v from G.Adj[u] randomly and remove it from G.Adj[u]    dfs(v)  INSERT(A, u)EULER-CYCLE(G)  select s ∈ G.V randomly  Let A be new array  EULER-CYCLE-DFS(G, A, s)  reverse A  return A\r\n20-4\r\n由于\\(R(u)\\)是表示在\\(G\\)中从\\(u\\)起可以到达的节点，那么也可以知道，\\(R(u)\\)是\\(G^T\\)中可达节点\\(u\\)的所有节点。\r\n为了避免循环依赖，我们首先求出\\(G^T\\)的分量图\\((G^T)^{SCC}\\)，那么就可以对\\((G^T)^{SCC}\\)进行基于BFS的拓扑排序，在这个过程中，所有节点的\\(L\\)值都能在路径上向后传递，而在这个过程中，我们只需要传递最小值即可。对\\((G^T)^{SCC}\\)处理完成后，我们再将求得的结果映射回原来的图\\(G^T\\)上的每个节点即可。\r\n算法由GEN-REACHABILITY给出，由于其两个重要步骤的时间复杂度均为\\(O(V+E)\\)，因此其时间复杂度同样为\\(O(V+E)\\)。\r\n// 每个节点u将会有一个属性min，代表答案。GEN-COMPONENT-GRAPH(G)  H = GEN-COMPONENT-GRAPH(G)  for each u in H.V    u.min = min&#123;L(v) | v ∈ G.V, v.scc = u&#125;  Q = ∅  for each u in H.V    u.deg = G.Adj[u].size    if u.deg == 0      ENQUEUE(Q, u)  while Q != ∅     u = DEQUEUE(Q)    for each v in G.Adj[u]      v.deg = v.deg - 1      v.min = min&#123;v.min, u.min&#125;      if v.deg == 0        ENQUEUE(Q, v)  for each u in G.V    u.min = u.scc.min  return G.V\r\n20-5\r\n本题似乎和图论并没有太大的关系，仅仅考察均摊分析的知识。题目中给定的平面图仅仅是说明了保证整个过程中满足\\(|E|&lt;3|V|\\)。\r\n// 假设count是一个全局变量，初始化为0，用于记录INSERT的调用次数，从而标记每个节点的进入时间。// 每个节点的属性newest表示最新邻居，time表示进入图G的时间。INSERT(G, v, neighbors)  count = count + 1  v.time = count  for each u in neighbors    u.newest = v  if neighbors == ∅    v.newest = NIL  else    v.newest = u s.t. u in neighbors and u.time is maximum    NEWEST-NEIGHBOR(G, v)  return v.newest\r\n使用核算法来分析这个过程的时间。对于每个INSERT操作，我们支付\\(4\\)美元，其中\\(1\\)美元用于对插入节点对操作，并且预支\\(3\\)美元用于边的增添进行操作；neighbors数组每个元素都将会使用预支的\\(1\\)美元完成对这一条边的邻居更新操作。对于每个NEWEST-NEIGHBOR，只需要花费\\(1\\)美元来查询当前节点的最新邻居。\r\n根据平面图的性质\\(|E|&lt;3|V|\\)可知，预支的费用是足够的。由于每次操作实际花费都不会超过\\(4\\)美元，因此可以知道INSERT和NEWEST-NEIGHBOR的平均时间复杂度为\\(O(1)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论22.4 Exercises 答案","url":"/introduction-to-algorithms/chapter-22/exercises-4/","content":"\r\n22.4-1\r\n可以知道，约束图\\(G=(V,E)\\)为：\\(V=\\{v_0,v_1,v_2,v_3,v_4,v_5,v_6\\},E\\)为下表：\r\n\\(\\begin{array}{|l|l|}\\hline\r\ne&amp;w(e)\\\\\\hline\r\n(v_0,v_1)&amp;0\\\\\\hline\r\n(v_0,v_2)&amp;0\\\\\\hline\r\n(v_0,v_3)&amp;0\\\\\\hline\r\n(v_0,v_4)&amp;0\\\\\\hline\r\n(v_0,v_5)&amp;0\\\\\\hline\r\n(v_0,v_6)&amp;0\\\\\\hline\r\n(v_2,v_1)&amp;1\\\\\\hline\r\n(v_4,v_1)&amp;-4\\\\\\hline\r\n(v_3,v_2)&amp;2\\\\\\hline\r\n(v_5,v_2)&amp;7\\\\\\hline\r\n(v_6,v_2)&amp;5\\\\\\hline\r\n(v_6,v_3)&amp;10\\\\\\hline\r\n(v_2,v_4)&amp;2\\\\\\hline\r\n(v_1,v_5)&amp;-1\\\\\\hline\r\n(v_4,v_5)&amp;3\\\\\\hline\r\n(v_3,v_6)&amp;8\\\\\\hline\r\n\\end{array}\\)\r\n最终对原点\\(0\\)执行Bellman-Ford算法，得到原差分约束的一个解为：\r\n\\((x_1,x_2,x_3,x_4,x_5,x_6)^T=(-5,-3,0,-1,-6,-8)^T\\)。\r\n22.4-2\r\n可以知道，约束图\\(G=(V,E)\\)为：\\(V=\\{v_0,v_1,v_2,v_3,v_4,v_5\\},E\\)为下表：\r\n\\(\\begin{array}{|l|l|}\\hline\r\ne&amp;w(e)\\\\\\hline\r\n(v_0,v_1)&amp;0\\\\\\hline\r\n(v_0,v_2)&amp;0\\\\\\hline\r\n(v_0,v_3)&amp;0\\\\\\hline\r\n(v_0,v_4)&amp;0\\\\\\hline\r\n(v_0,v_5)&amp;0\\\\\\hline\r\n(v_2,v_1)&amp;4\\\\\\hline\r\n(v_5,v_1)&amp;5\\\\\\hline\r\n(v_4,v_2)&amp;-6\\\\\\hline\r\n(v_2,v_3)&amp;1\\\\\\hline\r\n(v_1,v_4)&amp;3\\\\\\hline\r\n(v_3,v_4)&amp;5\\\\\\hline\r\n(v_5,v_4)&amp;10\\\\\\hline\r\n(v_3,v_5)&amp;-4\\\\\\hline\r\n(v_4,v_5)&amp;-8\\\\\\hline\r\n\\end{array}\\)\r\n最终运行Bellman-Ford算法后，发现了一个负环\\((v_1,v_4,v_2,v_3,v_5,v_1)\\)，其权值为\\(-1\\)。因此该差分约束无解。\r\n22.4-3\r\n不会。因为对于所有\\(v\\in\r\nV-\\{v_0\\}\\)，\\(E\\)中都有一条边\\((v_0,v)\\)，其权值为\\(0\\)。这说明从\\(v_0\\)到每个节点至少有一条长度为\\(0\\)的路径。随着Bellman-Ford算法对每一条边进行松弛，\\(v.d\\)的值只会递减。因此，在这个系统下不会有任何含有正数的解。\r\n22.4-4\r\n令\\(G=(V,E)\\)，那么\\(s\\)到\\(t\\)的最短路径问题表示成一个线性规划问题是：\r\n\\(\\begin{aligned}\r\n\\text{maximize}&amp;&amp; d_t\\\\\r\n\\text{subject to}&amp; \\\\\r\n&amp;&amp;d_v&amp;\\le d_u+w(u,v) &amp;&amp;\\forall (u,v)\\in E \\\\\r\n&amp;&amp;d_s&amp;=0\r\n\\end{aligned}\\)\r\n取最大值的原因是，\\(\\displaystyle{d_v=\\min_{(u,v)\\in\r\nE}\\{d_u+w(u,v)\\}}\\)，即\\(d_v\\)是小于等于\\(d_u+w(u,v)\\)中的最大值。\r\n22.4-5\r\n在Bellman-Ford的角度看来，边\\((v_0,v)\\)的权值为\\(0\\)是使所有节点\\(v\\in V-\\{v_0\\}\\)，\\(v.d\\le\r\n0\\)均成立。因此我们修改程序BELLMAN-FORD，使得其初始化时所有节点\\(u\\)为\\(u.d=0\\)即可。并且，这个算法是接受边权三元组输入，而不是邻接表输入。此时的时间复杂度将达到\\(O(nm)\\)。\r\n22.4-6\r\n如果满足\\(x_i=x_j+b_k\\)，那么也就是同时满足\\(x_i\\le x_j+b_k,x_i\\ge\r\nx_j+b_k\\)，进行变换后，得到两条不等式：\r\n\\(\\begin{aligned}\r\nx_i-x_j&amp;\\le b_k\\\\\r\nx_j-x_i&amp;\\le -b_k\r\n\\end{aligned}\\)\r\n将它们都添加到差分约束系统中即可。\r\n22.4-7\r\n这道题是22.4-5的实现，由过程DIFFERENCE-CONSTRAINTS-SOLVER给出，其时间复杂度为\\(O(nm)\\)。\r\nDIFFERENCE-CONSTRAINTS-SOLVER(G)  for each u in G.V    u.d = 0  for i = 1 to |G.V| - 1    for each edge (u, v, w) ∈ G.E      if u.d + w &lt; v.d        v.d = w + u.d  for each edge (u, v, w) ∈ G.E    if v.d &gt; u.d + w      return FALSE  return TRUE\r\n\\(\\star\\)\r\n22.4-8\r\n由于\\(\\forall v_i\\in\r\nV-\\{v_0\\}\\)，都有\\((v_0,v_i)\\in\r\nE,w(v_0,v_i)=0\\)，因此\\(x_i=\\delta(v_0,v_i)\\le w(v_0,v_i)=0\\)。\r\n对于任意一组解\\((y_1,y_2,\\dots,y_n)\\)，我们需要证明\\(y_i\\le x_i\\)均成立。 对于任意\\(v_i\\in V-\\{v_0\\}\\)，以及任意一条从\\(v_0\\)到\\(v_i\\)的一条最短路径\\(v_{j_1},u_{v_{j_2}},\\dots,v_{j_k}\\)，其中\\(j_1=0,j_k=i\\)，对于所有\\(t=2,3,\\dots,k\\)，都有\\(y_{j_{t+1}}-y_{j_t}\\le\r\nw(v_{j_{t+1}}-v_{j_t})\\)均成立。\r\n因此将这\\(k-1\\)条不等式左右分别相加，得到\\(\\displaystyle{y_i-y_0\\le\\sum_{t=2}^k\r\nw(v_{j_{t+1}}-v_{j_t})=\\delta(v_0,v_i)}=x_i\\)。\r\n也就是有\\(y_i-y_0\\le\r\nx_i\\)，由于\\(y_0=0\\)，因此\\(y_i\\le x_i\\)。也就是说，对于所有\\(y\\)，都有\\(\\displaystyle{\\sum_{i=1}^n y_i\\le\\sum_{i=1}^n\r\nx_i}\\)，因此原结论成立。\r\n\\(\\star\\)\r\n22.4-9\r\n此处假设这个差分约束系统中不存在无解的情况，也就是约束图不存在负环。\r\n由于Bellman-Ford算法在这个过程中求解的是最短路，因此随着整个松弛过程的进行，每个\\(x_i\\)都在减小。最终当\\(x_i=\\delta(v_0,v_i)\\)时，\\(x_i\\)将不再减小。所有\\(x_i\\)都将最小化，也就是\\(\\max\\{x_i\\}\\)最小化。\r\n在最小化\\(\\max\\{x_i\\}\\)的基础上，最小的\\(v_j.d\\)都应该最大化以确保从\\(v_0\\)到\\(v_j\\)的路径是一条真实的路径值。因此\\(\\min\\{x_i\\}\\)被最大化。\r\n在安排工程进度上，\\(\\max\\{x_i\\}-\\min\\{x_i\\}\\)相当于是最小化第一个工作开始到最后一个工作的这段时间。也就是通过合理安排这个工程内部的工作顺序，从而使得整个工程的时间最小化。\r\n22.4-10\r\n与当初的做法类似，考虑对约束图\\(G\\)添加额外原节点\\(v_0\\)，并且保证\\(x_0=\\delta(v_0,v_0)=0\\)成立。\r\n\r\n对于单个变量的约束条件\\(x_i\\le\r\nb_k\\)，可以改写成\\(x_i-x_0\\le\r\nb_k\\)，那么可以添加一条边\\((v_0,v_i)\\)到\\(E\\)中，并且权值\\(w(v_0,v_i)=b_k\\)。\r\n对于单个变量的约束条件\\(x_i\\ge\r\nb_k\\)，可以改写成\\(x_0-x_i\\le-b_k\\)，那么可以添加一条边\\((v_i,v_0)\\)到\\(E\\)中，并且权值\\(w(v_i,v_0)=-b_k\\)。\r\n\r\n接下来只需要对\\(G\\)以\\(v_0\\)为起点运行Bellman-Ford算法即可。如果\\(G\\)包含了负环，那么Bellman-Ford算法会报告这个约束系统无解。\r\n22.4-11\r\n对于所有\\(b_k\\)，令\\(b_k&#39;=\\lfloor\r\nb_k\\rfloor\\)，那么可以求解新的差分约束系统\\(x_i-x_j\\le\r\nb_k&#39;\\)即可。此时依照Bellman-Ford算法，求解出来的结果必定是整数。并且，由于\\(x_i-x_j\\le b_k&#39;\\le\r\nb_k\\)，因此这个约束实际上是比原约束条件更强，因此必定能求解出对应的结果。\r\n\\(\\star\\)\r\n22.4-12\r\n和题目22.4-11的区别在于只要求部分\\(x_i\\)必须是整数。因此为每个节点\\(v\\)添加一个布尔属性is-int来表示当前节点所求距离是否必须为整数。在松弛时，如果\\(v.d\\)是整数，那么使用值\\(v.d=\\lfloor\r\nu.d+w(u,v)\\rfloor\\)进行松弛，否则正常松弛即可，从而使结果仍然满足不等式的条件。整个算法由DIFFERENCE-CONSTRAINTS-SOLVER'给出，其时间复杂度和Bellman-Ford算法相同，为\\(O(n^2+mn)\\)。\r\nRELAX&#x27;&#x27;(u, v, w)  if v.is-int == True    if ⌊u.d + w(u, v)⌋ &lt; v.d      v.d = ⌊u.d + w(u, v)⌋  else    if u.d + w(u, v) &lt; v.d      v.d = w + u.d      DIFFERENCE-CONSTRAINTS-SOLVER&#x27;(G, w)  INITIALIZE-SINGLE-SOURCE(G, v0)  for i = 1 to |G.V| - 1    for each edge (u, v) ∈ G.E      RELAX&#x27;&#x27;(u, v, w)  for each edge (u, v) ∈ G.E    if v.d &gt; u.d + w(u, v)      return FALSE  return TRUE\r\n","categories":["算法导论"]},{"title":"算法导论22.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-22/exercises-3/","content":"\r\n22.3-1\r\n以\\(s\\)作为起点时的迭代过程如下：\r\n\\(\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\ns&amp;0&amp;\\text{NIL}\\\\\\hline\r\nt&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nx&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\ny&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nz&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\n\\end{array}\r\n\\underrightarrow{\\;\\;s\\;\\;}\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\ns&amp;0&amp;\\text{NIL}\\\\\\hline\r\nt&amp;3&amp;s\\\\\\hline\r\nx&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\ny&amp;5&amp;s\\\\\\hline\r\nz&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\n\\end{array}\r\n\\underrightarrow{\\;\\;t\\;\\;}\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\ns&amp;0&amp;\\text{NIL}\\\\\\hline\r\nt&amp;3&amp;s\\\\\\hline\r\nx&amp;9&amp;t\\\\\\hline\r\ny&amp;5&amp;s\\\\\\hline\r\nz&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\n\\end{array}\r\n\\underrightarrow{\\;\\;y\\;\\;}\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\ns&amp;0&amp;\\text{NIL}\\\\\\hline\r\nt&amp;3&amp;s\\\\\\hline\r\nx&amp;9&amp;t\\\\\\hline\r\ny&amp;5&amp;s\\\\\\hline\r\nz&amp;11&amp;y\\\\\\hline\r\n\\end{array}\r\n\\underrightarrow{\\;\\;x\\;\\;}\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\ns&amp;0&amp;\\text{NIL}\\\\\\hline\r\nt&amp;3&amp;s\\\\\\hline\r\nx&amp;9&amp;t\\\\\\hline\r\ny&amp;5&amp;s\\\\\\hline\r\nz&amp;11&amp;y\\\\\\hline\r\n\\end{array}\r\n\\underrightarrow{\\;\\;z\\;\\;}\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\ns&amp;0&amp;\\text{NIL}\\\\\\hline\r\nt&amp;3&amp;s\\\\\\hline\r\nx&amp;9&amp;t\\\\\\hline\r\ny&amp;5&amp;s\\\\\\hline\r\nz&amp;11&amp;y\\\\\\hline\r\n\\end{array}\\)\r\n以\\(z\\)作为起点时的迭代过程如下：\r\n\\(\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\ns&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nt&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nx&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\ny&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nz&amp;0&amp;\\text{NIL}\\\\\\hline\r\n\\end{array}\r\n\\underrightarrow{\\;\\;z\\;\\;}\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\ns&amp;3&amp;z\\\\\\hline\r\nt&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nx&amp;7&amp;z\\\\\\hline\r\ny&amp;\\infty&amp;\\text{NIL}\\\\\\hline\r\nz&amp;0&amp;\\text{NIL}\\\\\\hline\r\n\\end{array}\r\n\\underrightarrow{\\;\\;s\\;\\;}\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\ns&amp;3&amp;z\\\\\\hline\r\nt&amp;6&amp;s\\\\\\hline\r\nx&amp;7&amp;z\\\\\\hline\r\ny&amp;8&amp;s\\\\\\hline\r\nz&amp;0&amp;\\text{NIL}\\\\\\hline\r\n\\end{array}\r\n\\underrightarrow{\\;\\;t\\;\\;}\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\ns&amp;3&amp;z\\\\\\hline\r\nt&amp;6&amp;s\\\\\\hline\r\nx&amp;7&amp;z\\\\\\hline\r\ny&amp;8&amp;s\\\\\\hline\r\nz&amp;0&amp;\\text{NIL}\\\\\\hline\r\n\\end{array}\r\n\\underrightarrow{\\;\\;x\\;\\;}\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\ns&amp;3&amp;z\\\\\\hline\r\nt&amp;6&amp;s\\\\\\hline\r\nx&amp;7&amp;z\\\\\\hline\r\ny&amp;8&amp;s\\\\\\hline\r\nz&amp;0&amp;\\text{NIL}\\\\\\hline\r\n\\end{array}\r\n\\underrightarrow{\\;\\;y\\;\\;}\r\n\\begin{array}{|l|l|l|}\\hline\r\nv&amp;d&amp;\\pi\\\\\\hline\r\ns&amp;3&amp;z\\\\\\hline\r\nt&amp;6&amp;s\\\\\\hline\r\nx&amp;7&amp;z\\\\\\hline\r\ny&amp;8&amp;s\\\\\\hline\r\nz&amp;0&amp;\\text{NIL}\\\\\\hline\r\n\\end{array}\\)\r\n22.3-2\r\n令\\(G=(V,E),V=\\{a,b,c\\},E=\\{(a,b),(b,c),(a,c),(c,d)\\},w(a,c)=1,w(a,b)=2,w(b,c)=-3,w(c,d)=3\\)，如下图所示：\r\n\r\n由图可以知道\\(\\delta(a,d)=2\\)，但是从起点\\(a\\)运行Dijkstra算法后，得到的结果为\\(d.d=4\\)。这是因为\\(c\\)比\\(b\\)先弹出优先队列，并且此时对\\((c,d)\\)进行了松弛操作。当\\(c\\)的距离被更新成正确的距离\\(\\delta(a,c)=-1\\)后，节点\\(c\\)已经进入集合\\(S\\)，无法再更新后继节点。\r\n定理22.6证明不成立的原因是因为采用了所有边权为非负的假设，从而保证\\(\\delta(s,y)\\le \\delta(s,u)\\)，其中\\(s\\rightarrow y\\)是\\(s\\rightarrow u\\)的一条子路径。\r\n22.3-3\r\n这个做法是正确的。\r\n假设队列最后一个节点是\\(z\\)，那么在第\\(|V|-1\\)轮循环结束后，\\(\\forall v\\in V-\\{z\\}\\)，已经都有\\(v.d=\\delta(s,v)\\)，并且此时对于\\(\\forall (u,z)\\in\r\nE\\)，这些边都已经进行过一次松弛，因此根据收敛性质，有\\(z.d=\\delta(s,z)\\)。因此这个改动的操作是正确的。\r\n22.3-4\r\n修改之后的过程如DIJKSTRA'所示。使用一个属性mark表示阶段\\(u\\)是否曾经进入过优先队列。入队时机从初始化阶段改成了在松弛过程中通过mark标记进行入队。\r\nDIJKSTRA&#x27;(G, w, s)  INITIALIZE-SINGLE-SOURCE(G, s)  for each u ∈ G.V    u.mark = False  S = Ø  Q = Ø  s.mark = True  INSERT(Q, s)  while Q ≠ Ø    u = EXTRACT-MIN(Q)    S = S ∪ &#123;u&#125;    for each vertex v in G.Adj[u]      RELAX(u, v, w)      if u.mark == FALSE        u.mark = TRUE        INSERT(Q, s)      else if the call of RELAX decreased v.d        DECREASE-KEY(Q, v, v.d)\r\n22.3-5\r\n整个算法分三个步骤：\r\n\r\n判断\\(v.\\pi\\)是否构成了以\\(s\\)为根节点的一棵有根树。具体方法是对\\(v.\\pi,v\\)反向进行BFS，观察是否能到达所有节点。这个过程需要\\(O(V)\\)的时间。\r\n判断最短路径树中的所有树边是不是真实的树边，具体判断是对于所有非根节点\\(v\\)，判断\\(v.d=v.\\pi.d+w(v.\\pi,v)\\)是否成立。这个过程需要\\(O(V+E)\\)的时间。\r\n判断图\\(G\\)中是否还有边需要松弛。如果有，那么说明这棵树不是最短路径树。这个过程需要\\(O(V+E)\\)的时间。\r\n\r\n算法CHECK-DIJKSTRA-OUTPUT给出了一棵判断给定的\\(v.\\pi,v.d\\)是否合法的过程，其时间复杂度为\\(O(V+E)\\)。\r\nCHECK-DIJKSTRA-OUTPUT(G, w, s)  if s.π != NIL    return FALSE  Eπ = &#123;(v.π, v) | v ∈ G.V - &#123;s&#125;, v.π != NIL&#125;  Tπ = (G.V, Eπ)  BFS(Tπ, s)  for each u in G.V    if u.color != BLACK      return FALSE  for each (u, v) ∈ Eπ    if u.d + w(u, v) != v.d      return FALSE  for each (u, v) ∈ E    if u.d + w(u, v) &lt; v.d      return FALSE  return TRUE\r\n22.3-6\r\n令\\(G=(V,E),V=\\{a,b,c,d,e\\},E=\\{(a,b),(b,d),(a,c),(c,d),(d,e)\\},w(a,b)=w(b,d)=w(a,c)=w(c,d)=w(d,e)=0\\)，如下图所示：\r\n\r\n考虑计算\\(\\delta(a,e)\\)的值。可以发现从\\(a\\)到\\(e\\)有一条\\(a\\rightarrow b\\rightarrow d\\rightarrow\r\ne\\)的路径。那么按照这个证明过程的假设，\\((b,d)\\)一定先于\\((d,e)\\)松弛。然而实际上，当\\(c\\)比\\(b\\)先从\\(Q\\)出来，边\\((c,d)\\)的进行了一次松弛，此时\\(d.d=0\\)；如果\\(d\\)仍然先比\\(b\\)从优先队列出来，那么\\((d,e)\\)完成松弛；接下来\\(b\\)从\\(Q\\)中出来，对\\((b,d)\\)边进行松弛。在这个过程中，边\\((d,e)\\)先于边\\((b,d)\\)进行松弛，因此不能够用路径松弛性质证明Dijkstra算法的正确性。\r\n22.3-7\r\n如果一条通信路径\\(v_1,v_2,v_3,\\dots,v_k\\)是最可信的（其中\\(v_1=u,v_k=v\\)），那么相当于最大化如下值：\r\n\\[\\prod_{i=1}^{k-1}r(v_i,v_{i+1})\\]\r\n对其取对数后，也就是有最大化：\r\n\\[\\sum_{i=1}^{k-1}\\lg\r\nr(v_i,v_{i+1})\\]\r\n由于\\(r(i,j)\\in\r\n[0,1]\\)，因此我们需要去掉\\(r(i,j)=0\\)的边，防止不适用对数函数。那么此时\\(\\lg r(v_i,v_{i+1})\\)\r\n是一个负数。进一步，我们相当于最小化：\r\n\\[\\sum_{i=1}^{k-1}-\\lg\r\nr(v_i,v_{i+1})\\]\r\n由此可知，\\(-\\lg r(v_i,v_{i+1})\\ge\r\n0\\)恒成立。我们可以使用Dijkstra算法来求解这个问题。\r\n算法由程序RELIABLE-PATH给出。由于其主要过程为使用DIJKSTRA作为子程序，因此其时间复杂度为\\(O(E\\lg V)\\)。\r\nRELIABLE-PATH(G, r, s, t)  remove all edges (u, v) from G.E s.t. r(u, v) = 0  let weight function w(⋅, ⋅) = -lg r(⋅, ⋅)  DIJKSTRA(G, w, s)  PRINT-PATH(G, s, t)\r\n22.3-8\r\n图\\(G\\)中的每一条边\\(e\\)都被\\(w(e)\\)条新边所取代，因此每条边贡献了\\(w(e)-1\\)个节点。因此现在图\\(G&#39;\\)具有\\(\\displaystyle{|V|+\\sum_{e\\in E}\r\n(w(e)-1)=|V|+\\sum_{e\\in E} w(e)-|E|}\\)个节点。\r\n为了证明\\(V\\)在\\(G\\)中的Dijkstra算法的出队顺序与在\\(G&#39;\\)中BFS的出队相对顺序是一致的。我们考虑令\\(u,v\\in V\\)，并且在Dijkstra算法中，\\(u\\)先比\\(v\\)出队，因此有\\(u.d&lt;v.d\\)。那么在图\\(G&#39;\\)中，每一条在\\(E\\)中的边替换成了\\(w(u,v)\\)条连接中间对应节点的边。因此在图\\(G&#39;\\)中，访问到\\(u\\)需要\\(u.d\\)步，访问到\\(v\\)需要\\(v.d\\)步，因此在\\(G&#39;\\)中，\\(v\\)后于\\(u\\)被访问。\r\n22.3-9\r\n由于一条边的最大长度为\\((|V|-1)W\\)，因此我们可以考虑建立\\((|V|-1)W+2\\)个槽，其中第\\(i\\)个槽防止满足\\(v.d=i\\)的节点\\(v\\)，最后一个槽用于放置满足\\(u.d=\\infty\\)的节点。假设从一个槽插入和删除节点的时间复杂度均为\\(O(1)\\)，它们通过一个双向链表维护。\r\n随着松弛过程的进行，所有节点只会从后往前进行移动。此外，由于优先队列的出队顺序\\(u\\)满足\\(u.d\\)是单调不下降的，因此只需要从小到大遍历每个槽即可。这个算法由程序DIJKSTRA'给出，其时间复杂度为\\(O((V-1)W+E)=O(VW+E)\\)。\r\nDIJKSTRA&#x27;&#x27;(G, W, w, s)  INF = (|G.V| - 1) * W + 1  let A[0 : INF] be new array by list  for each vertex u ∈ G.V - &#123;s&#125;    u.d = INF    u.π = NIL    LIST-INSERT&#x27;(A[INF], u)  s.d = 0  s.π = NIL  LIST-INSERT&#x27;(A[0], s)  S = Ø  k = 0  for n = 1 to |V|    while A[k] == NIL      k = k + 1    u = A[k].head    LIST-DELETE&#x27;(A[k], u)    S = S ∪ &#123;u&#125;    for each vertex v in G.Adj[u]      if v.d &gt; u.d + w(u, v)        LIST-DELETE&#x27;(A[v.d], v)        v.π = u        v.d = u.d + w(u, v)        LIST-INSERT&#x27;(A[v.d], v)\r\n22.3-10\r\n可以知道，当\\(u\\)从优先队列\\(Q\\)弹出来后，并且插入集合\\(S\\)中。因此，\\(\\forall x\\in S,x.d\\le\r\nu.d\\)均成立。对于\\(v\\in\r\nV-S\\)，如果\\(v\\)被\\(S\\)中的节点松驰过，那么有\\(v.d\\le x.d+w(x,v)\\le\r\nu.d+W\\)；如果没有被松驰过，那么\\(v.d=\\infty\\)。因此，当\\(u\\)出队时，优先队列中的不同\\(d\\)值取值范围为\\([u.d,u.d+W]\\cup\\{\\infty\\}\\)，一共有\\(W+2\\)个不同取值。\r\n最终，从题目22.3-9而来，可以考虑使用一棵平衡二叉树来维护这些非空链表：如果槽\\(d\\)中的链表是非空的，那么这棵二叉树应该含有键值为\\(d\\)对应的链表；否则不包含，更新后若链表为空则删除节点。最终，无论是一次LIST-INSERT'操作还是一次LIST-DELETE'操作，都需要先花费\\(O(\\lg\r\nW)\\)的时间查找到其所在的链表，然后再对这个链表以\\(O(1)\\)的时间进行处理。由于这些操作一共有\\(|V|+2|E|\\)次，因此整个算法需要\\(O((V+E)\\lg W)\\)的时间复杂度。\r\n22.3-11\r\n原版的证明关键在于，由于\\(E\\)中所有路径都是非负权，因此\\(w(y,u)\\ge 0\\)，从而得出\\(\\delta(s,y)\\le\r\n\\delta(s,u)\\)。由于已经假设了\\(|S|\\ge\r\n2,y\\not\\in S\\)，因此\\(y\\ne\r\ns\\)必定成立。也就是说，对于\\(\\forall\r\n(s,u)\\in E\\)，这个证明没有对\\((s,u)\\)的权值做出限制，因此定理22.6的证明也适用于这里的证明。\r\n22.3-12\r\n为了排除常数\\(C\\)的影响，我们构造新的边权函数\\(w&#39;(\\cdot.\\cdot)=\\dfrac{w(\\cdot,\\cdot)}{C}\\)。根据题目可知，\\(w&#39;(\\cdot,\\cdot)\\in\r\n[1,2]\\)。那么在求出最短路之后，将全部路径值乘回\\(C\\)即可。\r\n我们考虑开设\\(2(|V|-1)+2\\)个桶，除了最后一个桶放置\\(u.d=\\infty\\)的节点，第\\(i\\)个桶放置满足\\(u.d\\in[i,i+1)\\)的节点。在这种情况下，如果目前正在访问节点\\(u\\)，边\\((u,v)\\)进行了一次松弛，那么\\(v\\)所在的桶必定不在\\(u\\)所在的桶中（因为权值\\(w&#39;(u,v)\\ge 1\\)）；类似的，如果\\(v\\)在\\(u\\)的桶内，那么松弛操作必定不成功。因此，当桶内的节点\\(u\\)被弹出时，它必定能保证\\(u.d=\\delta(s,u)\\)。\r\n由于最短路径长度最大能达到\\(2(|V|-1)\\)，因此我们需要开设\\(2|V|\\)个桶来存放这些节点。遍历每个桶的时间为\\(O(V)\\)，遍历每条边的时间为\\(O(V+E)\\)，因此整个算法的时间复杂度为\\(O(V+E)\\)。具体过程由DIJKSTRA-C给出。\r\nDIJKSTRA-C(G, w, C, s)  INF = (|G.V| - 1) * 2 + 1    let A[0 : INF] be new array by list  for each vertex u ∈ G.V – &#123;s&#125;    u.color = WHITE    u.d = INF    u.π = NIL    LIST-INSERT&#x27;(A[INF], u)  // 由此，所有边的边权都在范围[1, 2]中，以方便接下来的处理。  let weight function w&#x27;(⋅, ⋅) = w(⋅, ⋅) / C  s.color = GRAY  s.d = 0  s.π = NIL  Q = Ø  ENQUEUE(Q, s)  LIST-INSERT&#x27;(A[0], s)  S = Ø  k = 0  for n = 1 to |V|    while A[k] == NIL      k = k + 1    u = A[k].head    LIST-DELETE&#x27;(A[k], u)    S = S ∪ &#123;u&#125;    for each vertex v in G.Adj[u]      if v.d &gt; u.d + w(u, v)        LIST-DELETE&#x27;(A[ ⌊v.d⌋ ], v)        v.π = u        v.d = u.d + w(u, v)        LIST-DELETE&#x27;(A[ ⌊v.d⌋ ], v)  for each vertex u ∈ G.V – &#123;s&#125;    u.d = u.d * C\r\n","categories":["算法导论"]},{"title":"算法导论23.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-23/exercises-1/","content":"\r\n23.1-1\r\n运行SLOW-APSP的每步迭代结果：\r\n\\(\\begin{aligned}\r\n&amp;\\begin{pmatrix}\r\n0&amp;\\infty&amp;\\infty&amp;\\infty&amp;-1&amp;\\infty\\\\\r\n1&amp;0&amp;\\infty&amp;2&amp;\\infty&amp;\\infty\\\\\r\n\\infty&amp;2&amp;0&amp;\\infty&amp;\\infty&amp;-8\\\\\r\n-4&amp;\\infty&amp;\\infty&amp;0&amp;3&amp;\\infty\\\\\r\n\\infty&amp;7&amp;\\infty&amp;\\infty&amp;0&amp;\\infty\\\\\r\n\\infty&amp;5&amp;10&amp;\\infty&amp;\\infty&amp;0\r\n\\end{pmatrix}\r\n\\underrightarrow{m=2}\r\n\\begin{pmatrix}\r\n0&amp;6&amp;\\infty&amp;\\infty&amp;-1&amp;\\infty\\\\\r\n-2&amp;0&amp;\\infty&amp;2&amp;0&amp;\\infty\\\\\r\n3&amp;-3&amp;0&amp;4&amp;\\infty&amp;-8\\\\\r\n-4&amp;10&amp;\\infty&amp;0&amp;-5&amp;\\infty\\\\\r\n8&amp;7&amp;\\infty&amp;9&amp;0&amp;\\infty\\\\\r\n6&amp;5&amp;10&amp;7&amp;\\infty&amp;0\r\n\\end{pmatrix}\r\n\\underrightarrow{m=3}\r\n\\begin{pmatrix}\r\n0&amp;6&amp;\\infty&amp;8&amp;-1&amp;\\infty\\\\\r\n-2&amp;0&amp;\\infty&amp;2&amp;-3&amp;\\infty\\\\\r\n-2&amp;-3&amp;0&amp;-1&amp;2&amp;-8\\\\\r\n-4&amp;2&amp;\\infty&amp;0&amp;-5&amp;\\infty\\\\\r\n5&amp;7&amp;\\infty&amp;9&amp;0&amp;\\infty\\\\\r\n3&amp;5&amp;10&amp;7&amp;5&amp;0\r\n\\end{pmatrix}\\\\\r\n\\underrightarrow{m=4}\r\n&amp;\\begin{pmatrix}\r\n0&amp;6&amp;\\infty&amp;8&amp;-1&amp;\\infty\\\\\r\n-2&amp;0&amp;\\infty&amp;2&amp;-3&amp;\\infty\\\\\r\n-2&amp;-3&amp;0&amp;-1&amp;2&amp;-8\\\\\r\n-4&amp;2&amp;\\infty&amp;0&amp;-5&amp;\\infty\\\\\r\n5&amp;7&amp;\\infty&amp;9&amp;0&amp;\\infty\\\\\r\n3&amp;5&amp;10&amp;7&amp;5&amp;0\r\n\\end{pmatrix}\r\n\\underrightarrow{m=5}\r\n\\begin{pmatrix}\r\n0&amp;6&amp;\\infty&amp;8&amp;-1&amp;\\infty\\\\\r\n-2&amp;0&amp;\\infty&amp;2&amp;-3&amp;\\infty\\\\\r\n-5&amp;-3&amp;0&amp;-1&amp;-6&amp;-8\\\\\r\n-4&amp;2&amp;\\infty&amp;0&amp;-5&amp;\\infty\\\\\r\n5&amp;7&amp;\\infty&amp;9&amp;0&amp;\\infty\\\\\r\n3&amp;5&amp;10&amp;7&amp;2&amp;0\r\n\\end{pmatrix}\\\\\r\n\\end{aligned}\\)\r\n运行FAST-APSP的每步迭代结果：\r\n\\(\\begin{aligned}\r\n&amp;\\begin{pmatrix}\r\n0&amp;\\infty&amp;\\infty&amp;\\infty&amp;-1&amp;\\infty\\\\\r\n1&amp;0&amp;\\infty&amp;2&amp;\\infty&amp;\\infty\\\\\r\n\\infty&amp;2&amp;0&amp;\\infty&amp;\\infty&amp;-8\\\\\r\n-4&amp;\\infty&amp;\\infty&amp;0&amp;3&amp;\\infty\\\\\r\n\\infty&amp;7&amp;\\infty&amp;\\infty&amp;0&amp;\\infty\\\\\r\n\\infty&amp;5&amp;10&amp;\\infty&amp;\\infty&amp;0\r\n\\end{pmatrix}\r\n\\underrightarrow{m=2}\r\n\\begin{pmatrix}\r\n0&amp;6&amp;\\infty&amp;\\infty&amp;-1&amp;\\infty\\\\\r\n-2&amp;0&amp;\\infty&amp;2&amp;0&amp;\\infty\\\\\r\n3&amp;-3&amp;0&amp;4&amp;\\infty&amp;-8\\\\\r\n-4&amp;10&amp;\\infty&amp;0&amp;-5&amp;\\infty\\\\\r\n8&amp;7&amp;\\infty&amp;9&amp;0&amp;\\infty\\\\\r\n6&amp;5&amp;10&amp;7&amp;\\infty&amp;0\r\n\\end{pmatrix}\r\n\\underrightarrow{m=4}\r\n\\begin{pmatrix}\r\n0&amp;6&amp;\\infty&amp;8&amp;-1&amp;\\infty\\\\\r\n-2&amp;0&amp;\\infty&amp;2&amp;-3&amp;\\infty\\\\\r\n-2&amp;-3&amp;0&amp;-1&amp;2&amp;-8\\\\\r\n-4&amp;2&amp;\\infty&amp;0&amp;-5&amp;\\infty\\\\\r\n5&amp;7&amp;\\infty&amp;9&amp;0&amp;\\infty\\\\\r\n3&amp;5&amp;10&amp;7&amp;5&amp;0\r\n\\end{pmatrix}\\\\\r\n\\underrightarrow{m=8}\r\n&amp;\\begin{pmatrix}\r\n0&amp;6&amp;\\infty&amp;8&amp;-1&amp;\\infty\\\\\r\n-2&amp;0&amp;\\infty&amp;2&amp;-3&amp;\\infty\\\\\r\n-5&amp;-3&amp;0&amp;-1&amp;-6&amp;-8\\\\\r\n-4&amp;2&amp;\\infty&amp;0&amp;-5&amp;\\infty\\\\\r\n5&amp;7&amp;\\infty&amp;9&amp;0&amp;\\infty\\\\\r\n3&amp;5&amp;10&amp;7&amp;2&amp;0\r\n\\end{pmatrix}\\\\\r\n\\end{aligned}\\)\r\n23.1-2\r\n因为这采用了如下事实：从节点\\(i\\)回到自身的最短路径是一条空路径（没有负环的情况下），因此\\(w_{ii}=0\\)。\r\n如果不使用\\(w_{ii}=0\\)，那么\\(l_{ij}^{(r)}\\)求的是从\\(i\\)到\\(j\\)恰好包含\\(r\\)条边的最短路径。那么到最后，还需要求解\\(\\displaystyle{\\delta(i,j)=\\min_{k=1}^n\\{l_{ij}^{(k)}\\}}\\)，这将增加多余的代码量。\r\n23.1-3\r\n由于任何矩阵\\(A\\)和矩阵\\(L^{(0)}\\)“相乘”所得到的矩阵为\\(A\\)，因此\\(L^{(0)}\\)相当于是普通矩阵乘法中的单位矩阵。\r\n23.1-4\r\n不是一般性，考虑\\(n\\)阶级矩阵\\(W^a,W^b,W^c\\)，那么我们相当于证明\\((W^a\\cdot W^b)\\cdot W^c=W^a\\cdot(W^b\\cdot\r\nW^c)\\)。\r\n考虑\\((W^a\\cdot W^b)\\cdot\r\nW^c\\)的第\\(x\\)行第\\(y\\)列的值\\(w_{xy}\\)以及\\(W^a\\cdot(W^b\\cdot W^c)\\)的第\\(x\\)行第\\(y\\)列的值\\(w_{xy}&#39;\\)，那么有\r\n\\(\\begin{aligned}\r\nw_{xy}&amp;=\\min_{j=1}^n\\{\\min_{i=1}^n\\{w_{xi}^a,w_{ij}^b\\},w_{jy}^c\\}\\\\\r\n&amp;=\\min_{j=1}^n\\min_{i=1}^n\\{w_{xi}^a,w_{ij}^b,w_{jy}^c\\}\\\\\r\n&amp;=\\min_{i=1}^n\\{w_{xi}^a,\\min_{j=1}^n\\{w_{ij}^b,w_{jy}^c\\}\\}\\\\\r\n&amp;=w_{xy}&#39;\r\n\\end{aligned}\\)\r\n因此，这个矩阵运算的结合律成立，也就是有\\((W^a\\cdot W^b)\\cdot W^c=W^a\\cdot(W^b\\cdot\r\nW^c)\\)。\r\n23.1-5\r\n假设现在是求以原点为\\(s\\)的单源最短路。令\\(v^0\\)表示一个长度为\\(n\\)的行向量，其中\\(v^0_s=0\\)，并且对于\\(\\forall i\\neq s,v_i^0=\\infty\\)。\r\n那么，对于向量\\(v^i\\)，有\\(v^i=v^{i-1}W\\)。那么我们只需要花费\\(O(n^3)\\)的时间就可以计算出\\(v^{n-1}=v^0\\cdot W^{n-1}\\)。最终，向量\\(v^{n-1}\\)就代表从原点\\(s\\)到各点的最短距离值。\r\n在计算\\(v^{i}=v^{i-1}W\\)的过程就相当于是Bellman-Ford算法中的每一步迭代，\\(W\\)中的每一个元素\\(w_{i,j}\\)进行了一次乘法运算后，相当于在Bellman-Ford算法中边\\((i,j)\\)进行了一次松弛。\r\n23.1-6\r\n对子程序EXTEND-SHORTEST-PATHS和SLOW-APSP改写后的结果如下。事实上，这种更新方式是正确的，因为这相当于是Bellman-Ford算法进行松弛的过程：如果\\(v.d&gt;u.d+w(u,v)\\)，那么将\\(u.d+w(u,v)\\)原地赋值给\\(c.d\\)。只是在这里可以视为相当于对每个节点执行了总共\\(n\\)次的Bellman-Ford算法，这里的\\(l_{\\cdot\r\nu}\\)就相当于Bellman-Ford算法的\\(u.d\\)。因此，从前往后进行了\\(n-1\\)次松弛，这个改动是没错的。\r\nEXTEND-SHORTEST-PATHS&#x27;(L, W, n)  for i = 1 to n    for j = 1 to n      for k = 1 to n        l_&#123;ij&#125; = min&#123;l_&#123;ij&#125;, l_&#123;ik&#125; + w_&#123;kj&#125;&#125;SLOW-APSP&#x27;(W, L(0), n)  let L=(l_&#123;ij&#125;) and M = (m_&#123;ij&#125;) be new n × n matrices  L = L(0)  for r = 1 to n - 1    EXTEND-SHORTEST-PATHS&#x27;(L, W, n)  return L\r\n然而，FAST-APSP不能省略\\(M\\)，因为计算\\(M=L^2\\)时需要保证\\(L\\)和\\(L\\)（左边的和右边的\\(L\\)）都是正确的。\r\n23.1-7\r\n直接暴力枚举所有节点\\(i\\)，然后以\\(i\\)为原点进行BFS。具体做法是，对于图\\(G_s=(V,E_s)\\)，如果\\(l_{sv}=l_{su}+w_{uv}\\)，那么\\((u,v)\\in E_i\\)，那么从节点\\(i\\)开始进行BFS，遍历所有节点最终得到的\\(j.\\pi\\)值填入\\(\\pi_{ij}\\)即可。由于使用的是邻接矩阵，因此进行一次BFS的时间复杂度为\\(O(n^2)\\)，总共需要花费\\(O(n^3)\\)的时间才能构建出前驱矩阵\\(\\Pi\\)。整个过程由CONSTRUCT-PI给出。\r\n//假设子程序BFS-MAT(G, s)用于对图G进行BFS，且其原点为s。这里输入的G是以邻接矩阵来存储。CONSTRUCT-PI(L, W, n)  let Π be new n × n matrix  V = &#123;1, 2, 3, ..., n&#125;  for s = 1 to n    E = ∅    for u = 1 to n      for v = 1 to n        if l_&#123;sv&#125; == l_&#123;su&#125; + w_&#123;uv&#125;        E = E ∪ &#123;(u, v)&#125;    BFS-MAT((V, E))    for v = 1 to n      π_&#123;sv&#125; = v.π  return Π\r\n23.1-8\r\n将\\(\\Pi\\)中的每一行视为是一个独立的Bellman-Ford算法正在进行松弛操作，并且沿用\\(\\Pi^{(i-1)}\\)的值来构造出\\(\\Pi^{(i)}\\)。需要注意的是，\\(\\Pi^{(0)}\\)的值为全空。具体的过程如下给出，可以发现，SLOW-APSP'''的时间复杂度同样为\\(\\Theta(n^4)\\)。\r\nEXTEND-SHORTEST-PATHS&#x27;&#x27;&#x27;(L, Π, W, n)  let L&#x27; be new n × n matrix by ∞  Π&#x27; = Π  for i = 1 to n    for j = 1 to n      for k = 1 to n        if l&#x27;_&#123;ij&#125; &gt; l_&#123;ik&#125; + w_&#123;kj&#125;          l&#x27;_&#123;ij&#125; = l_&#123;ik&#125; + w_&#123;kj&#125;          π&#x27;_&#123;ij&#125; = k  return L&#x27;, Π&#x27;SLOW-APSP&#x27;&#x27;&#x27;(W, L(0), n)  let Π be new n × n matrix by NIL  L = L(0)  for r = 1 to n - 1    L, Π = EXTEND-SHORTEST-PATHS&#x27;&#x27;(L, Π, W, n)  return L, Π\r\n23.1-9\r\n在整个循环结束后，再进行一次迭代，从而得到\\(M=W^{2m},L=W^m,m\\ge n-1\\)。如果\\(M\\)和\\(L\\)不相同，那么说明存在一条长度超过\\(n-1\\)的最短路，因此这个图有负环。\r\n整个算法由程序FASTER-APSP'给出，其时间复杂度为\\(\\Theta(n^3\\lg\r\nn)\\)，相比起FASTER-APSP，仅仅是多运行了一次程序EXTEND-SHORTEST-PATHS。\r\nFASTER-APSP&#x27;(W, n)  let L and M be new n × n matrices  L = W  r = 1  while r &lt; n - 1    M = ∞  // initialize M    EXTEND-SHORTEST-PATHS(L, L, M, n) // compute M = L^2    r = 2r    L = M // ready for the next iteration  M = ∞  EXTEND-SHORTEST-PATHS(L, L, M, n)  for i = 1 to n    for j = 1 to n      if l_&#123;ij&#125; != m_&#123;ij&#125;        return False  return True\r\n23.1-10\r\n最基本的想法很简单：只要找到最小的\\(m\\)，\\(\\exists\r\ni,l_{ii}^{(m)}&lt;0\\)即可。也就是说从\\(i\\)到\\(i\\)已经存在一条负数边权的路径。\r\n其中一种最简单的做法是，从小到大枚举\\(m\\)值，计算出\\(L^{(m)}\\)后直接判断即可。这个过程由MINIMUM-NEG-CYCLE给出，可以看出这个算法是基于SLOW-APSP的，其时间复杂度为\\(O(n^4)\\)。\r\nMINIMUM-NEG-CYCLE(W, L(0), n)  let L=(l_&#123;ij&#125;) and M = (m_&#123;ij&#125;) be new n × n matrices  L = L(0)  // 最短的负环长度可能达到n，需要注意。  for r = 1 to n    M = ∞    EXTEND-SHORTEST-PATHS&#x27;(L, W, n)    L = m    for i = 1 to n      if l_&#123;ii&#125; &lt; 0        return r  // 不存在负环。  return -1\r\n另外一种做法则是基于FASTER-APSP的，使用倍增法进行实现。每次将当前矩阵\\(L\\)尝试乘上一个\\(L^{(m)}\\)，得到新矩阵\\(L&#39;\\)。如果仍未检测出负环，那么用\\(L&#39;\\)代替\\(L\\)，并将\\(m\\)翻倍，否则将\\(m\\)进行减半。\r\n在这种情况下，EXTEND-SHORTEST-PATHS将只会被调用\\(O(\\lg\r\nn)\\)次，因此整个程序的时间复杂度为\\(O(n^3\\lg\r\nn)\\)。完整过程由MINIMUM-NEG-CYCLE'给出。\r\nMINIMUM-NEG-CYCLE&#x27;(W, n)  L = L(1) = W  m = 1  k = 1  while k &lt; n or m &gt; 0    M = ∞    if k + m &gt; n      m = ⌊m / 2⌋    else      if L(m) == NIL        L(m) = ∞        EXTEND-SHORTEST-PATHS(L(m/2), L(m/2), L(m), n)      EXTEND-SHORTEST-PATHS(L, L(m), M, n)      have-neg-cycle = False      for i = 1 to n        if m_&#123;ii&#125; &lt; 0          have-neg-cycle = True      if have-neg-cycle == True        m = ⌊m / 2⌋      else        L = M        k = k + m        m = m * 2  if k &lt; n    // 找到了负环。    return k + 1  else    // 没有找到负环。    return -1\r\n","categories":["算法导论"]},{"title":"算法导论22 Problems 答案","url":"/introduction-to-algorithms/chapter-22/problems/","content":"\r\n22-1\r\na\r\n在\\(E_f\\)中，所有的边都是从标号小的边指向标号大的边，因此构造出无法一个序列\\(a_1,a_2,\\dots a_k\\)，使得\\(a_1&lt;a_2,a_2&lt;a_3,\\dots,a_{k-1}&lt;a_k,a_k&lt;a_1\\)成立，从而使得\\(\\forall i&lt;k (v_{a_i},v_{a_{i+1}})\\in E_f\\land\r\n(v_{a_k},v_{a_1})\\in E_f\\)。因此\\(E_f\\)是无环的。由于\\(\\forall (v_i,v_j)\\in\r\nE_f,i&lt;j\\)均成立，因此\\(\\langle\r\nv_1,v_2,\\dots,v_{|V|}\\rangle\\)是\\(G_f\\)的一个拓扑序列。\r\n类似的，\\(E_b\\)中的所有边都是从标号大的指向标号小的，因此\\(E_b\\)是无环的。由于\\(\\forall (v_i,v_j)\\in\r\nE_b,i&gt;j\\)均成立，因此\\(\\langle\r\nv_{|V|},v_{|V|-1},\\dots,v_{1}\\rangle\\)是\\(G_f\\)的一个拓扑序列。\r\nb\r\n不失一般性，目前需要计算从\\(v_s\\)到\\(v_t\\)的最短路，假设这条最短路为\\(v_{b_1},v_{b_2},v_{b_3}\\dots,v_{b_k},b_1=s,b_k=t\\)。按照路径松弛性质，只有将边穿插着按照顺序\\((v_{b_1},v_{b_2}),(v_{b_2},v_{b_3}),\\dots,(v_{b_{k-1}},v_{b_k})\\)进行松弛，才能得到\\(v_t.d=\\delta(v_s,v_t)\\)。\r\n考虑序列\\(b_1,b_2,b_3,\\dots,b_k\\)的起伏顺序。可以知道序列\\(b\\)的元素两两不同（因为最短路径是一条最短路径）。对于某个\\(b_j\\)，如果\\(b_{j}&lt;b_{j+1}&lt;\\dots&lt;b_{j+k}\\)，那么中间这\\(k\\)条边可以在这一半轮迭代中完成松弛。接下来，如果\\(b_{j+k}&gt;b_{j+k+1}&gt;\\dots&gt;b_{j+k+m}\\)，那么这\\(m\\)条边在另一半轮中可以完成松弛。\r\n也就是说，在一轮迭代中，至少可以对\\(2\\)条边进行松弛（如果\\(b_1&gt;b_2&lt;\r\nb_3\\)，那么第一轮迭代只能松弛\\((v_{b_1},v_{b_2})\\)这条边）。因此，至少需要\\(\\lceil|V|/2\\rceil\\)轮迭代才能保证边\\((v_{b_1},v_{b_2}),(v_{b_2},v_{b_3}),\\dots,(v_{b_{k-1}},v_{b_k})\\)按顺序被松弛完（为达到恰好\\(\\lceil\r\nN/2\\rceil\\)轮按顺序完成路径所有边的松弛，假设\\(|V|\\)是奇数，\\(b_1&gt;b_2&lt;b_3,k=|V|\\)）。\r\nc\r\n上述算法只需要进行\\(\\lceil|V|/2\\rceil\\)遍的松弛操作，每一遍都需要遍历\\(G\\)中的所有边\\(E\\)，整个算法的渐进时间复杂度仍然为\\(O(V^2+VE)\\)，因此它没有对Bellman-Ford算法的渐进运行时间改善，只是将常数减少到了原来的\\(\\dfrac{1}{2}\\)。\r\n22-2\r\na\r\n令\\(x,y,z\\)是\\(3\\)个不同的盒子。\r\n根据定义，如果\\(x\\)能够放在\\(y\\)中，并且\\(y\\)能够放在\\(z\\)中，那么存在置换\\(\\pi,\\tau\\)使得\\(x_{\\pi(1)}&lt; y_1,x_{\\pi(2)}&lt;\r\ny_2,\\dots,x_{\\pi(d)}&lt; y_d\\)和\\(y_{\\tau(1)}&lt; z_1,y_{\\tau(2)}&lt;\r\nz_2,\\dots,y_{\\tau(d)}&lt; z_d\\)。那么可以知道\\(x_{\\pi(\\tau(1))}&lt; z_1,x_{\\pi(\\tau(2))}&lt;\r\nz_2,\\dots,x_{\\pi(\\tau(d))}&lt; z_d\\)。排列\\(\\pi(\\tau(\\cdot))\\)说明\\(x\\)能够放在\\(z\\)中，因此传递关系成立。\r\nb\r\n只需要将数组\\(x\\)和\\(y\\)进行排序，然后对应下标直接进行比较即可。这种比较方式是正确的，对于\\(y\\)中最小的元素，应该将\\(x\\)中最小的元素分配给它进行比较，否则不是最优。程序由IS-INSIDE给出，其时间复杂度为\\(O(d\\lg d)\\)、\r\nIS-INSIDE(x, y, d)  RANDOMIZED-QUICKSORT(x, 1, d)  RANDOMIZED-QUICKSORT(y, 1, d)  for i = 1 to d    if x[i] &gt;= y[i]      return False  return True\r\nc\r\n令\\(G=(V,E),V=\\{B_1,B_2,\\dots,B_n\\},(B_i,B_j)\\in\r\nE\\)当且仅当\\(B_i\\)能装在\\(B_j\\)中。\r\n那么这个问题就成为了找一条\\(G\\)中的最长路径。首先花费\\(O(nd\\lg d)\\)的时间对\\(B\\)中的每个盒子的每个维度进行排序；接下来花费\\(O(n^2d)\\)的时间判断每一对盒子之间的嵌套关系，从而构建出图\\(G\\)；接下来使用题目22.2-3的内容，把一个盒子视为一个节点上的任务，并且花费为\\(1\\)，那么花费\\(O(E)=O(n^2)\\)的时间调用子程序DAG-LONGEST-PATHS'求出一条最长路径。因此整个算法的时间复杂度为\\(O(nd(n+\\lg d))\\)。\r\nLONGEST-SEQUENCE(B, n, d)  for i = 1 to n    RANDOMIZED-QUICKSORT(B[i], 1, d)  V = &#123;B1, B2, ..., Bn&#125;  E = ∅  for i = 1 to n    for j = 1 to n      if IS-INSIDE(B[i], B[j])        E = E ∪ &#123;(Bi, Bj)&#125;  G = (V, E)  let T, path be new arrays  for each u in V    T[u] = 1  DAG-LONGEST-PATHS&#x27;(G, T)  let Bj be the vertex s.t. Bj.d is maximum  p = Bj  while p.d != 0    INSERT(path, p)    p = p.π  // 进行逆序后才能得到这条路径。  REVERSE(path)  return path\r\n22-3\r\na\r\n对不等式两侧取对数\\(\\lg\\)，得到：\r\n\\(\\lg R[i_1,i_2]+\\lg R[i_2,i_3]+\\dots +\\lg\r\nR[i_{k-1},i_k]+\\lg R[i_k,i_1]&gt;0\\)\r\n那么再对两端取符号，得到：\r\n\\((-\\lg R[i_1,i_2])+(-\\lg R[i_2,i_3])+\\dots\r\n+(-\\lg R[i_{k-1},i_k])+(-\\lg R[i_k,i_1])&lt;0\\)\r\n我们构造图\\(G=(V,E),V=\\{c_1,c_2,\\dots,c_n\\},\\forall u,v \\in\r\nV,(c_i,c_j)\\in E,w(c_i,c_j)=-\\lg\r\nR[i,j]\\).我们通过将Bellman-Ford算法作为子程序即可完成判断这个子序列的存在，整个过程由CURRENCY-CYCLE-PROFIT给出，其时间复杂度依赖于Bellman-Ford算法的实现，为\\(O(V^2+VE)=O(V^3)\\)。\r\n注意到\\(G\\)是一个完全图，因此随机选择一个起点\\(s\\)即可。\r\nCURRENCY-CYCLE-PROFIT(R, n)  let vertex set V = &#123;1, 2, ..., n&#125;  let edge set E = &#123;(1, 2), (1, 3), ..., (n, n - 2), (n, n - 1)&#125;  let weight function w(⋅, ⋅) = -lg R[⋅, ⋅]  select s ∈ V randomly  return not BELLMAN-FORD((V, E), w, s)\r\nb\r\n这道题和题目22.1-8基本相同，依旧其构造出的GET-NEG-CYCLE作为子程序即可。其时间复杂度为\\(O(V^2+VE)=O(V^3)\\)。\r\nCURRENCY-NEG-CYCLE(R, n)  let vertex set V = &#123;1, 2, ..., n&#125;  let edge set E = &#123;(1, 2), (1, 3), ..., (n, n - 2), (n, n - 1)&#125;  let weight function w(⋅, ⋅) = -lg R[⋅, ⋅]  select s ∈ V randomly  return GET-NEG-CYCLE(G, w, s)\r\n22-4\r\na\r\n本题思路和题目22.3-9完全一致。由于路径最大长度为\\(|E|\\)，因此我们可以考虑建立\\(|E|+2\\)个槽，其中第\\(i\\)个槽防止满足\\(v.d=i\\)的节点\\(v\\)，最后一个槽用于放置满足\\(u.d=\\infty\\)的节点。假设从一个槽插入和删除节点的时间复杂度均为\\(O(1)\\)，它们通过一个双向链表维护。\r\n随着松弛过程的进行，所有节点只会从后往前进行移动。此外，由于优先队列的出队顺序\\(u\\)满足\\(u.d\\)是单调不下降的，因此只需要从小到大遍历每个槽即可。这个算法由程序DIJKSTRA''''给出，其时间复杂度为\\(O(E+E)=O(E)\\)。\r\nDIJKSTRA-E(G, w, s)  INF = |G.E| + 1  let A[0 : INF] be new array by list  for each vertex u ∈ G.V - &#123;s&#125;    u.d = INF    u.π = NIL    LIST-INSERT&#x27;(A[INF], u)  s.d = 0  s.π = NIL  LIST-INSERT&#x27;(A[0], s)  S = Ø  k = 0  for n = 1 to |V|    while A[k] == NIL      k = k + 1    u = A[k].head    LIST-DELETE&#x27;(A[k], u)    S = S ∪ &#123;u&#125;    for each vertex v in G.Adj[u]      if v.d &gt; u.d + w(u, v)        LIST-DELETE&#x27;(A[v.d], v)        v.π = u        v.d = u.d + w(u, v)        LIST-INSERT&#x27;(A[v.d], v)\r\nb\r\n本题可以直接使用题目22.3-9的代码作为子程序，令\\(W=1\\)后，直接调用DIJKSTRA''(G, 1, w, s)即可。那么在这题中由于\\(|E|\\ge\r\n|V|-1\\)，且题目22.3-9给出该算法的时间复杂度为\\((WV+E)\\)，因此时间复杂度为\\(O(E)\\)。\r\nc\r\n可以知道，\\(w_i(u,v)\\)表示的是\\(k\\)比特数\\(w(u,v)\\)的高\\(i\\)位。如果\\(w(u,v)\\)从高到低的第\\(i\\)位是\\(0\\)，那么有\\(w_i(u,v)=2w_{i-1}(u,v)\\)；如果是\\(1\\)，那么有\\(w_i(u,v)=2w_{i-1}(u,v)+1\\)。\r\n在以\\(w_i(\\cdot,\\cdot)\\)作为边权时，假设从\\(s\\)到\\(u\\)的最短路径为\\(v_1,v_2,\\dots,v_k,v_1=s,v_k=v\\)，那么考虑\\(\\delta_i(s,v)\\)的值，有：\r\n\\(\\begin{aligned}\r\n\\delta_i(s,v)&amp;=\\sum_{j=2}^k w_i(v_{j-1},v_j)\\\\\r\n&amp;\\ge \\sum_{j=2}^k 2w_{i-1}(v_{j-1},v_j)\\\\\r\n&amp;\\ge 2\\delta_{i-1}(s,v)\\\\\r\n\\end{aligned}\\)\r\n在以\\(w_{i-1}(\\cdot,\\cdot)\\)作为边权时，假设从\\(s\\)到\\(u\\)的最短路径为\\(v_1&#39;,v_2&#39;,\\dots,v_k&#39;,v_1&#39;=s,v_k&#39;=v\\)，那么考虑\\(\\delta_{i-1}(s,v)\\)，有：\r\n\\(\\begin{aligned}\r\n2\\delta_{i-1}(s,v)+|V|-1&amp;\\ge2\\delta_{i-1}(s,v)+k-1\\\\\r\n&amp;=\\sum_{j=2}^k (2w_{i-1}(v_{j-1}&#39;,v_j&#39;)+1)\\\\\r\n&amp;\\ge\\sum_{j=2}^k w_{i}(v_{j-1}&#39;,v_j&#39;)&amp;\\qquad(A)\\\\\r\n&amp;\\ge\\delta_{i}(s,v)\r\n\\end{aligned}\\)\r\n其中步骤\\((A)\\)是应用了\\(w_i(u,v)\\le2w_{i-1}(u,v)+1\\)。\r\n因此，最终有\r\n\\[2\\delta_{i-1}(s,v)\\le \\delta_i(s,v)\\le\r\n2\\delta_{i-1}(s,v)+|V|-1\\]\r\n【网上一些论证使用了假设：计算\\(w_i\\)所得到的最短路径也是\\(w_{i-1}\\)的最短路径。然而这是错误的，可以构造出反例：\\(G=(V,E),V=\\{a,b,c,d,e,f\\},E=\\{(a,b,1),(b,c,3),(c,d,3),(a,e,2),(e,f,2),(f,d,2)\\}\\)，计算\\(\\delta_1(a,d)\\)和\\(\\delta_2(a,d)\\)的最短路不是一样的】。\r\nd\r\n\\(\\begin{aligned}\r\n2\\delta_{i-1}(s,v)-2\\delta_{i-1}(s,u)&amp;\\le 2w_{i-1}(u,v)\\\\\r\n&amp;\\le w_i(u,v)&amp;\\qquad(B)\r\n\\end{aligned}\\)\r\n其中步骤\\((B)\\)是应用了\\(w_i(u,v)\\ge2w_{i-1}(u,v)\\)。\r\n因此有\\(\\hat{w}_i(u,v)=w_i(u,v)+2\\delta_{i-1}(s,u)-2\\delta_{i-1}(s,v)\\ge\r\n0\\)成立。\r\ne\r\n在以\\(\\hat{w}_i(\\cdot,\\cdot)\\)作为边权时，考虑\\(\\hat{\\delta}_i(s,v)\\)的值，有：\r\n\\(\\begin{aligned}\r\n\\hat{\\delta}_i(s,v)&amp;=\\min_{e\\in \\text{Path}(s,v)} \\hat{w}_i(e)\\\\\r\n&amp;=\\min_{\\substack{p:v_1,v_2,\\dots,v_k;\\\\v_1=s,v_k=v}}\\left\\{\\sum_{j=2}^k\r\n(w_i(v_{j-1},w_{j})+2\\delta_{i-1}(s,v_{j-1})-2\\delta_{i-1}(s,v_j))\\right\\}\\\\\r\n&amp;=\\min_{\\substack{p:v_1,v_2,\\dots,v_k;\\\\v_1=s,v_k=v}}\\left\\{\\sum_{j=2}^k\r\nw_i(v_{j-1},w_{j})-2\\delta_{i-1}(s,v)+2\\delta_{i-1}(s,s)\\right\\}\\\\\r\n&amp;=\\min_{\\substack{p:v_1,v_2,\\dots,v_k;\\\\v_1=s,v_k=v}}\\left\\{\\sum_{j=2}^k\r\nw_i(v_{j-1},w_{j})\\right\\}-2\\delta_{i-1}(s,v)\\\\\r\n&amp;=\\delta_i(s,v)-2\\delta_{i-1}(s,v)\r\n\\end{aligned}\\)\r\n从而得到\\(\\delta_i(s,v)=\\hat{\\delta}_i(s,v)+2\\delta_{i-1}(s,v)\\)。\r\n根据题目22-4-c的结论，可以得到\\(0\\le\\hat{\\delta}_i(s,v)\\le |V|-1\\le\r\n|E|\\)。\r\nf\r\n假设已经计算了\\(\\delta_{i-1}(s,v)\\)，那么我们可以以\\(O(E)\\)的时间构造出所有边的\\(\\hat{w_i}\\)值。由于\\(\\hat{\\delta}_i(s,v)\\le\r\n|E|\\)，因此我们可以使用题目22-4-a所提出的算法以\\(O(E)\\)的时间计算出\\(\\hat{\\delta}_i(s,v)\\)的值。最终通过题目22-4-f的结论以\\(O(V)\\)的时间计算\\(\\delta_i(s,v)=\\hat{\\delta}_i(s,v)+2\\delta_{i-1}(s,v)\\)的值。\r\n因此迭代\\(\\lg\r\nW\\)轮后，可以计算出所有节点的\\(\\delta(s,v)\\)，本题整个过程由程序DIJKSTRA-W给出。\r\n// 这里假设所有的函数被新构造出来后，那么所有值都已经记录好，不会随着时间推移而改变。DIJKSTRA-W(G, s, w)  W = max&#123;w(u, v) | (u, v) ∈ G.E&#125;  k = ⌈lg (W + 1)⌉  let new function w[i](⋅, ⋅⋅) = ⌈w(⋅, ⋅⋅) / 2^i⌉ for i = 1, 2, 3, ..., k  DIJKSTRA&#x27;&#x27;(G, 1, w[1], s)  let new function δ[1](s, ⋅) = ⋅.d  for i = 2 to k    let new function w&#x27;[i](⋅, ⋅⋅) = w[i](⋅, ⋅⋅) + 2 * δ[i - 1](s, ⋅) - 2 * δ[i - 1](s, ⋅⋅)    DIJKSTRA-E(G, 1, w&#x27;[i], s)    let new function δ[i](s, ⋅) = ⋅.d + 2 * δ[i - 1](s, ⋅)  for each u ∈ G.V    u.d = δ[k](s, v)\r\n22-5\r\na\r\n如果\\(\\mu^{\\ast}=0\\)，也就是说存在一个长度为\\(k\\)的环\\(\\langle\r\ne_1,e_2,\\dots,e_k\\rangle\\)，满足\\(\\displaystyle{\\dfrac{1}{k}\\sum_{i=1}^k}\r\nw(e_i)=0\\)。也就是说，这个环的权值和\\(\\displaystyle{\\sum_{i=1}^k}w(e_i)\\)是\\(G\\)中所有环的权值和最低的，且为\\(0\\)，因此图\\(G\\)没有负环。\r\n这意味着，\\(G\\)中来自\\(s\\)的最短路，其边数是来自不超过\\(n-1\\)的一条简单路径。对于边数超过\\(n-1\\)的最短路径，必定存在一些边权和为\\(0\\)的环，去掉这些环，直到成为一条简单路径，并不会影响它仍然是最短路径。\r\n因此从\\(0\\)到\\(n-1\\)枚举所有恰好包含\\(k\\)条边最短路径中的最短的一条，就可以得到从\\(s\\)到\\(v\\)的最短路径：\r\n\\[\\delta(s,v)=\\min_{k=0}^{n-1}\\{\\delta_k(s,v)\\}\\]\r\nb\r\n为证明\r\n\\[\\max_{k=0}^{n-1}\\left\\{\\dfrac{\\delta_n(s,v)-\\delta_k(s,v)}{n-k}\\right\\}\\ge\r\n0\\]\r\n只需要证明\r\n\\[\\max_{k=0}^{n-1}\\{\\delta_n(s,v)-\\delta_k(s,v)\\}\\ge\r\n0\\]\r\n即可，因为\\(n-k&gt;0\\)恒成立。\r\n由于\\(\\mu^{\\ast}=0\\)，因此这个图虽然没有负环，但是存在非负环。\r\n如果\\(\\delta_n(s,v)=\\infty\\)，那么原结论显然成立。如果\\(\\delta_n(s,v)&lt;\\infty\\)，那么这条路径必定存在一个边权和为\\(0\\)的环，去掉之后那么就成为了一条边数小于\\(n\\)的最短路径。此外，由于\\(\\delta_n(s,v)\\)是个和\\(k\\)无关的值，因此有\r\n\\(\\begin{aligned}\r\n\\max_{k=0}^{n-1}\\{\\delta_n(s,v)-\\delta_k(s,v)\\}&amp;=\\delta_n(s,v)-\\min_{k=0}^{n-1}\\{\\delta_k(s,v)\\}\\\\&amp;=\\delta_n(s,v)-\\delta(s,v)\\\\\r\n&amp;\\ge 0\r\n\\end{aligned}\\)\r\n因此原结论成立。\r\nc\r\n由于\\(\\mu^{\\ast}=0\\)，因此这个图虽然没有负环，也就是说\\(\\delta(s,v)\\neq-\\infty,\\delta(s,v)\\neq-\\infty\\)。\r\n由于从节点\\(u\\)到节点\\(v\\)上的简单路径权重为\\(x\\)，因此有\\(\\delta(s,v)\\le\\delta(s,u)+x\\)（否则，按顺序松弛这条路径上的边将会产生矛盾）。类似的原因，由于从节点\\(v\\)到节点\\(u\\)上的简单路径权重为\\(-x\\)，因此有\\(\\delta(s,u)\\le\\delta(s,v)-x\\)。结合这两条式子，最终得到\\(\\delta(s,v)=\\delta(s,u)+x\\)。\r\nd\r\n与题目22-5-b类似，只需要证明\\(\\displaystyle{\\max_{k=0}^{n-1}\\{\\delta_n(s,v)-\\delta_k(s,v)\\}}=0\\)即可。\r\n也就是有\\(\\displaystyle{\\delta_n(s,v)-\\min_{k=0}^{n-1}\\{\\delta_k(s,v)\\}}=0\\)，即证明\\(\\delta_n(s,v)=\\delta(s,v)\\)。\r\n令\\(c\\)是\\(G\\)上的某一个最小平均环，那么存在一条从\\(s\\)到\\(c\\)上某一个节点\\(u\\)的一条最短路径\\(p\\)，假设其长度为\\(m\\)。接下来从\\(u\\)沿着这个环走\\(n-m\\)步，到达另一个节点\\(v\\)。那么由于从\\(s\\)走\\(n\\)步可以到达节点\\(v\\)，因此\\(\\delta_n(s,v)\\neq\r\n\\infty\\)。也就是说，存在一条从\\(s\\)到\\(v\\)，且步数为\\(n\\)的最短路径\\(p&#39;\\)，根据题目22-5-c的结论，\\(p&#39;\\)是从\\(s\\)到\\(v\\)的全局最短路径。由于\\(p&#39;\\)的长度大于\\(n-1\\)，因此\\(p&#39;\\)必定经过一些环。又因为\\(\\mu^{\\ast}=0\\)，因此\\(p&#39;\\)经过的只能是一部分权值和为\\(0\\)的环。去掉这些权值和为\\(0\\)的所有环后，那么得到一条长度小于等于\\(n-1\\)的最短路径\\(p&#39;&#39;\\)，令\\(k\\)为\\(p&#39;&#39;\\)的长度，由此得到\\(\\delta_n(s,v)=\\delta_k(s,v)=\\delta(s,v)\\)。从而证明原结论成立。\r\ne\r\n本题的前提是：\\(\\mu^{\\ast}=0\\)，和题目22-5-b以及22-5-e一样。\r\n根据题目22-5-b的结论：\\(\\forall v\\in\r\nV,\\displaystyle{\\max_{k=0}^{n-1}\\left\\{\\dfrac{\\delta_n(s,v)-\\delta_k(s,v)}{n-k}\\right\\}\\ge\r\n0}\\)；\r\n以及题目22-5-e的结论：对于\\(V\\)中在最小平均环上的某个节点\\(v\\)，有\\(\\displaystyle{\\max_{k=0}^{n-1}\\left\\{\\dfrac{\\delta_n(s,v)-\\delta_k(s,v)}{n-k}\\right\\}=\r\n0}\\)，\r\n可以得到\\(\\displaystyle{\\min_{u\\in\r\nV}\\left\\{\\max_{k=0}^{n-1}\\left\\{\\dfrac{\\delta_n(s,v)-\\delta_k(s,v)}{n-k}\\right\\}\\right\\}}=0\\)。\r\nf\r\n将\\(E\\)中所有边\\(e\\)都增加一个常数\\(c\\)后，得到新的权重函数\\(w&#39;(e)=w(e)+t\\)。令新图中的平均回路权重\\(\\mu&#39;\\)。对于图中任意一个环\\(c\\)，考虑\\(\\displaystyle{\\mu&#39;^{\\ast}=\\min_{c}\\{\\mu&#39;(c)\\}}\\)，有：\r\n\\(\\begin{aligned}\r\n\\mu&#39;^{\\ast}&amp;=\\min_{c} \\mu&#39;(c)\\\\\r\n&amp;=\\min_{c:\\langle e_1,e_2,\\dots,e_k\\rangle} \\left\\{\\dfrac{1}{k}\r\n\\sum_{i=1}^k w&#39;(e_i)\\right\\}\\\\\r\n&amp;=\\min_{c:\\langle e_1,e_2,\\dots,e_k\\rangle}  \\left\\{\\dfrac{1}{k}\r\n\\sum_{i=1}^k (w(e_i)+t)\\right\\}\\\\\r\n&amp;=\\min_{c:\\langle e_1,e_2,\\dots,e_k\\rangle}  \\left\\{t+\\dfrac{1}{k}\r\n\\sum_{i=1}^k w(e_i)\\right\\}\\\\\r\n&amp;=t+\\min_{c:\\langle e_1,e_2,\\dots,e_k\\rangle}  \\left\\{\\dfrac{1}{k}\r\n\\sum_{i=1}^k w(e_i)\\right\\}\\\\\r\n&amp;=t+\\mu^{\\ast}\r\n\\end{aligned}\\)\r\n也就是说，对于旧图中的所有环\\(c\\)，如果将它们的所有边权都加上\\(t\\)，那么新的平均权重也会增加\\(t\\)，从而得证。\r\n如果使用题目所求事实，同样可得：\r\n\\(\\begin{aligned}\r\n\\mu&#39;^{\\ast}&amp;=\\min_{u\\in\r\nV}\\left\\{\\max_{k=0}^{n-1}\\left\\{\\dfrac{\\delta_n&#39;(s,v)-\\delta_k&#39;(s,v)}{n-k}\\right\\}\\right\\}\\\\\r\n&amp;=\\min_{u\\in\r\nV}\\left\\{\\max_{k=0}^{n-1}\\left\\{\\dfrac{(\\delta_n(s,v)+nt)-(\\delta_k(s,v)-kt)}{n-k}\\right\\}\\right\\}\\\\\r\n&amp;=\\min_{u\\in\r\nV}\\left\\{\\max_{k=0}^{n-1}\\left\\{\\dfrac{\\delta_n(s,v)-\\delta_k(s,v)}{n-k}+t\\right\\}\\right\\}\\\\\r\n&amp;=\\min_{u\\in\r\nV}\\left\\{\\max_{k=0}^{n-1}\\left\\{\\dfrac{\\delta_n(s,v)-\\delta_k(s,v)}{n-k}\\right\\}\\right\\}+t\\\\\r\n&amp;=\\mu^{\\ast}+t\r\n\\end{aligned}\\)\r\ng\r\n考虑使用动态规划计算出\\(\\delta_k(s,v)(0\\le\r\nk\\le n,v\\in V)\\)的所有值。那么可以将\\(\\delta_k(s,v)\\)写成如下状态转移方程：\r\n\\(\\delta_k(s,v)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0 &amp; &amp; \\text{if}\\quad  k=0\\land v=s \\\\\r\n  &amp;\\infty &amp; &amp; \\text{if}\\quad  k=0\\land v\\neq s \\\\\r\n  &amp;\\min_{u\\in V:(u,v)\\in E}\\{\\delta_{k-1}(s,u)+w(u,v)\\} &amp; &amp;\r\n\\text{if}\\quad  k&gt;0 \\\\\r\n\\end{aligned}\\right.\\)\r\n然而，对于\\(\\delta_{k-1}(s,\\cdot)\\)中的所有值，可以以\\(O(V+E)=O(E)\\)的时间复杂度求出\\(\\delta_{k}(s,\\cdot)\\)中的所有值。迭代\\(|V|\\)轮后，那么求出\\(\\delta_{k}(s,v)\\)这个表的时间复杂度为\\(O(VE)\\)。\r\n得到关于\\(\\delta_k(s,v)\\)的表后，我们只需要暴力枚举表\\(\\delta_k(s,\\cdot)\\)上的值，即可得到\\(\\displaystyle{\\mu^{\\ast}=\\min_{u\\in\r\nV}\\left\\{\\max_{k=0}^{n-1}\\left\\{\\dfrac{\\delta_n(s,v)-\\delta_k(s,v)}{n-k}\\right\\}\\right\\}}\\)的值。这个过程需要\\(O(V^2)\\)的时间复杂度。\r\n整个算法由过程MINIMUM-MEAN-WEIGHT-CYCLE给出，整个过程的时间复杂度为\\(O(VE)\\)。\r\nMINIMUM-MEAN-WEIGHT-CYCLE(G, s, w)  let δ[0 : |G.V|, 1 : |G.V|] be new table by ∞  n = |G.V|  δ[0, s] = 0  for i = 0 to n - 1    for each u ∈ G.V      for each v in G.Adj[u]        if δ[i + 1, v] &gt; δ[i, u] + w(u, v)          δ[i + 1, v] = δ[i, u] + w(u, v)  μ∗ = ∞  for each v ∈ G.V    if δ[n, v] != ∞      t = ∞      for k = 0 to |G.V| - 1        if δ[k, v] != ∞          t = max&#123;t, (δ[n, v] - δ[k, v]) / (n - k)&#125;      μ∗ = min&#123;μ∗, t&#125;  return μ∗\r\n22-6\r\n本题使用将使用类似Bellman-Ford算法的操作完成。首先需要对所有边按边权从大到小进行排序，这将花费\\(O(E\\lg E)\\)的时间。\r\n接下来先考虑两种情况：路径中权值先单调上升，再单调下降；或者是先单调下降，再单调上升；对于前者，将对每条边从小到大先进行松弛操作，再从大到小进行松弛；对于后者，情况类似。那么这两种情况所需要的时间开销为\\(O(E)\\)。\r\n接下来考虑这种情况：先单调上升，后单调下降，再单调上升（只是此时上升的值不能超过一开始的第一条边的边权，以维持双调序列的性质）。首先枚举\\(s\\)的每条出边\\((s,v)\\)。那么在这一轮中，先对整张图进行初始化，然后使用边\\((s,v)\\)进行松弛。接下来进行三轮的松弛：第一轮，从小到大枚举所有大于\\(w(u,v)\\)的边；第二轮，从大到小枚举所有\\(E\\)中的边；第三轮，从小到大枚举所有小于\\(w(u,v)\\)的边。由于\\(s\\)最多有\\(|V|-1\\)条出边，每轮枚举\\(E\\)条边，因此这种情况的时间复杂度为\\(O(V^2+VE)\\)。另一种镜像情况和这种情况类似，此处不赘述。\r\n算法BITONIC-SHORTEST-PATHS给出了具体过程，按照上面的分析，其时间复杂度为\\(O(V^2+VE)\\)。\r\n// 为了方便，假设G.E输入的是(出点，入点，边权)三元组，并且使用RELAX&#x27;子程序进行松弛操作，第三个参数接受的是边权值。RELAX-ORDER(E, s, e)  if s &lt;= e    for i = s to e      RELAX&#x27;(e[i].u, e[i].v, e[i].w)  else    for i = s downto e      RELAX&#x27;(e[i].u, e[i].v, e[i].w)BITONIC-SHORTEST-PATHS(G, s)  create a single list e of the edges in G.E  sort the list of edges into monotonically increasing order by weight e[i].w  // 情况1  INITIALIZE-SINGLE-SOURCE(G, s)  RELAX-ORDER(E, 1, |E|)  RELAX-ORDER(E, |E|, 1)  for each u ∈ G.V    u.d&#x27; = u.d  // 情况2  INITIALIZE-SINGLE-SOURCE(G, s)  RELAX-ORDER(E, |E|, 1)  RELAX-ORDER(E, 1, |E|)  for each u ∈ G.V    u.d&#x27; = min&#123;u.d&#x27;, u.d&#125;  for i = 1 to |E|     if e[i].u == s      // 情况3      INITIALIZE-SINGLE-SOURCE(G, s)      RELAX-ORDER(E, i, |E|)      RELAX-ORDER(E, |E|, 1)      RELAX-ORDER(E, 1, i)      for each u ∈ G.V        u.d&#x27; = min&#123;u.d&#x27;, u.d&#125;      // 情况4      INITIALIZE-SINGLE-SOURCE(G, s)      RELAX-ORDER(E, i, 1)      RELAX-ORDER(E, 1, |E|)      RELAX-ORDER(E, |E|, i)      for each u ∈ G.V        u.d&#x27; = min&#123;u.d&#x27;, u.d&#125;  // 最终，u.d&#x27;代表真正的答案。\r\n","categories":["算法导论"]},{"title":"算法导论23.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-23/exercises-3/","content":"\r\n23.3-1\r\n在第一步计算出的\\(h\\)值为：\r\n\\(\\begin{array}{|l|l|}\\hline\r\nv&amp;h(v)\\\\\\hline\r\n1&amp;-5\\\\\\hline\r\n2&amp;-3\\\\\\hline\r\n3&amp;0\\\\\\hline\r\n4&amp;-1\\\\\\hline\r\n5&amp;-6\\\\\\hline\r\n6&amp;-8\\\\\\hline\r\n\\end{array}\\)\r\n更新后的\\(\\hat{w}\\)值如下：\r\n\\(\\begin{array}{|c|c|c|}\\hline\r\nu&amp;v&amp;\\hat{w}(u,v)\\\\\\hline\r\n1&amp;5&amp;0\\\\\\hline\r\n2&amp;1&amp;3\\\\\\hline\r\n2&amp;4&amp;0\\\\\\hline\r\n3&amp;2&amp;5\\\\\\hline\r\n3&amp;6&amp;0\\\\\\hline\r\n4&amp;1&amp;0\\\\\\hline\r\n4&amp;5&amp;8\\\\\\hline\r\n5&amp;2&amp;4\\\\\\hline\r\n6&amp;2&amp;0\\\\\\hline\r\n6&amp;3&amp;18\\\\\\hline\r\n\\end{array}\\)\r\n23.3-2\r\n章节22.4已经解释了，求解差分约束时添加\\(v_0\\)是为了让节点\\(0\\)能够到达所有节点，从而保证每个解\\(x_i=\\delta(0,i)\\)能够被正确求出，避免了负环的情况。\r\n这里的\\(s\\)和差分约束时\\(v_0\\)的作用是一样的，从\\(s\\)能够到达\\(V\\)中的所有节点，并且\\(h(v)\\)都能够被正确求出，并且同样规避了负环的问题。\r\n23.3-3\r\n在图\\(G&#39;=(V\\cup\\{s\\},E&#39;)\\)中，由于\\(\\forall v\\in V,w(s,v)=0\\)，因此从\\(s\\)到\\(v\\)存在一条长度为\\(0\\)的路径。又因为\\(G&#39;\\)没有负数边权，因此这条路径就是从\\(s\\)到\\(v\\)的最短路。也就是说，\\(\\forall v\\in V,h(v)=0\\)。因此\\(\\forall (u,v)\\in\r\nE,\\hat{w}(u,v)=w(u,v)+h(u)-h(v)=w(u,v)\\)。\r\n也就是说，\\(\\hat{w}(\\cdot,\\cdot)=w(\\cdot,\\cdot)\\)。\r\n23.3-4\r\n这种做法不能保证路径\\(p\\)是使用权重函数\\(w\\)时从\\(u\\)到\\(v\\)的一条最短路径，当且仅当\\(p\\)是使用权重函数\\(\\hat{w}\\)时从\\(u\\)到\\(v\\)的一条最短路径。\r\n考虑图\\(G=(V,E),V=\\{a,b,c\\},E=\\{(a,b),(a,c),(b,c)\\},w(a,b)=w(b,c)=w(a,c)=1\\)。那么可以计算得\\(\\displaystyle{w^{\\ast}=\\min_{e\\in\r\nE}w(e)=1}\\)。\r\n那么得到\\(\\hat{w}(a,b)=\\hat{w}(b,c)=\\hat{w}(a,c)=0\\)。\r\n\r\n使用权重函数\\(w\\)时，\\(a\\rightarrow b\\rightarrow\r\nc\\)不是一条从\\(a\\)到\\(c\\)的最短路径。但是使用权重函数\\(\\hat{w}\\)时，\\(a\\rightarrow b\\rightarrow c\\)是一条从\\(a\\)到\\(c\\)的最短路径。\r\n23.3-5\r\n令\\(c=(v_0,v_1,v_2,\\dots,v_k)\\)，其中\\(v_0=v_k\\)。那么由题意可以知道，\\(w(c)=\\displaystyle{\\sum_{i=1}^k\r\nw(v_{i-1},v_i)=0}\\)。考虑计算\\(\\hat{w}(c)\\)的值，有\r\n\\(\\begin{aligned}\r\n\\hat{w}(c)&amp;=\\sum_{i=1}^k \\hat{w}(v_{i-1},v_i)\\\\\r\n&amp;=\\sum_{i=1}^k w(v_{i-1},v_i)+h(v_{i-1})-h(v_i)\\\\\r\n&amp;=h(v_0)-h(v_k)+\\sum_{i=1}^k w(v_{i-1},v_i)\\\\\r\n&amp;=0\r\n\\end{aligned}\\)\r\n也就是说，在以\\(\\hat{w}\\)作为边权函数时，边权之和仍然为\\(0\\)。根据\\(\\hat{w}\\)的定义，\\(\\forall i\\in [1,k],\\hat{w}(v_{i-1},v_{i})\\ge\r\n0\\)成立。因此\\(\\forall i\\in\r\n[1,k],\\hat{w}(v_{i-1},v_{i})= 0\\)成立。\r\n23.3-6\r\n考虑图\\(G=(V,E),V=\\{a,b,c\\},E=\\{(a,b),(a,c),(b,c)\\},w(b,a)=w(b,c)=w(c,a)=1\\)。\r\n\r\n那么当以\\(a\\)作为原点时，运行Bellman-Ford算法，将会无法正确计算出\\(h(b)\\)和\\(h(c)\\)的值（即\\(h(b)=h(c)=\\infty\\)），从而三条边的\\(\\hat{w}\\)值都无法被正确计算。\r\n使用反证法证明这个结论：考虑图\\(G=(V,E)\\)，如果\\(\\exists u,v\\in V\\)，从\\(u\\)到\\(v\\)没有路径。那么以\\(u\\)为原点对图\\(G\\)进行Bellman-Ford算法，将会得到\\(h(v)=\\infty\\)，和\\(v\\)相关的所有边（出边，入边）将会无法计算出\\(\\hat{w}\\)值。\r\n因此，\\(\\forall u ,v\\in\r\nV\\)，都存在从\\(u\\)到\\(v\\)的路径，也就是说，\\(G\\)是强连通的，这样才能从任意节点出发，都能计算出所有节点的\\(h\\)值。\r\n运行Bellman-Ford算法后，对于\\(\\forall\r\n(u,v)\\in E\\)，都有\\(h(u)+w(u,v)\\ge\r\nh(v)\\)。对于构造出的\\(\\hat{w}(u,v)=w(u,v)+h(u)-h(v)\\)，是一个满足符合要求的权重函数，其正确性的证明过程和引理23.1完全一致。之后的步骤和原来的都相同，因此这个版本的Johnson算法返回一个正确的结果。\r\n","categories":["算法导论"]},{"title":"算法导论23.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-23/exercises-2/","content":"\r\n23.2-1\r\n每步的迭代结果如下：\r\n\\(\\begin{aligned}\r\n&amp;\\begin{pmatrix}\r\n0&amp;\\infty&amp;\\infty&amp;\\infty&amp;-1&amp;\\infty\\\\\r\n1&amp;0&amp;\\infty&amp;2&amp;\\infty&amp;\\infty\\\\\r\n\\infty&amp;2&amp;0&amp;\\infty&amp;\\infty&amp;-8\\\\\r\n-4&amp;\\infty&amp;\\infty&amp;0&amp;3&amp;\\infty\\\\\r\n\\infty&amp;7&amp;\\infty&amp;\\infty&amp;0&amp;\\infty\\\\\r\n\\infty&amp;5&amp;10&amp;\\infty&amp;\\infty&amp;0\r\n\\end{pmatrix}\r\n\\underrightarrow{k=1}\r\n\\begin{pmatrix}\r\n0&amp;\\infty&amp;\\infty&amp;\\infty&amp;-1&amp;\\infty\\\\\r\n1&amp;0&amp;\\infty&amp;2&amp;0&amp;\\infty\\\\\r\n\\infty&amp;2&amp;0&amp;\\infty&amp;\\infty&amp;-8\\\\\r\n-4&amp;\\infty&amp;\\infty&amp;0&amp;-5&amp;\\infty\\\\\r\n\\infty&amp;7&amp;\\infty&amp;\\infty&amp;0&amp;\\infty\\\\\r\n\\infty&amp;5&amp;10&amp;\\infty&amp;\\infty&amp;0\r\n\\end{pmatrix}\r\n\\underrightarrow{k=2}\r\n\\begin{pmatrix}\r\n0&amp;\\infty&amp;\\infty&amp;\\infty&amp;-1&amp;\\infty\\\\\r\n1&amp;0&amp;\\infty&amp;2&amp;0&amp;\\infty\\\\\r\n3&amp;2&amp;0&amp;4&amp;2&amp;-8\\\\\r\n-4&amp;\\infty&amp;\\infty&amp;0&amp;-5&amp;\\infty\\\\\r\n8&amp;7&amp;\\infty&amp;9&amp;0&amp;\\infty\\\\\r\n6&amp;5&amp;10&amp;7&amp;5&amp;0\r\n\\end{pmatrix}\\\\\r\n\\underrightarrow{k=3}\r\n&amp;\\begin{pmatrix}\r\n0&amp;\\infty&amp;\\infty&amp;\\infty&amp;-1&amp;\\infty\\\\\r\n1&amp;0&amp;\\infty&amp;2&amp;0&amp;\\infty\\\\\r\n3&amp;2&amp;0&amp;4&amp;2&amp;-8\\\\\r\n-4&amp;\\infty&amp;\\infty&amp;0&amp;-5&amp;\\infty\\\\\r\n8&amp;7&amp;\\infty&amp;9&amp;0&amp;\\infty\\\\\r\n6&amp;5&amp;10&amp;7&amp;5&amp;0\r\n\\end{pmatrix}\r\n\\underrightarrow{k=4}\r\n\\begin{pmatrix}\r\n0&amp;\\infty&amp;\\infty&amp;\\infty&amp;-1&amp;\\infty\\\\\r\n-2&amp;0&amp;\\infty&amp;2&amp;-3&amp;\\infty\\\\\r\n0&amp;2&amp;0&amp;4&amp;-1&amp;-8\\\\\r\n-4&amp;\\infty&amp;\\infty&amp;0&amp;-5&amp;\\infty\\\\\r\n5&amp;7&amp;\\infty&amp;9&amp;0&amp;\\infty\\\\\r\n3&amp;5&amp;10&amp;7&amp;2&amp;0\r\n\\end{pmatrix}\r\n\\underrightarrow{k=5}\r\n\\begin{pmatrix}\r\n0&amp;6&amp;\\infty&amp;8&amp;-1&amp;\\infty\\\\\r\n-2&amp;0&amp;\\infty&amp;2&amp;-3&amp;\\infty\\\\\r\n0&amp;2&amp;0&amp;4&amp;-1&amp;-8\\\\\r\n-4&amp;2&amp;\\infty&amp;0&amp;-5&amp;\\infty\\\\\r\n5&amp;7&amp;\\infty&amp;9&amp;0&amp;\\infty\\\\\r\n3&amp;5&amp;10&amp;7&amp;2&amp;0\r\n\\end{pmatrix}\\\\\r\n\\underrightarrow{k=6}\r\n&amp;\\begin{pmatrix}\r\n0&amp;6&amp;\\infty&amp;8&amp;-1&amp;\\infty\\\\\r\n-2&amp;0&amp;\\infty&amp;2&amp;-3&amp;\\infty\\\\\r\n-5&amp;-3&amp;0&amp;-1&amp;-6&amp;-8\\\\\r\n-4&amp;2&amp;\\infty&amp;0&amp;-5&amp;\\infty\\\\\r\n5&amp;7&amp;\\infty&amp;9&amp;0&amp;\\infty\\\\\r\n3&amp;5&amp;10&amp;7&amp;2&amp;0\r\n\\end{pmatrix}\\\\\r\n\\end{aligned}\\)\r\n23.2-2\r\n对于图\\(G=(V,E)\\)的邻接矩阵\\(W\\)，我们设\\(w_{ij}=1\\)当且仅当边\\((i,j)\\in E\\)，此外，\\(\\forall i\\in\r\nV,w_{ii}=1\\)。接下来参照子程序EXTEND-SHORTEST-PATHS，构造出子程序EXTEND-PATHS'。那么剩下的是调用这个子程序即可求出传递闭包，整个过程和23.1节一致，由TRANSITIVE-CLOSURE'给出。\r\nEXTEND-PATHS&#x27;(T(r-1), W, T(r), n)  for i = 1 to n    for j = 1 to n      for k = 1 to n        t_&#123;ij&#125;^(r) = t_&#123;ij&#125;^(r) ∨ (t_&#123;ik&#125;^(r-1) ∧ w_&#123;kj&#125;^(r-1))TRANSITIVE-CLOSURE&#x27;(W, n)  let T and M be new n × n matrices  T = W  r = 1  while r &lt; n - 1    M = 0    EXTEND-PATHS&#x27;&#x27;(T, T, M, n)    r = 2r    T = M  return T\r\n23.2-3\r\n按照方程23.7和23.8，修改后的算法为FLOYD-WARSHALL''。\r\nFLOYD-WARSHALL&#x27;&#x27;(W, n)  D^(0) = W  let Π^(0) be a new n × n matrix  for i = 1 to n    for j = 1 to n      if w_&#123;ij&#125; &lt; ∞ and i != j        π^(0)_&#123;ij&#125; = i      else        π^(0)_&#123;ij&#125; = NIL  for k = 1 to n    let D^(k) = (d^(k)_&#123;ij&#125;),Π^(k) = (π^(k)_&#123;ij&#125;) be new n × n matrices    for i = 1 to n      for j = 1 to n        if d^(k-1)_&#123;ij&#125; &gt; d^(k-1)_&#123;ik&#125; + d^(k-1)_&#123;kj&#125;          d^(k)_&#123;ij&#125; = d^(k-1)_&#123;ik&#125; + d^(k-1)_&#123;kj&#125;          π^(k)_&#123;ij&#125; = π^(k-1)_&#123;kj&#125;        else          d^(k)_&#123;ij&#125; = d^(k-1)_&#123;ij&#125;          π^(k)_&#123;ij&#125; = π^(k-1)_&#123;ij&#125;  return D^(n), Π^(n)\r\n首先证明\\(G_{\\pi,i}\\)是一个有向无环图。当\\(\\pi_{ij}^{(k)}\\)被更新成一个值\\(l\\)时，说明\\(d_{ij}^{(k)}=d_{il}^{(k-1)}+w_{lj}\\)。由于\\(d_{ij}^{(k-1)}\\)是\\(d_{ij}^{(k)}\\)的一个子问题选项，因此有\\(d_{ij}^{(k)}\\le\r\nd_{ij}^{(k-1)}\\)，从而得到\\(d_{ij}^{(k)}\\ge\r\nd_{il}^{(k-1)}+w_{lj}\\)。接下来的证明和引理22.16的证明类似。假设\\(G_{\\pi,i}\\)构成了一个环\\(v_0,v_1,\\dots,v_m\\)，其中\\(v_0=v_m,\\forall\r\nj\\in[1,m],\\pi^{(k)}_{i,v_j}=v_{j-1}\\)都成立。那么在\\(\\pi_{i,v_m}\\)更新成\\(v_{m-1}\\)前，都有：\r\n\\[d_{i,v_j}^{(k)}\\ge\r\nd_{i,v_{j-1}}^{(k)}+w_{v_{j-1},v_j},j=1,2,\\dots,m-1\\]\r\n由于\\(\\pi_{i,v_m}\\)被更新，所以在\\(\\pi_{i,v_m}\\)被更新成\\(v_{m-1}\\)前，有\r\n\\[d_{i,v_{m}}^{(k)}&gt;d_{i,v_{m-1}}^{(k)}+w_{v_{m-1},v_m}\\]\r\n将这\\(m\\)条不等式左右各自相加，最终得到\\(\\displaystyle{\\sum_{j=1}^m\r\nw(v_{j-1},v_j)}&lt;0\\)。这和图\\(G\\)没有负环是矛盾的。因此，\\(G_{\\pi,i}\\)是一个有向无环图。\r\n接下来和引理22.17的证明类似。\\(G_{\\pi,i}\\)从\\(i\\)到每个节点\\(u\\)之间只存在唯一一条路径。如果存在两条路径\\(p_1:i\\rightsquigarrow u\\rightsquigarrow\r\nx\\rightarrow z\\rightsquigarrow u,p_2:i\\rightsquigarrow u\\rightsquigarrow\r\ny\\rightarrow z\\rightsquigarrow u\\)，并且\\(x\\neq y\\)，那么说明\\(\\pi_{iz}=x,\\pi_{iz}=y\\)同时成立。这是不可能的，因此从\\(i\\)到每个节点\\(u\\)之间只存在唯一一条路径，\\(G_{\\pi,i}\\)是以\\(i\\)为根形成的一棵树。\r\n最终，由于算法正确地求解出了\\(d_{ij}^{(n)}=\\delta(i,j)\\)，因此对于所有顶点\\(i,G_i\\)都是以\\(i\\)为根的最短路径树。\r\n23.2-4\r\n可以知道，这个对\\(d_{ij}^{(k)}\\)的更新本质上是来自\\(\\{d_{ik}^{(k)}+d_{kj}^{(k)},d_{ik}^{(k-1)}+d_{kj}^{(k-1)},d_{ik}^{(k)}+d_{kj}^{(k-1)},d_{ik}^{(k-1)}+d_{kj}^{(k)}\\}\\)这\\(4\\)组值中的某一个，我们将通过证明\\(d_{ik}^{(k-1)}=d_{ik}^{(k)},d_{kj}^{(k-1)}=d_{kj}^{(k)}\\)，从而说明这个更新是正确的。\r\n考虑先证明\\(d_{ik}^{(k-1)}=d_{ik}^{(k)}\\)。根据\\(d_{ij}^{(k)}\\)的定义：从\\(i\\)到\\(j\\)的路径中，中间节点只包含节点\\(1,2,\\dots,k\\)的最短路径。由于\\(k\\)是这条最短路径中的一个端点。\\(k\\)不在\\(d_{ik}^{(k-1)}\\)中，如果再尝试多途经一个节点\\(k\\)，那么来自路径\\(d_{ik}^{(k)}\\)的最短路径必定不会劣于\\(d_{ik}^{(k-1)}\\)（因为\\(d_{ik}^{(k-1)}\\)是\\(d_{ik}^{(k)}\\)的一个子问题）。因此有\\(d_{ik}^{(k-1)}\\ge d_{ik}^{(k)}\\)。如果\\(k\\)是从\\(i\\)到\\(k\\)这条路径的一个中间节点，那么路径上就会形成环，因此有\\(d_{ik}^{(k-1)}\\le\r\nd_{ik}^{(k)}\\)。从而得出\\(d_{ik}^{(k-1)}=d_{ik}^{(k)}\\)。\r\n可以用类似的证明方式，得到\\(d_{kj}^{(k-1)}=d_{kj}^{(k)}\\)。最终可知，这种更新方式是正确的。\r\n23.2-5\r\n由这个方式构造出来的矩阵是正确的。\r\n此处仅讨论\\(d_{ij}^{(k-1)}=d_{ik}^{(k-1)}+d_{kj}^{(k-1)}\\)时的这种情况，因为如果等号不成立，情况和方程23.8时的一致。当第\\(k\\)轮循环结束时，保证有\\(d_{ij}^{(k)}=d_{i,\\pi_{ij}}^{(k-1)}+d_{\\pi_{ij},j}^{(k-1)}\\)。\r\n本题对应的情况是\\(\\pi_{ij}^{(k)}=\\pi_{kj}^{(k-1)}\\)。由于\\(d_{ij}^{(k-1)}=d_{ij}^{(k)}=d_{ik}^{(k-1)}+d_{kj}^{(k-1)}\\)，因此\\(k\\)也可以作为从\\(i\\)到\\(j\\)某条最短路径中的一个节点，由于\\(d_{kj}^{(k-1)}\\)也是取自某条从\\(k\\)到\\(j\\)最短路径的长度，作为一条子路径，它的前驱\\(\\pi_{kj}^{(k-1)}\\)也适用于\\(\\pi_{ij}^{(k)}\\)。\r\n23.2-6\r\n如果其最终输出\\(D^{(n)}\\)的主对角线上存在负数，那么说明\\(G\\)中存在负环。因为某次\\(d^{k-1}_{ik}+d^{k-1}_{ki}&lt;0\\)的更新导致了主对角线上\\(d^{k}_{ii}\\)的值小于\\(0\\)。\r\n23.2-7\r\n由于Floyd-Warshall算法是从小到大插入中间节点\\(k\\)来求解最短路径的，因此如果节点\\(k\\)确实对从\\(i\\)到\\(j\\)的路径有实在的贡献，那么\\(\\phi^{(k)}_{ij}=k\\)，否则有\\(\\phi^{(k)}_{ij}=\\phi^{(k-1)}_{ij}\\)，也就是沿用上一次迭代的结果。更正式地可以将\\(\\Phi^{(k)}\\)写成：\r\n\\(\\phi^{(k)}_{ij}=\r\n\\left \\{\\begin{aligned}\r\n  &amp;k &amp; &amp; \\text{if}\\quad  d^{(k-1)}_{ij} &gt;\r\nd^{(k-1)}_{ik}+d^{(k-1)}_{kj} \\\\\r\n  &amp;\\phi^{(k-1)}_{ij} &amp; &amp; \\text{if}\\quad d^{(k-1)}_{ij} \\le\r\nd^{(k-1)}_{ik}+d^{(k-1)}_{kj} \\\\\r\n\\end{aligned}\\right.\\)\r\n那么可以将Floyd-Warshall算法进行改写以求出\\(\\Phi\\)，由FLOYD-WARSHALL'''给出：\r\nFLOYD-WARSHALL&#x27;&#x27;&#x27;(W, n)  D^(0) = W  for k = 1 to n    let D^(k) = (d^(k)_&#123;ij&#125;),Φ^(k) = (ϕ^(k)_&#123;ij&#125;) be new n × n matrices    for i = 1 to n      for j = 1 to n        if d^(k-1)_&#123;ij&#125; &gt; d^(k-1)_&#123;ik&#125; + d^(k-1)_&#123;kj&#125;          d^(k)_&#123;ij&#125; = d^(k-1)_&#123;ik&#125; + d^(k-1)_&#123;kj&#125;          ϕ^(k)_&#123;ij&#125; = k        else          d^(k)_&#123;ij&#125; = d^(k-1)_&#123;ij&#125;          d^(k)_&#123;ij&#125; = ϕ^(k-1)_&#123;ij&#125;  return D^(n), Φ^(n)\r\n修改后的PRINT-ALL-PAIRS-SHORTEST-PATH由程序PRINT-ALL-PAIRS-SHORTEST-PATH'给出，它需要调用一个子程序AUX-PRINT-PATH来保证路径能够被正确遍历。\r\n// 这个函数用来打印除了起点s和终点t以外的所有点。AUX-PRINT-PATH(Φ, W, n, s, t)  if ϕ_&#123;st&#125; == NIL    return  x = ϕ_&#123;st&#125;  AUX-PRINT-PATH(Φ, W, n, s, x)  print x  AUX-PRINT-PATH(Φ, W, n, x, t)PRINT-ALL-PAIRS-SHORTEST-PATH(Φ, W, n, s, t)  if ϕ_&#123;st&#125; == NIL and w_&#123;st&#125; == ∞    print &quot;no path from&quot; i &quot;to&quot; j &quot;exists&quot;  else if s == t    print s  else    print s    AUX-PRINT-PATH(Φ, W, n, s, t)    print t\r\n表\\(Φ\\)和矩阵链乘所得到的表\\(s\\)是一样的，它们表示的内容都是当前最优情况下，对对路径/乘法阶段的最优划分。然而，\\(\\Phi\\)表的路径追踪比\\(s\\)表难，因为\\(\\Phi\\)表中的元素并不能直接获得特定的前驱或者是后继节点，只能向下一步步遍历。\r\n23.2-8\r\n枚举\\(G=(V,E)\\)中的每一个节点\\(s\\)进行BFS即可，被标记的节点都是能从\\(s\\)到达的节点。枚举完\\(V\\)中所有节点得到的结构恰好就是传递闭包。\r\n整个算法由程序TRANSITIVE-CLOSURE''给出。每进行一次BFS的时间复杂度为\\(O(V+E)=O(E)\\)，因此进行\\(|V|\\)次BFS的时间复杂度为\\(O(VE)\\)。\r\nTRANSITIVE-CLOSURE&#x27;&#x27;(G)  E = ∅  for each s ∈ G.V    BFS(s)    for each v ∈ G.V      if v.color == BLACK:        E = E ∪ &#123;(s, v)&#125;  return (G.V, E)\r\n23.2-9\r\n考虑以\\(3\\)个步骤计算出有向图\\(G=(V,E)\\)的传递闭包。\r\n\r\n先花费\\(O(V+E)\\)的时间求出\\(G\\)的强连通分量，再以\\(O(V+E)\\)的时间计算出这些强连通分量的分量图\\(G^{SCC}=(V^{SCC},E^{SCC})\\)。注意到，\\(|V^{SCC}|\\le |V|,|E^{SCC}|\\le\r\n|E|\\)，并且\\(G^{SCC}\\)是一个有向无环图。\r\n使用题中算法所描述的算法求解\\(G^{SCC}\\)的传递闭包\\(G^{SCC\\ast}=(V^{SCC},E^{SCC\\ast})\\)，这将花费\\(f(|V^{SCC}|,|E^{SCC}|)\\)的时间。由于\\(f\\)是一个单调递增函数，因此说明只需要不超过\\(f(|V|,|E|)\\)的时间即可构造出\\(G^{SCC\\ast}\\)。\r\n考虑通过\\(G^{SCC\\ast}\\)来构造\\(G^{\\ast}=(V,E^{\\ast})\\)。假设求解分量图完成后，强连通分量\\(C_i\\)表示图\\(G\\)中属于这个分量的所有节点，\\(v_i\\)是\\(C_i\\)在\\(G^{SCC}\\)上对应的节点。那么首先枚举\\(C_i\\)中的所有节点，并将它们成对的边添加到\\(E^{\\ast}\\)中，每次枚举并添加一条边只需要\\(O(1)\\)的时间。对于\\(\\forall (v_i,v_j)\\in E^{SCC\\ast}\\)，\\(\\forall u\\in v_i,v\\in v_j,(u,v)\\in\r\nE^{\\ast}\\)，同样的，每次枚举并添加一条边只需要\\(O(1)\\)的时间。添加完所有边恰好需要\\(O(V+E^{\\ast})\\)的时间。\r\n\r\n因此，这\\(3\\)部分所需要花费的时间为\\(f(|V|,|E|)+O(V+E)+O(V+E^{\\ast})\\)，即可得到\\(f(|V|,|E|)+O(V+E^{\\ast})\\)。\r\n","categories":["算法导论"]},{"title":"算法导论22.5 Exercises 答案","url":"/introduction-to-algorithms/chapter-22/exercises-5/","content":"\r\n22.5-1\r\n以下是所求的另外两棵不同的最短路径树的边集：\r\n\r\n\\(E_1=\\{(s,t),(t,y),(y,x),(y,z)\\}\\)\r\n\\(E_2=\\{(s,t),(s,y),(y,x),(y,z)\\}\\)\r\n\r\n22.5-2\r\n令\\(G=(V,E),V=\\{a,b,c\\},E=\\{(a,b),(a,c),(b,c)\\},w(a,b)=0,w(a,c)=w(b,c)=1\\)。那么可以构造出两棵以\\(a\\)为根的不同的最短路径树：\r\n\r\n\\(E_1=\\{(a,b),(a,c)\\}\\)\r\n\\(E_2=\\{(a,b),(b,c)\\}\\)\r\n\r\n也就是说，对于边\\((a,c)\\)，它存在一棵最短路径树\\(T_1=(V,E_1)\\)中，但不存在\\(T_2=(V,E_2)\\)中。\r\n\r\n22.5-3\r\n我们定义在无穷上的运算：对于某个数\\(c\\)，都有\\(\\infty+c=\\infty,-\\infty+c=\\infty\\)均成立。\r\n如果从\\(s\\)到\\(u\\)最短路权重为\\(\\delta(s,u)\\)，这说明从\\(s\\)无法到达\\(u\\)。对于\\(v\\in\r\nV, (u,v)\\in E\\)，如果\\(\\delta(s,v)\\neq\r\n\\infty\\)，那么有\\(\\delta(s,u)+w(u,v)&gt;\\delta(s,v)\\)，原结论成立。如果\\(\\delta(s,v)=\\infty\\)，那么\\(\\delta(s,u)+w(u,v)=\\infty=\\delta(s,v)\\)，原结论成立。\r\n如果\\(\\delta(s,u)=-\\infty\\)，那么其某个后继节点\\(v\\)必定有\\(\\delta(s,v)=-\\infty\\)。因此\\(\\delta(s,u)+w(u,v)=-\\infty=\\delta(s,v)\\)，原结论成立。\r\n22.5-4\r\n\\(v.\\pi\\)的值被改变，当且仅当松弛操作成功，也就是有\\(u.d+w(u,v)&lt;v.d\\)时才能成功。\r\n假设现在将\\(s.\\pi\\)\r\n修改成非NIL值\\(u\\)，那么说明\\(0=s.d&gt;u.d+w(u,v)\\)。令\\(v_1,v_2,\\dots,v_k,v_1=s,v_k=u\\)是一条从\\(s\\)到\\(u\\)的路径。那么对于\\(i=2,3,\\dots,k\\)，在松弛的时刻，有\\(v_i.d=v_{i-1}.d+w(v_{i-1},v_i)\\)。随着松弛的过程继续进行，可能有\\(v_i.d\\ge v_{i-1}.d+w(v_{i-1},v_i)\\)。\r\n将这些不等式和\\(v_1.d&gt;v_k.d+w(v_k,v_1)\\)两侧一起相加，并且消去所有\\(\\cdot.d\\)的项，得到\\(\\displaystyle{\\sum_{i=2}^kw(v_{i-1},v_i)+w(v_k,v_1)&lt;0}\\)。并且由于\\(v_1=s\\)，因此节点\\(s\\)在一个负环上。\r\n22.5-5\r\n令\\(G=(V,E),V=\\{a,b,c,d\\},E=\\{(a,b),(a,c),(b,c),(c,d),(d,b)\\},w(a,b)=w(a,c)=1,w(b,c)=w(c,d)=w(d,a)=0\\)。\r\n我们令\\(b.\\pi=d,c.\\pi=b,d.\\pi=c\\)，那么可以知道\\(b,c,d\\)构成了一个环，此时的\\(G_{\\pi}\\)为所求。因为\r\n\r\n\\(a\\rightarrow c\\rightarrow d\\rightarrow\r\nb\\)是从\\(a\\)到\\(b\\)的一条最短路。\r\n\\(a\\rightarrow b\\rightarrow\r\nc\\)是从\\(a\\)到\\(c\\)的一条最短路。\r\n\\(a\\rightarrow c\\rightarrow\r\nd\\)是从\\(a\\)到\\(d\\)的一条最短路。\r\n\r\n\r\n22.5-6\r\n通过在松弛过程中使用归纳法来进行证明。\r\n在基础情况下，\\(V_\\pi\\)中只有\\(s\\)，然而从\\(s\\)到自身存在路径。\r\n现在假设进行多次松弛后，对于\\(u\\in\r\nV_\\pi\\)，从\\(s\\)到\\(u\\)都有一条路径。现在对\\((u,v)\\)进行松弛，并且\\(v\\not\\in V_{\\pi}\\)。那么此时\\(v.d=\\infty\\)，也就是说松弛操作必定成功，随后有\\(v.\\pi=u\\)。松弛完成后，根据归纳假设，从\\(s\\)到\\(u\\)有一条路径，现在通过边\\((u,v)\\)，从\\(s\\)到\\(v\\)也有一条路径，并且\\(v\\)被纳入\\(V_\\pi\\)中。\r\n因此，对于\\(\\forall v\\in\r\nV_\\pi,G_{\\pi}\\)存在一条路径从\\(s\\)到\\(v\\)中。\r\n22.5-7\r\n当构造好\\(G\\)的前驱子图\\(G_\\pi=(V,E_\\pi)\\)后，对\\(G_\\pi\\)进行BFS，可以证明边的BFS序列为所求松弛序列。将使用归纳法完成证明，假设\\(u.d&#39;\\)是从\\(s\\)到\\(u\\)在\\(G_{\\pi}\\)中的路径的边的数量。可以知道，\\(s.d&#39;=0\\)。\r\n\r\n满足\\(u.d&#39;=0\\)节点仅有一个，为\\(s\\)，此时已经满足\\(s.d=\\delta(s,s)\\)成立。\r\n假设对于某个\\(d&#39;&gt;0\\)，对于所有满足\\(u.d&#39;&lt;\r\nd&#39;\\)的节点，都已经完成了松弛（即\\(u.d=\\delta(s,u)\\)），现在正在对\\(u.d&#39;=d&#39;\\)的节点进行松弛，可以知道\\(u.\\pi.d&#39;=d&#39;-1\\)，此时已经有\\(u.\\pi.d=\\delta(s,v.\\pi)\\)，并且访问\\(u\\)在访问\\(u.\\pi\\)之后，现在通过对边\\((u.\\pi,u)\\)对\\(u\\)进行松弛，那么根据收敛性质，有\\(v.d=\\delta(s,v)\\)。\r\n\r\n因此边的BFS序列为原答案所求。\r\n22.5-8\r\n假设从\\(s\\)可达的一个负环为\\(C=(v_0,v_1,v_2,\\dots,v_k)\\)，其中\\(v_0=v_k\\)。分两个阶段构造一个无限松弛序列，如下：\r\n\r\n构造一条从\\(s\\)负环\\(C\\)的一条路径。不失一般性，假设从\\(s\\)到环\\(C\\)的第一个节点为\\(v_1\\)。由于一开始调用了INITIALIZE-SINGLE-SOURCE进行初始化，因此在这条简单路径上，每条边都成功地进行了一次松弛。\r\n构造环路\\(Q\\)：\\((v_1,v_2),(v_2,v_3),\\dots,(v_{k-1},v_k),(v_k,v_1)\\)。\r\n\r\n那么构造出来的无限松弛序列即为\\(P+Q+Q+Q+\\dots\\)\r\n由于存在负环，因此这\\(k\\)条不等式不能同时成立：\\(v_{i-1}+w(v_{i-1},v_i)\\ge v.d\\)，对于\\(i=1,2,\\dots,k\\)。\\(v_{i-1}+w(v_{i-1},v_i)\\ge v.d\\)\r\n考虑使用归纳法证明对\\(Q\\)中的边按这个顺序进行重复松弛都能成功。\r\n基础情况是，对\\(P\\)中的序列松弛完后，在松弛第一个\\(Q\\)的前\\(k-1\\)条边时，它们都将一个节点的\\(d\\)属性从\\(\\infty\\)松弛成一个有限值。\r\n归纳步骤是，从第一个\\(Q\\)的第\\(k\\)条边以及之后，假设现在即将松弛边\\((v_{i-1},v_i)\\)，可以发现\\(v_i\\)在前\\(k\\)次才被松弛过，到现在\\(v_i.d\\)还未改变。而\\(v_{i-1}.d\\)却减少了。由于在之前的第\\(j=k-1,k-2,\\dots,1\\)次都是分别对\\(v_{i+1},v_{i+2},\\dots,v_k,v_1,\\dots,v_{k-1}\\)进行了松弛，因此这\\(k-1\\)条不等式\\(v_{j-1}+w(v_{j-1},v_j)\\ge\r\nv_j.d\\)都能正确保持，并且能够取等号。那么由于\\(C\\)是负环，因此不等式\\(v_{i-1}+w(v_{i-1},v_i)\\ge\r\nv_i.d\\)不能再保持，因此此时是可以被松弛的。\r\n因此，这个松弛的顺序为题目所求。\r\n","categories":["算法导论"]},{"title":"算法导论23 Problems 答案","url":"/introduction-to-algorithms/chapter-23/problems/","content":"\r\n23-1\r\na\r\n这个更新算法由UPDATE-TRANSITIVE-CLOSURE给出。这个算法的基本思想是，在转递闭包从\\(i\\)到\\(j\\)中如果可以经过边\\((x,y)\\)到达（也就是存在\\(i\\rightarrow x\\rightarrow y\\rightarrow\r\nj\\)的路径），那么就将\\((i,j)\\)添加到\\(E^{\\ast}\\)中。由于对\\(V\\)中每个节点都进行了两层遍历，因此其时间复杂度为\\(O(V^2)\\)。\r\nUPDATE-TRANSITIVE-CLOSURE(T*, n, x, y)  for i = 1 to n    for j = 1 to n      t_&#123;ij&#125;* = t_&#123;ij&#125;* ∨ (t_&#123;ix&#125;* ∧ t_&#123;yj&#125;*)\r\nb\r\n考虑满足如下性质的图\\(G=(V,E)\\)：\r\n\r\n\\(V\\)中的所有点划分成均匀的两部分\\(V_1,V_2\\)，即\\(|V_1|=|V_2|=\\dfrac{|V|}{2}\\)。\r\n节点集合\\(V_1,V_2\\)内部是强连通的。\r\n节点集合\\(V_1,V_2\\)之间不连通。\r\n\r\n那么选择\\(u\\in V_1,v\\in\r\nV_2\\)，添加这条边到\\(E\\)中，那么就枚举\\(V_1\\)中的所有节点\\(x\\)和\\(V_2\\)中的所有节点\\(y\\)，将\\((x,y)\\)都添加到\\(E^{\\ast}\\)中，这意味着需要添加\\(\\dfrac{|V|^2}{4}\\)条边。因此无论采用什么算法更新传递闭包，其时间复杂度都满足\\(\\Omega(V^2)\\)。\r\nc\r\n首先注意到，当\\(t_{ix}^{\\ast}=0\\)时，这个循环可以跳过，因为从\\(i\\)不能到达\\(x\\)，边\\((x,y)\\)并不能对\\(i\\)的任何后继\\(t_{i\\cdot}^{\\ast}\\)做出任何改动。当\\(t_{ix}^{\\ast}=1\\)时，如果\\(t_{iy}^{\\ast}=1\\)，那么也可以跳过，因为从\\(i\\)已经可达\\(y\\)，从\\(y\\)可以到达的节点在之前就已经维护好，此时从\\(i\\)也可到达这些节点，因此边\\((x,y)\\)并没有用处。这个维护算法由UPDATE-TRANSITIVE-CLOSURE'给出。\r\nUPDATE-TRANSITIVE-CLOSURE&#x27;(T*, n, x, y)  for i = 1 to n    if t_&#123;ix&#125;* == 1 and t_&#123;iy&#125;* == 0       for j = 1 to n        if t_&#123;yj&#125;* == 1          t_&#123;ij&#125;* = 1\r\n假设每次输入的边\\((x,y)\\)是不同的，那么最多就会有\\(n(n-1)n\\)个不同的输入，\\(r\\)的最大值为\\(r=n(n-1)\\)。在这\\(r\\)次对UPDATE-TRANSITIVE-CLOSURE'调用中，到内层for循环最多可以进入\\(n(n-1)=O(n^2)\\)次，因为第2行中有一个判断\\(t_{iy}^{\\ast}=0\\)的要求，只有满足这个条件内层for循环才能进入；进入内层for循环后，当\\(j=y\\)时，\\(t_{yj}^{\\ast}=t_{yy}^{\\ast}=1\\)必定成立，因此\\(t_{iy}^{\\ast}\\)被赋值成了\\(1\\)，此后再也不能通过满足\\(t_{iy}^{\\ast}=0\\)这个条件进入内层for循环。\r\n一开始，表\\(T^{\\ast}\\)中最多只有\\(n(n-1)=O(n^2)\\)个项为\\(0\\)。因此，这\\(r\\)次调用总共的时间复杂度为\\(O(n)\\cdot O(n^2)=O(n^3)=O(V^3)\\)。\r\n23-2\r\na\r\n按照题目6-2中的结论，如果是使用\\(d\\)叉最小堆，那么调用一次INSERT和DECREASE-KEY都需要\\(O(\\log_d\r\nn)\\)的时间；而调用一次EXTRACT-MIN需要\\(O(d\\log_d n)\\)的时间。\r\n如果限定了\\(d=\\Theta(n^{\\alpha})\\)，那么调用一次INSERT和DECREASE-KEY都需要\\(O(1/\\alpha)\\)的时间；而调用一次EXTRACT-MIN需要\\(O(n^{\\alpha}/\\alpha)\\)的时间。\r\nb\r\n考虑使用Dijskra算法完成这个单源最短路算法，其内部数据结构使用的是\\(d\\)叉堆。\r\n可知它一共使用了\\(|V|\\)次INSERT操作，\\(|V|\\)次EXTRACT-MIN操作和\\(|E|\\)次DECREASE-KEY操作。那么其总时间复杂度为\\(O(V\\log_d V+Vd\\log_d V+E\\log_d V)=O(Vd\\log_d\r\nV+E\\log_d V)\\)。\r\n令\\(d=|V|^{\\epsilon}\\)，那么有\r\n\\(\\begin{aligned}\r\nO(Vd\\log_d V+E\\log_d\r\nV)&amp;=O\\left(\\dfrac{V^{1+\\epsilon}}{\\epsilon}+\\dfrac{E}{\\epsilon}\\right)\\\\\r\n&amp;=O\\left(\\dfrac{2E}{\\epsilon}\\right)\\\\\r\n&amp;=O(E)\r\n\\end{aligned}\\)\r\nc\r\n将题目23-2-b介绍的时间复杂度为\\(O(E)\\)的Dijskra算法作为子程序运行\\(|V|\\)次，那么就可以以\\(O(VE)\\)的时间求出无负权边图的全部点对的最短路径。\r\nd\r\n使用Johnson算法可以解决，大致步骤如下。\r\n\r\n通过Bellman-Ford算法可以完成\\(h\\)的计算，其时间复杂度为\\(O(VE)\\)。\r\n通过\\(h\\)，计算出新的边权权重\\(\\hat{w}\\)，这里需要花费时间\\(O(E)\\)。\r\n由于\\(\\hat{w}\\)是非负的，那么使用题目23-2-c介绍的Dijskra算法完成全部点对的最短路径计算，得到\\(D&#39;\\)，其花费的时间为\\(O(VE)\\)。\r\n根据\\(D&#39;\\)和\\(h\\)，恢复出使用\\(w\\)对应的全部点对的最短路径\\(D\\)，其花费的时间为\\(O(V^2)\\)。\r\n\r\n因此，使用Johnson算法可以以\\(O(VE)\\)的时间完成对\\(D\\)的计算。\r\n","categories":["算法导论"]},{"title":"算法导论21.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-21/exercises-1/","content":"\r\n21.1-1\r\n假设图\\(G\\)的一个最小生成树\\(T\\)不包含\\((u,v)\\)，那么可以构造出一个切割\\((S,V-S)\\)使得\\(u\\in S,v\\in V-S\\)，使得这个切割对\\(T\\)的某一个子集\\(A\\)是遵循的，也就是说\\((u,v)\\)横跨这个切割。\r\n那么，由于\\((u,v)\\)是一条轻边，那么根据定理20.1，\\(A\\cup\\{(u,v)\\}\\)仍然是安全的。因此\\((u,v)\\)是某个最小生成树的边。\r\n21.1-2\r\n令\\(G=(V,E),V=\\{a,b,c,d\\},E=\\{(a,b),(b,c),(c,d)\\},w(a,b)=1,w(b,c)=2,w(c,d)=3\\)。\r\n那么\\(G\\)的最小生成树就是它本身（因为\\(G\\)就是一棵树）。\r\n令\\(A=\\{(b,c)\\},S=\\{b,c\\}\\)，那么有\\(V-S=\\{c,d\\}\\)。也就是说，边\\((a,b),(c,d)\\)都横跨了这个切割。实际上，这两条边都是\\(G\\)的最小生成树的必不可少的边，因此这两条边都是安全的，那么边\\((c,d)\\)的权值不是最小，因此结论不正确。\r\n\r\n21.1-3\r\n我们将使用反证法进行证明。令\\(T\\)是\\(G\\)的一颗包含边\\((u,v)\\)的最小生成树。令\\(T_1,T_2\\)是从\\(T\\)删去\\((u,v)\\)后形成的两棵树，\\(V_1,V_2\\)分别表示这两棵树的节点集合，那么\\((V_1,V_2)\\)就是所求切割。接下来使用反证法证明\\((u,v)\\)是这个切割的一条轻边。如果存在\\(a\\in V_1,b\\in V_2\\)使得\\(w(a,b)&lt;w(u,v)\\)，那么通过\\((a,b)\\)连接这两棵树\\(T_1,T_2\\)，可以得到一个比\\(T\\)更优秀的最小生成树，这明显是错误的。因此，这时\\((u,v)\\)是切割\\((V_1,V_2)\\)的轻边。\r\n21.1-4\r\n令\\(G=(V,E),V=\\{a,b,c,d\\},E=\\{(a,b),(b,c),(c,d),(a,d)\\},w(a,b)=w(b,c)=1,w(c,d)=w(d,a)=2\\)。\r\n那么对于\\(S=\\{a,b\\}\\)这个得到的切割，\\((b,c)\\)所求边，\\((a,b)\\)也类似。\r\n对于\\(S=\\{a,b,c\\}\\)这个得到的切割，\\((a,d),(c,d)\\)都有成为轻边的可能性。\r\n因此，这个集合在这个例子中就相当于\\(E\\)。然而\\(G=(V,E)\\)并不是最小生成树。\r\n\r\n21.1-5\r\n这里题目需要给定一个前提：\\(e\\)不是桥。\r\n当求出\\(G&#39;=(V,E-\\{e\\})\\)的最小生成树\\(T\\)后，构造一个遵循\\(T\\)的某个子集\\(A\\)的切割\\((S,V-S)\\)，并且边\\(e\\)横跨这个切割。可以发现，对于任意满足条件如上的切割，边\\(e\\)的权值都不是所有横跨中最小的一个。因此从\\(A\\)添加\\(e\\)不是安全的，所以\\(G\\)中存在一棵不包含\\(e\\)的最小生成树。\r\n21.1-6\r\n使用反证法来证明这个结论。假设图\\(G\\)有两棵不相同的最小生成树\\(T_1,T_2\\)。那么存在两条边\\((u,v),(a,b)\\in E\\)，满足\\((u,v)\\)仅存在\\(T_1\\)中，\\((a,b)\\)仅存在\\(T_2\\)中。令\\(S=\\{a,u\\}\\)，那么在切割\\((S,V-S)\\)中存在唯一一条的轻边。不失一般性，如果这条边是\\((a,b)\\)（另一种情况则是\\((u,v)\\)。），那么我们可以将\\(T_1\\)中路径\\(a-b\\)上另一条横跨\\((S,V-S)\\)的边删去，并补上\\((a,b)\\)这条边，那么我们得到了一个比原来更优的最小生成树\\(T_1&#39;\\)。然而\\(T_1,T_2\\)本身就是最小生成树，这是不可能的。因此最小生成树唯一。\r\n令\\(G=(V,E),V=\\{a,b,c,d\\},E=\\{(a,b),(b,c),(c,d)\\},w(a,b)=w(b,c)=w(c,d)=1\\)。那么\\(G\\)的唯一一个最小生成树明显就是它自身。\r\n并且，对于切割\\((\\{b,c\\},\\{a,d\\})\\)，一共有两条轻边\\((a,b),(c,d)\\)，这不是唯一的轻边。\r\n\r\n21.1-7\r\n本题采用反证法进行证明。对于图\\(G\\)中的某一个连接所有节点的最小权值和边集\\(A\\)，如果它不是一棵树，那么必定存在一个环\\(C\\)，对这个环去除任意一条边\\((u,v)\\)，并不影响整个图的连通性；并且由于\\(w(u,v)&gt;0\\)，去除这条边的边集权值和更小，并且不影响整个图的连通性，这和\\(A\\)有最小权值和是矛盾的。因此原结论成立。\r\n如果边权是负数，那么结论不成立。令\\(G=(V,E),V=\\{a,b,c\\},E=\\{(a,b),(b,c),(a,c)\\},w(a,b)=w(b,c)=w(a,c)=-1\\)。按照上面的结论，最小边集权值和的一棵树为\\(-2\\)。然而实际上具有最小边集权值和的是\\(E\\)本身，为\\(-3\\)。\r\n\r\n21.1-8\r\n这题想表达的意思是，对于\\(G\\)的所有最小生成树\\(T=(V,E&#39;)\\)，无序多重集\\(\\{w(x,y)\\mid (x,y)\\in\r\nE&#39;\\}\\)总是同一个集合。\r\n假设\\(G\\)的两棵不同的最小生成树\\(T,T&#39;\\)的边权有序列表为\\(L,L&#39;\\)，并且\\(L\\neq\r\nL&#39;\\)。不失一般性，可以找到一个最小的\\(i\\in[1,|V|)\\)，使得\\(w(L[i])&lt;\r\nw(L&#39;[i])\\)成立（可以知道，\\(L\\)之后有一条边的边权会比\\(L&#39;\\)中对应的边权大，以保证\\(T,T&#39;\\)都是最小生成树）。\r\n将边\\(L[i]=(u,v)\\)加入\\(T&#39;\\)后形成了一个图\\(G&#39;\\)，可以发现\\(G&#39;\\)有且仅有一个经过边\\((u,v)\\)的环\\(C&#39;\\)。那么我们可以得出结论：环\\(C&#39;\\)上的所有边的边权不能超过\\(w(u,v)\\)；因为如果存在这条边，我们去掉之后就能得到比\\(T&#39;\\)更优的最小生成树，这是不可能的。\r\n那么，环\\(C&#39;\\)上的所有边的边权都不能超过\\(w(u,v)\\)。那么我们假设\\(C&#39;\\)上处\\((u,v)\\)外其它边的边权全部严格小于\\(w(u,v)\\)。令\\(T_1,T_2\\)是从\\(T\\)删去\\((u,v)\\)后形成的两棵树，\\(V_1,V_2\\)分别表示这两棵树的节点集合。考虑切割\\((V_1,V_2)\\)，那么\\(C&#39;\\)必定存在\\(2\\)条边横跨这个切割（一条是\\((u,v)\\)，假设另一条是\\((a,b)\\)）。那么由于\\(w(a,b)&lt;w(u,v)\\)，因此\\((a,b)\\)是一条轻边，而\\((u,v)\\)不是。那么对\\(T\\)去掉边\\((u,v)\\)并补上边\\((a,b)\\)就可以得到一棵比\\(T\\)更优秀的最小生成树，这是不可能的。因此，\\(C\\)中总有些边的权值和\\(w(u,v)\\)相同。\r\n假设边\\((a,b)\\)和边\\((u,v)\\)的权值相同，那么对\\(T&#39;\\)，我们可以将\\((a,b)\\)边替换成\\((u,v)\\)边，这不影响\\(T&#39;\\)仍是一棵最小生成树，但是\\(T\\)和\\(T&#39;\\)的公共边数增加了\\(1\\)。经过了足够的迭代次数后，\\(T\\)将会和\\(T&#39;\\)相等，这和\\(L=L&#39;\\)是矛盾的。因此原结论成立。\r\n21.1-9\r\n使用反证法证明。如果\\(T&#39;=(V&#39;,E&#39;)\\)不是\\(G&#39;\\)的最小生成树，那么也就是说\\(G&#39;\\)存在一棵更好的最小生成树\\(T&#39;_1=(V&#39;,E&#39;_1)\\)使得边权总和更低。那么我们可以使用\\(T&#39;\\)构造\\(G\\)上的另一棵生成树：\\(T_1=(V,(E-E&#39;)\\cup\r\nE_1&#39;)\\)。可以发现，\\(E-E&#39;\\)是和诱导子图\\(G&#39;\\)无关的所有边，而\\(E_1&#39;\\)则是来自\\(T_1\\)中连通\\(G&#39;\\)的所有边。因此\\(T_1\\)仍然是一棵树，并且其边权总和比已知的最小生成树要好，这是不可能的。因此原结论成立。\r\n21.1-10\r\n令\\(T=(V,E&#39;)\\)表示原本图\\(G\\)的最小生成树，\\(T_1,T_2\\)是从\\(T\\)删去\\((x,y)\\)后形成的两棵树，\\(V_1,V_2\\)分别表示这两棵树的节点集合，那么构造出的切割\\((V_1,V_2)\\)可以知道是对\\(\\{E&#39;-(x,y)\\}\\)遵循的，因此\\((x,y)\\)在这个切割中是轻边。由于\\(w&#39;(x,y)=w(x,y)-k&lt;w(x,y),\\forall (u,v)\\neq\r\n(x,y),w&#39;(u,v)=w(u,v)\\)，因此采用\\(w&#39;\\)后，\\((x,y)\\)仍然是这个切割的轻边。因此将它加入集合\\(E&#39;-\\{x,y\\}\\)仍然是安全的。因此原来的树\\(T\\)仍然是最小生成树。\r\n\\(\\star\\)\r\n21.1-11\r\n如果再添加这条边\\((u,v)\\)到最小生成树\\(T\\)中，那么这条边将会和\\(T\\)上从\\(u\\)到\\(v\\)的路径形成一个环，那么我们只需要从这个环上去掉其中一条最大边权的边就可以得到新的MST。我们只需要检索这个环上所有路径的权值即可。具体算法由程序NEW-MST给出，其时间复杂度为\\(O(V)\\)。\r\n// 实际上，这个算法不需要用到原图G。NEW-MST(T, u, v, k)  let p be the path from u to v in T  let (x, y) be an edge in T.E s.t. w(x, y) is maximum  if k &lt; w(x, y)    如果这条最大权值的边确实比新的边权值大，那么就需要去掉。    INSERT(T.E, (u, v))    REMOVE(T.E, (x, y))  return T.E\r\n","categories":["算法导论"]},{"title":"算法导论21.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-21/exercises-2/","content":"\r\n21.2-1\r\n对于\\(G\\)中的任意一个最小生成树\\(T\\)，为了通过Kruskal算法得到\\(T\\)，对于相等权值下的边，在\\(T\\)中的应该先被遍历，不在\\(T\\)中的后被遍历。根据题目21.1-8的结论，如果\\(e\\in\r\nT\\)那么这条边必定是当前边集下所添加的安全边。最终，不属于\\(T\\)的所有边不会将两棵树进行连通。那么对边经过这样的排序后，使用Kruskal算法得到的最小生成树恰好为\\(T\\)。\r\n21.2-2\r\n如果使用邻接矩阵存储这个图\\(G\\)，那么我们不使用优先队列表示这个key属性，反而是直接存储起来，每次找到仍然未被添加到树中的点的最小key值。这个算法由程序MST-PRIM'给出。嵌套的两层对\\(V\\)的遍历，可以知道这个算法的时间复杂度为\\(O(V^2)\\)。\r\nMST-PRIM&#x27;(G, w, r)  for each vertex u ∈ G.V    u.key = ∞    u.π = NIL    u.vis = False  r.key = 0  for i = 1 to |V|    get node u s.t. u.key is minimum and u.vis == False    u.vis = True    for each vertex v ∈ G.V      if v.vis == False and w(u, v) &lt; v.key        v.key = w(u, v)        v.π = u  \r\n21.2-3\r\n主要瓶颈在于第8-14行的while循环执行了\\(|E|\\)次DECREASE-KEY操作。\r\n当图\\(G\\)是稀疏图，即\\(|E|=\\Theta(V)\\)时。如果使用斐波那契堆，那么整个Prim算法的时间复杂度为\\(O(E+V\\lg V)=O(V+V\\lg V)=O(V\\lg\r\nV)\\)。如果直接使用二叉堆，同样整个Prim算法的时间复杂度为\\(O(E\\lg V)=O(V\\lg\r\nV)\\)。此时使用斐波那契堆和使用二叉堆具有相同的渐进时间。\r\n当图\\(G\\)是稠密图，即\\(|E|=\\Theta(V^2)\\)时。如果使用斐波那契堆，那么整个Prim算法的时间复杂度为\\(O(E+V\\lg V)=O(V^2+V\\lg\r\nV)=O(V^2)\\)。如果直接使用二叉堆，同样整个Prim算法的时间复杂度为\\(O(E\\lg V)=O(V^2\\lg\r\nV)\\)。此时使用斐波那契堆要高效于使用二叉堆。\r\n如果使用斐波那契堆优化是有效的，即\\(O(E+V\\lg V)\\)增长得比\\(O(E\\lg V)\\)慢，那么有\\(|E|=\\omega(V)\\)才能保证。\r\n21.2-4\r\n如果所有边的边权是\\([1,|V|]\\)之间的整数，那么Kruskal算法的时间复杂度可以优化到\\(O(E+V)\\)。因为Kruskal算法的瓶颈主要在于对所有边按照边权进行排序。如果整数都在这个区间，那么我们可以使用计数排序对这些边以\\(O(E+V)\\)的时间进行排序。\r\n同样的，如果边的权值的最大值为\\(W\\)，那么我们需要综合考虑\\(W\\)的值来选择使用快速排序还是计数排序来对边进行排序；前者的时间复杂度为\\(O(E\\lg V)\\)，后者则为\\(O(E+W)\\)。\r\n21.2-5\r\n其中一种做法是，使用\\(|V|+1\\)个槽来按照key值装入节点。（当key值为无穷大时装入最后一个节点）。随着每次DECREASE-KEY操作进行，可以以\\(O(1)\\)的时间将节点从对应的槽取出来，并插入更新后的槽中。然而，取出最小节点操作EXTRACT-MIN需要\\(O(V)\\)的时间进行。因此整个算法的时间复杂度为\\(O(V^2+E)=O(V^2)\\)。\r\n如果范围值是从\\(1\\)到\\(W\\)，那么就需要维护\\(W+1\\)个槽来放置这些节点，并且用一个双向有序链表来维护这些非空的槽，那么仍然需要\\(O(V^2+M+E)=O(V^2+W)\\)。\r\n综上所述，边权离散化且很小这个性质并不能很好的被Prim算法使用，还不如直接使用优先队列来维护每个节点的出队时机key。\r\n# 21.2-6\r\n该算法不正确。\r\n令\\(G=(V,E),V=\\{a,b,c\\},E=\\{(a,b),(b,c),(a,c)\\},w(a,b)=w(b,c)=1,w(a,c)=2\\)。\r\n如果一开始分治的划分方法是\\(V_1=\\{b\\},V_2=\\{a,c\\}\\)，那么在递归求解点集\\(V_2\\)在\\(G\\)上的诱导子图的最小生成树时，边\\((a,c)\\)就会被加入。然而实际上，边\\((a,c)\\)不能够作为最小生成树的边。因此这个算法是错误的。\r\n\r\n\\(\\star\\)\r\n21.2-7\r\n如果所有边权都是位于\\([0,1)\\)中，那么使用桶排序可以将Kruskal算法的平均时间复杂度优化到\\(O(E+V)\\)。与题目21.2-4类似，这种情况降低了对边按照边权进行排序所需要的时间。\r\n然而，Prim算法无法充分使用这个边权性质，因此在这种情况下，Kruskal算法的运行速度比Prim算法快。\r\n\\(\\star\\)\r\n21.2-8\r\n首先需要证明一个结论：假设图\\(G&#39;=(V&#39;,E&#39;)\\)是\\(G=(V,E)\\)的一个子图，\\(T&#39;=(V&#39;,E_T&#39;)\\)是\\(G&#39;\\)的一棵最小生成树，那么存在一个图\\(G\\)的最小生成树，它不包含\\(E&#39;-E_T&#39;\\)中的任意一条边。这个结论是为了说明，原来的边已经不使用了，那么到后面这些边也是多余的。\r\n证明：根据题目21.2-1的结论，存在一个对\\(E&#39;\\)的遍历顺序\\(L&#39;\\)，使得Kruskal算法构造出来的树就是所需要的树\\(T&#39;\\)。那么我们考虑将\\(E-E&#39;\\)这些边添加到\\(L&#39;\\)中，排序后形成遍历顺序\\(L\\)，并且确保\\(L\\)中原本属于\\(L&#39;\\)的边的相对顺序相同。那么对于\\(e\\in E&#39;-E_T&#39;\\)，假设它在\\(L&#39;\\)中的序号为\\(i&#39;\\)，在\\(L\\)中的序号为\\(i\\)。那么可以知道\\(i&#39;\\le i\\)。当Kruskal算法求\\(G&#39;\\)的最小生成树时，遍历到序号为\\(i\\)的边，由于\\(e\\notin E_T&#39;\\)，这说明此时\\(e\\)两端的节点已经是连通的。此时考虑Kruskal算法求\\(G\\)的最小生成树，遍历到序号为\\(i&#39;\\)的边，按照上面对\\(L\\)的构造可知，边\\(L&#39;[1:i&#39;-1]\\)都在\\(L[1:i-1]\\)中出现过，因此到了这个时间，\\(L[i]\\)的两个端点必定也是已经连通的。因此\\(e\\)在\\(G\\)中也不会成为最小生成树的边。因此原结论成立。\r\n最终，这个题目所求的算法是：将\\(G=(V,E)\\)中给定的某棵最小生成树\\(T=(V,E_T)\\)中的所有边和新加入的所有边构成一个新图\\(G&#39;&#39;=(V&#39;&#39;,E&#39;&#39;)\\)，再对\\(G&#39;&#39;\\)执行一次Kruskal算法得到的就是所求的一棵最小生成树。由于\\(|V&#39;&#39;|=|V|+1,|E&#39;&#39;|\\le\r\n2|V|-1\\)，因此这个更新操作的时间复杂度为\\(O(V\\lg V)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论21 Problems 答案","url":"/introduction-to-algorithms/chapter-21/problems/","content":"\r\n21-1\r\na\r\n题目21.1-8给出，对于图\\(G\\)中的每棵最小生成树\\(T\\)，其边权有序列表总是唯一的。由于本题中已经认定原图\\(G\\)的边权互不相同，因此求出一个最小生成树\\(T\\)后，对应构造出的列表\\(L\\)是唯一的，因此最小生成树是唯一的。\r\n令图\\(G\\)的权值邻接矩阵如下：\r\n\\(\\begin{array}{|l|l|l|l|l|}\\hline\r\n&amp;a&amp;b&amp;c&amp;d\\\\\\hline\r\na&amp;-&amp;1&amp;3&amp;5\\\\\\hline\r\nb&amp;1&amp;-&amp;2&amp;4\\\\\\hline\r\nc&amp;3&amp;2&amp;-&amp;-\\\\\\hline\r\nd&amp;5&amp;4&amp;-&amp;-\\\\\\hline\r\n\\end{array}\\)\r\n可以发现，边集\\(\\{(a,b),(b,c),(b,d)\\}\\)是最小生成树的边集，边权总和为\\(7\\)，而\\(\\{(a,b),(b,c),(a,d)\\}\\)和\\(\\{(a,b),(a,c),(b,d)\\}\\)是两棵不同的次小生成树，边权总和为\\(8\\)。如下图所示：\r\n\r\nb\r\n对于\\((u,v)\\in E_T\\)，令从\\(T=(V,E_T)\\)删除后连通的两部分边集\\(V_1,V_2\\)。对于切割\\((V_1,V_2)\\)，由于\\((u,v)\\)是轻边，那么说明将横跨这个切割的边\\((u,v)\\)添加到\\(E_T-\\{(u,v)\\}\\)是安全的。对于其它边都是不安全的，选择一条不安全的边添加到\\(E_{T}-\\{(u,v)\\}\\)中也构成了一个树结构。假设在这些边中，边权最小的是\\((a,b)\\)，那么\\((E_T-\\{(a,b)\\})\\cup\\{(a,b)\\}\\)就是一颗备选的最小生成树（其它边构成的新树都不可能是次小生成树，因为它们比\\((a,b)\\)边权更大，更不安全）。\r\nc\r\n我们可以使用动态规划的过程以\\(O(V)\\)的时间复杂度计算\\(\\max[u,\\cdot]\\)的所有值。由于树中没有环，并不会产生循环依赖，因此我们可以写出计算\\(\\max[u,v]\\)的状态转移方程：\r\n\\(\\max[u,v]=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0 &amp; &amp; \\text{if}\\quad  u=v \\\\\r\n  &amp;\\max\\{\\max[u,x],w(x,v)\\} &amp; &amp; \\text{if}\\quad  u\\neq v \\\\\r\n\\end{aligned}\\right.\\)\r\n其中节点\\(x\\)是\\(T\\)上从\\(u\\)到\\(v\\)这条路径上的倒数第二个节点。也就是说，\\(\\max[u,v]\\)要么是从\\(u\\)到\\(x\\)这条路径上的边权最大值，要么是\\((x,v)\\)的边权。因此，通过对这棵树进行BFS，最终能够以\\(O(V)\\)的算法计算出所有\\(\\max[u,\\cdot]\\)的值，这个算法由程序BFS-DIS给出。\r\n最终，枚举所有起点\\(s\\)，我们可以以\\(O(V^2)\\)的时间计算出所有\\(\\max[\\cdot,\\cdot]\\)的值，其通过程序CAL-DIS给出。\r\nBFS-DIS(T, s, w)  for each vertex u ∈ T.V - &#123;s&#125;    u.d = ∞    u.π = NIL  s.d = 0  s.π = NIL  Q = ∅  ENQUEUE(Q, s)  while Q != ∅     u = DEQUEUE(Q)    for each vertex v in T.Adj[u]     // search the neighbors of u      if v.d == ∞                     // is v being discovered now?        v.d = u.d + w(u, v)        v.π = u        ENQUEUE(Q, v)                  // v is now on the frontierCAL-DIS(T, w)  let max be new 2-dimension array  for each vertex u ∈ T.V    BFS-DIS(T, u, w)    for each vertex v ∈ T.V      max[u, v] = v.d  return max\r\nd\r\n通过题目21-1-c给出的CAL-DIS算法，我们可以给出求次小生成树的算法。其思想是，枚举所有不属于最小生成树\\(T=(C,E_T)\\)的边\\((u,v)\\)，并尝试将其添加到\\(T\\)中，那么树\\(T\\)和边\\((u,v)\\)就形成了一个环\\(C\\)，因此需要在\\(C\\)中删除一条除\\((u,v)\\)以外的边权最大的边，以使得增加的边权值最小（虽然是严格增加了）。整个算法由程序2ND-MST给出，其关键瓶颈在于计算\\(\\max[\\cdot,\\cdot]\\)，整个算法的时间复杂度为\\(O(V^2)\\)。\r\n2ND-MST(G, w)  // 首先求出一棵最小生成树  T.V, T.E = G.V, MST-KRUSKAL(G)  max = CAL-DIS(T, w)  // 次小生成树比最小生成树多出的边权总和值。  new-dif = ∞  create a single list of the edges in G.E  for each edge (u, v) taken from the list    if (u, v) not in T.E      dif = w(u, v) - max[u, v]      if dif &lt; new-dif        (mu, mv) = (u, v)        new-dif = dif  remove the edge e from T.E s.t. e is in path(mu, mv) and w(e) is maximum  INSERT(T.E, (mu, mv))  return T\r\n接下来给出一种基于LCA（最近公共祖先）倍增的做法。首先需要以\\(O(V\\lg V)\\)的时间对\\(T\\)预处理出两个表（这里需要对\\(T\\)指定一个根）：\\(fa[u,i]\\)表示\\(u\\)的第\\(2^i\\)个祖先，\\(m[u,i]\\)表示\\(\\max[u,fa[u,2^i]]\\)的值。\r\n那么接下来对于所有边\\((u,v)\\in\r\nE-E_T\\)，以\\(O(\\log\r\nV)\\)的时间在表\\(fa\\)上计算它们的LCA：\\(l\\)，并且计算出\\(\\max[u,l]\\)和\\(\\max[v,l]\\)的值，最终以\\(O(\\lg V)\\)的时间计算出\\(\\max[u,v]\\)的值。因此这个算法可以以\\(O(E\\lg V)\\)的时间复杂度求出次小生成树。\r\n21-2\r\na\r\n也就是说，证明由算法MST-REDUCE和MST-PRIM联合所生成的边集是最小生成树的边。\r\n对于算法MST-REDUCE生成的边集\\(T\\)，假设当前第4行代码正在访问的节点是\\(u\\)，那么考虑切割\\((\\{u\\},V-\\{u\\})\\)，第6行所选定的边是横跨切割\\((\\{u\\},V-\\{u\\})\\)并且是一条轻量级边，因此是安全的。此外将这两个节点通过这条边收缩起来，以后它们统一视为一个节点。\r\n算法MST-PRIM接受输入的是来自MST-REDUCE的输出图\\(G&#39;\\)。由于所有树边已经被收缩成一个节点，因此仍未收缩的边将会连通任意一个不同代表节点。对这些剩余边进行最小生成树算法将会得到剩下的安全边。因此$\r\nT {(x, y).orig′ : (x, y) ∈ A}\\(是\\)G$的一棵最小生成树。\r\nb\r\n首先可以发现\\(|G&#39;.V|+|T|=|V|\\)。因为\\(T\\)中每产生一条边，\\(G\\)中就会有\\(2\\)个节点被合并成一个，也就是说，节点数降低了\\(1\\)。\r\n当第5行代码if条件成功进入时，第10行代码有可能会另一个端点\\(v\\)从未标记变成已标记，这意味着以后并不能再产生一条边加入\\(T\\)中。因此有\\(|T|\\ge |V|-|T|\\)，也就是说，有\\(|T|\\ge |V|/2\\)。因此得到\\(|G&#39;.V|\\le |V|/2\\)。\r\nc\r\n使用一个长度为\\(|V|\\)的数组\\(A\\)可以代替并查集操作。花费时间\\(O(V)\\)对数组\\(A\\)初始化成A[u] = u，对于所有\\(V\\)中的节点\\(u\\)。FIND-SET(u)可以使用A[u]替代，UNION(u, v)可以用A[v] = A[u]替代（注意不可以反过来）。这种做法成立的原因是，可以直接访问当前连通块中的代表元素。最终，算法MST-REDUCE可以\\(O(E)\\)的时间完成。\r\nd\r\n每一次调用则意味着对这个图进行一次\\(O(E)\\)的操作，虽然节点数至少减少了一半，但是边数减少的数量也仅仅至少是节点数的减少量。因此\\(k\\)次调用意味着\\(O(kE)\\)的时间复杂度。\r\ne\r\n进行\\(k\\)次调用后，那么整个图的节点数最多为\\(\\dfrac{|V|}{2^k}\\)。因此我们需要选择\\(k\\)来使得\\(|E|+\\dfrac{|V|}{2^k}\\lg\\dfrac{|V|}{2^k}+kE=O(|E|\r\n\\lg\\lg |V|)\\)。题目给定的因子\\(\\lg\\lg\r\nB\\)提示我们考虑验证取值\\(k=\\lg\\lg\r\n|V|\\)是成立的。那么有\r\n\\(\\begin{aligned}\r\n|E|+\\dfrac{|V|}{2^k}\\lg\\dfrac{|V|}{2^k}+kE&amp;=|E|+\\dfrac{|V|}{\\lg\r\n|V|}\\lg\\dfrac{|V|}{\\lg |V|}+|E|\\lg\\lg |V|\\\\\r\n&amp;=\\dfrac{|V|}{\\lg |V|}\\lg\\dfrac{|V|}{\\lg |V|}+O(|E|\\lg\\lg |V|)\\\\\r\n&amp;=\\dfrac{|V|}{\\lg |V|}(\\lg |V|-\\lg\\lg |V|)+O(|E|\\lg\\lg |V|)\\\\\r\n&amp;=|V|-\\dfrac{|V|\\lg\\lg |V|}{\\lg |V|}+O(|E|\\lg\\lg |V|)\\\\\r\n&amp;=|V|+O(|E|\\lg\\lg |V|)\\\\\r\n&amp;=O(|E|\\lg\\lg |V|)\r\n\\end{aligned}\\)\r\nf\r\n如果这种带预处理的操作优于没有带预处理的操作，那么有\\(|E|\\lg\\lg |V|&lt;|E|+|V|\\lg\r\n|V|\\)，也就是得到\\(|E|&lt;\\dfrac{|V|\\lg\r\n|V|}{\\lg\\lg |V|-1}\\)。因此最终有\\(|E|=O\\left(\\dfrac{|V|\\lg |V|}{\\lg\\lg\r\n|V|}\\right)\\)。\r\n21-3\r\nA\r\n算法MAYBE-MST-A返回的是一个最小生成树。当我们按边权从大到小访问这些边\\((u,v)\\)时，考虑两种情况：\r\n\r\n\\((u,v)\\)没有被删去。这说明如果\\((u,v)\\)被删去了，这个图就不连通了，为保证\\(T\\)中的边连通，\\((u,v)\\)必须留下。\r\n\\((u,v)\\)成功被删去了。令\\((V_1,V_2)\\)是被边\\((u,v)\\)横跨的一个切割。由于删去\\((u,v)\\)后，\\(T\\)仍然连通，因此在这个时候，仍然有从\\(u\\)到\\(v\\)的一条路径，也就是说存在其它边\\((a,b)\\)仍然横跨\\((V_1,V_2)\\)。这条边仍然是未被迭代的，因此\\((a,b)\\)在切割\\((V_1,V_2)\\)中至少比\\((u,v)\\)安全。因此可以删去这条边。\r\n\r\n算法MAYBE-MST-A的实现依赖于判断图\\(T\\)的连通性，第4行的伪代码直接进行判断。逆序遍历每一条边然后删除边后判断\\(T\\)的连通性，这一次判断过程需要\\(O(V+E)\\)的运行时间。因此整个算法需要\\(O(E^2)\\)的运行时间。\r\nB\r\n算法MAYBE-MST-B返回的不是一个最小生成树。令\\(G=(V,E),V=\\{a,b,c\\},E=\\{(a,b),(b,c),(a,c)\\},w(a,b)=1,w(a,c)=2,w(b,c)=3\\)。如下图所示：\r\n\r\n如果边\\((b,c)\\)先被访问，那么它们就被添加到了树边集合\\(T\\)中，构成的\\(T\\)永远不会是最小生成树。因此算法MAYBE-MST-B是错误的。\r\n算法MAYBE-MST-B的实现依赖于并查集，只需要和Kruskal算法一样，边判断两个端点是否属于同一集合边合并即可。程序MAYBE-MST-B的具体实现由程序MAYBE-MST-B'给出，其时间复杂度为\\(O(E)\\)。\r\nMAYBE-MST-B&#x27;(G, w)  A = Ø  for each vertex v ∈ G.V    MAKE-SET(v)  create a single list of the edges in G.E  for each edge (u, v) taken from the list    if FIND-SET(u) ≠ FIND-SET(v)      A = A ∪ &#123;(u, v)&#125;      UNION(u, v)  return A\r\nC\r\n算法MAYBE-MST-C返回的是一个最小生成树。当我们按任意顺序访问并添加这些边\\((u,v)\\)到\\(T\\)后，考虑两种情况：\r\n\r\n\\(T\\)中没有环，这说明\\((u,v)\\)是所必须要的边。\r\n\\(T\\)中产生了环\\(C\\)，令\\((a,b)\\)是\\(c\\)中最大边权的那条边。令\\((V_1,V_2)\\)是被边\\((a,b)\\)横跨的一个切割，那么可以知道，环\\(C\\)上有另外一条边\\((x,y)\\)横跨切割\\((V_1,V_2)\\)。由于\\((a,b)\\)的边权是最大的，因此有\\(w(x,y)\\le w(a,b)\\)。也就是说，\\((x,y)\\)在这个切割中肯定比\\((a,b)\\)安全，因此可以删去\\((a,b)\\)这条边。\r\n\r\n算法MAYBE-MST-C的实现依赖于求出\\(C\\)中从\\(u\\)到\\(v\\)的这条路径。程序MAYBE-MST-C的具体实现由程序MAYBE-MST-C'给出，每次进行求解路径的时间复杂度为\\(O(V)\\)。因此整个算法需要\\(O(VE)\\)的运行时间。\r\nMAYBE-MST-C&#x27;(G, w)  A = Ø  for each vertex v ∈ G.V    MAKE-SET(v)  create a single list of the edges in G.E  for each edge (u, v) taken from the list    A = A ∪ &#123;(u, v)&#125;    if FIND-SET(u) ≠ FIND-SET(v)        UNION(u, v)    else:      get the cycle C where edge (u, v) in      select the edge e from C s.t. w(e) is maximum      A = A - &#123;e&#125;  return A\r\n21-4\r\na\r\n令\\(T\\)是\\(G\\)中的最小生成树，\\(T&#39;\\)是\\(G\\)中的一棵瓶颈生成树。假设\\(T\\)不是瓶颈生成树，也就是\\(T\\)中存在一条边\\((u,v)\\)，使得\\(w(u,v)&gt;m\\)，其中\\(m\\)是瓶颈生成树的最大边权值。那么令\\(T_1,T_2\\)是从\\(T\\)删去\\((u,v)\\)后形成的两棵树，\\(V_1,V_2\\)分别表示这两棵树的节点集合。考虑切割\\((V_1,V_2)\\)，由于\\(T&#39;\\)是连通的，因此必定存在一条边\\((a,b)\\)横跨\\((V_1,V_2)\\)。由于\\(w(a,b)\\le m&lt;w(u,v)\\)，因此边\\((a,b)\\)比边\\((u,v)\\)更安全，也就是说，从\\(T\\)删去\\((u,v)\\)并加上\\((a,b)\\)后，将会得到一棵更优的最小生成树，这是矛盾的。因此最小生成树是瓶颈生成树。\r\nb\r\n只要一个图\\(G\\)是连通的，那么我们总能找到一棵生成树。因此该问题的本质上是判断图\\(G\\)中小于等于\\(b\\)的所有边是否构成\\(G\\)中的一个连通图。我们通过改造BFS算法即可以以\\(O(V+E)\\)的时间复杂度判断\\(b\\)值是否可行。这个算法由程序CHECK-NECKBOTTLE-BOUND给出。\r\nCHECK-NECKBOTTLE-BOUND(G, w, b)  for each vertex u ∈ G.V    u.d = ∞    u.π = NIL  select s ∈ G.V randomly  s.d = 0  s.π = NIL  Q = ∅  ENQUEUE(Q, s)  while Q != ∅     u = DEQUEUE(Q)    for each vertex v in G.Adj[u]      if v.d == ∞ and w(u, v) &lt;= b                         v.d = u.d + 1        v.π = u        ENQUEUE(Q, v)\r\nc\r\n我们将使用子程序BST-REDUCE对所有满足\\(w(u,v)\\le\r\nb\\)的边进行收缩，整个过程的时间复杂度为\\(O(E)\\)，因为它遍历了两次所有边，第一次遍历是将所有满足\\(w(u,v)\\le\r\nb\\)中的边收缩成点，第二次遍历则是将满足\\(w(u,v)&gt; b\\)映射到新图中的点。\r\n主程序由GEN-NECKBOTTLE-TREE给出，它使用了第9章的算法来求中位数，并划分所有边。可以发现，第6行的while循环迭代一轮后，图\\(G\\)中的边数至少减少一半。而while循环后面的补边操作全过程也是\\(O(E)\\)，因此这个算法的时间复杂度为\\(O(E)\\)。\r\nBST-REDUCE(G, T, b)  for each vertex v ∈ G.V    MAKE-SET(v)  for each (u, v) in G.E    // 对小于等于门限b的边进行收缩。    if (u, v).c &lt;= b and FIND-SET(u) != FIND-SET(v)      UNION(u, v)      T = T ∪ &#123;(u, v).orig&#125;  G&#x27;.V = &#123;FIND-SET(v) : v ∈ G.V&#125;  G&#x27;.E = Ø  for each (x, y) in G.E    u = FIND-SET(x)    v = FIND-SET(y)    // 对大于门限b的边两侧的节点进行置换。    if (x, y).c &gt; b and u != v:      if (u, v) ∉ G&#x27;.E        G&#x27;.E = G&#x27;.E ∪ &#123;(u, v)&#125;        (u, v).orig&#x27; = (x, y).orig        (u, v).c&#x27; = (x, y).c      else if (x, y).c &lt; (u, v).c&#x27;        (u, v).orig&#x27; = (x, y).orig        (u, v).c&#x27; = (x, y).c  for each (u, v) in G&#x27;.E    (u, v).orig = (x, y).orig&#x27;    (u, v).c = (x, y).c&#x27;  return (G&#x27;, T)GEN-NECKBOTTLE-TREE(G&#x27;, w)  T = Ø  let G be a copy of G&#x27;  for each (u, v) in G.E    (u, v).orig = (u, v)    (u, v).c = w(u, v)  while G.E != Ø    find the median of w(e) for e in G.E and get the median b    if not CHECK-NECKBOTTLE-BOUND(G, w, b)      G, T = BST-REDUCE(G, T, b)    else      remove the edges e from G.E s.t. w(e) &gt;= b  // 需要注意的是，这里的T还不是瓶颈生成树，因为它去掉的边包含了临界值m，现在需要对T再补上权值恰好为b的边。  let m be the median we last determined  for each vertex v ∈ G.V    MAKE-SET(v)  for each (u, v) in T    UNION(u, v)  for each (u, v) in G.E    if w(u, v) == m and FIND-SET(u) ≠ FIND-SET(v)      T = T ∪ &#123;(u, v)&#125;      UNION(u, v)  return T\r\n","categories":["算法导论"]},{"title":"算法导论24.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-24/exercises-1/","content":"\r\n24.1-1\r\n令\\(f&#39;\\)是\\(G&#39;=(V&#39;,E&#39;)\\)中的一个流，\\(f\\)是\\(G=(V,E)\\)中的一个流，容易知道，\\(V\\subseteq\r\nV&#39;\\)。我们将证明，对于所有在图\\(G&#39;\\)中的流\\(f&#39;\\)，都在\\(G\\)中存在对应的流\\(f\\)，使得\\(|f&#39;|=|f|\\)；类似的，对于所有在图\\(G\\)中的流\\(f\\)，都在\\(G&#39;\\)中存在对应的流\\(f&#39;\\)，使得\\(|f|=|f&#39;|\\)，从而证明两个图中的流具有对应关系，因此\\(G&#39;\\)中的最大流就对应了\\(G\\)中的最大流。不失一般性，假设\\(G\\)中存在一对节点\\((u,v)\\)，满足\\(c(u,v)&gt;0,c(v,u)&gt;0\\)，并且在图\\(G&#39;\\)中，边\\((u,v)\\)被拆分成两条边\\((u,x),(x,v)\\)，并且有\\(c&#39;(u,x)=c&#39;(x,v)=c(u,v),c&#39;(v,u)=c(v,u)\\)。\r\n接下来先证明：对于所有在图\\(G&#39;\\)中的流\\(f&#39;\\)，都在\\(G\\)中存在对应的流\\(f\\)，使得\\(|f&#39;|=|f|\\)。假设\\(f&#39;\\)是图\\(G&#39;\\)的某一个流，那么根据流量守恒可知\\(f&#39;(u,x)=f&#39;(x,v)\\)，令\\(f(u,v)=f&#39;(u,x),f(v,u)=f&#39;(v,u)\\)。那么这对反平行边在图\\(G\\)中的\\(u\\)节点看来，它们使其释放了\\(f(u,v)-f(v,u)\\)的流量；在\\(v\\)节点看来，它们使其接受了\\(f(u,v)-f(v,u)\\)的流量，这个情况在图\\(G&#39;\\)中的节点\\(u\\)和\\(v\\)看来是一样的，因此节点\\(u,v\\)的流量守恒仍然保持成立。因此按照\\(f,f&#39;\\)的定义式，可以计算出\\(|f&#39;|-|f|\\)的值：\r\n\\(\\begin{aligned}\r\n|f&#39;|-|f|&amp;=\\left(\\sum_{v\\in V&#39;} f&#39;(s,v)-\\sum_{v\\in\r\nV&#39;} f&#39;(v,s)\\right)-\\left(\\sum_{v\\in V} f(s,v)-\\sum_{v\\in V}\r\nf(v,s)\\right)\\\\\r\n&amp;=\\left(\\sum_{v\\in V&#39;} f&#39;(s,v)-\\sum_{v\\in V}\r\nf(s,v)\\right)-\\left(\\sum_{v\\in V&#39;} f&#39;(v,s)-\\sum_{v\\in V}\r\nf(v,s)\\right)\\\\\r\n&amp;=\\left(\\sum_{v\\in V&#39;} f&#39;(s,v)-\\sum_{v\\in V}\r\nf(s,v)\\right)-\\left(\\sum_{v\\in V&#39;} f&#39;(v,s)-\\sum_{v\\in V}\r\nf(v,s)\\right)\\\\\r\n&amp;=0-0&amp;\\qquad(A)\\\\\r\n&amp;=0\r\n\\end{aligned}\\)\r\n其中步骤\\((A)\\)的得出，是因为图\\(G\\)中\\(s\\)的出边/入边和\\(G&#39;\\)中的出边/入边一一对应，因此构造出来的流\\(f\\)满足\\(|f&#39;|=|f|\\)。\r\n接下来证明：对于所有在图\\(G\\)中的流\\(f\\)，都在\\(G&#39;\\)中存在对应的流\\(f&#39;\\)，使得\\(|f|=|f&#39;|\\)。假设\\(f\\)是图\\(G\\)的某一个流，那么令\\(f&#39;(u,x)=f&#39;(x,v)=f(u,v),f&#39;(v,u)=f(v,u)\\)。由新构造出的\\(x\\)节点可以知道，\\(x\\)满足流量守恒，此外对于\\(u\\)节点和\\(v\\)节点，按照之前的论证，它们对节点\\(u\\)和\\(v\\)的流入流量和流出流量的贡献是相同的，因此按照类似的论证方式，可以得出\\(|f&#39;|=|f|\\)。\r\n因此最终，从\\(G&#39;\\)构造出来的最大流可以推导出图\\(G\\)的最大流。原结论成立。\r\n24.1-2\r\n定义源点集合\\(S=\\{s_1,s_2,\\dots,s_n\\}\\)，汇点集合\\(T=\\{t_1,t_2,\\dots,t_m\\}\\)。那么容量限制的定义依旧不变，流量守恒的定义转变成，对于所有的节点\\(u\\in V-S-T\\)，有\\(\\displaystyle{\\sum_{v\\in V} f(u,v)=\\sum_{v\\in V}\r\nf(v,u)}\\)成立。\r\n那么最大流\\(f\\)的值定义为：\r\n\\[|f|=\\sum_{s\\in S}\\left(\\sum_{v\\in V}\r\nf(s,v)-\\sum_{v\\in V}f(v,s)\\right) \\]\r\n令新增超级源点\\(s&#39;\\)和超级汇点\\(t&#39;\\)后所得到的图\\(G&#39;=(V&#39;,E&#39;)\\)，其中\\(V=V\\cup\\{s,t\\}\\)。那么\\(\\forall (u,v)\\in\r\nE,f&#39;(u,v)=f(u,v)\\)，并且对于\\(\\displaystyle{\\forall s\\in\r\nS,f&#39;(s&#39;,s)=\\sum_{v\\in V}f(s,v)-\\sum_{v\\in V}\r\nf(v,s)}\\)，以及\\(\\displaystyle{\\forall\r\nt\\in T,f(t,t&#39;)=\\sum_{v\\in V}f(v,t)-\\sum_{v\\in\r\nV}f(t,v)}\\)，那么对于节点\\(s\\in S,t\\in\r\nT\\)，在图\\(G&#39;\\)中都满足了流量守恒。因此\\(f\\)所对应的\\(f&#39;\\)是在\\(G&#39;\\)中的一个流。其流量值相等，均为\\(|f|\\)。从\\(f&#39;\\)中去除和\\(s&#39;,t&#39;\\)关联的所有边后，就得到了\\(G\\)中的一个流\\(f\\)。\r\n24.1-3\r\n我们将证明比题目更强的一个结论：如果图\\(G\\)中存在节点\\(u\\)，使得路径\\(s\\rightsquigarrow u\\rightsquigarrow\r\nt\\)不存在，那么对于\\(G\\)中的所有流\\(f\\)，都有\\(\\forall v\\in\r\nV,f(u,v)=f(v,u)=0\\)。我们将使用反证法证明。\r\n我们首先证明从\\(u\\)无法到达\\(t\\)的情况。假设\\(\\exists v\\in\r\nV,f(u,v)&gt;0\\)，那么根据流量守恒可以知道，从\\(u\\)起必定有一条路径\\(v_1,v_2,\\dots,v_m\\)，对于\\(i\\in[1,m-1]\\)，都有\\(f(v_{i},v_{i+1})&gt;0\\)成立，其中\\(v_1=u,v_2=v\\)。按照流量守恒的定义，只有汇点\\(t\\)允许流入量大于流出量，因此从\\(u\\)开始的流量只能不停向下传递，直到到达\\(t\\)，因此必定有\\(v_m=t\\)，这和从\\(u\\)到\\(t\\)中存在路径是矛盾的，因此只能有\\(f(u,v)=0\\)，也就是说\\(u\\)的所有出边的流量都为\\(0\\)，根据流量守恒，\\(u\\)的所有入边的流量都为\\(0\\)，因此原结论成立。\r\n接下来证明从\\(s\\)无法到达\\(u\\)的情况。证明过程和上面的过程类似。假设\\(\\exists v\\in\r\nV,f(v,u)&gt;0\\)，那么根据流量守恒可以知道，必定有以\\(u\\)为终点的一条路径\\(w_1,w_2,\\dots,w_n\\)，对于\\(\\forall i\\in[1,n-1]\\)，都有\\(f(w_i,w_{i+1})&gt;0\\)，其中\\(v_{n-1}=v,v_n=u\\)。按照流量守恒的定义，只有源点\\(s\\)允许流入量小于流出量，因此只能从\\(u\\)不停向上追溯，一直到达\\(s\\)，因此必定有\\(w_1=s\\)，这和从\\(s\\)到\\(u\\)中存在路径是矛盾的，因此只能有\\(f(v,u)=0\\)，也就是说\\(u\\)的所有入边的流量都为\\(0\\)，根据流量守恒，\\(u\\)的所有出边的流量都为\\(0\\)，因此原结论成立。\r\n24.1-4\r\n首先证明\\(\\alpha\r\nf_1+(1-\\alpha)f_2\\)是满足容量限制。\r\n对于边\\((u,v)\\)，由于\\(f_1(u,v)\\ge 0,f_2(u,v)\\ge\r\n0,\\alpha\\in[0,1]\\)，因此\\(\\alpha\r\nf_1(u,v)+(1-\\alpha)f_2(u,v)\\ge 0\\)。此外，有\r\n\\(\\begin{aligned}\r\n\\alpha f_1(u,v)+(1-\\alpha)f_2(u,v)&amp;\\le \\alpha\r\nc(u,v)+(1-\\alpha)c(u,v)\\\\\r\n&amp;=c(u,v)\r\n\\end{aligned}\\)\r\n因此容量限制得证。\r\n接下来证明\\(\\alpha\r\nf_1+(1-\\alpha)f_2\\)是满足流量守恒。对于每个节点\\(u\\in V-\\{s,t\\}\\)，考虑证明\\(\\displaystyle{\\sum_{v\\in V}(\\alpha\r\nf_1(u,v)+(1-\\alpha)f_2(u,v))=\\sum_{v\\in V}(\\alpha\r\nf_1(v,u)+(1-\\alpha)f_2(v,u))}\\)，那么有\r\n\\(\\begin{aligned}\r\n&amp;\\sum_{v\\in V}(\\alpha f_1(u,v)+(1-\\alpha)f_2(u,v))-\\sum_{v\\in\r\nV}(\\alpha f_1(v,u)+(1-\\alpha)f_2(v,u))\\\\=&amp;\\alpha\\left(\\sum_{v\\in V}\r\nf_1(u,v)-\\sum_{v\\in V} f_1(v,u)\\right)-(1-\\alpha)\\left(\\sum_{v\\in V}\r\nf_2(u,v)-\\sum_{v\\in V} f_2(v,u)\\right)\\\\\r\n=&amp;\\alpha\\cdot0+(1-\\alpha)\\cdot 0\\\\\r\n=&amp;0\r\n\\end{aligned}\\)\r\n因此流量守恒得证。\r\n因此，\\(\\alpha\r\nf_1+(1-\\alpha)f_2\\)是一个流。\r\n24.1-5\r\n令\\(G=(V,E)\\)，那么\\(s\\)到\\(t\\)的最大流问题表示成一个线性规划问题是：\r\n\\(\\begin{aligned}\r\n\\text{maximize}&amp;&amp; \\sum_{(s,v)\\in E} f(s,v)-\\sum_{(v,s)\\in E}\r\nf(v,s)\\\\\r\n\\text{subject to}&amp; \\\\\r\n&amp;&amp;f(u,v)&amp;\\ge 0 &amp;&amp;\\forall (u,v)\\in E \\\\\r\n&amp;&amp;f(u,v)&amp;\\le c(u,v) &amp;&amp;\\forall (u,v)\\in E \\\\\r\n&amp;&amp;\\sum_{(u,v)\\in E} f(u,v)&amp;=\\sum_{(v,u)\\in E} f(v,u)\r\n&amp;&amp;\\forall u\\in V-\\{s,t\\}\r\n\\end{aligned}\\)\r\n后面的两条式子分别代表了容量限制和流量守恒条件。\r\n24.1-6\r\n令\\(s\\)表示他们的家，令\\(t\\)表示他们的学校，地图\\(G\\)上的每条边的容量都设置为\\(1\\)。在这个输入上运行最大流算法，并判断最大流的值是否超过\\(2\\)，如果超过\\(2\\)，那么存在上学方案，否则不存在。\r\n24.1-7\r\n将图\\(G=(V,E)\\)中的每个节点\\(v\\)拆分成两个节点\\(v_{in},v_{out}\\)，并且从\\(v_{in}\\)到\\(v_{out}\\)只需要连一条容量为\\(l(v)\\)的边即可。对图\\(G&#39;=(V&#39;,E&#39;)\\)更正式的描述如下：\r\n\r\n\\(\\forall v\\in V,v_{in},v_{out}\\in\r\nV&#39;\\)均成立。\r\n\\(\\forall v\\in V,(v_{in},v_{out})\\in\r\nE&#39;\\)均成立，其中\\(c&#39;(v_{in},v_{out})=l(v)\\)。\r\n\\(\\forall (u,v)\\in E,(u_{out},v_{in})\\in\r\nE&#39;\\)均成立，其中\\(c&#39;(u_{out},v_{in})=c(u,v)\\)。\r\n\r\n那么假设图\\(G\\)上对应的源点和汇点分别为\\(s,t\\)，那么在图\\(G&#39;\\)上的源点和汇点分别为\\(s_{in},t_{out}\\)。\r\n因此，图\\(G&#39;\\)上一共有\\(2|V|\\)个节点，\\(|V|+|E|\\)条边。\r\n","categories":["算法导论"]},{"title":"算法导论24.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-24/exercises-2/","content":"\r\n24.2-1\r\n对于\\(u\\)的所有非出边，根据定义，都有\\(c(u,v)=0\\)，因此\\(f(u,v)=c(u,v)=0\\)，也就是有\\(\\displaystyle{\\sum_{v\\in V_l(u)}f(u,v)=\\sum_{v\\in\r\nV}f(u,v)}\\)。\r\n对于\\(u\\)的所有非入边，根据定义，都有\\(c(v,u)=0\\)，因此\\(f(v,u)=c(v,u)=0\\)，也就是有\\(\\displaystyle{\\sum_{v\\in V_e(u)}f(v,u)=\\sum_{v\\in\r\nV}f(v,u)}\\)。\r\n对于\\(u\\)的所有非关联边，无论之后的流变化如何，根据定义，都有\\(c&#39;(v,u)=c&#39;(u,v)=0\\)，因此\\(f&#39;(v,u)=f&#39;(v,u)=0\\)，也就是有\\(\\displaystyle{\\sum_{v\\in V_l(u)\\cup\r\nV_e(u)}f(v,u)=\\sum_{v\\in V}f(v,u),\\sum_{v\\in V_l(u)\\cup\r\nV_e(u)}f(u,v)=\\sum_{v\\in V}f(u,v)}\\)。\r\n因此，最终有\r\n\\(\\begin{aligned}\r\n&amp;\\sum_{v\\in V_l(u)}f(u,v)-\\sum_{v\\in V_e(u)}f(v,u)+\\sum_{v\\in\r\nV_l(u)\\cup V_e(u)}f&#39;(u,v)-\\sum_{v\\in V_l(u)\\cup V_e(u)}f&#39;(v,u)\\\\\r\n=&amp;\\sum_{v\\in V}f(u,v)-\\sum_{v\\in V}f(v,u)+\\sum_{v\\in\r\nV}f&#39;(u,v)-\\sum_{v\\in V}f&#39;(v,u)\\\\\r\n=&amp;\\left(\\sum_{v\\in V}f(u,v)-\\sum_{v\\in\r\nV}f(v,u)\\right)+\\left(\\sum_{v\\in V}f&#39;(u,v)-\\sum_{v\\in\r\nV}f&#39;(v,u)\\right)\\\\\r\n=&amp;0\r\n\\end{aligned}\\)\r\n24.2-2\r\n从\\(S\\)中的节点到\\(T\\)中的节点的所有边如下：\r\n\\(\\begin{array}{|c|c|c|}\\hline\r\ne&amp;f&amp;c\\\\\\hline\r\n(s,v_1)&amp;11&amp;16\\\\\\hline\r\n(v_2,v_1)&amp;1&amp;4\\\\\\hline\r\n(v_4,v_3)&amp;7&amp;7\\\\\\hline\r\n(v_4,t)&amp;4&amp;4\\\\\\hline\r\n\\end{array}\\)\r\n从\\(T\\)中的节点到\\(S\\)中的节点的所有边如下：\r\n\\(\\begin{array}{|c|c|c|}\\hline\r\ne&amp;f&amp;c\\\\\\hline\r\n(v_3,v_2)&amp;4&amp;9\\\\\\hline\r\n\\end{array}\\)\r\n因此，切割\\((S,T)的流大小\\)为\\(11+1+7+4-4=19\\)，容量为\\(16+4+7+5=31\\)。\r\n24.2-3\r\n接下里将使用残余网络来表示这个流网络。一开始残余网络如下：\r\n\r\n随后运行BFS，找到了一条增广路径\\((s,v_1,v_3,t)\\)，其流量值为\\(12\\)。由此可以对残余网络进行更新：\r\n\r\n随后找到了一条增广路径\\((s,v_2,v_4,t)\\)，其流量值为\\(4\\)。由此可以对残余网络进行更新：\r\n\r\n最后找到了一条增广路径\\((s,v_2,v_4,v_3,t)\\)，其流量值为\\(7\\)。由此可以对残余网络进行更新：\r\n\r\n此后，再也不存在增广路径，因此最大流\\(|f|=23\\)。\r\n24.2-4\r\n令\\(S=\\{s,v_1,v_2,v_4\\},T=\\{v_3,t\\}\\)为所求。图24.6(c)中路径上的边\\((v_1,v_2)\\)抵消了图24.6(b)所传输的流；图24.6(c)中路径上的边\\((v_2,v_3)\\)抵消了图24.6(a)所传输的流。\r\n24.2-5\r\n令\\(G=(V,E)\\)是一个具有多源点多汇点的流网络，并令\\(S&#39;=\\{s_1,s_2,\\dots,s_m\\},T&#39;=\\{t_1,t_2,\\dots,t_n\\}\\)，即\\(S&#39;\\)是\\(G\\)中的所有源点，\\(T&#39;\\)是\\(G\\)中的所有原点。由于\\(S&#39;\\cap T&#39;=\\varnothing,(S&#39;\\cup\r\nT&#39;)\\subseteq V\\)，因此可以构造出一个在图\\(G\\)上的切割\\((S,T)\\)，使得\\(S&#39;\\subseteq S,T&#39;\\subseteq\r\nT\\)。由于\\(G&#39;\\)的网络容量是有限的，即\\(\\forall (u,v)\\in\r\nE,c(u,v)&lt;\\infty\\)，因此横跨切割\\((S,T)\\)中的所有边的容量都是有限的，那么切割\\((S,T)\\)的容量\\(c(S,T)\\)是有限的。\r\n这个流网络转换后，那么令新流网络为\\(G_1=(V_1,E_1)\\)，其中\\(V_1=V\\cup\\{s,t\\}\\)，并且\\(s\\)是超级源点，\\(t\\)是超级汇点。那么对流网络构造切割\\((S_1,T_1)\\)满足\\(S_1=S\\cup\\{s\\},T_1=T\\cup\\{t\\}\\)，那么可见，图\\(G_1\\)上切割\\((S_1,T_1)\\)的容量\\(c(S_1,T_1)\\)和\\(c(S,T)\\)是相等的的（因为横跨这两个切割的都是相同的边），因此按照推论26.5，\\(G_1\\)中的所有流都受限于\\(c(S_1,T_1)\\)，即任何一个流的值都是有限的。\r\n24.2-6\r\n思路和第24.1节时构造超级源点和超级汇点相似。令\\(G=(V,E)\\)是题目所提供的流网络，并令\\(S=\\{s_1,s_2,\\dots,s_m\\},T=\\{t_1,t_2,\\dots,t_n\\}\\)，即\\(S\\)是\\(G\\)中的所有源点，\\(T&#39;\\)是\\(G\\)中的所有原点。\r\n那么令新转化后的流网络为\\(G&#39;=(V&#39;,E&#39;)\\)，其中\\(V&#39;=V\\cup\\{s,t\\}\\)，并且\\(s\\)是超级源点，\\(t\\)是超级汇点。并且\\(\\forall (u,v)\\in E,(u,v)\\in\r\nE&#39;\\)均成立，\\(c&#39;(u,v)=c(u,v)\\)。对于\\(\\forall s_i\\in S,(s,s_i)\\in\r\nE&#39;\\)，并且有\\(c&#39;(s,s_i)=p_i\\)；对于\\(\\forall t_i\\in T,(t_i,t)\\in\r\nE&#39;\\)，并且有\\(c&#39;(t_1,t)=q_i\\)。\r\n最终所给定的流网络\\(G&#39;\\)和容量函数\\(c&#39;\\)为所求。\r\n24.2-7\r\n令这条简单路径\\(p\\)表示为\\(v_1,v_2,\\dots,v_m\\)，其中\\(v_1=s,v_m=t\\)。\r\n首先证明容量限制。按照\\(c_f(p)\\)的定义，可以得出\\(\\forall (u,v)\r\n\\in p,c_f(p)\\le c_f(u,v)\\)。因此，对于\\(\\forall (u,v)\\in p,f_p(u,v)=c_f(p)\\le\r\nc_f(u,v)\\)。由于边的容量是正数，因此可以得出\\(c_f(p)&gt;0\\)。也就是说，\\(f_p(u,v)\\ge 0\\)。对于\\(\\forall (u,v)\\not\\in p\\)，都有\\(f_p(u,v)=0\\)。因此容量限制得证。\r\n接下来证明流量守恒。\\(\\forall v\\not\\in\r\np\\)，由于增广路径\\(p\\)不经过\\(v\\)，因此流入\\(v\\)的流量和与流出\\(v\\)的流量和均为\\(0\\)，因此\\(v\\)处满足流量守恒。\\(\\forall v\\in\r\np-\\{s,t\\}\\)，仅有一条边流入\\(v\\)和一条边流出\\(v\\)，并且它们的流量值均为\\(c_f(p)\\)，因此\\(v\\)处满足流量守恒。\r\n故\\(f_p\\)是\\(G_f\\)中的一个流。对于\\(s\\)，仅有一条边从它流出，其大小为\\(c_f(p)\\)，因此\\(|f_p|=c_f(p)&gt;0\\)。\r\n24.2-8\r\n可见，算法FORD-FULKERSON的第3行是求解了一条增广路径，即从\\(s\\)到\\(t\\)的简单路径。由于这是一条以\\(s\\)为起点的简单路径，因此这条路径不可能从某处重新到达\\(s\\)，因此残余网络中，指向\\(s\\)的反向边是不必要的，它不会影响第3行的求解增广路径求取算法。因此原结论成立。\r\n24.2-9\r\n如此增广后的\\(f\\uparrow\r\nf&#39;\\)将不是\\(G\\)中的一个流。不过，\\(f\\uparrow\r\nf&#39;\\)仍然满足流量守恒，因为方程24.6的推导仅仅依赖于\\(f&#39;\\)本身的定义，根据题目24.2-1的进一步形式化证明可知，\\(f\\uparrow f&#39;\\)仍然满足流量守恒。\r\n接下来说明\\(f\\uparrow\r\nf&#39;\\)不满足容量限制。令\\(G=(V,E),V=\\{s,t\\},E=\\{(s,t)\\},c(s,t)=1\\)。如图所示：\r\ngraph LR  s((s));t((t));  s--1--&gt;t\r\n那么，令\\(f,f&#39;\\)是两个流，其中\\(f(s,t)=f&#39;(s,t)=1\\)，那么可以计算出\\((f\\uparrow\r\nf&#39;)(s,t)=f(s,t)+f&#39;(s,t)-f&#39;(t,s)=1+1-0=2&gt;c(s,t)\\)，从而违反了容量限制。\r\n24.2-10\r\n首先求出流网络\\(G=(V,E)\\)的其中一个最大流\\(f\\)。那么令\\(c&#39;(u,v)=f(u,v)\\)。并且，如果\\(c&#39;(u,v)&gt;0\\)，那么\\((u,v)\\in E&#39;\\)。由此可知，\\(E&#39;\\subseteq E\\)。\r\n这个算法将进行多次迭代，每次迭代的过程中，找到\\(E&#39;\\)中\\(c&#39;\\)值最小的边\\((u,v)\\)，并且通过在\\(G&#39;=(V,E&#39;)\\)上对\\(u\\)进行反向BFS，对\\(v\\)进行正向BFS，找到一条路径\\(p:s\\rightsquigarrow u\\rightarrow v\\rightsquigarrow\r\nt\\)。可见，\\(p\\)是一条增广路径，并存入数组中，接下来令\\(c&#39;_f(p)=c&#39;(u,v)\\)。那么对\\(p\\)中的所有边，都减去值\\(c&#39;_f(p)\\)。这轮迭代结束后，边\\((u,v)\\)必定从\\(E&#39;\\)中删除。因此，这个算法最多迭代\\(|E&#39;|\\le\r\n|E|\\)次，也就是说，最多只有\\(|E|\\)条增广路径。\r\n大致过程由AUGMENTING-PATHS-BOUNDS给出，其迭代轮数至多为\\(|E|\\)轮。\r\nAUGMENTING-PATHS-BOUNDS(G, s, t)  Let P be a new array  Let E&#x27; be a new set  FORD-FULKERSON(G, s, t)  for each edge (u, v) ∈ G.E    if (u, v).f &gt; 0      (u, v).c&#x27; = (u, v).f      INSERT(E&#x27;, (u, v))  while E&#x27; != ∅    let (u, v) be the edge s.t. (u, v).c&#x27; is minimum in E&#x27;.    run BFS twice (forward and back) to get the path p from s to t through (u,v)    INSERT(P, p)    c&#x27; = (u, v).c&#x27;    for each edge (u, v) ∈ E&#x27;      (u, v).c&#x27; = (u, v).c&#x27; - c&#x27;      if (u, v).c&#x27; == 0        DELETE(E&#x27;, (u, v))  return E\r\n24.2-11\r\n首先，一个无向图\\(G=(V,E)\\)不连通意味着：\\(\\forall u\\in V,\\exists v\\in\r\nV\\)，使得从\\(u\\)节点不可到达\\(v\\)节点。因此，我们可以随机选定\\(V\\)中的一个节点作为源点\\(s\\)，枚举所有\\(t\\in V-\\{s\\}\\)作为汇点，并且将\\(G\\)中的每一条无向边都替换成一对容量均为\\(1\\)的反平行边。接下来只需要对这个构造出来的流网络求解最大流（也就是这个流网络的最小割），那么求出来的值中，最小的一个恰好为答案。具体过程由EDGE-CONNECTIVITY给出。\r\nEDGE-CONNECTIVITY(G)  Let V, E be new sets  V = G.V  select vertex s ∈ G.V randomly  for each edge (u, v) ∈ G.E    Let x be a new vertex    INSERT(V, x)    INSERT(E, (u, v))    (u, v).c_f = 1    INSERT(E, (v, x))    (v, x).c_f = 1    INSERT(E, (x, u))    (x, u).c_f = 1  edge-connectivity = |G.V| - 1  for each vertex t ∈ G.V - &#123;s&#125;    Let G&#x27; = (V, E) be a new flow net work    FORD-FULKERSON(G&#x27;, s, t)    edge-connectivity = min&#123;edge-connectivity, |f|&#125;  return edge-connectivity\r\n我们构造了\\(|V|-1\\)个流网络，每个流网络一共有\\(|V|+|E|=O(V+E)\\)个节点，一共有\\(3|E|=O(E)\\)条边。因此如上算法为所求。\r\n24.2-12\r\n由于所有增广路径都是从\\(s\\)开始的，因此如果存在一条边\\((v,s)\\)，使得\\(f(v,s)=1\\)，那么这意味着节点\\(s\\)在某个环上（也就是说，边\\((v,s)\\)也在环上）。我们可以考虑对流\\(f\\)进行DFS，处理出这个环，并且将这个环上的所有边的流大小减去\\(1\\)，得到的新流\\(f&#39;\\)则是所求流。\r\n不难证明所求流\\(f&#39;\\)满足容量限制，因为环上的所有边的流大小都超过\\(1\\)，将它们都减去\\(1\\)不会使得流大小变成负数。流量守恒也不难证明，因为这个环上的所有节点，减去的流入流量和流出流量都为\\(1\\)，因此由于原来的流\\(f\\)满足流量守恒，\\(f&#39;\\)也满足流量守恒；对于\\(s\\)也如此，因此有\\(|f&#39;|=|f|\\)。\r\n整个具体过程由SIMPLIFY-FLOAT-1给出，由于是对一次DFS进行修改，因此其时间复杂度为\\(O(E)\\)。\r\nSIMPLIFY-FLOAT-DFS(G, s, u)  u.color = GRAY  for each vertex v in G.Adj[u]    if (u, v).f &gt; 0      if v.color == WHITE        v.π = u        SIMPLIFY-FLOAT-DFS(G, s, v)      else if v.color == GRAY and v == s and (u, s).f == 1        (u, s).f = (u, s).f - 1        z = u        while z != NIL          (z.p, z).f = (z.p, z).f - 1          z = z.p        exit                      // 算法结束，从此退出。  u.color = BLACKSIMPLIFY-FLOAT-1(G, s, t)  for each vertex u ∈ G.V    u.color = WHITE    u.π = NIL  SIMPLIFY-FLOAT-DFS(G, s, s)\r\n24.2-13\r\n假设对流网络\\(G=(V,E)\\)所有边的容量\\(c\\)都加上一个足够小的常数\\(\\epsilon\\)得到\\(c&#39;\\)，那么对于\\(G\\)中的以容量函数\\(c\\)得到的每一个最小割\\((S,T)\\)，如果其容量值为\\(C\\)，那么以容量函数\\(c&#39;\\)为计算的切割\\((S,T)\\)的容量为\\(C+\\epsilon \\cdot M_{S,T}\\)，其中\\(M_{S,T}\\)是从\\(S\\)中的节点指向\\(T\\)中的节点的边数。那么，以容量函数\\(c&#39;\\)运行最大流算法后，在残余网络\\(G_{f&#39;}\\)中，从\\(s\\)可达的节点集合为\\(S\\)，其余节点在\\(T\\)中，那么切割\\((S,T)\\)为以容量函数\\(c\\)所求的最小割，并且切割的边数最小。\r\n这个常数\\(\\epsilon\\)必须足够小，以至于对最大流的值产生的影响是微不足道的（产生的影响小于\\(1\\)个单位的流）。因此，\\(\\epsilon=\\dfrac{1}{|E|+1}\\)是一个合适的取值，哪怕所有边都做出了贡献，对最大流的贡献总共也只有\\(\\dfrac{|E|}{|E|+1}\\)，不超过\\(1\\)。\r\n当然，为了确保流的容量仍然是整数，我们可以考虑对容量函数\\(c\\)进行放缩。将\\(c\\)所有的容量全部都扩大到原来的\\(|E|+1\\)倍，那么求出来的最大流也是原来的\\(|E|+1\\)倍。接下来再对所有边容量都加上\\(1\\)，运行最大流算法后，从\\(s\\)可达的节点集合为\\(S\\)，其余节点在\\(T\\)中，切割\\((S,T)\\)为所求。更正式的定义，则是\\(\\forall (u,v)\\in E\\)，取\\(c&#39;(u,v)=c(u,v)\\cdot (|E|+1)+1\\)。\r\n这个算法的过程由MINIMIN-CUT-MINIMUM-EDGES给出。\r\nMINIMIN-CUT-MINIMUM-EDGES(G, s, t)  for each edge (u, v) ∈ G.E    (u, v).&#123;c&#x27;_f&#125; = (u, v) * (|G.E| + 1) + 1    run FORD-FULKERSON(G, s, t) using c_&#x27;f as capacity.  let E, S, T be a new set  for each edge (u, v) ∈ G.E    if (u, v).f &gt; -      INSERT(E, (u, v))  let G&#x27; = (G.V, E) be a new graph  BFS(G&#x27;, s)  for each vertex u ∈ G.V    if u.color == BLACK      INSERT(S, u)    else      INSERT(T, u)  return (S, T)\r\n","categories":["算法导论"]},{"title":"算法导论24 Problems 答案","url":"/introduction-to-algorithms/chapter-24/problems/","content":"\r\n24-1\r\na\r\n本题的做法和24.1-7完全一致，其中\\(l(v)\\)是节点的流量限制。\r\n将图\\(G\\)中的每个节点\\(v\\)拆分成两个节点\\(v_{in},v_{out}\\)，并且从\\(v_{in}\\)到\\(v_{out}\\)只需要连一条容量为\\(l(v)\\)的边即可。对图\\(G&#39;=(V&#39;,E&#39;)\\)更正式的描述如下：\r\n\r\n\\(\\forall v\\in V,v_{in},v_{out}\\in\r\nV&#39;\\)均成立。\r\n\\(\\forall v\\in V,(v_{in},v_{out})\\in\r\nE&#39;\\)均成立，其中\\(c&#39;(v_{in},v_{out})=l(v)\\)。\r\n\\(\\forall (u,v)\\in E,(u_{out},v_{in})\\in\r\nE&#39;\\)均成立，其中\\(c&#39;(u_{out},v_{in})=c(u,v)\\)。\r\n\r\n那么假设图\\(G\\)上对应的源点和汇点分别为\\(s,t\\)，那么在图\\(G&#39;\\)上的源点和汇点分别为\\(s_{in},t_{out}\\)。\r\n因此，图\\(G&#39;\\)上一共有\\(2|V|\\)个节点，\\(|V|+|E|\\)条边。\r\nb\r\n令\\(P\\)表示这\\(m\\)个起点的数组，每个元素具有属性\\(x\\)和\\(y\\)，用于表示坐标。\r\n令图\\(G=(V,E)\\)表示这个流网络。将每个格点（一共\\(n^2\\)个）以及源点\\(s\\)和汇点\\(t\\)加入\\(V\\)中。对网格中的每条相邻边，都转化成一对容量为\\(1\\)的反平行边（此处忽略处理反平行边的细节），并加入\\(E\\)中。枚举\\(P\\)中的每个节点，从\\(s\\)向其连接一条容量为\\(1\\)的边；枚举正方形边缘中的每个顶点，从其向\\(t\\)连接一条容量为\\(1\\)的边。最终运行FORD-FULKERSON算法，判断最大流的值是否等于\\(m\\)即可。\r\n接下来分析这个算法的时间复杂度：\\(V\\)中一共有\\(n^2+2\\)个节点，网格中每条边在流网络中对应了\\(3\\)条有向边，因此这部分有\\(6n(n-1)\\)条有向边。从\\(s\\)出发的边一共有\\(m\\)条，以\\(t\\)为终点的边一共有\\(4(n-1)\\)条。\r\n因此有\\(|V|=n^2+2=O(n^2),|E|=6n(n-1)+m+4(n-1)=O(n^2)\\)。由于FORD-FULKERSON算法的时间复杂度为\\(O(VE^2)\\)，因此解决该问题的时间复杂度为\\(O(n^6)\\)。具体过程由ESCAPE-GRID给出。\r\nESCAPE-GRID(n, P, m)  let s, t be new vertexes  let V = &#123;s, t&#125;, E be new sets  for i = 1 to n    for j = 1 to n      let v_&#123;i, j&#125; be a new vertex      INSERT(V, v_&#123;i, j&#125;)  for each p in P    INSERT(E, (s, v_&#123;p.x, p.y&#125;))  for i = 1 to n    for j = 1 to n      if (i == 1 or i == n) and (j == 1 or j == n)        INSERT(E, (v_&#123;i, j&#125;, t))      if j &lt; n        let z be a new vertex        INSERT(v_&#123;i, j&#125;, v_&#123;i, j + 1&#125;)        INSERT(v_&#123;i, j + 1&#125;, z)        INSERT(z, v_&#123;i, j&#125;)      if i &lt; n        let z be a new vertex        INSERT(v_&#123;i, j&#125;, v_&#123;i + 1, j&#125;)        INSERT(v_&#123;i + 1, j&#125;, z)        INSERT(z, v_&#123;i, j&#125;)  for each (u, v) in E    c_f(u, v) = 1  let G = (V, E) be a new flow network  f = FORD-FULKERSON(G, s, t)  return |f| == m\r\n24-2\r\na\r\n以题目中给定好的\\(G&#39;\\)进行说明。\\(\\forall (u,v)\\in E,c(u,v)=1\\)，并且以\\(x_0\\)为源点，\\(y_0\\)为汇点运行FORD-FULKERSON算法后得到最大流\\(f\\)后，那么所需要的路径数为\\(n-|f|\\)。\r\n对于图\\(G&#39;=(V&#39;,E&#39;)\\)，如果所求最大流\\(f\\)满足\\(f(x_i,y_j)= 1\\)，其中\\(1\\le i,j\\le n\\)，那么\\((i,j)\\)为\\(G\\)所求最小路径集合中的一条边。假设最终所求边集为\\(E_0\\)，那么也就是有\\(|E_0|=n-|f|\\)。\r\n接下来说明这个算法是正确的。由于所有边的容量都为\\(1\\)（且都是整数），因此对于每个节点\\(v\\in\r\nV-\\{x_0,y_0\\}\\)，最多只一条边流入这些\\(v\\)；如果有流入，根据流量守恒，也有一条边对应流出（只流向某个节点）。对于边\\((x_0,x_i)\\)，每个节点最多只有一次成为起点的机会；同样对于边\\((y_j,y_0)\\)，每个节点最多只有一次成为终点的机会。由于\\(c(x_i,y_j)=1\\)，因此对于\\(\\forall i\\in V\\)，考虑如下\\(4\\)种情况：\r\n\r\n\\(f(x_0,x_i)=0,f(y_i,y_0)=0\\)，这说明\\(i\\)是一个孤立点；\r\n\\(f(x_0,x_i)=1,f(y_i,y_0)=0\\)，这说明\\(i\\)是某一条路径的起点；\r\n\\(f(x_0,x_i)=0,f(y_i,y_0)=1\\)，这说明\\(i\\)是某一条路径的终点；\r\n\\(f(x_0,x_i)=1,f(y_i,y_0)=1\\)，这说明\\(i\\)是某一条路径的中间节点。\r\n\r\n因此，\\(n-|f|\\)计算出了这个图中有多少个终点（即有多少条路径）。\r\n由于计算出来的\\(f\\)已经是最大流，它无法再继续增加\\((x_i,y_j)\\)的基数，因此此时求出的边集\\(E_0\\)是一个最小路径覆盖；每找到一条边\\((x_i,y_j)\\)，这个操作就相当于将一条以\\(i\\)为终点和以\\(j\\)为起点的边拼接在一起，从而将最小路径数减少\\(1\\)。\r\n可以注意到，当令\\(L=\\{x_i\\mid\r\ni\\in[1,n]\\},R=\\{y_i\\mid\r\ni\\in[1,n]\\}\\)时，上述问题的解决相当于是求解一个二分图最大匹配，因此这个算法的时间复杂度为\\(O(VE)\\)。\r\nb\r\n这个算法不能正确地工作在有环图上。令\\(G=(V,E),V=\\{1,2,3\\},E=\\{(1,2),(2,3),(3,1)\\}\\)。那么由此构造出来的图\\(G&#39;=(V&#39;,E&#39;)\\)为：\r\n\r\n\\(V&#39;=\\{x_0,x_1,x_2,x_3,y_0,y_1,y_2,y_3\\}\\)\r\n\\(E&#39;=\\{(x_0,x_1),(x_0,x_2),(x_0,x_3),(y_1,y_0),(y_2,y_0),(y_3,y_0),(x_1,y_2),(x_2,y_3),(x_3,y_1)\\}\\)\r\n\r\n最终，对图\\(G&#39;\\)运行FORD-FULKERSON算法得到\\(|f|=3\\)，只需要花费\\(0\\)条路径即可覆盖这\\(3\\)个节点，这是不正确的。\r\n24-3\r\n本题的b和c题都参考了如下链接中的内容。\r\na\r\n考虑使用反证法证明。如果\\(\\exists J_i\\in\r\nT\\)，使得\\(\\exists C_k\\in\r\nR_i,C_k\\not\\in T\\)成立。那么说明\\(C_k\\in S\\)。考虑计算切割\\(c(S,T)\\)的容量，那么有\r\n\\(\\begin{aligned}\r\nc(S,T)&amp;=\\sum_{u\\in S}\\sum_{v\\in T} c(u,v)\\\\\r\n&amp;\\ge c(C_k,J_i)\\\\\r\n&amp;=\\infty\r\n\\end{aligned}\\)\r\n这和\\((S,T)\\)是一个有限容量的切割这个假设是矛盾的。因此原结论成立。\r\nb\r\n首先定义一个有效计划组\\(P&#39;=(C&#39;,J&#39;)\\)，这个有效计划组的定义是：\\(\\forall J_i\\in J&#39;\\)，如果\\(C_k\\in R_i\\)，那么\\(C_k\\in C&#39;\\)。此时，这个有效计划组\\(P&#39;\\)的盈利值为\\(\\displaystyle{v(P&#39;)=\\sum_{J_i\\in\r\nJ&#39;}p_i-\\sum_{C_k\\in C&#39;}e_k}\\)。\r\n那么定义一个引理：流网络\\(G\\)中存在一个有限容量的割\\((S,T)\\)，当且仅当存在一个有效计划组\\(P&#39;\\)，使得\\(\\displaystyle{v(P&#39;)=\\sum_{J_i\\in J}p_i\r\n-c(S,T)}\\)。\r\n首先证明充分性。令\\((S,T)\\)是\\(G\\)中的一个有限容量割。那么可以构造如下计划组\\(P&#39;=(C&#39;,J&#39;)\\)：如果\\(C_k\\in T\\)，那么\\(C_k\\in C&#39;\\)；如果\\(J_i\\in T\\)，那么\\(J_i\\in\r\nJ&#39;\\)。按照题目24-3-a的结论，计划组\\(P&#39;\\)是一个有效计划组，因为\\(c(S,T)\\)是有限的，条件\\(J_i\\in T\\)（即\\(J_i\\in J&#39;\\)），确保了\\(\\forall C_k\\in R_i\\)，都有\\(C_k\\in T\\)，从而保证了\\(J_i\\in J&#39;\\)。\r\n由于\\((S,T)\\)是一个有限容量割，因此割的容量\\(c(S,T)\\)不可能来自形如\\((C_k,J_i)\\)的边，这意味着\\(C_k\\in S,J_i\\in T\\)。最终\\(c(S,T)\\)的值只能由形如\\((s,C_k)\\)和\\((J_i,t)\\)的边构成。更正式的，\\(c(S,T)\\)可以写成：\r\n\\[c(S,T)=\\sum_{C_k\\in T}\r\nc(s,C_k)+\\sum_{J_i\\in S} c(T_i,t)\\]\r\n考虑上述形如\\((s,C_k),C_k\\in\r\nT\\)的边，这意味着\\(C_k\\)是被雇佣的专家，并且由于\\(c(s,C_k)=e_k\\)，因此可以写出\\(\\displaystyle{\\sum_{C_k\\in T}\r\nc(s,C_k)=\\sum_{C_k\\in C&#39;}e_k}\\)。同样的，对于形如\\((J_i,t),J_i\\in S\\)的边。这意味着\\(J_i\\)不在有效计划组\\(P&#39;\\)中，并且由于\\(c(J_i,t)=p_i\\)，因此可以写出\\(\\displaystyle{\\sum_{J_i\\in S}\r\nc(J_i,t)=\\sum_{J_i\\not\\in J&#39;}p_i}\\)。计算这个有效工作组\\(P&#39;\\)的盈利值\\(v(P&#39;)\\)，有\r\n\\(\\begin{aligned}\r\nv(P&#39;)&amp;=\\sum_{J_i\\in J&#39;}p_i-\\sum_{C_k\\in C&#39;}e_k\\\\\r\n&amp;=\\sum_{J_i\\in J&#39;}p_i+\\sum_{J_i\\not\\in J&#39;}p_i-\\sum_{C_k\\in\r\nC&#39;}e_k-\\sum_{J_i\\not\\in J&#39;}p_i\\\\\r\n&amp;=\\left(\\sum_{J_i\\in J&#39;}p_i+\\sum_{J_i\\not\\in\r\nJ&#39;}p_i\\right)-\\left(\\sum_{C_k\\in C&#39;}e_k+\\sum_{J_i\\not\\in\r\nJ&#39;}p_i\\right)\\\\\r\n&amp;=\\sum_{J_i\\in J}p_i-\\left(\\sum_{C_k\\in C&#39;}e_k+\\sum_{J_i\\not\\in\r\nJ&#39;}p_i\\right)\\\\\r\n&amp;=\\sum_{J_i\\in J}p_i-\\left(\\sum_{C_k\\in T} c(s,C_k)+\\sum_{J_i\\in S}\r\nc(J_i,t)\\right)\\\\\r\n&amp;=\\sum_{J_i\\in J}p_i-c(S,T)\r\n\\end{aligned}\\)\r\n由此充分性成立。\r\n接下来证明必要性。对于一个有效计划组\\(P&#39;=(C&#39;,J&#39;)\\)，按如下方式构造流网络\\(G\\)上的一个割\\((S,T)\\)：\\(\\forall J_i\\in J&#39;\\)，都有\\(J_i\\in T\\)，并且对于\\(\\forall C_k\\in R_i\\)，都有\\(C_k\\in T\\)。对于其它不在\\(V-\\{s,t\\}\\)，都在\\(S\\)中。可以证明，\\(c(S,T)\\)是一个有限容量的割，因为只要\\(J_i\\in T\\)，那么对应的专家都有\\(C_k\\in T\\)，并不存在\\(C_k\\in R_i\\land C_k\\in S\\land J_i\\in\r\nT\\)的情况，因此割\\((S,T)\\)的容量是有限的。\r\n和之前的分析一致，割\\((S,T)\\)的容量为\\(\\displaystyle{c(S,T)=\\sum_{J_i\\in\r\nJ}p_i-c(S,T)}\\)。由此必要性成立。\r\n因此根据上面证明的引理，我们可以只凭借最小割的容量\\(c(S,T)\\)以及给定的\\(p_i\\)值，求出其最大盈利值\\(\\displaystyle{\\sum_{J_i\\in\r\nJ}p_i-c(S,T)}\\)。\r\nc\r\n按照题目中给定的流网络\\(G\\)，源点\\(s\\)和汇点\\(t\\)运行Ford-Fulkerson算法，得到最大流\\(f\\)及其对应的残余网络\\(G_f\\)后，\\(\\displaystyle{\\sum_{J_i\\in\r\nJ}p_i-|f|}\\)即为最大盈利值，对于从\\(s\\)不可达的节点\\(C_k\\)，则是需要应聘的专家；对于从\\(s\\)不可达的节点\\(J_i\\)，则是需要完成的任务。\r\n可以知道流网络\\(G=(V,E)\\)满足\\(|V|=n+m+2,|E|=n+m+r\\)。由于FORD-FULKERSON算法的运行的时间复杂度为\\(O(VE^2)\\)，因此这个决定最优有效计划组的算法\\(P&#39;\\)的时间复杂度为\\(O((n+m)(n+m+r)^2)\\)。\r\n24-4\r\na\r\n如果当前边使用的容量\\(f(u,v)\\)仍然不满，那么为这条边加上\\(1\\)个单位的容量仍然不会增加最大流（因为\\((u,v)\\)还有容量剩余，此前就可以使用）。否则，尝试通过BFS寻找一条增广路径\\(p\\)，如果找得到，这条路径必定经过\\((u,v)\\)。接下来只需要对\\(p\\)上的所有边的流量增加\\(1\\)即可。由于核心过程仅仅是一次BFS找到增广路径\\(p\\)，因此其时间复杂度为\\(O(V+E)\\)。大概过程由INCREASE-CAPICITY-UPDATE-FLOW给出。\r\nINCREASE-CAPICITY-UPDATE-FLOW(G, s, t, u, v)  (u, v).c_&#123;f&#125; = (u, v).c_&#123;f&#125; + 1  // 增加并不会产生效果  if (u, v).c_&#123;f&#125; &gt; (u, v).f + 1    return  if there exists a path p from s to t in the residual network G_f    for each edge (u, v) in p      if (u, v) ∈ G.E        (u, v).f = (u, v).f + 1      else        (v, u).f = (v, u).f - 1\r\nb\r\n如果当前边使用的容量\\(f(u,v)\\)仍然不满，那么为这条边减去\\(1\\)个单位的容量仍然不会减少最大流。否则，尝试通过对\\(u\\)进行反向BFS，对\\(v\\)进行正向BFS，找到一条路径\\(p:s\\rightsquigarrow u\\rightarrow v\\rightsquigarrow\r\nt\\)。接下来只需要对\\(p\\)上的所有边的流量减少\\(1\\)即可。由于核心过程仅仅是两次BFS找到一条完整的增广路径\\(p\\)，因此其时间复杂度为\\(O(V+E)\\)。大概过程由DECREASE-CAPICITY-UPDATE-FLOW给出。\r\nDECREASE-CAPICITY-UPDATE-FLOW(G, s, t, u, v)  if (u, v).c_&#123;f&#125; &gt; (u, v).f    (u, v).c_&#123;f&#125; = (u, v).c_&#123;f&#125; - 1    return  run BFS twice (forward and back) to get the path p from s to t through (u, v)  for each edge (u, v) in p    if (u, v) ∈ G.E      (u, v).f = (u, v).f - 1    else      (v, u).f = (v, u).f + 1  (u, v).c_&#123;f&#125; = (u, v).c_&#123;f&#125; - 1\r\n24-5\r\na\r\n假设当前某个最小割为\\((S,T)\\)，按照切割容量的定义\\(c(S,T)\\)，可以得到\r\n\\(\\begin{aligned}\r\nc(S,T)&amp;=\\sum_{u\\in S}\\sum_{v\\in T} c(u,v)\\\\\r\n&amp;=\\sum_{(u,v)\\in E\\land u\\in S\\land v\\in T} c(u,v)\\\\\r\n&amp;\\le\\sum_{(u,v)\\in E} c(u,v)\\\\\r\n&amp;\\le\\sum_{(u,v)\\in E} C\\\\\r\n&amp;=C|E|\r\n\\end{aligned}\\)\r\n因此原结论成立。\r\nb\r\n基本思想是，忽略掉所有满足\\(c_f(u,v)&lt;K\\)的所有边，在剩下的边中以\\(s\\)为起点进行BFS，如果能够到达\\(t\\)，那么说明找到了一条从\\(s\\)到\\(t\\)且流量值至少为\\(k\\)的增广路径。由于核心是进行一次BFS，因此这个过程的时间复杂度为\\(O(E)\\)。具体过程由AUGMENTING-PATH-AT-LEAST-K给出。\r\nAUGMENTING-PATH-AT-LEAST-K(G, s, t, K)  for each vertex u ∈ G.V - &#123;s&#125;    u.d = ∞    u.π = NIL    u.color = WHITE  s.d = 0  s.π = NIL  s.color = GRAY  Q = ∅  ENQUEUE(Q, s)  while Q != ∅     u = DEQUEUE(Q)    for each vertex v in G.Adj[u]               // search the neighbors of u      if v.color == WHITE and (u, v).c_&#123;f&#125; &gt;= K // is v being discovered now?        v.d = u.d + 1        v.π = u        v.color = GRAY        ENQUEUE(Q, v)                     // v is now on the frontier    u.color = BLACK                       // u is now behind the frontier  if t.p == NIL    return NIL  let P be a new array  z = t  while t != NIL    INSERT(P, z)    z = z.p  REVERSE(P)  // 增广路径存在数组P中  return P\r\nc\r\n在算法MAX-FLOW-BY-SCALING的第3行定义了\\(K\\)的值是\\(2\\)的幂。在第4行的while循环尚未结束时，\\(K\\)仍然是一个\\(2\\)的幂，因此可以取到\\(K=1\\)。在此时，第5行代码将寻找到所有容量至少为\\(1\\)的增广路径\\(p\\)，这意味着存在一条从\\(s\\)到\\(t\\)的路径\\(p\\)，并将\\(p\\)扩增到流\\(f\\)中。此时第5行while循环如果结束了，就意味着不再有增广路径（因为容量必定是整数，所以流也是整数），此时已经完成求解最大流。\r\n因此算法MAX-FLOW-BY-SCALING能够正确地求出最大流。\r\nd\r\n首先使用循环不变量证明，在每轮外层while循环的循环体执行前，都不存在大小至少为\\(2K\\)的增广路径，整个过程都是如此。\r\n初始化：不难发现，\\(2K=2^{\\lfloor\\lg\r\nC\\rfloor+1}&gt;2^{\\lg C}=C\\)，然而\\(C\\)已经是图中容量的最大值，因此此时最大的增广路径容量不超过\\(2K\\)。\r\n保持：当本轮外层while循环体结束时，已经没有增广路径的长度至少为\\(K\\)，此时第7行将当\\(K\\)被除至一半后，变成\\(K&#39;(K=2K&#39;)\\)时，此时就没有增广路径的长度至少为\\(2K&#39;\\)，这个\\(K&#39;\\)将作为下一轮的\\(K\\)使用，因此原结论成立。\r\n终止：最终外层while循环终止，\\(K&lt;1\\)，此时算法终止。\r\n总之，整个过程中，都不存在容量至少为\\(2K\\)的增广路径。那么令\\(G&#39;=(V,E&#39;),E&#39;=\\{(u,v)\\mid (u,v)\\in\r\nE_f,c_f(u,v)\\ge 2K\\}\\)，可见\\(G&#39;\\)中，从\\(s\\)不能到达\\(t\\)。令\\(S\\)是\\(G&#39;\\)中从\\(s\\)可达的节点的集合，\\(T=V-S\\)。我们将证明所求切割\\((S,T)\\)的容量\\(c(S,T)\\)满足\\(c(S,T)&lt; 2K|E|\\)，从而说明\\(G&#39;\\)的最小割的容量小于\\(2K|E|\\)。可以按照定义计算\\(c(S,T)\\)，得：\r\n\\(\\begin{aligned}\r\nc(S,T)&amp;=\\sum_{u\\in S}\\sum_{v\\in T} c_f(u,v)\\\\\r\n&amp;=\\sum_{(u,v)\\in E\\land u\\in S\\land v\\in T} c_f(u,v)\\\\\r\n&amp;&lt;\\sum_{(u,v)\\in E\\land u\\in S\\land v\\in T} 2K&amp;\\qquad(A)\\\\\r\n&amp;\\le\\sum_{(u,v)\\in E} 2K\\\\\r\n&amp;=2K|E|\r\n\\end{aligned}\\)\r\n其中，步骤\\((A)\\)使用了事实：\\(c_f(u,v)&lt;2K\\)，否则\\((u,v)\\in E&#39;\\)，节点\\(v\\)将会在\\(S\\)中。\r\n因此原结论成立。\r\ne\r\n按照题目24-5-d的结论，每轮外层while循环的循环体执行前，最小割的容量少于\\(2K|E|\\)。每次内层循环执行后，流大小至少增加\\(K\\)。因此根据引理24.5，内层while循环的执行次数至多为\\(\\dfrac{2K|E|}{K}=2|E|\\)，即\\(O(E)\\)。\r\nf\r\n由于\\(K=2^{\\lfloor\\lg\r\nC\\rfloor}\\)，因此外层while只会执行\\(O(\\lg\r\nC)\\)次。按照题目24-5-d的结论，内层while循环最多执行\\(O(E)\\)次，每次循环中，使用题目24-5-b的算法找到一条容量至少为\\(K\\)的路径所花费的时间为\\(O(E)\\)。因此，整个MAX-FLOW-BY-SCALING算法的时间复杂度为\\(O(\\lg C)\\cdot O(E)\\cdot O(E)=O(E^2\\lg\r\nC)\\)。\r\n24-6\r\na\r\n可以对Dijkstra进行如下修改：用\\(x.d\\)表示能够到达当前节点\\(x\\)的最大流的值，并且这条路径的上一个节点为\\(x.p\\)。此外，使用最大优先队列来处理节点。再初始化节点时，需要将所有节点的\\(d\\)属性初始化成\\(0\\)，而源点\\(s\\)属性则初始化成\\(\\infty\\)。修改后的算法如DIJKSTRA-AUGMENTING-PATH所示，其时间复杂度和原始的Dijkstra算法一致，为\\(O(E\\lg V)\\)。\r\nINITIALIZE-SINGLE-SOURCE-AUGMENTING-PATH(G, s)  for each vertex v ∈ G.V    v.d = 0    v.π = NIL  v.s = ∞RELAX-AUGMENTING-PATH(u, v, w)  if v.d &lt; min(u.d, w(u, v))    v.d = min(u.d, w(u, v))    v.π = uDIJKSTRA-AUGMENTING-PATH(G, s, t)  INITIALIZE-SINGLE-SOURCE-AUGMENTING-PATH(G, s)  S = Ø  Q = Ø  s.mark = True  for each vertex u ∈ G.V    INSERT(Q, u)  while Q ≠ Ø    u = EXTRACT-MAX(Q)    S = S ∪ &#123;u&#125;    for each vertex v in G.Adj[u]      RELAX-AUGMENTING-PATH(u, v, c_f)      if the call of RELAX increased v.d        INCREASE-KEY(Q, v, v.d)  if t.p == NIL    return NIL  let P be a new array  z = t  while t != NIL    INSERT(P, z)    z = z.p  REVERSE(P)  // 增广路径存在数组P中  return P\r\nb\r\n本题和24.2-10完全一致，以下是其解答：\r\n首先求出流网络\\(G=(V,E)\\)的其中一个最大流\\(f\\)。那么令\\(c&#39;(u,v)=f(u,v)\\)。并且，如果\\(c&#39;(u,v)&gt;0\\)，那么\\((u,v)\\in E&#39;\\)。由此可知，\\(E&#39;\\subseteq E\\)。\r\n这个算法将进行多次迭代，每次迭代的过程中，找到\\(E&#39;\\)中\\(c&#39;\\)值最小的边\\((u,v)\\)，并且通过在\\(G&#39;=(V,E&#39;)\\)上对\\(u\\)进行反向BFS，对\\(v\\)进行正向BFS，找到一条路径\\(p:s\\rightsquigarrow u\\rightarrow v\\rightsquigarrow\r\nt\\)。可见，\\(p\\)是一条增广路径，并存入数组中，接下来令\\(c&#39;_f(p)=c&#39;(u,v)\\)。那么对\\(p\\)中的所有边，都减去值\\(c&#39;_f(p)\\)。这轮迭代结束后，边\\((u,v)\\)必定从\\(E&#39;\\)中删除。因此，这个算法最多迭代\\(|E&#39;|\\le\r\n|E|\\)次，也就是说，最多只有\\(|E|\\)条增广路径。\r\n大致过程为题目24.2-10的AUGMENTING-PATHS-BOUNDS，其迭代轮数至多为\\(|E|\\)轮。\r\n因此，只需要进行最多\\(|E|\\)次从\\(s\\)到\\(t\\)的扩增，就能得到\\(G\\)的最大流。\r\nc\r\n在当前的残余网络\\(G_f\\)中，仍然有\\(|f^{\\ast}|-|f|\\)单位的流未被处理出来。也就是说，令流网络\\(G_f\\)为全新的图\\(G&#39;\\)，那么可知，\\(G&#39;\\)的最大流值为\\(|f^{\\ast}|-|f|\\)，其中对于每一对反平行边\\((u,v)\\)，要么\\(f(u,v)&gt;0\\)，要么\\(f(v,u)&gt;0\\)。因此\\(G&#39;\\)中的最大流最多只有\\(|E|\\)条边满足\\(f(u,v)&gt;0\\)。按照题目24-2-b的结论，\\(G&#39;\\)最大流最多可以拆分成最多\\(|E|\\)条增广路径，设这个增广路径序列为\\(P\\)。那么令\\(p\\)是这些增广路径中容量最大的一条，那么必定有\\(c_f(p)\\ge\r\n(|f^{\\ast}|-|f|)/|E|\\)。因为如果这些增广路径的容量都小于\\((|f^{\\ast}|-|f|)/|E|\\)，那么它们的容量之和就小于\\(|f^{\\ast}|-|f|\\)，这和\\(G&#39;\\)的最大流是\\(|f^{\\ast}|-|f|\\)是矛盾的。因此原结论得证。\r\nd\r\n由于原来的流是\\(f_{i-1}\\)，对其使用最宽增广路径\\(p\\)进行扩增，得到\\(f_i\\)。因此根据引理24.1，\\(|f_i|=|f_{i-1}|+c_f(p)\\)。代入题目24-6-c的结论，得到\\(|f_i|-|f_{i-1}|\\ge\r\n(|f^{\\ast}|-|f_{i-1}|)/|E|\\)。因此可以得到\\(|f_i|\\ge\r\n(1-1/|E|)|f_{i-1}|+|f^{\\ast}|/|E|\\)\r\n接下来使用归纳法进行证明本题结论。\r\n当\\(i=0\\)时，可以验证不等式两侧的值均为\\(|f^{\\ast}|\\)，因此原结论成立。\r\n当\\(i&gt;0\\)时，假设对于\\(j=0,1,2,\\dots,i-1\\)，都满足\\(|f^{\\ast}|-|f_{j}|\\le|f^{\\ast}|(1-1/|E|)^j\\)均成立。那么考虑缩放\\(|f^{\\ast}|-|f_i|\\)的值，有\r\n\\(\\begin{aligned}\r\n|f^{\\ast}|-|f_i|&amp;\\le |f^{\\ast}|\r\n-((1-1/|E|)|f_{i-1}|+|f^{\\ast}|/|E|)\\\\\r\n&amp;=(1-1/|E|)|f^{\\ast}| - (1-1/|E|)|f_{i-1}|\\\\\r\n&amp;=(1-1/|E|)(|f^{\\ast}|-|f_{i-1}|)\\\\\r\n&amp;\\le (1-1/|E|)\\cdot |f^{\\ast}|(1-1/|E|)^{i-1}\\\\\r\n&amp;=|f^{\\ast}|(1-1/|E|)^{i}\r\n\\end{aligned}\\)\r\n因此，原结论得证。\r\ne\r\n使用题目24-6-d的结论\\(|f^{\\ast}|-|f_{i}|&lt;\r\n|f^{\\ast}|(1-1/|E|)^i\\)，结合证明\\(1-1/|E|\\le e^{-1/|E|}\\)，即可得证\\(|f^{\\ast}|-|f_{i}|&lt; |f^{\\ast}|\r\ne^{-i/|E|}\\)。\r\n接下来证明\\(1-1/|E|\\le\r\ne^{-1/|E|}\\)，只需要从方程3.14中，令\\(x=-1/|E|\\)即可导出此式，因此原结论成立。\r\nf\r\n令\\(i_0=|E|\\ln\r\n|f^{\\ast}|\\)，那么从题目24-6-e的结论可以得到：\r\n\\(\\begin{aligned}\r\n|f^{\\ast}|-|f_{i_0}|&amp;&lt; |f^{\\ast}| e^{-i_0/|E|}\\\\\r\n&amp;=|f^{\\ast}| e^{-\\ln |f^{\\ast}|}\\\\\r\n&amp;=1\r\n\\end{aligned}\\)\r\n由于容量\\(c\\)都是整数，因此按照定理24.10，使用Ford-Fulkerson方法计算出的\\(|f_{i_0}|\\)一定是一个整数，那么按照上面的约束，得到\\(|f_{i_0}|=|f^{\\ast}|\\)，此时\\(f_{i_0}\\)是一个最大流。也就是说，对原始空流增广至多\\(i_0=|E|\\ln\r\n|f^{\\ast}|\\)次后，得到的流是最大流。\r\n24-7\r\n为求方便，本题将多重边\\((u,v)\\)转化成一个权值\\(w(u,v)\\)来表示。即如果原图\\(G&#39;=(V,E&#39;)\\)中，有\\(k(k&gt;0)\\)条无向边\\((u,v)\\)，那么在图\\(G=(V,E)\\)中，有一条无向边\\((u,v)\\)，且有边权函数\\(w(u,v)=k\\)。\r\na\r\n该题目和24.2-11一致，区别在于当前的图\\(G\\)是多重图，枚举\\(G\\)中每一对节点\\((s,t)\\)，其中一个座位源点，另一个作为汇点，将\\(G\\)中的每一条无向边都替换成一对容量均为\\(c(u,v)\\)的反平行边。接下来只需要对这个构造出来的流网络求解最大流（也就是这个流网络的最小割），那么求出来的值中，最小的一个恰好为答案。\r\n由于枚举的点对有\\(\\dbinom{|V|}{2}\\)个，因此相当于解决\\(\\dbinom{|V|}{2}\\)个最大流问题。大概过程由GLOBAL-MINIMUM-CUT-NAIVE给出。\r\nGLOBAL-MINIMUM-CUT-NAIVE(G, c)  Let V, E be new sets  V = G.V  for each edge (u, v) ∈ G.E    Let x be a new vertex    INSERT(V, x)    INSERT(E, (u, v))    (u, v).c_f = c(u, v)    INSERT(E, (v, x))    (v, x).c_f = c(u, v)    INSERT(E, (x, u))    (x, u).c_f = c(u, v)  mu = ∞  for each vertex s ∈ G.V    for each vertex t ∈ G.V - &#123;s&#125;      if s &lt; t        // 避免t作为汇点，s作为源点的情况。        Let G&#x27; = (V, E) be a new flow net work        FORD-FULKERSON(G&#x27;, s, t)        mu = min&#123;mu, |f|&#125;  return mu\r\nb\r\n该题目和24.2-11一致，区别同样在于当前的\\(G\\)是多重图。一个无向图\\(G=(V,E)\\)不连通意味着：\\(\\forall u\\in V,\\exists v\\in\r\nV\\)，使得从\\(u\\)节点不可到达\\(v\\)节点。因此，我们可以随机选定\\(V\\)中的一个节点作为源点\\(s\\)，枚举所有\\(t\\in V-\\{s\\}\\)作为汇点，并且将\\(G\\)中的每一条无向边都替换成一对容量均为\\(c(u,v)\\)的反平行边。接下来只需要对这个构造出来的流网络求解最大流（也就是这个流网络的最小割），那么求出来的值中，最小的一个恰好为答案。具体过程由GLOBAL-MINIMUM-CUT-NAIVE'给出。\r\nGLOBAL-MINIMUM-CUT-NAIVE&#x27;(G, c)  Let V, E be new sets  V = G.V  select vertex s ∈ G.V randomly  for each edge (u, v) ∈ G.E    Let x be a new vertex    INSERT(V, x)    INSERT(E, (u, v))    (u, v).c_f = c(u, v)    INSERT(E, (v, x))    (v, x).c_f = c(u, v)    INSERT(E, (x, u))    (x, u).c_f = c(u, v)  mu = ∞  for each vertex t ∈ G.V - &#123;s&#125;    Let G&#x27; = (V, E) be a new flow net work    FORD-FULKERSON(G&#x27;, s, t)    mu = min&#123;mu, |f|&#125;  return mu\r\n由于这里相当于解决了\\(|V|-1\\)个最大流问题，每个最大流问题需要花费\\(O(VE^2)\\)的时间，因此这个算法的时间复杂度为\\((|V|-1)\\cdot O(VE^2)=O(V^2E^2)\\)。\r\nc\r\n题目应该想证明的是\\(\\mu(G/(u,v))\\ge\r\n\\mu(G)\\)。\r\n我们首先证明，对于\\(G\\)中某一条边\\((u,v)\\)进行收缩后得到图\\(G&#39;=G/(u,v)\\)。在图\\(G/(u,v)\\)中的每个割\\(C&#39;\\)，都能在\\(G\\)中找到一个对应的割\\(C\\)，使得\\(|C&#39;|\\ge |C|\\)，从而证明\\(\\mu(G/(u,v))\\ge \\mu(G)\\)成立。\r\n对于\\(G&#39;\\)中的每一个割\\((S&#39;,T&#39;)\\)，考虑如下一个关于\\(G\\)的割\\((S,T)\\)：对于\\(\\forall w\\in V-\\{u,v\\}\\)，如果\\(w\\in S&#39;\\)，那么\\(w\\in S\\)，否则\\(w\\in T\\)。不失一般性，假设\\(x\\in S&#39;\\)。接下来考虑\\(u,v\\)所处的集合。\r\n如果\\(u\\in S,v\\in\r\nS\\)，那么说明上式的等号成立。因此原结论\\(\\mu(G/(u,v))\\ge \\mu(G)\\)成立。\r\n当\\((u,v)\\)是\\(G\\)中所有全局最小割的共同边时，那么满足\\(\\mu(G/(u,v))&gt;\\mu(G)\\)。\r\nd\r\n由于\\(G\\)的全局最小割至少为\\(\\mu(G)\\)，因此对于所有节点\\(v\\in V\\)，它们的度数都至少为\\(\\mu(G)\\)（这意味着如果\\(\\exists v\\in V\\)，使得节点\\(v\\)的度数小于\\(\\mu (G)\\)，那么\\((\\{v\\},V-\\{v\\})\\)是一个小于\\(\\mu(G)\\)的割，与\\(\\mu\\)的定义矛盾）。因此最终有\\(\\mu(G)\\cdot |V|\\le 2|E|\\)，从而得到\\(\\mu(G)\\le 2|E|/|V|\\)。\r\ne\r\n对于其中某个特定的全局最小割\\(C\\)，一共有\\(\\mu(G)\\)条边，即\\(|C|=\\mu(G)\\)。从这\\(|E|\\)条边均匀随机选择出一条属于\\(C\\)的边的概率为\\(\\dfrac{\\mu(G)}{|E|}\\)。按照题目24-7-d的结论，有\\(\\dfrac{\\mu(G)}{|E|}\\le\r\n\\dfrac{2}{|V|}\\)，因此原结论得证。\r\nf\r\n接下来在算法的每一轮中，都会随机选择一条边，将两个节点合并成一个节点。也就是说，进行合并一次操作中，节点数将会减少\\(1\\)。\r\n如果最终最小割\\(C\\)中的所有边都得以保留下来，那么接下来在这\\(n-1\\)轮迭代中，最小割\\(C\\)的这\\(|C|\\)条边都不允许被选到。令事件\\(A_i(1\\le i&lt;n-1)\\)表示，在第\\(i\\)轮迭代选择的边是不属于\\(C\\)中的边。在前\\(i-1\\)轮都没有选中\\(C\\)中的边的情况下，第\\(i\\)轮也没有选中最小割的边的事件为\\(\\displaystyle{A_i|\\bigcap_{j=1}^{i-1}\r\nA_j}\\)。在第\\(i\\)轮迭代中，迭代前一共有\\(|V|-i+1\\)个节点，因此按照题目24-7-e的结论，有\\(\\displaystyle{\\Pr\\left\\{A_i|\\bigcap_{j=1}^{i-1}\r\nA_j\\right\\}}\\ge 1-\\dfrac{2}{|V|-i+1}\\)。\r\n由于原图\\(G\\)的最小割不一定只有\\(C\\)，因此有\\(\\Pr\\{\\mu(G)=c(u,v)\\}\\ge \\Pr\\{\\mu(G)=c(u,v)\\land\r\n\\text{the minimum cut is } C\\}\\)。因此可以得到\r\n\\(\\begin{aligned}\r\n\\Pr\\{\\mu(G)=c(u,v)\\}&amp;\\ge \\Pr\\{\\mu(G)=c(u,v)\\land \\text{the minimum\r\ncut is } C\\}\\\\\r\n&amp;=\\Pr\\left\\{\\bigcap_{i=1}^{|V|-2} A_i\\right\\}\\\\\r\n&amp;=\\Pr\\{A_1\\}\\cdot \\prod_{i=2}^{|V|-2}\r\n\\Pr\\left\\{A_i|\\bigcap_{j=1}^{i-1} A_j\\right\\}\\\\\r\n&amp;\\ge\\prod_{i=1}^{|V|-2}\\left(1-\\dfrac{2}{|V|-i+1}\\right)\\\\\r\n&amp;=\\prod_{i=0}^{|V|-3}\\dfrac{|V|-i-2}{|V|-i}\\\\\r\n&amp;=\\dfrac{2}{|V|(|V|-1)}\\\\\r\n&amp;=1/\\dbinom{|V|}{2}\\\\\r\n\\end{aligned}\\)\r\n因此得到\\(\\Pr\\{\\mu(G)=c(u,v)\\}=\\Omega\\left(1/\\dbinom{|V|}{2}\\right)\\)。\r\ng\r\n按照题目24-7-f的结论，求解一次最小割失败的概率至多为\\(1-1/\\dbinom{|V|}{2}\\)。假设\\(p\\)为按照题目中所提供的算法重复求取\\(\\dbinom{|V|}{2}\r\n\\ln|V|\\)次全局割后，没有一个是全局最小割的概率。那么考虑\\(p\\)值，有\r\n\\(\\begin{aligned}\r\np&amp;\\le \\left(1-1/\\dbinom{|V|}{2}\\right)^{\\binom{|V|}{2}\\ln |V|}\\\\\r\n&amp;&lt;\\left(\\dfrac{1}{e}\\right)^{\\ln |V|}&amp;\\qquad(A)\\\\\r\n&amp;\\le \\dfrac{1}{|V|}\r\n\\end{aligned}\\)\r\n其中。步骤\\((A)\\)是基于如下事实：\\(\\forall\r\nx&gt;0,\\left(1-\\dfrac{1}{x}\\right)^x&lt;\\dfrac{1}{e}\\)。\r\n从而得知，这个算法能够成功求取一个最小割的概率为\\(1-p\\)，即以至少\\(1-1/|V|\\)的概率至少求出一个最小割。\r\nh\r\n在每一次循环中，以\\(O(1)\\)的时间选好边\\((u,v)\\)后，需要花费\\(O(V)\\)的时间来用新节点\\(x\\)关联原本和\\(u,v\\)关联的所有节点。并且维护好边数函数\\(c\\)。\r\n由于需要进行\\(|V|-2\\)次循环才能将\\(|V|\\)个顶点缩减成\\(2\\)个顶点，因此产生一个全局割的时间复杂度为\\(V\\cdot\r\nO(V)=O(V^2)\\)。具体过程由GEN-GLOBAL-CUT给出。\r\nGEN-GLOBAL-CUT(G, c)  n = |G.V|  for i = 1 to n - 2    select edge (u, v) from E randomly weighted by c    c(u, v) = 0    let x be a new vertex    INSERT(G.V, x)    for each w in G.Adj[u]      if w != v        INSERT(G.Adj[x], w)        c(x, w) = c(x, w) + c(u, w)        c(u, w) = 0        replace u in G.Adj[w] by x      else        DELETE(G.Adj[u], w)        for each w in G.Adj[v]      if w != u        INSERT(G.Adj[x], w)        c(x, w) = c(x, w) + c(v, w)        c(v, w) = 0        replace v in G.Adj[w] by x      else        DELETE(G.Adj[v], w)    DELETE(G.V, u)    DELETE(G.V, v)        return c\r\ni\r\n按照题目24-7-g的结论，哪怕是图\\(G\\)的全局最小割不唯一，只需要按照24-7-h的算法求出\\(|V|^2\\ln |V|\\)个全局割后，至少有\\(1-1/|V|\\)的概率找到\\(1\\)个全局最小割。然而，题目24.7-h求取一个全局割的时间复杂度为\\(O(V^2)\\)。最终，这个算法可以在时间\\(O|V|^2\\ln |V|\\cdot O(V^2)=O(V^4\\lg\r\nV)\\)以内，以至少\\(1-1/|V|\\)的概率求出一个全局最小割。\r\n","categories":["算法导论"]},{"title":"算法导论25.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-25/exercises-2/","content":"\r\n25.2-1\r\n用一个单向链表\\(L_f\\)用于存储所有处于自由状态的女人。用二维数组\\(rkl[i,j]\\)用来表示女人\\(i\\)的第\\(j\\)个排名的男人。用二维数组\\(rkr[i,j]\\)表示男人\\(i\\)的第\\(j\\)个排名的女人。维护一个数组\\(pos\\)，表示女人的求婚过程。具体过程将由GALE-SHAPLEY'给出，其时间复杂度为\\(O(n^2)\\)，其中\\(match[i]\\)表示和男人\\(i\\)结婚的女人。\r\n// 使用数字1~n表示每个男人和女人GALE-SHAPLEY&#x27;(n, rkl, rkr)  Let node[1 : n], pos[1 : n], match[1 : n] be new arrays  // pos-rank[i, j]表示男人i为女人j所给出的排名  Let pos-rank[1 : n, 1 : n] be a new table  // 每个链表节点都有一个数据属性id，表示女人编号。  Let L be a new link list  for i = 1 to n    let node[i] be a new node    node[i].id = i    INSERT-LIST(L, node[i])    // 用-1表示男人处于未婚状态    match[i] = -1    // 一开始女人都是从头开始求婚    pos[i] = 1    for j = 1 to n      pos-rank[i, rkr[i, j]] = j   // 仍然有女人处于自由状态  while L.size &gt; 0    // 女人的编号。    w = L.head.id    DELETE-LIST(L, L.head)    m = rkl[w, pos[w]]    pos[w] = pos[w] + 1    if match[m] == -1      match[m] = w    else      if pos-rank[i, w] &lt; pos-rank[i, match[m]]        // 说明现在的女人排名更高        INSERT(L, node[match[m]])        match[m] = w      else        INSERT(L, node[w])  return match\r\n25.2-2\r\n两个男人和两个女人之间存在不稳定匹配，考虑如下两个女人Wanda,\r\nEmma和两个男人Oscar, Davis。这些女人和男人对异性的排名如下：\r\n\r\nWanda: Oscar, Davis\r\nEmma: Davis, Oscar\r\nOscar: Wanda, Emma\r\nDavis: Emma, Wanda\r\n\r\n那么当前的不稳定匹配如下：\r\n\r\nWanda and Davis\r\nEmma and Oscar\r\n\r\n由于WanDa比起Davis，更喜欢Oscar，并且Oscar比起Emma，更喜欢Wanda，因此WanDa\r\nand\r\nOscar是一个阻塞对，这不是稳定匹配。类似的，Emma比起Oscar，更喜欢Davis，并且Davis比起Wanda，更喜欢Emma，因此Emma\r\nand Davis也是一个阻塞对这同样说明这个匹配不是完美匹配。\r\n25.2-3\r\n我们考虑这个过程是以学生为导向的（这很合理，因为通常都是学生报考学校，然后学校对学生进行评估，再反馈结果）。考虑一共有\\(m\\)个医院，\\(n\\)个学生，且\\(n\\ge m\\)。\r\n每间医院都会对每个学生进行排名。每个学生都会对每间医院进行排名。每个学生都有两个状态：自由和已录取。\r\n一开始，每间医院\\(h\\)的\\(h_c\\)个名额都处于自由状态，并且每个学生也是出于自由状态。接下来每轮迭代中，每个处于自由的学生\\(s\\)将按照它们对医院从高到低的排名，向尚未提交过申请的医院\\(h\\)提交申请。如果\\(h\\)名额仍未招满，那么\\(h\\)将会录取\\(s\\)，并且\\(s\\)变成已录取状态；否则，\\(h\\)按照其内部排名，找出当前最差的录取生\\(s&#39;\\)，和\\(s\\)进行比较。如果\\(s&#39;\\)比\\(s\\)在\\(h\\)中的排名更好，那么拒绝\\(s\\)，否则取消\\(s&#39;\\)并录取\\(s\\)，同时\\(s&#39;\\)变成自由状态，\\(s\\)变成录取状态。\r\n更具体的过程由GALE-SHAPLEY''给出，\\(rkl\\)是每个学生对每间医院的排名，\\(rkr\\)是每间医院对每个学生的排名。由于使用了最大堆来维护每个医院的最差学生，因此其时间复杂度为\\(O(nm\\lg\r\nn)\\)，其它细节和题目25.2-1一致。\r\n// 使用数字1~n表示每个学生，使用数字1~m表示每间医院GALE-SHAPLEY&#x27;&#x27;(n, m, rkl, rkr, hc)  Let node[1 : n], pos[1 : m], match[1 : m] be new arrays  // pos-rank[i, j]表示医院i为学生j所给出的排名  Let pos-rank[1 : m, 1 : n] be a new table  Let L be a new link list  for i = 1 to n    // 每个链表/堆节点都有两个数据属性key和id，其中key是表示排序关键字（也就是当前学生在医院h的排名），id表示学生编号    let node[i] be a new node    node[i].id = i    INSERT-LIST(L, node[i])    // 一开始学生都是从头开始进行申请    pos[i] = 1  for i = 1 to m    for j = 1 to n      pos-rank[i, rkr[i, j]] = j    Let match[i][1 : hc[i]] be a new array  // 仍然有学生处于自由状态  while L.size &gt; 0    // 学生的编号    s = L.head.id    DELETE-LIST(L, L.head)    h = rkl[w, pos[w]]    pos[w] = pos[w] + 1    if match[h].size &lt; hc[h]      node[s].key = pos-rank[h, s]      MAX-HEAP-INSERT(match[h], node[s], hc[h])    else      // x是match[h]中最差的学生      x = MAX-HEAP-MAXIMUM(match[h]).id      if pos-rank[h, s] &lt; pos-rank[h, x]        MAX-HEAP-EXTRACT-MAX(match[h])        INSERT(L, node[x])        node[s].key = pos-rank[h, s]        MAX-HEAP-INSERT(match[h], node[s], hc[h])      else        INSERT(L, node[s])        // 如果s比h中录取的学生都要差，那么把s插回L中。  return match\r\n25.2-4\r\n本题的证明将参考论文。\r\n令女人的集合为\\(X\\)，男人的集合为\\(Y\\)。那么有\\(|X|=|Y|=n\\)。令\\(M\\)表示从GALE-SHAPLEY算法得到的面向女人得到的最优稳定匹配，令\\(\\mu_M(x)\\)表示某组匹配\\(M\\)中\\(x\\)的配偶。在某组匹配\\(M\\)中，定义女人\\(w\\)爱慕男人\\(m\\)如下：\\(w\\)比起她的配偶\\(\\mu_M(w)\\)，更喜欢男人\\(m\\)。也就是说，如果某个匹配\\(M\\)中，两个人\\(w,m\\)相互爱慕，那么\\((w,m)\\)成为一个阻塞对。\r\n使用反证法证明，假设存在这样一个匹配\\(M&#39;\\)，使得每一个女人\\(w\\in X\\)，比起匹配\\(M\\)中的配偶\\(\\mu_m(w)\\)，更喜欢匹配\\(M&#39;\\)中的配偶\\(\\mu_{M&#39;}(w)\\)。最终证明这样的\\(M&#39;\\)并不存在。接下来先证明一个引理。\r\n首先证明引理：令\\(f\\)和\\(g\\)是一个从有限集\\(X\\)到有限集\\(Y\\)的函数，并且\\(f\\)是双射的。那么存在一个非空子集\\(A\\subseteq X\\)使得\\(f\\)和\\(g\\)是从有限集\\(A\\)到有限集\\(f(A):\\{f(x)\\mid x\\in A\\}\\)的双射函数。\r\n证明：令\\(h=f^{-1}\\circ\r\ng\\)，那么函数\\(h\\)将从\\(X\\)映射回\\(X\\)。可见，\\(h^0(X)=X\\)，由于\\(g\\)不一定是满射的，因此\\(h(X)\\subseteq X\\)。也就是说，\\(\\forall n\\ge 0\\)，都有\\(h^{n+1}(X)\\subseteq\r\nh^n(X)\\)，那么必定存在\\(k\\)使得\\(h^{k+1}(X)=h^k(X)\\)，令集合\\(A=h^k(X)\\)，那么集合\\(X\\)为所求。\r\n接下来声称：在面向女人的最优匹配\\(M\\)中，存在一个男人\\(m\\in\r\nY\\)，没有女人爱慕他。使用反正法证明，假设对于所有男人\\(m\\)，都有女人爱慕她。那么令\\(\\alpha_{M}(m)\\)表示对于某个匹配\\(M\\)，男人\\(m\\)的所有爱慕者中，\\(m\\)最喜欢的那个女人。根据上面的引理，存在一个男人的非空子集\\(\\hat{Y}\\subseteq Y\\)使得\\(\\mu_M(\\hat{Y})=\\alpha_M(Y)\\)。现在定义匹配\\(\\hat{M}\\)是只包含了男人\\(\\hat{Y}\\)和女人\\(\\mu_M(\\hat{Y})\\)，并且匹配函数\\(\\mu_{\\hat{M}}\\)是一个从有限集\\(\\hat{Y}\\)到有限集\\(\\mu_{M}(\\hat{Y})\\)的函数。可以证明，\\(\\hat{M}\\)是一个稳定匹配。因为如果\\(\\hat{M}\\)中存在一个阻塞对\\((w,m)\\)，那么\\(m\\in \\hat{Y}\\)，并且女人\\(w\\)爱慕他，但是\\(m\\)在\\(\\hat{M}\\)中已经和他最喜欢且爱慕他的人\\(\\alpha_M(m)\\)进行匹配（不爱慕\\(m\\)的女人根本不会作为出现在\\(\\alpha_M(m)\\)的候选中），和\\(m\\)最爱慕\\(\\alpha_M(m)\\)矛盾（在于这里认为男人\\(m\\)比起\\(\\alpha_M(m)\\)，更喜欢\\(w\\)）。因此这样的阻塞对不存在。\r\n但是对于所有女人\\(w\\in\\mu_M(\\hat{Y})\\)，\\(w\\)更喜欢在匹配\\(M&#39;\\)中的配偶\\(\\mu_{\\hat{M}}(w)\\)，而不是原本匹配\\(M\\)中的配偶\\(\\mu_M(w)\\)。这与稳定匹配\\(M\\)中的配偶是\\(w\\)的最优配偶矛盾。因此原来的声称成立，必定存在一个男人\\(m\\)没有爱慕他的女人。\r\n接下来证明稳定匹配问题的弱帕累托最优性。假设存在一个匹配\\(M&#39;\\)，使得其中每一个女人的配偶都比\\(M\\)中的更优，那么说明在匹配\\(M\\)中，每一个男人都必定存在爱慕他的女人，这和上面的声称是矛盾的。因此题目中的结论成立。\r\n25.2-5\r\n本题的图和原本的题目的区别在于，这时的评价图是一个完全图，而不是一个完全二分图。\r\n假设目前有如下\\(4\\)个人Brent, Davis,\r\nHank, Oscar，他们对其他\\(3\\)人的排名如下：\r\n\r\nBrent: Davis, Hank, Oscar\r\nDavis: Hank, Brent, Oscar\r\nHank: Brent, Davis, Oscar\r\nOscar: Brent, Davis, Hank\r\n\r\n那么可以发现，一共有\\(3\\)组不同的匹配，并且可以说明这\\(3\\)组不同的匹配都不是稳定的。\r\n\r\n考虑如下匹配：\r\n\r\n\r\nBrent and Davis\r\nHank and Oscar\r\n\r\n可见，Davis比起Brent，更喜欢Hank，而Hank比起Oscar，更喜欢Davis，因此Davis\r\nand Hank是一个阻塞对，这不是一个稳定的匹配。\r\n\r\n考虑如下匹配：\r\n\r\n\r\nBrent and Hank\r\nDavis and Oscar\r\n\r\n可见，Brent比起Hank，更喜欢Davis，而Davis比起Oscar，更喜欢Brent，因此Brent\r\nand Davis是一个阻塞对，这不是一个稳定的匹配。\r\n\r\n考虑如下匹配：\r\n\r\n\r\nBrent and Oscar\r\nDavis and Hank\r\n\r\n可见，Brent比起Oscar，更喜欢Hank，而Hank比起Davis，更喜欢Brent，因此Brent\r\nand Hank是一个阻塞对，这不是一个稳定的匹配。\r\n这说明上面给出的示例无法产生一个稳定的匹配。产生这种现象的原因如下：\r\n令\\(P\\)表示这些人的集合，其中一个人\\(z\\)在其他所有人排名都是在最后，但是对于一个匹配\\(M\\)而言，必定存在一个人\\(x\\)和\\(z\\)进行匹配。对于其他人\\(P=\\{x,z\\}\\)，只要至少\\(|P|-2\\)个人（设其为\\(y\\)）对\\(x\\)的排名不是倒数第二名，那么\\((x,y)\\)就成为了阻塞对。\r\n","categories":["算法导论"]},{"title":"算法导论24.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-24/exercises-3/","content":"\r\n24.3-1\r\n接下里将使用残余网络来表示这个流网络，并且由于边容量都是\\(1\\)，因此忽略容量标记值。一开始残余网络如下：\r\n\r\n随后运行BFS，找到了一条增广路径\\((s,1,6,t)\\)。由此可以对残余网络进行更新：\r\n\r\n随后找到了一条增广路径\\((s,2,8,t)\\)。由此可以对残余网络进行更新：\r\n\r\n最后找到了一条增广路径\\((s,3,7,t)\\)，由此可以对残余网络进行更新：\r\n\r\n此后，再也不存在增广路径，因此最大流\\(|f|=3\\)。，从而得到最大匹配\\(|M|=3\\)。\r\n24.3-2\r\n考虑算法FORD-FULKERSON的第3行的while循环，定义循环不变量：对于\\(\\forall (u,v)\\in E,c_f(u,v)\\)和\\((u,v).f\\)总是为整数。接下来证明这个循环变量成立。\r\n初始化：一开始，所有的流\\(f\\)都为\\(0\\)，由于容量只取整数值，因此所有容量\\(c_f(u,v)\\)都是整数，循环不变量得以成立。\r\n保持：假设循环执行前，循环不变量保持成立，此时找到了一条增广路径\\(p\\)。由于\\(\\forall(u,v)\\in\r\nE,c_f(u,v)\\)都是整数，因此从第4行计算出来的\\(c_f(p)\\)是整数。由于对于所有边\\((u,v)\\)的\\(f\\)属性都是整数，因此对\\((u,v).f\\)都减去一个整数\\(c_f(p)\\)，仍然是整数。按照方程24.2更新残余网络的每条边的容量\\(c_f\\)，得到的仍然是整数。\r\n终止：最终while循环停止后，所有边上的流\\(f\\)和残余容量\\(c_f\\)都是整数。\r\n因此，最终计算出来的最大流的值\\(|f|\\)一定是一个整数。\r\n24.3-3\r\n这条增广路径的最大值为：\\(2\\min\\{|L|,|R|\\}+1\\)。令\\(m=\\min\\{|L|,|R|\\}\\)。接下来介绍如何构造达到这个上界的增广路径。\r\n首先构造出图\\(G=(V,E)\\)。从\\(L\\)中取出\\(m\\)个节点，不失一般性，设其为\\(l_1,l_2,\\dots,l_m\\)，从\\(R\\)中也取出\\(m\\)个节点，设其为\\(r_1,r_2,\\dots,r_m\\)。那么\\(\\forall i \\in[1,m],(l_i,r_i)\\in E;\\forall\r\nj\\in[1,m-1],(l_j,r_{j+1})\\in E\\)。对于其它节点\\(u\\in\r\nV-\\{l_1,l_2,\\dots,l_m,r_1,r_2,\\dots,r_m\\}\\)，只需要保证它们在另一部分的节点和\\(u\\)相连即可。最终如此构造出图\\(G\\)。\r\n在前\\(m-1\\)轮迭代中，假设算法FORD-FULKERSON在第\\(i\\)轮的增广路径是\\(s\\rightarrow l_i\\rightarrow r_{i+1}\\rightarrow\r\nt\\)，那么这\\(m-1\\)轮后，残余网络\\(G_f\\)包含了如下这些边：\\(\\{(r_{i+1},l_i)\\mid\r\ni\\in[1,m-1]\\}\\)，那么第\\(m\\)轮所构造的增广路径\\(p\\)可以如下构造：\\(s\\rightarrow l_m\\rightarrow r_m\\rightarrow\r\nl_{m-1}\\rightarrow r_{m-1}\\rightarrow\\dots\\rightarrow r_2\\rightarrow\r\nl_1\\rightarrow r_1\\rightarrow t\\)。\r\n可见，上述所构造的增广路径\\(p\\)达到了长度\\(2m+1=2\\min\\{|L|,|R|\\}+1\\)。由于增广路径\\(p\\)是一条简单路径，\\(L,R\\)中总有一部分节点已经被使用完了，无法再找到一对节点\\((l,r)\\)再延长路径长度，因此只能走向节点\\(t\\)。最终，\\(p\\)是所求满足条件的最长路径。\r\n","categories":["算法导论"]},{"title":"算法导论25.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-25/exercises-1/","content":"\r\n25.1-1\r\n无论是正向BFS阶段还是反向DFS阶段，如果当前节点有多条出边，我们考虑以\\(l_1,l_2,l_3,l_4,l_5,l_6,l_7,r_1,r_2,r_3,r_4,r_5,r_6,r_7,r_8\\)的顺序来枚举这些出边。\r\n第\\(1\\)次迭代如下图所示，找到了增广路径集合\\(\\mathscr{P_1}=\\{(l_1,r_2),(l_2,r_1),(l_3,r_3),(l_4,r_7),(l_5,r_4),(l_7,r_5)\\}\\)。\r\n\r\n第\\(2\\)次迭代如下图所示，找到了增广路径集合\\(\\mathscr{P_2}=\\{(l_6,r_3,l_3,r_6)\\}\\)。\r\n\r\n最终求得的匹配如下图所示，所求得的最大匹配是\\(M=\\{(l_1,r_2),(l_2,r_1),(l_3,r_6),(l_4,r_7),(l_5,r_4),(l_6,r_3),(l_7,r_5)\\}\\)。\r\n\r\n25.1-2\r\n相同点：它们都是用于对当前解进行迭代，逐渐让当前解成为最优解。\r\n不同点：\r\n\r\n解的叠加方式不同。最大流的增广路径是按照定义\\(f\\uparrow\r\nf&#39;\\)的定义进行叠加，而最大匹配的增广路径则是将这条路径中所有的边进行“反相”操作（即如果这条路径\\(P\\)中的每条边\\((u,v)\\)在解中存在，那么下一个解中将会没有这条边，否则将这条边添加进这个解中）。\r\n增广路径边数限制不一样。最大流的增广路径对边数没有要求，而最大匹配的增广路径边数必定为奇数。\r\n\r\n25.1-3\r\n好处在于，不会访问到层数大于\\(d\\)的节点，因此也不需要进行任何合法性判断。\r\n由于第\\(0\\)层的节点都是在图\\(G\\)中尚未得到匹配的左部节点，因此在图\\(G_M\\)中不会有入边。由于\\(H\\)的边集是\\(G_M\\)的边集的子集，因此在\\(H^T\\)中，尚未得到匹配的左部节点不会有出边，因此不会访问到其它无关节点。\r\n如果从\\(H\\)正向DFS寻找增广路径集合，那么需要判断当前访问的节点是否大于必须层数\\(d\\)，如果大于，那么及时返回，避免非法访问。\r\n25.1-4\r\n在第\\(1\\)轮迭代中，搜索得到的增广路径集合的路径长度均为\\(1\\)。由引理25.5可知，随着整个迭代过程的进行，增广路径的长度必定是严格增长的。此外，由于增广路径是分别交替在\\(M,E-M\\)中产生的，并且第一条边和最后一条边都属于\\(E-M\\)，因此每一轮求解的增广路径长度必定比上一轮的长度大于等于\\(2\\)。也就是说，在第\\(m\\)轮迭代repeat循环时，必定有\\(q\\ge 2m-1\\)。\r\n迭代了\\(\\lceil\\sqrt{N}/2\\rceil\\)轮后，那么此时有\\(q\\ge 2\\lceil\\sqrt{N}/2\\rceil-1\\ge\r\n\\lceil\\sqrt{N}\\rceil-1\\)。按照引理25.6，达到最大匹配所仍然需要的迭代数至多为\\(\\dfrac{|V|}{(\\lceil\\sqrt{N}\\rceil+1)-1}=\\dfrac{|V|}{\\lceil\\sqrt{N}\\rceil}\\le\r\n\\sqrt{N}\\)。\r\n因此总共至多需要\\(\\lceil\\sqrt{N/2}\\rceil+\\sqrt{N}\\le\r\n\\lceil3\\sqrt{N}/2\\rceil\\)轮迭代即可得到最大匹配。\r\n\\(\\star\\)\r\n25.1-5\r\n首先证明充分性。令\\(M\\)是这个图的完美匹配。令\\(M[x]\\)表示和节点\\(x\\)匹配的另一个节点。那么由于\\(M\\)是一个完美匹配，因此\\(\\forall x\\in V,M[x]\\)都有定义，并且\\(\\forall x,y\\in V,x\\neq y\\)，都有\\(M[x]\\neq M[y]\\)。\r\n对于任意\\(A\\subseteq\r\nL\\)，按照上面的结论，\\(\\forall x,y\\in\r\nA,x\\neq y\\)，都有\\(M[x]\\neq\r\nM[y]\\)。因此\\(|A|=|\\{M[x]\\mid x\\in\r\nA\\}|\\)。由于\\(M[x]\\)是\\(x\\)的邻居，即\\((x,M[x])\\in E\\)，因此\\(|\\{M[x]\\mid x\\in A\\}|\\le\r\n|N(A)|\\)。因此最终可以证明\\(|A|\\le\r\n|N(A)|\\)，充分性成立。\r\n接下来证明必要性。构造流网络\\(G&#39;=(V&#39;,E&#39;)\\)，其中\\(V&#39;=V\\cup\\{s,t\\},\\forall l\\in L,(s,l)\\in\r\nE&#39;,c(s,l)=1;\\forall r\\in R,(r,t)\\in\r\nE&#39;,c(r,t)=1\\)。并且对于\\(\\forall\r\n(l,r)\\in E,(l,r)\\in E&#39;,c(l,r)=\\infty\\)。\r\n按照推论24.11（无论\\(c(l,r)\\)是取\\(1\\)还是\\(\\infty\\)，推论24.11均成立，论证方式相同），如果\\(G\\)具有一个完美匹配，那么意味着需要证明\\(G&#39;\\)的最大流为\\(|L|\\)，就意味着\\(G&#39;\\)的最小割值为\\(|L|\\)，同时也意味着对于任意关于\\(G&#39;\\)的割\\((S,T)\\)，都有\\(c(S,T)\\ge |V|\\)。\r\n接下来通过证明对于任意关于\\(G&#39;\\)的割\\((S,T)\\)，都有\\(c(S,T)\\ge |V|\\)，从而证明\\(G\\)存在完美匹配。任意取\\(G&#39;\\)的一个有限容量割\\((S,T)\\)（这意味着割\\((S,T)\\)不会有形如\\((l,r)\\)的边横跨过，并且如果\\((S,T)\\)是一个无限容量割，这直接导出结论成立），假设\\(L\\)中有\\(k\\)个节点在\\(S\\)中，令\\(X=L\\cap S\\)，那么\\(L\\)中有\\(|L|-k\\)个节点在\\(T\\)中。\r\n由于\\((S,T)\\)是一个有限容量割，因此\\(\\forall (l,r)\\in E\\)，如果\\(l\\in S\\)，那么\\(r\\in S\\)，这意味着\\(N(X)\\subseteq S\\)。因此\\(c(S,T)\\ge |L-X|+|N(X)|\\ge\r\n(|L|-k)+k=|L|\\)。最终原结论得证。\r\n25.1-6\r\n本定理使用反证法证明。假设\\(\\exists\r\nA\\subseteq L\\)，使得\\(|A|&gt;N(A)\\)成立。那么可知左部点集\\(A\\)中所有边的度数和为\\(d|A|\\)，并且这\\(d|A|\\)条边都连到右部集合\\(N(A)\\)中的所有节点，按照抽屉原理，必定存在一个节点\\(v\\in N(A)\\)，使得\\(v\\)的度数大于\\(d\\)，从而和图\\(G\\)是\\(d\\)正则的矛盾。因此，\\(\\forall A\\subseteq L\\)，都有\\(|A|\\le N(A)\\)。\r\n接下来证明\\(d\\)正则二分图\\(G\\)都包含\\(d\\)个不相交匹配。使用归纳法来证明。对于任何\\(1\\)正则二分图\\(G_1\\)，按照上面的结论，\\(G_1\\)存在一个完美匹配。由于每个节点都只有一度，因此所有边都恰好被使用了，此时\\(G_1\\)恰好有且只有\\(1\\)个完美匹配。原结论成立。现在考虑\\(d\\)正则图\\(G_d=(V,E)\\)，假设对于\\(e=1,2,3,\\dots,d-1,e\\)正则图都满足这个结论。那么根据上面的结论，\\(G_d\\)存在一个完美匹配\\(M\\)。从\\(E\\)中移除所有\\(M\\)中的边后，所有点的度数都减少了\\(1\\)，那么\\(G_d&#39;=(V,E-M)\\)是一个\\(d-1\\)正则图，因此\\(G_d&#39;\\)存在\\(d-1\\)个不相交完美匹配，\\(G_d&#39;\\)中的\\(d-1\\)个不相交完美匹配和\\(M\\)构成了\\(G_d\\)的\\(d\\)个不相交完美匹配，因此原结论成立。\r\n","categories":["算法导论"]},{"title":"算法导论26.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-26/exercises-1/","content":"\r\n26.1-1\r\n一个串行算法的运行轨迹是看起来是一个单链表。相比于图26.2和图26.4所展示的运行轨迹，每个节点最多只有一条入边和一条出边。\r\n26.1-2\r\n相比于原来，现在P-FIB变成了P-FIB'，如下：\r\nP-FIB&#x27;(n)  if n &lt;= 1    return n  else     x = spawn P-FIB&#x27;(n − 1)    y = spawn P-FIB&#x27;(n − 2)    sync    return x + y\r\n与原来的区别在于，父线程一进入else就被挂起，并且产生了两个子线程来求解P-FIB'(n − 1)和P-FIB'(n − 2)，父线程会一直等待，直到这两个线程完成执行，最终才返回计算结果。\r\n因此，除了增加了一些线程本身的空间占用，这种做法并不会产生任何的改进，因此其渐进工作量\\(T_1&#39;\\)仍然为\\(\\Theta(\\phi^n)\\)，其持续时间仍然是\\(T_{\\infty}&#39;=\\Theta(n)\\)，并行度为\\(T_1&#39;/T_{\\infty}&#39;=\\Theta(\\phi^n/n)\\)。\r\n26.1-3\r\n如下图所示，为P-FIB(5)的计算有向无环图。可见，图中有\\(29\\)个节点，因此其工作量为\\(29\\)。此外，粗线表示这个有向无环图的最长链，其一共有\\(10\\)个节点，因此其持续时间为\\(10\\)，最终我们得到并行度为\\(2.9\\)。\r\n\r\n26.1-4\r\n假设这些时间步中，一共有\\(x\\)个非完全步，一共有\\(y\\)个完全步。那么必定有\\(y\\le\\lfloor(T_1 -\r\nx)/P\\rfloor\\)。我们通过反证法来证明这个不等式是成立的。\r\n由于每个非完全步至少有\\(1\\)的工作量，因此至多只有\\(T_1-x\\)的工作量在完全步完成，也就是说，有\\(Py\\le T_1-x\\)。假设\\(y&gt;\\lfloor(T_1 -\r\nx)/P\\rfloor\\)，那么有\r\n\\(\\begin{aligned}\r\nPy&amp;\\ge P\\cdot(\\lfloor(T_1 - x)/P\\rfloor+1)\\\\\r\n&amp;=P\\cdot\\lfloor(T_1 - x)/P\\rfloor+P\\\\\r\n&amp;=P\\cdot\\left(\\dfrac{T_1-x}{P}-((T_1-x)\\bmod P)\\right) + P\\\\\r\n&amp;=T_1-x+P-((T_1-x)\\bmod P)\\\\\r\n&amp;&gt;T_1-x\r\n\\end{aligned}\\)\r\n这和\\(Py\\le T_1-x\\)矛盾，因此有\\(y\\le\\lfloor(T_1 - x)/P\\rfloor\\)。\r\n那么有\\(T_p=x+y\\le x+\\lfloor(T_1 -\r\nx)/P\\rfloor\\)。由于\\(x\\le\r\nT_\\infty\\)，即\\(x\\)是所有时间步的一个子集，因此有\r\n\\(\\begin{aligned}\r\nT_p&amp;\\le x+\\lfloor(T_1 - x)/P\\rfloor\\\\\r\n&amp;\\le x+(T_1 - x)/P\\\\\r\n&amp;\\le T_\\infty+(T_1 - T_\\infty)/P\\\\\r\n\\end{aligned}\\)\r\n原结论成立。\r\n26.1-5\r\n\r\n假设现在有\\(k\\)个处理器，\\(k+1\\)个任务，其中每个串行任务内部一共有\\(m\\)个节点。那么左图是贪心调度器的一种调度，接下来的\\(m\\)个时间步它先完成\\(k\\)个任务的串行节点，然后再花费\\(m\\)个时间步进行剩下的那一个任务，在这种调度下，花费了\\(2m+2\\)个时间步完成整个程序的运行（注意，这里加上了开始和结束的时间步）。如左图所示。\r\n另一种调度则是，每次优先选择剩余时间最长的\\(k\\)个任务运行一个时间步，直到完成所有任务为止。因此，这个过程总共需要\\(\\left\\lceil\\dfrac{(k+1)m}{k}\\right\\rceil+2=\\left\\lceil\r\nm+\\dfrac{m}{k}\\right\\rceil+2\\)个时间步进行。如右图所示。\r\n因此，有\\(\\displaystyle{\\lim_{k\\rightarrow\r\n+\\infty}(2m+2)/\\left(\\left\\lceil\r\nm+\\dfrac{m}{k}\\right\\rceil+2\\right)=2}\\)，这时第一种调度所花费的时间步是第二种调度的接近\\(2\\)倍。\r\n26.1-6\r\n根据工作量定律，有\\(T_1\\le \\min\\{4\\cdot\r\nT_4,10\\cdot T_{10},64\\cdot T_{64}\\}\\)，从而得到\\(T_1\\le 320\\)。\r\n根据持续时间定理，有\\(T_\\infty\\le\r\n\\min\\{T_4,T_{10},T_{64}\\}\\)，从而得到\\(T_\\infty\\le 10\\)。\r\n对\\(T_{10}\\)对应的情况应用不等式26.5，那么有\r\n\\(\\begin{aligned}\r\nT_{10}&amp;\\le \\dfrac{T_1-T_\\infty}{10}+T_\\infty\\\\\r\n&amp;\\le \\dfrac{T_1+9T_\\infty}{10}\\\\\r\n&amp;\\le 32+\\dfrac{9T_\\infty}{10}\r\n\\end{aligned}\\)\r\n从而得到\\(T_\\infty&gt;\\dfrac{100}{9}\\)，这和给出的\\(T_{\\infty}\\le\r\n10\\)是矛盾的，因此这个教授是在撒谎。\r\n26.1-7\r\n可以将提供的P-MAT-VEC-RECURSIVE进行改造后，得到如下代码：\r\nP-MAT-VEC-RECURSIVE-AUX&#x27;(A, x, n, i, j, j&#x27;)  if j == j&#x27;    return a_&#123;i, j&#125; * x_j  else    mid = ⌊(j + j&#x27;) / 2⌋    l = spawn P-MAT-VEC-RECURSIVE-AUX&#x27;(A, x, n, i, j, mid)    r = P-MAT-VEC-RECURSIVE-AUX&#x27;(A, x, n, i, mid + 1, j&#x27;)    sync    return l + rP-MAT-VEC-RECURSIVE&#x27;(A, x, y, n)  parallel for i = 1 to n    y_i = P-MAT-VEC-RECURSIVE-AUX&#x27;(A, x, n, i, 1, n)\r\n其基本思想在于，对于\\(A\\)的每一行都和\\(x\\)独立相乘，得到一个值。然后，先计算这一行左半部分和\\(x\\)的左半部分点积；右半部分和\\(x\\)的左半部分点并行进行计算，最终将结果合并。\r\n因此，P-MAT-VEC-RECURSIVE'的工作量为\\(T_1(n)=\\Theta(n^2)\\)，因为它仍然运行了\\(n^2\\)次乘法运算。\r\nP-MAT-VEC-RECURSIVE'的持续时间\\(T_{\\infty}(n)\\)如下计算。由于P-MAT-VEC-RECURSIVE'中的每次循环都是独立的，因此令\\(iter_{\\infty}(n,i)\\)表示第\\(i\\)次的循环结果，我们可以得到：\r\n\\[T_{\\infty}(n)=\\Theta(\\lg\r\nn)+\\max\\{iter_{\\infty}(n,i):1\\le i\\le n\\}\\]\r\n对于每一次P-MAT-VEC-RECURSIVE-AUX'的调用，我们可以发现，每一次调用都将求和的范围减小，因此有\\(iter_{\\infty}(n,i)=iter_{\\infty}(n/2,i)+\\Theta(1)\\)。根据主定理，可以得到：\r\n\\[iter_{\\infty}(n,i)=\\Theta(\\lg\r\nn)+\\Theta(\\lg n)\\]\r\n因此，我们最终得到\\(T_{\\infty}(n)=\\Theta(\\lg n)+\\Theta(\\lg\r\nn)=\\Theta(\\lg n)\\)。\r\n最终我们得到这个算法的并行度为\\(T_1(n)/T_\\infty(n)=\\Theta(n^2/\\lg\r\nn)\\)。\r\n26.1-8\r\n可见，这个程序的串行投影需要花费\\(\\Theta(n^2)\\)的时间完成，因此其工作量为\\(T_1(n)=\\Theta(n^2)\\)。\r\n接下来求解持续时间\\(T_{\\infty}(n)\\)。令\\(iter_1(j)(2\\le j\\le\r\nn)\\)表示其外层循环所需要的时间，\\(iter_2(i)(1\\le j&lt;\r\nn)\\)表示其内层循环所需要的时间。\r\n如果将内层for循环的parallel关键字转化为spawn ... sync结构后，那么可以得知\\(iter_1(i)=\\Theta(\\lg i)+\\max\\{iter_2(j):1\\le\r\nj&lt;i\\}\\)。可以知道，由于\\(iter_2(j)=\\Theta(1)\\)，因此有\\(iter_1(i)=\\Theta(\\lg i)+\\Theta(1)=\\Theta(\\lg\r\ni)\\)。\r\n再将外层for循环的parallel关键字转化为spawn ... sync结构后，那么可以得知\\(T_{\\infty}(n)=\\Theta(\\lg n)+\\max\\{iter_1(i):2\\le\r\nj\\le n\\}=\\Theta(\\lg n)+\\Theta(\\lg n)\\)。从而得到\\(T_{\\infty}(n)=\\Theta(\\lg n)\\)。\r\n因此并行度为\\(T_1(n)/T_{\\infty}(n)=\\Theta(n^2/\\lg\r\nn)\\)。\r\n26.1-9\r\n也就是说，现在的程序转化为P-TRANSPOSE'，即：\r\nP-TRANSPOSE(A, n)  parallel for j = 2 to n    for i = 1 to j − 1      exchange a_&#123;ij&#125; with a_&#123;ji&#125;\r\n工作量和题目28.1-8的情况一样，为\\(T_1(n)=\\Theta(n^2)\\)。\r\n接下来求解持续时间\\(T_{\\infty}(n)\\)。令\\(iter(j)(2\\le j\\le\r\nn)\\)表示其外层循环所需要的时间，由内层循环可以知道，\\(iter(j)=\\Theta(j)\\)。将外层for循环的parallel关键字转化为spawn ... sync结构后，那么可以得知\\(T_{\\infty}(n)=\\Theta(\\lg n)+\\max\\{iter(i):2\\le\r\nj\\le n\\}=\\Theta(\\lg n)+\\Theta(n)\\)。因此，我们最终得到\\(T_{\\infty}(n)=\\Theta(\\lg\r\nn)+\\Theta(n)=\\Theta(n)\\)。\r\n因此并行度为\\(T_1(n)/T_{\\infty}(n)=\\Theta(n^2/n)=\\Theta(n)\\)。\r\n26.1-10\r\n相当于解如下关于未知数\\(P,T_P,T_P&#39;\\)的方程组：\r\n\\[\\left \\{\\begin{aligned}\r\n  &amp;T_P=\\dfrac{T_1}{P}+T_\\infty\\\\\r\n  &amp;T_P&#39;=\\dfrac{T_1&#39;}{P}+T_\\infty&#39;\\\\\r\n  &amp;T_P=T_P&#39;\\\\\r\n\\end{aligned}\\right.\\]\r\n其中\\(T_1=2048,T_{\\infty}=1,T_1&#39;=1024,T_{\\infty}&#39;=8\\)，最终得到解：\r\n\\[\\left \\{\\begin{aligned}\r\n  &amp;P=\\dfrac{1024}{7}\\\\\r\n  &amp;T_P=15\\\\\r\n  &amp;T_P&#39;=15\\\\\r\n\\end{aligned}\\right.\\]\r\n也就是说，只需要约\\(146\\)或者\\(147\\)个处理器就能使这两个版本的算法运行时间相同。\r\n","categories":["算法导论"]},{"title":"算法导论26.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-26/exercises-3/","content":"\r\n26.3-1\r\n基本思想是，只需要当前排序的数组长度小于等于某个很小的阈值\\(K\\)，那么就选择使用原本串行的归并方式。否则使用当前优化过的归并方式，这个过程由P-MERGE'给出。其中MEGRE'和MERGE相比，表示将排序结果存储到\\(B\\)中（而不是原本的\\(A\\)中）。\r\nP-MERGE&#x27;(A, p, q, r)  let B[p : r] be a new array             // allocate scratch array  if r - p &gt; M    P-MERGE-AUX(A, p, q, q + 1, r, B, p)  // merge from A into B  else    MERGE&#x27;(A, p, q, r, B)  parallel for i = p to r                 // copy B back to A in parallel    A[i] = B[i]\r\n26.3-2\r\n通过对题目9.3-10给出的MEDIAN3进行改造，我们给出了一个程序MEDIAN4，它用于求解两个有序数组\\(A[1:n],B[1:m]\\)中的中位数。\r\n// 找出数组A[i : n], B[j : m]中的第k小数。SELECT4(A, i, n, B, j, m, k)  if i &gt; n    return B[j + k - 1]  else if j &gt; m    return A[j + k - 1]  else if k == 1    return min&#123;A[i], B[j]&#125;  if i + ⌊k/2⌋ - 1 &lt;= n    midl = A[i + ⌊k/2⌋ - 1]  else    midl = +∞  if j + ⌊k/2⌋ - 1 &lt;= m    midr = B[i + ⌊k/2⌋ - 1]  else    midr = +∞  if midl &lt; midr    return SELECT4(A, i + ⌊k/2⌋, n, B, j, m, k - ⌊k/2⌋, n)  else    return SELECT4(A, i, n, B, j + ⌊k/2⌋, m, k - ⌊k/2⌋, n)MEDIAN4(A, B, n, m)  return SELECT4(A, 1, n, B, 1, m, ⌊(n + m) / 2⌋)\r\n由此可以将P-MERGE-AUX修改成P-MERGE-AUX'，如下：\r\nP-MERGE-AUX(A, p1, r1, p2, r2, B, p3)  if p1 &gt; r1 and p2 &gt; r2    return  if r1 − p1 &lt; r2 − p2    exchange p1 with p2    exchange r1 with r2  x = MEDIAN4(A[p1 : r1], B[p2 : r2], r1 - p1 + 1, r2 - p2 + 2)  q2 = FIND-SPLIT-POINT(A, p2, r2, x)  q3 = p3 + (q1 − p1) + (q2 − p2)   B[q3] = x  spawn P-MERGE-AUX(A, p1, q1 − 1, p2, q2 − 1, B, p3)  spawn P-MERGE-AUX(A, q1 + 1, r1, q2, r2, B, q3 + 1)  sync\r\n先求解P-MERGE-AUX'的工作量\\(T_1(n)\\)。可见，由于每次都淘汰了数组中一半的元素，并且每一轮除了递归部分，只需要\\(\\Theta(\\lg n)\\)的时间运行。因此有\\(T_1(n)=2T_1(n/2)+\\Theta(\\lg\r\nn)\\)。根据主定理可以得到\\(T_1(n)=\\Theta(n)\\)。\r\n接下来求解P-MERGE-AUX'的持续时间\\(T_{\\infty}(n)\\)。同样的，我们得到\\(T_\\infty(n)=T_\\infty(n/2)+\\Theta(\\lg\r\nn)\\)。从而得到\\(T_{\\infty}(n)=\\Theta(\\lg^2n)\\)。\r\n由于P-MERGE-AUX'的工作量和持续时间都不变，因此得到的P-MERGE'得到的工作量和持续时间和第26.3章分析的一样，分别为\\(\\Theta(n)\\)和\\(\\Theta(\\lg^2n)\\)。因此其并行量仍然为\\(\\Theta(n/\\lg^2 n)\\)。\r\n26.3-3\r\nPARTITION的并行化版本P-PARTITION如下展示。\r\n// 令T[p, r]表示一棵二叉树T存储了区间[p, r]内所有数的相关信息，包括：// small：A[p, r]中小于等于x的数的个数。// large：[p, r]中大于x的数的个数。P-PARTITION-CAL(A, p, r, x)  if p == r    if A[p] &lt;= x      T[p, r].small = 1      T[p, r].large = 0      return (1, 0)    else      T[p, r].small = 0      T[p, r].large = 1      return (0, 1)  else    mid = ⌊(p + r) / 2⌋    cl-small, cl-large = spawn P-PARTITION-CAL(A, p, mid, x)    cr-small, cr-large = spawn P-PARTITION-CAL(A, mid + 1, q, x)    sync    T[p, r].small = cl-small + cr-small    T[p, r].large = cl-large + cr-large    return (T[p, r].small, T[p, r].large)P-PARTITION-FILL(A, p, r, x, B, ls, rs, ll, rl)  if p == r:    if A[p] &lt;= x      B[ls] = A[p]    else      B[ll] = A[p]  else    mid = ⌊(p + r) / 2⌋    spawn P-PARTITION-FILL(A, p, mid, x, B, ls, ls + T[p, mid].small - 1, ll, ll + T[p, mid].large + 1)    spawn P-PARTITION-FILL(A, p, mid, x, B, rs - T[mid + 1, r].small + 1, rs, rl - T[mid + 1, r].large + 1, rl)    syncP-PARTITION(A, p, r)  if p == r    return p  x = A[r]  c-small, c-large = P-PARTITION-CAL(A, p, r - 1, x)  let B[p : r] be a new array  q = p + c-small  B[q] = x  P-PARTION-FILL(A, p, r, x, B, p, p + c-small - 1, r - c-large + 1, r)  parallel for i = p to r    A[i] = B[i]  return q\r\n我们可以首先并行化地构筑出一棵二叉树\\(T\\)，其中\\(T[l,r]\\)存储区间\\([l,r]\\)内的信息：小于等于\\(x\\)的元素个数和大于\\(x\\)的元素个数。我们可以知道这棵树的节点数为\\(\\displaystyle{\\sum_{i=0}^{\\infty}\\left\\lceil\\dfrac{n}{2^i}\\right\\rceil}=\\Theta(n)\\)。\r\n因此，第一趟遍历首先是将这棵树的所有节点信息先处理出来（如P-PARTITION-CAL所示），由于这棵树一共有\\(\\Theta(n)\\)个节点，其深度为\\(\\Theta(\\lg\r\nn)\\)，因此这一部分的工作量为\\(\\Theta(n)\\)，持续时间为\\(\\Theta(\\lg n)\\)。\r\n第二趟遍历则是按照树给定的信息，自底向上地将所有元素填入新数组\\(B\\)中（如P-PARTITION-FILL所示）。这一部分的分析和第一趟类似，这一部分的工作量为\\(\\Theta(n)\\)，持续时间为\\(\\Theta(\\lg n)\\)。\r\n第三趟遍历则是将\\(B\\)数组并行地填入\\(A\\)中对应位置，因此这一部分的工作量为\\(\\Theta(n)\\)，持续时间为\\(\\Theta(\\lg n)\\)。\r\n也就是说，P-PARTITION的工作量\\(T_1(n)\\)满足\\(T_1(n)=2T_1(n/2)+\\Theta(1)\\)，即得到\\(T_1(n)=\\Theta(n)\\)。其工作时间\\(T_{\\infty}(n)\\)满足\\(T_\\infty(n)=T_{\\infty}(n/2)+\\Theta(1)=\\Theta(\\lg\r\nn)\\)。因此其并行度为\\(\\Theta(n/\\lg\r\nn)\\)。\r\n26.3-4\r\n给出的FFT的并行版本P-FFT如下：\r\nFFT(a, n)  if n == 1    return a  let a-even_&#123;0 : n / 2 - 1&#125;, a-odd_&#123;0 : n / 2 - 1&#125; be new arrays  parallel for k = 0 to n / 2 - 1    a-even_&#123;k&#125; = a_&#123;k * 2&#125;    a_odd_&#123;k&#125; = a_&#123;k * 2 + 1&#125;  y-even = spawn FFT(a-even, n / 2)  y-odd = spawn FFT(a-odd, n / 2)  sync  parallel for k = 0 to n / 2 - 1    ω = exp(2 * π * i * k / n)    y_k = y-even_&#123;k&#125; + ω * y-odd_&#123;k&#125;    y_&#123;k + n / 2&#125; = y-even_&#123;k&#125; - ω * y-odd_&#123;k&#125;  return y\r\nP-FFT和其串行投影FFT的区别在于：将\\(a\\)向量进行奇偶划分的过程可以并行完成。其次，\\(y^{even},y^{odd}\\)的计算也是同时派生出两个子线程再进行合并。此外，\\(\\omega_n^k\\)的值不能够递推计算，它只能以\\((\\omega_n)^k\\)的方式进行计算。\r\n可见其串行投影为普通的FFT，因此其工作量为\\(T_1(n)=\\Theta(n\\lg n)\\)。\r\n每次递归，它都会将两个大小恰好为一半的两个子问题进行递归计算，其余部分只需要\\(\\Theta(\\lg\r\nn)\\)的时间就能够完成好（如两次次parallel for循环以及\\(\\omega_n^k\\)的计算），因此其持续时间满足\\(T_{\\infty}(n)=T_{\\infty}(n/2)+\\Theta(\\lg\r\nn)\\)，最终得到\\(T_{\\infty}(n)=\\Theta(\\lg^2n)\\)。\r\n因此，P-FFT的并行度为\\(T_1(n)/T_{\\infty}(n)=\\Theta(n/\\lg\r\nn)\\)。\r\n\\(\\star\\)\r\n26.3-5\r\nP-SELECT(A, p, r, i)  g = ⌊(r – p + 1) / 5⌋  f = (r - p + 1) % 5  parallel for j = p to p + g – 1    sort〈A[j], A[j + g], A[j + 2 * g], A[j + 3 * g], A[j + 4 * g]〉in place  for j = 0 to t - 1    exchange A[p + 3 * g + j] with A[p + 5 * g + j]   x = P-SELECT(A, p + 2 * g, p + 3 * g + f – 1, ⌈(g + f) /2⌉)  q = P-PARTITION-AROUND(A, p, r, x)  k = q – p + 1  if i == k    return A[q]  else if i &lt; k    return P-SELECT(A, p, q – 1, i)  else     return P-SELECT(A, q + 1, r, i – k)\r\n修改后得到的P-SELECT算法如上。相比于SELECT，P-SELECT将未满一个组的五个元素进行了延后处理。此外，套用题目26.3-3的结论，P-PARTITION-AROUND可以由PARTITION-AROUND转化而来。其余部分只需要\\(\\Theta(\\lg n)\\)的时间即可完成。\r\n因此，P-SELECT的工作量\\(T_1(n)\\)和SELECT的运行时间一样，为\\(\\Theta(n)\\)。\r\nP-SELECT的持续时间\\(T_{\\infty}(n)\\)可以由\\(T_{\\infty}(n)\\le\r\nT_{\\infty}(n/5)+T_{\\infty}(7n/10)+\\Theta(\\lg\r\nn)\\)给出。这里可以考虑使用第4.7章介绍的Akra-Bazzi方法进行求解。\r\n令\\(c_1=\\dfrac{1}{5},c_2=\\dfrac{7}{10}\\)，构造关于未知数\\(p\\)的方程\\(c_1^p+c_2^p=1\\)，可以得到\\(p\\approx\r\n0.84\\)。因此，使用等式4.23，可以得到\r\n\\(\\begin{aligned}\r\nT_{\\infty}(n)&amp;=\\Theta\\left(n^p\\left(1+\\int_{1}^n\r\n\\dfrac{f(x)}{x^{p+1}}dx\\right)\\right) \\\\\r\n&amp;=\\Theta\\left(n^p\\left(1+\\int_{1}^n \\dfrac{\\lg\r\nx}{x^{p+1}}dx\\right)\\right) \\\\\r\n&amp;=\\Theta\\left(n^p\\left(1+\\left(\\dfrac{1-n^{-p}(1+p\\ln n)}{p^2\\ln\r\n2}\\right)\\right)\\right) \\\\\r\n&amp;=\\Theta(n^p)\r\n\\end{aligned}\\)\r\n因此，P-SELECT的并行度为\\(T_1(n)/T_{\\infty}(n)=\\Theta(n^{1-p})\\approx\\Theta(n^{0.16})\\)。\r\n","categories":["算法导论"]},{"title":"算法导论25.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-25/exercises-3/","content":"\r\n25.3-1\r\n修改后的代码由FIND-AUGMENTING-PATH'给出。\r\nFIND-AUGMENTING-PATH&#x27;(GM, h)  Q = Ø  FL = Ø  FR = Ø  for each unmatched vertex l ∈ L    l.π = NIL    ENQUEUE(Q, l)    FL = FL ∪ &#123;l&#125;   // forest F starts with unmatched vertices in L  repeat    if Q is empty   // ran out of vertices to search from?      δ = min &#123; l.h + r.h − w(l, r) : l ∈ FL and r ∈ R − FR &#125;      for each vertex l ∈ FL        l.h = l.h − δ   // relabel according to equation      for each vertex r ∈ FR        r.h = r.h + δ   // relabel according to equation      from G, M, and h, form a new directed equality graph GM,h      FL = Ø      FR = Ø      for each unmatched vertex l ∈ L        l.π = NIL        ENQUEUE(Q, l)        FL = FL ∪ &#123;l&#125;    u = DEQUEUE(Q)                          // search from u    for each neighbor v of u in GM,h      if v ∈ L        v.π = u                                     FL = FL ∪ &#123;v&#125;                       // discover v, add it to F        ENQUEUE(Q, v)                       // can search from v later      else if v ∉ FR                        // v ∈ R, do same as lines 18–22        v.π = u        if v is unmatched          an M-augmenting path has been found (exit the repeat loop)        else           ENQUEUE(Q, v)          FR = FR ∪ &#123;v&#125;  until an M-augmenting path has been found  using the predecessor attributes π, construct an M-augmenting path P by tracing back from the unmatched vertex in R  return P\r\n缺点在于，每次对相等子图\\(G_h\\)更新后，都需要重新对整个图重新进行BFS，而原来的算法FIND-AUGMENTING-PATH只需要按照原来的搜索结果继续往下搜索即可。不过，FIND-AUGMENTING-PATH'的这个改动并没有对渐进时间复杂度\\(O(n^4)\\)变坏。\r\n25.3-2\r\n对于任意二分图\\(G\\)，考虑其中一个最大匹配\\(M\\)。在\\(M\\)看来，算法GREEDY-BIPARTITE-MATCHING相当于将选择任意\\(G\\)中选择任意一条边\\((l,r)\\)加入候选答案\\(M&#39;\\)，并且在此之前\\(l,r\\)未曾出现在\\(M&#39;\\)中。每次加入一条边进\\(M&#39;\\)后，\\(M\\)至多有两条边不再可能添加到\\(M&#39;\\)中（其中一条包含\\(l\\)，另一条包含\\(r\\)）。因此，贪心算法GREEDY-BIPARTITE-MATCHING至少可以迭代\\(\\lfloor M/2\\rfloor\\)轮。如果\\(|M|\\)是偶数，那么证明完成。如果\\(M\\)是奇数，那么迭代\\(\\lfloor M/2\\rfloor\\)轮后，\\(M\\)中必定会存在一条边\\(e\\)，使得\\(e\\)中两个节点尚未出现在\\(M&#39;\\)中。也就是说，\\(G\\)中仍然必定存在一条边能够加入\\(M&#39;\\)中。因此，最终无论如何都有\\(|M&#39;| \\ge |M|/2\\)，原结论成立。\r\n25.3-3\r\n按照引理25.15，可以知道\\(l.h+r.h\\ge\r\nw(l,r),l.h&#39;+r.h&#39;\\ge w(l,r)\\)。\r\n由于\\((l,r)\\in\r\nG_{M,h}\\)，因此有\\(l.h+r.h=w(l,r)\\)；由于\\((l,r)\\not\\in G_{M,h&#39;}\\)，那么有\\(l.h&#39;+r.h&#39;&gt;w(l,r)\\)。\r\n按照方程25.5对属性\\(h&#39;\\)的定义，可知左部节点\\(l\\)的\\(h\\)属性非递增，有部节点\\(r\\)的\\(h\\)属性非递减。由于\\(l.h+r.h=w(l,r)\\)的下一步就得出了\\(l.h&#39;+r.h&#39;&gt;w(l,r)\\)，因此只能有\\(l.h&#39;=l.h,r.h&#39;=r.h+\\delta\\)，因此按照方程25.5，有\\(l\\in L-F_L,r\\in F_R\\)。\r\n25.3-4\r\n当一个左部节点\\(l\\)被访问时，它只有两种情况：如果\\(l\\)是尚未被匹配的节点，按照\\(G_{M,h}\\)的图构造，\\(l\\)必定是BFS森林\\(F\\)的某一个根，即某个起点。如果\\(l\\)是已经被匹配所覆盖的节点，那么必定存在一个右部节点\\(r\\)，并且\\((r,l)\\in E_{M,h}\\)，再从\\(r\\)节点访问\\(l\\)节点，由于\\(M\\)中的边都是不相交的，因此节点\\(l\\)在\\(G_{M,h}\\)中只有唯一一条入边。因此，\\(\\forall l\\in L\\)，节点\\(l\\)只会被访问一次，因此不需要判断是否重新发现。\r\n25.3-5\r\n图\\(G_{M,h}\\)不需要显示构造出来，只需要用两个长度为\\(n\\)的一维数组标记好\\(h\\)值即可。事实上，接下来的操作可以视为是在图的邻接矩阵上进行操作。这个算法由HUNGARIAN''给出。同样的，它的时间复杂度和HUNGARIAN一样，为\\(O(n^4)\\)。\r\n//左部节点用整数1~n来表示，右部节点用n+1~2n来表示，并且函数w(i,j)的定义域是1&lt;=i&lt;=n&lt;j&lt;=2nHUNGARIAN&#x27;&#x27;(w, n)  let h[1 : n + n] be new arrays  for i = 1 to n + n    if i &lt;= n      h[i] = max&#123;w(i, j) : n + 1 &lt;= j &lt;= n + n&#125;    else      h[i] = 0  // match[j]表示右部节点j将要匹配的左部节点，如果为0，表示暂时还没有左部节点与之匹配  let match[1 : n] be any matching in Gh (such as the matching returned by GREEDY-BIPARTITE-MATCHING)  while match still contain element 0    P = FIND-AUGMENTING-PATH&#x27;&#x27;(w, n, h, match)    m = P.size    for i = 2 to m by 2      // P[i]一定是右部节点        match[P[i]] = P[i - 1]  return matchFIND-AUGMENTING-PATH&#x27;&#x27;(w, n, h, match)  Q = Ø  FL = Ø  FR = Ø  for each unmatched vertex l ∈ L    l.π = NIL    ENQUEUE(Q, l)    FL = FL ∪ &#123;l&#125;  repeat    if Q is empty      δ = min &#123; h[l] + h[r] − w(l, r) : l ∈ FL and r ∈ R − FR &#125;      for each vertex l ∈ FL        h[l] = h[l] − δ      for each vertex r ∈ FR        h[r] = h[r] + δ      for each vertex l ∈ FL        for each vertex r ∈ R - FR          if h[l] + h[r] == w(l, r)            r.π = l            if match[r] == 0              // 代表r仍然未被匹配              an M-augmenting path has been found (exit the repeat loop)          else             ENQUEUE(Q, r)            FR = FR ∪ &#123;r&#125;    u = DEQUEUE(Q)    if 1 &lt;= u &lt;= n      // 这时u是左部节点      for r = n + 1 to n + n        if h[u] + h[r] == w(u, r) and r ∉ FR           r.π = u          if match[r] == 0            an M-augmenting path has been found (exit the repeat loop)          else            ENQUEUE(Q, r)            FR = FR ∪ &#123;r&#125;    else      // 这时u是右部节点      l = match[u]      l.π = u      FL = FL ∪ &#123;l&#125;      ENQUEUE(Q, l)  until an M-augmenting path has been found  using the predecessor attributes π, construct an M-augmenting path P by tracing back from the unmatched vertex in R  return P\r\n25.3-6\r\n只需要将所有边权全部取负，得到新边权函数\\(w&#39;\\)，再使用\\(w&#39;\\)运行原本的匈牙利算法即可。最终所求得的匹配\\(M\\)就是最小匹配。\r\n25.3-7\r\n不失一般性，假设\\(|L|&lt;|R|\\)，那么为\\(L\\)补充\\(|R|-|L|\\)个虚拟节点，集合为\\(L&#39;\\)，并且将它们对\\(R\\)中的所有节点连向所有边，且权值为\\(0\\)，最终得到新图\\(G&#39;\\)。更正式的说，\\(G&#39;=(V&#39;,E&#39;),V&#39;=L&#39;\\cup L\\cup\r\nR,\\forall l&#39;\\in L&#39;,r\\in R,w(l,r)=0\\)。\r\n接下来对新图\\(G&#39;\\)运行匈牙利算法得到最大匹配\\(M&#39;\\)，对于\\(R\\)中的所有节点\\(r\\)，如果\\(r\\)在\\(M&#39;\\)中连向了虚拟结点\\(L&#39;\\)，那么\\(r\\)在原最大匹配中是孤立节点。最终，从\\(M&#39;\\)去掉这些虚拟节点所关联的边那么就得到原图的最大匹配\\(M\\)。\r\n","categories":["算法导论"]},{"title":"算法导论26.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-26/exercises-2/","content":"\r\n26.2-1\r\n使用P-MATRIX-MULTIPLY计算\\(2\\times 2\\)矩阵的轨迹如下图所示：\r\n\r\n可见，图中有\\(13\\)个节点，因此其工作量为\\(13\\)。此外，粗线表示这个有向无环图的最长链，其一共有\\(6\\)个节点，因此其持续时间为\\(6\\)，最终我们得到并行度为\\(\\dfrac{13}{6}\\)。\r\n26.2-2\r\n使用P-MATRIX-MULTIPLY-RECURSIVE计算\\(2\\times 2\\)矩阵的轨迹如下图所示：\r\n\r\n可见，图中有\\(42\\)个节点，因此其工作量为\\(42\\)。此外，粗线表示这个有向无环图的最长链，其一共有\\(23\\)个节点，因此其持续时间为\\(23\\)，最终我们得到并行度为\\(\\dfrac{42}{23}\\)。\r\n26.2-3\r\n对P-MATRIX-MULTIPLY修改后，由P-MATRIX-MULTIPLY'给出。\r\nP-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, k, k&#x27;)  if k == k&#x27;    return a_&#123;ik&#125; * b_&#123;kj&#125;  else    mid = ⌊(k + k&#x27;) / 2⌋    l = spawn P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, k, mid)    r = P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, mid, k&#x27;)    sync    return l + rP-MATRIX-MULTIPLY&#x27;(A, B, C, n)  parallel for i = 1 to n    parallel for j = 1 to n      C_&#123;ij&#125; = P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, 1, n)\r\n可以知道其工作量为\\(T_1(n)=\\Theta(n^3)\\)。\r\n对程序P-MATRIX-MULTIPLY-AUX'的分析和对题目26.1-7中对P-MAT-VEC-RECURSIVE-AUX'的分析完全一致。因此，假设\\(iter_n(i,j)\\)表示外层循环为\\(i\\)，内层循环为\\(j\\)时的运行时间，那么有\\(iter_n(i,j)=O(\\lg n)\\)。\r\n由于P-MATRIX-MULTIPLY'首先沿着parallel for循环\\(i\\)的递归树的路径向下，然后沿着内层循环parallel for循环\\(j\\)的递归树的路径向下，因此这个算法的持续时间为\\(T_{\\infty}(n)=\\Theta(\\lg n)+\\Theta(\\lg\r\nn)+\\max\\{iter_n(i,j):1\\le i,j\\le n\\}=\\Theta(\\lg n)\\)。\r\n因此并行度为\\(T_1(n)/T_{\\infty}(n)=\\Theta(n^3/\\lg\r\nn)\\)。\r\n26.2-4\r\n考虑对题目26.2-3的代码P-MATRIX-MULTIPLY'进行修改，最终由P-MATRIX-MULTIPLY''给出。\r\nP-MATRIX-MULTIPLY-AUX&#x27;&#x27;(A, B, i, j, k, k&#x27;)  if k == k&#x27;    return a_&#123;ik&#125; * b_&#123;kj&#125;  else    mid = ⌊(k + k&#x27;) / 2⌋    l = spawn P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, k, mid)    r = P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, mid, k&#x27;)    sync    return l + rP-MATRIX-MULTIPLY&#x27;&#x27;(A, B, C, p, q, r)  parallel for i = 1 to p    parallel for j = 1 to r      C_&#123;ij&#125; = P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, 1, q)\r\n使用和题目26.2-3一样的分析方式，我们可以知道这个算法的工作量为\\(T_1(n)=\\Theta(pqr)\\)。\r\n如果假设\\(iter_n(i,j)\\)表示外层循环为\\(i\\)，内层循环为\\(j\\)时的运行时间，那么有\\(iter_n(i,j)=O(\\lg\r\nq)\\)。那么这个算法的持续时间为\\(T_{\\infty}(n)=\\Theta(\\lg p)+\\Theta(\\lg\r\nr)+\\max\\{iter_n(i,j):1\\le i\\le p,1\\le j\\le r\\}=\\Theta(\\lg\r\n(pqr))\\)。\r\n因此并行度为\\(T_1(n)/T_{\\infty}(n)=\\Theta(pqr/\\lg\r\n(pqr))\\)。\r\n26.2-5\r\n修改后的可并行化的Floyd-Warshall算法由P-FLOYD-WARSHALL'给出（使用题目23.2-4的Floyd-Warshall算法伪代码FLOYD-WARSHALL'进行修改）：\r\nP-FLOYD-WARSHALL&#x27;(W, n)  D = W  for k = 1 to n    parallel for i = 1 to n      parallel for j = 1 to n        d_&#123;ij&#125; = min &#123;d_&#123;ij&#125;, d_&#123;ik&#125; + d_&#123;kj&#125; &#125;6 return D\r\n首先说明一下这样修改的正确性。可见，在第\\(k\\)轮循环中，P-FLOYD-WARSHALL'的第5行只会使用\\(D\\)的第\\(k\\)行和第\\(k\\)列中的元素进行读取，并对其它元素进行修改。由于原来的图是一个非负边权的图，因此哪怕对\\(d_{ik},d_{kj}\\)这样的元素进行更新，也不会对原本的值进行改变。因此。这个算法通过如此并行化完成是正确的。\r\n这个程序的串行投影需要花费\\(\\Theta(n^3)\\)的时间完成，因此其工作量为\\(T_1(n)=\\Theta(n^3)\\)。\r\n接下来求解持续时间\\(T_{\\infty}(n)\\)。假设\\(iter_n(i,j)\\)表示外层parallel for循环为\\(i\\)，内层parallel for循环为\\(j\\)时的运行时间，那么有\\(iter_n(i,j)=O(1)\\)，因为接下来只有一个较小值更新操作和加法操作。将两层循环中的parallel关键字转化为spawn ... sync结构后，那么可以得知\\(T_{\\infty}(n)=\\Theta(\\lg n)+\\Theta(\\lg\r\nn)+\\max\\{iter_n(i,j):1\\le i,j\\le n\\}=\\Theta(\\lg\r\nn)\\)。由于这个两层parallel for循环需要串行地执行\\(k\\)次，因此我们可以求出\\(T_{\\infty}(n)=n\\cdot \\Theta(\\lg n)=\\Theta(n\\lg\r\nn)\\)。\r\n最终并行度为\\(T_1(n)/T_{\\infty}(n)=\\Theta(n^3/(n\\lg\r\nn))=\\Theta(n^2/\\lg n)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论28.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-28/exercises-1/","content":"\r\n28.1-1\r\n根据前向替代的过程，可以知道：\r\n\\(\\begin{aligned}\r\nx_1&amp;=b_1=3\\\\\r\nx_2&amp;=b_2-\\sum_{j=1}^1 a_{2,j} x_j=14-4\\cdot 3=2\\\\\r\nx_3&amp;=b_3-\\sum_{j=1}^2 a_{3,j} x_j=-7-(-6)\\cdot 3-5\\cdot 2=1\\\\\r\n\\end{aligned}\\)\r\n也就是有解\\(\\begin{bmatrix}\r\nx_1\\\\\r\nx_2\\\\\r\nx_3\\\\\r\n\\end{bmatrix}=\r\n\\begin{bmatrix}\r\n3\\\\\r\n2\\\\\r\n1\\\\\r\n\\end{bmatrix}\\)。\r\n28.1-2\r\n以下是多轮进行迭代的结果：\r\n\\(\\begin{array}{c|c}\r\nL&amp;U\\\\\r\n\\begin{bmatrix}\r\n1&amp;0&amp;0\\\\\r\n0&amp;1&amp;0\\\\\r\n0&amp;0&amp;1\\\\\r\n\\end{bmatrix}&amp;\r\n\\begin{bmatrix}\r\n0&amp;0&amp;0\\\\\r\n0&amp;0&amp;0\\\\\r\n0&amp;0&amp;0\\\\\r\n\\end{bmatrix}\\\\\r\n\\begin{bmatrix}\r\n1&amp;0&amp;0\\\\\r\n2&amp;1&amp;0\\\\\r\n3&amp;0&amp;1\\\\\r\n\\end{bmatrix}&amp;\r\n\\begin{bmatrix}\r\n4&amp;-5&amp;6\\\\\r\n0&amp;0&amp;0\\\\\r\n0&amp;0&amp;0\\\\\r\n\\end{bmatrix}\\\\\r\n\\begin{bmatrix}\r\n1&amp;0&amp;0\\\\\r\n2&amp;1&amp;0\\\\\r\n3&amp;2&amp;1\\\\\r\n\\end{bmatrix}&amp;\r\n\\begin{bmatrix}\r\n4&amp;-5&amp;6\\\\\r\n0&amp;4&amp;-5\\\\\r\n0&amp;0&amp;0\\\\\r\n\\end{bmatrix}\\\\\r\n\\begin{bmatrix}\r\n1&amp;0&amp;0\\\\\r\n2&amp;1&amp;0\\\\\r\n3&amp;2&amp;1\\\\\r\n\\end{bmatrix}&amp;\r\n\\begin{bmatrix}\r\n4&amp;-5&amp;6\\\\\r\n0&amp;4&amp;-5\\\\\r\n0&amp;0&amp;4\\\\\r\n\\end{bmatrix}\\\\\r\n\\end{array}\\)\r\n28.1-3\r\n令\\(A=\\begin{bmatrix}\r\n1&amp;5&amp;4\\\\\r\n2&amp;0&amp;3\\\\\r\n5&amp;8&amp;2\\\\\r\n\\end{bmatrix},b=\\begin{bmatrix}\r\n12\\\\\r\n9\\\\\r\n5\r\n\\end{bmatrix}\\)。\r\n那么首先对\\(A\\)进行LUP分解，得到\r\n\\[L=\\begin{bmatrix}\r\n1&amp;0&amp;0\\\\\r\n\\frac{1}{5}&amp;1&amp;0\\\\\r\n\\frac{2}{5}&amp;-\\frac{16}{17}&amp;2\\\\\r\n\\end{bmatrix},U=\\begin{bmatrix}\r\n5&amp;8&amp;2\\\\\r\n0&amp;\\frac{17}{5}&amp;\\frac{18}{5}\\\\\r\n0&amp;0&amp;\\frac{95}{17}\\\\\r\n\\end{bmatrix},P=\\begin{bmatrix}\r\n0&amp;0&amp;1\\\\\r\n1&amp;0&amp;0\\\\\r\n0&amp;1&amp;0\\\\\r\n\\end{bmatrix}\\]\r\n那么使用前向替代求解关于\\(y\\)的未知数的方程\\(Ly=Pb\\)，最终可以得到：\r\n\\[\\begin{bmatrix}\r\ny_1\\\\\r\ny_2\\\\\r\ny_3\\\\\r\n\\end{bmatrix}=\r\n\\begin{bmatrix}\r\n5\\\\\r\n11\\\\\r\n\\frac{295}{17}\\\\\r\n\\end{bmatrix}\\]\r\n再使用后向替代可以得到：\r\n\\[\\begin{bmatrix}\r\nx_1\\\\\r\nx_2\\\\\r\nx_3\\\\\r\n\\end{bmatrix}=\r\n\\begin{bmatrix}\r\n-\\frac{3}{19}\\\\\r\n-\\frac{1}{19}\\\\\r\n\\frac{49}{19}\\\\\r\n\\end{bmatrix}\\]\r\n28.1-4\r\n根据对角矩阵\\(A\\)的性质，我们可以构造\\(I_nA=I_nA\\)，其中\\(I_n\\)是单位矩阵，它可以视为是单位下三角矩阵\\(L\\)，而\\(A\\)可以视为是上三角矩阵\\(U\\)。\r\n28.1-5\r\n结论：令\\(L=U=I_n\\)，\\(P=A^{-1}\\)，其中\\(A\\)是给定的排列矩阵.\\(I_n\\)是单位矩阵。接下来证明这种构造是唯一的。\r\n根据题目D.2-3的结论，可以知道\\(A\\)是可逆的，因此\\(U\\)中主对角线上的所有元素都是非\\(0\\)。由于\\(P,A\\)都是排列矩阵，因此根据题目D.1-4的结论，\\(PA=LU\\)仍是排列矩阵。\r\n接下来使用反证法证明：\\(L=I_n\\)，也就是说\\(\\forall 1\\le j&lt;i\\le\r\nn,l_{ij}=u_{ji}=0\\)均成立：假设\\(\\exists i&gt;1,l_{i,1}\\neq\r\n0\\)，那么g观察此时\\(LU\\)的第一列，那么将会导致\\((LU)_{11}\\neq 0,(LU)_{i1}\\neq\r\n0\\)，这说明\\(LU\\)不可能是排列矩阵；类似的论证可以证明\\(\\forall\r\nj&gt;1,u_{ij}=0\\)必然成立。因此我们抛弃矩阵\\(L,U\\)的第\\(1\\)行和第\\(1\\)列递归进行论证，可以发现，递归情形和原本的情形一样。因此，\\(\\forall 1\\le j&lt;i\\le\r\nn,l_{ij}=u_{ji}=0\\)均成立。也就是说，\\(L,U\\)都是对角矩阵，那么可知\\(L=I_n\\)。由于\\(PA\\)是排列矩阵，因此\\(U\\)也是排列矩阵，那么有\\(U=I_n\\)。因此得到\\(P=A^{-1}\\)。\r\n28.1-6\r\n零矩阵\\(O_n\\)显而易见地拥有一个LU分解：\\(O_n=I_nO_n\\)。其中\\(I_n\\)是单位矩阵，它可以视为是单位下三角矩阵\\(L\\)，而\\(O_n\\)可以视为是上三角矩阵\\(U\\)。\r\n28.1-7\r\n对于算法LU-DECOMPOSITION，执行最后一次外层for循环是必须的。因为\\(u_{nn}\\)上三角处的所有值一开始都是未定义的，而执行最后一次循环后，才会有\\(u_{nn}=a_{nn}\\)，从而有定义。\r\n对于算法LUP-DECOMPOSITION，执行最后一次外层for循环不是必须的。因为此时\\(U\\)和\\(L\\)都在原来的矩阵\\(A\\)上表示，当第\\(n-1\\)次循环执行完成后，第\\(n\\)行的结果已经是\\(U\\)中的值。此外，无论\\(a_{nn}\\)结果如何，都不会改变\\(\\pi\\)中前\\(n-1\\)个元素的值。因此此处的外层for循环没有必要执行最后一次。\r\n","categories":["算法导论"]},{"title":"算法导论26 Problems 答案","url":"/introduction-to-algorithms/chapter-26/problems/","content":"\r\n26-1\r\na\r\n使用得到P-MAT-VEC-RECURSIVE类似的方法对SUM-ARRAYS进行修改，同样可以得到其基于递归的并行版本SUM-ARRAYS-RECURSIVE：\r\nSUM-ARRAYS-RECURSIVE(A, B, C, i, i&#x27;)  if i == i&#x27;    C[i] = A[i] + B[i]  else    mid = ⌊(i + i&#x27;) / 2⌋    spawn SUM-ARRAYS-RECURSIVE(A, B, C, i, mid)    spawn SUM-ARRAYS-RECURSIVE(A, B, C, mid + 1, i&#x27;)    sync\r\n可见这个算法的工作量为\\(T_1(n)=\\Theta(n)\\)。由于其递归深度达到\\(\\Theta(\\lg n)\\)，并且只需要花费\\(\\Theta(1)\\)的时间即可完成，因此其持续时间为\\(T_{\\infty}(n)=\\Theta(\\lg\r\nn)\\cdot\\Theta(1)=\\Theta(\\lg n)\\)。因此的并行度为\\(T_1(n)/T_{\\infty}(n)=\\Theta(n/\\lg\r\nn)\\)。\r\nb\r\n如果\\(grain\\text{-}size=1\\)，那么\\(r=n\\)，SUM-ARRAYS'中的for循环将会串行地执行\\(n\\)次，每次调用ADD-SUBARRAY都只花费\\(\\Theta(1)\\)的时间。因此持续时间\\(T_{\\infty}(n)=n\\cdot\r\n\\Theta(1)=\\Theta(n)\\)。可以知道其工作量为\\(T_1(n)=\\Theta(n)\\)，因此其并行度为\\(T_1(n)/T_{\\infty}(n)=\\Theta(1)\\)。\r\nc\r\n令\\(g=grain\\text{-}size\\)。执行单次ADD-SUBARRAY所需要的时间为\\(O(g)\\)。在SUM-ARRAYS'中，一共需要执行\\(n/g\\)次ADD-SUBARRAY，但是for循环并没有带有parrllel关键字，也就是说，这些调用ADD-SUBARRAY的线程是按顺序启动的，它们并非同时启动的，因此这里仍然需要花费\\(O(n/g)\\)的时间完成这个for循环。\r\n因此，SUM-ARRAYS'需要花费\\(O(g+n/g)\\)的时间完成。令\\(f(g)=g+n/g\\)，那么有\\(f&#39;(g)=1-n/g^2\\)。令\\(f&#39;(g)=00\\)，即\\(g=\\sqrt{n}\\)时，SUM-ARRAYS'只需要花费\\(O(\\sqrt{n})\\)的时间就可以完成。\r\n26-2\r\na\r\n修改后的代码由P-MATRIX-MULTIPLY-RECURSIVE'所示，它消去了临时矩阵\\(D\\)的存在。\r\nP-MATRIX-MULTIPLY-RECURSIVE&#x27;(A, B, C, n)  if n == 1    c11 = c11 + a11 · b11    return  partition A, B, C, and D into n/2 × n/2 submatrices A11, A12, A21, A22; B11, B12, B21, B22; and C11, C12, C21, C22; respectively  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A11, B11, C11, n / 2)  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A11, B12, C12, n / 2)  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A21, B11, C21, n / 2)  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A21, B12, C22, n / 2)  sync  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A12, B21, C11, n / 2)  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A12, B22, C12, n / 2)  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A22, B21, C21, n / 2)  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A22, B22, C22, n / 2)  sync\r\n可见，它的串行投影是MATRIX-MULTIPLY-RECURSIVE，因此其工作量为\\(\\Theta(n^3)\\)。\r\nb\r\n对于其工作量\\(T_1(n)\\)，可以给出其递推式\\(T_1(n)=8T_1(n/2)+\\Theta(n^2)\\)，因此得到\\(T_1(n)=\\Theta(n^3)\\)。\r\n对于其持续时间，除了递归调用，P-MATRIX-MULTIPLY-RECURSIVE'没有再做其它工作。因此可以给出其递推式\\(T_{\\infty}(n)=2T_{\\infty}(n/2)+\\Theta(1)\\)，最终通过主定理可以得知\\(T_{\\infty}(n)=\\Theta(n)\\)。\r\n也就是说，算法P-MATRIX-MULTIPLY-RECURSIVE'的并行度为\\(T_1(n)/T_{\\infty}(n)=\\Theta(n^2)\\)。\r\nc\r\n忽略掉\\(\\Theta\\)符号后，对于\\(1000\\times1000\\)的矩阵而言，调用P-MATRIX-MULTIPLY-RECURSIVE'的并行度为\\(10^6\\)。相比于调用P-MATRIX-MULTIPLY-RECURSIVE得到\\(10^7\\)的并行度，计算机依旧不会有这么多的处理器，但是在算法的运行时间的常数却明显减少了，因此这种权衡是值得的。\r\n26-3\r\na\r\n对LU-DECOMPOSITION修改后得到的并行化版本为P-LU-DECOMPOSITION：\r\nP-LU-DECOMPOSITION(A, n)  let L and U be new n × n matrices   initialize U with 0s below the diagonal  initialize L with 1s on the diagonal and 0s above the diagonal  for k = 1 to n    u_&#123;kk&#125; = a_&#123;kk&#125;    parallel for i = k + 1 to n      l_&#123;ik&#125; = a_&#123;ik&#125; / a_&#123;kk&#125;      u_&#123;ki&#125; = a_&#123;ki&#125;    parallel for i = k + 1 to n      parallel for j = k + 1 to n        a_&#123;ij&#125; = a_&#123;ij&#125; − l_&#123;ik&#125; * u_&#123;kj&#125;  return L and U\r\n也就是说，所有内循环都可以进行并行，但是最外层的那一层循环不允许并行。第一个内循环能够并行的原因是：它只读取\\(a\\)矩阵的元素，并修改\\(L,U\\)对应行和对应列的元素，并不会进行多次存取。第二个双重内循环能够并行的原因是第\\(i\\)轮二层循环，第\\(j\\)轮三次循环中，他只会读取\\(L,U\\)矩阵的值并且修改\\(a_{ij}\\)的值，不会造成冲突。外层循环不能是并行的原因是按照LU分解的定义，后一次的运行依赖于前一次的结果。\r\nP-LU-DECOMPOSITION的串行投影是LU-DECOMPOSITION，因此其工作量为\\(T_1(n)=\\Theta(n^3)\\)。\r\n对于P-LU-DECOMPOSITION的持续时间，第一层的第一次内循环花费的时间是\\(\\Theta(\\lg(n-k))=\\Theta(\\lg\r\nn)\\)，因为转化成spawn ... sync结构后就变成了分支法，然后进行递归。第二次的两个双重嵌套寻呼按的原因相同，其花费的时间为\\(\\Theta(\\lg(n-k))+\\Theta(\\lg(n-k))=\\Theta(\\lg\r\nn)\\)。因此，外层for循环需要\\(\\Theta(\\lg\r\nn)\\)的时间完成一次。最终，P-LU-DECOMPOSITION的持续时间为\\(T_{\\infty}(n)=n\\cdot \\Theta(\\lg n)=\\Theta(n\\lg\r\nn)\\)。\r\n最终我们可以计算出P-LU-DECOMPOSITION的并行度为\\(T_1(n)/T_{\\infty}(n)=\\Theta(n^2/\\lg\r\nn)\\)。\r\nb\r\n对LUP-DECOMPOSITION修改后得到的并行化版本为P-LUP-DECOMPOSITION：\r\nP-LUP-DECOMPOSITION(A, n)  let π[1 : n] be a new array  parallel for i = 1 to n    π[i] = i  for k = 1 to n    p = 0    parallel for i = k to n      if |a_&#123;ik&#125;| &gt; p        p = |a_&#123;ik&#125;|        k&#x27; = i    if p == 0      error &quot;singular matrix&quot;    exchange π[k] with π[k&#x27;]    parallel for i = 1 to n      exchange a_&#123;ki&#125; with a_&#123;k&#x27;i&#125;     parallel for i = k + 1 to n      a_&#123;ik&#125; = a_&#123;ik&#125; / a_&#123;kk&#125;      parallel for j = k + 1 to n        a_&#123;ij&#125; = a_&#123;ij&#125; − a_&#123;ik&#125; * a_&#123;kj&#125;\r\n第2行的for循环可以并行，这是显而易见的。第6-9行的for循环是可以并行的，因为这是寻找一个最大值，在这个过程中，\\(n\\)个元素构成一棵\\(n\\)个叶节点的二叉树，对于内部节点，它是两个子节点中的最大值，由于这棵树的深度为\\(\\Theta(\\lg\r\nn)\\)，因此这段循环的持续时间为\\(\\Theta(\\lg\r\nn)\\)。第13行的for循环用于交换两行元素，显而易见是可以并行的。对于第15行和17行的for循环，第16行仅仅是对\\(a_{ik}\\)进行更新，此后都是对\\(a_{ij}(j&gt;k)\\)中的所有元素进行更新。至于先对哪一行操作都是没有关系的，因此第15行和17行的for循环它们都可以并行。外面针对\\(k\\)的for循环不能并行，因为会导致数据读取冲突。\r\nP-LUP-DECOMPOSITION的串行投影是LUP-DECOMPOSITION，因此其工作量为\\(T_1(n)=\\Theta(n^3)\\)。\r\n对于P-LUP-DECOMPOSITION的持续时间，分析和P-LU-DECOMPOSITION非常相似。第6，13，15，17行的for循环都可以进行，因此这部分只使用\\(\\Theta(\\lg\r\nn)\\)的时间即可完成。最终，P-LUP-DECOMPOSITION的持续时间为\\(T_{\\infty}(n)=n\\cdot \\Theta(\\lg n)=\\Theta(n\\lg\r\nn)\\)。\r\n最终我们可以计算出P-LUP-DECOMPOSITION的并行度为\\(T_1(n)/T_{\\infty}(n)=\\Theta(n^2/\\lg\r\nn)\\)。\r\nc\r\n对LUP-SOLVE修改后得到的并行化版本为P-LUP-SOLVE：\r\nP-LUP-SOLVE(L, U, π, b, n)  let x and y be new vectors of length n  for i = 1 to n    val = 0    parallel for j = 1 to i - 1      val = val + l_&#123;ij&#125; * y_j    y_i = b_&#123;π[i]&#125; - val  for i = n downto 1    val = 0    parallel for j = i + 1 to n      val = val + u_&#123;ij&#125; * x_j    x_i = (y_u - val) / u_&#123;ii&#125;  return x\r\n第4和9行的for循环可以并行，只需要将长度为\\(n\\)的序列构造出一棵\\(n\\)个叶子节点的完全二叉树即可，对于内部节点，它是两个子节点中的值之和。因此，这两个内部for循环都能够在\\(\\Theta(\\lg\r\nn)\\)的时间内完成。对于第2和7行的for循环，因为后面计算\\(x,y\\)值需要依赖前面已经计算出的\\(x,y\\)值。\r\n最终，P-LUP-SOLVE的串行投影即为LUP-SOLVE，因此其工作量为\\(T_1(n)=\\Theta(n^2)\\)。按照上面的结论，可以得到持续时间\\(T_{\\infty}(n)=n\\cdot \\Theta(\\lg n)=\\Theta(n\\lg\r\nn)\\)。最终我们可以计算出P-LUP-SOLVE的并行度为\\(T_1(n)/T_{\\infty}(n)=\\Theta(n/\\lg\r\nn)\\)。\r\nd\r\n一个对正定矩阵求逆的并行算法由P-MATRIX-INVERSION-POSITIVE-DEFINITE给出。\r\nP-MATRIX-INVERSION-POSITIVE-DEFINITE(A, n)  partition A into n/2 × n/2 submatrices B, CT, C, D; respectively  let W[1 : n, 1 : n], X[1 : n, 1 : n], Y[1 : n, 1 : n], Z[1 : n, 1 : n], S[1 : n, 1 : n] be new matrices  B&#x27; = P-MATRIX-INVERSION-POSITIVE-DEFINITE(B, n / 2)  W = P-MATRIX-MULTIPLY(C, B&#x27;, W, n / 2)  WT = W  P-TRANSPOSE(WT, n / 2)  P-MATRIX-MULTIPLY(W, CT, X, n / 2)  S = D - X  S&#x27; = P-MATRIX-INVERSION-POSITIVE-DEFINITE(S, n / 2)  P-MATRIX-MULTIPLY(S&#x27;, W, Y, n / 2)  YT = Y  P-TRANSPOSE(YT, n / 2)  P-MATRIX-MULTIPLY(WT, y, Z)  R = B&#x27; + Z  A&#x27; = [[R, -YT], [-Y, S&#x27;]]  return A&#x27;\r\n按照第28.2章的结论以及不等式28.15，可以知道其工作量\\(I_1(n)\\le\r\n2I_1(n/2)+4M_1(n/2)+O(n^2)\\)，最终得到\\(I_1(n)=O(M(n))\\)。\r\n在并行版本中，由题目26.1-8，26.2-3和题26-1-a可知，矩阵的转置、加法和乘法都可以在\\(\\Theta(\\lg\r\nn)\\)时间内完成。在P-MATRIX-INVERSION-POSITIVE-DEFINITE中，一共进行了\\(2\\)次矩阵转置，\\(4\\)次矩阵加减法，\\(4\\)次矩阵乘法。同样的，它们还进行了\\(2\\)次大小为\\(n/2\\times\r\nn/2\\)矩阵的求逆。可见，这些步骤都是依赖于前一步的结果，因此步骤之间不能直接并行。我们可以写出它的持续时间\\(I_{\\infty}(n)\\)满足\\(I_{\\infty}(n)=2I_{\\infty}(n/2)+10\\cdot\\Theta(\\lg\r\nn)\\)，因此最终得到\\(I_{\\infty}(n)=\\Theta(n)\\)。\r\n最终我们可以得到它的并行度为\\(I_1(n)/I_{\\infty}(n)=O(M(n)/n)\\)。\r\n26-4\r\na\r\n设计的P-REDUCE如下所示：\r\nP-REDUCE(x, i, j)  if i == j    return x[i]  else    mid = ⌊(i + j) / 2⌋    l = spawn P-REDUCE(x, i, mid)    r = spawn P-REDUCE(x, mid + 1, j)    sync    return l ⊗ r\r\n不难发现它的串行投影即为REDUCE，因此它的工作量为\\(T_1(n)=\\Theta(n)\\)。由于这棵进行搜索的二叉树的深度为\\(\\Theta(\\lg\r\nn)\\)，因此这个算法的持续时间为\\(T_{\\infty}(n)=\\Theta(\\lg n)\\)。\r\nb\r\n这个算法相当于是以\\(k=1,2,\\dots,n\\)对P-REDUCE都进行了一次调用。因此P-SCAN-1的工作量为\\(\\displaystyle{T_1(n)=\\sum_{k=1}^n\\Theta(k)=\\Theta(n^2)}\\)。\r\n接下来求解P-SCAN-1的持续时间。由于对P-SCAN-1对P-REDUCE的间接调用呈树形，假设伪代码中，第\\(i\\)次对P-REDUCE的调用的持续时间为\\(iter(i)\\)，那么有\\(T_{\\infty}(n)=\\Theta(\\lg n)+\\max\\{iter(i):1\\le\r\ni\\le n\\}\\)，按照题目26-4-a的结论，有\\(T_{\\infty}(n)=\\Theta(\\lg n)\\)。\r\n因此P-SCAN-1的并行度为\\(T_1(n)/T_{\\infty}(n)=\\Theta(n^2/\\lg\r\nn)\\)。\r\nc\r\n我们可以使用归纳法进行证明其正确性。即证明，调用P-SCAN-2-AUX(i, j)，对于\\(\\forall k\\in[i,j]\\)，它都正确计算出了\\(y[k]=x[i]\\otimes x[i+1]\\otimes\\dots\\otimes\r\nx[k]\\)。\r\n对于基本情况：\\(i=j\\)，P-SCAN-2-AUX都正确计算出了\\(y\\)数组，这由P-SCAN-2-AUX的前两行明显可知。\r\n当\\(i&lt;j\\)时，假设对于区间\\([i,j]\\)内的所有真子区间\\([i&#39;,j&#39;]\\)，即\\(i\\le i&#39;\\le j&#39;\\le j\\)，且\\(i=i&#39;,j=j&#39;\\)不同时成立，P-SCAN-2-AUX都计算出了正确的结果。那么第三行得到了一个\\(k=\\lfloor(i+j)/2\\rfloor\\)。对于第4和5行的代码，它们分别对\\(y\\)数组的区间\\([i,k]\\)和\\([k+1,j]\\)进行写入，并且读取的内容也不相交，因此这两行代码不会构成竞争。在第6行结束后，\\(y\\)数组满足：如果\\(p\\le k\\)，那么\\(y[p]=x[i]\\otimes x[i+1]\\otimes\\dots\\otimes\r\nx[p]\\)，否则\\(y[p]=x[k+1]\\otimes\r\nx[k+2]\\otimes\\dots\\otimes x[k]\\)。对于\\(p&gt;k\\)的情况，第8行将\\(y[p]\\)重新赋值成\\(y[k]\\otimes y[p]\\)。这个步骤完成后，\\(\\forall p\\in[i,j]\\)，都有\\(y[p]=x[i]\\otimes x[i+1]\\otimes\\dots\\otimes\r\nx[p]\\)。因此P-SCAN-2-AUX是正确的。\r\n接下来考虑P-SCAN-2-AUX的工作量\\(T_1(n)\\)，消去最后的for循环中的parallel关键字后，那么除去递归部分，它的运行时间是\\(\\Theta(n)\\)。因此可以写出\\(T_1(n)=2T_1(n/2)+\\Theta(n)\\)，从而得到\\(T_1(n)=\\Theta(n\\lg n)\\)。\r\n接下来考虑其持续时间\\(T_{\\infty}(n)\\)。可见出了递归部分，其余部分仍然需要\\(\\Theta(\\lg n)\\)进行。因此有\\(T_{\\infty}(n)=T_{\\infty}(n/2)+\\Theta(\\lg\r\nn)\\)，最终得到\\(T_{\\infty}(n)=\\Theta(\\lg^2n)\\)。\r\n因此P-SCAN-2的并行度为\\(T_1(n)/T_{\\infty}(n)=\\Theta(n/\\lg\r\nn)\\)。\r\nd\r\nP-SCAN-UP第8行填入的是$right ⊗ t[k]；P-SCAN-DOWN的第5行填入v，第6行填入v ⊗ t[k]。\r\n需要注意的是，\\(t[k]\\)存储的是当一个区间\\([i,j]\\)被尽量均匀地划分成两个区间\\([i,k],[k+1,j]\\)后，\\(t[k]\\)就是记录区间\\([i,j]\\)前面一半元素（即\\([i,k]\\)）的元素之和\\(t[k]=x[i]\\otimes x[i+1]\\otimes\\dots\\otimes\r\nx[k]\\)。\r\n首先证明，调用时每个\\(t[k]\\)最多只会被赋值一次（因此，在执行P-SCAN-DOWN时不会造成任何冲突）。只有调用P-SCAN-UP，当\\(i&lt;j\\)时，才会对\\(t[k]\\)进行赋值，在此之后更深的递归讲不会再对\\(t[k]\\)进行赋值，原因如下。如果递归的区间是左半子区间\\([i,k]\\)，那么对于所有\\([i,k]\\)的长度大于等于\\(2\\)的（等于\\(1\\)则不会进入到这个分支）真子区间\\([i&#39;,k&#39;]\\)，都有\\(\\lfloor(i&#39;+k&#39;)/2\\rfloor&lt;k\\)，因此\\(t[k]\\)不会被重复赋值；如果递归的是右子区间\\([k+1,j]\\)，那么它的访问和读写只会在这个区间内进行，更不会对\\(t[k]\\)进行访问。因此，\\(t[k]\\)确实能够正确记录区间\\([i,j]\\)的信息。根据P-SCAN-DOWB的第5行代码，就可以知道\\(t[k]\\)记录的是区间i,j的左半区间的元素之和。并且，P-SCAN-UP的返回值是\\([i,j]\\)这个区间的所有元素之和，因此结论成立。\r\n接下来证明每次调用P-SCAN-DOWN(v, x, t, y, i, j)时，总满足\\(v=x[1]\\otimes x[2]\\otimes\\dots\\otimes\r\nx[i-1]\\)。同样使用归纳法来证明。在P-SCAN-3调用P-SCAN-DOWN时，有\\(v=x[1],i=2\\)，因此基本情况下是成立的。P-SCAN-DOWN首先调用P-SCAN-DOWN(v, x, t, y, i, k)，由于参数\\(i\\)没有变化，因此\\(v\\)仍然使用原来的\\(v\\)，原结论成立；然后调用P-SCAN-DOWN(v ⊗ t[k], x, t, y, k + 1, j)，由于此时\\(t[k]=x[i]\\otimes x[i+1]\\otimes\\dots\\otimes\r\nx[k]\\)，因此有\\(v\\otimes\r\nt[k]=x[1]\\otimes x[2]\\otimes\\dots\\otimes\r\nx[k]\\)。因此第二次调用时同样满足题目的条件。因此当P-SCAN-DOWN进入第2行后，y[i] = v ⊗ x[i]则是\\(y[i]=x[1]\\otimes x[2]\\otimes\\dots\\otimes\r\nx[i]\\)，\\(y[i]\\)被正确地计算出来。\r\n因此，算法P-SCAN-3是正确的。\r\ne\r\n可以发现，这棵树的节点数仍然是\\(\\Theta(n)\\)，因此P-SCAN-3的工作量\\(T_1(n)=\\Theta(n)\\)。\r\n接下来首先考虑P-SCAN-UP。由于其每次划分出了两个长度尽量均等的区间，并且其余处理部分都只要\\(\\Theta(1)\\)的时间，因此P-SCAN-UP这段代码的持续时间满足\\(T_{\\infty}(n)=T_{\\infty}(n/2)+\\Theta(1)\\)，从而得到\\(T_{\\infty}(n)=\\Theta(\\lg\r\nn)\\)。P-SCAN-DOWN和P-SCAN-UP的结构基本相同，因此对其分析也一样。\r\n最终，P-SCAN-3的持续时间为\\(T_{\\infty}(n)=\\Theta(\\lg n)\\)。\r\n因此，P-SCAN-3的并行度为\\(T_1(n)/T_{\\infty}(n)=\\Theta(n/\\lg\r\nn)\\)。\r\nf\r\n修改后的P-SCAN-3由P-SCAN-3'给出。代价是并发度将会降低。\r\nP-SCAN-3&#x27;(x, n)  let y[1 : n] be a new array  y[1] = x[1]  if n &gt; 1    P-SCAN-3-AUX(x[1], x, y, 2, n)  return yP-SCAN-SUM-ARRAYS(x, i, j)  if i == j    return x[i]  else    k = ⌊(i + j) / 2⌋    l = spawn P-SCAN-SUM-ARRAYS(x, t, i, k)    r = P-SCAN-SUM-ARRAYS(x, t, k + 1, j)    return l ⊗ rP-SCAN-3-AUX(v, x, y, i, j)  if i == j    y[i] = v ⊗ x[i]  else    k = ⌊(i + j) / 2⌋    spawn P-SCAN-3-AUX(v, x, y, i, k)    t = P-SCAN-SUM-ARRAYS(x, i, k)    P-SCAN-3-AUX(v ⊗ t, x, y, k + 1, j)    sync\r\n\\(\\star\\) g\r\nP-SCAN-4(x, n)  l = 1  while l &lt;= n    parallel for i = 1 to n by l * 2      parallel j = 0 to l - 1        if i + l + j &lt;= n          x[i + l + j] = x[i + l + j] + x[i + l - 1]    l = l * 2\r\n这个算法的基本思想是，将\\(x\\)分成\\(\\lceil\r\nn/(2l)\\rceil\\)块，每一块的长度为\\(2l\\)（最后一块不足\\(2l\\)也以一块记），并且\\(l\\)是\\(2\\)的幂。一开始\\(l=1\\)，将前半块的最后一个元素\\(x[i+l-1]\\)添加到后半块\\(x[i+l+j](0\\le\r\nj&lt;l)\\)中的每一个元素。从而最终完成后，每一块内部都是对应值的前缀和。可见两个parallel for循环不会导致冲突，因此这个算法的持续时间为\\(T_{\\infty}(n)=\\Theta(\\lg^2n)\\)。\r\nh\r\n将字符串中的(视为\\(+1\\)，')'视为\\(-1\\)，得到一个数组\\(x\\)，求出其前缀和\\(y\\)。那么一个括号字符串是合法的，当且仅当\\(\\forall i\\in[1,n],y_i\\ge 0\\)，并且有\\(y_n=0\\)。通过对P-SCAN-3进行改造，我们可以得到一个在\\(\\Theta(\\lg\r\nn)\\)时间内判断一个括号字符串是否合法的程序PARENTHESES-IS-WELL-FORMED：\r\nPARENTHESES-IS-WELL-FORMED(s, n)  let y[0 : n] and t[1 : n] be new arrays  y[0] = 0  P-SCAN-UP&#x27;(s, t, 1, n)  mn = P-SCAN-DOWN&#x27;(0, s, t, y, 1, n)  return mn &gt;= 0 and y[n] == 0P-SCAN-UP&#x27;(s, t, i, j)  if i == j    if s[i] == &#x27;(&#x27;      return 1    else      return -1  else    k = ⌊(i + j) / 2⌋    t[k] = spawn P-SCAN-UP&#x27;(s, t, i, k)    right = P-SCAN-UP&#x27;(s, t, k + 1, j)    sync    return t[k] + rightP-SCAN-DOWN&#x27;(v, s, t, y, i, j)  if i == j    y[i] = v + x[i]    return y[i]  else    k = ⌊(i + j) / 2⌋    l = spawn P-SCAN-DOWN (v, x, t, y, i, k)    r = P-SCAN-DOWN(v + t[k], x, t, y, k + 1, j)    sync    return min&#123;l, r&#125;\r\n改造后的程序还返回了前缀和数组中的最小值。\r\n26-5\r\na\r\n不失一般性，这里假设矩阵\\(A\\)的大小\\(n\\)是\\(2\\)的幂次。基于等式26.9，那么对矩阵\\(A\\)的填充并行分治算法由SIMPLE-STENCIL给出。\r\nSIMPLE-STENCIL(A, n)  if n == 1    generate the value of a11    return  partition A into n/2 × n/2 submatrices A11, A12, A21, A22; respectively  SIMPLE-STENCIL(A11, n / 2)  spawn SIMPLE-STENCIL(A12, n / 2)  spawn SIMPLE-STENCIL(A21, n / 2)  sync  SIMPLE-STENCIL(A22, n / 2)\r\n可见这个算法只是为了填充原来矩阵的所有元素，由其串行投影可以知道其工作量满足\\(T_1(n)=4T_1(n/2)+\\Theta(1)\\)，可以得到\\(T_1(n)=\\Theta(n^2)\\)。\r\n这个算法的持续时间满足\\(T_{\\infty}(n)=3T_\\infty(n/2)+\\Theta(1)\\)，可以得到\\(T_{\\infty}(n)=\\Theta(n^{\\lg 3})\\)。\r\n最终可以得到并行度为\\(T_1(n)/T_{\\infty}(n)=\\Theta(n^{2-\\lg\r\n3})\\)。\r\nb\r\n不失一般性，这里假设矩阵\\(A\\)的大小\\(n\\)是\\(3\\)的幂次，那么按照题目26-5-a的结果，我们可以对SIMPLE-STENCIL修改成SIMPLE-STENCIL3。\r\nSIMPLE-STENCIL3(A, n)  if n == 1    generate the value of a11    return  partition A into n/3 × n/3 submatrices A11, A12, A13, A21, A22, A23, A31, A32, A33; respectively  SIMPLE-STENCIL3(A11, n / 3)  spawn SIMPLE-STENCIL3(A12, n / 3)  spawn SIMPLE-STENCIL3(A21, n / 3)  sync  spawn SIMPLE-STENCIL3(A13, n / 3)  spawn SIMPLE-STENCIL3(A22, n / 3)  spawn SIMPLE-STENCIL3(A31, n / 3)  sync  spawn SIMPLE-STENCIL3(A23, n / 3)  spawn SIMPLE-STENCIL3(A32, n / 3)  sync  SIMPLE-STENCIL3(A33, n / 3)\r\n和题目26-3-a分析的过程类似，可以知道其工作量满足\\(T_1(n)=9T_1(n/3)+\\Theta(1)\\)，可以得到\\(T_1(n)=\\Theta(n^2)\\)。\r\n这个算法的持续时间满足\\(T_{\\infty}(n)=5T_\\infty(n/3)+\\Theta(1)\\)，可以得到\\(T_{\\infty}(n)=\\Theta(n^{\\log_3 5})\\)。\r\n最终可以得到并行度为\\(T_1(n)/T_{\\infty}(n)=\\Theta(n^{2-\\log_3\r\n5})\\)。\r\nc\r\n利用类似的方式修改题目26-5-a和26-5-b的代码，可以给出SIMPLE-STENCIL-B代码为：\r\nSIMPLE-STENCIL-B(A, n)  if n == 1    generate the value of a11    return  partition A into n/b × n/b submatrices A11, A12, ..., A1b, A21, A22, ..., A2b, ...,  Ab1, Ab2, ..., Abb; respectively  for k = 2 to b * b    //注意这里的parallel for 循环将是以硬编码的形式构造出来，因此后面的分析不会对Θ(lg n)这个因子进行考虑。    parallel for i = 1 to b      j = k - i      if 1 &lt;= j and j &lt;= b      SIMPLE-STENCIL3(Aij, n / b)\r\n和题目26-3-a和26-3-b分析的过程类似，可以知道其工作量满足\\(T_1(n)=b^2T_1(n/b)+\\Theta(1)\\)，可以得到\\(T_1(n)=\\Theta(n^2)\\)。\r\n这个算法的持续时间满足\\(T_{\\infty}(n)=(2b-1)T_\\infty(n/b)+\\Theta(1)\\)，可以得到\\(T_{\\infty}(n)=\\Theta(n^{\\log_b\r\n(2b-1)})\\)。\r\n最终可以得到并行度为\\(T_1(n)/T_{\\infty}(n)=\\Theta(n^{2-\\log_b\r\n(2b-1)})\\)。\r\n为了证明\\(T_1(n)/T_{\\infty}(n)=\\Theta(n^{2-\\log_b\r\n(2b-1)})=o(n)\\)，那么需要证明\\(f\\forall\r\nb\\ge 2\\)，都有\\(2-\\log_b(2b-1)&lt;1\\)，即证明\\(\\log_b(2b-1)&gt;1\\)。由于\\(\\forall b\\ge 2\\)，都有\\(2b-1&gt;b\\)，因此\\(\\log_b(2b-1)&gt;1\\)成立是很显然的。因此有\\(T_1(n)/T_{\\infty}(n)=o(n)\\)。\r\nd\r\n这个算法由STENCIL给出，并且它还能对更一般形式的矩阵进行填充。\r\nSTENCIL(A, n)  for k = 2 to n + n - 1    up = max&#123;1, k - n&#125;    down = min&#123;n, k - 1&#125;    parallel for i = up to down      j = k - i      generate the value of aij\r\n可以知道STENCIL的工作量是\\(T_1(n)=\\Theta(n^2)\\)，因为它仅仅是从小到大枚举矩阵的每条副对角线，并按顺序填入一个个元素。\r\n可以知道STENCIL的持续时间满足\\(T_\\infty(n)=n\\cdot\\Theta(\\lg n)=\\Theta(n\\lg\r\nn)\\)。因为第\\(k\\)轮迭代最多也只会进行\\(n\\)次操作。如果去掉关键字parallel关键字并转化为spawn ... sync结构，那么这一部分需要花费\\(\\Theta(\\lg n)\\)的时间。\r\n因此，STENCIL的并行度为\\(T_1(n)/T_{\\infty}(n)=\\Theta(n/\\lg\r\nn)\\)。\r\n如果需要达到\\(\\Theta(n)\\)的并行度，那么可以将parallel for循环转化成硬编码形式，\r\n从而去掉这个parallel for循环，并且一次性在\\(\\Theta(1)\\)的时间内生产\\(\\Theta(n)\\)个元素，从而使并行度提升到\\(\\Theta(n)\\)。但是这里使用了parallel for循环，它是基于分治法实现的，因此达不到这个最大并行度。\r\n26-6\r\na\r\n工作量定律将改写成\\(E[T_P]\\ge\r\nE[T_1]/P\\)；持续时间定律将改写成\\(E[T_P]\\ge\r\nE[T_{\\infty}]\\)；贪心调度界限改写成\\(E[T_P]\\le E[T_1]/P+E[T_{\\infty}]\\)。\r\nb\r\n按照题目给出的数据，令\\(P=10000\\)，那么可以写出以下三条式子：\r\n\\(\\begin{aligned}\r\nE[T_1]&amp;=10^4\\cdot 0.01+10^9\\cdot 0.99\\\\\r\nE[T_P]&amp;=1\\cdot 0.01+10^9\\cdot0.99\\\\\r\nE[T_1/T_P]&amp;=\\dfrac{10^4}{1}\\cdot0.01+\\dfrac{10^9}{10^9}\\cdot0.99\\\\\r\n\\end{aligned}\\)\r\n从而得到\\(E[T_1/T_P]\\approx100,\\dfrac{E[T_1]}{E[T_P]}\\approx\r\n1\\)。\r\n选用\\(\\dfrac{E[T_1]}{E[T_P]}\\)的原因有如下两个：\r\n\r\n由于在绝大多数时间中，无论是\\(P=1\\)还是\\(P=10000\\)，其运行时间大多数都在\\(10^9\\)，因此说明这个添加到\\(P=10000\\)的操作应该对加速作用不大，因此选用\\(\\dfrac{E[T_1]}{E[T_P]}\\)是一个比较恰当的值。\r\n\\(T_1/T_P\\)这个随机变量并不成立。题目中没有提到\\(T_1=10^4\\)和\\(T_1=10^9\\)的时机是否和\\(T_P=1\\)和\\(T_P=10^9\\)的时机相同。也就是说，它们不一定是相关的。因此采用独立计算更加合适，即选用\\(\\dfrac{E[T_1]}{E[T_P]}\\)。\r\n\r\nc\r\n当\\(P\\)趋于无穷时，期望的加速比应该和并行度相等。这和题目26-6-b使用的定义是一致的。\r\nd\r\n我们可以对第7.3章提到的RANDOMIZED-QUICKSORT算法提出其并行化版本P-RANDOMIZED-QUICKSORT（按照题目要求，不对RANDOMIZED-PARTITION并行化）：\r\nP-RANDOMIZED-QUICKSORT(A, p, r)  if p &lt; r:    q = RANDOMIZED-PARTITION(A, p, r)    spawn P-RANDOMIZED-QUICKSORT(A, p, q - 1)    spawn P-RANDOMIZED-QUICKSORT(A, q + 1, r)    sync\r\ne\r\n可见，P-RANDOMIZED-QUICKSORT的串行投影为RANDOMIZED-QUICKSORT，因此其期望工作量\\(E[T_1(n)]=O(n\\lg n)\\)。\r\n对于P-RANDOMIZED-QUICKSORT持续时间，考虑将P-RANDOMIZED-QUICKSORT和RANDOMIZED-SELECT的行为进行对比。P-RANDOMIZED-QUICKSORT的RANDOMIZED-PARTITION和RANDOMIZED-SELECT中的一样，这部分都是占据了主导的时间\\(\\Theta(n)\\)。因此，对其划分的推导也和第9.2章给的完全一样。接下来考虑其递归部分。可以发现，P-RANDOMIZED-QUICKSORT的阶段划分和RANDOMIZED-SELECT也相同，并且证明过程同样也考虑了那个执行时间比较长的执行分支。因此对P-RANDOMIZED-QUICKSORT持续时间\\(T_{\\infty}(n)\\)的分析过程和RANDOMIZED-SELECT的分析过程完全一致。按照定理9.2的结论，我们得到\\(T_{\\infty}(n)=\\Theta(n)\\)。\r\n因此，P-RANDOMIZED-QUICKSORT的并行度为\\(T_1(n)/T_{\\infty}(n)=O(\\lg n)\\)。\r\nf\r\nRANDOMIZED-SELECT的并行化版本由P-RANDOMIZED-SELECT给出。其中，给定的P-RANDOMIZED-PARTITION由题目26.3-3的P-PARTITION实现而来。\r\nP-RANDOMIZED-PARTITION(A, p, r)  i = RANDOM(p, r)  exchange A[r] with A[i]  return P-PARTITION(A, p, r)P-RANDOMIZED-SELECT(A, p, r, i)  if p == r    return A[p]  q = P-RANDOMIZED-PARTITION(A, p, r)  k = q – p + 1  if i == k    return A[q]  else if i &lt; k    return P-RANDOMIZED-SELECT(A, p, q – 1, i)  else     return P-RANDOMIZED-SELECT(A, q + 1, r, i – k)\r\n可见这个算法的串行投影为RANDOMIZED-SELECT，因此它的工作量为\\(T_1(n)=\\Theta(n)\\)。\r\n令示性遍历\\(X_k\\)表示P-RANDOMIZED-PARTITION划分出来后的元素在于位置\\(k\\)。那么由于程序的其余部分都需要\\(\\Theta(\\lg\r\nn)\\)完成（根据题目26.3-3的结论，这里的主要开销就在于P-RANDOMIZED-PARTITION需要花费\\(\\Theta(\\lg\r\nn)\\)的时间），因此可以对随机变量\\(T_{\\infty}(n)\\)可以写出如下递推式：\r\n\\[T_{\\infty}(n)=\\sum_{i=1}^n X_k\\cdot\r\nT_{\\infty}(\\max\\{k-1,n-k\\})+\\Theta(\\lg n)\\]\r\n可见\\(E[X_k]=\\dfrac{1}{n}\\)，因为每个位置都有可能被选到。那么对式子左右两侧取期望值，那么有\r\n\\(\\begin{aligned}\r\nE[T_{\\infty}(n)]&amp;=\\sum_{k=1}^n E[X_k]\\cdot\r\nE[T_{\\infty}(\\max\\{k-1,n-k\\})]+\\Theta(\\lg n)\\\\\r\n&amp;\\le\\dfrac{2}{n}\\sum_{k=\\lfloor n/2\\rfloor}^{n-1}\r\nE[T_{\\infty}(k)]+\\Theta(\\lg n)\\\\\r\n\\end{aligned}\\)\r\n接下来使用代入法证明\\(E[T_{\\infty}(n)]=O(n^d)\\)，即\\(\\exists c,n_0&gt;0,d\\in(0,1)\\)，使得\\(\\forall n\\ge n_0\\)，都有\\(E[T_{\\infty}(n)]\\le c\\cdot\r\nn^{d}\\)。那么就可以得到\r\n\\(\\begin{aligned}\r\nE[T_{\\infty}(n)]&amp;\\le\\dfrac{2}{n}\\sum_{k=\\lfloor n/2\\rfloor}^{n-1}\r\nE[T_{\\infty}(k)]+\\Theta(\\lg n)\\\\\r\n&amp;\\le\\dfrac{2}{n}\\sum_{k=\\lfloor n/2\\rfloor}^{n-1} c\\cdot\r\nk^d+\\Theta(\\lg n)\\\\\r\n&amp;=\\dfrac{2c}{n}\\sum_{k=\\lfloor n/2\\rfloor}^{n-1} k^d+\\Theta(\\lg n)\\\\\r\n&amp;\\le \\dfrac{2c}{n}\\int_{\\lfloor n/2\\rfloor}^n x^d dx+\\Theta(\\lg n)\\\\\r\n&amp;=\\dfrac{2c}{n}\\cdot\\left.\\dfrac{x^{d+1}}{d+1}\\right|_{x=\\lfloor\r\nn/2\\rfloor}^n+\\Theta(\\lg n)\\\\\r\n&amp;=c\\cdot\\dfrac{2-2^{-d}}{d+1}\\cdot n^d + \\Theta(\\lg n)\r\n\\end{aligned}\\)\r\n考虑关于\\(d\\)的一元一次不等式\\(\\dfrac{2-2^{-d}}{d+1}&lt;1\\)，可以得到\\(d&gt;0\\)。\r\n也就是说，无论\\(d\\)取\\((0,1)\\)中的什么值，只要第一个项中的\\(c\\)足够大，它就可以覆盖到\\(\\Theta(\\lg n)\\)中的常数，从而最终得到\\(T_{\\infty}(n)\\)\r\n因此，\\(T_{\\infty}(n)=o(n^d)\\)，其中\\(d\\)是任意正数。\r\n最终可以得到并行度为\\(T_1(n)/T_{\\infty}(n)=\\Theta(n^{1-d})\\)。\r\n","categories":["算法导论"]},{"title":"算法导论3.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-3/exercises-1/","content":"\r\n3.1-1\r\n令\\(n=3k+r\\)，其中\\(r\\in\\{0,1,2\\},k\\ge 0\\)。其中\\(n\\)是数组\\(A\\)长度。可以发现，\\(3k+r\\)可以表出任意正整数。\r\n假设数组\\(A\\)中最大的\\(k\\)个元素恰好在数组的最左边。那么最终插入排序完成后，这\\(k\\)个元素最终在最右边的\\(k\\)个位置。这\\(k\\)个元素至少要移动\\(k+r\\)步。因此，这\\(k\\)个数总共需要移动\\(k^2+kr\\)步，那么这个算法的时间复杂度下限为\\(\\Omega(k^2+kr)\\)。当\\(n\\)足够大时，\\(k\\gg r\\)，因此回代\\(k=\\dfrac{n-r}{3}\\)，得到\\(\\Omega\\left(\\dfrac{(n-r)(n+2r)}{9}\\right)\\)，舍去低阶的项\\(r\\)后得到\\(\\Omega(n^2)\\)。\r\n3.1-2\r\nSELECTION-SORT(A, n)  for i = 1 to n - 1    minpos = i    for j = i + 1 to n      if A[j] &lt; A[minpos]        minpos = j      swap(a[i], a[minpos])\r\n选择排序中的两个循环都与所需要排序的值无关。在第\\(i\\)轮循环中会固定进行\\(n-i\\)次，总共次数为\\(\\dfrac{n(n-1)}{2}\\)，因此时间复杂度的上限为\\(O(n^2)\\)。\r\n同样的，假设当前数组\\(A\\)长度\\(n=3k\\)，其中最小的\\(k\\)个数位于数组的最后\\(k\\)个位置。那么在第\\(i(i\\le\r\nk)\\)次外循环时，内循环至少要先完成中间的\\(k\\)个数的比较（也就是\\(A[k+1:2k]\\)里的数），才能够对最后\\(k\\)个数进行比较。这些无用对比较次数为\\(k\\)次，对于前\\(k\\)小对元素，这些无用的比较次数为\\(k^2\\)，也就是\\(\\dfrac{n^2}{9}\\)，因此这个算法有\\(\\Omega(n^2)\\)的下界。最终，选择排序算法的最坏时间复杂度为\\(\\Theta(n^2)\\)。\r\n3.1-3\r\n\r\n分数\\(\\alpha\\)的分母必须能够整除数组长度\\(n\\)。\r\n\\(0&lt;\\alpha &lt;\r\n0.5\\)，否则前\\(\\alpha\r\nn\\)个位置和后\\(\\alpha\r\nn\\)个位置产生覆盖，这个问题没有讨论的意义。\r\n\r\n这\\(\\alpha n\\)个元素通过中间的\\((1-2\\alpha)n\\)个位置至少需要\\(\\alpha(1-2\\alpha)n^2\\)次。\r\n令\\(f(\\alpha)=\\alpha(1-2\\alpha)\\)，那么\\(f&#39;(\\alpha)=1-4\\alpha\\)。令\\(f&#39;(\\alpha)=0\\)，得到\\(\\alpha\r\n=\\dfrac{1}{4}\\)。也就是说，只有当\\(\\alpha =\\dfrac{1}{4}\\)时，才能最大化这\\(\\alpha n\\)个元素通过中间\\((1-2\\alpha) n\\)个位置的次数。\r\n","categories":["算法导论"]},{"title":"算法导论28.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-28/exercises-2/","content":"\r\n28.2-1\r\n首先证明矩阵平方并不比矩阵乘法更难。令任意一个矩阵\\(A\\)，那么有\\(A^2=A\\cdot A\\)。也就是说，一个\\(M(n)\\)时间复杂度的矩阵乘法算法意味着一个\\(O(M(n))\\)的矩阵平方算法。\r\n接下来证明矩阵乘法并不比矩阵平方更难，证明过程和定理28.1的过程类似：假设\\(S(n)\\)时间内可以求出两个\\(n\\times n\\)矩阵的乘积，并且\\(S(n)=\\Omega(n^2)\\)且满足正则性条件：\\(S(2n)=O(S(n))\\)，那么可以在\\(O(S(n))\\)求出任意两个矩阵的乘积。\r\n证明：构造矩阵\\(C=\\begin{pmatrix}\r\nA&amp;B\\\\I&amp;O\\end{pmatrix}\\)，其中\\(A,B\\)分别是两个\\(n\\times n\\)大小的矩阵，那么有：\r\n\\[C^2=\\begin{pmatrix}A^2+B&amp;AB\\\\A&amp;B\\end{pmatrix}\\]\r\n可以发现，计算\\(C^2\\)完后，相当于完成了一次\\(AB\\)的矩阵乘法。计算上其它开销，可以知道\r\n\\[M(n)\\le S(2n)=O(S(n))\\]\r\n其中等号是通过正则性条件得出，最终有\\(M(n)=O(S(n))\\)。\r\n因此，对矩阵进行平方和乘法的困难性是一样的。\r\n28.2-2\r\n本解答参考了此页面的信息。\r\n我们令\\(L(n)\\)表示对大小为\\(n\\)的方阵进行LUP分解的时间。证明过程和定理28.2的过程类似：假设\\(S(n)\\)时间内可以求出两个\\(n\\times n\\)矩阵的乘积，并且\\(M(n)=\\Omega(n^2)\\)且满足两个正则性条件：\\(\\forall\r\nk\\in[0,n],M(n+k)=O(M(n))\\)均成立；\\(\\exists c&lt;1/2,M(n/2)\\le\r\ncM(n)\\)成立。那么可以在\\(O(M(n))\\)内对矩阵进行LUP分解。\r\n证明：假设矩阵\\(A\\)的大小\\(n\\)是二次幂，那么对\\(A\\)进行分块\\(A=\\begin{pmatrix}\r\nB&amp;C\\\\D&amp;E\\end{pmatrix}\\)，可以发现每个矩阵大小都是一样的。\r\n对\\(B\\)递归进行分解，假设是\\(P_1B=L_1U_1\\)，那么有\r\n\\(\\begin{aligned}\r\nA&amp;=\\begin{pmatrix}P_1^{-1}&amp;O\\\\O&amp;I_{n/2}\\end{pmatrix}\\begin{pmatrix}L_1U_1&amp;(P_1^{-1})^T\r\nC\\\\D&amp;E\\end{pmatrix}\\\\\r\n&amp;=\\begin{pmatrix}P_1^{-1}&amp;O\\\\O&amp;I_{n/2}\\end{pmatrix}\\begin{pmatrix}L_1&amp;O\\\\DU_1^{-1}&amp;E-DU_1^{-1}L_1^{-1}(P_{1}^{-1})^TC\\end{pmatrix}\\begin{pmatrix}U_1&amp;L_1^{-1}(P_1^{-1})^T\r\nC\\\\O&amp;I_{n/2}\\end{pmatrix}\\\\\r\n\\end{aligned}\\)\r\n接下来再对\\(E-DU_1^{-1}L_1^{-1}(P_{1}^{-1})^TC=P_2^{-1}L_2U_2\\)进行LUP分解，那么得到\r\n\\(\\begin{aligned}\r\nA&amp;=\\begin{pmatrix}P_1^{-1}&amp;O\\\\O&amp;I_{n/2}\\end{pmatrix}\\begin{pmatrix}L_1&amp;O\\\\DU_1^{-1}&amp;P_2^{-1}L_2U_2\\end{pmatrix}\\begin{pmatrix}U_1&amp;L_1^{-1}(P_1^{-1})^T\r\nC\\\\O&amp;I_{n/2}\\end{pmatrix}\\\\\r\n&amp;=\\begin{pmatrix}P_1^{-1}&amp;O\\\\O&amp;I_{n/2}\\end{pmatrix}\\begin{pmatrix}I_{n/2}&amp;O\\\\O&amp;P_2^{-1}\\end{pmatrix}\\begin{pmatrix}L_1&amp;O\\\\DU_1^{-1}&amp;L_2\\end{pmatrix}\\begin{pmatrix}U_1&amp;L_1^{-1}(P_1^{-1})^T\r\nC\\\\O&amp;U_2\\end{pmatrix}\\\\\r\n&amp;=\\begin{pmatrix}P_1^{-1}&amp;O\\\\O&amp;P_2^{-1}\\end{pmatrix}\\begin{pmatrix}L_1&amp;O\\\\DU_1^{-1}&amp;L_2\\end{pmatrix}\\begin{pmatrix}U_1&amp;L_1^{-1}(P_1^{-1})^T\r\nC\\\\O&amp;U_2\\end{pmatrix}\\\\\r\n\\end{aligned}\\)\r\n那么令\\(P=\\begin{pmatrix}P_1&amp;O\\\\O&amp;P_2\\end{pmatrix},L=\\begin{pmatrix}L_1&amp;O\\\\DU_1^{-1}&amp;L_2\\end{pmatrix},U=\\begin{pmatrix}U_1&amp;L_1^{-1}(P_1^{-1})^T\r\nC\\\\O&amp;U_2\\end{pmatrix}\\)，我们得到了\\(A\\)的一个LUP分解。\r\n在这个过程中，我们进行了\\(2\\)次小矩阵的递归LUP分解。其余操作都是对小矩阵进行矩阵乘法，矩阵求匿，根据定理28.1和28.2，这两个操作的时间都为\\(O(M(n))\\)；此外还涉及了一些矩阵转置，矩阵移位等操作，这些操作的时间为\\(O(n^2)\\)。那么有\r\n\\(\\begin{aligned}\r\nL(n)&amp;\\le2L(n/2)+O(M(n))+O(n^2)\\\\\r\n&amp;=2L(n/2)+O(M(n))\\\\\r\n&amp;=O(M(n))\r\n\\end{aligned}\\)\r\n与定理28.2的证明过程类似，最终有\\(L(n)=O(M(n))\\)，原结论成立。\r\n对于\\(n\\)不是\\(2\\)的幂的情况，证明方式和定理28.2的证明过程相同，此处不赘述。\r\n28.2-3\r\n首先证明：如果存在一个时间为\\(M(n)\\)的布尔矩阵乘法算法，那么存在一个时间复杂度为\\(O(M(n)\\lg n)\\)的求解传递闭包算法。\r\n布尔矩阵\\(A,B\\)上的乘法定义成是：\\(\\displaystyle{(AB)_{ij}=\\bigvee_{k=1}^n\r\na_{ik}\\land b_{kj}}\\)。此外由于\\(A\\)的传递闭包\\(A^{\\ast}\\)相当于是\\(A^n\\)，因此按照第23.1章的思想，可以使用单次矩阵乘法依次计算出\\(A^2,A^4,A^8,\\dots\\)也就是说，总共需要进行\\(\\lceil\r\n\\lg(n-1)\\rceil\\)次矩阵乘法即可。因此存在一个时间复杂度为\\(O(M(n)\\lg n)\\)的求解传递闭包算法。\r\n接下来证明：如果存在一个时间为\\(T(n)\\)的求解转递闭包算法，那么存在一个时间复杂度为\\(O(T(n))\\)的布尔矩阵乘法。此处需要假设\\(T(n)\\)满足正则性条件\\(T(3n)=O(T(n))\\)。\r\n将矩阵\\(A,B\\)视为是某些矩阵的邻接矩阵。需要注意的是，传递闭包所求出的是从当前节点\\(u\\)能够到达的所有节点。因此我们考虑构造出一个图\\(G=(V,E)\\)（其邻接矩阵为\\(D\\)），最长路径只有\\(2\\)，从而保证对这个图求出其传递闭包后，这个传递闭包的一部分就是矩阵\\(A,B\\)的乘积。\r\n假设对于\\(A\\)的每一行（列），在\\(G\\)中都有\\(3\\)个节点。其中第\\(i\\)行表示有节点\\(u_i,v_i,w_i\\)。此外，矩阵\\(D\\)的行和列顺序都是\\(u_1,u_2,\\dots,u_n,v_1,v_2,\\dots,v_n,w_1,w_2,\\dots,w_n\\)。如果\\(a_{ik}=1\\)，那么\\((u_i,v_k)\\in E\\)；如果\\(b_{kj}=1\\)，那么\\((v_k,w_j)\\in E\\)。并且令\\(D\\)中的主对角线上的值都为\\(1\\)，那么构造好的\\(D\\)如下：\r\n\\[D=\\begin{bmatrix}\r\nI_n&amp;A&amp;O\\\\\r\nO&amp;I_n&amp;B\\\\\r\nO&amp;O&amp;I_n\r\n\\end{bmatrix}\\]\r\n可见，右上角的那一块属于至少长度为\\(2\\)的路径的区域。因此可以得到\\(D\\)的传递闭包\\(D^{\\ast}\\)为：\r\n\\[D^{\\ast}=\\begin{bmatrix}\r\nI_n&amp;A&amp;AB\\\\\r\nO&amp;I_n&amp;B\\\\\r\nO&amp;O&amp;I_n\r\n\\end{bmatrix}\\]\r\n只需要取出右上角的一块即可得到\\(AB\\)的乘积。因此，求出矩阵\\(AB\\)需要\\(T(3n)\\)的运行时间。如果\\(T(3n)=O(T(n))\\)，那么矩阵乘法只需要花费\\(O(T(n))\\)的时间。\r\n28.2-4\r\n此时定理28.2所提出的矩阵所发求逆无效。定理28.2指出，如果\\(A\\)不是正定矩阵，那么可以构造出对称正定矩阵\\(A^TA\\)，通过间接求出对称正定矩阵\\(A^TA\\)的逆矩阵\\((A^TA)^{-1}\\)，从而通过\\(A^{-1}=(A^TA)^{-1}A^T\\)间接求出\\(A^{-1}\\)。然而，\\(A_TA\\)是正定矩阵在\\(\\mathbb{Z}_2\\)中不一定是成立的。\r\n定理D.6指出在\\(\\mathbb{R}\\)中，\\(A^TA\\)是正定矩阵，是因为对于某个\\(n\\)维向量向量\\(\\mathbf{x}\\in\\mathbb{R}^n,\\mathbf{x}^T(A^TA)\\mathbf{x}=\\lVert\r\nA\\mathbf{x}\\rVert=0\\)当且仅当\\(\\mathbf{x}\\)中的全部值为\\(\\mathbf{x}\\)。但是在\\(\\mathbb{Z}_2^n\\)中，\\(\\lVert\r\nA\\mathbf{x}\\rVert=0\\)并不意味着向量\\(A\\mathbf{x}\\)中全部值为\\(0\\)（可以是偶数个\\(1\\)）。\r\n最终，由于\\(A^TA\\)不一定是正定的，定理28.2无法有效地求出非正定对称（但满秩）矩阵\\(A\\)的一个逆。\r\n\\(\\star\\)\r\n28.2-5\r\n和证明定理28.2的过程类似。首先假设Hermitian矩阵\\(A\\)是正定的，其大小为\\(2\\)的整数次幂。因此矩阵\\(A\\)可以分块成\r\n\\[A=\\begin{bmatrix}\r\nB&amp;C^{\\ast}\\\\\r\nC&amp;D\r\n\\end{bmatrix}\\]\r\n其中\\(C^{\\ast}\\)是\\(C\\)的共轭对称矩阵。\r\n其余过程的步骤完全相同。\r\n当\\(A\\)不是Hermitian矩阵，或者不是正定矩阵时，使用类似的方式，先计算出Hermitian且正定的矩阵\\(A^{\\ast}A\\)的逆\\((A^{\\ast}A)^{-1}\\)，然后再计算\\(A^{-1}=(A^{\\ast}A)^{-1}A^{\\ast}\\)即可。容易验证\\(((A^{\\ast}A)^{-1}\r\nA^{\\ast})A=(A^{\\ast}A)^{-1}(A^{\\ast}A)=I_n\\)。\r\n接下来证明\\(A^{\\ast}A\\)是既是Hermitian矩阵，又是正定的矩阵。整个过程分三步进行。\r\n\r\n证明对于任意复数矩阵\\(A,B\\)，都有\\((AB)^{\\ast}=B^{\\ast}A^{\\ast}\\)。证明过程和题目D.1-2类似。为了方便表示，\\(A\\)中的元素用\\(a_{rc}+b_{rc}i\\)表示，\\(B\\)中的元素用\\(x_{rc}+y_{rc}i\\)表示。\r\n\r\n令\\(a_{rc}^{\\ast}+b_{rc}^{\\ast}i\\)表示转置矩阵\\(A^T\\)的元素，也就是有\\(a_{rc}^{\\ast}+b_{rc}^{\\ast}i=a_{cr}-b_{cr}i\\)。同理，\\(x_{rc}^{\\ast}+y_{rc}^{\\ast}i\\)表示转置矩阵\\(B^T\\)的元素。\r\n对于\\((AB)^{\\ast}\\)中的元素\\(p_{rc}+q_{rc}i\\)，有：\r\n\\(\\begin{aligned}\r\np_{cr}^{\\ast}-q_{cr}^{\\ast}i&amp;=p_{rc}+q_{rc}i\\\\\r\n&amp;=\\sum_{k=1}^n (a_{rk}+b_{rk}i)(x_{kc}+y_{kc}i)\\\\\r\n&amp;=\\sum_{k=1}^n\r\n(a_{kr}^{\\ast}-b_{kr}^{\\ast}i)(x_{ck}^{\\ast}-y_{ck}^{\\ast}i)\\\\\r\n&amp;=\\sum_{k=1}^n\r\n(x_{ck}^{\\ast}-y_{ck}^{\\ast}i)(a_{kr}^{\\ast}-b_{kr}^{\\ast}i)\\\\\r\n\\end{aligned}\\)\r\n可见，对于最后一行，\\(\\displaystyle{\\sum_{k=1}^n\r\n(x_{ck}^{\\ast}-y_{ck}^{\\ast}i)(a_{kr}^{\\ast}-b_{kr}^{\\ast}i)}\\)是计算\\(B^{\\ast}A^{\\ast}\\)矩阵乘法的单个元素的定义式。因此有\\((AB)^{\\ast}=B^{\\ast}A^{\\ast}\\)。\r\n\r\n证明对于列满秩矩阵\\(A,A^{\\ast}A\\)是一个正定矩阵。对于任意\\(n\\)维向量\\(\\mathbf{x}\\)，都有\\(\\mathbf{x}^{\\ast}A^{\\ast}A\\mathbf{x}=(A\\mathbf{x})^{\\ast}\r\n(A\\mathbf{x})=\\langle\r\n((A\\mathbf{x})^{\\ast})^T,A\\mathbf{x}\\rangle\\)。如果\\(Ax\\)中存在一个项目不为\\(0\\)，那么\\(\\langle\r\n((A\\mathbf{x})^{\\ast})^T,A\\mathbf{x}\\rangle\\)的值就大于\\(0\\)，因此\\(A^{\\ast}A\\)是一个正定矩阵。\r\n证明对于列满秩矩阵\\(A,A^{\\ast}A\\)是一个Hermitian矩阵。这里是直接计算\\(A^{\\ast}A\\)中的每个元素\\(u_{rc}+v_{rc}i\\)。可见，有\r\n\r\n\\(\\begin{aligned}\r\nu_{rc}+v_{rc}i&amp;=\\sum_{k=1}^n\r\n(a_{rk}^{\\ast}+b_{rk}^{\\ast}i)(a_{kc}+b_{kc}i)\\\\\r\n&amp;=\\sum_{k=1}^n (a_{kr}-b_{kr}i)(a^{\\ast}_{ck}-b^{\\ast}_{ck}i)\\\\\r\n&amp;=u_{cr}^{\\ast}-v_{cr}^{\\ast}i\r\n\\end{aligned}\\)\r\n因此\\(A^{\\ast}A\\)是一个Hermitian矩阵。\r\n当\\(n\\)不是\\(2\\)的幂时，对矩阵\\(A\\)的操作相同。因此原结论成立。\r\n","categories":["算法导论"]},{"title":"算法导论28 Problems 答案","url":"/introduction-to-algorithms/chapter-28/problems/","content":"\r\n28-1\r\na\r\n以下是多轮进行迭代的结果：\r\n\\(\\begin{array}{c|c}\r\nL&amp;U\\\\\r\n\\begin{bmatrix}\r\n1&amp;0&amp;0&amp;0&amp;0\\\\\r\n0&amp;1&amp;0&amp;0&amp;0\\\\\r\n0&amp;0&amp;1&amp;0&amp;0\\\\\r\n0&amp;0&amp;0&amp;1&amp;0\\\\\r\n0&amp;0&amp;0&amp;0&amp;1\\\\\r\n\\end{bmatrix}&amp;\r\n\\begin{bmatrix}\r\n0&amp;0&amp;0&amp;0&amp;0\\\\\r\n0&amp;0&amp;0&amp;0&amp;0\\\\\r\n0&amp;0&amp;0&amp;0&amp;0\\\\\r\n0&amp;0&amp;0&amp;0&amp;0\\\\\r\n0&amp;0&amp;0&amp;0&amp;0\\\\\r\n\\end{bmatrix}\\\\\r\n\\begin{bmatrix}\r\n1&amp;0&amp;0&amp;0&amp;0\\\\\r\n-1&amp;1&amp;0&amp;0&amp;0\\\\\r\n0&amp;0&amp;1&amp;0&amp;0\\\\\r\n0&amp;0&amp;0&amp;1&amp;0\\\\\r\n0&amp;0&amp;0&amp;0&amp;1\\\\\r\n\\end{bmatrix}&amp;\r\n\\begin{bmatrix}\r\n1&amp;-1&amp;0&amp;0&amp;0\\\\\r\n0&amp;0&amp;0&amp;0&amp;0\\\\\r\n0&amp;0&amp;0&amp;0&amp;0\\\\\r\n0&amp;0&amp;0&amp;0&amp;0\\\\\r\n0&amp;0&amp;0&amp;0&amp;0\\\\\r\n\\end{bmatrix}\\\\\r\n\\begin{bmatrix}\r\n1&amp;0&amp;0&amp;0&amp;0\\\\\r\n-1&amp;1&amp;0&amp;0&amp;0\\\\\r\n0&amp;-1&amp;1&amp;0&amp;0\\\\\r\n0&amp;0&amp;0&amp;1&amp;0\\\\\r\n0&amp;0&amp;0&amp;0&amp;1\\\\\r\n\\end{bmatrix}&amp;\r\n\\begin{bmatrix}\r\n1&amp;-1&amp;0&amp;0&amp;0\\\\\r\n0&amp;1&amp;-1&amp;0&amp;0\\\\\r\n0&amp;0&amp;0&amp;0&amp;0\\\\\r\n0&amp;0&amp;0&amp;0&amp;0\\\\\r\n0&amp;0&amp;0&amp;0&amp;0\\\\\r\n\\end{bmatrix}\\\\\r\n\\begin{bmatrix}\r\n1&amp;0&amp;0&amp;0&amp;0\\\\\r\n-1&amp;1&amp;0&amp;0&amp;0\\\\\r\n0&amp;-1&amp;1&amp;0&amp;0\\\\\r\n0&amp;0&amp;-1&amp;1&amp;0\\\\\r\n0&amp;0&amp;0&amp;0&amp;1\\\\\r\n\\end{bmatrix}&amp;\r\n\\begin{bmatrix}\r\n1&amp;-1&amp;0&amp;0&amp;0\\\\\r\n0&amp;1&amp;-1&amp;0&amp;0\\\\\r\n0&amp;0&amp;1&amp;-1&amp;0\\\\\r\n0&amp;0&amp;0&amp;0&amp;0\\\\\r\n0&amp;0&amp;0&amp;0&amp;0\\\\\r\n\\end{bmatrix}\\\\\r\n\\begin{bmatrix}\r\n1&amp;0&amp;0&amp;0&amp;0\\\\\r\n-1&amp;1&amp;0&amp;0&amp;0\\\\\r\n0&amp;-1&amp;1&amp;0&amp;0\\\\\r\n0&amp;0&amp;-1&amp;1&amp;0\\\\\r\n0&amp;0&amp;0&amp;-1&amp;1\\\\\r\n\\end{bmatrix}&amp;\r\n\\begin{bmatrix}\r\n1&amp;-1&amp;0&amp;0&amp;0\\\\\r\n0&amp;1&amp;-1&amp;0&amp;0\\\\\r\n0&amp;0&amp;1&amp;-1&amp;0\\\\\r\n0&amp;0&amp;0&amp;1&amp;-1\\\\\r\n0&amp;0&amp;0&amp;0&amp;0\\\\\r\n\\end{bmatrix}\\\\\r\n\\begin{bmatrix}\r\n1&amp;0&amp;0&amp;0&amp;0\\\\\r\n-1&amp;1&amp;0&amp;0&amp;0\\\\\r\n0&amp;-1&amp;1&amp;0&amp;0\\\\\r\n0&amp;0&amp;-1&amp;1&amp;0\\\\\r\n0&amp;0&amp;0&amp;-1&amp;1\\\\\r\n\\end{bmatrix}&amp;\r\n\\begin{bmatrix}\r\n1&amp;-1&amp;0&amp;0&amp;0\\\\\r\n0&amp;1&amp;-1&amp;0&amp;0\\\\\r\n0&amp;0&amp;1&amp;-1&amp;0\\\\\r\n0&amp;0&amp;0&amp;1&amp;-1\\\\\r\n0&amp;0&amp;0&amp;0&amp;1\\\\\r\n\\end{bmatrix}\\\\\r\n\\end{array}\\)\r\nb\r\n根据题目28-1-a，可知对应求出\\(L\\)和\\(U\\)矩阵的\\(P=I_5\\)。\r\n因此，可以通过反向替代求出\\(U\\mathbf{x}=\\mathbf{y}=(1,2,3,4,5)^T\\)。接下来，可以通过正向替代求出\\(\\mathbf{x}=(15,14,12,9,5)^T\\)。\r\nc\r\n令\\(e_1,e_2,e_3,e_4,e_5\\)分别为每一维内的单位向量，考虑按照题目28-2-b的方法分别求解方程组\\(A\\mathbf{x_1}=e_1,A\\mathbf{x_2}=e_2,A\\mathbf{x_3}=e_3,A\\mathbf{x_4}=e_4,A\\mathbf{x_5}=e_5\\)的解，分别得到：\r\n\\(\\begin{aligned}\r\n\\mathbf{x_1}&amp;=(5,4,3,2,1)^T\\\\\r\n\\mathbf{x_2}&amp;=(4,4,3,2,1)^T\\\\\r\n\\mathbf{x_3}&amp;=(3,3,3,2,1)^T\\\\\r\n\\mathbf{x_4}&amp;=(2,2,2,2,1)^T\\\\\r\n\\mathbf{x_5}&amp;=(1,1,1,1,1)^T\\\\\r\n\\end{aligned}\\)\r\n因此得到\\(A^{-1}\\)为：\r\n\\(A^{-1}=(\\mathbf{x_1},\\mathbf{x_2},\\mathbf{x_3},\\mathbf{x_4},\\mathbf{x_5})=\r\n\\begin{bmatrix}\r\n5&amp;4&amp;3&amp;2&amp;1\\\\\r\n4&amp;4&amp;3&amp;2&amp;1\\\\\r\n3&amp;3&amp;3&amp;2&amp;1\\\\\r\n2&amp;2&amp;2&amp;2&amp;1\\\\\r\n1&amp;1&amp;1&amp;1&amp;1\\\\\r\n\\end{bmatrix}\\)\r\nd\r\n考虑对算法LU-DECOMPOSITION行为的讨论。由于\\(A\\)是一个三对角矩阵，因此主对角线上的元素\\(a_{ii}(i&lt;\r\nn)\\)，下方仅有至多一个元素不为\\(0\\)，它是\\(a_{i+1,i}\\)。因此算法LU-DECOMPOSITION的第6行的for循环只需要对第\\(i+1\\)行处理即可。这意味着\\(L\\)矩阵的第\\(i\\)列只有元素\\(l_{ii}\\)和\\(l_{i+1,i}\\)可能非零，其它元素都是\\(0\\)。\r\n同理，主对角线上的元素\\(a_{ii}(i&lt;\r\nn)\\)，油坊方仅有至多一个元素不为\\(0\\)，它是\\(a_{i,u_1}\\)。因此算法LU-DECOMPOSITION的第10行的for循环只需要对第\\(i+1\\)列处理即可，根据上面的结论，第9行的for循环也只会处理到第\\(i+1\\)行。这意味着\\(U\\)矩阵的第\\(i\\)行只有元素\\(u_{ii}\\)和\\(u_{i,i+1}\\)可能非零，其它元素都是\\(0\\)。\r\n因此，只需要\\(O(n)\\)的时间就可以构造出三对角矩阵的\\(L\\)矩阵和\\(R\\)矩阵。由于\\(L,U\\)中每行每列至多只有\\(2\\)个元素非\\(0\\)，因此可以在\\(O(n)\\)的时间内完成后向替代和前向替代，求出原方程的解，原结论成立。\r\n考虑使用题目28-1-c的方法求逆矩阵，即计算\\(n\\)个线性方程组的解，计算每个解需要花费\\(O(n)\\)的时间，因此构造出\\(A^{-1}\\)需要\\(n\\cdot\r\nO(n)=O(n^2)\\)的时间。由于构建一个矩阵至少需要\\(\\Omega(n^2)\\)的时间，因此其它求解\\(A\\)逆矩阵的算法将不会低于\\(\\Omega(n^2)\\)。原结论成立。\r\ne\r\n证明过程和题目28-1-d类似。由于\\(A\\)是一个三对角矩阵，因此算法LUP-DECOMPOSITION的第6行和第15行for循环最多只需要执行到第\\(i+1\\)行；因此，在LUP-DECOMPOSITION执行的过程中，当处理到第\\(k\\)行时，因为可能需要和第\\(k+1\\)行交换元素，因此\\(a_{k,k+2}\\)也有可能非\\(0\\)。但总而言之，第\\(k\\)行其它元素必定非\\(0\\)，因此和第13行和第17行的for循环只需要执行到第\\(k+2\\)列，此外13行的for循环的起点只需要设成\\(\\max\\{1,k-1\\}\\)即可，因为第\\(k\\)行和第\\(k+1\\)行的前\\(k-2\\)个元素均为\\(0\\)，可以免去交换。\r\n因此，对三对角矩阵执行算法LUP-DECOMPOSITION后，得到的\\(L\\)矩阵的第\\(i\\)列只有元素\\(l_{ii}\\)和\\(l_{i+1,i}\\)可能非零，其它元素都是\\(0\\)；得到的\\(U\\)矩阵的第\\(i\\)行只有元素\\(u_{ii},u_{i,i+1},u_{i,i+2}\\)可能非零，其它元素都是\\(0\\)。\r\n因此，只需要\\(O(n)\\)的时间就可以构造出三对角矩阵的\\(L\\)矩阵和\\(R\\)矩阵，以及序列\\(\\pi\\)。由于\\(L,U\\)中每行每列至多只有\\(3\\)个元素非\\(0\\)，因此可以在\\(O(n)\\)的时间内完成后向替代和前向替代，求出原方程的解，原结论成立。\r\n28-2\r\na\r\n考虑第\\(i\\)个样条的曲线的系数。由于\\(f(x_i)=f(i)=y_i,f(x_{i+1})=f(i+1)=y_{i+1}\\)，因此有\\(f_i(0)=y_i,f_i(1)=y_{i+1}\\)。类似的，由于\\(f&#39;(x_i)=D_i,f&#39;(x_{i+1})=D_{i+1}\\)，因此有\\(f_i&#39;(0)=D_i,f_i&#39;(1)=D_{i+1}\\)。那么可以列出如下关于\\(a_i,b_i,c_i,d_i\\)的四元一次方程组：\r\n\\(\\left\\{\\begin{aligned}\r\na_i&amp;=y_i\\\\\r\na_i+b_i+c_i+d_i&amp;=y_{i+1}\\\\\r\nb_i&amp;=D_i\\\\\r\nb_i+2c_i+3d_i&amp;=D_{i+1}\r\n\\end{aligned}\\right.\\)\r\n因此可以直接计算出：\r\n\\(\\left\\{\\begin{aligned}\r\na_i&amp;=y_i\\\\\r\nb_i&amp;=D_i\\\\\r\nc_i&amp;=3y_{i+1}-3y_i-D_{i+1}-2D_i\\\\\r\nd_i&amp;=D_{i+1}-2y_{i+1}+2y_i+D_i\r\n\\end{aligned}\\right.\\)\r\n由于每个数\\(y_i,y_{i+1},D_i,D_{i+1}\\)都是已知的，因此我们可以以\\(O(n)\\)的时间直接在计算出这\\(4n\\)个系数。\r\nb\r\n如果二阶仍然保持连续性限制，那么有\\(f_{i}&#39;&#39;(1)=f_{i+1}&#39;&#39;(0)\\)。也就是可以得到\r\n\\[2c_i+6d_{i}=2c_{i+1}\\]\r\n将题目28-2-a的方程组的解代入此式，化简后即可得到\r\n\\[D_i+4D_{i+1}+D_{i+2}=3(y_{i+2}-y_i)\\]\r\n其中，\\(i=0,1,2,\\dots,n-2\\)。将所有下标同时减去\\(1\\)即可得到原题目结论。\r\nc\r\n如果假设\\(x=0\\)是拐点，那么有\\(f&#39;&#39;(0)=0\\)，即\\(f&#39;&#39;_i(0)=0\\)，可以得到\\(c_0=0\\)。代入\\(c_0=3y_{1}-3y_0-D_{1}-2D_0\\)，可以得到\\(D_1+2D_0=3(y_1-y_0)\\)。\r\n同样的，如果假设\\(x=n\\)也是拐点，那么有\\(f&#39;&#39;(n)=0\\)，即\\(f&#39;&#39;_{n-1}(1)=0\\)，可以得到\\(2c_{n-1}+6d_{n-1}=0\\)。代入\\(c_{n-1}=3y_{n}-3y_{n-1}-D_{n}-2D_{n-1},d_{n-1}=D_{n}-2y_{n}+2y_{n-1}+D_{n-1}\\)，可以得到\\(D_{n-1}+2D_n=3(y_n-y_{n-1})\\)。\r\nd\r\n根据题目28-2-b和题目28-2-c的结论，可以写成如下关于\\(D\\)的\\(n+1\\)元线性方程组：\r\n\\[\\begin{bmatrix}\r\n2 &amp; 1 &amp; 0 &amp; 0&amp; \\cdots &amp; 0 &amp; 0 &amp; 0\\\\\r\n1 &amp; 4 &amp; 2 &amp; 0&amp; \\cdots &amp; 0 &amp; 0 &amp; 0\\\\\r\n0 &amp; 1 &amp; 4 &amp; 2&amp; \\cdots &amp; 0 &amp; 0 &amp; 0\\\\\r\n0 &amp; 0 &amp; 1 &amp; 4&amp; \\cdots &amp; 0 &amp; 0 &amp; 0\\\\\r\n\\vdots &amp; \\vdots &amp; \\vdots &amp;\\vdots &amp; \\ddots &amp; \\vdots\r\n&amp; \\vdots &amp;\\vdots\\\\\r\n0 &amp; 0 &amp; 0 &amp; 0&amp;\\cdots &amp; 1 &amp; 4 &amp; 2\\\\\r\n0 &amp; 0 &amp; 0 &amp; 0&amp;\\cdots &amp; 0&amp; 1 &amp; 2\r\n\\end{bmatrix}\r\n\\begin{bmatrix}\r\nD_0\\\\\r\nD_1\\\\\r\nD_2\\\\\r\nD_3\\\\\r\n\\vdots\\\\\r\nD_{n-1}\\\\\r\nD_n\\\\\r\n\\end{bmatrix}\r\n=\r\n\\begin{bmatrix}\r\n3(y_1-y_0)\\\\\r\n3(y_2-y_0)\\\\\r\n3(y_3-y_1)\\\\\r\n3(y_4-y_2)\\\\\r\n\\vdots\\\\\r\n3(y_n-y_{n-2})\\\\\r\n3(y_n-y_{n-1})\r\n\\end{bmatrix}\\]\r\n将上面的方程组简化成\\(AD=Y\\)，那么可以发现，\\(A\\)是题目28-1中提到的三对角矩阵。\r\ne\r\n由于\\(A\\)是一个非奇异矩阵，也是一个三对角矩阵，因此按照题目28-1-e的结论，题目28-2-d所构造出的关于向量\\(D\\)的方程组可以在\\(O(n)\\)的时间计算出来。\r\n计算出\\(D\\)后，按照题目28-2-a的结论，\\(f\\)中的每个样条的每个系数可以在\\(O(n)\\)时间内计算出来。\r\n因此这种插值方式可以在\\(O(n)\\)时间内完成。\r\nf\r\n对于更一般的点值\\((x_0,y_0),(x_1,y_1),\\dots,(x_n,y_n)\\)，其中\\(x_i\\le x_{i+1}\\)，并且\\(0\\le i&lt;n\\)。如果\\(x\\in[x_i,x_{i+1}]\\)，那么\\(f(x)=f_i(x-x_i)\\)，其中\\(f_i(x)\\)的定义域是\\([0,x_{i+1}-x_i]\\)，令\\(t_i=x_{i+1}-x_i\\)。\r\n按照题目28-2-a类似的方式，可以导出如下关于\\(a_i,b_i,c_i,d_i\\)的方程组。\r\n\\(\\left\\{\\begin{aligned}\r\nf_i(0)&amp;=y_i\\\\\r\nf_i(t_i)&amp;=y_{i+1}\\\\\r\nf_i&#39;(0)&amp;=D_i\\\\\r\nf_i&#39;(t_i)&amp;=D_{i+1}\r\n\\end{aligned}\\right.\\)\r\n将其求解后，可以使用\\(y_i,y_{i+1},D_i,D_{i+1}\\)来表示\\(a_i,b_i,c_i,d_i\\)的值。\r\n按照题目28-2-b类似的方式，可以得出\\(f&#39;&#39;_i(t_i)=f_{i+1}&#39;&#39;(0)\\)，化简后得到\\(2c_i+6d_{i}t_i=2c_{i+1}\\)。代入上面的式子，可以得到一个关于\\(D_i,D_{i+1},D_{i+2}\\)的等式。\r\n按照题目28-2-c类似的方式，也可以得出两条分别关于\\(D_0,D_1\\)的等式和\\(D_{n-1},D_n\\)的等式。\r\n最终由此构造出来的线性方程组仍然是\\(AD=Y\\)的形式，并且\\(A\\)仍然是一个三对角矩阵，之后构建出函数\\(f\\)的方法和题目28-2-e相同。\r\n","categories":["算法导论"]},{"title":"算法导论3.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-3/exercises-2/","content":"\r\n3.2-1\r\n由于\\(f(n)\\ge 0,g(n)\\ge\r\n0\\)，因此可以构造出如下不等式：\r\n\\(\\begin{aligned}\r\n&amp;f(n)\\le \\max\\{f(n),g(n)\\}&amp;(1)\\\\\r\n&amp;g(n)\\le \\max\\{f(n),g(n)\\}&amp;(2)\\\\\r\n&amp;f(n)+g(n) \\ge \\max\\{f(n),g(n)\\}&amp;(3)\r\n\\end{aligned}\\)\r\n根据式子\\((1),(2)\\)，可以得到\\(\\dfrac{f(n)+g(n)}{2}\\le\r\n\\max\\{f(n),g(n)\\}\\)。利用这条不等式和式子\\((3)\\)，可以得到：\r\n\\[0\\le\\dfrac{f(n)+g(n)}{2}\\le\r\n\\max\\{f(n),g(n)\\}\\le f(n)+g(n)  \\]\r\n其中，\\(c_1=\\dfrac{1}{2},c_2=1\\)，根据\\(\\Theta\\)符号的定义得到${f(n),g(n)}=(f(n)+g(n))\r\n$\r\n3.2-2\r\n这句话可能的本意是：算法\\(A\\)的时间复杂度至少为\\(\\Theta(n^2)\\)。根据符号\\(O\\)的定义，\\(n^2\\)是内部这些函数的上界。也就是说，这句话是说明算法\\(A\\)的时间复杂度至少是以\\(n^2\\)为上界中的一个。因此这种说法毫无意义。\r\n3.2-3\r\n\\(2^{n+1}=O(2^n)\\)\r\n要求构造出一对\\(n_0,c\\)使得对于所有的\\(n\\ge n_0\\)，满足\\(0\\le 2^{n+1}\\le c\\cdot 2^n\\)。\r\n可以将第二个不等式化简成\\(c\\ge\r\n2\\)，那么我们能够成功构造出\\(c=n_0=2\\)。\r\n\\(2^{2n}\\neq O(2^n)\\)\r\n要求构造出一对\\(n_0,c\\)使得对于所有的\\(n\\ge n_0\\)，满足\\(0\\le 2^{2n}\\le c\\cdot 2^n\\)。\r\n可以将第二个不等式化简成\\(c\\ge\r\n2^n\\)，由于\\(2^n\\)的无限增长，不存在\\(n_0\\)，使得当\\(n&gt;n_0\\)时，仍然满足\\(c\\ge 2^n\\)，由此得出答案。\r\n3.2-4\r\n充分性：对于\\(f(n)=\\Theta(g(n))\\)，存在正整数\\(n_0,c_1,c_2\\)使得对于所有\\(n\\ge n_0,0\\le c_1g(n)\\le f(n)\\le c_2\r\ng(n)\\)成立。\r\n将如上不等式提取出\\(0\\le c_1 g(n)\\le\r\nf(n)\\)，那么\\((c_1,n_0)\\)的存在性说明\\(f(n)=\\Omega(g(n))\\)\r\n将如上不等式提取出\\(0\\le f(n)\\le\r\nc_2g(n)\\)，那么\\((c_2,n_0)\\)的存在性说明\\(f(n)=O(g(n))\\)\r\n最终，充分性成立。\r\n必要性：\r\n对于\\(f(n)=\\Omega(g(n))\\)，存在正数\\(n_1,c_1\\)使得对于所有使得对于所有\\(n\\ge n_1,0\\le c_1 g(n)\\le f(n)\\)成立。\r\n对于\\(f(n)=O(g(n))\\)，存在正数\\(n_2,c_2\\)使得对于所有使得对于所有\\(n\\ge n_2,0\\le f(n)\\le c_2 g(n)\\)成立。\r\n构造出\\(n&#39;=\\max(n_1,n_2)\\)，那么对于所有\\(n\\ge n&#39;,0\\le c_1 g(n)\\le f(n),0\\le f(n)\\le c_2\r\ng(n)\\)均成立，也就是\\(0\\le c_1g(n)\\le\r\nf(n)\\le c_2 g(n)\\)。\r\n那么新构造出的\\((c_1,c_2,n&#39;)\\)说明\\(f(n)=\\Theta(g(n))\\)\r\n最终，必要性成立。\r\n3.2-5\r\n假设算法的最好运行时间为\\(T_l(n)\\)，最坏运行时间为\\(T_r(n)\\)，那么对于算法的任意运行时间\\(t(n)\\)位于区间\\([T_l(n),T_r(n)]\\)中。\r\n根据题目所给的条件，得到\\(T_l(n)=\\Omega(g(n)),T_r(n)=O(g(n))\\)，那么根据\\(\\Omega,O\\)符号的定义，分别有：\r\n存在正数\\(n_1,c_1\\)使得对于所有使得对于所有\\(n\\ge n_1,0\\le c_1 g(n)\\le\r\nT_l(n)\\)成立。\r\n存在正数\\(n_2,c_2\\)使得对于所有使得对于所有\\(n\\ge n_2,0\\le T_r(n)\\le c_2\r\ng(n)\\)成立。\r\n令\\(n&#39;=\\max(n_1,n_2)\\)，那么对于所有\\(n\\ge n&#39;\\)，以下不等式成立：\r\n\\[0\\le c_1g(n)\\le T_l(n)\\le t(n)\\le\r\nT_r(n)\\le c_2g(n)\\]\r\n根据\\(\\Theta\\)符号的定义，构造出的\\((n&#39;,c_1,c_2)\\)说明\\(t(n)=\\Theta(g(n))\\)。\r\n3.2-6\r\n令\\(f(n)=o(g(n))\\cap\r\n\\omega(g(n))\\)。\r\n根据\\(\\omega\\)符号的定义：存在正数\\(n_1,c_1\\)使得对于所有使得对于所有\\(n\\ge n_1,0\\le c_1 g(n)&lt; f(n)\\)成立。\r\n根据\\(o\\)符号的定义：存在正数\\(n_2,c_2\\)使得对于所有使得对于所有\\(n\\ge n_2,0\\le f(n) &lt; c_2g(n)\\)成立。\r\n令\\(n&#39;=\\max(n_1,n_2)\\)，那么对于所有\\(n\\ge n&#39;\\)，以下不等式成立：\r\n\\[c_1g(n)&lt;f(n)&lt;c_2g(n)\\]\r\n根据\\(o,\\omega\\)的定义，随着\\(n\\)增长，它不能在保证\\(c_1 g(n)&lt; f(n)\\)的同时，又满足\\(f(n)&lt; c_2g(n)\\)。因此这样的\\(f(n)\\)不存在，原集合为空集。\r\n3.2-7\r\n集合\\(\\Omega(g(n,m))\\)是满足以下条件的所有函数\\(f(n,m)\\)：存在正数\\(c,n_0,m_0\\)，对于所有\\(n\\ge n_0\\lor m\\ge m_0\\)，等式\\(0\\le cg(n,m)\\le f(n,m)\\)成立。\r\n集合\\(\\Theta(g(n,m))\\)是满足以下条件的所有函数\\(f(n,m)\\)：存在正数\\(c_1,c_2,n_0,m_0\\)，对于所有\\(n\\ge n_0\\lor m\\ge m_0\\)，等式\\(0\\le c_1g(n,m)\\le f(n,m)\\le\r\nc_2g(n,m)\\)成立。\r\n","categories":["算法导论"]},{"title":"算法导论3 Problems 答案","url":"/introduction-to-algorithms/chapter-3/problems/","content":"\r\n3-1\r\na\r\n不失一般性，本题将证明\\(p(n)=O(n^d)\\)，因为对于\\(\\forall k\\ge d,n^d=O(n^k)\\)均成立。\r\n那么此时证明\\(\\exists c,n_0&gt;0,\\forall\r\nn\\ge n_0,0\\le p(n)\\le cn^d\\)成立。\r\n那么对\\(p(n)\\le\r\ncn^d\\)两边同时除上\\(n^d\\)，得到\r\n\\(c\\ge\r\na_d+\\dfrac{a_{d-1}}{n}+\\dfrac{a_{d-2}}{n^2}+\\dots+\\dfrac{a_0}{n^d}\\)\r\n也就是\\(c-a_d\\ge\r\n\\dfrac{a_{d-1}}{n}+\\dfrac{a_{d-2}}{n^2}+\\dots+\\dfrac{a_0}{n^d}\\)\r\n如果令\\(c-a_d=1\\)，那么说明可以构造出\\(n_0\\)满足\\(\\max_{i=1}^d\\left\\{\\dfrac{a_{d-i}}{n_0^i}\\right\\}\\le\\dfrac{1}{d}\\)。\r\n也就是说，\\(n_0=\\max_{i=1}^d\r\n\\{\\sqrt[i]{d\\cdot a_{d-i}}\\}\\)。\r\n如上构造出的\\((c,n_0)\\)，说明\\(p(n)=O(n^d)\\)。\r\n问题b,c,d,e的证明方式类似，此处不再赘述。\r\n3-2\r\n\\[\\begin{array}{|l|l|l|l|l|l|l|}\r\n\\hline\r\nA &amp; B &amp; O &amp; o &amp; \\Omega &amp; \\omega &amp;\\Theta\\\\\r\n\\hline\r\n\\lg^k n &amp; n^{\\epsilon} &amp;\r\n\\texttt{yes}&amp;\\texttt{yes}&amp;\\texttt{no} &amp; \\texttt{no} &amp;\r\n\\texttt{no}\\\\\r\n\\hline\r\nn^k &amp; c^n &amp; \\texttt{yes}&amp;\\texttt{yes}&amp;\\texttt{no} &amp;\r\n\\texttt{no} &amp; \\texttt{no}\\\\\r\n\\hline\r\n\\sqrt{n} &amp; n^{\\sin n} &amp;\r\n\\texttt{no}&amp;\\texttt{no}&amp;\\texttt{no} &amp; \\texttt{no} &amp;\r\n\\texttt{no}\\\\\r\n\\hline\r\n2^n &amp; 2^{n/2} &amp; \\texttt{no}&amp;\\texttt{no}&amp;\\texttt{yes}\r\n&amp; \\texttt{yes} &amp; \\texttt{no}\\\\\r\n\\hline\r\nn^{\\lg c} &amp; c^{\\lg n} &amp;\r\n\\texttt{yes}&amp;\\texttt{no}&amp;\\texttt{yes} &amp; \\texttt{no} &amp;\r\n\\texttt{yes}\\\\\r\n\\hline\r\n\\lg(n!) &amp; \\lg(n^n) &amp;\r\n\\texttt{yes}&amp;\\texttt{no}&amp;\\texttt{yes} &amp; \\texttt{no} &amp;\r\n\\texttt{yes}\\\\\r\n\\hline\r\n\\end{array}\\]\r\n显而易见，随着\\(n\\)的增大，\\(n^{\\sin\r\nn}\\)不是渐进增长的，一直在震荡。没有任何函数能够以它为界限。\r\n根据等式\\(3.21\\)，有\\(n^{\\lg c} = c^{\\lg\r\nn}\\)，因此第四行的两个式子实际上是相同的。\r\n3-3\r\na\r\n增长速度从大到小如下：\r\n\\[\\begin{aligned}\r\n&amp;2^{2^{n+1}}\\\\\r\n&amp;2^{2^n}\\\\\r\n&amp;(n+1)!\\\\\r\n&amp;n!\\\\\r\n&amp;e^n\\\\\r\n&amp;n\\cdot 2^n\\\\\r\n&amp;2^n\\\\\r\n&amp;(3/2)^n\\\\\r\n&amp;(\\lg n)^{\\lg n},n^{\\lg \\lg n}\\\\\r\n&amp;(\\lg n)!&amp; \\qquad(A)\\\\\r\n&amp;n^3\\\\\r\n&amp;n^2,4^{\\lg n}\\\\\r\n&amp;n\\lg n,\\lg(n!)\\\\\r\n&amp;n,2^{\\lg n}\\\\\r\n&amp;\\sqrt{2}^{\\lg n}&amp;\\qquad(B)\\\\\r\n&amp;2^{\\sqrt{2\\lg n}}\\\\\r\n&amp;\\lg ^2 n\\\\\r\n&amp;\\ln n\\\\\r\n&amp;\\sqrt{\\lg n}\\\\\r\n&amp;\\ln \\ln n\\\\\r\n&amp;2^{\\lg^{\\ast} n}\\\\\r\n&amp;\\lg^{\\ast}n,\\lg^{\\ast}(\\lg n)&amp;\\qquad(C)\\\\\r\n&amp;\\lg(\\lg^{\\ast} n)\\\\\r\n&amp; n^{1/\\lg n},1&amp;\\qquad(D)\\\\\r\n\\end{aligned}\\]\r\n\\((A)\\)式可以根据斯特林公式如下化简：\r\n\\((\\lg n)!=\\sqrt{2\\pi\\lg n}\\dfrac{(\\lg\r\nn)^{\\lg n}}{e^{\\lg\r\nn}}\\left(1+\\Theta\\left(\\dfrac{1}{n}\\right)\\right)=\\dfrac{\\sqrt{2\\pi \\lg\r\nn}}{n} (\\lg n)^{\\lg n}\r\n\\left(1+\\Theta\\left(\\dfrac{1}{n}\\right)\\right)\\)\r\n由此发现，其渐进增长速度低于\\((\\lg n)^{\\lg\r\nn}\\)。\r\n\\((B)\\)式化简后的结果为\\(\\sqrt{n}\\)。\r\n对于\\((C)\\)式子，相比于\\(\\lg^{\\ast}n\\)，\\(\\lg^{\\ast}(\\lg n)\\)的迭代次数恰好少\\(1\\)，因为\\(n\\)进行一次迭代后就变成了 \\(\\lg n\\)。因此，\\(\\lg^{\\ast}(\\lg\r\nn)=\\lg^{\\ast}n-1=\\Theta(\\lg^{\\ast}n)\\)。\r\n\\((D)\\)式可以如下化简：\\(n^{1/\\lg n}=n^{\\log_n 2}=2=\\Theta(1)\\)\r\nb\r\n\\(f(n)=3^{2^{n+1}}\\cdot (n\\bmod\r\n2)\\)。可以发现，\\(f(n)\\neq\r\n\\Omega(1)\\)，因为\\(f(n)=0\\)也成立。同样的，\\(f(n)\\neq\r\nO(2^{2^{n+1}})\\)也成立。根据符号\\(O,\\Omega\\)的传递性，可以知道\\(f(n)\\)满足题意。\r\n3-4\r\na\r\n不正确。\r\n若\\(f(n)=n,g(n)=n^2\\)，那么虽然\\(f(n)=O(g(n))\\)，但是\\(g(n)\\neq O(f(n))\\)。\r\nb\r\n不正确。\r\n若\\(f(n)=n,g(n)=n^2\\)，那么虽然\\(f(n)=g(n)=n^2+n=\\Theta(n^2)\\neq\r\nn\\)，此时\\(f(n)+g(n)\\neq\r\n\\min\\{f(n)+g(n)\\}\\)。\r\nc\r\n正确。\r\n\\(f(n)=O(g(n))\\)意味着\\(\\exists c,n_0&gt;0,\\forall n\\ge n_0,0\\le f(n)\\le\r\ncg(n)\\)成立。不失一般性，假设\\(c&gt;1\\)，那么\\(\\lg f(n)\\le \\lg c+\\lg g(n)\\le(\\lg c+1)\\lg\r\ng(n)\\)成立。那么，新构造出来的一对\\((\\lg c+1,n_0)\\)说明\\(\\lg f(n)=O(\\lg g(n))\\)。\r\nd\r\n不正确。\r\n令\\(f(n)=2n,g(n)=n\\)，虽然\\(f(n)=O(g(n))\\)，但是\\(4^n\\neq O(2^n)\\)，也就是\\(2^{f(n)}\\neq O(2^{g(n)})\\)。\r\ne\r\n先决条件：如果\\(f(n)\\ge\r\n1\\)恒成立，那么就是正确的。\r\n\\(f(n)=O(f^2(n))\\)意味着\\(\\exists c,n_0&gt;0,\\forall n\\ge n_0,0\\le f(n)\\le\r\ncf^2(n)\\)成立。基于先决条件，这个不等式是正确的。\r\nf\r\n正确。\r\n\\(f(n)=O(g(n))\\)意味着\\(\\exists c,n_0&gt;0,\\forall n\\ge n_0,0\\le f(n)\\le\r\ncg(n)\\)成立。也就是说，\\(0\\le\r\n\\dfrac{f(n)}{c}\\le g(n)\\)成立。那么新构造出来的一对\\(\\left(\\dfrac{1}{c},n_0\\right)\\)说明\\(g(n)=\\Omega(f(n))\\)。\r\ng\r\n不正确。\r\n假设\\(f(n)=2^n\\)，那么\\(2^n\\neq \\Theta(2^{n/2})\\)，因此\\(f(n)\\neq \\Theta(f(n/2))\\)。\r\nh\r\n令\\(g(n)=o(f(n))\\)，那么意味着\\(\\exists c,n_0,\\forall n\\ge n_0,0\\le g(n)&lt;\r\ncf(n)\\)成立。那么得到如下不等式：\r\n\\(0\\le f(n)\\le f(n)+g(n)&lt; (c+1)\r\nf(n)\\)\r\n那么新构造出的一对\\((c+1,n_0)\\)，说明\\(f(n)+o(f(n))=\\Theta(f(n))\\)成立。\r\n3-5\r\na\r\n由\\(\\Theta\\)符号的自反性可得：\\(f(n)=\\Theta(f(n))=\\Theta(\\Theta(f(n)))\\)。\r\nb\r\n令\\(g(n)=\\Theta(f(n)),h(n)=O(f(n))\\)，那么：\r\n\r\n\\(\\exists c_1,c_2,n_1&gt;0,\\forall n\\ge\r\nn_1,0\\le c_1f(n)\\le g(n)\\le c_2f(n)\\)成立。\r\n\\(\\exists c,n_2&gt;0,\\forall n\\ge n_2,0\\le\r\nh(n)\\le cf(n)\\)成立。\r\n\r\n令\\(n&#39;=\\max(n_1,n_2)\\)，那么\\(\\forall n\\ge n&#39;\\)，以下不等式成立。\r\n\\[0\\le c_1f(n)\\le g(n)+h(n)\\le\r\n(c+c_2)f(n)\\]\r\n那么新构造出来的\\((c_1,c+c_2,n&#39;)\\)说明\\(g(n)+h(n)=\\Theta(f(n))\\)，即\\(\\Theta(f(n))+O(f(n))=\\Theta(f(n))\\)。\r\nc\r\n令\\(p(n)=\\Theta(f(n)),q(n)=\\Theta(g(n))\\)，那么：\r\n\r\n\\(\\exists c_1,c_2,n_1&gt;0,\\forall n\\ge\r\nn_1,0\\le c_1f(n)\\le p(n)\\le c_2f(n)\\)成立。\r\n\\(\\exists c_3,c_4,n_2&gt;0,\\forall n\\ge\r\nn_2,0\\le c_3g(n)\\le q(n)\\le c_4g(n)\\)成立。\r\n\r\n令\\(n&#39;=\\max(n_1,n_2)\\)，那么\\(\\forall n\\ge n&#39;\\)，以下不等式成立。\r\n\\[0\\le \\min(c_1,c_3)\\cdot(f(n)+g(n))\\le\r\nc_1f(n)+c_3g(n)\\le p(n)+q(n)\\le c_2f(n)+c_4g(n)\\le \\max(c_2,c_4)\\cdot\r\n(f(n)+g(n))\\]\r\n那么新构造出来的\\((\\min(c_1,c_3),\\max(c_2,c_4),n&#39;)\\)说明\\(p(n)+q(n)=\\Theta(f(n)+g(n))\\)，即\\(\\Theta(f(n))+\\Theta(g(n))=\\Theta(f(n)+g(n))\\)\r\nd\r\n令\\(p(n)=\\Theta(f(n)),q(n)=\\Theta(g(n))\\)，那么：\r\n\r\n\\(\\exists c_1,c_2,n_1&gt;0,\\forall n\\ge\r\nn_1,0\\le c_1f(n)\\le p(n)\\le c_2f(n)\\)成立。\r\n\\(\\exists c_3,c_4,n_2&gt;0,\\forall n\\ge\r\nn_2,0\\le c_3g(n)\\le q(n)\\le c_4g(n)\\)成立。\r\n\r\n令\\(n&#39;=\\max(n_1,n_2)\\)，那么\\(\\forall n\\ge n&#39;\\)，以下不等式成立。\r\n\\[0\\le  c_1\\cdot c_3\\cdot f(n) \\cdot\r\ng(n)\\le p(n)\\cdot q(n)\\le  c_2\\cdot c_4\\cdot f(n) \\cdot\r\ng(n)\\]\r\n那么新构造出来的\\((c_1\\cdot c_3,c_2\\cdot\r\nc_4,n&#39;)\\)说明\\(p(n)\\cdot\r\nq(n)=\\Theta(f(n)\\cdot g(n))\\)，即\\(\\Theta(f(n))\\cdot\\Theta(g(n))=\\Theta(f(n)\\cdot\r\ng(n))\\)。\r\ne\r\n考虑计算极限 \\(\\displaystyle{\\lim_{n\\rightarrow+\\infty}\\dfrac{(a_1n)^{k_1}\r\n\\lg^{k_2}(a_2n)}{n^{k_1}\\lg^{k_2} n}}\\) 的值。有\r\n\\(\\begin{aligned}\r\n\\lim_{n\\rightarrow+\\infty}\\dfrac{(a_1n)^{k_1}\r\n\\lg^{k_2}(a_2n)}{n^{k_1}\\lg^{k_2}\r\nn}&amp;=\\lim_{n\\rightarrow+\\infty}\\left(\\dfrac{a_1n}{n}\\right)^{k_1}\r\n\\left(\\dfrac{\\lg(a_2n)}{\\lg n}\\right)^{k_2}\\\\\r\n&amp;=\\lim_{n\\rightarrow+\\infty}a_1^{k_1}\\left(1+\\dfrac{\\lg a_2}{\\lg\r\nn}\\right)^{k_2}\\\\\r\n&amp;=a_1^{k_1}\r\n\\end{aligned}\\)\r\n当\\(a_1&gt; 0\\)时，\\(a_1^{k_1}\\neq 0\\)，因此\\((a_1n)^{k_1}\r\n\\lg^{k_2}(a_2n)=\\Theta(n^{k_1}\\lg^{k_2} n)\\)成立。\r\n\\(\\star\\) f\r\n令\\(g(n)=\\Theta(f(n))\\)，那么\\(\\exists c_1,c_2,n_1&gt;0,\\forall n\\ge n_1,0\\le\r\nc_1f(n)\\le g(n)\\le c_2f(n)\\)成立。\r\n当\\(k &lt; n_0\\)时，\\(g(k)=\\Theta(1)\\)，为低阶项，不需要进行考虑。因此仅需要\\(\\forall k\\in S, k\\ge n_1\\)时的情况。\r\n那么对不等式每一个项进行求和，有\\(\\displaystyle{0\\le c_1\\sum_{k\\in S} f(k)\\le\r\n\\sum_{k\\in S} g(k)\\le c_2\\sum_{k\\in S} f(k)}\\)。\r\n由此构造出来的\\(\\{n_1,c_1,c_2\\}\\)说明\\(\\displaystyle{\\sum_{k\\in S} g(k)=\\Theta\r\n\\left(\\sum_{k\\in S} f(k)\\right)}\\)。\r\n因此有\\(\\displaystyle{\\sum_{k\\in S}\r\n\\Theta(f(k))=\\Theta \\left(\\sum_{k\\in S} f(k)\\right)}\\)。\r\n\\(\\star\\) g\r\n对于所有整数\\(n\\)，令\\(f(n)\\equiv 1,g(n)\\equiv\r\n\\dfrac{1}{2}\\)，不难知道，\\(g(n)=\\Theta(f(n))\\)。\r\n那么有\\(\\displaystyle{\\prod_{k\\in S}\r\ng(k)=\\prod_{k\\in S} \\Theta(f(k))=\\dfrac{1}{2^{|S|}}}\\)。\r\n不难发现\\(\\displaystyle{\\prod_{k\\in S}\r\ng(k)=O\\left(\\prod_{k\\in S} f(k)\\right)}=O(1)\\)，但是\\(\\displaystyle{\\prod_{k\\in S}\r\ng(k)\\neq\\Omega\\left(\\prod_{k\\in S}\r\nf(k)\\right)}=\\Omega(1)\\)。因为当集合\\(S\\)的大小区域无穷大时，\\(\\displaystyle{\\prod_{k\\in S}\r\ng(k)}\\)的值无限趋近于\\(0\\)，那么不存在正常数\\(c&#39;\\)，使得对于无穷多的\\(S\\subseteq \\mathbb{Z},\\displaystyle{\\prod_{k\\in S}\r\ng(k)}\\ge c&#39;\\prod_{k\\in S} f(k)\\)成立。\r\n此时有\\(\\displaystyle{\\prod_{k\\in S}\r\n\\Theta(f(k))\\neq \\Theta\\left(\\prod_{k\\in S} f(k)\\right)}\\)。\r\n因此，对于所有整数\\(n\\)，令\\(f(n)\\equiv 1,g(n)\\equiv\r\n\\dfrac{1}{2}\\)为一个反例。并且，无论\\(\\displaystyle{\\prod_{k\\in S}\r\n\\Theta(f(k))}\\)还是\\(\\displaystyle{\\Theta\\left(\\prod_{k\\in S}\r\nf(k)\\right)}\\)，它们都是收敛的。\r\n3-6\r\na\r\n如果\\(f(n)=\\Theta(g(n))\\)，那么\\(f(n)=O(g(n)),f(n)=\\Omega^{\\infty}(g(n))\\)。\r\n如果存在整数\\(c\\)，存在无穷多个\\(n,f(n)\\ge cg(n)\\ge0\\)成立，那么\\(f(n)=\\Omega^{\\infty}(g(n))\\)。\r\n如果存在整数\\(c\\)，存在无穷多个\\(n,cg(n)\\ge f(n)\\ge0\\)成立，那么\\(f(n)=O(g(n))\\)。\r\n如果存在整数\\(c\\)，就算存在有穷多个\\(n,f(n)\\ge cg(n)\\ge0\\)成立，那么随着\\(n\\rightarrow + \\infty,cg(n)\\ge\r\nf(n)\\ge0\\)成立。也就是\\(f(n)=O(g(n))\\)\r\nb\r\n可以构造出\\(f(n)=n^{1+\\sin\r\nn},g(n)=n\\)，可以发现，\\(f(n)\\)和\\(g(n)\\)不能用于彼此渐进比较。\r\nc\r\n使用\\(\\Omega^{\\infty}\\)的优点：可以用于描述所有函数之间的渐近关系（如果有的话）。\r\n缺点：无穷多个\\(n\\)和\\(n\\)趋于无穷这两种说法似乎有点区别，描述不够精确。\r\nd\r\n\\(f(n)=\\Theta(g(n))\\)可以推导出\\(f(n)=O&#39;(g(n)),f(n)=\\Omega(g(n))\\)。\r\n如果\\(f(n)=O&#39;(g(n)),f(n)=\\Omega(g(n))\\)，不能推导出\\(f(n)=\\Theta(g(n))\\)。\r\ne\r\n\\(\\tilde{\\Omega}(g(n)):\\exists\r\nc,k,n_0&gt;0,\\forall n\\ge n_0,0\\le cg(n)\\lg ^k(n)\\le\r\nf(n)\\)成立。\r\n\\(\\tilde{\\Theta}(g(n)):\\exists\r\nc_1,k_1,c_2,k_2,n_0&gt;0,\\forall n\\ge n_0,0\\le c_1g(n)\\lg ^{k_1}(n)\\le\r\nf(n)\\le c_2g(n)\\lg^{k_2}(n)\\)成立。\r\n充分性：\r\n将如上不等式提取出\\(0\\le\r\nc_1g(n)\\lg^{k_1}(n)\\le f(n)\\)，那么\\((c_1,k_1,n_0)\\)的存在性说明\\(f(n)=\\tilde{\\Omega}(g(n))\\)\r\n将如上不等式提取出\\(0\\le f(n)\\le\r\nc_2g(n)\\lg^{k_2}(n)\\)，那么\\((c_2,k_2,n_0)\\)的存在性说明\\(f(n)=\\tilde{O}(g(n))\\)\r\n最终，充分性成立。\r\n必要性：\r\n对于\\(f(n)=\\tilde{\\Omega}(g(n))\\)，存在正数\\(n_1,c_1\\)使得对于所有使得对于所有\\(n\\ge n_1,0\\le c_1g(n)\\lg^{k_1}(n)\\le\r\nf(n)\\)成立。\r\n对于\\(f(n)=\\tilde{O}(g(n))\\)，存在正数\\(n_2,c_2\\)使得对于所有使得对于所有\\(n\\ge n_2,0\\le f(n)\\le\r\nc_2g(n)\\lg^{k_2}(n)\\)成立。\r\n构造出\\(n&#39;=\\max(n_1,n_2)\\)，那么对于所有\\(0\\le c_1g(n)\\lg^{k_1}(n)\\le f(n),0\\le f(n)\\le\r\nc_2g(n)\\lg^{k_2}(n)\\)均成立，也就是\\(0\\le c_1g(n)\\lg ^{k_1}(n)\\le f(n)\\le\r\nc_2g(n)\\lg^{k_2}(n)\\)。\r\n那么新构造出的\\((c_1,k_1,c_2,k_2,n&#39;)\\)说明\\(f(n)=\\tilde{\\Theta}(g(n))\\)。\r\n最终，必要性成立。\r\n3-7\r\n\\[\\begin{array}{|l|l|l|}\r\n\\hline\r\nf(n) &amp; c &amp; f_c^{\\ast}(n) \\\\\r\n\\hline\r\nn-1 &amp; 0 &amp; \\Theta(n)\\\\\r\n\\hline\r\n\\lg n &amp; 1 &amp; \\Theta(\\lg^{\\ast} n)\\\\\r\n\\hline\r\nn/2 &amp; 1 &amp; \\Theta(\\lg n) \\\\\r\n\\hline\r\nn/2 &amp; 2 &amp; \\Theta(\\lg n)\\\\\r\n\\hline\r\n\\sqrt{n} &amp; 2 &amp;\\Theta(\\lg \\lg n)\\\\\r\n\\hline\r\n\\sqrt{n} &amp; 1 &amp;\\texttt{undefined} \\\\\r\n\\hline\r\nn^{1/3} &amp; 2 &amp;\\Theta(\\lg \\lg n)\\\\\r\n\\hline\r\n\\end{array}\\]\r\n对于问题e，根据迭代式子的定义，找到一个最小的\\(i\\)，使得以下式子成立：\r\n\\[n^{\\frac{1}{2^i}}\\le 2\\]\r\n两边取对\\(n\\)对数，得到\\(\\dfrac{1}{2^i}\\le \\log_n 2\\)，也就是\\(2^i\\ge \\lg n\\)。两边再对\\(2\\)取对数，得到：\r\n\\[i\\ge \\lg\\lg n\\]\r\n这个答案和问题g同理。\r\n至于问题f，对于大于\\(1\\)的数，无论做多少次取根号迭代都无法小于等于\\(1\\)，因此无法取值。\r\n","categories":["算法导论"]},{"title":"算法导论29.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-29/exercises-1/","content":"\r\n29.1-1\r\n\\((0,7),(1,6),(2,5)\\)分别是这个线性规划的\\(3\\)个可行解，其目标函数值分别为\\(21,16,11\\)。\r\n29.1-2\r\n\\((7,3,0),(7,4,0),(7,5,0)\\)分别是这个线性规划的\\(3\\)个可行解，其目标函数值分别为\\(35,42,49\\)。\r\n29.1-3\r\n对第二条约束变形后，得到\\(x_1+x_2\\ge\r\n5\\)，这和第一条约束\\(x_1+x_2\\le\r\n2\\)是明显冲突的。因此，这个线性规划是不可行的。\r\n29.1-4\r\n考虑令\\(x_1=2t,x_2=t\\)，那么目标函数为\\(t\\)。当\\(t\\ge\r\n0\\)时，第一条约束化成\\(-3t\\le\r\n-1\\)，第二条约束化成\\(-4t\\le\r\n-2\\)，其余约束化成\\(t\\ge\r\n0\\)。哪怕\\(t\\)趋向于正无穷，这些约束仍然是成立的。由于需要最大化目标值，那么目标值可以到达正无穷，因此这个线性规划是无界的。\r\n29.1-5\r\n构造出的线性规划问题如下：\r\n\\(\\begin{aligned}\r\n\\text{maximize}&amp;&amp; x_1+x_2\\\\\r\n\\text{subject to}&amp; \\\\\r\n&amp;&amp;x_1+2x_2&amp;\\le 4\\\\\r\n&amp;&amp;2x_1+x_2&amp;\\le 5\r\n\\end{aligned}\\)\r\n虽然可行解是无界的，但是最优解只有一个：\\((2,1)\\)，其目标值为\\(3\\)。\r\n29.1-6\r\na\r\n只需要将等式约束\\(\\displaystyle{\\sum_{j=1}^n\r\na_{ij}x_j=b_j}\\)替换成如下两个约束即可：\r\n\\(\\begin{aligned}\r\n\\sum_{j=1}^n a_{ij}x_j &amp;\\le b_i\\\\\r\n\\sum_{j=1}^n a_{ij}x_j &amp;\\ge b_i\r\n\\end{aligned}\\)\r\nb\r\n将不等式约束\\(\\displaystyle{\\sum_{j=1}^n\r\na_{ij}x_j\\le b_j}\\)替换成如下两个约束即可：\r\n\\(\\begin{aligned}\r\n\\sum_{j=1}^n a_{ij}x_j &amp;= b_i-s\\\\\r\ns&amp;\\ge 0\r\n\\end{aligned}\\)\r\n29.1-7\r\n如果当前是对某个目标函数\\(f(x)\\)最小化，那么其等价的最大化线性约束就是对目标函数\\(g(x)=-f(x)\\)最大化。\r\n令\\(S\\)是第一个线性规划的可行域，\\(x_0\\in S\\)是其一个最优解。这意味着\\(\\forall x\\in S\\)，都有\\(f(x)\\ge f(x_0)\\)。代入\\(g(x)=-f(x)\\)，那么有\\(f\\forall x \\in S\\)，均有\\(g(x)\\le\r\ng(x_0)\\)。因此，原线性规划和新线性规划是等价的。\r\n29.1-8\r\n还需要添加如下约束，以确保真实投票人数不会超过人口数：\r\n\\(\\begin{aligned}\r\n-2x_1+8x_2+0x_3+10x_4&amp;\\le 100\\\\\r\n5x_1+2x_2+0x_3+0x_4&amp;\\le 200\\\\\r\n3x_1-5x_2+10x_3-2x_4&amp;\\le 50\\\\\r\n\\end{aligned}\\)\r\n","categories":["算法导论"]},{"title":"算法导论29.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-29/exercises-3/","content":"\r\n29.3-1\r\n该线性规划的对偶线性规划为：\r\n\\(\\begin{aligned}\r\n\\text{maximize}&amp;&amp; 50y_1+100y_2+25y_3\\\\\r\n\\text{subject to}&amp; \\\\\r\n&amp;&amp;-2y_1+5y_2+3y_3&amp;\\le 1\\\\\r\n&amp;&amp;8y_1+2y_2-5y_3&amp;\\le 1\\\\\r\n&amp;&amp;0y_1+0y_2+10y_3&amp;\\le 1\\\\\r\n&amp;&amp;10y_1+0y_2-2y_3&amp;\\le 1\\\\\r\n&amp;&amp;y_1,y_2,y_3&amp;\\ge 0\r\n\\end{aligned}\\)\r\n29.3-2\r\n整个过程分成两个步骤进行：\r\n\r\n是将所有约束的比较符号的方向统一化。不失一般性，如果现在需要将除去非负约束以外的\\(\\ge\\)的约束转化成\\(\\le\\)的约束，那么只需要对原约束两侧乘上\\(-1\\)，并将比较符号反向即可。\r\n假设经第1个步骤处理后，原线性规划的目标函数为\\(\\mathbf{c}^T\\mathbf{x}\\)，并且朝某一个方向优化（最大/最小），约束是\\(\\mathbf{A}^T\\mathbf{x}\\circ\r\n\\mathbf{b}\\)，其中\\(\\circ\\in\\{\\le,\\ge\\}\\)。那么原线性规划的对偶线性规划的目标函数是\\(\\mathbf{b}^T\\mathbf{y}\\)，并且朝另一个方向优化（最小/最大），约束是\\(\\mathbf{A}^T\\mathbf{y}\\overline{\\circ}\r\n\\mathbf{c}\\)，即将统一前的比较符号均取反即可。\r\n\r\n29.3-3\r\n我们可以给出最大流问题线性规划的标准型为：\r\n\\(\\begin{aligned}\r\n\\text{maximize}&amp;&amp; \\sum_{(s,v)\\in E} f_{sv}-\\sum_{(v,s)\\in E}\r\nf_{vs}\\\\\r\n\\text{subject to}&amp; \\\\\r\n&amp;&amp;f_{uv}&amp;\\le c(u,v) &amp;&amp;\\forall (u,v)\\in E \\\\\r\n&amp;&amp;f_{uv}&amp;\\ge 0 &amp;&amp;\\forall (u,v)\\in E \\\\\r\n&amp;&amp;\\sum_{(u,v)\\in E} f_{uv}-\\sum_{(v,u)\\in E} f_{vu}&amp;\\le 0\r\n&amp;&amp;\\forall u\\in V-\\{s,t\\}\\\\\r\n&amp;&amp;\\sum_{(v,u)\\in E} f_{vu}-\\sum_{(u,v)\\in E} f_{uv}&amp;\\le 0\r\n&amp;&amp;\\forall u\\in V-\\{s,t\\}\r\n\\end{aligned}\\)\r\n可见，令左边的系数矩阵为\\(\\mathbf{A}\\)，其大小为\\((2|V|+2|E|-4)\\times |E|\\)，右边的\\(\\mathbf{b}\\)是一个\\(2|V|+2|E|-4\\)维的向量，其目标函数\\(\\mathbf{c}^T\\mathbf{x}\\)中的向量\\(\\mathbf{c}^T\\)长度为\\(|E|\\)。因此最大流问题的对偶线性规划为\r\n\\(\\begin{aligned}\r\n\\text{minimize}&amp;&amp; \\mathbf{b}^T\\mathbf{y}\\\\\r\n\\text{subject to}&amp; \\\\\r\n&amp;&amp;\\mathbf{A}^T\\mathbf{y}&amp;\\ge\\mathbf{c}\r\n\\end{aligned}\\)\r\n29.3-4\r\n我们可以给出最小费用流问题线性规划的统一符号方向后的结果为：\r\n\\(\\begin{aligned}\r\n\\text{minimize}&amp;&amp; \\sum_{(u,v)\\in E} a(u,v)\\cdot f_{uv}\\\\\r\n\\text{subject to}&amp; \\\\\r\n&amp;&amp;f_{uv}&amp;\\le c(u,v) &amp;&amp;\\forall (u,v)\\in E \\\\\r\n&amp;&amp;f_{uv}&amp;\\ge 0 &amp;&amp;\\forall (u,v)\\in E \\\\\r\n&amp;&amp;\\sum_{(u,v)\\in E} f_{uv}-\\sum_{(v,u)\\in E} f_{vu}&amp;\\le 0\r\n&amp;&amp;\\forall u\\in V-\\{s,t\\}\\\\\r\n&amp;&amp;\\sum_{(v,u)\\in E} f_{vu}-\\sum_{(u,v)\\in E} f_{uv}&amp;\\le 0\r\n&amp;&amp;\\forall u\\in V-\\{s,t\\}\\\\\r\n&amp;&amp;\\sum_{(s,v)\\in E} f_{sv}-\\sum_{(v,s)\\in E} f_{vs}&amp;\\le d\\\\\r\n&amp;&amp;\\sum_{(v,s)\\in E} f_{vs}-\\sum_{(s,v)\\in E} f_{sv}&amp;\\le -d\r\n\\end{aligned}\\)\r\n可见，令左边的系数矩阵为\\(\\mathbf{A}\\)，其大小为\\((2|V|+2|E|-2)\\times |E|\\)，右边的\\(\\mathbf{b}\\)是一个\\(2|V|+2|E|-2\\)维的向量，其目标函数\\(\\mathbf{c}^T\\mathbf{x}\\)中的向量\\(\\mathbf{c}^T\\)长度为\\(|E|\\)。因此最小费用流问题的对偶线性规划为\r\n\\(\\begin{aligned}\r\n\\text{maximize}&amp;&amp; \\mathbf{b}^T\\mathbf{y}\\\\\r\n\\text{subject to}&amp; \\\\\r\n&amp;&amp;\\mathbf{A}^T\\mathbf{y}&amp;\\ge\\mathbf{c}\r\n\\end{aligned}\\)\r\n29.3-5\r\n不失一般性，这里仅考虑标准型的线性规划：\r\n\\(\\begin{aligned}\r\n\\text{maximize}&amp;&amp; \\mathbf{c}^T\\mathbf{x}\\\\\r\n\\text{subject to}&amp; \\\\\r\n&amp;&amp;\\mathbf{A}\\mathbf{x}&amp;\\le\\mathbf{b}\\\\\r\n&amp;&amp;\\mathbf{x}&amp;\\ge\\mathbf{0}\r\n\\end{aligned}\\)\r\n按照定义，其对偶线性规划为：\r\n\\(\\begin{aligned}\r\n\\text{minimize}&amp;&amp; \\mathbf{b}^T\\mathbf{y}\\\\\r\n\\text{subject to}&amp; \\\\\r\n&amp;&amp;\\mathbf{A}^T\\mathbf{y}&amp;\\ge\\mathbf{c}\\\\\r\n&amp;&amp;\\mathbf{y}&amp;\\ge\\mathbf{0}\r\n\\end{aligned}\\)\r\n该对偶线性规划的对偶线性规划为：\r\n\\(\\begin{aligned}\r\n\\text{maximize}&amp;&amp; \\mathbf{c}^T\\mathbf{x&#39;}\\\\\r\n\\text{subject to}&amp; \\\\\r\n&amp;&amp;\\mathbf{A}\\mathbf{x&#39;}&amp;\\le\\mathbf{b}\\\\\r\n&amp;&amp;\\mathbf{x&#39;}&amp;\\ge\\mathbf{0}\r\n\\end{aligned}\\)\r\n可见，第一个线性规划和第三个线性规划的形式是完全一致的，因此一个线性规划对偶的对偶是它本身。\r\n29.3-6\r\n最大流问题中，推论24.5最大流的值的上界被最小割值限制着，这可以被解释成最大流问题的弱对偶。\r\n29.3-7\r\n本题以分类讨论为主。\r\n对于原线性规划：\r\n\r\n当\\(r&gt;0,s&lt;0\\)时，原线性规划的可行域是\\(\\varnothing\\)，因此它不可行。\r\n当\\(r&gt;0,s\\ge\r\n0\\)时，原线性规划的可行域是\\(0\\le x\\le\r\ns/r\\)。此时目标值必定是有限的。\r\n当\\(r=0,s&lt;0\\)时，原线性规划的可行域是\\(\\varnothing\\)，因此它不可行。\r\n当\\(r=0,s\\ge\r\n0\\)时，原线性规划的可行域是\\(x\\ge\r\n0\\)。如果\\(t\\le0\\)，那么其目标值有限，否则是无界的。\r\n当\\(r&lt;0,s&lt;0\\)时，原线性规划的可行域是\\(x\\ge s/r\\)。如果\\(t\\le0\\)，那么其目标值有限，否则是无界的。\r\n当\\(r&lt;0,s\\ge\r\n0\\)时，原线性规划的可行域是\\(x\\ge\r\n0\\)。如果\\(t\\le0\\)，那么其目标值有限，否则是无界的。\r\n\r\n可见这个线性规划的对偶线性规划是：\r\n\\(\\begin{aligned}\r\n\\text{minimize}&amp;&amp; sy\\\\\r\n\\text{subject to}&amp; \\\\\r\n&amp;&amp;ry&amp;\\ge t\\\\\r\n&amp;&amp;y&amp;\\ge0\r\n\\end{aligned}\\)\r\n\r\n当\\(r&gt;0,t\\le\r\n0\\)时，对偶线性规划的可行域是\\(y\\ge\r\n0\\)。如果\\(s\\ge\r\n0\\)，那么其目标值有限，否则是无界的。\r\n当\\(r&gt;0,t&gt;0\\)时，对偶线性规划的可行域是\\(y\\ge t/r\\)。如果\\(s\\ge\r\n0\\)，那么其目标值有限，否则是无界的。\r\n当\\(r=0,t\\le\r\n0\\)时，对偶线性规划的可行域是\\(y\\ge\r\n0\\)。如果\\(s\\ge\r\n0\\)，那么其目标值有限，否则是无界的。\r\n当\\(r=0,t&gt;\r\n0\\)时，对偶线性规划的可行域是\\(\\varnothing\\)，因此它不可行。\r\n当\\(r&lt;0,t\\le\r\n0\\)时，对偶线性规划的可行域是\\(0\\le\r\nx\\le t/r\\)。此时目标值必定是有限的。\r\n当\\(r&lt;0,t&gt;\r\n0\\)时，对偶线性规划的可行域是\\(\\varnothing\\)，因此它不可行。\r\n\r\n综上所述：\r\n\r\n当\\((r=0\\land s\\ge 0\\land t\\le\r\n0)\\lor(r&gt;0\\land r&gt;0\\land s\\ge 0)\\lor(r&lt;0\\land t\\le\r\n0)\\)为真时，满足第一个断言。\r\n当\\((r=0\\land s\\ge 0\\land t&gt;\r\n0)\\lor(r&lt;0\\land t&gt; 0)\\)为真时，满足第二个断言。\r\n当\\((r=0\\land s&lt; 0\\land t\\le\r\n0)\\lor(r&gt;0\\land s&lt; 0)\\)为真时，满足第三个断言。\r\n当\\(r=0\\land s&lt; 0\\land t&gt;\r\n0\\)为真时，满足第四个断言。\r\n\r\n29.3-8\r\n如果一个线性规划无解，即不存在一个向量\\(\\mathbf{x}\\)满足各个约束，那么说明这个标准线性规划是不可行的。\r\n否则，必定存在一系列可行解，使得多个向量\\(\\mathbf{x}\\)满足这些约束。如果这个线性规划没有有限的最优目标值，那么说明这个可行域必定是无界的。否则按照最优性（即要么最大，要么最小），有一个有限目标值的最优解。\r\n","categories":["算法导论"]},{"title":"算法导论28.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-28/exercises-3/","content":"\r\n28.3-1\r\n构造\\(n\\)维单位向量\\(e_i=(0,0,\\dots,1,0,\\dots,0)\\)，即\\(e_i\\)的第\\(i\\)个值为\\(1\\)，其余值为\\(0\\)。可见\\(e_i\\)是一个非零向量。那么可以得到\\(e_i^TAe_i=a_{ii}\\)。由于\\(A\\)是一个正定矩阵，\\(e_i\\)是一个非零向量，因此\\(a_{ii}&gt;0\\)。\r\n故一个正定矩阵中，对角线的元素都是正数。\r\n28.3-2\r\n令\\(x=(y,z)^T\\)是一个二维向量，那么考虑求\\(x^TAx\\)的值，有\r\n\\(\\begin{aligned}\r\nx^TAx&amp;=(y,z)\\begin{bmatrix}a&amp;b\\\\b&amp;c\\end{bmatrix}\\begin{bmatrix}y\\\\z\\end{bmatrix}\\\\\r\n&amp;=(y,z)\\begin{bmatrix}ay+bz\\\\by+cz\\end{bmatrix}\\\\\r\n&amp;=ay^2+2byz+cz^2\\\\\r\n\\end{aligned}\\)\r\n类似的，构造\\(y=-bz/a\\)，那么有\\(x^TAx=-b^2z^2/a+cz^2=z^2(c-b^2/a)=z^2(ca-b^2)/a\\)。\r\n当\\(z\\neq 0\\)时，\\(x\\)是一个非零向量。由于\\(a\\)是对角线上的元素，按照题目28.3-1的结论，有\\(a&gt;0\\)。由于\\(A\\)是对称正定的，由此推出\\(ca-b^2&gt;0\\)。\r\n28.3-3\r\n使用反证法证明。假设这个最大元素出现在矩阵\\(A\\)的位置\\(a_{ij}\\)中，由于\\(A\\)是对称的，因此有\\(a_{ij}=a_{ji}\\)。构造向量\\(x=e_i-e_j\\)，其中\\(e_i\\)表示第\\(i\\)个位置为\\(1\\)的单位向量。考虑计算\\(x^TAx\\)的值，有\\(x^TAx=a_{ii}-a_{ij}-a_{ji}+a_{jj}=a_{ii}+a_{jj}-2a_{ij}\\le\r\n0\\)。非\\(0\\)向量\\(x\\)的存在说明了矩阵\\(A\\)不是正定矩阵。\r\n因此，元素的最大值一定出现在正定矩阵的主对角线中。\r\n28.3-4\r\n假设\\(A\\)中的某个主子矩阵是从\\(A\\)的第\\(i_1,i_2,\\dots,i_k\\)行和列构成的，令\\(J=\\{i_1,i_2,\\dots,i_k\\}\\)。\r\n由于\\(A\\)是正定矩阵，因此对于满足如下条件\\(x\\)的向量，都有\\(f(\\mathbf{x})=\\mathbf{x}^TA\\mathbf{x}&gt;0\\)：\r\n\r\n如果\\(i\\not\\in J\\)，那么\\(\\mathbf{x}_i=0\\)；否则，\\(\\mathbf{x}_i\\)可以取任意值。\r\n\\(\\mathbf{x}\\)是非\\(0\\)向量。\r\n\r\n针对这种形式的\\(\\mathbf{x}\\)向量，可以将二次型\\(f(\\mathbf{x})\\)化简成：\r\n\\[f(\\mathbf{x})=\\sum_{i\\in J}\\sum_{j\\in J}\r\na_{ij}x_ix_j\\]\r\n由于这个二次型只有\\(x_{i_1},x_{i_2},\\dots,x_{i_k}\\)这些变量，因此可以重新构建出一个从\\(A\\)的第\\(i_1,i_2,\\dots,i_k\\)行和列构成的主子矩阵\\(A&#39;\\)。\r\n由于\\(f(\\mathbf{x})&gt;0\\)对于任意非\\(0\\)向量\\((\\mathbf{x}_{i_1},\\mathbf{x}_{i_2},\\dots,\\mathbf{x}_{i_k})\\)均成立，因此\\(A&#39;\\)是一个正定矩阵。\r\n28.3-5\r\nLU分解并不会做出任何行变换，因此LU分解的每一轮的主元都是矩阵左上角的函数。\r\n在LU分解一开始时，有\\(\\det\r\nA_1=a_{11}\\)，并且主元为\\(a_{11}\\)，因此当\\(k=1\\)时，有\\(\\dfrac{\\det A_1}{\\det\r\nA_{0}}=a_{11}\\)，因为题目假定了\\(\\det\r\nA_0=1\\)。\r\n由于LU分解的过程是对矩阵\\(A\\)进行高斯消元，即对\\(A\\)进行行变换；此外，由于高斯消元的过程只对下面的行进行消元；而不会使用下面的行对上面的行进行行变换操作，因此顺序主子式\\(A_1,A_2,\\dots,A_n\\)的行列式都不会改变。到了选取第\\(k\\)个主元时\\(a_{kk}&#39;\\)，第\\(k\\)行在\\(a_{kk}\\)左边的元素都已经变成了\\(0\\)，因此有\\(\\det\r\nA_k=a_{kk}&#39;\\cdot \\det A_{k-1}\\)，即第\\(k\\)个主元的值为\\(\\dfrac{\\det A_k}{\\det\r\nA_{k-1}}\\)。原结论成立。\r\n28.3-6\r\n通过这些数据点和\\(F\\)形式的函数，可以写出\\(A\\)为：\r\n\\(A=\\begin{bmatrix}\r\n1 &amp; 0 &amp; e\\\\\r\n1 &amp; 2 &amp; e^2\\\\\r\n1 &amp;3\\lg 3 &amp; e^3\\\\\r\n1 &amp; 8 &amp; e^4\r\n\\end{bmatrix}\\)\r\n通过如下Python代码，可以求出\\(A^{+}\\)和\\(\\mathbf{c}\\)的结果大约为：\r\nimport numpy as npfrom math import log2, eA = np.array([[1, 0, e], [1, 2, e ** 2], [1, 3 * log2(3), e ** 3], [1, 8, e ** 4]])y = np.array([[1, 1, 3, 8]]).transpose()AT = A.transpose()mA = AT @ AAp = np.linalg.inv(mA) @ ATprint(Ap)print(Ap @ y)\r\n\\(\\begin{aligned}\r\nA^+&amp;\\approx\\begin{bmatrix}\r\n0.73633742 &amp;  0.36355436&amp; -0.02219508 &amp; -0.0776967\\\\\r\n-0.36756766&amp;  0.0944919 &amp;  0.4232796  &amp; -0.15020383\\\\\r\n0.04101932&amp; -0.02179989 &amp; -0.06081614 &amp; 0.04159671\r\n\\end{bmatrix}\\\\\r\nC&amp;\\approx (0.41173294,-0.20486764,0.16954468)^T\r\n\\end{aligned}\\)\r\n28.3-7\r\n这\\(4\\)个等式的证明过程如下：\r\n\\(\\begin{aligned}\r\nAA^{+}A&amp;=A((A^TA)^{-1} A^T)A\\\\\r\n&amp;=A(A^TA)^{-1}(A^TA)\\\\\r\n&amp;=A\\\\\r\n\\\\\r\nA^{+}AA^{+}&amp;=((A^TA)^{-1} A^T)AA^+\\\\\r\n&amp;=(A^TA)^{-1} (A^TA)A^+\\\\\r\n&amp;=A^+\\\\\r\n\\\\\r\n(AA^+)^T&amp;=(A((A^TA)^{-1} A^T))^T\\\\\r\n&amp;=(A(A^TA)^{-1} A^T)^T\\\\\r\n&amp;=(A^T)^T((A^TA)^{-1})^T A^T\\\\\r\n&amp;=A((A^TA)^T)^{-1}A^T\\\\\r\n&amp;=A(A^T(A^T)^T)^{-1}A^T\\\\\r\n&amp;=A(A^TA)^{-1}A^T\\\\\r\n&amp;=A((A^TA)^{-1}A^T)\\\\\r\n&amp;=AA^+\\\\\r\n\\\\\r\n(A^+A)^T&amp;=(((A^TA)^{-1} A^T)A)^T\\\\\r\n&amp;=((A^TA)^{-1} (A^TA))^T\\\\\r\n&amp;=I^T\\\\\r\n&amp;=I\\\\\r\n&amp;=(A^TA)^{-1}(A^TA)\\\\\r\n&amp;=((A^TA)^{-1}A^T)A\\\\\r\n&amp;=A^+A\r\n\\end{aligned}\\)\r\n","categories":["算法导论"]},{"title":"算法导论29 Problems 答案","url":"/introduction-to-algorithms/chapter-29/problems/","content":"\r\n29-1\r\na\r\n假设现在存在一个标准型线性规划的算法LP-SOLVER-A(A, b, c)（其中\\(\\mathbf{A,b}\\)表示约束，\\(\\mathbf{c}\\)表示目标函数对应的向量，最大化\\(\\mathbf{c}^T\\mathbf{x}\\)的值），那么按照定理29.5，这个算法无非就返回\\(3\\)种结果：\r\n\r\n一个达到最优目标值的向量\\(\\mathbf{x}\\)。\r\n\"unbounded\"，即无界。\r\n\"infeasible\"，即这个约束不可行。\r\n\r\n那么线性不等式可行性问题检测算法LINEAR-INEQUALITY-FEASIBILITY用于检测标准型线性不等式可行性，只需要调用LP-SOLVER-A作为子程序即可。更具体的过程如下给出：\r\nLINEAR-INEQUALITY-FEASIBILITY(A, b, m, n):  let c[1 : n] be a new array  sol = LP-SOLVE-A(A, b, c)  if sol != &quot;infeasible&quot;    return sol  return NIL\r\n这个过程用到的变量和约束的个数分是\\(n,m\\)，即它们本身。\r\nb\r\n如果一个标准型线性规划\\(L\\)存在一个有限最优解（最大值），那么其对偶问题也存在一个有限最优解（最小值）。如果我们令这个最大值和最小值相等，再交由LINEAR-INEQUALITY-FEASIBILITY-A求出一个可行解即可。\r\n更具体地说，线性规划\\(L\\)可行当且仅当下面关于\\(\\mathbf{x,y}\\)的线性不等式是否可行：\r\n\\(\\begin{aligned}\r\n\\mathbf{A}\\mathbf{x}&amp;\\le\\mathbf{b}\\\\\r\n\\mathbf{A}^T\\mathbf{y}&amp;\\ge\\mathbf{c}\\\\\r\n\\mathbf{c}^T\\mathbf{x}&amp;=\\mathbf{b}^T\\mathbf{y}\\\\\r\n\\mathbf{x}&amp;\\ge 0\\\\\r\n\\mathbf{y}&amp;\\ge 0\\\\\r\n\\end{aligned}\\)\r\n如果\\(L\\)是无界的，那么上面的线性不等式同样是不可行的。因此，我们下一步只需要判断\\(L\\)是否为可行，从而区分出无界和不可行这两种情况。只需要进行两次判断以区分这\\(3\\)种情况即可。更具体的情况由LP-SOLVE给出，假定LINEAR-INEQUALITY-FEASIBILITY-A是用于求解标准型线性不等式可行性的算法。最终求解线性规划算法由LP-SOLVE给出。\r\n将上面的线性\r\nLP-SOLVE(A, b, c, m, n)  sol1 = LINEAR-INEQUALITY-FEASIBILITY-A(A, b, m, n)  if sol1 == NIL    return &quot;infeasible&quot;  let A&#x27;[2 * n + 2 * m + 2, n + m] be a new table by 0  let b&#x27;[2 * n + 2 * m + 2] be a new array by 0  for i = 1 to m    for j = 1 to n      A&#x27;[i, j] = A[i, j]      A&#x27;[m + j][n + i] = A[i, j]  for i = 1 to m    A[m + n + 1][n + i] = -b[i]    A[m + n + 2][n + i] = b[i]  for j = 1 to n    A[m + n + 1][j] = c[j]    A[m + n + 2][j] = -c[j]  for k = 1 to m + n    A[m + n + 2 + k][k] = -1  for i = 1 to m    b&#x27;[i] = b[i]  for j = 1 to n    b&#x27;[m + i] = c[j]  sol2 = LINEAR-INEQUALITY-FEASIBILITY-A(A, b, 2 * n + 2 * m + 2, n + m)  if sol2 == NIL    return &quot;unbounded&quot;  else    return sol2\r\n对上面的线性不等式标准化后，将会有\\(2n+2m+2\\)条不等式，\\(n+m\\)个变量，它们仍然是\\(n\\)和\\(m\\)的多项式。\r\n29-2\r\na\r\n该线性规划\\(L\\)给出的最优可行解为\\(\\mathbf{x}^{\\ast}=(x_1,x_2,x_3)=(8,4,0)\\)，对于其对偶线性规划，其最优可行解为\\(\\mathbf{y}^{\\ast}=(y_1,y_2,y_3)=(0,1/6,2/3)\\)。令\\(\\mathbf{A}\\)表示原约束的系数矩阵，可以知道，\\(\\mathbf{Ax}^{\\ast}=(12,24,36)^T,\\mathbf{A}^T\\mathbf{y}=(3,1,13/6)^T\\)。将\\(\\mathbf{A}^T\\mathbf{y^{\\ast}}\\)和\\(\\mathbf{x}^{\\ast}\\)以及\\(\\mathbf{Ax}\\)和\\(\\mathbf{y}^{\\ast}\\)相对比即可完成验证。\r\nb\r\n必要性：假设互补松驰性成立，那么有\\(\\displaystyle{\\sum_{j=1}^n\r\nc_j\\overline{x}_j=\\sum_{j=1}^n\\sum_{i=1}^m\r\na_{ij}\\overline{y}_i\\overline{x}_j}\\)。原因在于，考虑每个\\(j\\in[1,n]\\)，如果\\(\\overline{x}_j=0\\)，那么\\(\\displaystyle{c_j\\overline{x}_j=0,\\overline{x}_j\\cdot\\sum_{i=1}^ma_{ij}\\overline{y}_i=0}\\)，等式\\(\\displaystyle{c_j\\overline{x}_j=\\sum_{i=1}^ma_{ij}\\overline{y}_i\\overline{x}_j}\\)成立；如果\\(\\overline{x}_j=0\\)不成立，那么按照互补松弛性，此时有\\(\\displaystyle{\\sum_{i=1}^ma_{ij}\\overline{y}_i=c_j}\\)，等式\\(\\displaystyle{c_j\\overline{x}_j=\\sum_{i=1}^ma_{ij}\\overline{y}_i\\overline{x}_j}\\)依旧成立。因此有\\(\\displaystyle{\\sum_{j=1}^n\r\nc_j\\overline{x}_j=\\sum_{j=1}^n\\sum_{i=1}^m\r\na_{ij}\\overline{y}_i\\overline{x}_j}\\)。\r\n可以用类似的方法证明\\(\\displaystyle{\\sum_{i=1}^m\r\nb_i\\overline{y}_i=\\sum_{i=1}^m\\sum_{j=1}^n\r\na_{ij}\\overline{x}_j\\overline{y}_i}\\)。考虑每个\\(i\\in[1,m]\\)，如果\\(\\overline{y}_i=0\\)，那么\\(\\displaystyle{b_i\\overline{y}_i=0,y_i\\cdot\\sum_{j=1}^n}a_{ij}\\overline{x}_j=0\\)，等式\\(\\displaystyle{b_i\\overline{y}_i=\\sum_{j=1}^n\r\na_{ij}\\overline{x}_j\\overline{y}_i}\\)成立。如果\\(\\overline{y}_i=0\\)不成立，那么按照互补松弛性，此时有\\(\\displaystyle{\\sum_{j=1}^n\r\na_{ij}\\overline{x}_j=b_i}\\)，等式\\(\\displaystyle{b_i\\overline{y}_i=\\sum_{j=1}^n\r\na_{ij}\\overline{x}_j\\overline{y}_i}\\)依旧成立。因此有\\(\\displaystyle{\\sum_{i=1}^m\r\nb_i\\overline{y}_i=\\sum_{i=1}^m\\sum_{j=1}^n\r\na_{ij}\\overline{x}_j\\overline{y}_i}\\)。\r\n由于\\(\\displaystyle{\\sum_{j=1}^n\\sum_{i=1}^m\r\na_{ij}\\overline{y}_i\\overline{x}_j=\\sum_{i=1}^m\\sum_{j=1}^n\r\na_{ij}\\overline{x}_j\\overline{y}}\\)，因此有\\(\\displaystyle{\\sum_{j=1}^n\r\nc_j\\overline{x}_j=\\sum_{i=1}^m b_i\\overline{y}_i}\\)，即\\(\\mathbf{c}^T\\overline{\\mathbf{x}}=\\mathbf{b}^T\\overline{\\mathbf{y}}\\)。\r\n按照定理29.4，\\(\\overline{\\mathbf{x}},\\overline{\\mathbf{y}}\\)分别是原线性规划和对偶线性规划的最优解，原结论成立。\r\n充分性：我们将使用反证法完成证明。假设现在\\(\\mathbf{x}^{\\ast},\\mathbf{y}^{\\ast}\\)分别是原线性规划和对偶线性规划的最优解。假设\\(\\exists i\\in[1,m]\\)满足\\(y_i^{\\ast}\\neq 0\\)，并且有\\(\\displaystyle{\\sum_{j=1}^n\r\na_{ij}x_j^{\\ast}&lt;b_i}\\)，使用必要性种类似的计算过程，可以得到：\r\n\\(\\begin{aligned}\r\n\\sum_{j=1}^n\r\nc_jx_j^{\\ast}&amp;=\\sum_{j=1}^n\\sum_{i=1}^ma_{ij}y_i^{\\ast}x_j^{\\ast}\\\\\r\n&amp;=\\sum_{i=1}^m\\sum_{j=1}^n a_{ij}x_j^{\\ast}y_i^{\\ast}\\\\\r\n&amp;&lt;\\sum_{i=1}^m\\sum_{j=1}^n b_iy_i^{\\ast}\\\\\r\n\\end{aligned}\\)\r\n按照定理29.4，\\(\\overline{\\mathbf{x}},\\overline{\\mathbf{y}}\\)必定不是原线性规划和对偶线性规划的最优解，因此原结论成立。\r\n对于另外一种情况的证明过程类似，假设\\(\\exists j\\in[1,n]\\)满足\\(x_j^{\\ast}\\neq 0\\)，并且有\\(\\displaystyle{\\sum_{i=1}^m\r\na_{ij}y_i^{\\ast}&gt;c_j}\\)，使用必要性种类似的计算过程，可以得到：\r\n\\(\\begin{aligned}\r\n\\sum_{j=1}^n\r\nc_jx_j^{\\ast}&amp;&lt;\\sum_{j=1}^n\\sum_{i=1}^ma_{ij}y_i^{\\ast}x_j^{\\ast}\\\\\r\n&amp;=\\sum_{i=1}^m\\sum_{j=1}^n a_{ij}x_j^{\\ast}y_i^{\\ast}\\\\\r\n&amp;=\\sum_{i=1}^m\\sum_{j=1}^n b_iy_i^{\\ast}\\\\\r\n\\end{aligned}\\)\r\n同样的，\\(\\overline{\\mathbf{x}},\\overline{\\mathbf{y}}\\)必定不是原线性规划和对偶线性规划的最优解，因此原结论成立。\r\n因此原结论成立。\r\nc\r\n本题使用29-2-b的结论即可直接证明。 充分性：由于\\(\\mathbf{x}^{\\ast}\\)是原线性规划的最优解，令\\(\\mathbf{y}^{\\ast}\\)是对偶线性规划的最优解，那么其必定满足条件1。按照题目29-2-b的结论，条件2和3都成立。由此充分性成立。\r\n必要性：条件1说明了\\(\\overline{\\mathbf{y}}\\)是对偶线性规划的一个可行解，根据题目29-2-b的结论，条件2和条件3说明了构造出来的可行解\\(\\overline{\\mathbf{x,y}}\\)都是各自线性规划的最优解。由此必要性成立。\r\n因此原结论成立。\r\n29-3\r\na\r\n证明过程和在线性规划时期，对引理29.1的证明过程完全相同。不失一般性，假设现在需要证明的整数规划是标准型。\r\n令\\(\\mathbf{x}\\)是原整数规划的一个可行解，\\(\\mathbf{y}\\)是对偶整数规划的一个可行解，那么有\r\n\\(\\begin{aligned}\r\n\\mathbf{c}^T\\overline{\\mathbf{x}}&amp;\\le\r\n(\\mathbf{A}^T\\overline{\\mathbf{y}})^T\\overline{\\mathbf{x}}\\\\\r\n&amp;=\\overline{\\mathbf{y}}^T\\mathbf{A}\\overline{\\mathbf{x}}\\\\\r\n&amp;\\le\\overline{\\mathbf{y}}^T\\mathbf{b}\r\n\\end{aligned}\\)\r\n因此原结论成立。\r\nb\r\n考虑如下单个变量\\(x\\)的标准型整数规划：\r\n\\(\\begin{aligned}\r\n\\text{maximize}&amp;&amp; x\\\\\r\n\\text{subject to}&amp; \\\\\r\n&amp;&amp;x&amp;\\le\\dfrac{1}{2}\\\\\r\n&amp;&amp;x&amp;\\ge 0\r\n\\end{aligned}\\)\r\n可以发现其最优可行解只有\\(x=0\\)，目标函数值为\\(0\\)。\r\n那么其对偶整数规划为：\r\n\\(\\begin{aligned}\r\n\\text{mimimize}&amp;&amp; \\dfrac{1}{2}y\\\\\r\n\\text{subject to}&amp; \\\\\r\n&amp;&amp;y&amp;\\ge 1\\\\\r\n&amp;&amp;y&amp;\\ge 0\r\n\\end{aligned}\\)\r\n可以发现其最优可行解为\\(y=1\\)，目标函数值为\\(\\dfrac{1}{2}\\)。\r\n由于它们的最优解不相同，因此整数规划不满足对偶性。\r\nc\r\n不失一般性，假设现在需要证明的整数规划是标准型。\r\n令\\(L_I\\)是一个标准型整数规划，\\(L\\)是\\(L_I\\)除去整数约束后所得到的线性规划，\\(L_I^D\\)是\\(L_I\\)的对偶整数规划，\\(L^D\\)是\\(L\\)的对偶线性规划。那么\\(P,D\\)分别是\\(L,L^D\\)的目标函数值。按照定理29.4，有\\(P=D\\)。\r\n由于\\(L_I\\)是\\(L\\)添加上了整数约束而来，因此\\(L_I\\)的可行域必定是\\(L\\)的可行域的子集。这意味着在\\(L\\)中的最优解必定不劣于\\(L_I\\)中的最优解，因此有\\(IP\\le P\\)；类似的，在\\(L^D\\)中的最优解必定不劣于\\(L^D_I\\)中的最优解，因此有\\(ID\\ge D\\)。\r\n最终有等式\\(IP\\le P=D\\le ID\\)。\r\n29-4\r\n这里的证明参考了这篇文章。\r\n首先列出原始Farkas引理：\r\nFarkas引理\r\n给定\\(M\\in\\mathbb{R}^{(m+1)\\times\r\nn},g\\in\\mathbb{R}^{m+1}\\)，如下两种陈述只有一种成立：\r\n\r\n\\(\\exists \\mathbf{v}\\in\r\n\\mathbb{R}^{n},\\mathbf{Mv=g},\\mathbf{v}\\ge \\mathbf{0}\\)\r\n\\(\\exists \\mathbf{w}\\in\r\n\\mathbb{R}^{m+1},\\mathbf{M}^T\\mathbf{w}\\ge\r\n\\mathbf{0},\\mathbf{g}^T\\mathbf{w}&lt;0\\)\r\n\r\n\r\n接下来证明题目中给定的变种Farkas引理。第一步则是使用反证法证明至多只有一个陈述成立。假设这两个陈述都成立，那么我们针对\\(\\mathbf{v,w}\\)的存在性，可以列出：\r\n\\(\\begin{aligned}\r\n\\mathbf{Mv}&amp;\\le \\mathbf{g}\\\\\r\n\\mathbf{w}^T\\mathbf{M}&amp;=\\mathbf{0}\\\\\r\n\\mathbf{w}^T\\mathbf{g}&amp;&lt;\\mathbf{0}\r\n\\end{aligned}\\)\r\n对第一条不等式左乘上一个恒非负的向量\\(\\mathbf{w^T}\\)，得到\\(\\mathbf{w}^T\\mathbf{Mv}\\le\r\n\\mathbf{w}^T\\mathbf{g}\\)，即得到\\(\\mathbf{w}^T\\mathbf{g}=\\mathbf{0}\\)，和第三条不等式矛盾，因此这两个陈述至多只有一个成立。\r\n接下来证明第2个陈述和如下第3个陈述是等价的：\r\n\r\n\\(\\exists \\mathbf{w}\\in\r\n\\mathbb{R}^{m+1}\\)，使得\\(\\mathbf{w}\\ge\r\n\\mathbf{0},\\mathbf{M}^T\\mathbf{w}=0,\\mathbf{w}^T\\mathbf{g}=-1\\)。\r\n\r\n必要性显然成立，因为\\(\\mathbf{w}^T\\mathbf{g}=-1&lt;0\\)，从而第2个陈述也是成立的。接下来证明充分性，令\\(\\mathbf{w&#39;}=-\\dfrac{1}{\\mathbf{w}^T\\mathbf{g}}\\cdot\r\nw\\)，那么由于\\(-\\dfrac{1}{\\mathbf{w}^T\\mathbf{g}}&lt;0\\)，因此\\(\\mathbf{w&#39;}\\ge 0\\)仍然成立；\\(\\mathbf{w&#39;}^T\\mathbf{g}=\\dfrac{1}{\\mathbf{w}^T\\mathbf{g}}\\cdot(\\mathbf{w}^T\\mathbf{g})=-1\\)；此外，\\(\\mathbf{w&#39;}^T\\mathbf{M}=-\\dfrac{1}{\\mathbf{w}^T\\mathbf{g}}\\cdot\r\n(\\mathbf{w}^T\\mathbf{M})=0\\)，最终\\(\\mathbf{w&#39;}\\)的存在说明充分性成立。由此，第2个陈述和第3个陈述等价。\r\n假设现在第2个陈述不成立，那么第3个陈述也不成立。那么可以将\\(\\mathbf{M}^T\\mathbf{w}=\\mathbf{0},\\mathbf{g}^T\\mathbf{w}=-1\\)重写成\\(\\mathbf{A}=(\\mathbf{M},\\mathbf{g})^T,\\mathbf{b}=(0,0,\\dots,0,-1)^T\\)。\r\n由于第3个陈述不成立，这意味着\\(\\nexists\r\n\\mathbf{x}\\in\\mathbb{R}^{m+1},\\mathbf{x}\\ge 0\\)使得\\(\\mathbf{Ax=b}\\)。也就是说，这时不满足原始Farkas引理的第1个陈述，那么这意味着原始Farkas引理第2个陈述必须成立，因此通过这条陈述，给出了\\(\\exists\r\n\\mathbf{y}\\in\\mathbb{R}^{n+1},\\mathbf{A}^T\\mathbf{y}\\ge\r\n0,\\mathbf{b}^T\\mathbf{y}&lt;0\\)。\r\n令\\(\\mathbf{y}=\\begin{pmatrix}\\mathbf{z}\\\\\\lambda\\end{pmatrix}\\)，其中\\(\\mathbf{z}\\in \\mathbb{R}^n,\\lambda\\in\r\n\\mathbb{R}\\)。由于\\(\\mathbf{b}^T\\)前\\(n\\)个分量都是\\(0\\)，因此\\(\\mathbf{b}^T\\mathbf{y}=-\\lambda&lt;0\\)，因此得到\\(\\lambda&gt;0\\)。\\(\\mathbf{A}^T\\mathbf{y}\\ge 0\\)意味着\\(\\begin{pmatrix}\\mathbf{M}&amp;\\mathbf{g}\\end{pmatrix}\\begin{pmatrix}\\mathbf{z}\\\\\\lambda\\end{pmatrix}\\ge\r\n0\\)，这给出了\\(\\mathbf{Mz}+\\lambda\r\n\\mathbf{g}\\ge 0\\)，即\\(\\mathbf{M}(-\\mathbf{z}/\\lambda)\\le\r\ng\\)。向量\\((-\\mathbf{z}/\\lambda)\\)的存在证明了变种Farkas引理的第1条陈述是正确的，因此原结论成立。\r\n29-5\r\na\r\n由于删除了一些约束，因此这个问题的线性规划可以从最小费用流问题转化而来：\r\n\\(\\begin{aligned}\r\n\\text{minimize}&amp;&amp; \\sum_{(u,v)\\in E}a(u,v)\\cdot f_{uv}\\\\\r\n\\text{subject to}&amp; \\\\\r\n&amp;&amp;f_{uv}&amp;\\le c(u,v) &amp;&amp;\\forall (u,v)\\in E \\\\\r\n&amp;&amp;f_{uv}&amp;\\ge 0 &amp;&amp;\\forall (u,v)\\in E \\\\\r\n&amp;&amp;\\sum_{(u,v)\\in E} f_{uv}&amp;=\\sum_{(v,u)\\in E} f_{vu}\r\n&amp;&amp;\\forall u\\in V\r\n\\end{aligned}\\)\r\nb\r\n由于花费函数\\(a(u,v)&gt;0\\)，并且线性规划的目标函数是最小化费用。因此线性规划的最优方案将是：不使用任何边进行流动，那么这样将不会产生任何花费。因此，这个流是的大小为\\(0\\)。\r\nc\r\n不失一般性，我们可以删除\\(E\\)中\\((t,s)\\)的边，这不会减少最大流的值。\r\n我们构造图\\(G&#39;=(V&#39;,E&#39;)\\)，其中\\(V&#39;=V,E&#39;=E\\cup\\{(t,s)\\}\\)。令\\(a(t,s)=-1,c(t,s)=+\\infty\\)，对于\\(\\forall(u,v)\\in E\\)，都有\\(a(u,v)=0,c(u,v)\\)为原最大流问题中，有向边\\((u,v)\\)的容量。考虑新构造后的图\\(G&#39;\\)，以及对应的容量函数\\(c\\)和费用函数\\(a\\)，那么最大流问题就相当于解决如此一个最小费用流通问题。\r\n在\\(G&#39;\\)中，如果一个“流”从\\(t\\)流动到\\(s\\)，那么将会有一个真正的流从\\(s\\)流动到\\(t\\)。并且由于\\(a(t,s)=-1\\)，因此线性规划算法将会“激励”尽量多的流产生，并且产生一个真正的流并不会添加任何代价。由于\\(c(t,s)=+\\infty\\)，因此这将不会限制从\\(s\\)到\\(t\\)的流产生。\r\n最终，舍去变量\\(f_{ts}\\)的值（或者是让其值为\\(0\\)），那么计算出的一组解\\(f\\)为原图\\(G\\)上的最大流。\r\nd\r\n令\\(\\displaystyle{A=1+\\sum_{(u,v)\\in\r\nE}a(u,v)}\\)，其中\\(a(u,v)\\)是从\\(u\\)到\\(v\\)的距离。也就是说，\\(M\\)是一个足够大的数，但并非是无穷大。\r\n同样的，不失一般性，我们可以删除\\(E\\)中\\(s\\)的所有入边，这不会增加从\\(s\\)到任意节点的最短路径。\r\n可以构造图\\(G&#39;=(V&#39;,E&#39;)\\)，其中\\(V&#39;=V,E&#39;=E\\cup\\{(v,s):v\\in\r\nV-\\{s\\}\\}\\)。\\(\\forall (v,s)\\in\r\nE&#39;\\)，令\\(c(v,s)=1,a(v,s)=-A\\)。\\(\\forall (u,v)\\in\r\nE,c(u,v)=+\\infty,a(u,v)\\)为原最短路问题中，从\\(u\\)到\\(v\\)的距离边权。考虑新构造后的图\\(G&#39;\\)，以及对应的容量函数\\(c\\)和费用函数\\(a\\)，那么最短路问题就相当于解决如此一个最小费用流通问题。\r\n在\\(G&#39;\\)中，任意一条简单路径的长度都小于\\(A\\)。因此在一个最小费用流通问题中，使用边\\((v,s)\\in\r\nE&#39;\\)一定是更优的。对于任意\\(v\\in\r\nV-\\{s\\}\\)，这意味着必定有一个流从\\(s\\)到达\\(v\\)，并且这个流的费用是最小的，这时从\\(s\\)到\\(v\\)的这个流恰好就对应了原问题的最短路径。\r\n最终，舍去所有变量\\(f_{vs}(s\\in\r\nV-\\{s\\})\\)（或者是让其值为\\(0\\)）。对于任意节点\\(v\\in V-\\{s\\}\\)，求出从\\(s\\)到\\(v\\)的最短路径，需要从\\(v\\)开始，逐渐向前移动，找到这个流的起点即可。最终处理出来的流就是对应最短路径。\r\n","categories":["算法导论"]},{"title":"算法导论29.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-29/exercises-2/","content":"\r\n29.2-1\r\n这个最短路问题的对应线性规划问题如下：\r\n\\(\\begin{aligned}\r\n\\text{maximize}&amp;&amp; d_x\\\\\r\n\\text{subject to}&amp; \\\\\r\n&amp;&amp;d_t&amp;\\le d_s+3\\\\\r\n&amp;&amp;d_y&amp;\\le d_s+5\\\\\r\n&amp;&amp;d_x&amp;\\le d_t+6\\\\\r\n&amp;&amp;d_y&amp;\\le d_t+2\\\\\r\n&amp;&amp;d_z&amp;\\le d_x+2\\\\\r\n&amp;&amp;d_t&amp;\\le d_y+1\\\\\r\n&amp;&amp;d_x&amp;\\le d_y+4\\\\\r\n&amp;&amp;d_z&amp;\\le d_y+6\\\\\r\n&amp;&amp;d_s&amp;\\le d_z+3\\\\\r\n&amp;&amp;d_x&amp;\\le d_z+7\\\\\r\n&amp;&amp;d_s&amp;=0\r\n\\end{aligned}\\)\r\n29.2-2\r\n这和第29.2章介绍的线性规划系统类似，如下给出：\r\n\\(\\begin{aligned}\r\n\\text{maximize}&amp;&amp; \\sum_{v\\in V} d_v\\\\\r\n\\text{subject to}&amp; \\\\\r\n&amp;&amp;d_v&amp;\\le d_u+w(u,v) &amp;&amp;\\forall (u,v)\\in E \\\\\r\n&amp;&amp;d_s&amp;=0\r\n\\end{aligned}\\)\r\n两条约束和29.2所给出的约束相同，区别在于目标函数。由于目前是希望最大化所有变量\\(d_v\\)，但是最短路径的松弛性质仍然保持，因此这时的最优解对应了\\(s\\)到所有节点的最短路径长度。\r\n29.2-3\r\n这个最大流问题的对应线性规划问题如下：\r\n\\(\\begin{aligned}\r\n\\text{maximize}&amp;&amp; f_{sv_1}+f_{sv_2}\\\\\r\n\\text{subject to}&amp; \\\\\r\n&amp;&amp;f_{uv}&amp;\\ge 0 &amp;&amp;\\forall (u,v)\\in E \\\\\r\n&amp;&amp;f_{sv_1}&amp;\\le 16\\\\\r\n&amp;&amp;f_{sv_2}&amp;\\le 14\\\\\r\n&amp;&amp;f_{v_1v_3}&amp;\\le 12\\\\\r\n&amp;&amp;f_{v_2v_1}&amp;\\le 4\\\\\r\n&amp;&amp;f_{v_2v_4}&amp;\\le 14\\\\\r\n&amp;&amp;f_{v_3v_2}&amp;\\le 9\\\\\r\n&amp;&amp;f_{v_3v_t}&amp;\\le 20\\\\\r\n&amp;&amp;f_{v_4v_3}&amp;\\le 7\\\\\r\n&amp;&amp;f_{v_4t}&amp;\\le 4\\\\\r\n&amp;&amp;f_{sv_1}+f_{v_2v_1}&amp;= f_{v_1v_3}\\\\\r\n&amp;&amp;f_{sv_2}+f_{v_3v_2}&amp;= f_{v_2v_1}+f_{v_2v_4}\\\\\r\n&amp;&amp;f_{v_1v_3}+f_{v_4v_3}&amp;= f_{v_3v_2}+f_{v_3t}\\\\\r\n&amp;&amp;f_{v_2v_4}&amp;= f_{v_4v_3}+f_{v_4t}\\\\\r\n\\end{aligned}\\)\r\n29.2-4\r\n这里使用题目24.1-4的结果：\r\n\\(\\begin{aligned}\r\n\\text{maximize}&amp;&amp; \\sum_{(s,v)\\in E} f_{sv}-\\sum_{(v,s)\\in E}\r\nf_{vs}\\\\\r\n\\text{subject to}&amp; \\\\\r\n&amp;&amp;f_{uv}&amp;\\ge 0 &amp;&amp;\\forall (u,v)\\in E \\\\\r\n&amp;&amp;f_{uv}&amp;\\le c(u,v) &amp;&amp;\\forall (u,v)\\in E \\\\\r\n&amp;&amp;\\sum_{(u,v)\\in E} f_{uv}&amp;=\\sum_{(v,u)\\in E} f_{vu}\r\n&amp;&amp;\\forall u\\in V-\\{s,t\\}\r\n\\end{aligned}\\)\r\n可见，这里一共有\\(2|E|+|V|-2=O(V+E)\\)条约束。\r\n29.2-5\r\n令二分图\\(G=(V,E),V=L\\cup\r\nR\\)。使用第24.3章的结论，我们可以将这个问题转化成最大流问题进行解答：令\\(V&#39;=V\\cup\\{s,t\\},E&#39;=\\{(s,l):l\\in\r\nL\\}\\cup\\{(r,t):r\\in R\\}\\cup E\\)，对于\\(\\forall (u,v)\\in E&#39;\\)，都有\\(c(u,v)=1\\)。那么图\\(G\\)的二分图最大匹配数量相当于是图\\(G&#39;=(V&#39;,E&#39;)\\)中从\\(s\\)到\\(t\\)的最大流。这个线性规划将使用题目29.2-4的结论，如下：\r\n\\(\\begin{aligned}\r\n\\text{maximize}&amp;&amp; \\sum_{l\\in L}f_{sl} \\\\\r\n\\text{subject to}&amp; \\\\\r\n&amp;&amp;f_{uv}&amp;\\ge 0 &amp;&amp;\\forall (u,v)\\in E&#39; \\\\\r\n&amp;&amp;f_{uv}&amp;\\le c(u,v) &amp;&amp;\\forall (u,v)\\in E&#39; \\\\\r\n&amp;&amp;\\sum_{(u,v)\\in E&#39;} f_{uv}&amp;=\\sum_{(v,u)\\in E&#39;}\r\nf_{vu} &amp;&amp;\\forall u\\in V\r\n\\end{aligned}\\)\r\n29.2-6\r\n这意味着对于任意一条路径\\(p_i\\)，如果其经过边\\((u,v)\\)，那么这条路径就需要受到这条边容量的限制。因此，对于路径\\(P\\)，我们可以写出如下线性规划：\r\n\\(\\begin{aligned}\r\n\\text{maximize}&amp;&amp; \\sum_{i=1}^px_i \\\\\r\n\\text{subject to}&amp; \\\\\r\n&amp;&amp;x_{i}&amp;\\ge 0 &amp;&amp;\\forall i\\in[1,p] \\\\\r\n&amp;&amp;\\sum_{1\\le i\\le p,(u,v)\\in P_i}x_i&amp;\\le c(u,v)\r\n&amp;&amp;\\forall (u,v)\\in E \\\\\r\n\\end{aligned}\\)\r\n如果\\(G\\)是一个有\\(\\dfrac{|V|(|V|-1)}{2}\\)条边的有向无环图，那么\\(p\\)的值可以达到\\(2^{|V|-2}\\)。因此使用这个线性规划求解最大流问题是不明智的，因为约束的大小和数量都太多（呈指数级数量）。\r\n29.2-7\r\n只需要对多商品流问题的目标函数进行修改即可。修改后的线性规划问题如下：\r\n\\(\\begin{aligned}\r\n\\text{minimize}&amp;&amp; \\sum_{(u,v)\\in E}a(u,v)\\cdot\\left(\\sum_{i=1}^k\r\nf_{i,u,v}\\right) \\\\\r\n\\text{subject to}&amp; \\\\\r\n&amp;&amp;\\sum_{i=1}^kf_{i,u,v}&amp;\\le c(u,v) &amp;&amp;\\forall\r\n(u,v)\\in E\\\\\r\n&amp;&amp;\\sum_{(u,v)\\in E}f_{i,u,v}-\\sum_{(v,u)\\in E}f_{i,v,u}&amp;= 0\r\n&amp;&amp;\\forall i\\in[1,k],\\forall u\\in V-\\{s_i,t_i\\} \\\\\r\n&amp;&amp;\\sum_{(s_i,v)\\in E}f_{i,s_i,v}-\\sum_{(v,s_i)\\in\r\nE}f_{i,v,s_i}&amp;= d_i &amp;&amp;\\forall i\\in[1,k]\\\\\r\n&amp;&amp;f_{i,u,v}&amp;\\ge 0 &amp;&amp;\\forall i\\in[1,k],\\forall\r\n(u,v)\\in E\\\\\r\n\\end{aligned}\\)\r\n","categories":["算法导论"]},{"title":"算法导论31.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-31/exercises-2/","content":"\r\n31.2-1\r\n令\\(\\displaystyle{a&#39;=\\prod_{i=1}^{r}\r\np_i^{e_i-\\min(e_i,f_i)},b&#39;=\\prod_{i=1}^{r}\r\np_i^{f_i-\\min(e_i,f_i)}},g=\\prod_{i=1}^{r}\r\np_i^{\\min(e_i,f_i)}\\)。\r\n那么有\\(a=a&#39;g,b=b&#39;g\\)，并且由于\\(\\forall i\\in[1,r],e_i\\ge\\min(e_i,f_i),f_i\\ge\r\n\\min(e_i,f_i)\\)，因此\\(a&#39;,b&#39;\\)的所有指数仍然仍然是非负整数。也就是说，\\(a&#39;,b&#39;\\)仍然是整数，\\(g\\mid a,g\\mid b\\)。\r\n接下来说明\\(\\gcd(a&#39;,b&#39;)=1\\)。由于\\(\\forall\r\ni\\in[1,r],e_i-\\min(e_i,f_i)=0\\)和\\(f_i-\\min(e_i,f_i)=0\\)必定有一个成立，因此要么\\(p_i\\nmid a\\)，要么\\(p_i\\nmid\r\nb\\)，这两个条件必须有一个成立。也就是说，\\(\\nexists p,p\\mid a,p\\mid\r\nb\\)同时成立。因此\\(\\gcd(a&#39;,b&#39;)=1\\)，这说明\\(\\gcd(a,b)=g\\)。\r\n31.2-2\r\n按照图31.1可以列出下表：\r\n\\(\\begin{array}{cccccc}\r\na&amp;b&amp;\\lfloor a/b\\rfloor&amp;d&amp;x&amp;y\\\\\\hline\r\n899&amp;493&amp;1&amp;29&amp;-6&amp;11\\\\\r\n493&amp;406&amp;1&amp;29&amp;5&amp;-6\\\\\r\n406&amp;87&amp;4&amp;29&amp;-1&amp;5\\\\\r\n87&amp;58&amp;1&amp;29&amp;1&amp;-1\\\\\r\n58&amp;29&amp;2&amp;29&amp;0&amp;-1\\\\\r\n29&amp;0&amp;-&amp;29&amp;1&amp;0\r\n\\end{array}\\)\r\n最终EXTENDED-EUCLID(899, 493)返回\\((29,-6,11)\\)。\r\n31.2-3\r\n根据定理31.9，有\r\n\\(\\begin{aligned}\r\n\\gcd(a+kn,n)&amp;=\\gcd(n,(a+kn)\\bmod n)\\\\\r\n&amp;=\\gcd(n,a\\bmod n)\\\\\r\n&amp;=\\gcd(a,n)\r\n\\end{aligned}\\)\r\n因此当\\(a\\)满足\\(a=1\\pmod\r\nn\\)时，将上面的式子由下往上推，有\r\n\\(\\begin{aligned}\r\n\\gcd(a,n)&amp;=\\gcd(n,a\\bmod n)\\\\\r\n&amp;=\\gcd(n,1)\\\\\r\n&amp;=1\r\n\\end{aligned}\\)\r\n31.2-4\r\n这个算法由EUCLID'给出。\r\nEUCLID&#x27;(a, b)  while b != 0    (a, b) = (b, a % b)  return a\r\n31.2-5\r\n定理33.11给出，当\\(b&lt;F_{k+1}\\)时，调用次数小于\\(k\\)次。又因为\\(F_{k+1}&lt;\\dfrac{\\phi^{k+1}}{\\sqrt{5}}\\)，因此可得\\(b&lt;\\dfrac{\\phi^{k+1}}{\\sqrt{5}}\\)。令\\(k=\\log_{\\phi}\\)\r\n定理33.10给出，当\\(b\\ge\r\nF_{k+1}\\)时，EUCLID的调用次数上界才能达到\\(k\\)。\r\n那么可以知道，\\(F_{k+1}\\ge\\dfrac{\\phi^{k+1}}{\\sqrt{5}}-\\dfrac{\\sqrt{5}-1}{2}\\)。那么有\\(\\dfrac{\\phi^{k+1}}{\\sqrt{5}}\\le\r\nb+\\dfrac{\\sqrt{5}-1}{2}\\)。两侧对\\(\\phi\\)取对数并且移项，得到\r\n\\[k\\le\\log_{\\phi}\\sqrt{5}+\\log_{\\phi}\\left(b+\\dfrac{\\sqrt{5}-1}{2}\\right)-1\\]\r\n当\\(b\\ge 4\\)时，可以得到\\(k\\le\r\n\\log_{\\phi}\\sqrt{5}+\\log_{\\phi}\\left(b+\\dfrac{\\sqrt{5}-1}{2}\\right)-1&lt;1+\\log_{\\phi}\r\nb\\)，从而保证原结论成立。\r\n当\\(b=1,2,3\\)时，通过代入定理33.10的结论进行验证也可知原结论成立。\r\n使用循环不变量来证明这个界限可以缩紧到\\(1+\\log_{\\phi}\\dfrac{b}{\\gcd(a,b)}\\)。\r\n令\\(g=\\gcd(a,b),a&#39;=\\dfrac{a}{g},b&#39;=\\dfrac{b}{g}\\)，我们将证明在整个递归过程中，参数值为\\((a,b)\\)的调用过程产生的参数，永远是参数值为\\((a&#39;,b&#39;)\\)的调用过程产生的参数的\\(g\\)倍。\r\n初始：程序\\(A\\)调用EUCLID(a, b)，子程序\\(B\\)调用EUCLID(a', b')，有\\(a=a&#39;g,b=b&#39;g\\)。\r\n保持：程序\\(A\\)计算出了\\(a\\bmod b\\)的值，程序\\(B\\)计算出了\\(a&#39;\\bmod b&#39;\\)的值。可以发现，\r\n\\(a\\bmod\r\nb=(a&#39;g)\\mod(b&#39;g)=a&#39;g-b&#39;g\\left\\lfloor\\dfrac{a&#39;g}{b&#39;g}\\right\\rfloor=g\\left(a&#39;-b&#39;\\left\\lfloor\\dfrac{a&#39;}{b&#39;}\\right\\rfloor\\right)=g(a&#39;\\bmod\r\nb&#39;)\\)\r\n整个循环保持了这个性质。\r\n终止：最终程序\\(A\\)的最后一步调用参数为\\((g,0)\\)，并返回；程序\\(B\\)的最后一步调用参数为\\((1,0)\\)，并返回。\r\n这说明了程序\\(A\\)和程序\\(B\\)的递归步骤总是一致的。也就是说，上面的调用次数上限可以缩紧到\\(1+\\log_\\phi\r\nb&#39;=1+\\log_{\\phi}\\dfrac{b}{\\gcd(a,b)}\\)。\r\n31.2-6\r\n定理31.11的描述过程给出了求解\\(\\gcd(F_{k+1},F_k)\\)的答案；它实际上是：\r\n\\(\\gcd(F_{k+1},F_k)=\\gcd(F_{k},F_{k-1})=\\dots=\\gcd(F_{2},F_1)=\\gcd(F_{1},F_0)=1\\)\r\n也就是说，相邻两项的斐波那契数的最大公因数为\\(1\\)。\r\n因此接下来我们考虑调用EXTENDED-EUCLID(F[k+1], F[k])的结果，用\\((x_k,y_k)\\)表示（不需要考虑\\(d_k\\)，我们刚刚已经知道了\\(d_k=1\\)）。我们将自底向上地考虑这个过程，那么有：\r\n\\(\\left \\{\\begin{aligned}\r\n  &amp;x_k=y_{k-1}\\\\\r\n  &amp;y_k=x_{k-1}-\\lfloor F_{k}/F_{k-1}\\rfloor y_{k-1} =\r\nx_{k-1}-y_{k-1}\r\n\\end{aligned}\\right.\\)\r\n其中，第二个等号是当\\(k\\ge\r\n3\\)时才满足。\r\n对于一些比较小的\\(k\\)值，有\r\n\\(\\begin{array}{cccc}\r\nk&amp;d_k&amp;x_k&amp;y_k\\\\\r\n\\hline\r\n0&amp;1&amp;1&amp;0\\\\\r\n1&amp;1&amp;0&amp;1\\\\\r\n2&amp;1&amp;0&amp;1\\\\\r\n3&amp;1&amp;1&amp;-1\\\\\r\n4&amp;1&amp;-1&amp;2\r\n\\end{array}\\)\r\n对于较大的\\(k\\)值，我们考虑计算求解递推式\\(a_k=a_{k-2}-a_{k-1},a_0=0,a_1=1\\)，不难求出\\(a_k=(-1)^{k+1}F_k\\)。\r\n因此，将\\(a\\)回代到\\(y\\)。不难知道，对于\\(k\\ge\r\n4\\)，算法EXTENDED-EUCLID的返回结果为\\((1,(-1)^{k+1}F_{k-2},(-1)^{k}F_{k-1})\\)。\r\n31.2-7\r\n等式31.6证明说明了参数的次序不影响最大公因数的值，即满足交换律。\r\n题目31.1-10证明了参数的优先运算顺序不影响最大公因数的值，即满足结合律，哪怕多于两个参数。\r\n因此按照这两个性质，无论是多个参数参与进行运算，最大公因数的值并不会受到影响。\r\n至于求解\\(a_1x_1+a_2x_2+\\dots+a_nx_n=\\gcd(a_1,a_2,\\dots,a_n)\\)，令\\(g_n=\\gcd(a_1,a_2,\\dots,a_n)\\)。我们使用\\(\\gcd(g_{n-1},a_n)=g_n\\)这个等式来考虑：\r\n假设已经计算出了一组整数\\(y_1,y_2,\\dots,y_{n-1}\\)，使得\\(\\displaystyle{\\sum_{i=1}^{n-1}\r\na_iy_i=g_{n-1}}\\)，那么将左边的这一些值视为整体，我们就可以得到以\\((x,y)\\)为未知数的方程\\(g_{n-1}x+a_ny=g_n\\)。对它使用EXTENDED-EUCLID求出解后，那么对于\\(i\\in[1,n)\\)，令\\(x_i=y_i\\cdot x\\)即可，并令\\(x_n=y\\)，那么久求出了一组解\\((x_1,x_2,\\dots.x_n)\\)。\r\n只要\\(a\\)值是从小到大求解的，那么EXTENDED-EUCLID算法使用除法的次数仅仅取决于\\(a_i\\)的最大值，并且由于每次遍历时，一开始调用EXTENDED-EUCLID的参数\\(b\\)必定不为\\(0\\)，因此也需要一次除法操作。因此整个程序的时间复杂度为\\(\\displaystyle{O\\left(n+\\max_{i=1}^n\\{a_i\\}\\right)}\\)。这个算法由MULTI-EXTENDED-EUCLID给出。\r\nMULTI-EXTENDED-EUCLID(A, n)  Sort A monotonically increasing   let X[1 : n] be new array  X[1] = 1  g = A[1]  for i = 2 to n    (g, x, y) = EXTENDED-EUCLID(g, A[i])    X[i] = y    for j = 1 to n      X[j] = X[j] * x  return X\r\n31.2-8\r\n这个算法由LCM-MULTI给出。其基于的事实是，\\(\\text{lcm}(a_1,a_2,\\dots,a_n)=\\text{lcm}(\\text{lcm}(a_1,a_2,\\dots,a_{n-1}),a_n)\\)，以及\\(\\text{lcm}(a,b)\\cdot\\gcd(a,b)=ab\\)。\r\nLCM-MULTI(A, n)  l = A[1]  for i = 2 to n    g = EUCLID(l, A[i])    l = l * A[i] / g  return l\r\n整个算法的时间复杂度为\\(O(n\\log\r\nM)\\)，因为计算复杂性主要在于求解最大公因数。\r\n31.2-9\r\n以下证明将围绕定理31.6进行证明：\\(\\gcd(ab,p)=1\\)当且仅当\\(\\gcd(a,p)=1,\\gcd(b,p)=1\\)。\r\n由于\\(\\gcd(n_1n_2,n_3n_4)=1\\)，因此\\(\\gcd(n_1,n_3)=\\gcd(n_1,n_4)=\\gcd(n_2,n_3)=\\gcd(n_2,n_4)=1\\)，按照定理31.6，这两个条件是充要的。\r\n由于\\(\\gcd(n_1n_3,n_2n_4)=1\\)，因此\\(\\gcd(n_1,n_2)=\\gcd(n_1,n_4)=\\gcd(n_3,n_2)=\\gcd(n_3,n_4)=1\\)，同样按照定理31.6，这两个条件是充要的。\r\n因此，\\(n_1,n_2,n_3,n_4\\)两两互质当且仅当\\(\\gcd(n_1n_2,n_3n_4)=\\gcd(n_1n_3,n_2n_4)=1\\)。\r\n对于更一般的过程（为了方便，这里我们假设下标从\\(0\\)开始），令\\(m=\\lceil \\lg k\\rceil\\)，在第\\(i\\)轮中，将下标满足第\\(i\\)位为\\(1\\)的数（假设这个数集为\\(S^i_1\\)）乘起来得到\\(s^i_1\\)，将下标满足第\\(i\\)位为\\(0\\)的数（假设这个数集为\\(S^i_0\\)）乘起来得到\\(s^i_0\\)，如果\\(\\gcd(s_0,s_1)=1\\)，那么说明\\(S_0^i\\)中的数和\\(S_1^i\\)中的都是互质的，因此每一对数总会在某一轮中处在不同的集合。\r\n这个算法由程序IS-PAIRWISE-RELATIVELY-PRIME给出。\r\nIS-PAIRWISE-RELATIVELY-PRIME(A, k)  m = ⌈lg k⌉   for i = 0 to m - 1    s0 = 1    s1 = 1    for j = 0 to k      // 下标j的第i比特为0。      if (j &gt;&gt; i &amp; 1) == 0        s0 = s0 * A[j]      else        s1 = s1 * A[j]    if EUCLID(s0, s1) != 1      return False  return True\r\n","categories":["算法导论"]},{"title":"算法导论31.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-31/exercises-3/","content":"\r\n31.3-1\r\n群\\((\\mathbb{Z}_4,+_4),(\\mathbb{Z}_5^{\\ast},\\cdot_5)\\)：\r\n\\(\\begin{array}{l|llll}\r\n+_4&amp; 0 &amp; 1 &amp; 2 &amp; 3 \\\\\r\n\\hline\r\n0 &amp; 0 &amp; 1 &amp; 2 &amp; 3 \\\\\r\n1 &amp; 1 &amp; 2 &amp; 3 &amp; 0 \\\\\r\n2 &amp; 2 &amp; 3 &amp; 0 &amp; 1 \\\\\r\n3 &amp; 3 &amp; 0 &amp; 1 &amp; 2 \\\\\r\n\\end{array}\r\n\\qquad\r\n\\begin{array}{l|llll}\r\n\\cdot_5&amp; 1 &amp; 2 &amp; 3 &amp; 4 \\\\\r\n\\hline\r\n1 &amp; 1 &amp; 2 &amp; 3 &amp; 4 \\\\\r\n2 &amp; 2 &amp; 4 &amp; 1 &amp; 3 \\\\\r\n3 &amp; 3 &amp; 1 &amp; 4 &amp; 2 \\\\\r\n4 &amp; 4 &amp; 3 &amp; 2 &amp; 1 \\\\\r\n\\end{array}\\)\r\n可以看到，这两个群是同态的：\r\n对于\\(f(x)=2^x\\bmod 5\\)，其中\\(x\\in \\mathbb{Z_4},f(x)\\in\r\n\\mathbb{Z}_5^{\\ast}\\)，都有：\\(f(a+_4\r\nb)=f(a)\\cdot_5 f(b)\\)。\r\n31.3-2\r\n\\(\\mathbb{Z}_9\\)有如下子群：\r\n\\(\\begin{aligned}\r\n&amp;\\langle0\\rangle=\\{0\\}\\\\\r\n&amp;\\langle1\\rangle=\\{0,1,2,3,4,5,6,7,8\\}\\\\\r\n&amp;\\langle3\\rangle=\\{0,3,6\\}\\\\\r\n\\end{aligned}\\)\r\n\\(\\mathbb{Z}_{13}^{\\ast}\\)有如下子群：\r\n\\(\\begin{aligned}\r\n&amp;\\langle1\\rangle=\\{1\\}\\\\\r\n&amp;\\langle2\\rangle=\\{1,2,3,4,5,6,7,8,9,10,11,12\\}\\\\\r\n&amp;\\langle3\\rangle=\\{1,3,9\\}\\\\\r\n&amp;\\langle4\\rangle=\\{1,3,4,9,10,12\\}\\\\\r\n&amp;\\langle5\\rangle=\\{1,5,8,12\\}\\\\\r\n&amp;\\langle12\\rangle=\\{1,12\\}\\\\\r\n\\end{aligned}\\)\r\n31.3-3\r\n封闭性：\\(\\forall a,b \\in S&#39;,a\\oplus\r\nb\\in S&#39;\\)，因此满足封闭性。\r\n单位元：假设\\(a\\in\r\nS&#39;\\)，将元素\\(a\\)的幂按序列出来，那么有\\(a,a^2,a^3,\\dots,a^{k-1},a,a^{k+1},a^{k+2},\\dots\\)。由于\\(S&#39;\\)的大小是有限的，因此总存在一个值\\(k\\)使得\\(a^{k}=a\\)，那么就找到了一个单位元\\(a^{k-1}=1\\)。\r\n结合律：由于\\(S&#39;\\)中的元素都是来自于\\(S\\)，其运算过程完全一致。因此，由于群\\((S,\\oplus)\\)满足结合律，因此\\((S&#39;,\\oplus)\\)也满足结合律。\r\n逆元：对于任意\\(a\\in\r\nS&#39;\\)，如果\\(a^{k+1}=a\\)，那么它的逆元是\\(a^{k-1}\\)，即\\(a\\cdot a^{k-1}=a^k=1\\)。\r\n31.3-4\r\n\\(p^e\\)这个数只有质因子\\(p\\)。在\\(1\\sim\r\np^e\\)种，含有质因子\\(p\\)的数的个数为\\(p^{e-1}\\)个。\r\n因此有\\(\\phi(p^e)=p^e-p^{e-1}=p^{e-1}(p-1)\\)。\r\n31.3-5\r\n采用反证法来证明。\r\n如果\\(\\exists x,y\\in[0,n),x\\neq\r\ny\\)，并且有\\(ax\\equiv ay\\pmod\r\nn\\)。那么有\\(a(x-y)\\equiv 0\\pmod\r\nn\\)，也就是说，\\(n\\mid\r\na(x-y)\\)。\r\n由于\\(a\\in\r\n\\mathbb{Z}_n^{\\ast}\\)，因此\\(\\gcd(a,n)=1\\)，那么\\(n\\mid (x-y)\\)。只有当\\(x=y\\)时，整除才成立，和原假设矛盾。\r\n因此\\(\\forall x,y\\in[0,n),x\\neq\r\ny,f_a(x)\\bmod n\\neq f_a(y)\\bmod n\\)均成立。由于\\(f_a(x)\\in [0,n)，\\)因此\\(f_a(x)=ax\\bmod n\\)是一个\\(n\\)阶排列。\r\n","categories":["算法导论"]},{"title":"算法导论31.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-31/exercises-1/","content":"\r\n31.1-1\r\n\\(c=a+b=a\\cdot 1+b\\)，并且由于\\(0&lt; b&lt; a\\)，因此根据除法定理\\(31.1\\)，有\\(c\r\n\\bmod a=b\\)。\r\n31.1-2\r\n考虑使用反证法证明。\r\n假设质数是的数量是有限的，只有\\(k\\)个，分别为\\(p_1,p_2,\\dots,p_k\\)。考虑构造出一个新数\\(p=\\prod_{i=1}^k p_i + 1\\)。\r\n对于所有\\(p_i\\)，可以发现\\(\\prod_{j=1}^k p_j\\)都是\\(p_i\\)的倍数。因此\\(\\left(\\prod_{j=1}^kp_j+1\\right)\\bmod\r\np_i=1\\)。也就是说都有\\(p_i\\nmid\r\np\\)。那么我们新构造出了一个质数\\(p\\)。由此和原来只有\\(k\\)个质数的结论矛盾。\r\n31.1-3\r\n\\(a\\mid b,b\\mid c\\)意味着存在\\(k_1,k_2\\in \\mathbb{Z}\\)使得\\(b=k_1a,c=k_2b\\)，那么说明\\(c=(k_1k_2)a\\)，因此\\(a\\mid c\\)。\r\n31.1-4\r\n令\\(g=\\gcd(k,p)\\)。那么\\(g\\mid k,g\\mid p\\)均成立。由于\\(p\\)是质数，因此\\(g\\)的值要么为\\(p\\)，要么为\\(1\\)。由于\\(k&lt;\r\np\\)，那么\\(g\\)不可能为\\(p\\)。因此\\(g=\\gcd(k,p)=1\\)。\r\n31.1-5\r\n因为\\(\\gcd(a,n)=1\\)，所以\\(\\exists\r\nx,y,ax+ny=1\\)成立。两边同时乘上\\(b\\)，得到\\(bax+bny=b\\)。\r\n又因为\\(n\\mid ab\\)，所以\\(\\exists k,nk=ab\\)。因此最终转换成\\(nkx+bny=n(kx+by)=b\\)。由此可得，\\(n\\mid b\\)。\r\n31.1-6\r\n根据二项式定理，可以写出：\r\n\\[(a+b)^p=\\sum_{k=0}^p\\dbinom{p}{k}\r\na^kb^{p-k}=\\dfrac{p!}{k!(p-k)!} a^kb^{p-k}=\\dfrac{p\\cdot\r\n(p-1)!}{k!(p-k)!} a^kb^{p-k}\\]\r\n由于组合数是个整数，因此\\(k!(p-k)!\\mid\r\np\\cdot (p-1)!\\)。当\\(0 &lt; k &lt;\r\np\\)时，由于\\(k!,(p-k)!\\)的所有项都小于\\(p\\)，并且\\(p\\)是个质数，因此\\(\\gcd(p,k!(p-k)!)=1\\)。那么根据推论\\(31.5\\)，有\\(k!(p-k)!\\mid (p-1)!\\)。令\\((p-1)!=c\\cdot k!(p-k)!\\)，那么有\\(\\dbinom{p}{k}a^kb^{p-k}=cpa^kb^{p-k}\\)成立。\r\n因此有：\r\n\\[\\sum_{k=0}^p\\dbinom{p}{k}\r\na^kb^{p-k}\\equiv a^p+b^p \\pmod p\\]\r\n仅仅保留了\\(k=0\\)和\\(k=p\\)时的项。\r\n31.1-7\r\n由于\\(a\\mid b\\)，因此\\(\\exists k\\in \\mathbb{Z}\\)，使得\\(b=ka\\)成立。\r\n令\\(x=q_1b+r_1,r_1=q_2a+r_2\\)，其中满足\\(0\\le r_1&lt; b,0\\le r_2&lt;\r\na\\)。那么可以得知，\\(r_2=(x \\bmod\r\nb)\\bmod a\\)。\r\n将两条式子合并，得到\\(x=q_1b+q_2a+r_2=q_1ka+q_2a+r_2=(q_1k+q_2)a+r_2\\)。\r\n也就是有\\(x-r_2=(q_1k+q_2)a\\)。因此最终\\((x\\mod a)\\equiv x\\equiv r_2\\equiv (x \\bmod b)\\bmod\r\na\\)成立。\r\n如果\\(x\\equiv y\\pmod b\\)，那么\\(\\exists k_1\\in\r\n\\mathbb{Z},x-y=k_1b\\)成立。那么可以得到\\(x-y=(kk_1)a\\)成立，因此有\\(x\\equiv y\\pmod a\\)。\r\n31.1-8\r\n假设这个整数\\(n\\)在二进制下是\\(\\beta\\)比特数。\r\n可以发现，所需要测试的\\(k\\)的值至多为\\(\\beta\\)。因为\\(2^{\\beta}\\)是\\(\\beta+1\\)比特数，比\\(n\\)还大。\r\n那么将从\\(2\\)到\\(\\beta\\)遍历\\(k\\)值，对每个\\(k\\)进行判断，这个循环需要\\(\\Theta(\\beta)\\)次。\r\n从\\(1\\)和\\(n\\)之间二分查找整数\\(x\\)，判断\\(x^k\\ge\r\nn\\)。这个二分的过程需要进行\\(\\Theta(\\beta)\\)次。\r\n计算\\(x^k\\)的过程中需要使用乘法和求幂。如果我们朴素地进行求幂，那么在第\\(i(1\\le i&lt; k)\\)次做乘法时，是将一个\\(\\beta\\)位二进制数和\\(i\\beta\\)位二进制数相乘，如果不适用任何方法优化乘法，那么完成一次乘法计算的运行时间为\\(\\Theta(i\\beta ^2)\\)，最终完成\\(x^k\\)的求幂计算需要\\(\\Theta(\\beta^4)\\)的计算。如果使用31.6章使用的求幂算法，那么可以将求幂运算优化到\\(\\Theta(\\beta^3\\log \\beta)\\)。\r\n因此，存在一个\\(O(\\beta^6)\\)的算法，完成对\\(\\beta\\)位二进制数\\(x\\)是否为非平凡幂的测试。\r\n31.1-9\r\n考虑集合\\(S:\\{ax+by:x,y\\in\\mathbb{Z}\\}\\)。\r\n等式 31.6\r\n根据定理31.2，如果交换\\(a,b\\)的值，那么将\\(x,y\\)的值也相互交换，那么得到的集合仍然是\\(S=\\{by+xa:x,y\\in \\mathbb{Z}\\}\\)。因此\\(\\gcd(a,b)=\\gcd(b,a)\\)。\r\n等式 31.7\r\n根据定理31.2，只需要同时将集合中的\\(a,x\\)取负，那么得到的集合仍然是\\(S=\\{-a(-x)+by:x,y\\in\r\n\\mathbb{Z}\\}\\)。因此\\(\\gcd(a,b)=\\gcd(-a,b)\\)。\r\n等式 31.8\r\n根据等式31.7，有\\(\\gcd(a,b)=\\gcd(a,-b)=\\gcd(-a,-b)=\\gcd(-a,b)\\)。可知，\\(\\gcd(|a|,|b|)\\)必定是这个等式中\\(4\\)个项之一。\r\n等式 31.9\r\n根据定理31.2，令\\(y=0\\)，那么得到的集合是\\(S=\\{ax:x\\in\r\n\\mathbb{Z}\\}\\)。这个集合中最小的正整数是\\(|a|\\)，因此\\(\\gcd(a,0)=|a|\\)。\r\n等式 31.10\r\n根据定理31.2，令\\(y=ka\\)，那么得到的集合是\\(S=\\{(x+ky)a:x,y\\in\r\n\\mathbb{Z}\\}\\)。只要固定\\(y\\)，任取\\(x\\in\r\n\\mathbb{Z}\\)，那么\\(x+ky\\)就能表示出所有整数。故这个集合中最小的正整数是\\(|a|\\)，\\(\\gcd(a,ka)=|a|\\)。\r\n31.1-10\r\n考虑通过中间值\\(\\gcd(a,b,c)\\)来证明题目的两个值是相等的。\r\n令\\(g=\\gcd(a,b,c),h=\\gcd(\\gcd(a,b),c)\\)。\r\n一方面，可以知道有\\(h\\mid \\gcd(a,b),h\\mid\r\nc\\)。\r\n根据\\(\\gcd\\)的性质，从\\(h\\mid \\gcd(a,b)\\)可以得到\\(h\\mid a,h\\mid b\\)。\r\n由于\\(g=\\gcd(a,b,c)\\)，因此\\(h\\mid g\\)。\r\n另一方面，可以知道\\(g\\mid a,g\\mid b,g\\mid\r\nc\\)。由此可以得到\\(g\\mid\r\n\\gcd(a,b)\\)。\r\n从而得到\\(g\\mid h\\)。\r\n因此\\(h=g\\)，完成了对\\(\\gcd(a,b,c)=\\gcd(\\gcd(a,b),c)\\)的证明。\r\n通过类似的方式，我们可以证明\\(\\gcd(a,b,c)=\\gcd(a,\\gcd(b,c))\\)。\r\n因此最终得到\\(\\gcd(\\gcd(a,b),c)=\\gcd(a,\\gcd(b,c))\\)。\r\n\\(\\star\\)\r\n31.1-11\r\n需要证明算术基本定理的存在性和唯一性。\r\n存在性\r\n使用反证法证明。\r\n假设存在最小的合数\\(n\\)，它不能写成一系列的质数乘积。\r\n那么由于\\(n\\)是合数，因此\\(n\\)存在两个非平凡因子\\(a,b\\)满足\\(1&lt;\r\na,b&lt; n,ab=n\\)。\r\n\\(a,b\\)都比\\(n\\)小，那么\\(a,b\\)可以写成质数的乘积\\(a=p_1p_2\\dots p_r,b=q_1q_2\\dots q_s\\)。\r\n最终，\\(n\\)也可以写成一个质数的乘积序列\\(n=ab=p_1p_2\\dots p_n q_1q_2\\dots\r\nq_s\\)。与假设矛盾。\r\n因此所有整数都能够写成一系列质数的乘积。\r\n唯一性\r\n使用反证法证明。\r\n假设\\(n\\)是最小的数，存在两个不同的分解：\\(n=p_1p_2\\dots p_{r-1}p_r=q_1q_2\\dots\r\nq_{s-1}q_s\\).\r\n那么有\\(p_1\\mid q_1q_2\\dots\r\nq_{s-1}q_s\\)。\r\n由于\\(q_1,q_2,\\dots,q_s\\)都是质数，根据定理31.7，因此存在一个质数\\(q_k(1\\le k\\le s)\\)，使得\\(p_1\\mid q_k\\)。不失一般性，假设\\(k=1\\)。那么消去\\(p_1=q_1\\)后，令\\(n&#39;=p_2p_3\\dots\r\np_{r-1}p_r\\)，那么说明\\(n&#39;\\)也有两个分解：\r\n\\(n&#39;=p_2p_3\\dots p_{r-1}p_r=q_2q_3\\dots\r\nq_{s-1} q_s\\)\r\n由于\\(n&#39;\\cdot p_1=n\\)，即\\(n&#39;&lt; n\\)，违背了\\(n\\)是最小的假设。\r\n因此所有整数的质因数分解都是唯一的。\r\n31.1-12\r\n可以简单地使用长除法进行。假设被除数是\\(\\beta\\)比特数，为\\(a=a_{\\beta-1}a_{\\beta-2}\\dots\r\na_{1}a_{0}\\)；除数是\\(k\\)比特数，为\\(b=b_{k-1}b_{k-2}\\dots b_1 b_0\\).\r\n那么这个除法过程将会迭代\\(\\beta-b\\)次。在每一次迭代中，都会做一次比较操作，有时会做一次减法操作。这两种操作的开销都是\\(\\Theta(\\beta)\\)。\r\n整个长除法完成后，商和余数都能求出来，最终运行时间为\\((\\beta-b)\\cdot\\Theta(\\beta)=\\Theta(\\beta^2)\\)。\r\n31.1-13\r\n如果数\\(n\\)的二进制长度\\(\\beta\\)不是\\(2\\)的幂，那么可以考虑将最高位补充\\(0\\)，直到\\(\\beta\\)是\\(2\\)的幂，由此进行分治。\r\n那么可以将\\(n\\)写成\\(n=h\\cdot 2^{\\beta/2} + l\\)，其中\\(h\\)是\\(n\\)高\\(\\beta/2\\)位的结果，\\(l\\)是\\(n\\)低\\(\\beta/2\\)位的结果。\r\n通过递归，求解出\\(h\\)的十进制值\\(h&#39;\\)和\\(l\\)的十进制值\\(l&#39;\\)。那么要重新计算出\\(n&#39;\\)的十进制值，需要进行一次\\(\\beta/2\\)位数的乘法，以及一次\\(\\beta\\)位数的加法。\r\n那么也就是说，调用一次的结果可以写成：\r\n\\(T(\\beta)=2T(\\beta/2)+M(\\beta/2)\\)\r\n由于\\(M(\\beta)=\\Omega(\\beta)\\)，那么考虑如下情况：\r\n\r\n如果\\(\\exists k\\ge 0,M(\\beta)=\\Theta(\\beta\r\n\\cdot \\lg ^k \\beta)\\)，那么根据主定理，有\\(T(\\beta)=\\Theta(\\beta \\lg^{k+1}\r\n\\beta)=\\Theta(M(\\beta)\\cdot\\lg \\beta)\\)成立。\r\n如果\\(\\exists\r\n\\epsilon&gt;0,M(\\beta)=\\Omega(\\beta^{1+\\epsilon})\\)，那么根据主定理，有\\(T(\\beta)=\\Theta(M(\\beta))\\)。\r\n\r\n无论那种情况，都满足\\(M(\\beta)=O(M(\\beta)\\cdot \\lg \\beta)\\)。\r\n关于预处理：\\(2^{2^0},2^{2^1},\\dots,2^{\\beta}\\)的这些数的十进制预计算。可以知道，这些数一共有\\(\\lg \\beta\\)个，每次可以从\\(2^{2^{i-1}}\\)计算出\\(2^{2^i}\\)，一次计算需要\\(M(\\beta/2)\\)的时间。因此这部分处理需要\\(\\Theta(M(\\beta)\\cdot\\lg\r\n\\beta)\\)的时间。\r\n最终合并这两部分时间，得到最终运行时间为\\(O(M(\\beta)\\cdot \\lg \\beta)\\)。\r\n31.1-14\r\n可以发现，在第\\(i\\)轮中，灯\\(j\\)被按下开关时当且仅当\\(i\\mid j\\)。\r\n也就是说，灯泡\\(j\\)的开关被按次数相当于是它的因子个数。\r\n那么如果灯泡被打开，那么意味着它有奇数个因子。\r\n令\\(n\\)的分解为\\(n=\\prod_{i=1}^k\r\np_i^{e_i}\\)，根据因数个数定理，\\(n\\)一共有\\(\\prod_{i=1}^k (e_i+1)\\)个因子。\r\n因子个数为奇数，当且仅当对于所有的\\(1\\le\r\ni\\le k,e_i\\)都是偶数。\r\n因此，只有当\\(m\\)为平方数时，灯泡\\(m\\)才会被打开。\r\n","categories":["算法导论"]},{"title":"算法导论31.4 Exercises 答案","url":"/introduction-to-algorithms/chapter-31/exercises-4/","content":"\r\n31.4-1\r\n第一步通过求解\\(35x+50y=\\gcd(35,50)\\)得到一组解\\((3,-2)\\)，那么计算出来的\\(x_0=x\\cdot \\dfrac{b}{d}=6\\)。\r\n随后计算\\(\\left(x_0+i\\cdot\\dfrac{n}{d}\\right)\\)，对于\\(i=\\{0,1,2,3,4\\}\\)，得到解的集合为\\(\\{6,16,26,36,46\\}\\)。\r\n31.4-2\r\n也就是说，从方程\\(a(x-y)=0\\pmod\r\nn\\)推导出\\(x-y=0\\pmod\r\nn\\)。令\\(z=(x-y)\\bmod\r\np\\)，那么按照推论31.25，由于\\(d=\\gcd(a,n)=1\\)，因此方程\\(az=0\\pmod p\\)有唯一解，即\\(z=0\\)，从而满足\\(x=y\\pmod n\\)。否则，\\(z\\)将有多个解，这将不再保证\\(z=0\\pmod n\\)成立。\r\n如果\\(a=2,n=6\\)，那么令\\(x=1,y=4\\)，虽然有\\(ax=ay=2\\pmod n\\)，但是不满足\\(x=y\\pmod n\\)。\r\n31.4-3\r\n仍然可以正常工作，而且\\(x_0\\)是这些解中最小的一个。\r\n考虑这种情况下的\\(x_0\\)，那么存在整数\\(q\\)，使得\\(x_0=\\dfrac{x&#39;b}{d}-\\dfrac{qn}{d}\\)成立，我们只需要验证\\(x_0\\)是否为\\(ax=b\\pmod n\\)的解即可。\r\n使用定理31.24类似的证明步骤，那么有\r\n\\(\\begin{aligned}\r\nax_0&amp;=a(x&#39;b/d-qn/d)\\pmod n\\\\\r\n&amp;=(b-aqn/d)\\pmod n\\\\\r\n&amp;=(b-(a/d)qn)\\pmod n\\\\\r\n&amp;=b\\pmod n\r\n\\end{aligned}\\)\r\n因此这种情况下，\\(x_0\\)仍然是原方程的解。后面的\\(x_i\\)值正确性论证方式和原结论一致，因此原结论是正确的。\r\n\\(\\star\\)\r\n31.4-4\r\n令\\(\\displaystyle{f(x)=\\sum_{i=0}^t\r\nf_ix^i,g(x)=\\sum_{i=0}^{t-1} g_ix^i}\\)。\r\n如果\\(a=0\\)，那么简单地对\\(f(x)\\)提取一个因子\\(x\\)即可得到\\(g(x)\\)。\r\n如果\\(a\\neq 0\\)，那么对于\\(f\\)中的每个系数\\(f_i\\)，考虑使用\\(g_i\\)来表示：\r\n\r\n\\(f_0=-a g_0;\\)\r\n\\(\\forall i\\in[1,t),f_i=g_{i-1}-a\r\ng_i;\\)\r\n\\(f_t=g_{t-1}.\\)\r\n\r\n前\\(t\\)个约束（因为这足以帮助我们确认出\\(g\\)的所有值）足以构造出\\(g_i\\)中的所有值，因此我们还需要证明\\(f_t=g_{t-1}\\)才能够说明\\(g\\)为所求。由前\\(t\\)个约束可以得到\r\n\r\n\\(g_0=-f_0 a^{-1}\\)\r\n\\(\\forall i\\in[1,t),g_i=(g_{i-1}-f_i)\r\na^{-1}\\)\r\n\r\n由于\\(p\\)是质数，因此\\(\\gcd(a,p)=1\\)，因此\\(a\\)在\\(\\mathbb{Z}_p^{\\ast}\\)上的逆元\\(a^{-1}\\)必定存在。\r\n我们首先使用归纳法证明：\\(\\displaystyle{\\forall\r\nt\\in[0,t),a^{k+1}g_k=-\\sum_{i=0}^k}f_ia^i\\)。\r\n当\\(k=0\\)时，\\(ag_0=-f_0\\)，原结论成立。\r\n当\\(k&gt;0\\)时，假设对于\\(m=0,1,\\dots,k-1\\)，都满足\\(\\displaystyle{a^{m+1}g_m=-\\sum_{i=0}^ma^if_i}\\)，那么考虑\\(a^{k+1} g_k\\)，有\r\n\\(\\begin{aligned}\r\na^{k+1}g_k&amp;=a^{k+1}(g_{k-1}-f_k) a^{-1}\\\\\r\n&amp;=a^k(g_{k-1}-f_k)\\\\\r\n&amp;=a^kg_{k-1} -a^kf_k\\\\\r\n&amp;=-\\sum_{i=0}^{k-1}a^if_i-a^{k}f_k\\\\\r\n&amp;=-\\sum_{i=0}^{k}a^if_i\r\n\\end{aligned}\\)\r\n因此原结论成立。\r\n此外，由于\\(\\displaystyle{f(a)=\\sum_{i=0}^{t-1}f_ia^i+f_ta^t}\\)，并且\\(f(a)=0\\)，因此有\\(\\displaystyle{f_ta^t=-\\sum_{i=0}^{t-1}f_ia^i=g_{t-1}a^t}\\)。最终得到\\(g_{t-1}=f_t\\)。\r\n因此，根据多项式\\(f\\)以及其零点\\(a\\)，我们构造出了一个多项式\\(g\\)使得\\(f(x)=(x-a)g(x)\\)。\r\n对于后面的那个结论，使用归纳法来证明。\r\n当\\(f(x)\\)的度数\\(t=1\\)时，有\\(x=-a\r\n\\pmod p\\)，原结论成立。\r\n当\\(f(x)\\)的度数大于\\(1\\)时，假设对于\\(t&#39;=1,2,3,\\dots,t-1\\)，原结都成立。那么考虑如下情况：\r\n\r\n\\(f(x)\\)不能够写成\\((x-a)g(x)\\)，那么\\(f(x)\\)没有零点，原结论成立。\r\n\\(f(x)=(x-a)g(x)\\)，但是\\(g(a)=0\\)，这说明\\(f(x)\\)至多只有\\(t-1\\)个不同的零点。也就是说，“\\(f(x)\\)至多只有\\(t\\)个不同的零点”也是正确的，原结论成立。\r\n\\(f(x)=(x-a)g(x)\\)，并且\\(g(a)\\neq 0\\)，那么\\(g(x)\\)中的所有零点也是\\(f(x)\\)的零点，再加上\\(a\\)，因此\\(f(x)\\)至多只有\\(t\\)个不同的零点，原结论成立。\r\n\r\n最终，原结论是正确的。\r\n","categories":["算法导论"]},{"title":"算法导论31.7 Exercises 答案","url":"/introduction-to-algorithms/chapter-31/exercises-7/","content":"\r\n31.7-1\r\n\\(\\begin{aligned}\r\n&amp;\\phi = (p-1)\\cdot (q-1)=280\\\\\r\n&amp;d=e^{-1} \\bmod \\phi = 187\\\\\r\n&amp;P(M)=M^e\\bmod n=100^3 \\bmod 319 = 254\r\n\\end{aligned}\\)\r\n31.7-2\r\n根据RSA公钥加密系统的定义，有\\(ed\\equiv 1\r\n\\pmod {\\phi(n)}\\).\r\n也就是说，\\(\\exists\r\nk,ed-1=k\\phi(n)\\)。\r\n由于\\(p,q\\)都非常大，因此可以假设\\(p&lt; n/3,q&lt; n/3\\)。\r\n那么有\\(\\phi(n)=n-p-q+1&gt;n/3+1&gt;n/3\\).\r\n由于\\(ed-1=3d-1&lt;3n-1&lt;3n\\)，那么得到：\r\n\\(k(n/3)&lt;k\\phi(n)=3d-1&lt;3n\\)。这说明，\\(k&lt;9\\)。\r\n因此，枚举\\(k\\)值\\(1,2,3,\\dots,8\\)，使得\\(k\\mid ed-1\\)，并计算出\\(\\phi(n)=\\dfrac{ed-1}{k}\\)，并且计算二元二次方程组\\(\\left\\{\\begin{aligned}&amp;pq=n\\\\&amp;(p-1)(q-1)=\\phi(n)\\end{aligned}\\right.\\)，即可得到\\(p,q\\)的值。如果解出来是整数，那么分解完毕。\r\n值得注意的是，这个方程组可以化成使用韦达定理来解。\r\n\\(\\star\\)\r\n31.7-3\r\n证明乘法性：\\(P_A(M_A)\\cdot P_A(M_B)\\equiv\r\nM_A^{e}\\cdot M_B^{e}\\equiv (M_A\\cdot M_B)^e\\equiv P_A(M_A\\cdot M_B)\\pmod\r\nn\\)\r\n证明解密：如果我们打算解密密文\\(C\\)，那么随机选择\\(a\\in \\mathbb{Z}_n^{\\ast}\\)，并且对\\(a^e\\cdot\r\nC\\)进行题中所说的解密程序。如果解密得到正确的结果\\(M&#39;\\)，那么返回\\(M=a^{-1}\\cdot M&#39;\\bmod\r\nn\\)，否则重新随机选择\\(a\\)，继续尝试即可。\r\n","categories":["算法导论"]},{"title":"算法导论31.5 Exercises 答案","url":"/introduction-to-algorithms/chapter-31/exercises-5/","content":"\r\n31.5-1\r\n令\\((a_1,n_1)=(4,5),(a_2,n_2)=(5,11)\\)。可以知道，\\(m_1=11,m_2=5\\)，因此有\\(m_1^{-1}\\bmod n_1=1,m_2^{-1}\\bmod\r\nn_2=9\\)。\r\n计算出\\(c_1=m_1\\cdot(m_1^{-1}\\bmod n_1) =\r\n11,c_2=m_2\\cdot(m_2^{-1}\\bmod n_2)=45\\)。\r\n最终有\\(a=(c_1a_1+c_2a_2)\\bmod(n_1n_2)=49\\)。\r\n因此，整体解为\\(49+55k,k\\in\\mathbb{Z}\\)。\r\n31.5-2\r\n令\\((a_1,n_1)=(1,9),(a_2,n_2)=(2,8),(a_3,n_3)=(3,7)\\)。可以知道，\\(m_1=56,m_2=63,m_3=72\\)，因此有\\(m_1^{-1}\\bmod n_1=5,m_2^{-1}\\bmod\r\nn_2=7,m_3^{-1}\\bmod n_3=4\\)。\r\n计算出\\(c_1=m_1\\cdot(m_1^{-1}\\bmod n_1) =\r\n280,c_2=m_2\\cdot(m_2^{-1}\\bmod n_2)=441,c_3=m_3\\cdot(m_3^{-1}\\bmod\r\nn_3)=288\\)。\r\n最终有\\(a=(c_1a_1+c_2a_2+c_3a_3)\\bmod(n_1n_2n_3)=10\\)。\r\n因此，整体解为\\(10+504k,k\\in\\mathbb{Z}\\)。\r\n31.5-3\r\n由于\\(\\gcd(a,n)=1\\)，因此\\(\\forall\r\ni\\in[1,k],\\gcd(a,n_i)=1\\)均成立，令\\(x\\)是满足\\(ax=1\\pmod n\\)的值，即\\(x=a^{-1}\\bmod n\\)。\r\n那么有\\(x_i=x\\bmod n_i,a_i=a\\bmod\r\nn_i\\)。使用等式31.30，由于\\(ax=1\\bmod\r\nn\\)，因此\\(\\forall\r\ni\\in[1,k],a_ix_i\\bmod n_i=1\\)也成立。\r\n由此，从\\(x\\)可以映射到一个关于\\(x\\)的向量\\((x_1,x_2,\\dots,x_k)\\)。\r\n最终由这个向量通过定理31.27回代即可求出\\(x\\)，即\\(a^{-1}\\bmod n\\)。\r\n31.5-4\r\n令\\(\\displaystyle{f(x)=\\sum_{i=0}^t\r\nf_ix^i}\\)。通过定理31.27知道，\\(\\displaystyle{\\sum_{i=0}^t f_ix^i}=0\\pmod\r\nn\\)当且仅当\\(\\displaystyle{\\forall\r\nj\\in[1,k],\\sum_{i=0}^t f_ix_j^i=0\\pmod {n_j}}\\)均成立。\r\n考虑任意一个\\(j\\)，假设方程的\\(f(x_j)=0\\pmod{n_j}\\)的解的集合为\\(S_j\\)。那么从每个\\(S_j\\)中选取一个\\(x_j\\)，从\\((x_1,x_2,\\dots,x_k)\\)映射回去的\\(x\\)也是方程\\(f(x)=0\\pmod{n}\\)的一个解（因为它确保了\\(f(x)=0\\pmod{n_j}\\)成立）。\r\n从\\(S_1,S_2,\\dots,S_k\\)各选择一个解都能拼凑一个符合条件的解，因此根据乘法原理，原结论成立。\r\n","categories":["算法导论"]},{"title":"算法导论31.8 Exercises 答案","url":"/introduction-to-algorithms/chapter-31/exercises-8/","content":"\r\n31.8-1\r\n如果\\(n\\)不是一个奇质数的幂，那么可以将\\(n\\)写成\\(n=p_1^{e_1}p_2^{e_2}\\dots\r\np_r^{e_r}\\)，其中\\(r\\ge\r\n2\\)。\r\n按照定理31.34，对于\\(\\forall\r\ni\\in[1,r]\\)，方程\\(x=1\\pmod\r\n{p_i^{e_i}}\\)都有两个平凡根\\(-1,1\\)。\r\n对于方程\\(x^2=1\\pmod\r\nn\\)而言，它最多只有两个平凡根\\((-1,1)\\)。但是按照题目31.5-4的结论，这个方程它含有\\(2^r&gt;2\\)个不同的根，因此总存在一组关于所有方程\\(x_i=1\\pmod {p_i^{e_i}}\\)的根组合\\((x_1,x_2,\\dots,x_n)\\)，通过中国剩余定理映射出来的\\(x\\)，是方程\\(x^2=1\\pmod n\\)的非平凡根。\r\n\\(\\star\\)\r\n31.8-2\r\n根据欧拉函数函数\\(\\phi\\)的不完全积性，可以得知\\(\\displaystyle{\\phi(n)=\\prod_{i=1}^r\r\n\\phi(p_i)^{e_i}}\\)。也就是说，\\(\\forall\r\ni\\in [1,r]\\)，都有\\(\\phi(e_i^{e_i})\\mid\r\n\\phi(n)\\)。那么整除所有\\(\\phi(p_i^{e_i})\\)的最小倍数也应该整除\\(\\phi(n)\\)，即\\(\\text{lcm}(\\phi(p_1^{e_1}),\\dots,\\phi(p_r^{e_r}))\\mid\r\n\\phi(n)\\)，那么也就是有\\(\\lambda(n)\\mid\r\n\\phi(n)\\)。\r\n先通过反证法证明\\(n\\)是无平方因子的。假设\\(n\\)的某个质因子\\(p\\)对应的指数\\(e\\)满足\\(e\\ge\r\n2\\)，那么按照\\(\\phi\\)的定义，有\\(p\\mid \\phi(p^e)\\)，因为\\(\\phi(p^e)=(p-1)p^{e-1}\\)。那么按照最小公倍数的定义，因为\\(\\lambda(n)=\\text{lcm}(\\phi(p_1^{e_1}),\\dots,\\phi(p_r^{e_r}))\\)，有\\(p\\mid \\lambda(n)\\)，然而当\\(\\lambda(n)\\mid n-1\\)时，\\(n\\)才是Carmichael数，但此时\\(p\\nmid n-1\\)，因此\\(\\lambda(n)\\mid\r\nn-1\\)不可能成立。从而证明了\\(n\\)是Carmichael数需要满足\\(n\\)是无平方因子的。\r\n接下来使用反证法证明\\(n\\)至少有\\(3\\)个质因子，如果\\(n\\)只有两个质因子\\(p,q\\)（即\\(n=pq\\)）。那么有\\(\\phi(q)=q-1\\)，并且由于\\(n-1=pq-1=p-1\\pmod{(q-1)}\\)，由于\\(p&gt;1\\)，因此\\(q-1\\nmid n-1\\)，这说明\\(\\text{lcm}(p-1,q-1)\\nmid\r\nn-1\\)，因此这时\\(n\\)不可能是Carmichael数。这说明Carmichael数至少有\\(3\\)个质因子。\r\n31.8-3\r\n如果\\(x^2=1\\pmod\r\nn\\)，那么变形后，可以得到\\((x+1)(x-1)=0\\pmod n\\)。也就是说，\\(n\\mid(x+1)(x-1)\\)。\r\n考虑使用反证法来证明：\r\n\r\n如果\\(\\gcd(x-1,n)=1\\)或者是\\(\\gcd(x+1,n)=n\\)，那么有\\(n\\mid(x+1)\\)，由于\\(x\\in\\mathbb{Z}_p^{\\ast}\\)，因此有\\(x=n-1\\)，它是平凡的。\r\n如果\\(\\gcd(x-1,n)=n\\)或者是\\(\\gcd(x+1,n)=1\\)，那么有\\(n\\mid(x-1)\\)，由于\\(x\\in\\mathbb{Z}_p^{\\ast}\\)，因此有\\(x=1\\)，它是平凡的。\r\n\r\n因此，只要满足了其中一个条件，即\\(\\gcd(x-1,n)\\)或\\(\\gcd(x+1,n)\\)是\\(n\\)的平凡因子，那么意味着\\(x\\)是\\(x^2=1\\pmod\r\nn\\)的平凡根。\r\n因此原结论成立。\r\n","categories":["算法导论"]},{"title":"算法导论31 Problems 答案","url":"/introduction-to-algorithms/chapter-31/problems/","content":"\r\n31-1\r\na\r\n通过推论31.4可知，由于\\(a,b\\)是偶数，因此可以写成\\(a&#39;=a/2,b&#39;=a/2\\)。代入\\(n=2\\)的情形，即可得到\r\n\\(\\gcd(a,b)=\\gcd(2a&#39;,2b&#39;)=2\\gcd(a&#39;,b&#39;)=2\\gcd(a/2,b/2)\\)\r\nb\r\n当\\(a\\)是奇数，\\(b\\)是奇数时，由于\\(2\\mid b,2\\nmid a\\)，因此\\(d=\\gcd(a,b)\\)不满足\\(2\\mid d\\)，因此对\\(b\\)抛弃质因子\\(2\\)，仍然不会对\\(d\\)值造成任何影响。故\\(\\gcd(a,b)=\\gcd(a,b/2)\\)。\r\nc\r\n我们首先证明：\\(\\gcd(a,b)=\\gcd(a-b,b)\\)。证明方式与定理31.9类似。\r\n令\\(d=\\gcd(a,b)\\)，那么\\(d\\mid a,d\\mid b\\)。根据式子31.4，有\\(d\\mid (a-b)\\)。\r\n因此有\\(\\gcd(a,b)\\mid\r\n\\gcd(a-b,b)\\)。\r\n类似的，令\\(d&#39;=\\gcd(a-b,b)\\)，那么有\\(d&#39;\\mid (a-b),d&#39;\\mid\r\nb\\)。可以将\\(a\\)写成\\(a=1\\cdot(a-b)+1\\cdot\r\nb\\)。根据式子31.4，有\\(d&#39;\\mid\r\na\\)。\r\n因此，\\(\\gcd(a-b,b)\\mid\\gcd(a,b)\\)，这说明\\(\\gcd(a,b)=\\gcd(a-b,b)\\)。\r\n此时\\(a-b\\)是偶数，\\(b\\)是奇数，根据题目33-1-b的结论，有\\(\\gcd(a-b,b)=\\gcd((a-b)/2,b)\\)。\r\n因此最终得到\\(\\gcd(a,b)=\\gcd((a-b)/2,b)\\)。\r\nd\r\n这个算法由程序GCD'给出。经过一轮迭代后，两个参数之和\\(a+b\\)的值至多是原来的\\(\\dfrac{3}{4}\\)。因此，这个程序的时间复杂度为\\(O(\\lg (a+b))=O(\\lg a)\\)。\r\nGCD&#x27;(a, b)  if a &gt; b    exchange a with b  if b == 0    return a  // 取a, b的奇偶性  (x, y) = (a &amp; 1, b &amp; 1)  if x == 1 and y == 1    return GCD&#x27;((a - b) &gt;&gt; 1, b)  else if x == 1    return GCD&#x27;(a, b &gt;&gt; 1)  else if y == 1    return GCD&#x27;(a &gt;&gt; 1, b)  else    return GCD&#x27;(a &gt;&gt; 1, b &gt;&gt; 1) &lt;&lt; 1\r\n31-2\r\n将\\(a\\)和\\(b\\)表示成一个二进制数，然后使用长除法求解\\(a,b\\)。\r\n由于商有\\(O(\\lg\r\nq)\\)位，因此需要进行\\(O(\\lg\r\nq)\\)的迭代，每轮迭代求出商的一位数值。每一轮中，需要判断当前商位的前\\(\\lg b\\)比特所表示的数是否大于等于\\(b\\)；如果大于等于\\(b\\)，那么需要做一次\\(\\lg b\\)位数的减法，商的这一位为\\(1\\)，并补上后一位数；否则什么都不做，直接补上后一位数，商的这一位为\\(0\\)。无论是比较操作还是减法操作都需要花费\\(O(\\lg\r\nb)\\)次比特操作进行。因此在整个迭代过程中共进行了\\(O(\\lg q\\lg b)\\)次比特操作。\r\n此外，还需要\\(O(\\lg\r\nb)\\)的时间来找到商的最高位。\r\n最终，因此整个操作需要\\(O((1+\\lg q)\\lg\r\nb)\\)次的位操作。\r\nb\r\n将计算\\(\\gcd(a,b)\\)转化为求解\\(\\gcd(b,a\\bmod\r\nb)\\)这个过程本质上是进行了一次取模操作。因此只需要证明这个上界值超过\\(O((1+\\lg q)\\lg b)\\)即可。\r\n\\(\\begin{aligned}\r\nc(\\mu(a,b)-\\mu(b,a\\bmod b))&amp;=c(\\mu(a,b)-\\mu(b,r))\\\\\r\n&amp;=c((1+\\lg a)(1+\\lg b)-(1+\\lg b)(1+\\lg r))\\\\\r\n&amp;=c(1+\\lg b)(\\lg a-\\lg r)\\\\\r\n&amp;\\ge c(1+\\lg b)(\\lg a-\\lg b)\\\\\r\n&amp;\\ge c/2(1+\\lg b)(1+\\lg q)&amp;\\qquad(A)\\\\\r\n&amp;\\ge c/2(1+\\lg q) \\lg b\r\n\\end{aligned}\\) 其中步骤\\((A)\\)假设了\\(c\\)足够大。通过缩减系数，来保证\\(\\lg q+1&gt;\\lg a-\\lg\r\nb\\)所产生的差值不受影响。\r\n因此，只要\\(c\\)足够大，对于足够大的所有\\(a\\)，\\(c(\\mu(a,b)-\\mu(b,a\\bmod b))\\)将会是\\(O((1+\\lg q) \\lg b)\\)的上界。\r\nc\r\n对于EUCLID算法的某个参数迭代序列\\(r_1,r_2,r_3,\\dots,r_k\\)，其中\\(r_1=a,r_2=b,r_k=0\\)，总共的比特操作次数\\(T(a,b)\\)的上界为\r\n\\(\\begin{aligned}\r\nT(a,b)&amp;\\le \\sum_{i=1}^{k-3}\r\nc(\\mu(r_i,r_{i+1})-\\mu(r_{i+1},r_{i+2}))\\\\\r\n&amp;=c(\\mu(a,b)-\\mu(r_{k-2},r_{k-1}))\\\\\r\n&amp;\\le c\\mu(a,b)\r\n\\end{aligned}\\)\r\n因此\\(T(a,b)=O(\\mu(a,b))\\)。由于\\(\\lg a=\\lg\r\nb=O(\\beta)\\)，因此更一般的情况下，有\\(T(a,b)=O(\\beta)\\)。\r\n31-3\r\na\r\n因为求解\\(F_n\\)需要求解\\(F_{n-1},F_{n-2}\\)。假设求解\\(F_n\\)所需要花费的时间为\\(T(n)\\)，那么有\r\n\\[T(n)=T(n-1)+T(n-2)+\\Theta(1)\\]\r\n我们希望证明\\(T(n)=\\Theta(F_n)\\)。\r\n首先证明\\(T(n)=O(F_n)\\)。假设对于\\(k=0,1,\\dots,n-1\\)，都有\\(T(k)\\le cF_k-c_1k\\)。考虑\\(T(n)\\)，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=T(n-1)+T(n-2)+\\Theta(1)\\\\\r\n&amp;\\le cF_{n-1}-c_1(n-1)+cF_{n-2}-c_1(n-2)+\\Theta(1)\\\\\r\n&amp;= cF_n-c_1n+(\\Theta(1)-c_1(n-3))\\\\\r\n&amp;\\le cF_n-c_1n &amp;\\qquad(A)\r\n\\end{aligned}\\)\r\n其中步骤\\((A)\\)假设了当\\(n\\)足够大时，\\(c_1(n-3)\\)的增长速度快过\\(\\Theta(1)\\)。\r\n因此有\\(T(n)=O(F_n)\\)。\r\n接下来证明\\(T(n)=\\Omega(F_n)\\)。假设对于\\(k=0,1,\\dots,n-1\\)，都有\\(T(k)\\ge cF_k+c_2k\\)。考虑\\(T(n)\\)，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=T(n-1)+T(n-2)+\\Theta(1)\\\\\r\n&amp;\\ge cF_{n-1}+c_2(n-1)+cF_{n-2}+c_2(n-2)+\\Theta(1)\\\\\r\n&amp;= cF_n+c_2n+(\\Theta(1)+c_2(n-3))\\\\\r\n&amp;\\ge cF_n+c_2n &amp;\\qquad(B)\r\n\\end{aligned}\\)\r\n其中步骤\\((A)\\)假设了当\\(n\\)足够大时才成立。\r\n因此有\\(T(n)=\\Theta(F_n)=\\Theta(\\phi^n)\\)，也就是说，\\(T(n)\\)的运行时间是指数级别的。\r\nb\r\n该题目的做法和题目14.1-6完全一致。\r\nFIB(n)  let fib[0 : n] be a new array  fib[0] = fib[1] = 1  for i = 2 to n    fib[i] = fib[i - 1] + fib[i - 2]  return fib[n]\r\nc\r\n\\(F_n\\)可以写成如下矩阵乘法的形式：\r\n\\[\r\n\\begin{bmatrix}\r\nF_n\\\\\r\nF_{n+1}\r\n\\end{bmatrix}\r\n=\r\n\\begin{bmatrix}\r\n0&amp;1\\\\\r\n1&amp;1\r\n\\end{bmatrix}\r\n\\begin{bmatrix}\r\nF_{n-1}\\\\\r\nF_{n}\r\n\\end{bmatrix}\r\n\\]\r\n那么为了计算\\(F_n\\)，将上式写成矩阵的幂，有\r\n\\[\r\n\\begin{bmatrix}\r\nF_n\\\\\r\nF_{n+1}\r\n\\end{bmatrix}\r\n=\r\n\\begin{bmatrix}\r\n0&amp;1\\\\\r\n1&amp;1\r\n\\end{bmatrix}^k\r\n\\begin{bmatrix}\r\nF_{0}\\\\\r\nF_{1}\r\n\\end{bmatrix}\r\n\\]\r\n对于一个\\(2\\times\r\n2\\)矩阵自乘的运算，可以使用\\(8\\)次乘法和\\(4\\)次加法完成。\r\n假设子程序MUL-MATRIX(A, B)是将两个矩阵相乘的乘法，那么可以写出这个算法的伪代码FIB'，其计算时间复杂度为\\(O(\\lg n)\\)。\r\nFIB&#x27;(n)  A = [[0], [1]]  B = [[0, 1], [1, 1]]  while n &gt; 0    if n &amp; 1      A = MUL-MATRIX(B, A)    B = MUL-MATRIX(B, B)  return A[0, 0]\r\nd\r\n由于\\(\\beta\\)是\\(n\\)的位数，因此有\\(\\beta=\\Theta(\\lg n)\\)。\r\n对于题目31-3-a的算法，它总共执行了\\(\\Theta(T(n))\\)次加法，因此其时间复杂度为\\(\\Theta(\\phi^n\\cdot\\lg n)\\)。\r\n对于题目31-3-b的算法，它总共执行了\\(n-1\\)次加法，因此其时间复杂度为\\((n-1)\\Theta(\\beta)=\\Theta(n\\lg n)\\)。\r\n对于题目31-3-c的算法，它一共执行了\\(\\Theta(\\lg\r\nn)\\)次的矩阵操作，并且每次算法最多只包含\\(8\\)次乘法，\\(4\\)次加法，因此其时间复杂度为\\(\\Theta(\\lg\r\nn)\\cdot(8\\Theta(\\beta^2)+4\\Theta(\\beta))=\\Theta(\\lg ^3n)\\).\r\n31-4\r\na\r\n如果\\(\\mathbb{Z}_p^{\\ast}\\)中的两个不同数\\(x,y\\)它们的平方值相同，那么有\\(x^2=y^2\\pmod p\\)，即\\((x+y)(x-y)=0\\pmod p\\)。那么由于\\(x\\neq y\\)，有\\(x+y\\equiv 0\\pmod p\\)。因此这两个数在\\(\\mathbb{Z}_p^{\\ast}\\)中是互为“相反数”。\r\n也就是说，如果\\(x^2=a\\pmod\r\np\\)，那么同样有\\((p-x)^2=a\\pmod\r\np\\)。\\((x,p-x)\\)是成对出现的。而\\(\\mathbb{Z}_p^{\\ast}\\)中有\\(p-1\\)个元素，因此\\(\\mathbb{Z}_p^{\\ast}\\)中二次剩余为\\(\\dfrac{p-1}{2}\\)个，\r\nb\r\n这个二次剩余的判别法称为欧拉准则。\r\n首先，先证明\\(a^{(p-1)/2}\\bmod\r\np\\)的值要么为\\(1\\)，要么为\\(-1\\)。通过费马小定理可以知道，\\(a^{p-1}=1\\pmod p\\)，并且\\(p-1\\)是个偶数，因此对费马小定理的式子进行化简，可以得到\r\n\\[(a^{(p-1)/2}+1)(a^{(p-1)/2}-1)=0\\pmod\r\np\\]\r\n由于\\(p\\)是质数，因此\\(a^{(p-1)/2}\\bmod p\\)的值要么为\\(1\\)，要么为\\(-1\\)，才能确保上式成立。\r\n令\\(g\\)是\\(\\mathbb{Z}_{p}^{\\ast}\\)中的一个原根，那么\\(\\mathbb{Z}_{p}^{\\ast}\\)中所有的元素都可以通过\\(g^1,g^2,\\dots,g^{p-1}\\)来表示出。\r\n如果\\(a\\)是一个二次剩余，那么\\(\\exists x\\in\r\n\\mathbb{Z}_{p}^{\\ast}\\)使得\\(x^2=a\\pmod\r\np\\)成立，此时有\\(\\left(\\dfrac{a}{p}\\right)=a^{(p-1)/2}=x^{p-1}=1\\pmod\r\np\\)。\r\n否则，如果\\(a\\)不是二次剩余，那么存在整数\\(i\\)使得\\(a=g^{2i+1}\\)。那么有\\(\\left(\\dfrac{a}{p}\\right)=a^{(p-1)/2}=(g^{2i+1})^{(p-1)/2}=(g^{(p-1)/2})^{2i+1}=(-1)^{2i+1}=-1\\pmod\r\np\\)。\r\n接下来解释为什么\\(g^{(p-1)/2}=-1\\pmod\r\np\\)。这是因为\\(g\\)是原根，生成群\\(\\langle\r\ng\\rangle\\)中的元素各不相同，又因为\\(g^{p-1}=1\\pmod p\\)，所以\\(g^{(p-1)/2}=-1\\pmod p\\)。\r\n判断\\(a\\)是否为二次剩余的算法由IS-QUADRATIC-RESIDUE给出。它使用了MODULAR-EXPONENTIATION作为子程序来计算\\(a^{(p-1)/2}\\bmod\r\np\\)的值，因此其时间复杂度为\\(O(\\lg\r\np)\\)。\r\nIS-QUADRATIC-RESIDUE(a, p)  return MODULAR-EXPONENTIATION(a, (p - 1) / 2, p) == 1\r\n如果不忽略运算操作本身的开销，那么如下考虑：这个子程序进行了\\(O(\\lg\r\np)\\)次迭代，每次迭代中进行了常数次的乘法计算和取模计算，每次计算需要进行\\(O(\\lg^2p)\\)比特的开销。因此这个判断算法的时间复杂度为\\(O(\\lg^3p)\\)。\r\nc\r\n按照勒让德符号的定义，如果\\(a\\)是模\\(p\\)下的一个二次剩余，并且\\(p=4k+3\\)，那么有\r\n\\(\\left(\\dfrac{a}{p}\\right)=a^{(p-1)/2}=a^{2k+1}=1\\pmod\r\np\\)\r\n在这里，只需要验证\\(a^{k+1}\\)是否为\\(a\\)的平方根即可，有\r\n\\(\\begin{aligned}\r\n(a^{k+1})^2&amp;=a^{2k+2}\\\\\r\n&amp;=a\\cdot a^{2k+1}\\\\\r\n&amp;=a&amp;\\pmod p\r\n\\end{aligned}\\)\r\n因此\\(a^{k+1}\\)是\\(a\\)的平方根。计算这个值只需要调用MODULAR-EXPONENTIATION(a, (p + 1) / 2, p)即可。其运行时间和题目31-4-b分析的相同，为\\(O(\\lg\r\np)\\)。如果考虑运算操作本身的开销，那么为\\(O(\\lg ^3p)\\)。\r\nd\r\n由于非二次剩余恰好在\\(\\mathbb{Z}_p^{\\ast}\\)中只占一半，因此我们最简单的方法是在这个集合中均匀地随机选择一个元素，用欧拉准则进行判断它是否是二次剩余即可，如果不是那么就返回这个元素，算法终止；否则就继续下一次抽样。\r\n这个随机选择一个元素次数符合参数为\\(\\dfrac{1}{2}\\)的指数分布，因此这个算法的期望抽取次数为\\(2\\)。最终这个算法的期望时间复杂度和31-4-b分析的相同，为\\(O(\\lg p^3)\\)\r\n","categories":["算法导论"]},{"title":"算法导论30.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-30/exercises-1/","content":"\r\n30.1-1\r\n\\(\\begin{aligned}\r\n&amp;A(x)\\cdot B(x)\\\\\r\n=&amp;(7x^3−x^2+x−10)\\cdot(8x^3-6x+3)\\\\\r\n=&amp;7\\cdot8x^6-8x^5+(-7\\cdot 6+1\\cdot8)x^4+(7\\cdot\r\n3-1\\cdot(-6)-10\\cdot8)x^3+(-1\\cdot\r\n3+1\\cdot(-6))x^2+(1\\cdot3-10\\cdot(-6))-10\\cdot 3\\\\\r\n=&amp;56x^2-8x^5-34x^4-53x^3-9x^2+63x-30\r\n\\end{aligned}\\)\r\n30.1-2\r\n假设当前所求多项式为\\(\\displaystyle{A(x)=\\sum_{i=0}^{n-1}\r\na_ix^{i}}\\)，使用长除法来计算\\(q(x)\\)和\\(r\\)。现在考虑消去最高项\\(a_{n-1}\\)，按照长除法，次高项的系数的变化为\\(a_{n-2}&#39;=a_{n-2}+x_0\\cdot\r\na_{n-1}\\)，从而得到\\(q(x)\\)的第\\(n-2\\)项系数为\\(a_{n-1}\\)，并且消去了\\(A(x)\\)的最高次项。往下迭代，直到\\(A(x)\\)只剩最低次项的系数即可。\r\n具体过程由EVALUATE-POLY'给出，由于整个过程只有一个for循环，因此其时间复杂度为\\(\\Theta(n)\\)。\r\nEVALUATE-POLY&#x27;(A, n, x0)  Let Q[0 : n - 2] be a new array  for i = n - 1 downto 1    Q[i - 1] = A[i]    A[i - 1] = A[i - 1] + x0 * A[i]  r = A[0]  return Q, r\r\n30.1-3\r\n对于多项式\\(A(x)\\)中的某个点值对为\\((x_0,A(x_0))\\)，我们可以计算出\\(A^{\\text{rev}}(x)\\)的某个点值对\\(\\left(\\dfrac{1}{x_0},A^{\\text{rev}}\\left(\\dfrac{1}{x_0}\\right)\\right)\\)，其中\\(A^{\\text{rev}}\\left(\\dfrac{1}{x_0}\\right)\\)可以如下进行计算：\r\n\\(\\begin{aligned}\r\nA^{\\text{rev}}\\left(\\dfrac{1}{x_0}\\right)&amp;=\\sum_{j=0}^{n-1}\r\na_{n-1-j} x_0^{-j}\\\\\r\n&amp;=\\sum_{j=0}^{n-1} a_jx_0^{j-(n-1)}\\\\\r\n&amp;=x_0^{1-n} \\sum_{j=0}^{n-1} a_jx_0^{j}\\\\\r\n&amp;=x_0^{1-n} A(x_0)\r\n\\end{aligned}\\)\r\n由于每一个点值对的点\\(x_i\\)都不为\\(0\\)，因此\\(A(x)\\)中的每个点值对\\((x_i,A(x_i))\\)对应着\\(A^{\\text{rev}}(x)\\)的\\(\\left(\\dfrac{1}{x_i},x_i^{1-n}\r\nA(x_i)\\right)\\)\r\n30.1-4\r\n假设现在存在一个\\(x\\)坐标两两不同的点集\\(P\\)，其大小为\\(n-1\\)。令\\(P_1=P\\cup\\{(x_{n-1},y_{n-1})\\},P_2=P\\cup\\{(x_{n-1},y_{n-1}&#39;)\\}\\)，其中\\(\\forall j\\in[0,n-2],x_{n-1}\\neq\r\nx_{j}\\)，并且有\\(y_{n-1}\\neq\r\ny&#39;_{n-1}\\)。按照定理30.1，节点集合\\(P_1\\)可以构造出一个\\(n\\)元一次方程组\\(\\mathbf{Xa=y_1}\\)，并且是存在唯一解向量\\(\\mathbf{a_1}\\)。类似的，节点集合\\(P_2\\)也能够造出一个\\(n\\)元一次方程组\\(\\mathbf{Xa=y_2}\\)，并且存在唯一解向量\\(\\mathbf{a_2}\\)。由于这两个方程的系数矩阵相同，常数向量不相同，因此解\\(\\mathbf{a_1}\\)和\\(\\mathbf{a_2}\\)必定不相同。这确定出了两个不相同的多项式，因此原结论成立。\r\n30.1-5\r\n整个过程由程序INTERPOLATE给出。第1-7行使用普通的乘法计算出多项式\\(\\displaystyle{C(x)=\\sum_{i=0}^{n-1}(x-x_i)}\\)的系数，可见是两个for循环的嵌套，因此总共花费了\\(\\Theta(n^2)\\)的时间。在后面的for循环中，首先调用了一次EVALUATE-POLY'来计算得到\\(\\displaystyle{\\sum_{j\\neq\r\nk}(x-x_j)}\\)的系数，花费了\\(\\Theta(n)\\)的时间，然后使用了\\(\\Theta(n)\\)的时间计算出了值\\(\\displaystyle{\\sum_{j\\neq\r\nk}(x_k-x_j)}\\)，接下来使用了\\(\\Theta(n)\\)的时间对\\(A\\)的每一个系数都进行了一次更新。因此后面第9-16行的for循环花费的时间也是\\(\\Theta(n^2)\\)。总而言之，算法INTERPOLATE花费了\\(\\Theta(n^2)\\)的时间来完成差值。\r\n// 点集P中的每个元素有两个属性x和y，表示点的坐标。INTERPOLATE(P, n)  C = [1]       // 0-index  for i = 0 to n - 1    let B[0 : i] be a new array by 0    for j = 0 to i      B[i] = B[i] - P[i].x * A[i]      B[i + 1] = B[i + 1] + A[i]    C = B  let A[0 : n - 1] be a new array by 0  for k = 0 to n - 1    Q, r = EVALUATE-POLY&#x27;(A, n + 1, P[k].x)    m = 1    for j = 0 to n - 1      if j != k        m = m * (P[k].x - P[j].x)    for j = 0 to n - 1      A[j] = A[j] + P[j].y / m * Q[j]  return A\r\n30.1-6\r\n令\\(P,Q\\)分别表示两个多项式，使用点值表示法。我们考虑计算\\(R=P/Q\\)。可能出现的错误如下：\r\n\r\n当\\(Q\\)中的某些点的\\(y\\)坐标为\\(0\\)时，直接整除法不可行，需要舍弃掉对应\\(x\\)坐标下分别在\\(P,Q\\)中的两个点，这时并没有确定结果。\r\n如果错误1不存在，那么可以使用对应的除法计算出确定结果的点集\\(R\\)。但是，\\(P/Q\\)不一定是一个多项式（如\\(P(x)=x^2+1,Q(x)=x+2\\)），计算出来的点集\\(R\\)虽然存在一个多项式进行对应，但是在系数形式下，验算\\(R\\cdot Q\\)的结果将会发现不为\\(P\\)。\r\n\r\n因此，只有在\\(Q\\)是\\(P\\)的一个因子，并且\\(Q\\)中不包含\\(y\\)坐标为\\(0\\)的点，普通的坐标除法才能够给出正确的答案。\r\n30.1-7\r\n对集合\\(A\\)定义多项式\\(\\displaystyle{p_A(x)=\\sum_{i=0}^{10n}\r\na_ix^{i}}\\)，其中，对于整数\\(x\\in[0,10n]\\)，如果\\(x\\in A\\)，那么\\(a_x=1\\)，否则\\(a_x=0\\)；对集合\\(B\\)也可以定义类似的多项式\\(\\displaystyle{p_B(x)=\\sum_{i=0}^{10n}\r\nb_ix^{i}}\\)。FFT算法可以以\\(O(10n\\lg(10n))=O(n\\lg\r\nn)\\)的时间内计算出多项式\\(\\displaystyle{p_C(x)=p_A(x)\\cdot\r\np_B(x)=\\sum_{i=0}^{20n} c_ix^{i}}\\)的所有系数。\r\n那么可以求出\\(C=\\{x:c_x&gt;0,x\\in[0,20n]\\}\\)。并且，\\(c_x\\)表示元素\\(x\\)在集合\\(C\\)中出现的次数。\r\n","categories":["算法导论"]},{"title":"算法导论25 Problems 答案","url":"/introduction-to-algorithms/chapter-25/problems/","content":"\r\n25-1\r\na\r\n证明方式和题目20-3-a相似。\r\n充分性：由于\\(G\\)有一条欧拉回路\\(C\\)，因此在\\(C\\)中，当有一条入边进入节点\\(v\\)，总有一条出边离开节点\\(v\\)（重复经过节点\\(v\\)的无向边是不同的）。由于这些边恰好包含了\\(E\\)中所有的边各一次，只要\\(v\\)在\\(C\\)上出现了\\(k_v\\)次，那么就有\\(k_v\\)条不同的无向边进入\\(C\\)，\\(k_v\\)条不同的无向边离开\\(v\\)，那么\\(v\\)的度数为\\(2k_v\\)，即所有节点的度数都是偶数，原结论成立。\r\n必要性：对于任意一条从\\(s\\)出发的一条路径\\(P\\)，它必定能回到\\(s\\)，使用反证法证明这个结论。如果从\\(s\\)出发存在一条路径它不能回到\\(s\\)，也就是说，有一条路径\\(P&#39;\\)是\\(s-v_1-v_2-\\dots-v_k\\)，并且\\(v_k\\neq s\\)，并且从\\(v_k\\)之后所有已经没有出边可走。那么令\\(v=v_k\\)，统计路径\\(P&#39;\\)得到\\(v\\)的出现次数为\\(k\\)，那么可以知道离开\\(v\\)的边数为\\(k-1\\)（因为已经没有边走出来了），而进入\\(v\\)的边数为\\(k\\)，那么节点\\(v\\)的度数为\\(2k-1\\)，这和节点\\(v\\)是偶数的结论矛盾，因此\\(P\\)必定是一条回路。那么，接下来我们找出\\(G\\)的其中一条回路\\(C_1\\)，那么如果\\(C_1\\)是一条欧拉回路，那么完成；否则，去除\\(C_1\\)中的所有边，节点度数的性质仍然保持不变，由于\\(G\\)是连通图，那么可以找到另一条和\\(C_1\\)点相交，边不相交的回路\\(C_2\\)，并且将交点一处整合成一条回路（如下图所示），直到所有的边都已经被使用。\r\n\r\n如图所示，我们已经找到了两个环\\(C_1:b-d-a-b\\)和\\(C_2: b-e-c-b\\)，那么我们可以整合成回路\\(C:b-d-a-b-c-e-b\\)。\r\nb\r\n该算法EULER-CYCLE'和题目20-3-b所提出的类似，区别在于EULER-CYCLE在访问完一条边\\((u,v)\\)后，需要在\\(v\\)的邻接表删除一个\\(u\\)。\r\nEULER-CYCLE-UNDIRECTED-DFS(G, A, u)  while G.Adj[u] != ∅    select v from G.Adj[u] randomly and remove it from G.Adj[u]    remove a u from G.Adj[v]    dfs(v)  INSERT(A, u)EULER-CYCLE-UNDIRECTED(G)  select s ∈ G.V randomly  Let A be new array  EULER-CYCLE-DFS(G, A, s)  reverse A  return A\r\nc\r\n对于一个\\(1\\)-正则图\\(G_1=(V,E_1)\\)，由于每个节点的度数均为\\(1\\)，因此仅有\\(1\\)个节点与它相邻。因此\\(G_1\\)的节点个数必定为偶数，且\\(E_1\\)是它的一个完美匹配。\r\n对于一个\\(2^k\\)-正则二分图\\(G_{2^k}=(V,E_{2^k}),V=L\\cup\r\nR\\)，由于所有节点的度数都为偶数，因此\\(G_{2^k}\\)必定存在一条欧拉回路\\(C\\)。并且\\(C\\)为\\(E\\)中的所有无向边都指定了一个方向，并且这条回路的节点是\\(L,R\\)相间的。不失一般性，我们去掉所有从\\(R\\)到\\(L\\)定向的所有边，那么每个节点的度数只剩下原来的一半，即\\(2^{k-1}\\)，剩下的图是一个\\(2^{k-1}\\)-正则图，那么继续递归进行操作，直到这个图是一个\\(1\\)-正则图，那么我们就得到了\\(G_{2^k}\\)的一个完美匹配。如果我们去掉的是从\\(L\\)到\\(R\\)定向的所有边，那么接下来得到的完美匹配和前面得到的完美匹配是不相交的。\r\n最终，整个问题相当于使用了一次分治算法。具体过程由GEN-DISJOINT-PERFECT-MATCHING给出。\r\nGEN-DISJOINT-PERFECT-MATCHING-AUX(G, A)  if |G.E| * 2 == |G.V|    INSERT(A, G.E)  else    E1 = Ø    E2 = Ø    P = EULER-CYCLE-UNDIRECTED(G)    for i = 2 to P.size      if i % 2 == 0        E1 = E1 ∪ &#123;P[i - 1], P[i]&#125;      else        E2 = E2 ∪ &#123;P[i - 1], P[i]&#125;    GEN-DISJOINT-PERFECT-MATCHING-AUX((G.V, E1), A)    GEN-DISJOINT-PERFECT-MATCHING-AUX((G.V, E2), A)GEN-DISJOINT-PERFECT-MATCHING(G)  Let A be a new array  GEN-DISJOINT-PERFECT-MATCHING-AUX(G, A)\r\n接下来考虑程序GEN-DISJOINT-PERFECT-MATCHING-AUX的时间复杂度。每次调用GEN-DISJOINT-PERFECT-MATCHING-AUX时，首先都会对\\(G\\)中的所有边进行\\(O(1)\\)时间的处理，接下来将这些边进行均匀地分成两部分进行递归处理。由于这个程序最多递归\\(\\lg d\\)层，因此整个程序的时间复杂度为\\(O(E\\lg d)\\)。\r\n25-2\r\na\r\nFIND-AUGMENTING-PATH的第10行代码可以改等价地改为\\(\\delta=\\min\\{r.\\sigma:r\\in\r\nR-F_R\\}\\)，它将可以遍历所有\\(R-F_R\\)中的节点进行求出，因此时间复杂度为\\(O(n)\\)。\r\nb\r\n在第11-14行结束后，\\(F_L\\)中每个\\(l\\)节点的属性\\(h\\)都减少了\\(\\delta\\)，而对于\\(r\\in R-F_r\\)，属性\\(h\\)的值未曾改变。按照\\(\\sigma\\)参数的定义：\\(r.\\sigma=\\min\\{l.h+r.h-w(l,r):l\\in\r\nF_L\\}\\)可以得知，\\(r.\\delta\\)减少了\\(\\delta\\)。因此只需要插入如下两行代码就可以以\\(O(n)\\)的时间完成对\\(R-F_R\\)所有节点\\(\\delta\\)属性的更新。\r\nfor each vertex r ∈ R - FR  r.δ = r.δ - δ\r\nc\r\n只需要在每次对集合\\(F_L\\)更新时，对\\(R-F_R\\)中的所有节点的\\(\\delta\\)属性进行进行更新即可，一次刷新只需要\\(O(n)\\)的时间。由于FIND-AUGMENTING-PATH的增长步数最多只有\\(n\\)次，因此这个步骤在一次调用FIND-AUGMENTING-PATH中，所需要花费的时间为\\(n\\cdot O(n)=O(n^2)\\)。\r\n也就是说，只需要在第26行的下面插入如下两行代码即可。\r\nfor each vertex r ∈ R - FR  r.δ = min&#123;r.δ, v.h + r.h - w(v, r)&#125;\r\nd\r\n经过修改后，以及题目25.3-5的修改，得到新版的寻找増广路径算法为FIND-AUGMENTING-PATH'''如下。\r\nFIND-AUGMENTING-PATH&#x27;&#x27;&#x27;(w, n, h, match)  Q = Ø  FL = Ø  FR = Ø  for each unmatched vertex l ∈ L    l.π = NIL    ENQUEUE(Q, l)    FL = FL ∪ &#123;l&#125;  for each vertex r in R    r.δ = min&#123;h[l] + h[r] − w(l, r) : l ∈ FL&#125;  repeat    if Q is empty      δ = min &#123; h[l] + h[r] − w(l, r) : l ∈ FL and r ∈ R − FR &#125;      for each vertex l ∈ FL        h[l] = h[l] − δ      for each vertex r ∈ FR        h[r] = h[r] + δ      for each vertex r ∈ R - FR        r.δ = r.δ - δ        if r.δ == 0          for each l ∈ FL            if h[l] + h[r] == w(l, r)              r.π = l              break          if match[r] == 0            // 代表r仍然未被匹配            an M-augmenting path has been found (exit the repeat loop)          else             ENQUEUE(Q, r)            FR = FR ∪ &#123;r&#125;    u = DEQUEUE(Q)    if 1 &lt;= u &lt;= n      // 这时u是左部节点      for r = n + 1 to n + n        if h[u] + h[r] == w(u, r) and r ∉ FR           r.π = u          if match[r] == 0            an M-augmenting path has been found (exit the repeat loop)          else            ENQUEUE(Q, r)            FR = FR ∪ &#123;r&#125;    else      // 这时u是右部节点      l = match[u]      l.π = u      FL = FL ∪ &#123;l&#125;      ENQUEUE(Q, l)      for each vertex r ∈ R - FR        r.δ = min&#123;r.δ, l[h] + r[h] - w(v, r)&#125;  until an M-augmenting path has been found  using the predecessor attributes π, construct an M-augmenting path P by tracing back from the unmatched vertex in R  return P\r\n在程序FIND-AUGMENTING-PATH'''的repeat ... until循环中，所有的for循环都是线性的。中间那个用于更新\\(R-F_R\\)中每个节点的\\(\\delta\\)属性的for循环中，内部的for循环每个节点\\(r\\)节点最多只能进入一次，然后要么找到了增广路径，repeat ... until跳出，要么被添加进集合\\(F_R\\)中，之后再也不会进入。除此之外，repeat ... until循环体内的其它所有for循环都是单层的。因此一次repeat ... until循环的时间复杂度为\\(O(n)\\)，调用一次FIND-AUGMENTING-PATH'''所需要花费的时间为\\(O(n^2)\\)。\r\n由于匈牙利算法至多需要寻找\\(n\\)次增广路径，因此优化后的匈牙利算法的时间复杂度为\\(n\\cdot O(n^2)=O(n^3)\\)。\r\n25-3\r\na\r\n对于原二分图\\(G=(V,E),V=L\\cup\r\nR\\)，可以构造完全二分图\\(G&#39;=(V,E&#39;)\\)，即对于\\(\\forall l\\in L,r\\in R\\)，都有\\((l,r)\\in E&#39;\\)。对于\\(\\forall (l,r)\\in E\\)，有\\(w&#39;(l,r)=w(l,r)\\)，对于\\(\\forall (l,r)\\in E&#39;-E\\)，有\\(w&#39;(l,r)=-\\infty\\)。使用图\\(G&#39;\\)运行匈牙利算法的结果即为所求。\r\nb\r\n与题目25-3-a建立的图\\(G&#39;\\)一致。令\\(\\delta=\\min\\{x(l,r)\\mid(l,r)\\in\r\nE\\}\\)。对于\\(\\forall (l,r)\\in\r\nE\\)，有\\(w&#39;(l,r)=w(l,r)+\\delta+1\\)，对于\\(\\forall (l,r)\\in E&#39;-E\\)，有\\(w&#39;(l,r)=-\\infty\\)。由于\\(G\\)必定包含一个完美匹配，因此使用图\\(G&#39;\\)运行匈牙利算法的结果即为所求。\r\nc\r\n考虑将图\\(G=(V,E)\\)中的每个节点\\(v\\)拆分成两个节点\\(v_{in},v_{out}\\)。通过图\\(G\\)，构造二分图\\(G&#39;=(V&#39;,E&#39;),V&#39;=L\\cup\r\nR\\)，其中\\(L=\\{v_{out}\\mid v\\in\r\nV\\},R=\\{v_{in}\\mid v\\in V\\}\\)。对于\\(\\forall (u,v)\\in E\\)，都有\\((u_{out},v_{in})\\in E&#39;\\)，并且\\(w&#39;(u_{out},v_{in})=w(u,v)\\)。使用题目25-3-b的构造方法，对图\\(G&#39;\\)求出的一个最大二分匹配\\(M&#39;\\)，所在\\(E\\)对应的边集\\(M\\)即为所求。因为在\\(M&#39;\\)中，\\(G&#39;\\)的所有节点都出现了一次。也就是说，在图\\(G\\)中，求出来的\\(M\\)都代表了每个节点的一条出边和入边，这意味着这些节点只在一个环中。\r\n25-4\r\na\r\n\\(M^{\\ast}\\)是最大匹配的一个最优解，并且假设任意匹配的空间为\\(S\\)，那么有\\(M^{\\ast}\\in\r\nS\\)。对于分数匹配，假设任意匹配的空间为\\(S&#39;\\)，对于所有的边，都有\\(x(l,r)\\in[0,1]\\)而非\\(\\{0,1\\}\\)，因此\\(S\\subseteq\r\nS&#39;\\)，即最大匹配的所有解也是最大分数匹配的解。由于\\(M^{\\ast}\\)是最大匹配，因此\\(\\forall M\\in S,|M|\\le\r\n|M^{\\ast}|\\)均成立，即\\(M^{\\ast}\\)是\\(S\\)中的一个全局最优解，但是\\(M^{\\ast}\\)在\\(S&#39;\\)中只是一个局部最优解，那么存在一个全局最优解\\(x^{\\ast}\\in S&#39;\\)使得\\(|x^{\\ast}|\\ge\r\n|M^{\\ast}|\\)，原结论成立。\r\nb\r\n考虑\\(G=(V,E)\\)中的其中一个分数匹配\\(x\\)。那么考虑将\\(x\\)转换成一个不会更劣的整数匹配\\(x&#39;\\)。\r\n首先考虑边集\\(H=\\{(u,v)\\in\r\nE,0&lt;x(u,v)&lt;1 \\}\\)。如果\\(H\\)为空，那么整个过程完成。如果\\(H\\)为空，那么整个过程结束。如果\\(H\\)包含一个环\\(C\\)，那么由于\\(G\\)是一个二分图，因此\\(C\\)必定是个偶环。为这个环\\(C\\)中的所有边进行定向得到有向环\\(C&#39;\\)，那么\\(C&#39;\\)中必定有\\(|C|/2\\)条边是从\\(L\\)指向\\(R\\)的，有\\(|C|/2\\)条边是从\\(R\\)指向\\(L\\)的。令\\(E_{L}=\\{(l,r)\\mid (l,r)\\in C&#39;,l\\in L,r\\in\r\nR\\},E_R=C&#39;-E_L\\)\r\n不失一般性，考虑消去一条\\(E_R\\)中的边。令\\(\\delta=\\min\\{x(l,r)\\mid(l,r)\\in\r\nE_R\\}\\)。那么构造新的分数匹配\\(x&#39;\\)：\r\n\\(x&#39;(l,r)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;x(l,r)+\\delta &amp; &amp; \\text{if}\\quad  (l,r)\\in E_L \\\\\r\n  &amp;x(l,r)-\\delta &amp; &amp; \\text{if}\\quad  (l,r)\\in E_R \\\\\r\n  &amp;x(l,r) &amp; &amp; \\text{if}\\quad  (l,r)\\in E-C \\\\\r\n\\end{aligned}\\right.\\)\r\n那么在下一轮迭代中，由\\(x&#39;\\)所诱导出来的边集\\(H&#39;\\)至少比原来少一条边。最终直到\\(H&#39;\\)没有环为止。\r\n现在，假设由\\(x\\)诱导出来的边集\\(H\\)是没有环的。令\\(P\\)是\\(H\\)中的其中一条最长路，令\\(s_P,t_P\\)表示\\(P\\)的起点和终点，那么\\(s_P\\)和\\(t_P\\)除了\\(H\\)中的边，其他与\\(s_P\\)或\\(t_P\\)相邻的边的分数值\\(x\\)为\\(0\\)，因为如果为\\(1\\)，那么\\(s_P\\)或\\(t_P\\)的分数之和大于\\(1\\)，这是不可能的；如果位于区间\\((0,1)\\)，那么与\\(s_P,t_P\\)相邻的这些边也会在\\(H\\)中，这不是一条最长路。\r\n那么接下来，每次找到一条关于边集\\(H\\)中长度为\\(2\\)的路径，并且这条路径中某个节点在\\(H\\)中出现\\(1\\)次。不失一般性，假设这条路径为\\(a-b-c\\)，并且\\(a\\)在\\(H\\)中只出现一次。那么考虑去掉边\\((b,c)\\)，令\\(x&#39;(a,b)=x(a,b)+x(b,c),x&#39;(b,c)=0\\)（注意此处的\\(a\\)边权之和仍然不会超出\\(1\\)，因为\\(b\\)的边权和不变）。最终得到的新匹配\\(x&#39;\\)所诱导的边集\\(H&#39;\\)也会少一条边，最终直到\\(H\\)不存在长度为\\(2\\)以上的路径。\r\n最终，对于\\(\\forall\r\n(u,v):x(u,v)&gt;0\\)，由于\\(H\\)中不存在长度至少为\\(2\\)的路径，因此只需要令\\(x&#39;(u,v)=1\\)。那么得到\\(x&#39;(u,v)\\ge\r\nx(u,v)\\)。最终得到了一个比分数匹配可能更优的整数匹配，原结论成立。\r\n大致的过程由GEN-INTEGER-MATCHING给出。\r\nGEN-INTEGER-MATCHING(G, x)  while the edge set H = &#123;(u, v) |(u, v) ∈ G.E, 0 &lt; x(u, v) &lt; 1&#125; still contain a cycle C    generate the directed cycle C&#x27; from C    EL = &#123;(l, r) ∣ (l, r) ∈ C&#x27;, l ∈ L, r ∈ R&#125;    ER = H - EL    δ = min&#123;x(l, r) ∣ (l, r) ∈ ER&#125;    for each edge (u, v) in EL      x(u, v) = x(u, v) + δ    for each edge (u, v) in ER      x(u, v) = x(u, v) - δ  while the longest path length of (V, H) exceeds 2    let a - b - c be a path of length of 2 s.t. a incident only once in H    x(a, b) = x(a, b) + x(b, c)    x(b, c) = 0  E = Ø  for each edge (u, v) in G.E    if x(u, v) &gt; 0      E = E ∪ &#123;(u, v)&#125;  return E\r\nc\r\n与题目25-4-b类似，改动的地方在于：\r\n\r\n当考虑是让\\(E_L\\)和\\(E_R\\)中的边消去一条时，不是再随便消去，而是计算\\(\\displaystyle{s_L=\\sum_{(u,v)\\in\r\nE_L}x(u,v)}\\)和\\(\\displaystyle{s_R=\\sum_{(u,v)\\in\r\nE_R}x(u,v)}\\)的值，如果\\(s_L&gt;s_R\\)，那么选择消去\\(E_R\\)的边，否则选择消去\\(E_L\\)中的边。这将会使得分数匹配的解更优。\r\n去除长度至少为\\(2\\)的路径时，不能再使用以上的方法，因为有可能\\(w(b,c)&gt;w(a,b)\\)，使得解的最优性降低。做法是：在\\(H\\)中选择一条长度至少\\(2\\)的路径\\(P\\)，并且\\(P\\)两端的节点在\\(H\\)中只出现一次。可见，\\(P\\)是一条在点集\\(L,R\\)交替的路径，为\\(P\\)进行定向得到\\(P&#39;\\)。令\\(F_{L}=\\{(l,r)\\mid (l,r)\\in P&#39;,l\\in L,r\\in\r\nR\\},F_R=P-F_L\\)，考虑从\\(F_L\\)或者\\(F_R\\)消去一条边，计算\\(\\displaystyle{t_L=\\sum_{(u,v)\\in\r\nF_L}x(u,v)}\\)和\\(\\displaystyle{t_R=\\sum_{(u,v)\\in\r\nF_R}x(u,v)}\\)的值，如果\\(t_L&gt;t_R\\)，那么选择消去\\(E_R\\)的边，否则选择消去\\(E_L\\)中的边，这个过程和为消去环的过程相同。\r\n\r\n其他过程和25-4-b一致，这说明可以将一个带权分数最大匹配转化成一个更优的带权整数最大匹配，使得原结论成立。大致的过程由GEN-INTEGER-MATCHING-WEIGHTED给出。\r\nUPDATE-X-FRACTIONAL-MATCHING(C, x, w)  generate the directed edges set C&#x27; from C s.t. all of the edges in the same direction  EL = &#123;(l, r) ∣ (l, r) ∈ C&#x27;, l ∈ L, r ∈ R&#125;  ER = H - EL  SL = 0  SR = 0  for each edge (u, v) in EL    SL = SL + w(u, v)  for each edge (u, v) in ER    SR = SR + w(u, v)  if SL &gt; SR    δ = min&#123;x(l, r) ∣ (l, r) ∈ ER&#125;    for each edge (u, v) in EL      x(u, v) = x(u, v) + δ    for each edge (u, v) in ER      x(u, v) = x(u, v) - δ  else    δ = min&#123;x(l, r) ∣ (l, r) ∈ EL&#125;    for each edge (u, v) in ER      x(u, v) = x(u, v) + δ    for each edge (u, v) in EL      x(u, v) = x(u, v) - δ  GEN-INTEGER-MATCHING(G, x, w)  while the edge set H = &#123;(u, v) |(u, v) ∈ G.E, 0 &lt; x(u, v) &lt; 1&#125; still contain a cycle C    UPDATE-X-FRACTIONAL-MATCHING(C, x, w)  while the longest path P length of (V, H) exceeds 2    UPDATE-X-FRACTIONAL-MATCHING(P, x, w)  E = Ø  for each edge (u, v) in G.E    if x(u, v) &gt; 0      E = E ∪ &#123;(u, v)&#125;  return E\r\nd\r\n令图\\(G=(V,E),V=\\{a,b,c\\},E=\\{(a,b),(b,c),(a,c)\\}\\)。\r\n那么，图\\(G\\)的最大整数匹配\\(|M^{\\ast}|\\)为\\(1\\)，为其中一条边。但图\\(G\\)的最大分数匹配\\(|x^{\\ast}|\\)为\\(1.5\\)，其中\\(x^{\\ast}(a,b)=x^{\\ast}(b,c)=x^{\\ast}(a,c)=0.5\\)。\r\n25-5\r\n令图\\(G=(V,E)\\)为题目中所给定二分图，\\(V=L\\cup\r\nR\\)。本题将考虑使用差分约束来求解。那么对于\\(\\forall l\\in L\\)，有\\(l.d=l.h\\)，并且\\(\\forall r\\in R\\)，有\\(r.d=-r.h\\)。那么给定匹配\\(M\\)，问题转化为求解所有节点的\\(d\\)属性，使得：\r\n\r\n\\(\\forall l\\in L,r\\in R,l.d-r.d\\ge\r\nw(l,r)\\)都成立。\r\n\\(\\forall (l,r)\\in M^{\\ast},l.d-r.d=\r\nw(l,r)\\)都成立。\r\n\r\n考虑构造如下约束图\\(G&#39;=(V&#39;,E&#39;)\\)。其中\\(V&#39;=V\\cup\\{v_0\\}\\)。那么考虑将如下三种边加入\\(E&#39;\\)中：\r\n\r\n\\(\\forall v\\in V,(v_0,v)\\in\r\nE\\)，都有\\(w&#39;(v_0,v)=0\\)。\r\n\\(\\forall (l,r)\\in\r\nM^{\\ast}\\)，都有\\((l,r)\\in\r\nE&#39;,w&#39;(l,r)=-w(l,r),(r,l)\\in\r\nE&#39;,w&#39;(r,l)=w(l,r)\\)。\r\n\\(\\forall (l,r)\\in\r\nE-M^{\\ast}\\)。都有\\((l,r)\\in\r\nE&#39;,w&#39;(l,r)=-w(l,r)\\)。\r\n\r\n对约束图\\(G&#39;\\)以\\(v_0\\)为起点调用BELL-MANFORD算法后，计算出了每个节点的\\(d\\)属性，那么根据\\(d\\)属性可以计算出\\(h\\)属性，最终\\(h\\)属性为所求。整个算法的时间复杂度为\\(O(|V|^3)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论30.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-30/exercises-3/","content":"\r\n30.3-1\r\n经过蝴蝶变换，得到\\(A\\)的新序列为\\(A&#39;=(0,4,3,7,2,5,-1,9)\\)。\r\n以下是自底向上的DFT过程：\r\n\\(\\begin{array}{|l|l|}\\hline\r\ns&amp;\\\\\\hline\r\n0&amp;[0],[4],[3],[7],[2],[5],[-1],[9]\\\\\\hline\r\n1&amp;[4,-4],[10,-4],[7,-3],[8,-10]\\\\\\hline\r\n2&amp;[14,-3-3i,-8,-3-3i],[15,3+4i,-13,3-4i]\\\\\\hline\r\n3&amp;\\left[19,\\left(-4+\\dfrac{7\\sqrt{2}}{2}\\right)-\\left(4+\\dfrac{13\\sqrt{2}}{2}\\right)i,-6+i,-\\left(4+\\dfrac{7\\sqrt{2}}{2}\\right)+\\left(4-\\dfrac{13\\sqrt{2}}{2}\\right)i,-1,-\\left(4+\\dfrac{7\\sqrt{2}}{2}\\right)-\\left(4-\\dfrac{13\\sqrt{2}}{2}\\right)i,-6-i,\\left(-4+\\dfrac{7\\sqrt{2}}{2}\\right)+\\left(4+\\dfrac{13\\sqrt{2}}{2}\\right)i\\right]\\\\\\hline\r\n\\end{array}\\)\r\n30.3-2\r\n考虑图30.6的FFT电路。在第\\(s\\)个阶段，有\\(\\dfrac{n}{2^s}\\)个蝶形电路组，从上到下分别编号\\(0\\sim\r\n\\dfrac{n}{2^s}-1\\)，在每个蝶形电路组中，有\\(2^{s-1}\\)个蝶形电路组，假设从上到下编号为\\(0\\sim 2^{s-1}-1\\)。\r\n那么对于第\\(k\\)条导线，它在第\\(s\\)阶段是在蝶形电路组\\(\\left\\lfloor\\dfrac{\\text{rev}(k)}{2^s}\\right\\rfloor\\)，在这个组内的编号为\\(\\text{rev}(k)\\bmod {2^{s-1}}\\)。\r\n也就是说，对于第\\(s\\)个阶段第\\(g\\)个蝶形电路组的的第\\(j\\)个蝶形电路，其输入和输出的两条引线的编号为\\(\\text{rev}(g\\cdot 2^s+j)\\)和\\(\\text{rev}(g\\cdot 2^s+j+2^{s-1})\\)。\r\n30.3-3\r\n假设\\(k\\)是一个01列向量\\(k=(b_0,b_1,\\dots,b_{n-1})^T\\)。那么由于是对向量\\(k\\)进行逆序，即相当于将位置\\(i\\)上的比特转移到位置\\(n-1-j\\)。因此，\\(M\\)矩阵的构造如下：\r\n\\[\r\nm_{ij}=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1  &amp; &amp; \\text{if}\\quad i+j=n-1 \\\\\r\n  &amp;0  &amp; &amp; \\text{if}\\quad i+j\\neq n-1 \\\\\r\n\\end{aligned}\\right.\r\n\\]\r\n考虑向量\\(z=Mk\\)，那么计算向量\\(z_i\\)元素的值，有\\(\\displaystyle{z_i=\\sum_{j=0}^{n-1}m_{ij}k_j=k_{n-1-j}}\\)。因此构造出的矩阵\\(M\\)为所求。事实上，\\(M\\)的形式如下：\r\n\\[\r\n\\begin{bmatrix}\r\n0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 1\\\\\r\n0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 1 &amp; 0\\\\\r\n0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0\\\\\r\n\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp;\r\n\\vdots\\\\\r\n0 &amp; 1 &amp; 0 &amp;\\cdots &amp; 0 &amp; 0\\\\\r\n1 &amp; 0 &amp; 0 &amp;\\cdots &amp; 0 &amp; 0\r\n\\end{bmatrix}\r\n\\]\r\n30.3-4\r\n蝴蝶变换的本质是将数组\\(a\\)中，对若干对数交换位置。因此可以通过BIT-REVERSE-OF计算出新位置后原地交换。由于\\(i =\r\n\\text{rev}(\\text{rev}(i))\\)，因此只有当\\(\\text{rev}(i)&lt;\r\ni\\)时才交换这两个数的位置。\r\nBIT-REVERSE-PERMUTATION(a, n)  b = lg(n)  for k = 0 to n - 1    i = BIT-REVERSE-OF(k, b)    if k &lt; i      exchange a[i] with a[k]\r\n\\(\\star\\)\r\n30.3-5\r\n对于\\(i\\in[0,n)\\)，输入\\(a_i=i+1\\)。那么电路相当于计算多项式\\(\\displaystyle{A(x)=\\sum_{i=0}^{n-1}(i+1)\\cdot\r\nx^i}\\)，当\\(x\\neq\r\n1\\)时，可以得到\\(A(x)=\\dfrac{nx^{n+1}-(n+1)x^n+1}{(x-1)^2}\\)。（选择这种系数的原因是，确保了不会有任何一个中间电路的输出值是\\(0\\)）\r\n对于\\(k\\in[0,n)\\)，考虑计算\\(y_k=A(\\omega_n^k)\\)的值，那么有\r\n\\(y_k=\r\n\\left \\{\\begin{aligned}\r\n  &amp;\\dfrac{n(n+1)}{2} &amp; &amp; \\text{if}\\quad  k=0 \\\\\r\n  &amp;\\dfrac{n}{1-\\omega_n^k} &amp; &amp;\r\n\\text{if}\\quad  k=1,2,\\dots,n-1\\\\\r\n\\end{aligned}\\right.\\)\r\n其中第二行式子容易得出，因为\r\n\\(\\begin{aligned}\r\ny_k&amp;=\\dfrac{n\\omega_n^{k(n+1)}-(n+1)\\omega_n^n+1}{(\\omega_n^k-1)^2}\\\\\r\n&amp;=\\dfrac{n\\omega_n^k-(n+1)+1}{(\\omega_n^k-1)^2}\\\\\r\n&amp;=\\dfrac{n(\\omega_n^k-1)}{(\\omega_n^k-1)^2}\\\\\r\n&amp;=\\dfrac{n}{\\omega_n^k-1}\\\\\r\n\\end{aligned}\\)\r\n可见，\\(y_k\\)可以以\\(O(n)\\)的时间全部计算出来。\r\n接下来，对题目中的故障电路输入上面所提供的输入，获得输出\\(y&#39;\\)，并且记录集合\\(S=\\{k:y_k\\neq\r\ny_k&#39;,k\\in[0,n)\\}\\)。令\\(m=\\lg\r\nn\\)，对于图中的FFT电路，可见一个错误的输入将会导致两个错误的输出，也就是说，如果第\\(i\\)个阶段的电路发生故障，那么最终将会导致\\(2^{m-i}\\)个输出错误。\r\n因此，在这个电路中发生故障的蝶形电路是在阶段\\(s=m-\\lg |S|\\)中。并且可见，对于\\(S\\)中的所有数，它们都是关于\\(2^{s}\\)同余的，因此故障蝶形电路所在蝶形电路组的编号为\\(\\displaystyle{j=\\dfrac{\\min_{x\\in\r\nS}x}{2}}\\)。接下来求故障蝶形电路所在的蝶形电路组\\(g\\)。\r\n首先，如果蝶形电路的两个输入均为\\(0\\)，那么两个输出也是\\(0\\)。这启发我们首先定义多项式\\(\\displaystyle{A_{l,r}(x)=\\sum_{i=0}^{n-1}\r\na_{l,r,i} x^i}\\)，其中系数如下：\r\n\\(a_{l,r,i}=\r\n\\left \\{\\begin{aligned}\r\n  &amp;i+1 &amp; &amp; \\text{if}\\quad  l\\le i\\le r \\\\\r\n  &amp;0 &amp; &amp; \\text{otherwise}\\\\\r\n\\end{aligned}\\right.\\)\r\n可以发现，\\(A_{0,n-1}(x)=A(x)\\)。类似的，当\\(x\\neq 1\\)时，可以得到\\(A_{l,r}(x)=\\dfrac{(l+1)x^l-lx^{l+1}-(r+2)x^{r+1}+(r+1)x^{r+2}}{(x-1)^2}\\)\r\n对于\\(k\\in[0,n)\\)，考虑计算\\(y_{l,r,k}=A_{l,r}(\\omega_n^k)\\)的值，那么有\r\n\\(y_{l,r,k}=\r\n\\left \\{\\begin{aligned}\r\n  &amp;\\dfrac{(l+r + 2)(r-l+1)}{2} &amp; &amp; \\text{if}\\quad  k=0 \\\\\r\n  &amp;\\dfrac{(l+1)\\omega_n^{kl}-l\\omega_n^{k(l+1)}-(r+2)\\omega_n^{k(r+1)}+(r+1)\\omega_n^{k(r+2)}}{(\\omega_n^k-1)^2}\r\n&amp; &amp; \\text{if}\\quad  k=1,2,\\dots,n-1\\\\\r\n\\end{aligned}\\right.\\)\r\n同样可见，\\(y_{l,r,k}\\)可以以\\(O(n)\\)的时间全部计算出来。\r\n那么我们考虑使用二分法来确定电路组\\(g\\)，每次给定对应的输入，判断一个连续的蝶形电路组\\([l,r]\\)是否包含了一个故障蝶形电路（即输入多项式\\(A_{lr}(x)\\)并判断输出结果是否正确），如果输出不正确，那么故障的电路确实在这个电路组中。最终需要\\(\\lg n-s\\)次判断即可。\r\n因此，最终我们只需要恰好\\(\\lg\r\nn-s+1\\)次（至多\\(\\lg\r\nn\\)从）的判断。整个找出故障蝶形电路的位置\\((s,g,j)\\)由程序FIND-FAILED-ADDER给出：\r\nGEN-POLY(l, r, n)  let A[0 : n - 1] be a new array  for i = 0 to n - 1    if l &lt;= i and i &lt;= r      A[i] = A[i + 1]    else      A[i] = 0  return A[i]COMPUT-CORRECT-RESULT(l, r, n)  let Y[0 : n - 1] be a new array  ωn = exp(2 * π * i / n)  ωnl = ωn ^ l  ωnl1 = ωnl * ωn  ωnr1 = ωn ^ (r + 1)  ωrn2 = ωnr1 * ωn  ω = 1  ωl = 1  ωl1 = 1  ωr1 = 1  ωr2 = 1  Y[0] = (l + r + 2) * (r - l + 1) / 2  for k = 1 to n - 1    ω = ω * ωn    ωl = ωl * ωnl    ωl1 = ωl1 * ωnl1    ωr1 = ωr1 * ωnr1    ωr2 = ωr2 * ωnr2    Y[k] = ((l + 1) * ωl - l * ωl1 - (r + 2) * ωr1 + (r + 1) * ωr2) / (ω - 1) ^ 2  return Y// D是题目所提供的带有故障的FFT电路FIND-FAILED-ADDER(D, n)  m = lg n  y = COMPUT-CORRECT-RESULT(0, n - 1, n)  input polynomial GEN-PLOY(0, n - 1, n), run FFT circuit D, and get output y&#x27;  S = &#123;k : y_k != y_k&#x27;, 0 &lt;= k &lt; n&#125;  s = lg |S|  j = min&#123;x : x ∈ S&#125; / 2  l = 0  r = n / 2 ^ s - 1   while l &lt; r    mid = ⌊(l + r) / 2⌋    Alr = GEN-PLOY((2 ^ s) * l, 2 ^ s * (mid + 1) - 1, n)    y = GEN-POLY((2 ^ s) * l, 2 ^ s * (mid + 1) - 1, n)    input polynomial Alr, run FFT circuit D, and get output y&#x27;    if y == y&#x27;      // 说明带有故障电路组不在区间[l, mid]中      l = mid + 1    else      r = mid  return s, l, j\r\n","categories":["算法导论"]},{"title":"算法导论30 Problems 答案","url":"/introduction-to-algorithms/chapter-30/problems/","content":"\r\n30-1\r\na\r\n本题和题目4.2-5类似。\r\n\\(\\begin{aligned}\r\n(ax+b)(cx+d)&amp;=acx^2+(bc+ad)x+bd\\\\\r\n&amp;=acx^2+((a+b)(c+d)-ac-bd)x+bd\r\n\\end{aligned}\\)\r\n计算三次乘法\\(u=(a+b)(c+d),v=ac,w=bd\\)，那么可以计算出多项式的结果为\\(vx^2+(u-v-w)x+w\\)。\r\nb\r\n此处假设\\(n\\)是一个偶数。不失一般性，假设现在有两个多项式\\(\\displaystyle{A(x)=\\sum_{i=0}^{n-1}\r\na_ix^i,B(x)=\\sum_{i=0}^{n-1} b_ix^i}\\)，现在计算多项式\\(C(x)=A(x)\\cdot\r\nB(x)\\)的系数。假设多项式\\(A(x),B(x)\\)的次数\\(n\\)都为偶数。\r\n首先考虑第一种分治策略，即分成高阶系数一半和低阶系数一半。\r\n令\\(\\displaystyle{A_1(x)=\\sum_{i=0}^{n/2-1}\r\na_ix^i,A_2=\\sum_{i=0}^{n/2-1} a_{i+n/2}x^i}\\)。那么有\\(A(x)=A_2(x)x^{n/2}+A_1(x)\\)。类似的，令\\(\\displaystyle{B_1(x)=\\sum_{i=0}^{n/2-1}\r\nb_ix^i,B_2=\\sum_{i=0}^{n/2-1} b_{i+n/2}x^i}\\)。那么有\\(B(x)=B_2(x)x^{n/2}+B_1(x)\\)。那么考虑计算如下\\(3\\)个多项式的乘积（均是\\(n/2\\)次的多项式）：\r\n\\(\\begin{aligned}\r\nu(x)&amp;=(A_1(x)+A_2(x))\\cdot(B_1(x)+B_2(x))\\\\\r\nv(x)&amp;=A_2(x)\\cdot B_2(x)\\\\\r\nw(x)&amp;=A_1(x)\\cdot B_1(x)\r\n\\end{aligned}\\)\r\n那么最终可以得到\\(C(x)=v(x)\\cdot\r\nx^n+(u(x)-v(x)-w(x))\\cdot x^{n/2}+w(x)\\)。可以验证：\r\n\\(\\begin{aligned}\r\nC(x)&amp;=u(x)\\cdot x^n+(u(x)-v(x)-w(x))\\cdot x^{n/2}+w(x)\\\\\r\n&amp;=A_2(x)\\cdot B_2(x)\\cdot x^n+A_1(x)\\cdot B_2(x)\\cdot\r\nx^{n/2}+A_2(x)\\cdot x^{n/2}\\cdot B_1(x)+A_1(x)\\cdot B_1(x)\\\\\r\n&amp;=(A_2(x)x^{n/2}+A_1(x))\\cdot(B_2(x)x^{n/2}+B_1(x))\\\\\r\n&amp;=A(x)\\cdot B(x)\r\n\\end{aligned}\\)\r\n令\\(T(n)\\)表示这种分治策略的运行时间。首先花费\\(3T(n/2)\\)的时间计算出多项式\\(u(x),v(x),w(x)\\)，再花费\\(\\Theta(n)\\)的时间将这三个多项式合成计算结果\\(C(x)=A(x)\\cdot\r\nB(x)\\)，因此可以写出关于\\(T(n)\\)的递推式：\r\n\\[T(n)=3T(n/2)+\\Theta(n)\\]\r\n根据主定理的第1个条件，可以得到\\(T(n)=\\Theta(n^{\\lg 3})\\)。\r\n接下来考虑第二种分治策略，即按照系数下标的奇偶性划分。\r\n令\\(\\displaystyle{A_1(x)=\\sum_{i=0}^{n/2-1}\r\na_{2i}x^i,A_2=\\sum_{i=0}^{n/2-1} a_{2i+1}x^i}\\)。那么有\\(A(x)=A_2(x^2)x+A_1(x^2)\\)。类似的，令\\(\\displaystyle{B_1(x)=\\sum_{i=0}^{n/2-1}\r\nb_{2i}x^i,B_2=\\sum_{i=0}^{n/2-1} b_{2i+1}x^i}\\)。那么有\\(B(x)=B_2(x^2)x+B_1(x^2)\\)。那么考虑计算如下\\(3\\)个多项式的乘积（均是\\(n/2\\)次的多项式）：\r\n\\(\\begin{aligned}\r\nu(x)&amp;=(A_1(x)+A_2(x))\\cdot(B_1(x)+B_2(x))\\\\\r\nv(x)&amp;=A_2(x)\\cdot B_2(x)\\\\\r\nw(x)&amp;=A_1(x)\\cdot B_1(x)\r\n\\end{aligned}\\)\r\n那么最终可以得到\\(C(x)=v(x^2)\\cdot\r\nx^2+(u(x^2)-v(x^2)-w(x^2))\\cdot x+w(x^2)\\)。可以验证：\r\n\\(\\begin{aligned}\r\nC(x)&amp;=v(x^2)\\cdot x^2+(u(x^2)-v(x^2)-w(x^2))\\cdot x+w(x^2)\\\\\r\n&amp;=A_2(x^2)\\cdot B_2(x^2)\\cdot x^2+A_1(x^2)\\cdot B_2(x^2)\\cdot\r\nx+A_2(x^2)\\cdot x\\cdot B_1(x)+A_1(x^2)\\cdot B_1(x^2)\\\\\r\n&amp;=(A_2(x^2)x+A_1(x^2))\\cdot(B_2(x^2)x+B_1(x^2))\\\\\r\n&amp;=A(x)\\cdot B(x)\r\n\\end{aligned}\\)\r\n可见，子问题的数量和规模和第一种分治策略一致，并且可以\\(\\Theta(n)\\)的时间根据分治结果合并出\\(C(x)\\)，因此这种分治策略所需要的时间开销为\\(\\Theta(n^{\\lg 3})\\)。\r\nc\r\n先将\\(n\\)位二进制数\\(a,b\\)在\\(O(n)\\)的时间内转化成度数为\\(n\\)的多项式\\(\\displaystyle{A(x)=\\sum_{i=0}^{n-1}\r\na_ix^i,B(x)=\\sum_{i=0}^{n-1} b_ix^i}\\)。其中\\(a_k\\)表示\\(a\\)的第\\(k\\)比特（\\(b_k\\)同理）。\r\n使用上面的分治算法计算出多项式\\(C(x)=A(x)\\cdot B(x)\\)，需要花费\\(O(n^{\\lg 3})\\)，然后花费\\(O(n)\\)的时间处理数组\\(C\\)的进位，并转化成二进制数\\(c\\)，最终只需要\\(O(n^{\\lg 3})\\)的时间就可以计算出\\(c\\)。以下过程是计算出\\(c\\)的过程MULTIPLY-FFT。\\(O(n^{\\lg\r\n3})\\)中的每个步骤均摊下来，只花费\\(O(1)\\)（即常数）的比特操作。\r\nMULTIPLY-FFT(a, b, n)  convert binary numbers a, b into polynomials A, B of degree n  m = 2 ^ (⌈lg n⌉ + 1)  for i = 1 to m - n    INSERT(A, 0)    INSERT(B, 0)  C = FFT-INV(FFT(A, m) ⋅ FFT(B, m), m)  cap = 0  for i = 0 to m - 1    cap = cap + C[i]    C[i] = cap % 2    cap = ⌊cap / 2⌋  convert polynomial C to binary number c  return c\r\n30-2\r\na\r\n考虑将\\(\\omega_{n_2}^{j_2k_2},\\omega_{n_3}^{j_3k_3},\\dots,\\omega_{n_d}^{j_dk_d}\\)都视为是常数。那么有\r\n\\(\\begin{aligned}\r\ny_{k_1,k_2,\\dots,k_d}&amp;=\\sum_{j_1=0}^{n_1-1}\\sum_{j_2=0}^{n_2-1}\\dots\\sum_{j_d=0}^{n_d-1}a_{k_1,k_2,\\dots,k_d}\\omega_{n_1}^{j_1k_1}\\omega_{n_2}^{j_2k_2}\\dots\\omega_{n_d}^{j_dk_d}\\\\\r\n&amp;=\\sum_{j_2=0}^{n_2-1}\\sum_{j_3=0}^{n_3-1}\\dots\\sum_{j_d=0}^{n_d-1}\\sum_{j_1=0}^{n_1-1}a_{k_1,k_2,\\dots,k_d}\\omega_{n_1}^{j_1k_1}\\omega_{n_2}^{j_2k_2}\\dots\\omega_{n_d}^{j_dk_d}\\\\\r\n&amp;=\\sum_{j_2=0}^{n_2-1}\\sum_{j_3=0}^{n_3-1}\\dots\\sum_{j_d=0}^{n_d-1}\\sum_{j_1=0}^{n_1-1}a_{k_1,k_2,\\dots,k_d}\\omega_{n_1}^{j_1k_1}\\omega_{n_2}^{j_2k_2}\\dots\\omega_{n_d}^{j_dk_d}\\\\\r\n&amp;=\\sum_{j_2=0}^{n_2-1}\\sum_{j_3=0}^{n_3-1}\\dots\\sum_{j_d=0}^{n_d-1}\\omega_{n_2}^{j_2k_2}\\dots\\omega_{n_d}^{j_dk_d}\\left(\\sum_{j_1=0}^{n_1-1}a_{k_1,k_2,\\dots,k_d}\\omega_{n_1}^{j_1k_1}\\right)\\\\\r\n&amp;=\\sum_{j_2=0}^{n_2-1}\\sum_{j_3=0}^{n_3-1}\\dots\\sum_{j_d=0}^{n_d-1}\\omega_{n_2}^{j_2k_2}\\dots\\omega_{n_d}^{j_dk_d}\\cdot\r\na&#39;_{k_1,k_2,k_3,\\dots,k_d}\\\\\r\n&amp;=\\sum_{j_2=0}^{n_2-1}\\sum_{j_3=0}^{n_3-1}\\dots\\sum_{j_d=0}^{n_d-1}a&#39;_{k_1,k_2,k_3,\\dots,k_d}\\omega_{n_2}^{j_2k_2}\\dots\\omega_{n_d}^{j_dk_d}\\\\\r\n\\end{aligned}\\)\r\n对于独立的\\(\\dfrac{n}{n_1}\\)个一维DFT问题\\((k_2,k_3,\\dots,k_d)\\)，将\\(k_1\\)视作指数，那么最后一行的计算结果\\(a&#39;:a&#39;_{\\cdot,k_2,k_3,\\dots,k_d}=\\text{DFT}_{n_1}(a&#39;_{\\cdot,k_2,k_3,\\dots,k_d})\\)，作为下一个问题的步骤的系数\\(a\\)的输入，这个过程消去了一个求和符号。在下一次迭代中，仅有\\(\\dfrac{n}{n_1n_2}\\)个一维DFT问题（下一步是取原来第\\(2\\)维），直到所有求和符号都被消去，最终得到的就是多维DFT的结果。\r\nb\r\n由于这\\(d\\)个求和符号的上下限仅依赖于第\\(d\\)维度\\(n_d\\)，因此各个求和符号的位置可以随意改变次序；同样的，所有的\\(\\omega_{n}^{jk}\\)的次序都可以改变。因此，无论哪个维度的消去顺序都是一样的（可以把对应想消去的那一维放到第\\(1\\)个位置，然后使用题目30-2-a的方法使用FFT）。因此，原结论成立。\r\nc\r\n假设目前正在消去第\\(i\\)维的求和符号，那么一共有\\(\\displaystyle{n/\\prod_{j=1}^{i}\r\nn_j}\\)个DFT问题，这些DFT问题的规模大小为\\(n_i\\)，需要花费\\(O(n_i\\lg n_i)\\)的时间求解，因此消去第\\(i\\)维的求和符号所需要花费的时间为\\(\\displaystyle{n/\\prod_{j=1}^{i} n_j\\cdot O(n_i\\lg\r\nn_i)=O\\left(\\left(n/\\prod_{j=1}^{i-1} n_j\\right)\\lg\r\nn_i\\right)}\\)。因此完成这\\(d\\)步循环后，所需要花费的时间为\r\n\\(\\begin{aligned}\r\n\\sum_{i=1}^d \\left(\\left(n/\\prod_{j=1}^{i-1} n_j\\right)\\lg\r\nn_i\\right)&amp;\\le n\\lg n\\cdot \\sum_{i=1}^d1/\\left(\\prod_{j=1}^{i-1}\r\nn_i\\right)\\\\\r\n&amp;\\le n\\lg n\\cdot \\sum_{i=1}^d1/\\left(\\prod_{j=1}^{i-1}\r\n2\\right)\\qquad(A)\\\\\r\n&amp;=n\\lg n\\cdot \\sum_{i=1}^d 2^{1-i}\\\\\r\n&amp;\\le 2n\\lg n\\\\\r\n&amp;=O(n\\lg n)\r\n\\end{aligned}\\)\r\n其中步骤\\((A)\\)假定了\\(n_i\\ge 2\\)，因为如果\\(n_i=1\\)，那么\\(\\lg n_i=0\\)，消去第\\(i\\)个求和符号不需要花费任何时间。因此最终原结论成立。\r\n30-3\r\na\r\n当\\(t\\le n-1\\)时，有\r\n\\(\\begin{aligned}\r\nA^{(t)}(x)&amp;=\\dfrac{d^t}{dx^t}A(x)\\\\\r\n&amp;=\\dfrac{d^t}{dx^t}\\sum_{j=0}^{n-1}b_j(x-x_0)^{j}\\\\\r\n&amp;=\\sum_{j=0}^{n-1}\\dfrac{d^t}{dx^t}b_j(x-x_0)^{j}\\\\\r\n&amp;=\\sum_{j=t}^{n-1}\\dfrac{d^t}{dx^t}b_j(x-x_0)^{j}&amp;\\qquad(A)\\\\\r\n&amp;=\\sum_{j=t}^{n-1}\\dfrac{j!}{(j-t)!}b_j(x-x_0)^{j-t}\\\\\r\n&amp;=\\sum_{j=0}^{n-1-t}\\dfrac{(j+t)!}{j!}b_{j+t}(x-x_0)^{j}\\\\\r\n\\end{aligned}\\)\r\n步骤\\((A)\\)所得是因为所有小于\\(t\\)次的多项式进行\\(t\\)次求导后的值为\\(0\\)。因此最终有\\(A^{(t)}(x_0)=b_t\\cdot t!\\)。\r\n因此对于\\(t=0,1,2,\\dots,n-1\\)，维护好\\(t!\\)的值，就可以以\\(O(n)\\)的时间计算出\\(A^{(t)}(x_0)\\)的所有值。大概过程由程序COMPUTE-ATX0给出：\r\nCOMPUTE-ATX0(B, n, x)  let D[0 : n - 1] be a new array  fac = 1  for t = 0 to n - 1    D[t] = B[t] * fac    fac = fac * (t + 1)  return D\r\nb\r\n由于我们知道了值\\(\\displaystyle{A(x_0+\\omega_n^k)=\\sum_{j=0}^{n-1}\r\nb_j\\omega_n^j}\\)，因此为了求出\\(b_j\\)，只需要对\\(A(x_0+\\omega_n^k),k=0,1,\\dots,n-1\\)这\\(n\\)个数进行一次逆向FFT即可，所需要花费的时间为\\(O(n\\lg n)\\)。\r\n令示性函数\\(i(x)=[x\\ge0]\\)。\r\nc\r\n\\(\\begin{aligned}\r\nA(x_0+\\omega_n^k)&amp;=\\sum_{j=0}^{n-1} a_j(x_0+\\omega_n^k)^j\\\\\r\n&amp;=\\sum_{j=0}^{n-1}\r\na_j\\sum_{r=0}^j\\dbinom{j}{r}\\omega_n^{kr}x_0^{j-r}\\\\\r\n&amp;=\\sum_{j=0}^{n-1}\r\na_j\\sum_{r=0}^j\\dfrac{j!}{r!\\cdot(j-r)!}\\omega_n^{kr}x_0^{j-r}\\\\\r\n&amp;=\\sum_{j=0}^{n-1}\r\na_j\\sum_{r=0}^j\\dfrac{j!}{r!\\cdot(j-r)!}\\omega_n^{kr}x_0^{j-r}\\\\\r\n&amp;=\\sum_{j=0}^{n-1}\r\na_j\\sum_{r=0}^j\\dfrac{j!}{r!}\\omega_n^{kr}\\dfrac{x_0^{j-r}}{(j-r)!}\\\\\r\n&amp;=\\sum_{j=0}^{n-1}\r\na_j\\left(\\sum_{r=0}^j\\dfrac{j!}{r!}\\omega_n^{kr}\\dfrac{x_0^{j-r}}{(j-r)!}+\\sum_{r=j+1}^{n-1}\\dfrac{j!}{r!}\\omega_n^{kr}\\cdot\r\n0\\right)\\\\\r\n&amp;=\\sum_{j=0}^{n-1}\r\na_j\\left(\\sum_{r=0}^j\\dfrac{j!}{r!}\\omega_n^{kr}g(r-j)+\\sum_{r=j+1}^{n-1}\\dfrac{j!}{r!}\\omega_n^{kr}\r\ng(r-j)\\right)\\\\\r\n&amp;=\\sum_{j=0}^{n-1}\r\na_j\\left(\\sum_{r=0}^{n-1}\\dfrac{j!}{r!}\\omega_n^{kr}g(r-j)\\right)\\\\\r\n&amp;=\\sum_{r=0}^{n-1}\r\n\\sum_{j=0}^{n-1}a_j\\cdot\\dfrac{j!}{r!}\\omega_n^{kr}g(r-j)\\\\\r\n&amp;=\\sum_{r=0}^{n-1}\r\n\\sum_{j=0}^{n-1}\\dfrac{f(j)}{r!}\\omega_n^{kr}g(r-j)\\\\\r\n&amp;=\\sum_{r=0}^{n-1}\\left[\\dfrac{\\omega_n^{kr}}{r!}\\sum_{j=0}^{n-1}f(j)g(r-j)\\right]\\\\\r\n\\end{aligned}\\)\r\n因此最终原结论成立。\r\nd\r\n令\\(h(j)=g(j-(n-1))\\)，那么有\\(\\displaystyle{A(x_0+\\omega_n^k)=\\sum_{r=0}^{n-1}\\left[\\dfrac{\\omega_n^{kr}}{r!}\\sum_{j=0}^{n-1}f(j)h(n+r-1-j)\\right]}\\)，然而对于\\(j\\ge n\\)，都有\\(h(j)=0\\)。\r\n当\\(j\\ge n\\)时，假设\\(f(j)=0\\)，令\\(\\displaystyle{y_r=\\sum_{j=0}^{n-1}f(j)h(n+r-1-j)=}\\sum_{j=0}^{n+r-1}f(j)h(n+r-1-j)\\)，那么可以在\\(O(n\\lg\r\nn)\\)的时间内通过多项式卷积计算出\\(y_r\\)，其中\\(r\\in[0,n)\\)。\r\n令\\(z_r=\\dfrac{y_r}{r!}\\)，那么得到\\(\\displaystyle{A(x_0+\\omega_n^k)=\\sum_{r=0}^{n-1}z_r\\omega_{n}^{kr}}\\)。接下来再使用一次FFT即可计算出\\(A(x_0+\\omega_n^k)\\)，其中\\(k\\in[0,n)\\)。\r\n然后，按照题目30-3-b的结论，使用一次逆向FFT，得到多项式\\(A\\)的系数\\(b_0,b_1,\\dots,b_{n-1}\\)。\r\n最后使用题目30-3-a的结论，通过系数\\(b\\)在\\(O(n)\\)的时间内计算出\\(A(x)\\)所有非平凡导数在\\(x_0\\)的值。由于整个过程仅仅使用了\\(5\\)次FFT，以及最后一步以\\(O(n)\\)的时间计算出所有答案，因此整个过程的时间复杂度为\\(O(n\\lg n)\\)。\r\n整个大致过程由COMPUTE-DERIVATIVE-BY-FFT给出。\r\nCOMPUTE-DERIVATIVE-BY-FFT(A, n, x)  m = 2 ^ (⌈lg n⌉ + 1)  for i = 1 to m - n    INSERT(A, 0)  let F[0 : m - 1], H[0 : m - 1] ,fac[0, m - 1] be new arrays  fac[0] = 1  for i = 1 to n - 1    fac[i] = fac[i - 1] * i  for i = 0 to n - 1    F[i] = A[i] * fac[i]    l = i - (n - 1)    H[i] = exp(x, -l) / fac[-l]  Y = FFT-INV(FFT(F, m) ⋅ FFT(H, m), m)  let Z[0 : m - 1], D[0 : n - 1] be new arrays  for i = 0 to n - 1    Z[i] = Y[i + m / 2] / fac[i]  B = FFT-INV(Z, m)  for i = 0 to n - 1    D[i] = B[i] * fac[i]  return 0\r\n30-4\r\na\r\n这个问题等价于证明：\\(x-z\\mid\r\nA(x)-A(z)\\)。\r\n首先证明一个引理：\\(\\forall n\\ge\r\n1\\)，其中\\(n\\)是一个整数，都有\\(a-b\\mid\r\na^n-b^n\\)。接下来使用归纳法进行证明。当\\(n=1\\)时，明显成立。当\\(n&gt;1\\)时，假设对于\\(k=1,2,\\dots,n-1\\)，都有\\(a-b\\mid a^k-b^k\\)。考虑\\(a^n-b^n\\)，那么有\\(a^n-b^n=(a-b)\\cdot\r\na^{n-1}+b(a^{n-1}-b^{n-1})\\)。由于前者包含一个因子\\((a-b)\\)，因此\\(a-b\\)整除\\((a-b)\\cdot a^{n-1}\\)；按照假设，可知\\(a-b\\mid b(a^{n-1}-b^{n-1})\\)，因此得出\\(a-b\\mid a^n-b^n\\)，该引理成立。\r\n接下来证明原结论。考虑\\(A(x)-A(z)\\)，那么有\\(\\displaystyle{A(x)-A(z)=\\sum_{i=0}^{n-1}\r\na_i(x^i-z^i)}\\)。当\\(i=0\\)时，这个项为\\(0\\)；对于\\(i&gt;0\\)，按照上面的引理，都有\\(x-z\\mid x^i-z^i\\)，因此最终有\\(x-z\\mid A(x)-A(z)\\)。即\r\n\\[A(x)\\bmod (x-z)=A(z)\\]\r\nb\r\n可以得知\\(Q_{kk}(x)=A(x)\\bmod\r\n(x-x_k)\\)，因此按照题目30-4-a的结论，有\\(Q_{kk}(x)=A(x_k)\\)。\r\n由于多项式\\(P_{0,n-1}(x)\\)的次数为\\(n\\)，但是\\(A(x)\\)的次数为\\(n-1\\)，因此\\(A(x)\\bmod P_{0,n-1}(x)=A(x)\\)，即\\(Q_{0,n-1}(x)=A(x)\\)。\r\nc\r\n本题考虑证明一个更强的结论：对于任意非空集合\\(S\\subseteq\\{0,1,\\dots,n-1\\}\\)的任意一个非空子集\\(T\\)，都有\\(\\displaystyle{A(x)\\bmod \\prod_{i\\in\r\nT}(x-x_i)=(A(x)\\bmod \\prod_{i\\in S}(x-x_i))\\bmod\r\n\\prod_{i\\in T}(x-x_i)}\\)。\r\n令\\(\\displaystyle{s(x)=\\prod_{i\\in\r\nS}(x-x_i),t(x)=\\prod_{i\\in T}(x-x_i)}\\)，可见\\(t(x)\\mid\r\ns(x)\\)。接下里是证明：构造两个多项式\\(q_1(x),r_1(x_1)\\)满足\\(\\displaystyle{A(x)=q_1(x)\\cdot\r\ns(x)+r_1(x)}\\)，其中\\(\\text{degree}(r_1)&lt;|S|\\)，那么有\\(A(x)\\bmod\r\ns(x)=r_1(x)\\)。同时构造两个多项式\\(q_2(x),r_2(x)\\)满足\\(r_1(x)=q_2(x)\\cdot t(x)+r_2(x)\\)，其中\\(\\text{degree}(r_2)&lt;|T|\\)。由于\\(t(x)\\mid s(x)\\)，令多项式\\(u(x)=s(x)/t(x)\\)，那么有\r\n\\(\\begin{aligned}\r\nA(x)&amp;=q_1(x)\\cdot s(x)+r_1(x)\\\\\r\n&amp;=q_1(x)\\cdot u(x)\\cdot t(x)+q_2(x)\\cdot t(x)+r_2(x)\\\\\r\n&amp;=(q_1(x)\\cdot u(x)+q_2(x))\\cdot t(x)+r_2(x)\r\n\\end{aligned}\\)\r\n由于\\(\\text{degree}(r_2)&lt;|T|\\)，因此有\\(A(x)\\bmod\r\nt(x)=r_2(x)\\)，上面证明的结论成立。\r\n假设现在\\(S=\\{i,i+1,\\dots,j\\}\\)。当\\(T=\\{i,i+1,\\dots,k\\}\\)时，则相当于证明了\\(A(x)\\bmod P_{ik}(x)=(A(x)\\bmod P_{ij}(x))\\bmod\r\nP_{ik}(x)\\)，即\\(Q_{ik}(x)=Q_{ij}(x)\\bmod\r\nP_{ik}(x)\\)。当\\(T=\\{k,k+1,\\dots,j\\}\\)时，则相当于证明了\\(A(x)\\bmod P_{kj}(x)=(A(x)\\bmod P_{ij}(x))\\bmod\r\nP_{kj}(x)\\)，即\\(Q_{kj}(x)=Q_{ij}(x)\\bmod\r\nP_{kj}(x)\\)，因此原结论成立。\r\nd\r\n令\\(m=2^{\\lceil\\lg\r\nn\\rceil}\\)。整个过程分为两个阶段。按照题目30.2-7的思路，首先自底向上，使用FFT计算出所有的\\(P_{lr}:\\exists k:r-l+1=2^k,2^k\\mid\r\nl\\)，这个阶段将花费\\(O(m\\lg^2\r\nm)\\)的时间。接下来则是自顶向下计算出所有的\\(Q_{lr}:\\exists k:r-l+1=2^k,2^k\\mid\r\nl\\)，同样的，在第\\(k\\)轮迭代中计算单次多项式的长度为\\(\\dfrac{m}{2^{k-1}}\\)，取模所需要花费的时间为\\(O\\left(\\dfrac{m}{2^{k-1}}\\lg\r\n\\dfrac{m}{2^{k-1}}\\right)\\)。一共需要进行\\(2^{k-1}\\cdot\r\n2\\)次，因此总共所需要花费的时间为\\(O(m\\lg m)\\)。因此第二个阶段也将花费\\(O(m\\lg^2m)\\)的时间。\r\n由于两个阶段都使用了\\(O(m\\lg^2\r\nm)\\)的运行时间，并且\\(n=\\Theta(m)\\)，因此这个算法的时间复杂度为\\(O(n\\lg^2n)\\)，具体过程由EVALUATE-N-VALUES给出。\r\n// 假设函数PLOY-MULTIPLY和POLY-MODULO会将多项式的长度拓展成2的幂，并且用FFT和FFT-INV分别作为子程序运行，以O(n lg n)的时间进行，这里忽略了实现细节。EVALUATE-N-VALUES(A, X, n)  m = 2 ^ (⌈lg n⌉)  c = ⌈lg n⌉  for i = 0 to m    if i &lt; n      P_&#123;ii&#125; = [-X[i], 1]    else      P_&#123;ii&#125; = [1, 0]  for k = 1 to c    for l = 0 to m by 2^k      r = l + 2 ^ k - 1      P_&#123;l, r&#125; = PLOY-MULTIPLY(P_&#123;l, l + 2 ^ (k - 1) - 1&#125;, P_&#123;l + 2 ^ (k - 1), r&#125;)  Q_&#123;0, m - 1&#125; = A  for k = c to 1    for l = 0 to m by 2^k      r = l + 2 ^ k - 1      Q_&#123;l, l + 2 ^ (k - 1) - 1&#125; = PLOY-MODULO(Q_&#123;l, r&#125;, P_&#123;l + 2 ^ (k - 1), r&#125;)      Q_&#123;l + 2 ^ (k - 1), r&#125; = PLOY-MODULO(Q_&#123;l, r&#125;, P_&#123;l, l + 2 ^ (k - 1) - 1&#125;)  let Y[0 : n - 1] be a new array  for i = 0 to n - 1    Y[i] = Q_&#123;ii&#125;  return Y\r\n30-5\r\n事实上，这种在\\(\\mathbb{Z}_p\\)上的傅里叶变换称为数论变换。\r\na\r\n按照素数定理，从\\(1\\)到\\(m\\)中素数的个数占比约为\\(\\dfrac{1}{\\ln m}\\)。因此从\\(1\\)到\\(n\\ln\r\nn\\)中选取到一个质数的概率约为\\(\\dfrac{1}{\\ln n+\\ln \\ln n}\\approx\\dfrac{1}{\\ln\r\nn}\\)。考虑从\\(k=1,2,3,\\dots,\\ln\r\nn\\)，考察存在\\(k\\)使得\\(kn+1\\)是一个质数的概率\\(p\\)。可以计算得到\r\n\\(\\begin{aligned}\r\np&amp;\\approx 1-\\left(1-\\dfrac{1}{\\ln n+\\ln\\ln n}\\right)^{\\ln n}\\\\\r\n&amp;\\approx1-\\left(1-\\dfrac{1}{\\ln n}\\right)^{\\ln n}\\\\\r\n&amp;&gt; 1-\\dfrac{1}{e}\\\\\r\n&amp;\\approx 0.632121\r\n\\end{aligned}\\)\r\n因此，有相当高的概率使得这\\(\\ln\r\nn\\)数中存在一个质数，因此需要检查的\\(k\\)期望个数为\\(O(\\lg n)\\)。因此\\(p\\)的期望值为\\(O(n\\lg n)\\)，并且\\(p\\)的长度值的期望是\\(O(\\lg(n\\lg n))=O(\\lg n+\\lg\\lg n)=O(\\lg\r\nn)\\)。\r\nb\r\n由于\\(g\\)是\\(\\mathbb{Z}_p^{\\ast}\\)生成元，因此\\(g\\)在\\(\\mathbb{Z}_p^{\\ast}\\)上的阶\\(\\lambda_p(g)=p-1=kn\\)。由于\\(w=g^k\\bmod p\\)，因此\\(\\lambda_p(w)=n\\)。也就是说，\\(\\mathbb{Z}_p^{\\ast}\\)上的一个循环子群\\(\\langle w\\rangle\\)的大小为\\(n\\)。按照\\(\\omega_n\\)的定义，有\\(\\omega_n^n=1\\)，类似的，按照费马小定理，有\\(w^{n}\\equiv (g^{k})^n\\equiv g^{p-1}\\equiv 1\\pmod\r\np\\)。\r\n接下来证明引理/定理/推论30.3，30.4，30.5，30.6, 30.76在\\(\\langle w\\rangle\\)中是成立的。\r\n引理30.3的证明：考虑\\(n\\)的某个因子\\(d\\)，令\\(w&#39;=w^d\\)，那么有\\(w&#39;^{k/d}\\equiv (w^{d})^{k/d}\\equiv w^k\\pmod\r\np\\)，因此原结论成立。\r\n推论30.4的证明：不难知道\\(w^{n/2}\\equiv\r\ng^{kn/2}\\equiv -1\\pmod {p}\\)，（由于\\(g^{kn}\\equiv 1\\pmod p\\)，因此\\(g^{kn/2} \\bmod p\\)的值要么为\\(-1\\)，要么为\\(1\\)，但是它的值必定是\\(-1\\)，因为\\(g\\)是原根）。\r\n引理30.5的证明：\\((w^{k+n/2})^2\\equiv\r\nw^{2k+n}\\equiv w^{2k}\\cdot w^{n}\\equiv (w^k)^2\\pmod\r\np\\)，因此结论得证。\r\n引理30.6的证明：当\\(n\\nmid\r\nk\\)时，有\\(w^k\\not\\equiv 1\\pmod\r\np\\)成立。证明过程和原本的定理30.6的计算过程一致，原结论得证。\r\n定理30.7的证明：此时\\(V_{n}^{-1}\\)的第\\(j\\)行第\\(k\\)列的项为\\(w^{-jk}\\cdot n^{-1}\\bmod p\\)。由于\\(p\\)是奇数，且\\(n&lt;p\\)，因此\\(\\gcd(n,p)=1\\)，因此在\\(\\mathbb{Z}_p\\)中存在\\(n\\)的逆元\\(n^{-1}\\)，结论中的写法是成立的，考虑\\([V_{n}^{-1}V_n]_{kk}\\)的值，有\\([V_{n}^{-1}V_n]_{kk}\\equiv\\displaystyle{\\sum_{j=0}^{n-1}}(w^{-jk}\\cdot\r\nn^{-1})(w^{jk&#39;})\\equiv n^{-1}\\cdot\r\n\\sum_{j=0}^{n-1}w^{j(k&#39;-k)}\\pmod\r\np\\)。其余证明过程类似，因此原结论成立。\r\n那么在\\(\\mathbb{Z}_{p}\\)上的DFT问题定义为：给定长度为\\(n\\)的序列\\((a_0,a_1,\\dots,a_{n-1})\\)，计算\\(\\displaystyle{y_j=\\sum_{i=0}^{n-1}} a_i(w^j)^i\r\n\\bmod p\\)，其中\\(w=g^k\\)。最终，计算结果\\(y_j\\in\\mathbb{Z}_{p}\\)，可见计算结果是封闭的。正向DFT的过程成立。\r\n现在在\\(\\mathbb{Z}_{p}\\)上的逆向DFT问题定义为：给定长度为\\(n\\)的序列\\((y_0,y_1,\\dots,y_{n-1})\\)，构造一组序列\\((a_0,a_1,\\dots,a_{n-1})\\in\\mathbb{Z}_p^n\\)，使得\\(\\displaystyle{\\forall\r\nj\\in[0,n),y_j=\\sum_{i=0}^{n-1}} a_i(w^j)^i \\bmod\r\np\\)均成立，其中\\(w=g^k\\)。那么按照类似的结论，由于\\(\\gcd(w,p)=1\\)，因此\\(w\\)在\\(\\mathbb{Z}_p^{\\ast}\\)中也存在逆元\\(w^{-1}\\)。容易验证\\(\\langle w\\rangle=\\langle\r\nw^{-1}\\rangle\\)，因此\\(\\displaystyle{a_k=n^{-1}\\sum_{i=0}^{n-1}y_i(\\omega^{-k})^i}\\bmod\r\np\\)的整个计算过程是封闭的，即DFT的逆过程是正确定义的。\r\nc\r\n对FFT和FFT-INV改造后，可以得到FFT-OVER-RING和FFT-INV-OVER-RING算法，程序如下给出。由于操作分别和FFT与FFT-INV一致，因此其时间复杂度均为\\(O(n\\lg n)\\)。需要注意的是，\\(w^{-1}\\)和\\(n^{-1}\\)可以提前计算好，避免以后的重复计算。\r\nFFT-OVER-RING(a, n, p, wn)  if n == 1    return a  w = 1  a-even = (a_0, a_2, ..., a_&#123;n - 2&#125;)  a-odd = (a_1, a_3, ..., a_&#123;n - 1&#125;)  y-even = FFT-INV(FFT-OVER-RING, n / 2, p, wn * wn % p)  y-odd = FFT-INV(FFT-OVER-RING, n / 2, wn * wn % p)  for k = 0 to n / 2 - 1    y_k = (a-even_&#123;k&#125; + w * a-odd_&#123;k&#125;) % p    y_&#123;k + n / 2&#125; = (a-even_&#123;k&#125; - w * a-odd_&#123;k&#125;) % p    w = w * wn % p  return y// wn^&#123;-1&#125;和n^&#123;-1&#125;需要提前使用扩展欧几里得算法计算好，避免重复计算，结果分别用wn-inv和n-inv表示。FFT-INV-OVER-RING(y, n, p, wn-inv)  if n == 1    return a  w = 1  y-even = (y_0, y_2, ..., y_&#123;n - 2&#125;)  y-odd = (y_1, y_3, ..., y_&#123;n - 1&#125;)  a-even = FFT-INV-OVER-RING(y-even, n / 2, p, wn-inv * wn-inv % p)  a-odd = FFT-INV-OVER-RING(y-odd, n / 2, p, wn-inv * wn-inv % p)  for k = 0 to n / 2 - 1    a_k = (a-even_&#123;k&#125; + w * a-odd_&#123;k&#125;) * n-inv % p    a_&#123;k + n / 2&#125; = (a-even_&#123;k&#125; - w * a-odd_&#123;k&#125;) * n-inv % p    w = w * wn-inv % p  return a\r\nd\r\n由于\\(n=8\\)，因此\\(g_n=g^{\\frac{p-1}{n}}=9\\)。\r\n那么\\(\\forall k\\in\r\n[0,n)\\)，都有\\(\\displaystyle{y_k=\\sum_{i=0}^{n-1} a_i\\cdot\r\n(g_n^k)^i\\bmod p}\\)。可以计算得到\r\n\\(\\begin{aligned}\r\ny_0&amp;=\\sum_{i=0}^{n-1} a_i\\cdot (g_n^0)^i\\bmod p=14\\\\\r\ny_1&amp;=\\sum_{i=0}^{n-1} a_i\\cdot (g_n^1)^i\\bmod p=10\\\\\r\ny_2&amp;=\\sum_{i=0}^{n-1} a_i\\cdot (g_n^2)^i\\bmod p=10\\\\\r\ny_3&amp;=\\sum_{i=0}^{n-1} a_i\\cdot (g_n^3)^i\\bmod p=4\\\\\r\ny_4&amp;=\\sum_{i=0}^{n-1} a_i\\cdot (g_n^4)^i\\bmod p=8\\\\\r\ny_5&amp;=\\sum_{i=0}^{n-1} a_i\\cdot (g_n^5)^i\\bmod p=11\\\\\r\ny_6&amp;=\\sum_{i=0}^{n-1} a_i\\cdot (g_n^6)^i\\bmod p=13\\\\\r\ny_7&amp;=\\sum_{i=0}^{n-1} a_i\\cdot (g_n^7)^i\\bmod p=15\\\\\r\n\\end{aligned}\\)\r\n因此DFT的结果为\\((14,10,10,4,8,11,13,15)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论27.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-27/exercises-1/","content":"\r\n27.1-1\r\n令\\(i(m)\\)表示采取等待至多\\(p\\)个单位时间电梯时所花费的时间。那么可以写出\\(i(m)\\)为\r\n\\(i(m)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;m+1 &amp; &amp; \\text{if}\\quad  m\\le p \\\\\r\n  &amp;p+k &amp; &amp; \\text{if}\\quad m&gt;p\\\\\r\n\\end{aligned}\\right.\\)\r\n那么此时的竞争比例为\\(r=\\max\\{i(m)/t(m):0\\le m&lt;B\\}\\)。\r\n如果有\\(p&lt;k-1\\)，那么竞争比例为\\(r=\\max\\left\\{\\dfrac{1}{1},\\dfrac{2}{2},\\dots,\\dfrac{p-1}{p-1},\\dfrac{p}{p},\\dfrac{p+1}{p+1},\\dfrac{p+k}{p+2},\\dots,\\dfrac{p+k}{k},\\dfrac{p+k}{k},\\dots,\\dfrac{p+k}{k}\\right\\}=\\dfrac{p+k}{p+2}=1+\\dfrac{k-2}{p+2}\\)。\r\n如果有\\(p=k-1\\)，那么竞争比例为\\(r=\\max\\left\\{\\dfrac{1}{1},\\dfrac{2}{2},\\dots,\\dfrac{k-1}{k-1},\\dfrac{k}{k},\\dfrac{(k-1)+k}{k},\\dots,\\dfrac{(k-1)+k}{k}\\right\\}=\\dfrac{p+k}{p+2}=\\dfrac{2k-1}{k}\\)。\r\n如果有\\(p=k\\)，那么竞争比例为\\(r=2\\)。\r\n如果有\\(p&gt;k\\)，那么竞争比例为\\(r=\\max\\left\\{\\dfrac{1}{1},\\dfrac{2}{2},\\dots,\\dfrac{k}{k},\\dfrac{k+1}{k},\\dots,\\dfrac{p-1}{k},\\dfrac{p}{k},\\dfrac{p+1}{k},\\dfrac{p+k}{k},\\dots,\\dfrac{p+k}{k}\\right\\}=\\dfrac{p+k}{k}&gt;2\\)。\r\n由此可见，当取\\(p=k-2\\)时，可以得到最小的竞争比例\\(r=\\dfrac{2k-2}{k}\\)。\r\n27.1-2\r\n对于一个能够预测到自己滑雪天数的预言家，他一定能够采取最优的策略。令\\(t(m)\\)表示滑雪\\(m\\)天时，预言家所采取最优策略需要的花费，可以给出为：\r\n\\(t(m)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;rm &amp; &amp; \\text{if}\\quad  m&lt;\\lceil b/r\\rceil \\\\\r\n  &amp;b &amp; &amp; \\text{if}\\quad m\\ge \\lceil b/r\\rceil \\\\\r\n\\end{aligned}\\right.\\)\r\n考虑如下在线策略：对于前\\(\\lceil\r\nb/r\\rceil-1\\)天，每天都支付\\(r\\)元来支付租金。在第\\(\\lceil\r\nb/r\\rceil\\)天，买断这对滑雪板，从此以后不需要再花钱。因此，如果需要滑雪\\(m\\)天，令\\(h(m)\\)表示这个在线策略中，前\\(m\\)天的花费，如下：\r\n\\(h(m)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;rm &amp; &amp; \\text{if}\\quad  m&lt;\\lceil b/r\\rceil \\\\\r\n  &amp;r(\\lceil b/r\\rceil-1) +b &amp; &amp; \\text{if}\\quad m\\ge \\lceil\r\nb/r\\rceil \\\\\r\n\\end{aligned}\\right.\\)\r\n可见，当\\(m&lt;\\lceil\r\nb/r\\rceil\\)时，有\\(t(m)=h(m)\\)；当\\(m\\ge\\lceil b/r\\rceil\\)时，有\\(\\dfrac{h(m)}{r(m)}=1+\\dfrac{r(\\lceil\r\nb/r\\rceil-1)}{b}&lt;2\\)。因此可以得到竞争比例\\(r=\\max\\{h(m)/t(m):m&gt;1\\}&lt;2\\)。因此如上策略满足题意。\r\n27.1-3\r\n假设现在一共有\\(n\\)匹配的卡片（一共有\\(2n\\)张）。对于一个能够预测到牌子底下动物的预言家，他一定能够采取最优的策略，即每次翻出一对相同的卡片。这意味着预言家只需要\\(n\\)回合就可以结束游戏。因此令\\(t(n)\\)表示包含\\(n\\)对卡片时，预言家所采取最优策略需要的回合数，可以给出为：\\(t(n)=n\\)。\r\n考虑如下在线策略：每次揭开这\\(2n\\)张卡片中尚未曾经揭开过的两张，如果相同，那么移除，否则记住卡片上的动物并翻转回去，这个阶段一共包含了\\(n\\)回合的操作，并且至多只剩下\\(m(m\\le\r\nn)\\)对卡片在卡片堆中。接下来只需要将这\\(2m\\)张卡片按照记忆，一对对进行翻转并移除即可，这个阶段包含了\\(m\\)次操作。因此这个在线算法的操作次数为\\(h(n)=m+n\\le n+n\\le 2n\\)。\r\n由于\\(\\forall n\\ge 1,\\dfrac{h(n)}{t(n)}\\le\r\n2\\)均成立，因此如上策略满足题意。\r\n","categories":["算法导论"]},{"title":"算法导论30.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-30/exercises-2/","content":"\r\n30.2-1\r\n\\(\\begin{aligned}\r\n\\omega_{n}^{n/2} &amp;= (e^{2\\pi i/n})^{n/2}\\\\\r\n&amp;=e^{\\pi i}\\\\\r\n&amp;=e^{2\\pi i/2}\\\\\r\n&amp;=\\omega_2\\\\\r\n&amp;=\\cos \\pi+i\\sin\\pi\\\\\r\n&amp;=-1\r\n\\end{aligned}\\)\r\n30.2-2\r\n经过暴力计算，可得\\(\\text{DFT}_4(A)\\)的结果如下：\r\n\\(\\begin{aligned}\r\ny_0&amp;=0\\cdot (\\omega_{4}^0)^0+1\\cdot (\\omega_{4}^0)^1+2\\cdot\r\n(\\omega_{4}^0)^2+3\\cdot (\\omega_{4}^0)^3\\\\\r\n&amp;=6\\\\\r\ny_1&amp;=0\\cdot (\\omega_{4}^1)^0+1\\cdot (\\omega_{4}^1)^1+2\\cdot\r\n(\\omega_{4}^1)^2+3\\cdot (\\omega_{4}^1)^3\\\\\r\n&amp;=0+i-2-3i\\\\\r\n&amp;=-2i\\\\\r\ny_2&amp;=0\\cdot (\\omega_{4}^2)^0+1\\cdot (\\omega_{4}^2)^1+2\\cdot\r\n(\\omega_{4}^2)^2+3\\cdot (\\omega_{4}^2)^3\\\\\r\n&amp;=0+1\\cdot(-1)+2-3\\cdot(-1)\\\\\r\n&amp;=-2\\\\\r\ny_3&amp;=0\\cdot (\\omega_{4}^3)^0+1\\cdot (\\omega_{4}^3)^1+2\\cdot\r\n(\\omega_{4}^3)^2+3\\cdot (\\omega_{4}^3)^3\\\\\r\n&amp;=0-1\\cdot(-i)+2\\cdot(-1)+3\\cdot i\\\\\r\n&amp;=2i-2\r\n\\end{aligned}\\)\r\n即有\\(\\text{DFT}_4(A)=(6,-2i,-2,2i-2)\\)。\r\n30.2-3\r\n如下是递归计算\\(\\text{FFT}((-10,1,-1,7,0,0,0,0),8)\\)的结果：\r\n\\(\\begin{aligned}\r\n&amp;\\text{FFT}((-10,1,-1,7,0,0,0,0),8)\\\\\r\n&amp;\\qquad \\text{FFT}((−10,−1,0,0),4)\\\\\r\n&amp;\\qquad\\qquad \\text{FFT}((-10,0),2)\\\\\r\n&amp;\\qquad\\qquad\\qquad \\text{FFT}((-10),1)\\\\\r\n&amp;\\qquad\\qquad\\qquad\\qquad y=(-10)\\\\\r\n&amp;\\qquad\\qquad\\qquad \\text{FFT}(0,1)\\\\\r\n&amp;\\qquad\\qquad\\qquad\\qquad y=(0)\\\\\r\n&amp;\\qquad\\qquad\\qquad y=(-10,10)\\\\\r\n&amp;\\qquad\\qquad \\text{FFT}((-1,0),2)\\\\\r\n&amp;\\qquad\\qquad\\qquad \\text{FFT}((-1),1)\\\\\r\n&amp;\\qquad\\qquad\\qquad\\qquad y=(-1)\\\\\r\n&amp;\\qquad\\qquad\\qquad \\text{FFT}((0),1)\\\\\r\n&amp;\\qquad\\qquad\\qquad\\qquad y=(0)\\\\\r\n&amp;\\qquad\\qquad\\qquad y=(-1,1)\\\\\r\n&amp;\\qquad\\qquad y=(-11,-10-i,-9,-10+i)\\\\\r\n&amp;\\qquad \\text{FFT}((1,7,0,0),4)\\\\\r\n&amp;\\qquad\\qquad \\text{FFT}((1,0),2)\\\\\r\n&amp;\\qquad\\qquad\\qquad \\text{FFT}((1),1)\\\\\r\n&amp;\\qquad\\qquad\\qquad\\qquad y=(1)\\\\\r\n&amp;\\qquad\\qquad\\qquad \\text{FFT}(0,1)\\\\\r\n&amp;\\qquad\\qquad\\qquad\\qquad y=(0)\\\\\r\n&amp;\\qquad\\qquad\\qquad y=(1,11)\\\\\r\n&amp;\\qquad\\qquad \\text{FFT}((7,0),2)\\\\\r\n&amp;\\qquad\\qquad\\qquad \\text{FFT}((7),1)\\\\\r\n&amp;\\qquad\\qquad\\qquad\\qquad y=(7)\\\\\r\n&amp;\\qquad\\qquad\\qquad \\text{FFT}((0),1)\\\\\r\n&amp;\\qquad\\qquad\\qquad\\qquad y=(0)\\\\\r\n&amp;\\qquad\\qquad\\qquad y=(7,7)\\\\\r\n&amp;\\qquad\\qquad y=(8,1+7i,-6,1-7i)\\\\\r\n&amp;\\qquad\r\ny=(-3,-(10+3\\sqrt{2})+(4\\sqrt{2}-1)i,-9-6i,(-10+3\\sqrt{2})+(4\\sqrt{2}+1)i,-19,(-10+3\\sqrt{2})-(4\\sqrt{2}+1)i,-9+6i,-(10+3\\sqrt{2})+(1-4\\sqrt{2})i)\r\n\\end{aligned}\\)\r\n类似的，可以计算出\\(\\text{FFT}((3,-6,0,8,0,0,0,0),8)\\)的结果为\r\n\\((5,(3-7\\sqrt{2})+\\sqrt{2}i,3-14i,(3+7\\sqrt{2})+\\sqrt{2}i,1,(3+7\\sqrt{2})-\\sqrt{2}i,3+14i,(3-7\\sqrt{2})-\\sqrt{2}i)\\)\r\n通过点值表示法将各自的值直接相乘，可以得到乘积的点值表示为\r\n\\((-15,(4+62\\sqrt{2})+(-65+9\\sqrt{2})i,-111+108i,(4-62\\sqrt{2})+(65+9\\sqrt{2})i,-19,(4-62\\sqrt{2})+(-65-9\\sqrt{2})i,-111-108i,(4+62\\sqrt{2})+(65-9\\sqrt{2})i)\\)\r\n最终通过逆快速傅里叶变换得到答案为\\((-30,63,-9,-53,-34,-8,56,0)\\)。\r\n30.2-4\r\n给出的代码为FFT-INV。\r\nFFT-INV(y, n)  if n == 1    return y  ωn = exp(-2 * π * i / n)  ω = 1  y-even = (y_0, y_2, ..., y_&#123;n - 2&#125;)  y-odd = (y_1, y_3, ..., y_&#123;n - 1&#125;)  a-even = FFT-INV(y-even, n / 2)  a-odd = FFT-INV(y-odd, n / 2)  for k = 0 to n / 2 - 1    a_k = (a-even_&#123;k&#125; + ω * a-odd_&#123;k&#125;) / n    a_&#123;k + n / 2&#125; = (a-even_&#123;k&#125; - ω * a-odd_&#123;k&#125;) / n    ω = ω * ωn  return a\r\n30.2-5\r\n参考引理30.5，首先证明三分引理：如果\\(n\\)是一个\\(3\\)的倍数，那么这\\(n\\)个\\(n\\)次单位复数根的立方的集合就是\\(n/3\\)个\\(n/3\\)次单位复数根的集合。\r\n接下来证明这个引理，考虑\\((\\omega_{n}^{k+n/3})^3,(\\omega_{n}^{k+2n/3})^3,(\\omega_{n}^{k})^3\\)之间的关系，有\r\n\\(\\begin{aligned}\r\n(\\omega_{n}^{k+n/3})^3&amp;=\\omega_n^{3k}\\omega_n^n\\\\\r\n&amp;=\\omega_n^{3k}\\\\\r\n&amp;=(\\omega_n^{k})^3\\\\\r\n(\\omega_{n}^{k+2n/3})^3&amp;=\\omega_n^{3k}\\omega_n^{2n}\\\\\r\n&amp;=\\omega_n^{3k}\r\n\\end{aligned}\\)\r\n根据引理30.3和上面的结论，可以得到\\((\\omega_{n}^{k+n/3})^3=(\\omega_{n}^{k+2n/3})^3=(\\omega_{n}^{k})^3=\\omega_{n}^{3k}=\\omega_{n/3}^{k}\\)，最终引理成立。\r\n那么接下来令\\(\\displaystyle{A(x)=\\sum_{i=0}^{n-1}\r\na_ix^{i}}\\)，并且定义\\(\\displaystyle{A^{(k)}(x)=\\sum_{i=0}^{n/3-1}\r\na_{3i+k}x^{i}}\\)，其中\\(k\\in\\{0,1,2\\}\\)。那么可以将\\(A(x)\\)写成：\r\n\\[A(x)=A^{(0)}(x^3)+xA^{(1)}(x^3)+x^2A^{(2)}(x^3)\\]\r\n那么一个规模为\\(n\\)的问题被分解成\\(3\\)个规模为\\(n/3\\)的问题。令\\(T(n)\\)表示规模为\\(n\\)的问题的运行时间，那么有\r\n\\[T(n)=3T(n/3)+\\Theta(n)\\]\r\n按照主定理的第二个条件，可以得到\\(T(n)=\\Theta(n\\lg n)\\)。\r\n如下是满足这个情况时的算法FFT3：\r\nFFT3(y, n)  if n == 1    return y  ωn = exp(2 * π * i / n)  ω = 1  a0 = (a_0, a_3, ..., y_&#123;n - 3&#125;)  a1 = (a_1, a_4, ..., y_&#123;n - 2&#125;)  a2 = (a_2, a_5, ..., y_&#123;n - 1&#125;)  y0 = FFT3(a0, n / 3)  y1 = FFT3(a1, n / 3)  y2 = FFT3(a2, n / 3)  for k = 0 to n / 3 - 1    y_&#123;k&#125; = y0_&#123;k&#125; + ω * y1_&#123;k&#125; + ω^2 * y2_&#123;k&#125;    y_&#123;k + n / 3&#125; = y0_&#123;k&#125; + (ω * ω_&#123;3&#125;^&#123;1&#125;) * y1_&#123;k&#125; + (ω * ω_&#123;3&#125;^&#123;1&#125;)^2 * y2_&#123;k&#125;    y_&#123;k + 2 * n / 3&#125; = y0_&#123;k&#125; + (ω * ω_&#123;3&#125;^&#123;2&#125;) * y1_&#123;k&#125; + (ω * ω_&#123;3&#125;^&#123;2&#125;)^2 * y2_&#123;k&#125;    ω = ω * ωn  return a\r\n\\(\\star\\)\r\n30.2-6\r\n不难发现\\(\\gcd(m,\\omega)=1\\)，因为\\(m\\)为奇数，且\\(\\omega\\)只包含因子\\(2\\)。因此\\(\\omega\\in\r\n\\mathbb{Z}_m^{\\ast}\\)。接下来考虑\\(\\omega\\)在\\(\\mathbb{Z}_m^\\ast{}\\)中的阶\\(k=\\lambda_m(\\omega)\\)，也就是最小的整数使得\\(\\omega^{k}\\equiv 1\\pmod m\\)成立。\r\n考虑\\(\\dfrac{2^{tk}-1}{2^{tn/2}+1}=\\dfrac{2^{tk}+2^{tn/2}}{2^{tn/2}+1}-1=2^{tn/2}\\cdot\\dfrac{2^{tk-tn/2}+1}{2^{tn/2}+1}-1\\)，当\\(k=n\\)时，\\(\\dfrac{2^{tk-tn/2}+1}{2^{tn/2}+1}=1\\)，即保持了整除，且分子是分母的最小倍数，因此有\\(k=n\\)，即\\(\\lambda_m(\\omega)=n\\)。\r\n由于\\(\\lambda_m(\\omega)=n\\)的存在，因此由元素\\(\\omega\\)在\\(\\mathbb{Z}_m\\)所生成的群\\(\\langle\\omega\\rangle\\)是一个循环群。那么定义\\(\\omega^j=2^{tj}\\bmod m\\)。\r\n接下来证明引理/定理/推论30.3，30.4，30.5，30.6, 30.7在\\(\\langle\\omega\\rangle\\)中是成立的。\r\n引理30.3的证明：考虑\\(n\\)的某个因子\\(d\\)，令\\(\\omega&#39;=2^{td}\\)，那么有\\(\\omega&#39;^{k/d}\\equiv 2^{tk}\\equiv\r\n\\omega^{k}\\pmod m\\)。因此原结论成立。\r\n推论30.4的证明：\\(\\omega^{n/2}\\equiv\r\n2^{tn/2}\\equiv -1\\pmod {m}\\)，因此结论得证。\r\n引理30.5的证明：\\((\\omega^{k+n/2})^2\\equiv\\omega^{2k+n}\\equiv\\omega^{2k}\\omega^n\\equiv\\omega^{2k}\\equiv\r\n(\\omega^k)^2\\pmod m\\)，因此结论得证。\r\n引理30.6的证明：当\\(n\\nmid\r\nk\\)时，有\\(\\omega^k\\not\\equiv 1\\pmod\r\nm\\)成立。证明过程和原本的定理30.6的计算过程一致，原结论得证。\r\n定理30.7的证明：此时\\(V_{n}^{-1}\\)的第\\(j\\)行第\\(k\\)列的项为\\(\\omega^{-jk}\\cdot n^{-1}\\bmod\r\nm\\)。由于\\(n\\)是\\(2\\)的幂，但是\\(m\\)是奇数，因此\\(\\gcd(n,m)=1\\)，因此在\\(\\mathbb{Z}_m\\)中存在\\(n\\)的逆元\\(n^{-1}\\)，结论中的写法是成立的，考虑\\([V_{n}^{-1}V_n]_{kk}\\)的值，有\\([V_{n}^{-1}V_n]_{kk}\\equiv\\displaystyle{\\sum_{j=0}^{n-1}}(\\omega^{-jk}\\cdot\r\nn^{-1})(\\omega^{jk&#39;})\\equiv n^{-1}\\cdot\r\n\\sum_{j=0}^{n-1}\\omega^{j(k&#39;-k)}\\pmod\r\np\\)。其余证明过程类似，因此原结论成立。\r\n在\\(\\langle\\omega\\rangle\\)中，首先计算好\\(\\omega\\)的幂\\(\\omega^i\\)。由于\\(\\langle\\omega\\rangle\\subseteq\r\n\\mathbb{Z}_m^{\\ast}\\subseteq \\mathbb{Z}_m\\)，可见\\(\\omega^i\\in \\mathbb{Z}_m\\)。因此\\(\\displaystyle{y_k=\\sum_{i=0}^{n-1}a_i(\\omega^k)^i}\\)的整个计算过程是封闭的，DFT过程是正确定义的。\r\n对于DFT的逆过程，由于\\(\\gcd(\\omega,m)=1\\)，因此\\(\\omega\\)在\\(\\mathbb{Z}_m\\)中也存在逆元\\(\\omega^{-1}\\)，容易验证\\(\\langle\r\n\\omega\\rangle=\\langle\\omega^{-1}\\rangle\\)，因此\\(\\displaystyle{a_k=n^{-1}\\sum_{i=0}^{n-1}y_i(\\omega^{-k})^i}\\bmod\r\nm\\)的整个计算过程是封闭的，即DFT的逆过程是正确定义的。\r\n最终原结论成立。\r\n30.2-7\r\n我们将考虑构造出多项式\\(\\displaystyle{P(x)=\\prod_{i=0}^{n-1}(x-z_i)}\\)，并考虑计算它的系数。\r\n可见，\\(P(x)\\)是由\\(n\\)个\\(1\\)次多项式同时相乘。令\\(m\\)是大于等于\\(n\\)的最小二次幂，那么\\(P(x)\\)也可以看成是由\\(m\\)个\\(1\\)次项同时相乘。\r\n接下来考虑讲相邻的每\\(2\\)个\\(k\\)次多项式因子相乘，得到一个新的\\(2k\\)次多项式进行存储，这个过程需要进行\\(\\dfrac{m}{2k}\\)次，得到\\(\\dfrac{m}{2k}\\)个\\(2k\\)次多项式因子，接下来将\\(k\\)扩增成\\(2\\)倍继续操作即可。具体算法由GEN-POLY-BY-ZERO-POINT给出。\r\nGEN-POLY-BY-ZERO-POINT(z, n)  let m be a power of 2 s.t. m &gt;= n and m is minium   let P[0 : m - 1] be a new array  for i = 0 to m    if i &lt; n      P[i] = [-z[i], 1]    else      P[i] = [1, 0]  b = m  while b &gt; 1    l = n / b * 2    let Q[0 : b / 2 - 1] be a new array    for i = 0 to b / 2 - 1      for k = 0 to l        INSERT(P[i * 2], 0)        INSERT(P[i * 2 + 1], 0)      Q[i] = IFFT-INV(FFT(P[i * 2], 2 * l) ⋅ FFT(P[i * 2 + 1], 2 * l), 2 * l)    b = b / 2    P = Q  return P[0, 0 : n]\r\n在每次while循环中，需要进行\\(\\dfrac{m}{2k}\\)次规模大小为\\(O(k\\lg\r\nk)\\)的FFT，因此单次while循环的时间复杂度为\\(\\dfrac{m}{2k}\\cdot O(k\\lg k)=O(m\\lg k)=O(m\\lg\r\nm)\\)。由于需要进行\\(\\lg\r\nm\\)次while循环，并且\\(m=\\Theta(n)\\)因此GEN-POLY-BY-ZERO-POINT的时间复杂度为\\(m\\cdot O(m\\lg\r\nm)=O(m\\lg^2m)=O(n\\lg^2n)\\)。\r\n\\(\\star\\)\r\n30.2-8\r\n构造如下两个多项式：\\(\\displaystyle{B(x)=\\sum_{j=0}^{n-1}b_jx^j}\\)和\r\n\\(\\displaystyle{C(x)=\\sum_{j=0}^{n-1}C_jx^j}\\)，其中\\(b_j=a_jz^{j^2/2},c_j=z^{-j^2/2}\\)。使用FFT算法可以求出\\(D(x)=B(x)\\cdot C(x)\\)。令\\(\\displaystyle{D(x)=\\sum_{j=0}^{n-1}d_jx^j}\\)。那么可以知道：\r\n\\(\\begin{aligned}\r\nd_k&amp;=\\sum_{j=0}^{k} b_jc_{k-j}\\\\\r\n&amp;=\\sum_{j=0}^{k} (a_jz^{j^2/2})(z^{-(k-j)^2/2})\r\n\\end{aligned}\\)\r\n对于\\(\\forall k\\in[0,n)\\)，在以\\(O(n\\lg n)\\)的时间计算好值\\(d_k\\)的值之后，只需要令\\(y_k=z^{k^2/2}\\cdot\r\nd_k\\)即可。此外多项式\\(B(x),C(x)\\)可以以\\(O(n\\lg\r\nn)\\)的时间构造出来，因此最终整个过程仅使用\\(O(n\\lg\r\nn)\\)的时间完成。大概过程由CHIRP-TRANSFORM给出。\r\nCHIRP-TRANSFORM(A, n, z)  let m be a power of 2 s.t. m &gt;= n and m is minium   let B[0 : 2 * m - 1], C[0 : 2 * m - 1] be new arrays by 0  for j = 0 to n - 1    w = exp(z, j * j / 2)    B[j] = A[j] * w    C[j] = 1 / w  D = IFFT-INV(FFT(B, 2 * l) ⋅ FFT(C, 2 * l), 2 * l)  let Y[0 : n - 1] be a new array  for k = 0 to n - 1    Y[k] = exp(z, k * k / 2) * D[k]  return Y\r\n","categories":["算法导论"]},{"title":"算法导论27.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-27/exercises-2/","content":"\r\n27.2-1\r\n由于每次查询都是相互独立的，因此假设每一次查询需要进行检索的期望值为\\(e\\)（与查询的序号无关）。由于需要检索关键字的概率为\\(x_i\\)，因此这时\\(e\\)值为\r\n\\(\\begin{aligned}\r\ne&amp;=\\sum_{k=1}^n k\\cdot\\left(\\sum_{x\\in S\\land r_L(x)=k}\r\np(x)\\right)\\\\\r\n&amp;=\\sum_{i=1}^n r_L(x_i)\\cdot p(x_i)\r\n\\end{aligned}\\)\r\n因此\\(m\\)次查询的总期望次数为\\(\\displaystyle{me=m\\sum_{i=1}^n r_L(x_i)\\cdot\r\np(x_i)}\\)。\r\n如果\\(L\\)中的关键字\\(x_i\\)不是按照查询概率\\(p\\)从大到小出现的，那么必定存在一对不同的关键字\\(x_j,x_k\\)，使得\\(r_L(x_j)&lt;r_L(x_k)\\)并且有\\(p(x_j)&lt;p(x_k)\\)。那么考虑新构造的静态表\\(L&#39;\\)，它是将关键字\\(x_j\\)和\\(x_k\\)进行了交换，由此可见\\(r_L(x_i)=r_{L&#39;}(x_j),r_L(x_j)=r_{L&#39;}(x_i)\\)。考虑计算静态表上\\(L&#39;\\)进行一次检索的花费的期望值，可以得到\\(\\displaystyle{e&#39;=\\sum_{i=1}^n\r\nr_{L&#39;}(x_i)\\cdot p(x_i)}\\)。\r\n那么得到\r\n\\(\\begin{aligned}\r\ne&#39;-e&amp;=p(x_j)\\cdot r_{L&#39;}(x_j)+p(x_k)\\cdot\r\nr_{L&#39;}(x_k)-p(x_j)\\cdot r_{L}(x_j)-p(x_k)\\cdot r_{L&#39;}(x_k)\\\\\r\n&amp;=p(x_j)(r_{L&#39;}(x_j)-r_{L}(x_j))+p(x_k)(r_{L&#39;}(x_k)-r_{L}(x_k))\\\\\r\n&amp;=p(x_j)(r_{L}(x_k)-r_{L}(x_j))+p(x_k)(r_{L}(x_j)-r_{L}(x_k))\\\\\r\n&amp;=p(x_j)(r_{L}(x_k)-r_{L}(x_j))-p(x_k)(r_{L}(x_k)-r_{L}(x_j))\\\\\r\n&amp;=(p(x_j)-p(x_k))(r_{L}(x_k)-r_{L}(x_j))\\\\\r\n&amp;&lt;0\r\n\\end{aligned}\\)\r\n因此\\(L\\)不是使查找期望数最小的静态表。最终，只有按照\\(p(x_i)\\)降序的静态表才是所求的。\r\n27.2-2\r\n这个结论是错误的。FORESEE考虑的是全局最优的策略，每一个步骤的开销都并非比MOVE-TO-FRONT优秀。\r\n考虑对序列\\(\\langle\r\n1,2,3,4,5\\rangle\\)，接下来\\(3\\)次搜索分别是检索\\(3,5,5\\)，那么有\r\n\\(\\begin{array}{c|ccccc|ccccc}\r\n\\begin{array}{c}\\text{element}\\\\\\text{searched}\\end{array}\r\n&amp;L&amp;\\begin{array}{c}\\text{search}\\\\\\text{cost}\\end{array}&amp;\\begin{array}{c}\\text{swap}\\\\\\text{cost}\\end{array}&amp;\\begin{array}{c}\\text{search\r\n+}\\\\\\text{swap}\\\\\\text{cost}\\end{array}&amp;\\begin{array}{c}\\text{cumulative}\\\\\\text{cost}\\end{array}&amp;L&amp;\\begin{array}{c}\\text{search}\\\\\\text{cost}\\end{array}&amp;\\begin{array}{c}\\text{swap}\\\\\\text{cost}\\end{array}&amp;\\begin{array}{c}\\text{search\r\n+}\\\\\\text{swap}\\\\\\text{cost}\\end{array}&amp;\\begin{array}{c}\\text{cumulative}\\\\\\text{cost}\\end{array}\\\\\\hline\r\n3&amp;\\langle 1,2,3,4,5\\rangle&amp;3&amp;4&amp;7&amp;7&amp;\\langle\r\n1,2,3,4,5\\rangle&amp;3&amp;2&amp;5&amp;5\\\\\r\n5&amp;\\langle 5,1,2,3,4\\rangle&amp;1&amp;0&amp;0&amp;8&amp;\\langle\r\n3,1,2,4,5\\rangle&amp;5&amp;4&amp;9&amp;14\\\\\r\n5&amp;\\langle 5,1,2,3,4\\rangle&amp;1&amp;0&amp;0&amp;9&amp;\\langle\r\n5,3,1,2,4\\rangle&amp;1&amp;0&amp;0&amp;15\r\n\\end{array}\\)\r\n可见在这个检索序列中，FORESEE的总操作开销小于MOVE-TO-FRONT的总操作，但是FORESEE的第一步开销大于MOVE-TO-FRONT的第一步开销，从而证伪原结论。\r\n27.2-3\r\n结论：这种通过关键字的访问次数维护表\\(L\\)的策略并非是常数竞争比例的。\r\n考虑一个表\\(L\\)中有如下关键字：\\(\\langle\r\n1,2,3,\\dots,n\\rangle\\)，以及一个访问序列：首先进行\\(n\\)次对\\(1\\)的访问，然后进行\\(n\\)次对\\(2\\)的访问，接下来进行\\(n\\)次对\\(3\\)的访问……最后对\\(n\\)进行\\(n\\)次访问。也就是说，一共对表\\(L\\)进行了\\(n^2\\)次检索。在这个过程中，不失一般性，如果存在元素的访问次数相同，那么对列表重排后，相同访问次数的元素相对顺序不变。那么在这个过程中，表\\(L\\)所有的关键字的顺序将会维持不变（因为访问次数全程都是非递增的）。\r\n在这\\(n^2\\)检索中，对于第\\((k-1)n+1\\)到第\\(kn\\)次访问（其中\\(k\\in[1,n]\\)），都是访问\\(L\\)中的第\\(k\\)个元素，所花费的代价为\\(k\\)。因此，这\\(n^2\\)次操作的代价为\\(\\displaystyle{c_1(n)=\\sum_{k=1}^nnk=n\\cdot\r\n\\dfrac{n(n+1)}{2}=\\dfrac{n^2(n+1)}{2}}\\)。\r\n考虑使用MOVE-TO-FRONT算法充当FORESEE算法的角色。对于第\\((k-1)n+1\\)到第\\(kn\\)次访问中，第\\(k(n-1)\\)次访问使用了\\(k\\)的开销寻找到了这个元素，并且用\\(k-1\\)的开销将其移动到最前面，因此总共有\\(2k-1\\)的开销；而第\\((k-1)n+2\\)到第\\(kn\\)次访问中，仅仅使用了\\(1\\)的代价用于寻找。因此，这\\(n^2\\)次操作的代价为\\(\\displaystyle{c_2(n)=\\sum_{k=1}^n(2k-1+n-1)=n^2-2n+n(n+1)=2n^2-n}\\)。\r\n可见，\\(\\dfrac{c_1(n)}{c_2(n)}=O(n)\\)，因此这种策略不是常数竞争比例的。\r\n27.2-4\r\n如果MOVE-TO-FRONT算法移动元素不需要花费任何的代价，那么方程27.3可以改写成：\r\n\\(c_i^M=r_{{L}_{i-1}^M}(x)\\)\r\n如果使用势函数\\(\\Phi_i=I(L_i^M,L_i^F)\\)，并且这个模型下中，第\\(i\\)次操作的真实代价为\\(c_i^{M}\\)，均摊代价为\\(\\hat{c}_i^M\\)。那么有\\(\\hat{c}_i^M=c_i^M+\\Phi_{i}-\\Phi_{i-1}\\)，并且按照\\(I\\)的定义，可见有\\(\\Phi_0=0,\\forall i\\in[1,n],\\Phi_{i}\\ge\r\n0\\)。考虑计算\\(\\hat{c}_i^M\\)，通过书上类似的论证方式，有\r\n\\(\\begin{aligned}\r\n\\hat{c}_i^M&amp;=c_i^M+\\Phi_{i}-\\Phi_{i-1}\\\\\r\n&amp;=r_{{L}_{i-1}^M}(x)+(|BB|-|BA|+t_i)\\\\\r\n&amp;=r_{{L}_{i-1}^M}(x)+(|BB|-(r_{{L}_{i-1}^M}(x)-1-|BB|)+t_i)\\\\\r\n&amp;=2|BB|+1+t_i\\\\\r\n&amp;\\le 2|BB|+2|AB|+2t_i+2\\\\\r\n&amp;= 2(|BB|+|AB|+t_i+1)\\\\\r\n&amp;=2(r_{L_{i-1}^F}(x)+t_i)\\\\\r\n&amp;=2c_i^F\r\n\\end{aligned}\\)\r\n那么由于\\(\\displaystyle{\\sum_{i=1}^m\\hat{c}_i^M=\\sum_{i=1}^mc_i^M+\\Phi_m-\\Phi_0\\ge\r\n\\sum_{i=1}^mc_i^M}\\)\r\n\\(\\begin{aligned}\r\n\\sum_{i=1}^m\\hat{c}_i^M&amp;=\\sum_{i=1}^mc_i^M+\\Phi_m-\\Phi_0\\\\\r\n&amp;\\ge \\sum_{i=1}^mc_i^M，\r\n\\end{aligned}\\)\r\n因此有\r\n\\(\\begin{aligned}\r\n\\sum_{i=1}^mc_i^M&amp;\\le\\sum_{i=1}^m\\hat{c}_i^M\\\\\r\n&amp;\\le\\sum_{i=1}^m2c_i^F\\\\\r\n&amp;=2\\sum_{i=1}^mc_i^F\\\\\r\n\\end{aligned}\\)\r\n最终在这个模型下，如果不计算算法MOVE-TO-FRONT移动关键字的代价，那么它是\\(2\\)竞争的。\r\n","categories":["算法导论"]},{"title":"算法导论3.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-3/exercises-3/","content":"\r\n3.3-1\r\n假设\\(m\\le n\\)，那么根据\\(f(n),g(n)\\)的单调性，可以得到：\r\n\\(\\begin{aligned}\r\nf(m)\\le f(n)\\\\\r\ng(m)\\le g(n)\r\n\\end{aligned}\\)\r\n那么得到\\(f(m)+g(m)\\le\r\nf(n)+g(n)\\)，因此函数\\(f(n)+g(n)\\)是单调递增的。\r\n由于\\(g(m)\\le g(n)\\)，那么根据\\(f\\)的单调性，\\(f(g(m))\\le f(g(n))\\)，因此函数\\(f(g(n))\\)是单调递增的。\r\n在\\(0\\le g(n),0\\le\r\nf(n)\\)的基础上，那么有以下不等式：\r\n\\(0\\le f(m)\\cdot g(m)\\le f(n)\\cdot g(m)\\le\r\nf(n)\\cdot g(m)\\)\r\n因此函数\\(f(n)\\cdot\r\ng(n)\\)是单调递增的。\r\n3.3-2\r\n\\(\\begin{aligned}\r\n\\lfloor\\alpha n\\rfloor+\\lceil(1-\\alpha)n\\rceil&amp;=\\lfloor\\alpha\r\nn\\rfloor+\\lceil n-\\alpha n\\rceil\\\\\r\n&amp;=\\lfloor\\alpha n\\rfloor+\\lceil-\\alpha n\\rceil + n\\\\\r\n&amp;=\\lfloor\\alpha n\\rfloor-\\lfloor \\alpha n\\rfloor + n\\\\\r\n&amp;=n\r\n\\end{aligned}\\)\r\n3.3-3\r\n不难发现当\\(k=0\\)时结论成立。\r\n考虑极限\\(\\displaystyle{\\lim_{n\\rightarrow\\infty}\r\n\\dfrac{(n+o(n))^k}{n^k}}\\)的值。\r\n\\[\\begin{aligned}\r\n\\lim_{n\\rightarrow\\infty}\\dfrac{(n+o(n))^k}{n^k}&amp;=\\lim_{n\\rightarrow\\infty}\\left(1+\\dfrac{o(n)}{n}\\right)^k\\\\\r\n&amp;=1\r\n\\end{aligned}\\]\r\n因此有\\((n+o(n))^k=\\Theta(n^k)\\)\r\n由于\\(n\\le \\lceil n\\rceil &lt;\r\nn+1\\)，发现：\r\n\\(n^k=\\Theta(n^k)\\)\r\n又因为\\(1=o(n)\\)，根据上面的结论，有\\((n+1)^k=\\Theta(n^k)\\).\r\n当\\(k&lt;0\\)时，得到\\((n+1)^k&lt; \\lceil n\\rceil ^k\\le\r\nn^k\\)，由于\\((n+1)^k=\\Omega(n^k),n^k=O(n^k)\\)，因此有\\(\\lceil n\\rceil^k=\\Theta(n^k)\\)。\r\n当\\(k&lt;0\\)时，得到\\(n^k\\le \\lceil n\\rceil ^k&lt;\r\n(n+1)^k\\)，由于\\((n+1)^k=O(n^k),n^k=\\Omega(n^k)\\)，因此有\\(\\lceil n\\rceil^k=\\Theta(n^k)\\)。\r\n综上所述，\\(\\lceil\r\nn\\rceil^k=\\Theta(n^k)\\)。\r\n\\(\\lfloor\r\nn\\rfloor\\)的证法类似，使用不等式\\(n-1&lt;\\lfloor n\\rfloor \\le n\\)即可。\r\n3.3-4\r\na\r\n\\[a^{\\lg _b c}=a^{\\frac{\\lg _a c}{\\lg _a\r\nb}}=a^{\\lg_a c\\cdot \\frac{1}{\\lg _a b}}=c^{\\frac{1}{\\lg _a b}}=c^{\\lg _b\r\na}\\]\r\nb\r\n对于\\(n!=o(n^n)\\)，考虑计算极限\\(\\displaystyle{\\lim_{n\\rightarrow +\\infty}\r\n\\dfrac{n!}{n^n}}\\)的值，有\r\n\\[\\begin{aligned}\r\n\\lim_{n\\rightarrow +\\infty} \\dfrac{n!}{n^n}&amp;=\\lim_{n\\rightarrow\r\n+\\infty}\\dfrac{\\sqrt{2\\pi n}\r\n\\left(\\dfrac{n^n}{e^n}\\right)\\left(1+\\Theta\\left(\\dfrac{1}{n}\\right)\\right)}{n^n}\\\\\r\n&amp;=\\lim_{n\\rightarrow +\\infty}\\dfrac{\\sqrt{2\\pi\r\nn}\\left(1+\\Theta\\left(\\dfrac{1}{n}\\right)\\right)}{e^n}\\\\\r\n&amp;=\\lim_{n\\rightarrow +\\infty}\\dfrac{\\sqrt{2\\pi\r\nn}\\left(1+\\Theta\\left(\\dfrac{1}{n}\\right)\\right)}{e^n}\\\\\r\n&amp;=\\lim_{n\\rightarrow\r\n+\\infty}\\dfrac{O\\left(\\frac{1}{\\sqrt{n}}\\right)}{e^n}\\\\\r\n&amp;=0\r\n\\end{aligned}\\]\r\n因此\\(n!=o(n^n)\\)。\r\n对于\\(n!=\\omega(2^n)\\)，考虑计算极限\\(\\displaystyle{\\lim_{n\\rightarrow +\\infty}\r\n\\dfrac{2^n}{n!}}\\)的值，有\r\n\\[\\begin{aligned}\r\n\\lim_{n\\rightarrow +\\infty} \\dfrac{2^n}{n!}&amp;=\\lim_{n\\rightarrow\r\n+\\infty}\\dfrac{2^n}{\\sqrt{2\\pi n}\r\n\\left(\\dfrac{n^n}{e^n}\\right)\\left(1+\\Theta\\left(\\dfrac{1}{n}\\right)\\right)}\\\\\r\n&amp;=\\lim_{n\\rightarrow +\\infty}\\dfrac{1}{\\sqrt{2\\pi n}\\cdot\r\n\\left(1+\\Theta\\left(\\dfrac{1}{n}\\right)\\right)}\\cdot\r\n\\left(\\dfrac{2e}{n}\\right)^n\\\\\r\n&amp;\\le\\lim_{n\\rightarrow +\\infty}\\left(\\dfrac{2e}{n}\\right)^n\\\\\r\n&amp;=0\r\n\\end{aligned}\\]\r\n因此\\(n!=\\omega(2^n)\\)。\r\n对于\\(\\lg n!=\\Theta(n\\lg\r\nn)\\)，有\r\n\\[\\begin{aligned}\r\n\\lg n!&amp;=\\lg \\sqrt{2\\pi n} + n\\lg n-n\\lg\r\ne+\\lg\\left(1+\\Theta\\left(\\dfrac{1}{n}\\right)\\right) \\\\\r\n&amp;=\\Theta(\\lg n)+\\Theta(n\\lg n)+ \\Theta(n) +\r\n\\Theta\\left(\\dfrac{1}{n}\\right)\\\\\r\n&amp;=\\Theta(n\\lg n)\r\n\\end{aligned}\\]\r\n因此\\(\\lg n!=\\Theta(n\\lg n)\\)。\r\nc\r\n假设\\(f(n)=\\lg(\\Theta(n))\\)，那么\\(\\exists c_1,c_2,n_0,\\forall n\\ge n_0,0\\le \\lg (c_1\r\nn)\\le f(n)\\le \\lg (c_2n)\\)成立，也就是\r\n\\[\\lg c_1+\\lg n\\le f(n)\\le \\lg c_2 + \\lg\r\nn\\]\r\n由于\\(c_1,c_2\\)是常数，因此\\(\\lg c_1+\\lg n=\\Omega(\\lg n),\\lg c_2=O(\\lg\r\nn)\\)，因此\\(f(n)=\\Theta(\\lg\r\nn)\\)。\r\n假设\\(f(n)=\\Theta(\\lg\r\nn)\\)，那么\\(\\exists c_1,c_2,n_0,\\forall\r\nn\\ge n_0,0\\le c_1\\lg n\\le f(n)\\le c_2\\lg n\\)成立。由于\\(\\lg n=\\lg \\Theta(n)\\)，也就是有\\(\\lg n=\\lg \\Omega(n),\\lg n=\\lg\r\nO(n)\\)，因此\\(f(n)=\\lg\r\n\\Theta(n)\\)。\r\n最终，\\(\\lg(\\Theta(n))=\\Theta(\\lg\r\nn)\\)\r\n\\(\\star\\)\r\n3.3-5\r\n证明一个函数\\(f(n)\\)是多项式有界的等价于证明\\(\\lg f(n)=O(\\lg n)\\)。原因如下：\r\n充分性：根据定义，如果\\(f(n)\\)是多项式有界的，那么\\(\\exists c,k,n_0\\in \\mathbb{R}^{+},\\forall n\\ge\r\nn_0,0\\le f(n)\\le cn^k\\)均成立。不失一般性，假设\\(c\\ge 1\\)，因为\\(c&lt;1\\)意味着\\(f(n)\\le n^k\\)成立。假设\\(n_0\\ge 2\\)，那么有：\r\n\\(\\lg f(n)\\le \\lg c + k\\lg n\\le (\\lg\r\nc+k)\\lg n\\)\r\n因此有\\(\\lg f(n)=O(\\lg n)\\)\r\n必要性：如果\\(\\lg f(n)=O(\\lg\r\nn)\\)，那么\\(\\exists c,n_0\\in\r\n\\mathbb{R}^{+},\\forall n\\ge n_0,0\\le f(n)\\le \\lg\r\nn\\)。那么就有\r\n\\(0\\le f(n)=2^{\\lg f(n)}\\le 2^{c\\lg\r\nn}=n^c\\)\r\n因此\\(f(n)\\)是多项式有界的。\r\n最终使用如上结论来求解本题。\r\n这道题首先基于两个前置结论：\r\n\r\n\\(\\lg(n!)=\\Theta(n\\lg n)\\)\r\n\\(\\lceil \\lg n\\rceil=\\Theta(\\lg\r\nn)\\)，因为当\\(n\\ge\r\n2\\)时，满足\\(\\lg n\\le \\lceil \\lg\r\nn\\rceil \\le \\lg n+1\\le 2\\lg n\\)\r\n\r\n最终，可以得到：\r\n\\(\\begin{aligned}\r\n\\lg(\\lceil\\lg n\\rceil!)&amp;=\\Theta(\\lceil\\lg n\\rceil\\cdot \\lg(\\lceil\\lg\r\nn\\rceil))\\\\\r\n&amp;=\\Theta((\\lg n)\\cdot (\\lg \\lg n))\\\\\r\n&amp;=\\omega(\\lg n)\r\n\\end{aligned}\\)\r\n由于\\(\\lg(\\lceil\\lg n\\rceil!)\\neq O(\\lg\r\nn)\\)，因此\\(\\lceil\\lg\r\nn\\rceil!\\)不是多项式有界的。\r\n\\(\\begin{aligned}\r\n\\lg(\\lceil\\lg\\lg n\\rceil!)&amp;=\\Theta(\\lceil\\lg\\lg n\\rceil\\cdot\r\n\\lg(\\lceil\\lg\\lg n\\rceil))\\\\\r\n&amp;=\\Theta((\\lg\\lg n)\\cdot (\\lg\\lg\\lg n))\\\\\r\n&amp;=o((\\lg\\lg n)^2)\\\\\r\n&amp;=o(\\lg n) &amp;\\text{(A)}\\\\\r\n&amp;=O(\\lg n)\r\n\\end{aligned}\\)\r\n变换\\(A\\)使用了结论：对于所有正数\\(a,b\\)，都有\\(\\lg^b n&#39;=o(n&#39;^a)\\)。因此代入\\(b=2,a=1,n&#39;=\\lg n\\)得到最后一步。\r\n由于\\(\\lg(\\lceil\\lg\\lg n\\rceil!)= O(\\lg\r\nn)\\)，因此\\(\\lceil\\lg\\lg\r\nn\\rceil!\\)是多项式有界的。\r\n\\(\\star\\)\r\n3.3-6\r\n相比于\\(\\lg^{\\ast}n\\)，\\(\\lg^{\\ast}(\\lg n)\\)的迭代次数恰好少\\(1\\)，因为\\(n\\)进行一次迭代后就变成了 \\(\\lg n\\)。因此，\\(\\lg^{\\ast}(\\lg n)=\\lg^{\\ast}n-1\\)。\r\n令\\(t=\\lg^{\\ast}n,\\displaystyle{\\lim_{n\\rightarrow\r\n+\\infty} \\lg^{\\ast}n =+\\infty}\\)，因此有：\r\n\\[\\begin{aligned}\r\n\\lim_{n\\rightarrow+\\infty} \\dfrac{\\lg(\\lg ^{\\ast}n)}{\\lg^{\\ast}(\\lg\r\nn)}&amp;=\\lim_{n\\rightarrow+\\infty} \\dfrac{\\lg(\\lg ^{\\ast}n)}{\\lg^{\\ast}\r\nn-1}\\\\\r\n&amp;=\\lim_{t\\rightarrow+\\infty} \\dfrac{\\lg t}{t-1}\\\\\r\n&amp;=0\r\n\\end{aligned}\\]\r\n因此，\\(\\lg(\\lg\r\n^{\\ast}n)\\)的渐进增长速率要比\\(\\lg^{\\ast}(\\lg n)\\)慢。\r\n3.3-7\r\n可以得到\\(\\phi\\cdot\r\n\\hat{\\phi}=-1,\\phi+\\hat{\\phi}=1\\)。\r\n以\\(\\phi,\\hat{\\phi}\\)这两个值为解的一元二次方程可以构造出来：\\((x-\\phi)(x-\\hat{\\phi})=0\\)\r\n将左边展开后，有\\(x^2-(\\phi+\\hat{\\phi})x+\\phi\\cdot\\hat{\\phi}\\)，代入后得到\\(x^2-x-1\\)。\r\n那么最终可以构造出原一元二次方程\\(x^2=x+1\\)。\r\n3.3-8\r\n\\(\\phi=\\dfrac{1+\\sqrt{5}}{2},\\hat{\\phi}=\\dfrac{1-\\sqrt{5}}{2}\\)\r\n由于\\(\\phi,\\hat{\\phi}\\)是方程\\(x^2=x+1\\)的根，因此\\(\\phi^2=\\phi+1,\\hat{\\phi}^2=\\hat{\\phi}+1\\)。\r\n考虑使用数学归纳法证明。\r\n首先，\\(F_0=\\dfrac{\\phi^0-\\hat{\\phi}^0}{\\sqrt{5}}=0\\)，符合条件；\r\n\\(F_1=\\dfrac{\\phi^1-\\hat{\\phi}^1}{\\sqrt{5}}=\\dfrac{\\sqrt{5}}{\\sqrt{5}}=1\\)，符合条件。\r\n假设\\(F_{i-1}=\\dfrac{\\phi^{i-1}-\\hat{\\phi}^{i-1}}{\\sqrt{5}},F_{i-2}=\\dfrac{\\phi^{i-2}-\\hat{\\phi}^{i-2}}{\\sqrt{5}}\\)均成立，那么计算\\(F_{i-2}+F_{i-1}\\)，有\r\n\\[\\dfrac{\\phi^{i-1}+\\phi^{i-2}-(\\hat{\\phi}^{i-1}+\\hat{\\phi}^{i-2})}{\\sqrt{5}}=\\dfrac{(\\phi+1)\\phi^{i-2}-(\\hat{\\phi}+1)(\\hat{\\phi}^{i-2})}{\\sqrt{5}}=\\dfrac{\\phi^i-\\hat{\\phi}^i}{\\sqrt{5}}=F_i\\]\r\n因此原式\\(F_i\\)得证。\r\n3.3-9\r\n\\(k\\lg k =\\Theta(n)\\)，意味着\\(n=\\Theta(k\\lg k)\\)。\r\n那么\\(\\lg n=\\Theta(\\lg (k\\cdot \\lg\r\nk))=\\Theta(\\lg k+\\lg \\lg k)=\\Theta(\\lg k)\\)。\r\n因此有\\(\\dfrac{n}{\\lg\r\nn}=\\Theta\\left(\\dfrac{k\\lg k}{\\lg k}\\right)=\\Theta(k)\\).\r\n最终得到\\(k=\\Theta(n/\\lg n)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论31.6 Exercises 答案","url":"/introduction-to-algorithms/chapter-31/exercises-6/","content":"\r\n31.6-1\r\n\\(\\begin{aligned}\r\ni&amp;&amp; 0 &amp;&amp; 1 &amp;&amp; 2 &amp;&amp; 3 &amp;&amp; 4\r\n&amp;&amp; 5 &amp;&amp; 6 &amp;&amp; 7 &amp;&amp; 8 &amp;&amp; 9\r\n&amp;&amp; 10 \\\\\r\n1^i \\bmod 11 &amp;&amp; 1 &amp;&amp; 1 &amp;&amp; 1 &amp;&amp; 1\r\n&amp;&amp; 1 &amp;&amp; 1 &amp;&amp; 1 &amp;&amp; 1 &amp;&amp; 1\r\n&amp;&amp; 1 &amp;&amp; 1 \\\\\r\n2^i \\bmod 11 &amp;&amp; 1 &amp;&amp; 2 &amp;&amp; 4 &amp;&amp; 8\r\n&amp;&amp; 5 &amp;&amp; 10 &amp;&amp; 9 &amp;&amp; 7 &amp;&amp; 3\r\n&amp;&amp; 6 &amp;&amp; 1 \\\\\r\n3^i \\bmod 11 &amp;&amp; 1 &amp;&amp; 3 &amp;&amp; 9 &amp;&amp; 5\r\n&amp;&amp; 4 &amp;&amp; 1 &amp;&amp; 3 &amp;&amp; 9 &amp;&amp; 5\r\n&amp;&amp; 4 &amp;&amp; 1 \\\\\r\n4^i \\bmod 11 &amp;&amp; 1 &amp;&amp; 4 &amp;&amp; 5 &amp;&amp; 9\r\n&amp;&amp; 3 &amp;&amp; 1 &amp;&amp; 4 &amp;&amp; 5 &amp;&amp; 9\r\n&amp;&amp; 3 &amp;&amp; 1 \\\\\r\n5^i \\bmod 11 &amp;&amp; 1 &amp;&amp; 5 &amp;&amp; 3 &amp;&amp; 4\r\n&amp;&amp; 9 &amp;&amp; 1 &amp;&amp; 5 &amp;&amp; 3 &amp;&amp; 4\r\n&amp;&amp; 9 &amp;&amp; 1 \\\\\r\n6^i \\bmod 11 &amp;&amp; 1 &amp;&amp; 6 &amp;&amp; 3 &amp;&amp; 7\r\n&amp;&amp; 9 &amp;&amp; 10 &amp;&amp; 5 &amp;&amp; 8 &amp;&amp; 4\r\n&amp;&amp; 2 &amp;&amp; 1 \\\\\r\n7^i \\bmod 11 &amp;&amp; 1 &amp;&amp; 7 &amp;&amp; 5 &amp;&amp; 2\r\n&amp;&amp; 3 &amp;&amp; 10 &amp;&amp; 4 &amp;&amp; 6 &amp;&amp; 9\r\n&amp;&amp; 8 &amp;&amp; 1 \\\\\r\n8^i \\bmod 11 &amp;&amp; 1 &amp;&amp; 8 &amp;&amp; 9 &amp;&amp; 6\r\n&amp;&amp; 4 &amp;&amp; 10 &amp;&amp; 3 &amp;&amp; 2 &amp;&amp; 5\r\n&amp;&amp; 7 &amp;&amp; 1 \\\\\r\n9^i \\bmod 11 &amp;&amp; 1 &amp;&amp; 9 &amp;&amp; 4 &amp;&amp; 3\r\n&amp;&amp; 5 &amp;&amp; 1 &amp;&amp; 9 &amp;&amp; 4 &amp;&amp; 3\r\n&amp;&amp; 5 &amp;&amp; 1 \\\\\r\n10^i \\bmod 11 &amp;&amp; 1 &amp;&amp; 10 &amp;&amp; 1 &amp;&amp; 10\r\n&amp;&amp; 1 &amp;&amp; 10 &amp;&amp; 1 &amp;&amp; 10 &amp;&amp; 1\r\n&amp;&amp; 10 &amp;&amp; 1 \\\\\r\n\\end{aligned}\\)\r\n因此，\\(\\mathbb{Z}_{11}^{\\ast}\\)中的所有的元素的阶为：\r\n\\(\\begin{aligned}\r\n\\text{ord}_{11}(1) &amp;= 1 \\\\\r\n\\text{ord}_{11}(2) &amp;= 10 \\\\\r\n\\text{ord}_{11}(3) &amp;= 5 \\\\\r\n\\text{ord}_{11}(4) &amp;= 5 \\\\\r\n\\text{ord}_{11}(5) &amp;= 5 \\\\\r\n\\text{ord}_{11}(6) &amp;= 10 \\\\\r\n\\text{ord}_{11}(7) &amp;= 10 \\\\\r\n\\text{ord}_{11}(8) &amp;= 10 \\\\\r\n\\text{ord}_{11}(9) &amp;= 5 \\\\\r\n\\text{ord}_{11}(10) &amp;= 2 \\\\\r\n\\end{aligned}\\)\r\n因此，\\(\\mathbb{Z}_{11}^{\\ast}\\)中的最小原根为\\(g=2\\)。并且有此表：\r\n\\(\\begin{aligned}\r\n\\text{ind}_{11,2}(1) &amp;= 0 \\\\\r\n\\text{ind}_{11,2}(2) &amp;= 1 \\\\\r\n\\text{ind}_{11,2}(3) &amp;= 8 \\\\\r\n\\text{ind}_{11,2}(4) &amp;= 2 \\\\\r\n\\text{ind}_{11,2}(5) &amp;= 4 \\\\\r\n\\text{ind}_{11,2}(6) &amp;= 9 \\\\\r\n\\text{ind}_{11,2}(7) &amp;= 7 \\\\\r\n\\text{ind}_{11,2}(8) &amp;= 3 \\\\\r\n\\text{ind}_{11,2}(9) &amp;= 6 \\\\\r\n\\text{ind}_{11,2}(10) &amp;= 5 \\\\\r\n\\end{aligned}\\)\r\n31.6-2\r\n\\(x^2\\equiv 1\\pmod\r\n{p^e}\\)意味着\\(x^2-1\\equiv 0\\pmod\r\n{p^e}\\)。由于\\(x^2-1=(x+1)(x-1)\\)，因此\\(p^2\\mid (x+1)(x-1)\\)。\r\n31.6-3\r\nMODULAR-EXPONENTIATION(a, b, n)  if b == 0    return 1  while b mod 2 == 0    a = a * a mod n    b = b / 2  return a * MODULAR-EXPONENTIATION(a * a mod n, (b - 1) / 2, n) mod n\r\n31.6-4\r\nMODULAR-EXPONENTIATION(a, b, n)  d = 1  while b &gt; 0    if b mod 2 == 1      d = d * a mod n      b = b - 1    a = a * a mod n    b = b / 2  return d\r\n31.6-5\r\n根据欧拉定理，有\\(a^{\\phi(n)}\\equiv 1 \\pmod\r\nn\\)。那么两边同时乘上\\(a^{-1}\\)，得到\\(a^{-1}\\equiv a^{\\phi(n)-1}\\pmod n\\)。\r\n那么，仅需要调用MODULAR-EXPONENTIATION(a, phi - 1, n)即可计算出\\(a^{-1}\\)。\r\n","categories":["算法导论"]},{"title":"算法导论27.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-27/exercises-3/","content":"\r\n27.3-1\r\n假设给出的序列为\\(1,2,1,5,4,4,1,2,4,2,3,4,5,2,2,1,2,2\\)，那么每个时期的过程如下表给出：\r\n\\(\\begin{array}{|c|c|l|c|c|}\\hline\r\n\\text{epoch}&amp;\\text{request}&amp;\\text{cache}&amp;\\text{miss?(\\texttt{Y/N})}&amp;\\text{miss\r\ncount}\\\\\\hline\r\n1&amp;1&amp;1&amp;\\texttt{Y}&amp;3\\\\\r\n&amp;2&amp;2,1&amp;\\texttt{Y}\\\\\r\n&amp;1&amp;1,2&amp;\\texttt{N}\\\\\r\n&amp;5&amp;5,1,2&amp;\\texttt{Y}\\\\\\hline\r\n2&amp;4&amp;4,5,1&amp;\\texttt{Y}&amp;2\\\\\r\n&amp;4&amp;4,5,1&amp;\\texttt{N}\\\\\r\n&amp;1&amp;1,4,5&amp;\\texttt{N}\\\\\r\n&amp;2&amp;2,1,4&amp;\\texttt{Y}\\\\\r\n&amp;4&amp;4,2,1&amp;\\texttt{N}\\\\\r\n&amp;2&amp;2,4,1&amp;\\texttt{N}\\\\\\hline\r\n3&amp;3&amp;3,2,4&amp;\\texttt{Y}&amp;2\\\\\r\n&amp;4&amp;4,3,2&amp;\\texttt{N}\\\\\r\n&amp;5&amp;5,4,3&amp;\\texttt{Y}\\\\\\hline\r\n4&amp;2&amp;2,5,4&amp;\\texttt{Y}&amp;2\\\\\r\n&amp;2&amp;2,5,4&amp;\\texttt{N}\\\\\r\n&amp;1&amp;1,2,5&amp;\\texttt{Y}\\\\\r\n&amp;2&amp;2,1,5&amp;\\texttt{N}\\\\\r\n&amp;2&amp;2,1,5&amp;\\texttt{N}\\\\\\hline\r\n\\end{array}\\)\r\n27.3-2\r\n证明过程和定理27.2相似。我们先展示LFU算法的竞争比例具有下界\\(\\Omega(n/k)\\)。\r\n考虑构造如下长度为\\(n=(k+1)m\\)的请求序列，其中\\(m&gt;1\\)：\r\n\\(1,\\dots,1,2,3,\\dots,k,k+1,2,3,\\dots,k,k+1\\dots,2,3,\\dots,k,k+1\\)\r\n即先请求\\(m\\)次\\(1\\)，接下来对\\(2,3,\\dots,k,k+1\\)这个序列按顺序请求\\(m\\)次。\r\n考虑这个序列的请求未命中次数。一开始缓存是空的，因此请求\\(m\\)次\\(1\\)时，只发生\\(1\\)次未命中。对于接下来的\\(k-1\\)次从\\(2\\)到\\(k+1\\)的请求，从\\(2\\)到\\(k\\)依次请求都会发生一次未命中。当请求\\(k+1\\)时，缓存空间已满，由于从\\(2\\)到\\(k\\)至少都访问了\\(1\\)次（而\\(1\\)访问了\\(m\\)次），并且\\(2\\)在其中滞留最久，因此\\(2\\)将会被驱逐，对\\(k+1\\)加入缓存。接下来对\\(2\\)进行请求，缓存中从\\(3\\)到\\(k+1\\)至少都访问了\\(1\\)次（而\\(1\\)访问了\\(m\\)次），并且\\(3\\)在其中滞留最久，因此\\(3\\)会被驱逐，\\(2\\)将会被加入，接下来对\\(3\\)进行请求……可见，对\\(1\\)进行\\(m\\)次请求后，接下来的\\(km\\)次请求都会导致未命中，因此这个请求序列将会导致\\(km+1=n-m+1\\)次未命中。\r\n对于一个最优离线算法，当\\(k+1\\)被请求时，应该将\\(1\\)驱逐掉。那么整个请求过程中，每个不同的块只会导致\\(1\\)次未命中，那么最优离线算法只会发生\\(k+1\\)次未命中。\r\n因此，LFU算法的竞争比例的下限为\\(\\dfrac{n-m+1}{k+1}=\\Omega(n/k)\\)。\r\n类似的，对于竞争比例的上界，对于任何规模为\\(n\\)的请求序列，任何缓存算法都会导致最多\\(n\\)次缓存缺失。由于请求不同块的种类数至少为\\(n\\)，因此所有缓存算法，包括离线最优缓存算法都会导致至少\\(k\\)次的缓存缺失，因此LFU算法的竞争比例上限为\\(O(n/k)\\)。\r\n最终，LFU算法具有竞争比例\\(\\Theta(n/k)\\)，也因此它是无界的。\r\n27.3-3\r\n同证明定理27.3的过程相同，按照相同的方式，为整个请求序列划分成一个个时期。\r\n接下来考虑FIFO算法的行为。在每个时期中，对于任意一种特定块\\(b\\)，它仅仅在这个时期的第一次出现才会可能发生未命中（如果发生未命中，那么就会被加入到缓存中，并且在接下来的\\(k-1\\)次未命中发生都不会被驱逐）。而如果在这个时期中\\(b\\)再次出现，那么必定会命中，因为FIFO算法只保留最近使用的\\(k\\)个块，在此之前，\\(b\\)已经加载到缓存中，因此中间不会有超过\\(k-1\\)个不同的请求。最终在每个时期中，FIFO算法只会发生最多\\(k\\)次未命中。\r\n接下来考虑离线最优算法的行为。由于每个时期的第一个请求必定是一个新请求，此时离线最优算法会触发\\(1\\)次未命中。那么，离线最优算法在每个时期中都至少会触发\\(1\\)次未命中。\r\n因此，FIFO算法的竞争比例为\\(k/1=O(k)\\)，原结论成立。\r\n27.3-4\r\n同证明定理27.3的和题目27.3-3过程相同，按照相同的方式，为整个请求序列划分成一个个时期。\r\n接下来考虑确定性MARKING算法的行为。在每个时期中，对于任意一种特定块\\(b\\)，它仅仅在这个时期的第一次出现才会可能发生未命中。此后，如果\\(b\\)再在同一时期被进行一次请求，那么一定会发生命中，并且已经被标记成了\\(1\\)。在每个时期的开始时，所有块的标记都已经是\\(1\\)，并且需要将它们的所有标记置\\(0\\)，并且使用确定性算法选择一个块进行驱逐。每个时期只有\\(k\\)种不同的块，最多只会导致\\(k\\)次未命中。\r\n接下来考虑离线最优算法的行为。由于每个时期的第一个请求必定是一个新请求，此时离线最优算法会触发\\(1\\)次未命中。那么，离线最优算法在每个时期中都至少会触发\\(1\\)次未命中。\r\n因此，确定性MARKING算法的竞争比例为\\(k/1=O(k)\\)，原结论成立。\r\n27.3-5\r\n定理27.4给出的是\\(l=0\\)前瞻的情况。\r\n对于\\(1\\)前瞻的情况，考虑有这么一个对手\\(A\\)，他能够按照这个\\(1\\)前瞻的确定性算法\\(F_1\\)输出一个长串的请求块。\r\n\\(F_1\\)只能够预测\\(A\\)的下\\(1\\)步操作，\\(A\\)也知道\\(F\\)能够预测到自己下\\(1\\)步的操作，但是\\(F_1\\)无法预测到\\(A\\)的下\\(2\\)步操作，但是\\(A\\)可以根据\\(F_1\\)算法的过程，提前构造好自己下\\(2\\)步的操作，使得\\(F\\)必定发生未命中。也就是说，\\(A\\)每产生相邻的两个请求必定会导致\\(F_1\\)发生一次未命中。因此，如果\\(0\\)前瞻算法\\(F_0\\)的竞争比例为\\(\\Omega(k)\\)，那么\\(F_1\\)的竞争比例为\\(\\Omega(k/2)=\\Omega(k)\\)，原结论成立。\r\n对于\\(l\\)前瞻的情况\\((l&gt;1)\\)，考虑某个在\\(1\\)前瞻算法\\(F_1\\)中达到竞争比例下界的请求序列\\(S\\)，并将请求这个请求序列中的每个块都向\\(l\\)前瞻算法\\(F_l\\)都请求\\(l\\)次，那么在\\(F_l\\)的视角中，这个请求序列相当于是\\(1\\)前瞻下的视角（因为最多只能预测到\\(1\\)个块）。那么\\(F_l\\)的未命中次数至少是\\(F_1\\)对请求序列\\(S\\)的未命中次数。但是在最优算法下，未命中次数是相同的。因此\\(F_l\\)的竞争比例为\\(\\Omega(k/l)=\\Omega(k)\\)，原结论成立。\r\n","categories":["算法导论"]},{"title":"算法导论27 Problems 答案","url":"/introduction-to-algorithms/chapter-27/problems/","content":"\r\n27-1\r\n以下解答参考了这篇论文，它给出了一个竞争比例为\\(9\\)的在线算法。这个页面则描述了这个问题的原型。\r\n对于一个输入未知输入\\(x\\)。接下来考虑这个在线算法\\(F(x)\\)的行为。考虑一个无限访问序列\\(x_i=-\\delta(-2)^i\\)，可见\\(\\displaystyle{\\lim_{i\\rightarrow-\\infty}}x_i=0\\)，因此起点是\\(x_{-\\infty}=0\\)，然后按这个顺序依次访问中间的所有节点。如果当前从\\(x_{-\\infty}=0\\)按顺序访问到了第\\(k\\)个节点，那么访问的距离总共为\\(\\displaystyle{|x_k|+\\sum_{i=-\\infty}^{k-1}|x_i|}\\)。\r\n对于输入\\(x\\)，假设算法\\(F\\)所产生的步行距离为\\(f(x)\\)。现在假设\\(x&gt;0\\)，那么可以选择\\(n\\)使得\\(x_{2n-1}&lt;x\\le x_{2n+1}\\)，即\\(-\\delta \\cdot (-2)^{2n-1}&lt;x\\le -\\delta\\cdot\r\n(-2)^{2n+1}\\)。算法\\(F\\)将从\\(x_{-\\infty}\\)逐步访问节点到\\(x_{2n}\\)，再从\\(x_{2n}\\)访问到\\(x\\)。那么有\r\n\\(\\begin{aligned}\r\nf(x)&amp;= x+2\\cdot\\sum_{i=-\\infty}^{2n} |x_i|\\\\\r\n&amp;=x+\\delta\\cdot 2^{2n+2}\\\\\r\n&amp;&lt;x+8x &amp;\\qquad(A)\\\\\r\n&amp;=9x\r\n\\end{aligned}\\)\r\n其中步骤\\((A)\\)是从\\(-\\delta \\cdot (-2)^{2n-1}&lt;x\\)得到\\(\\delta\\cdot 2^{2n}&lt;2x\\)。\r\n现在假设\\(x&lt;0\\)，那么可以选择\\(n\\)使得\\(x_{2n+2}\\le x&lt; x_{2n}\\)，即\\(-\\delta \\cdot (-2)^{2n+2}\\le x&lt;-\\delta\\cdot\r\n(-2)^{2n}\\)。算法\\(F\\)将从\\(x_{-\\infty}\\)逐步访问节点到\\(x_{2n+1}\\)，再从\\(x_{2n+1}\\)访问到\\(x\\)。那么有\r\n\\(\\begin{aligned}\r\nf(x)&amp;= |x|+2\\cdot\\sum_{i=-\\infty}^{2n+1} |x_i|\\\\\r\n&amp;=-x+\\delta\\cdot 2^{2n+3}\\\\\r\n&amp;&lt;-x-8x &amp;\\qquad(B)\\\\\r\n&amp;=-9x\r\n\\end{aligned}\\)\r\n其中步骤\\((B)\\)是从\\(x&lt;-\\delta\\cdot (-2)^{2n}\\)得到\\(\\delta\\cdot 2^{2n}&lt;-x\\)。\r\n如果\\(x=0\\)，那么算法\\(F\\)不需要移动即可，即\\(f(x)=0\\)。\r\n对于一个离线最优算法的花费\\(g(x)\\)，它知道\\(x\\)在哪个地方，因此只需要径直走过去即可，需要步行的距离为\\(g(x)=|x|\\)。\r\n也就是说，\\(\\forall x\\in\r\n(-\\infty,\\infty)\\)，都有\\(f(x)\\le\r\n9g(x)\\)，因此算法\\(F\\)是线性查找问题中一个竞争比例为\\(9\\)的算法。\r\n实际上，如果来回行走时到达了路径的终点，就可以立即返回。\r\n27-2\r\n这篇论文和本题目相关。\r\na\r\n假设有如下\\(n\\)个任务\\(\\{a_{1},a_2,\\dots,a_n\\}\\)，其中\\(r_1=0,p_1=m(m&gt;n)\\)，并且\\(\\forall\r\ni\\in[2,n],r_i=1,p_i=1\\)。考虑这个在线算法和最优离线算法的行为。\r\n首先考虑在线算法的行为。一开始\\((t=0)\\)，在线算法检查到未运行的最短时间任务\\(a_1\\)，那么它将会运行这个任务，并且最终在\\(C_1=m\\)这个时刻完成了它。完成\\(a_1\\)后，它检查到了任务\\(a_2,a_3,\\dots,a_n\\)。由于它们所需要花费的时间都相同，因此不失一般性，按照\\(a_2,a_3,\\dots,a_n\\)的时间运行。因此\\(\\forall i\\in[2,n]\\)，都有\\(C_i=m+i-1\\)。因此总共需要的时间为\\(C=\\dfrac{(m+m+n-1)n}{2}\\)。\r\n对于一个最优离线算法，它会先等待\\(n-1\\)个短任务\\(a_2,a_3,\\dots,a_n\\)的到来，并执行完成。因此\\(\\forall i\\in[2,n]\\)，都有\\(C_i&#39;=i\\)。接下来执行任务\\(a_1\\)，最终有\\(C_1&#39;=n+m\\)。因此总共需要的时间为\\(C&#39;=\\dfrac{(2+n)(n-1)}{2}+m+n\\)。\r\n那么，可见这个在线算法的竞争比例\\(r\\)至少为\\(C/C&#39;=\\Omega(mn/(n^2+m))\\)。如果\\(m=\\omega(n^2)\\)，那么有\\(r=\\Omega(m/n)\\)。也就是说，竞争比例取决于最长任务\\(a_1\\)的运行时间\\(m\\)。因此并不存在一个正常数\\(d\\)，使得这个算法是\\(d\\)竞争的。也就是说，这个算法的竞争比例是无界的。\r\nb\r\n对于任意一个时刻，如果当前处理机处于空闲状态，那么从任务队列\\(Q\\)中取一个剩余时间最短的任务运行。在运行某一个任务\\(a_i\\)中，如果在线算法发现一个新释放的任务\\(a_j\\)所需要的运行时间比当前任务的剩余运行时间还要短，那么\\(a_i\\)便会挂起，推入\\(Q\\)，并开始运行\\(a_j\\)；否则继续运行\\(a_i\\)，且将\\(a_j\\)推入\\(Q\\)中。\r\nc\r\nSPRT算法是题目15-2-b的所提供算法的最优解，同时它也是抢占式算法下平均完成时间的最优解，因此它是一个\\(1\\)竞争的在线算法。也就是说，运行算法SPRT所得到的\\(C_1^P,C_2^P,\\dots,C_n^P\\)同样也是题目15-2-b的离线最优抢占式调度的一个最优解。由于非抢占式调度策略是抢占式调度策略的一个子集，因此\\(C_1^{\\ast},C_2^{\\ast},\\dots,C_{i}^{\\ast}\\)并不会比\\(C_1^P,C_2^P,\\dots,C_n^P\\)更优。因此根据题目15-2-b的结论，有\\(\\displaystyle{\\sum_{i=1}^nC_i^P\\le \\sum_{i=1}^n\r\nC_i^{\\ast}}\\)。\r\nd\r\n按照SPRT算法下的任务完成时间对任务进行排序完成后，考虑任务\\(i\\)完成的时刻，这时任务\\(1,2,\\dots,i-1\\)都已经完成。因此有\\(\\displaystyle{C_i^P\\ge \\sum_{j=1}^i\r\np_i}\\)。\r\n由于\\(r_j\\)是任务\\(j\\)的释放时间，\\(C_j^P\\)是任务\\(j\\)的完整时间，因此有\\(r_j&lt;C_j^P\\)。又因为\\(C_1^P,C_2^P,\\dots,C_n^P\\)是严格单调递增的，因此\\(\\forall j\\in[1,i]\\)，都有\\(C_i^P&gt;r_j\\)成立。\r\n因此有\\(\\displaystyle{C_i^P\\ge\\max\\left\\{\\sum_{j=1}^i\r\np_j,\\max\\{r_j:j\\le i\\}\\right\\}}\\)，原结论成立。\r\ne\r\n对于前\\(i\\)个任务，最懒惰且最贪心的做法是先将这\\(i\\)个任务全部释放后，再一次性全部完成。等待全部任务释放需要花费\\(\\max\\{r_j:j\\le\r\ni\\}\\)的时间，一次性完成这些任务需要花费\\(\\displaystyle{\\sum_{j=1}^i\r\np_i}\\)的时间。由于这\\(i\\)个任务是紧密完成的，因此必定有\\(\\displaystyle{C_i\\le \\max\\{r_j:j\\le\r\ni\\}+\\sum_{j=1}^i\r\np_j}\\)，否则，必定存在某些时刻，处理机空闲且仍有任务未执行的情况，而这种情况必定不是最优的。\r\nf\r\n对算法COMPLETION-TIME-SCHEDULE可以改成如下离线版本COMPLETION-TIME-SCHEDULE-ONLINE：如果任务\\(a_j\\)在抢占式算法下于时刻\\(C_j^P\\)结束，那么在线非抢占式算法则只需要在\\(C_j^P\\)时间开始运行。如果此时不是空闲，那么需要等待上一个任务完成后，任务\\(a_j\\)需要开始执行。\r\ng\r\n结合题目27-2-d和题目27-2-e的结论，有\r\n\\(\\begin{aligned}\r\nC_i&amp;\\le \\max\\{r_j:j\\le i\\}+\\sum_{j=1}^i p_j\\\\\r\n&amp;\\le \\max\\left\\{\\sum_{j=1}^i p_j,\\max\\{r_j:j\\le\r\ni\\}\\right\\}+\\max\\left\\{\\sum_{j=1}^i p_j,\\max\\{r_j:j\\le i\\}\\right\\}\\\\\r\n&amp;\\le 2C_i^P\r\n\\end{aligned}\\)\r\n针对题目27-2-f提出的算法COMPLETION-TIME-SCHEDULE-ONLINE的输出结果，以及题目27-2-c的结论，有\r\n\\(\\begin{aligned}\r\n\\sum_{i=1}^nC_i &amp;\\le \\sum_{i=1}^n2C_i^P\\\\\r\n&amp;=2\\sum_{i=1}^P C_i^P\\\\\r\n&amp;\\le 2\\sum_{i=1}^P C_i^{\\ast}\\\\\r\n\\end{aligned}\\)\r\n由于\\(C_1^{\\ast},C_2^{\\ast},\\dots,C_{i}^{\\ast}\\)是非抢占式最优离线算法输出的结果，因此COMPLETION-TIME-SCHEDULE-ONLINE是\\(2\\)竞争的。\r\n","categories":["算法导论"]},{"title":"算法导论34.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-34/exercises-3/","content":"\r\n34.3-1\r\n根据图34.8b的图，可以给出这个布尔组合电路所定义的布尔公式如下：\r\n\\[((x_1\\lor x_2)\\land (\\neg(\\neg x_3)))\r\n\\land((\\neg(\\neg x_3))\\lor(x_1\\land(\\neg x_3)\\land x_2))\\land\r\n(x_1\\land(\\neg x_3)\\land x_2)\\]\r\n化简后，可以得到这个布尔公式为：\r\n\\[((x_1\\lor x_2)\\land x_3) \\land(\r\nx_3\\lor(x_1\\land(\\neg x_3)\\land x_2))\\land (x_1\\land(\\neg x_3)\\land\r\nx_2)\\]\r\n去掉一部分括号，根据运算符\\(\\land\\)的交换律及结合律，可以得到\r\n\\[(x_1\\lor x_2) \\land(\r\nx_3\\lor(x_1\\land(\\neg x_3)\\land x_2))\\land x_1\\land x_2\\land\r\nx_3\\land(\\neg x_3)\\]\r\n由于\\(x_3\\land (\\neg\r\nx_3)\\)不可能为\\(1\\)，因此原来的布尔表达式的值必定为\\(0\\)，它是不可满足的。\r\n34.3-2\r\n如果\\(L_1\\le_P\r\nL_2\\)，那么意味着存在一个规约函数\\(f_1\\)以及一个时间复杂度为\\(O(n^{k_1})\\)的算法\\(F_1\\)计算规约函数\\(f_1\\)，将语言\\(L_1\\)规约到\\(L_2\\)，其中\\(k_1\\)为一个正常数。同样的，如果\\(L_2\\le_P\r\nL_3\\)，那么意味着存在一个规约函数\\(f_2\\)以及一个时间复杂度为\\(O(n^{k_2})\\)的算法\\(F_2\\)计算规约函数\\(f_2\\)，将语言\\(L_2\\)规约到\\(L_3\\)，其中\\(k_2\\)为一个正常数。\r\n通过\\(f_1\\)和\\(f_2\\)，可以构造出规约函数\\(f_3=f_2\\circ f_1\\)，并且存在算法\\(F_3\\)通过嵌套调用\\(F_2,F_1\\)计算规约函数\\(f_3\\)，将语言\\(L_1\\)规约成语言\\(L_3\\)，其时间复杂度为\\(O(n^{k_1k_2})\\)。因此有\\(L_1\\le_P L_3\\)。\r\n34.3-3\r\n可见，由于充分性和必要性的过程互为补运算，证明过程是对称的。因此只需要证明一个方向即可。\r\n这里证明充分性，\\(L\\le_P\r\n\\overline{L}\\)意味着存在一个规约函数\\(f\\)以及一个多项式时间的算法\\(F\\)计算规约函数\\(f\\)，将语言\\(L\\)规约到\\(\\overline{L}\\)。\r\n对于一个\\(x\\)，如果\\(x\\in\\overline{L}\\)，那么有\\(x\\not\\in L\\)，即\\(f(x)\\not\\in \\overline{L}\\)，从而得到\\(f(x)\\in L\\)。也就是说，\\(f\\)同样可以将语言\\(\\overline{L}\\)规约到\\(L\\)，因此充分性成立。\r\n必要性的证明过程相同，最终原结论成立。\r\n34.3-4\r\n相对于原来的检验算法\\(A\\)，新的检验算法\\(A&#39;\\)接受的证书\\(y\\)只需要包含所有的电路输入即可，而不需要包含每一根线上的值。检测算法\\(A&#39;\\)将会根据\\(C\\)的编码解析出原来的电路，然后按照给定\\(y\\)作为输入值，将整个布尔电路的所有导线的值计算出来。最终得到电路的输出结果，如果电路的输出结果为\\(1\\)，那么说明这个\\(y\\)是\\(x\\)是可满足的证据，算法\\(A&#39;\\)返回\\(1\\)，否则返回\\(0\\)。\r\n34.3-5\r\n当使用图34-9来论证使用的工作存储器数量为\\(n\\)的多项式时，假设了存储单元是连续的。\r\n实际上，这些存储空间不必是连续的，对于不同功能的内容（数据或代码），只需要在整个存储空间上划出一小部分足够让这些内容存储下来即可。由于这里仅仅是强调使用的存储器数量的上限，因此假设存储单元连续是不失一般性的。\r\n34.3-6\r\n可见\\(\\varnothing,\\{0,1\\}^{\\ast}\\in\r\nP\\)。考虑使用反证法来证明\\(\\varnothing,\\{0,1\\}^{\\ast}\\)对\\(P\\)不是完全的。\r\n现在假设\\(\\varnothing\\)对\\(P\\)是完全的，由于\\(\\{0,1\\}^{\\ast}\\in P\\)，因此\\(\\{0,1\\}^{\\ast}\\le_P\r\n\\varnothing\\)。那么必定存在多项式规约函数\\(f\\)，使得\\(x\\in\r\n\\{0,1\\}^{\\ast}\\)当且仅当\\(f(x)\\in\r\n\\varnothing\\)。但是\\(f(x)\\in\\varnothing\\)是永远不成立的，因为\\(\\varnothing\\)是空集合，然而\\(\\{0,1\\}^{\\ast}\\)并不是空集合，这引出了矛盾。因此\\(\\varnothing\\)对\\(P\\)不是完全的。\r\n现在假设\\(\\{0,1\\}^{\\ast}\\)对\\(P\\)是完全的，由于\\(\\varnothing\\in P\\)，因此\\(\\varnothing\\le _P\r\n\\{0,1\\}^{\\ast}\\)。和之前的类似，那么必定存在多项式规约函数\\(f&#39;\\)，使得\\(x\\in \\varnothing\\)当且仅当\\(f&#39;(x)\\in \\{0,1\\}^{\\ast}\\)。但是\\(x\\in\\varnothing\\)是永远不成立的，因为\\(\\varnothing\\)是空集合，然而\\(\\{0,1\\}^{\\ast}\\)并不是空集合，这引出了矛盾。因此\\(\\{0,1\\}^{\\ast}\\)同样对\\(P\\)不是完全的。（注意：这个结论也可以从题目34.3-2中直接得出）\r\n接下来考虑\\(P\\)中除\\(\\varnothing,\\{0,1\\}^{\\ast}\\)中的任意一个语言\\(L\\)，并假设任意语言\\(L&#39;\\in P\\)。取\\(y_1\\in L,y_2\\in \\overline{L}\\)。由于\\(L&#39;\\in P\\)，因此必定存在一个算法\\(A&#39;\\)可以在多项式时间内判断一个字符串\\(x\\)是否在语言\\(L&#39;\\)。我们可以构造一个规约函数\\(f\\)：\r\n\\(f(x)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;y_1 &amp; &amp; \\text{if}\\quad  x\\in L&#39; \\\\\r\n  &amp;y_2 &amp; &amp; \\text{if}\\quad  x\\not\\in L&#39; \\\\\r\n\\end{aligned}\\right.\\)\r\n并且可以构造出一个多项式时间算法\\(F\\)用于计算\\(f\\)，它是将\\(A&#39;\\)作为子程序进行计算。因此可以得到\\(L&#39;\\le_P L\\)。\r\n也就是说，\\(\\forall L&#39;\\in P,L&#39;\\le_P\r\nL\\)均成立，因此\\(L\\)对\\(P\\)是完全的。\\(\\varnothing,\\{0,1\\}^{\\ast}\\)是在\\(P\\)中仅有两个语言对\\(P\\)是不完全的。\r\n34.3-7\r\n和题目一样，由于充分性和必要性的过程互为补运算，证明过程是对称的。因此只需要证明一个方向即可。\r\n充分性：由于\\(L\\)对\\(\\text{NP}\\)是完全的，因此\\(L\\in\\text{NP}\\)，这意味着\\(\\overline{L}\\in\\text{co-NP}\\)。类似的，由于\\(\\forall L&#39;\\in \\text{NP}\\)，都有\\(L&#39;\\le_PL\\)。这说明存在一个规约函数\\(f\\)和一个多项式算法\\(F\\)用来计算\\(f\\)，将\\(L&#39;\\)归约到\\(L\\)中。按照\\(f\\)的定义，可见\\(x\\in L&#39;\\)当且仅当\\(f(x)\\in L\\)。也就是说\\(x\\in \\overline{L&#39;}\\)当且仅当\\(x\\in\\overline{L}\\)。因此多项式算法\\(F\\)也可以将\\(\\overline{L&#39;}\\)在多项式时间内归约到\\(\\overline{L}\\)，即\\(\\overline{L&#39;}\\le_P\\overline{L}\\)。因此\\(\\overline{L}\\)对\\(\\text{co-NP}\\)是完全的。\r\n必要性的证明过程相同，最终原结论成立。\r\n34.3-8\r\n需要注意的是，证明一个语言\\(L\\)是NP困难的，只需要证明\\(\\forall L&#39;\\in\\text{NP}\\)，将\\(L&#39;\\)归约到\\(L\\)的多项式规约函数\\(f\\)存在即可，而并不需要显式地构造一个多项式算法\\(F\\)来计算\\(f\\)。证明的内容相当于是，由于多项式规约函数\\(f\\)存在，因此在多项式时间内计算规约函数\\(f\\)的算法\\(F\\)也存在。因此，由于\\(L&#39;\\in\r\n\\text{NP}\\)，都有一个多项式算法\\(A&#39;\\)来对\\(L&#39;\\)进行验证。多项式算法\\(A&#39;\\)存在，那么调用\\(A&#39;\\)来计算\\(f\\)的算法\\(F\\)也是存在的，它是多项式次数的。因此，哪怕不需要知道\\(O(n^k)\\)的常数，也是足够用来证明CIRCUIT-SAT是NP困难的。\r\n","categories":["算法导论"]},{"title":"算法导论34.4 Exercises 答案","url":"/introduction-to-algorithms/chapter-34/exercises-4/","content":"\r\n34.4-1\r\n可以构造的电路形式如下，如图是一个\\(n=3\\)规模的电路：\r\n\r\n可见，第\\(k(k\\ge\r\n1)\\)层的电路的输出端所代表的表达式，就包含了\\(2^k-1\\)个运算符，因此这个电路一共有\\(n\\)层时，整个电路的输出端一共有\\(2^{n+1}-1\\)个运算符，即这个表达式的长度是指数增长的。\r\n34.4-2\r\n对于\\(\\phi&#39;\\)中的所有子句，经过3个步骤后可以得到：\r\n\\(\\begin{aligned}\r\n\\phi_0&#39;&#39;&#39;&amp;=y&amp;&amp;=(y \\lor p \\lor q) \\land (y \\lor p\r\n\\lor \\neg q) \\land (y \\lor \\neg p \\lor q) \\land (y \\lor \\neg p \\lor \\neg\r\nq)\\\\\r\n\\phi_1&#39;&#39;&#39;&amp;=(y_1 \\leftrightarrow (y_2 \\land \\neg x_2))\r\n&amp;&amp;= (\\neg y_1 \\lor \\neg y_2 \\lor \\neg x_2) \\land (\\neg y_1 \\lor\r\ny_2 \\lor \\neg x_2) \\land (\\neg y_1 \\lor y_2 \\lor x_2) \\land (y_1 \\lor\r\n\\neg y_2 \\lor x_2)\\\\\r\n\\phi_2&#39;&#39;&#39;&amp;=(y_2 \\leftrightarrow (y_3 \\lor y_4))\r\n&amp;&amp;= (\\neg y_2 \\lor y_3 \\lor y_4) \\land (y_2 \\lor \\neg y_3 \\lor\r\n\\neg y_4) \\land (y_2 \\lor \\neg y_3 \\lor y_4) \\land (y_2 \\lor y_3 \\lor\r\n\\neg y_4)\\\\\r\n\\phi_3&#39;&#39;&#39;&amp;=(y_3 \\leftrightarrow (x_1 \\rightarrow x_2))\r\n&amp;&amp;= (\\neg y_3 \\lor \\neg x_2 \\lor x_2) \\land (y_3 \\lor \\neg x_1\r\n\\lor \\neg x_2) \\land (y_1 \\lor x_1 \\lor \\neg x_2) \\land (y_3 \\lor x_1\r\n\\lor x_2)\\\\\r\n\\phi_4&#39;&#39;&#39;&amp;=(y_4 \\leftrightarrow \\neg y_5) &amp;&amp;=\r\n(\\neg x_4 \\lor \\neg y_5 \\lor q) \\land (\\neg x_4 \\lor \\neg y_5 \\lor \\neg\r\np) \\land (x_4 \\lor y_5 \\lor p) \\land (x_4 \\lor y_5 \\lor \\neg p)\\\\\r\n\\phi_5&#39;&#39;&#39;&amp;=(y_5 \\leftrightarrow (y_6 \\lor x_4))\r\n&amp;&amp;= (\\neg y_5 \\lor y_6 \\lor x_4) \\land (y_5 \\lor \\neg y_6 \\lor\r\n\\neg x_4) \\land (y_5 \\lor \\neg y_6 \\lor x_4) \\land (y_5 \\lor y_6 \\lor\r\n\\neg x_4)\\\\\r\n\\phi_6&#39;&#39;&#39;&amp;=(y_6 \\leftrightarrow (\\neg x_1\r\n\\leftrightarrow x_3)) &amp;&amp;= (\\neg y_6 \\lor \\neg x_1 \\lor \\neg x_3)\r\n\\land (\\neg y_6 \\lor x_1 \\lor x_3) \\land (y_6 \\lor \\neg x_1 \\lor x_3)\r\n\\land (y_6 \\lor x_1 \\lor \\neg x_3)\r\n\\end{aligned}\\)\r\n因此最终\\(\\phi\\)转化后得到\\(3\\text{-CNF}\\)的表达式\\(\\phi&#39;&#39;&#39;\\)为：\r\n\\(\\begin{aligned}\r\n\\phi&#39;&#39;&#39;=&amp;(y \\lor p \\lor q) \\land (y \\lor p \\lor \\neg q)\r\n\\land (y \\lor \\neg p \\lor q) \\land (y \\lor \\neg p \\lor \\neg q)\\land\\\\\r\n&amp;(\\neg y_1 \\lor \\neg y_2 \\lor \\neg x_2) \\land (\\neg y_1 \\lor y_2\r\n\\lor \\neg x_2) \\land (\\neg y_1 \\lor y_2 \\lor x_2) \\land (y_1 \\lor \\neg\r\ny_2 \\lor x_2)\\land\\\\\r\n&amp;(\\neg y_2 \\lor y_3 \\lor y_4) \\land (y_2 \\lor \\neg y_3 \\lor \\neg\r\ny_4) \\land (y_2 \\lor \\neg y_3 \\lor y_4) \\land (y_2 \\lor y_3 \\lor \\neg\r\ny_4)\\land\\\\\r\n&amp;(\\neg y_3 \\lor \\neg x_2 \\lor x_2) \\land (y_3 \\lor \\neg x_1 \\lor\r\n\\neg x_2) \\land (y_1 \\lor x_1 \\lor \\neg x_2) \\land (y_3 \\lor x_1 \\lor\r\nx_2)\\land\\\\\r\n&amp;(\\neg x_4 \\lor \\neg y_5 \\lor q) \\land (\\neg x_4 \\lor \\neg y_5 \\lor\r\n\\neg p) \\land (x_4 \\lor y_5 \\lor p) \\land (x_4 \\lor y_5 \\lor \\neg\r\np)\\land\\\\\r\n&amp;(\\neg y_5 \\lor y_6 \\lor x_4) \\land (y_5 \\lor \\neg y_6 \\lor \\neg\r\nx_4) \\land (y_5 \\lor \\neg y_6 \\lor x_4) \\land (y_5 \\lor y_6 \\lor \\neg\r\nx_4)\\land\\\\\r\n&amp;(\\neg y_6 \\lor \\neg x_1 \\lor \\neg x_3) \\land (\\neg y_6 \\lor x_1\r\n\\lor x_3) \\land (y_6 \\lor \\neg x_1 \\lor x_3) \\land (y_6 \\lor x_1 \\lor\r\n\\neg x_3)\r\n\\end{aligned}\\)\r\n34.4-3\r\n这种策略是错误的。如果\\(\\phi\\)有\\(n\\)个自由布尔变量，那么构造出的真值表一共有\\(2^n\\)项，从这个真值表导出的表达式的长度至少是\\(\\Omega(2^n)\\)的，而不是多项式长度的。因此原结论错误。\r\n34.4-4\r\n根据题目34.3-7的结论，为了证明语言\\(L=\\text{TAUTOLOGY}\\)对\\(\\text{co-NP}\\)是完全的，只需要证明\\(\\overline{L}\\)是NP完全的即可，其中\\(\\overline{L}\\)是如下布尔表达式\\(\\phi\\)所表示的集合：存在一组输入变量，使得这个表达式的输出值为\\(0\\)。\r\n首先证明\\(\\overline{L}\\in\r\n\\text{NP}\\)。证明过程非常简单：验证算法可以在多项式时间内对一个表达式\\(\\phi\\)和一组输入\\(x\\)，判断出表达式的输出值是否为\\(0\\)。这个步骤和定理34.9对应步骤的证明是一样的，因此\\(\\overline{L}\\in\\text{NP}\\)。（也可以从题目34.2-8直接得出此结论。）\r\n接下来证明\\(\\overline{L}\\)是NP困难的。根据定理34.9得知，问题\\(\\text{SAT}\\)是NP完全的。因此，通过证明\\(\\text{SAT}\\le_P\r\n\\overline{L}\\)，从而完成此证明。对于问题\\(\\text{SAT}\\)中的任意一个表达式\\(\\phi\\)，存在一组输入\\(x\\)使得\\(\\phi\\)的输出为\\(0\\)。规约函数\\(f\\)则是将表达式\\(\\phi\\)进行取反，即\\(f(\\phi)=\\neg\\phi\\)，它可以在多项式时间内被计算出来。因此有\\(\\text{SAT}\\le_P\\overline{L}\\)，也就是说，\\(\\overline{L}\\)是NP困难的。\r\n因此，\\(\\overline{L}\\)是NP完全的，原来的结论成立。\r\n34.4-5\r\n对于一个析取范式\\(\\phi\\)，它是表示为所有子句的或，并且每个子句都是多个文字的与。因此每个子句\\(\\phi_i\\)和\\(\\phi\\)之间的关系可以写成\r\n\\[\\phi=\\bigvee_{i=1}^k \\phi_i\\]\r\n因此，对于一个析取范式的可满足性问题，只要其中一个子句的值为\\(1\\)，那么整个\\(\\phi\\)的输出值为\\(1\\)。我们可以枚举每个子句\\(\\phi_i\\)。由于\\(\\phi\\)是一系列文字的与运算，只要\\(\\phi_i\\)有一个输入为\\(1\\)即可满足要求。检查\\(\\phi_i\\)中的所有文字，如果不存布尔变量\\(x_j\\)，使得\\(x_j\\)和\\(\\neg\r\nx_j\\)都在这个子句中，子句\\(\\phi_i\\)的值就可以为\\(1\\)。只要将在子句\\(\\phi_i\\)中，没有取反\\(\\neg\\)的变量赋予\\(1\\)，带有取反符号的赋予\\(0\\)即可，最终这是一个证明该析取范式是可满足的证据。如果\\(\\phi\\)每一个子句，都有某个布尔变量\\(x_j\\)和\\(\\neg\r\nx_j\\)都在这个子句中，那么\\(\\phi\\)是不可满足的。每个子句只需要线性的时间即可完成判断。\r\n因此，判断析取范式的可行性问题\\(\\text{DNF-SAT}\\in P\\)，原结论成立。\r\n34.4-6\r\n如果存在一个多项式算法DECIDE-FORMULA-SATISFIABILITY用于判断布尔表达式的可满足性。那么考虑如下程序FIND-SATISFYING-ASSIGNMENT用于为每个布尔变量赋值。\r\n//A是某个布尔表达式，X是自由变量集合//DECIDE-FORMULA-SATISFIABILITY(P, X)用于检测布尔表达式P是否具有可行性，X是其布尔变量集合。FIND-SATISFYING-ASSIGNMENT(P, X)  X&#x27; = ∅  while X != ∅    select x from X randomly and remove it    X = X - &#123;x&#125;    X&#x27; = X&#x27; ∪ &#123;x&#125;    all x in P are assigned a value of 1    simplify P to get a new expression P&#x27;    if DECIDE-FORMULA-SATISFIABILITY(P&#x27;, X) == 1      x.value = 1      P = P&#x27;    else      x.value = 0      all x in P are assigned a value of 0      simplify P to get a new expression P&#x27;      P = P&#x27;  return X&#x27;\r\nFIND-SATISFYING-ASSIGNMENT的基本思想是，对每个变量尝试进行\\(x_i\\)赋值，如果赋予其中一个值后（程序中是\\(1\\)），对于剩下的变量来说，这个布尔表达式是可满足的，那么当前赋值是正确的，否则赋予另外一个值（程序中是\\(0\\)）。\r\n所有化简过程都可以在多项式时间内完成。上面的算法中，如果布尔表达式包含了\\(n\\)个自由变量，那么FIND-SATISFYING-ASSIGNMENT只会调用\\(n\\)次DECIDE-FORMULA-SATISFIABILITY，并且每次调用的规模都不大于原来的布尔表达式的长度。由于DECIDE-FORMULA-SATISFIABILITY是多项式时间的算法，因此FIND-SATISFYING-ASSIGNMENT也是多项式时间的算法，原结论成立。\r\n34.4-7\r\n假设这个恰有两个文字的合取范式\\(\\phi\\)被表示成\\(\\displaystyle{\\phi=\\bigwedge_{i=1}^n y_i\\lor\r\nz_i}\\)，其中\\(y_i,z_i\\)是第\\(i\\)个子句的文字\\(\\phi_i\\)，一共有\\(k\\)个自由变量。考虑有向图\\(G=(V,E)\\)，其中\\(V=\\{x_1,\\neg x_1,x_2,\\neg x_2,\\dots,x_k,\\neg\r\nx_k\\}\\)，即表示这\\(k\\)个自由变量可能的\\(2k\\)个文字。\r\n对于每个子句\\(\\phi_i\\)，将边\\((\\neg y_i,z_i),(\\neg y_i,z_i)\\)添加到\\(E\\)中。原因是，如果\\(y_i\\)和\\(z_i\\)其中一个被赋予\\(0\\)，那么另一个变量就必须赋予\\(1\\)。\r\n接下来对图\\(G\\)运行章节20.5所描述的求解强连通算法STRONGLY-CONNECTED-COMPONENTS。如果存在某个\\(i\\in[1,k]\\)，使得\\(x_i,\\neg\r\nx_i\\)都在一个强连通分量中，那么说明\\(x_i\\)对其中一个变量赋值都会导致\\(x_i\\)将会对另外一个变量进行赋值，这是不可能的，因此\\(\\phi\\)此时不可满足。否则\\(\\phi\\)是可满足的。\r\n由于建立整个图\\(G\\)只需要花费\\(O(n)\\)的时间，并且算法STRONGLY-CONNECTED-COMPONENTS的时间复杂度为\\(O(E+V)\\)，因此恰好\\(2\\)个子句的可满足行问题是多项式时间内可判定的，即\\(\\text{2-CNF-SAT}\\in P\\)。\r\n","categories":["算法导论"]},{"title":"算法导论34 Problems 答案","url":"/introduction-to-algorithms/chapter-34/problems/","content":"\r\n34-1\r\na\r\n图\\(G=(V,E)\\)的一个独立集\\(V&#39;\\)意味着以节点集合\\(V&#39;\\)的子图不包含任何一条边。\r\n这个判定性问题是：对于图\\(G=(V,E)\\)，是否存在一个大小至少为\\(k\\)的点集\\(V&#39;\\subseteq V\\)，使得\\(\\forall (u,v)\\in E,\\neg(u\\in V&#39;\\land v\\in\r\nV&#39;)\\)均成立。\r\n将这个问题定义成一种语言INDEPENDENT-SET：\r\n\\[\\begin{aligned}\r\n\\text{INDEPENDENT-SET}=\\{\\langle G, k\\rangle:&amp;G = (V, E)\\text{ is an\r\nundirected graph, }\\\\\r\n&amp;k \\ge 0\\text{ is an integer, and}\\\\\r\n&amp;G\\text{ contains a independent set at least }k\\text{ vertex}\\}\r\n\\end{aligned}\\]\r\n首先证明INDEPENDENT-SET属于\\(\\text{NP}\\)。对于一个集合\\(V&#39;\\)，检验程序只需要对\\(E\\)中的所有边\\((u,v)\\)进行判断是否\\(u,v\\)都在\\(V&#39;\\)中，以及判断是否满足\\(|V&#39;|\\ge\r\nk\\)即可。检验程序可以在多项式时间内运行，因此INDEPENDENT-SET属于\\(\\text{NP}\\)。\r\n接下来证明INDEPENDENT-SET是NP困难的，考虑使用团问题进行规约，即证明\\(\\text{CLIQUE}\\le_P\\text{INDEPENDENT-SET}\\)。对于CLIQUE问题中的任意一个实例\\(\\langle G,k\\rangle\\)，规约算法\\(F\\)构造出如下一个INDEPENDENT-SET问题的实例\\(\\langle G&#39;,k&#39;\\rangle\\)，使得\\(G=(V,E)\\)包含一个大小为\\(k\\)的团，当且仅当\\(G&#39;=(V&#39;,E)\\)包含一个大小为\\(k&#39;\\)的独立集。\r\n规约过程是：令\\(V&#39;=V,E&#39;=\\overline{E}\\)，即\\(G&#39;\\)是\\(G\\)的补图，且\\(k&#39;=k\\)。可见，\\(G\\)的补图可以在多项式时间内被求出来，因此规约算法\\(F\\)是多项式时间的。\r\n现在证明\\(G=(V,E)\\)包含一个大小为\\(k\\)的团，当且仅当\\(G&#39;=(V,\\overline{E})\\)包含一个大小为\\(k\\)的独立集。\r\n充分性：如果\\(G\\)中存在一个大小为\\(k\\)的团\\(V_1\\)，那么在\\(G\\)的补图\\(G&#39;\\)中，节点集合\\(V_1\\)中的任意两点都没有\\(\\overline{E}\\)中的边，因此\\(V_1\\)也是\\(G&#39;\\)中的一个独立集。\r\n必要性：如果\\(G&#39;\\)中存在一个大小为\\(k\\)的独立集\\(V_1\\)，那么在\\(G&#39;\\)的补图\\(G\\)中，节点集合\\(V_1\\)中的任意两点都有\\(E\\)中的边相连，因此\\(V_1\\)也是\\(G\\)中的一个团。\r\n因此\\(\\text{CLIQUE}\\le_P\\text{INDEPENDENT-SET}\\)。由于CLIQUE是NP完全的，那么INDEPENDENT-SET是NP困难的，也是NP完全的，原结论成立。\r\nb\r\n首先可以使用二分法，用于确定最大独立集的大小\\(k\\)，这仅需要\\(O(\\lg\r\nV)\\)次使用INDEPENDENT-SET。接下来，由于移除一个顶点并不会以及其关联的所有边增大，因此考虑尝试移除每一个顶点，并使用INDEPENDENT-SET判断图中是否仍然有一个至少为\\(k\\)的独立集，如果仍然有，说明这个顶点不是必要的，可以删除。否则必须保留下来。\r\nMAX-INDEPENDENT-SET(G)  l = 1  r = |G.V|  while l &lt; r    mid = ⌊(l + r + 1) / 2⌋    if INDEPENDENT-SET(G, mid) == 1      l = mid    else      r = mid - 1  k = l  VI = ∅  V = G.V  E = G.V  while V != ∅    select v from V randomly    V = V - &#123;v&#125;    E&#x27; = E - &#123;(w, v) : (w, v) ∈ E and w ∈ V&#125;    if INDEPENDENT-SET((V ∪ VI, E&#x27;), mid) == 1      E = E&#x27;    else      VI = VI ∪ &#123;v&#125;  return VI\r\nc\r\n如果图\\(G=(V,E)\\)的每个节点度数为\\(2\\)，那么这意味着\\(G\\)是由多个不相交的环\\(C\\)构成。遍历每个环\\(C\\)，那么这个环中不相邻的所有节点就是一个独立集（这保证了这些节点之间将不会有边进行连接，因此这是一个独立集，且是一个极大的独立集）。最终，所有环中的极大独立集拼起来，就是图\\(G=(V,E)\\)的最大独立集。具体过程由MAX-INDEPENDENT-SET-DEGREE-2给出，其时间复杂度为\\(O(V+E)\\)。\r\nMAX-INDEPENDENT-SET-DEGREE-2(G)  let vis[1 : |G.V|] be a new array by False  S = ∅  for each vertex u in G.V    if vis[u] == false      T = ∅      cnt = 0      while True        if cnt % 2 == 1          T = T ∪ &#123;u&#125;        vis[u] = True        cnt = cnt + 1        // 表示u的两个相邻节点        v = G.Adj[u, 0]        w = G.Adj[u, 1]        if vis[v] == False          u = v        else if vis[w] == False          u = w        else          break      S = S ∪ T  return S\r\nd\r\n首先考虑图\\(G=(V,E)\\)最大独立集问题和最小点覆盖问题的可规约性：对于一个点覆盖\\(V&#39;\\)，在图\\(G=(V,E)\\)中，将\\(V&#39;\\)和\\(V&#39;\\)关联的所有边删去后，剩下的图不会含有任何一条边，因此\\(V-V&#39;\\)是\\(G\\)的一个独立集。因此对于\\(G\\)的一个最小点覆盖\\(V_0\\)，那么得知\\(V-V_0\\)就是图\\(G\\)的一个最大独立集。\r\n接下来考虑二分图\\(G\\)下最小点覆盖问题和最大匹配的问题的等价性。\r\n首先说明图\\(G=(V,E),V=L\\cup\r\nR\\)的最小点覆盖中的点数不可能小于最大匹配的边数，因为最大匹配是由多条不相交的边构成的，这些边都至少需要一个顶点进行覆盖。接下里证明图\\(G\\)最小点覆盖中的点数恰好为最大匹配的边数。\r\n考虑如下一个构造方法，最终通过二分图最大匹配算法得到二分图的最小点覆盖：\r\n\r\n求出\\(G\\)的最大匹配。\r\n再次从\\(L\\)中所有节点非匹配节点出发，寻找一条增广路径（且一定寻找失败）。\r\n取\\(L\\)中尚未被标记的节点\\(L_0\\)，\\(R\\)中被标记过的节点\\(R_0\\)，这些顶点构成了\\(G\\)的一个最小点覆盖\\(V_0=L_0\\cup R_0\\)。\r\n\r\n接下来证明这个方法构造出来的\\(V_0\\)是一个最小点覆盖。运行完整个增广路径算法后，对于\\(L\\)中的非匹配节点，它们一定都被标记，因为它们是出发点；而对于\\(R\\)中非匹配节点，它们一定都没有被标记，否则就找到了一条增广路径。对于一条匹配边，两边的节点要么被标记，要么没有被标记，因为左部节点只能通过匹配边从右部节点进行访问。\r\n可以发现，\\(L_0\\)和\\(R_0\\)恰好是从最大匹配中，来自每条边的两个节点之一。\\(L_0\\)中节点所对应的匹配边，是指增广路径算法中没有访问的边；\\(R_0\\)中节点所对应的匹配边，是指增广路径算法中有访问的边。接下来验证这个点覆盖确实覆盖了所有边：\r\n\r\n左部节点\\(l\\in\r\nL\\)是非匹配点，右部节点\\(r\\in\r\nR\\)也是非匹配点。这种边是不可能存在的，因为这是一条增广路径。\r\n\\(l\\)是匹配点，\\(r\\)也是匹配点。这种边被覆盖了，因为每条匹配边的其中一个节点都在\\(V_0\\)中。\r\n\\(l\\)是匹配点，\\(r\\)是非匹配点。这说明\\(l\\)没有被访问到，否则找到了通向\\(r\\)的增广路径，因此这条边是被\\(L_0\\)中的节点覆盖。\r\n\\(l\\)是非匹配点，\\(r\\)是匹配点。因为起点是\\(l\\)，所以\\(r\\)一定被访问，因此这条边是被\\(R_0\\)中的节点覆盖。\r\n\r\n自此证明了最大匹配问题和最小点覆盖问题的等价性。可以给出如下过程MAX-INDEPENDENT-SET-BIPARTITE，其时间复杂度取决于增广路径算法的时间复杂度，因此这个算法是多项式时间的。\r\nMAX-INDEPENDENT-SET-BIPARTITE(G)  M = HOPCROFT-KARP(G)  // 记录被标记的节点  construct GM from M and G  Q = Ø  L0 = Ø  R0 = Ø  for each unmatched vertex l ∈ L    l.π = NIL    ENQUEUE(Q, l)    L0 = L0 ∪ &#123;l&#125;  while Q != Ø    u = DEQUEUE(Q)    for each v in GM.Adj[u]      if v in L and v not in L0        L0 = L0 ∪ &#123;v&#125;        ENQUEUE(Q, v)      else if v in R and v not in R0        R0 = R0 ∪ &#123;v&#125;        ENQUEUE(Q, v)  V0 = (L - L0) ∪ R0  return V - V0\r\n34-2\r\na\r\n这是一个多项式时间的算法即可完成。\r\n当钱的总数为奇数时，必定无法分成。\r\n假设有\\(a\\)枚\\(x\\)美元的硬币，\\(n-a\\)枚\\(y\\)美元的硬币，那么这些钱的总共的价值为\\(ax+(n-a)y\\)，那么每一个人将分得\\(s=\\dfrac{ax+(n-a)y}{2}\\)块钱。\r\n接下来使用扩展欧几里得算法对关于\\((u,v)\\)的方程\\(xu+yu=s\\)进行求解，并尝试找到一个满足\\(0\\le u\\le a,0\\le v\\le\r\nn-a\\)的整数解，这将在多项式的时间内完成。更具体的过程由DIVIDING-MONEY-A给出：\r\nDIVIDING-MONEY-A(a, n, x, y)  b = n - a  s = (a * x + b * y)  if s % 2 != 0    return 0  s = s / 2  (d, u, v) = EXTENDED-EUCLID(x, y)  if s % d != 0    return 0  u0 = (u * (s / d)) % y  // 求取使u满足u&lt;=a的最大解。  u1 = u0 + ⌊(a - u0) / (y / d)⌋ * (y / d)  v1 = (s - u1 * x) / y  if 0 &lt;= u1 &lt;= a and 0 &lt;= v1 &lt;= b    return 1  v0 = (v * (s / d)) % x  // 求取使v满足v&lt;=b的最大解。  v2 = v0 + ⌊(b - v0) / (x / d)⌋ * (x / d)  u2 = (s - v2 * y) / x  if 0 &lt;= u2 &lt;= a and 0 &lt;= v2 &lt;= b    return 1  return 0\r\nb\r\n这是一个多项式时间的算法即可完成。将所有币依照币值大小从大到小分配，每次分配给持有币值总数较小的那个人，更具体的过程由DIVIDING-MONEY-B给出：\r\nDIVIDING-MONEY-B(X, n)  Bonnie-s = 0  Clyde-s = 0  RANDOMIZED-QUICKSORT(X, 1, n)  for i = n downto 1    if Bonnie-s &lt;= Clyde-s      Bonnie-s = Bonnie-s + X[i]      X[i] will be assigned to Bonnie    else      Clyde-s = Clyde-s + X[i]      X[i] will be assigned to Clyde  if Bonnie-s == Clyde-s    return 1  else    return 0\r\n可见，这个算法是多项式的，接下来说明这个算法能够正确地运行。假设现在遍历到\\(x_i\\)，Bonnie得到了\\(s_B\\)美元，Clyde得到了\\(s_C\\)美元。如果当前\\(2\\)个人得到的钱相等，那么将\\(x_i\\)可以随机分配给一个人，不失一般性，假设分配给了Bonnie，因此在整个过程中，总有\\(s_B\\ge s_C\\)。如果现在\\(s_B&gt;s_C\\)，由于\\(\\forall j\\le i,x_i\\mid\r\nx_j\\)均成立，因此总有\\(x_i\\mid\r\ns_B-s_C\\)，并假设分配\\(x_{i-1}\\)之前，有\\(s_B=s_C\\)（这样的起点\\(i\\)必定存在，例如\\(i=2\\)，在分配\\(x_1\\)给\\(B\\)前有\\(s_B=s_C\\)），那么接下来按顺序将所有钱都给Clyde，直到\\(s_B=s_C\\)这个临界点，如果能够达到\\(s_B=s_C\\)，那么以这个临界点为下一个起点。否则说明接下来剩下的钱都不足以弥补当前\\(s_B-s_C\\)的差值。因此，DIVIDING-MONEY-B是多项式时间内可行的算法。\r\nc\r\n这恰好是题目34.5-5所提到的集合划分问题SET-PARTITION，它已经被证明是NP完全的。\r\nd\r\n这个问题是NP完全的，如下是证明。\r\n先将这个问题定义成一种语言SET-PARTITION-100：\r\n\\[\\text{SET-PARTITION-100} =\r\n\\left\\{\\langle S\\rangle : \\text{there exists a set }A\\subseteq S\\text{\r\nsuch that }\\left|\\sum_{x\\in A} x-\\sum_{x\\in\\overline{A}}x\\right|\\le\r\n100\\right\\}\\]\r\n首先证明SET-PARTITION-100属于\\(\\text{NP}\\)。对于\\(S\\)和它的一个非空子集\\(A\\)，检验程序只需要判断\\(\\displaystyle{\\left|\\sum_{x\\in A}\r\nx-\\sum_{x\\in\\overline{A}}x\\right|\\le\r\n100}\\)是否满足即可，它可以在多项式时间内运行，因此SET-PARTITION-100属于\\(\\text{NP}\\)。\r\n接下来证明SET-PARTITION-100是NP困难的，考虑使用集合划分问题进行规约，即证明\\(\\text{SET-PARTITION}\\le_P\\text{SET-PARTITION-100}\\)。对于SET-PARTITION问题中的任意一个实例\\(\\langle S\\rangle\\)，规约算法\\(F\\)构造出如下一个SET-PARTITION-100问题的实例\\(\\langle S&#39;\\rangle\\)，使得\\(S\\)能够划分成两个和值相等的子集，当且仅当\\(S&#39;\\)能够划分成两个和值相差不超过\\(100\\)的子集。\r\n规约过程是：令\\(S&#39;=\\{101x\\mid x\\in\r\nS\\}\\)。可见只是将集合\\(S\\)中的每个数乘上\\(101\\)，再将它插入集合\\(S&#39;\\)。可见这个过程是多项式可以完成的。\r\n现在证明\\(S\\)能够划分成两个和值相等的子集，当且仅当\\(S&#39;\\)能够划分成两个和值相差不超过\\(100\\)的子集。\r\n充分性：如果\\(S\\)能够划分成两个和值相等的集合\\(A,\\overline{A}\\)，将\\(A,\\overline{A}\\)中的所有元素都乘上\\(101\\)，得到\\(A&#39;,\\overline{A&#39;}\\)。可见\\(A&#39;,\\overline{A&#39;}\\)也是\\(S&#39;\\)的一个划分，并且差值为\\(0\\cdot 101=0\\)，因此\\(A&#39;,\\overline{A&#39;}\\)为\\(S&#39;\\)一个满足条件的划分。\r\n必要性：假设\\(S&#39;\\)包含两个和值相差不超过\\(100\\)的集合\\(A&#39;,\\overline{A&#39;}\\)。由于\\(S&#39;\\)中所有数都是\\(101\\)的倍数，因此\\(A&#39;,\\overline{A&#39;}\\)的元素和也都是\\(101\\)的倍数，因此如果要满足假设，两个集合的元素和必须相等。因此，将\\(A&#39;,\\overline{A&#39;}\\)中的所有元素都除上\\(101\\)，得到\\(A,\\overline{A}\\)。可见\\(A,\\overline{A}\\)是\\(S\\)一个满足条件的划分。\r\n因此\\(\\text{SET-PARTITION}\\le_P\\text{SET-PARTITION-100}\\)。由于SET-PARTITION是NP完全的，那么SET-PARTITION-100是NP困难的，也是NP完全的，原结论成立。\r\n34-3\r\na\r\n题目20.2-7所给出的判断二分图的算法即为所求，其时间复杂度为\\(O(V+E)\\)。\r\nDETERMINE-WRESTLERS(G)  for each vertex u in G.V    u.type = NIL  for each vertex s in G.V    if s.type == NIL      s.type = babyface      Q = ∅      ENQUEUE(Q, s)      while Q != ∅         u = DEQUEUE(Q)          for each vertex v in G.Adj[u]           if v.type == NIL            if u.type == babyface              v.type = heel            else              v.type = babyface            ENQUEUE(Q, s)          else if v.type == u.type            return NIL  return G.V      \r\nb\r\n这个判定性问题是：对于图\\(G=(V,E)\\)，是否至多可以用\\(k\\)种颜色进行着色。假设判定性问题的语言定义为K-COLOR：\r\n\\[\\begin{aligned}\r\n\\text{K-COLOR}=\\{\\langle G, k\\rangle:&amp;G = (V, E)\\text{ is an\r\nundirected graph, }\\\\\r\n&amp;k \\ge 1\\text{ is an integer, and}\\\\\r\n&amp;\\text{there exists a function }c:V\\rightarrow\\{1,2,\\dots,k\\}\\text{\r\nsuch that } \\forall (u,v)\\in E,c(u)\\neq c(v)\\}\r\n\\end{aligned}\\]\r\n接下来证明K-COLOR能够在多项式时间内能够解决，当且仅当图着色问题可以在多项式时间内解决。\r\n必要性：显而易见，图着色问题如果能够在多项式算法内解决，那么K-COLOR只需要统计图着色问题求解中所使用的颜色个数\\(k&#39;\\)，再判断是否不超过给定的\\(k\\)值即可。因此K-COLOR也可以在多项式时间内解决。\r\n充分性：假设K-COLOR多项式时间内可解决。可见，只需要最多\\(|V|\\)种颜色，就可以将图\\(G\\)完成着色。因此图着色问题考虑使用K-COLOR作为子程序，依照二分法的思想，即可能够判断出对图\\(G\\)的着色最少颜色数，那么图着色问题至多只需要询问\\(O(\\lg\r\nV)\\)次K-COLOR。由于K-COLOR是多项式时间内可解决的，因此图着色问题也是多项式时间内可解决的。\r\n因此原结论成立。\r\nc\r\n首先证明K-COLOR属于\\(\\text{NP}\\)。对于\\(G\\)和它的一个着色函数\\(c\\)，检验程序只需要判断是否\\(\\forall (u,v)\\in E,c(u)\\neq\r\nc(v)\\)均成立，并判断\\(c(u)\\)的取值是否在\\([1,k]\\)中即可。它可以在多项式时间内运行，因此K-COLOR属于\\(\\text{NP}\\)。\r\n接下来证明K-COLOR是NP困难的，考虑使用三着色问题进行规约，即证明\\(\\text{3-COLOR}\\le_P\\text{K-COLOR}\\)。对于3-COLOR问题中的任意一个实例\\(\\langle G\\rangle\\)，规约算法\\(F\\)构造出如下一个K-COLOR问题的实例\\(\\langle G,k\\rangle\\)，使得图\\(G\\)是\\(3\\)着色的，当且仅当图\\(G\\)是\\(k\\)着色的。\r\n规约过程是：只需要令\\(k=3\\)即可。\r\n现在证明图\\(G\\)是\\(3\\)着色的，当且仅当图\\(G\\)是\\(k\\)着色的。当\\(k=3\\)时，这两个问题是两个完全相同的问题，因此充分性和必要性均成立。\r\n因此\\(\\text{3-COLOR}\\le_P\\text{K-COLOR}\\)。由于题目已经假设了3-COLOR是NP完全的，因此K-COLOR是NP困难的，也是NP完全的，原结论成立。\r\nd\r\n在图\\(G=(V,E)\\)中，\\(3\\)个特殊节点\\(\\text{RED,TRUE,FALSE}\\)两两相连，因此\\(G\\)中的\\(3\\)中颜色只能用\\(c(\\text{RED}),c(\\text{TRUE}),c(\\text{FALSE})\\)分别表示。从图34.20中可以看出，\\(\\forall i\\in[1,n]\\)，节点\\(x_i,\\neg x_i,\\text{RED}\\)这\\(3\\)个节点两两相连，因此\\(x_i\\)和\\(\\neg\r\nx_i\\)这两个节点只能其中一个着色为\\(c(\\text{TRUE})\\)，另一个为\\(c(\\text{FALSE})\\)。\r\n对于每对节点\\(x_i,\\neg\r\nx_i\\)，如果公式在公式\\(\\phi\\)中，最终\\(x_i\\)赋值为\\(1\\)，那么节点\\(x_i\\)着色为\\(c(\\text{TRUE}),\\neg x_i\\)着色成\\(c(\\text{FALSE})\\)；如果\\(x_i\\)赋值为\\(0\\)，那么节点\\(x_i\\)着色为\\(c(\\text{FALSE}),\\neg x_i\\)着色成\\(c(\\text{TRUE})\\)即可。\r\n因此，对于\\(\\phi\\)中的任意一种赋值，都对应着只包含文字的图的其中一种\\(3\\)着色。\r\ne\r\n假设将每个组件中，先从左到右，再从上到下的\\(5\\)个节点分别命名为\\(a,b,c,d,e\\)。\r\n那么考虑枚举节点\\(x,y,z,a,b,c,d,e\\)的着色情况，一共有\\(2^3\\cdot3^5\\)种不同的情况。对每种情况进行判断，最终可以得到一个组件图中有如下\\(3\\)着色的方式，一共有\\(20\\)种：\r\n\\(\\begin{array}{|c|c|c|c|c|c|c|c|}\\hline\r\nx&amp;y&amp;z&amp;a&amp;b&amp;c&amp;d&amp;e\\\\\\hline\r\nc\\text{(TRUE)}&amp;c\\text{(FALSE)}&amp;c\\text{(FALSE)}&amp;c\\text{(FALSE)}&amp;c\\text{(RED)}&amp;c\\text{(TRUE)}&amp;c\\text{(FALSE)}&amp;c\\text{(RED)}\\\\\\hline\r\nc\\text{(TRUE)}&amp;c\\text{(FALSE)}&amp;c\\text{(FALSE)}&amp;c\\text{(FALSE)}&amp;c\\text{(TRUE)}&amp;c\\text{(RED)}&amp;c\\text{(FALSE)}&amp;c\\text{(RED)}\\\\\\hline\r\nc\\text{(FALSE)}&amp;c\\text{(TRUE)}&amp;c\\text{(FALSE)}&amp;c\\text{(RED)}&amp;c\\text{(FALSE)}&amp;c\\text{(TRUE)}&amp;c\\text{(FALSE)}&amp;c\\text{(RED)}\\\\\\hline\r\nc\\text{(FALSE)}&amp;c\\text{(TRUE)}&amp;c\\text{(FALSE)}&amp;c\\text{(TRUE)}&amp;c\\text{(FALSE)}&amp;c\\text{(RED)}&amp;c\\text{(FALSE)}&amp;c\\text{(RED)}\\\\\\hline\r\nc\\text{(TRUE)}&amp;c\\text{(TRUE)}&amp;c\\text{(FALSE)}&amp;c\\text{(RED)}&amp;c\\text{(FALSE)}&amp;c\\text{(TRUE)}&amp;c\\text{(FALSE)}&amp;c\\text{(RED)}\\\\\\hline\r\nc\\text{(TRUE)}&amp;c\\text{(TRUE)}&amp;c\\text{(FALSE)}&amp;c\\text{(FALSE)}&amp;c\\text{(RED)}&amp;c\\text{(TRUE)}&amp;c\\text{(FALSE)}&amp;c\\text{(RED)}\\\\\\hline\r\nc\\text{(FALSE)}&amp;c\\text{(FALSE)}&amp;c\\text{(TRUE)}&amp;c\\text{(RED)}&amp;c\\text{(TRUE)}&amp;c\\text{(FALSE)}&amp;c\\text{(RED)}&amp;c\\text{(FALSE)}\\\\\\hline\r\nc\\text{(FALSE)}&amp;c\\text{(FALSE)}&amp;c\\text{(TRUE)}&amp;c\\text{(TRUE)}&amp;c\\text{(RED)}&amp;c\\text{(FALSE)}&amp;c\\text{(RED)}&amp;c\\text{(FALSE)}\\\\\\hline\r\nc\\text{(TRUE)}&amp;c\\text{(FALSE)}&amp;c\\text{(TRUE)}&amp;c\\text{(RED)}&amp;c\\text{(TRUE)}&amp;c\\text{(FALSE)}&amp;c\\text{(RED)}&amp;c\\text{(FALSE)}\\\\\\hline\r\nc\\text{(TRUE)}&amp;c\\text{(FALSE)}&amp;c\\text{(TRUE)}&amp;c\\text{(FALSE)}&amp;c\\text{(RED)}&amp;c\\text{(TRUE)}&amp;c\\text{(RED)}&amp;c\\text{(FALSE)}\\\\\\hline\r\nc\\text{(TRUE)}&amp;c\\text{(FALSE)}&amp;c\\text{(TRUE)}&amp;c\\text{(FALSE)}&amp;c\\text{(RED)}&amp;c\\text{(TRUE)}&amp;c\\text{(FALSE)}&amp;c\\text{(RED)}\\\\\\hline\r\nc\\text{(TRUE)}&amp;c\\text{(FALSE)}&amp;c\\text{(TRUE)}&amp;c\\text{(FALSE)}&amp;c\\text{(TRUE)}&amp;c\\text{(RED)}&amp;c\\text{(FALSE)}&amp;c\\text{(RED)}\\\\\\hline\r\nc\\text{(FALSE)}&amp;c\\text{(TRUE)}&amp;c\\text{(TRUE)}&amp;c\\text{(TRUE)}&amp;c\\text{(RED)}&amp;c\\text{(FALSE)}&amp;c\\text{(RED)}&amp;c\\text{(FALSE)}\\\\\\hline\r\nc\\text{(FALSE)}&amp;c\\text{(TRUE)}&amp;c\\text{(TRUE)}&amp;c\\text{(RED)}&amp;c\\text{(FALSE)}&amp;c\\text{(TRUE)}&amp;c\\text{(RED)}&amp;c\\text{(FALSE)}\\\\\\hline\r\nc\\text{(FALSE)}&amp;c\\text{(TRUE)}&amp;c\\text{(TRUE)}&amp;c\\text{(RED)}&amp;c\\text{(FALSE)}&amp;c\\text{(TRUE)}&amp;c\\text{(FALSE)}&amp;c\\text{(RED)}\\\\\\hline\r\nc\\text{(FALSE)}&amp;c\\text{(TRUE)}&amp;c\\text{(TRUE)}&amp;c\\text{(TRUE)}&amp;c\\text{(FALSE)}&amp;c\\text{(RED)}&amp;c\\text{(FALSE)}&amp;c\\text{(RED)}\\\\\\hline\r\nc\\text{(TRUE)}&amp;c\\text{(TRUE)}&amp;c\\text{(TRUE)}&amp;c\\text{(RED)}&amp;c\\text{(FALSE)}&amp;c\\text{(TRUE)}&amp;c\\text{(RED)}&amp;c\\text{(FALSE)}\\\\\\hline\r\nc\\text{(TRUE)}&amp;c\\text{(TRUE)}&amp;c\\text{(TRUE)}&amp;c\\text{(FALSE)}&amp;c\\text{(RED)}&amp;c\\text{(TRUE)}&amp;c\\text{(RED)}&amp;c\\text{(FALSE)}\\\\\\hline\r\nc\\text{(TRUE)}&amp;c\\text{(TRUE)}&amp;c\\text{(TRUE)}&amp;c\\text{(RED)}&amp;c\\text{(FALSE)}&amp;c\\text{(TRUE)}&amp;c\\text{(FALSE)}&amp;c\\text{(RED)}\\\\\\hline\r\nc\\text{(TRUE)}&amp;c\\text{(TRUE)}&amp;c\\text{(TRUE)}&amp;c\\text{(FALSE)}&amp;c\\text{(RED)}&amp;c\\text{(TRUE)}&amp;c\\text{(FALSE)}&amp;c\\text{(RED)}\\\\\\hline\r\n\\end{array}\\)\r\n按照上面的表可以发现，这个组件图如果是\\(3\\)着色的，那么\\(x,y,z\\)必定有一个着色成\\(c\\text{(TRUE)}\\)，原结论成立。\r\n需要注意的是，只要\\(x,y,z\\)不同时被着色成\\(c\\text{(FALSE)}\\)，那么另外\\(7\\)种组合着色情况都是有对应的\\(3\\)着色方案对应着。\r\nf\r\n首先证明3-COLOR属于\\(\\text{NP}\\)。这个证明过程和题目34-3-c相同，只需要取\\(k=3\\)即可。因此3-COLOR属于\\(\\text{NP}\\)。\r\n接下来证明3-COLOR是NP困难的，考虑使用3-CNF可满足性问题问题进行规约，即证明\\(\\text{3-CNF-SAT}\\le_P\\text{3-COLOR}\\)。对于3-CNF-SAT问题中的任意一个实例\\(\\langle \\phi\\rangle\\)，规约算法\\(F\\)构造出如下一个3-COLOR问题的实例\\(\\langle G\\rangle\\)，使得3-CNF布尔公式\\(\\phi\\)是可满足的，当且仅当图\\(G\\)是\\(3\\)着色的。\r\n规约过程是：按照题目34-3-c和题目34-3-d之间的提示构造出了一个图\\(G=(V,E)\\)。\\(V\\)一共有\\(2n+5m+3\\)个节点，其中包含了\\(2n\\)个文字节点，\\(m\\)个组件中，每个组件有\\(5\\)个节点，以及\\(3\\)个特殊节点；\\(E\\)一共有\\(3n+10m+3\\)条边，其中有\\(3n+3\\)条文字边，\\(10m\\)条子句边。因此\\(G\\)可以在多项式时间内构造出来，故规约算法\\(F\\)是多项式时间的。\r\n现在证明3-CNF布尔公式\\(\\phi\\)是可满足的，当且仅当图\\(G\\)是\\(3\\)着色的。\r\n充分性：由于\\(\\phi\\)是可满足的，因此考虑其中一组可满足行赋值，并将\\(2n\\)个文字节点然上对应的颜色。这也意味着，对于所有子句\\(\\phi_i\\)，每个子句至少有一个文字的值为\\(1\\)。可以在表中选择对应的表项，将图\\(G\\)中对应的组件内部的\\(5\\)个节点染上表项对应颜色。因此，每个文字节点和组件内部的节点颜色都不会和相邻节点颜色相同，所求着色方式说明图\\(G\\)是\\(3\\)着色的。\r\n必要性：由于图\\(G\\)是\\(3\\)着色的，因此存在一种\\(3\\)着色方案。对于图\\(G\\)的第\\(i\\)个组件，它的着色方式必定是\\(20\\)个表项之一，然而所有表项中，\\(x,y,z\\)三个节点必定其中一个着色为\\(c(\\text{TRUE})\\)，因此\\(\\phi_i\\)对应文字也为\\(1\\)，对于其它子句也是如此。此外，这个\\(3\\)着色方案中，如果\\(x_i\\)被染成\\(c(\\text{TRUE})\\)，那么\\(x_i\\)赋值为\\(1\\)，否则赋值为\\(0\\)。最终这个着色方案意味着这个3-CNF公式\\(\\phi\\)是可满足的。\r\n因此\\(\\text{3-CNF-SAT}\\le_P\\text{3-COLOR}\\)。由于3-CNF-SAT是NP完全的，因此3-COLOR是NP困难的，也是NP完全的，原结论成立。\r\n34-4\r\na\r\n这个判定性问题是：是否存在一个\\(n\\)阶排列\\(\\sigma\\)，使得按照顺序\\(a_{\\sigma(1)},a_{\\sigma(2)},\\dots,a_{\\sigma(n)}\\)执行任务，可以获得至少\\(k\\)的利润。可以将这个判定问题定义成一种语言K-PROFIT-DEADLINES：\r\n\\[\\begin{aligned}\r\n\\text{K-PROFIT-DEADLINES}=\\{\\langle A,\r\nk\\rangle:&amp;A=\\{a_1,a_2,\\dots,a_n\\}\\text{ is a tasks set, }\\\\\r\n&amp;k \\ge 0\\text{ is an integer, and}\\\\\r\n&amp;\\text{there exists a sequence to finish thest task and get at least\r\nprofit }k\\}\r\n\\end{aligned}\\]\r\nb\r\n首先证明K-PROFIT-DEADLINES属于\\(\\text{NP}\\)。给定一个任务清单\\(A\\)和整数\\(k\\)，以及一个完成顺序\\(\\sigma\\)，检验程序需要模拟这些任务的完成时间，并且需要判断完成时间是否会超过截止时间，如果没有超过截止时间就算上利润\\(p_i\\)，最终判断获得的总利润\\(k&#39;\\)是否超过\\(k\\)即可。因此检验程序可以在多项式时间内完成模拟，因此K-PROFIT-DEADLINES属于\\(\\text{NP}\\)。\r\n接下来证明K-PROFIT-DEADLINES是NP困难的，考虑使用子集和问题问题进行规约，即证明\\(\\text{SUBSET-SUM}\\le_P\\text{K-PROFIT-DEADLINES}\\)。对于SUBSET-SUM问题中的任意一个实例\\(\\langle S,t\\rangle\\)，规约算法\\(F\\)构造出如下一个K-PROFIT-DEADLINES问题的实例\\(\\langle A,k\\rangle\\)，使得\\(S\\)包含一个和为\\(t\\)的子集，当且仅当\\(A\\)中的任务按照某个顺序执行，能够获得至少\\(k\\)的利润。\r\n规约过程是：对于集合\\(S\\)中的第\\(i\\)个数\\(x_i\\)，可以构造如下任务\\(a_i:t_i=x_i,p_i=a_i,d_i=t\\)。此外，至少得到利润\\(k=t\\)。可见这个规约过程仅仅是将\\(S\\)中的每个数都建立了一个任务，并且添加了一个数\\(t\\)作为利润上限。这些内容可以在多项式时间内构造出来，因此规约算法\\(F\\)是多项式时间的。\r\n现在证明\\(S\\)包含一个和为\\(t\\)的子集，当且仅当\\(A\\)中的任务按照某个顺序执行，能够获得至少\\(t\\)的利润。\r\n充分性：如果\\(S\\)包含一个和为\\(t\\)的子集\\(S&#39;\\)，那么只需要按任意顺序执行\\(S&#39;\\)在中\\(A&#39;\\)对应的任务（\\(A-A&#39;\\)的任务按随意顺序执行，反正得不到利润），就可以得到恰好\\(t\\)的利润，这个任务执行计划是满足要求的。\r\n必要性：假设\\(A\\)中的任务按某种顺序执行可以得到至少\\(t\\)利润。由于\\(A\\)中所有任务的截止时间都相等（均为\\(t\\)），因此在\\(t\\)时间前执行的任务并不需要固定的顺序。此外，由于每个任务单位时间内所获得的利润都是\\(1\\)，因此在时间\\(t\\)内，恰好只能获得利润\\(t\\)。也就是说，存在一个\\(A\\)子集\\(A&#39;\\)，其利润之和恰好为\\(t\\)。将集合\\(A&#39;\\)中的任务映射回\\(S\\)中的数，那么就得到了一个子集和为\\(t\\)的集合。\r\n因此\\(\\text{SUBSET-SUM}\\le_P\\text{K-PROFIT-DEADLINES}\\)。由于SUBSET-SUM是NP完全的，因此K-PROFIT-DEADLINES是NP困难的，也是NP完全的，原结论成立。\r\nc\r\n由于超过了任务期限后再完成任务，再也不能得到利润，因此我们可以先选择尽力完成一部分能够得到利润的任务，再完成剩下的另一部分任务。选定了一部分任务后，只有按照截止日期按顺序完成，才能够达到最大利润。因此需要对任务按照截止时间进行排序。\r\n令状态\\(f[i,j](i,j\\ge\r\n0)\\)表示时间\\(j\\)内完成前\\(i\\)个任务所能获得最大的利润。那么不难写出关于\\(f[i,j]\\)的状态转移方程：\r\n\\(f[i,j]=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0 &amp; &amp; \\text{if}\\quad  i=0 \\\\\r\n  &amp;f[i-1,j] &amp; &amp; \\text{if}\\quad  i&gt;0\\land(j&lt;t_i\\lor\r\nj&gt;d_i) \\\\\r\n  &amp;\\max\\{f[i-1,j-t_i]+p_i,f[i-1,j]\\} &amp; &amp;\r\n\\text{if}\\quad  i&gt;0\\land(t_i\\le j\\land j\\le d_i) \\\\\r\n\\end{aligned}\\right.\\)\r\n那么对于状态\\(f[i,j]\\)，要么不完成（或者无法完成）第\\(i\\)个任务，从\\(f[i-1,j]\\)转移过来，要么尽力完成第\\(i\\)个任务，并获得\\(p_i\\)的利润，从\\(f[i-1,j-t_i]\\)转移而来。\r\n至此，\\(\\displaystyle{f[n,T]}\\)则是可以获得的最大利润，其中\\(\\displaystyle{T=\\sum_{i=1}^n t_i}\\)。\r\n由于此时仅要求给出的是一个判定性算法，因此只需要对至少获取的利润\\(k\\)和\\(f[n,T]\\)进行比较即可。具体过程由程序K-PROFIT-DEADLINES'给出。\r\n//A中每个任务都带有3个属性t, p, d，分别表示任务的运行时间，利润以及截止时间。K-PROFIT-DEADLINES&#x27;(A, n, k)  sort A[1 : n] by attribute d  T = 0  for i = 1 to n    T = T + A[i].t  let f[0 : n, 0 : T] be a new table by 0  for i = 1 to n    for j = 1 to T      f[i, j] = f[i - 1, j]    A[i].d = min&#123;A[i].d, T&#125;    for j = A[i].t to A[i].d      f[i, j] = min&#123;f[i, j], f[i - 1, j - A[i].t] + A[i].p&#125;  return f[i, T] &gt;= k\r\n由于每个任务的运行时间不超过\\(n\\)，因此\\(T\\le\r\nn^2\\)。因此算法K-PROFIT-DEADLINES'的时间复杂度为\\(O(nT)=O(n^3)\\)，它是多项式的。\r\nd\r\n题目34-c的动态规划算法即可直接计算出最大利润值。修改后的程序为PROFIT-DEADLINES，它的时间复杂度同样为\\(O(n^3)\\)。\r\nPROFIT-DEADLINES(A, n)  sort A[1 : n] by attribute d  T = 0  for i = 1 to n    T = T + A[i].t  let f[0 : n, 0 : T] be a new table by 0  for i = 1 to n    for j = 1 to T      f[i, j] = f[i - 1, j]    A[i].d = min&#123;A[i].d, T&#125;    for j = A[i].t to A[i].d      f[i, j] = min&#123;f[i, j], f[i - 1, j - A[i].t] + A[i].p&#125;  return f[i, T]\r\n","categories":["算法导论"]},{"title":"算法导论33.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-33/exercises-1/","content":"\r\n33.1-1\r\n\\(\\begin{aligned}\r\nf(S,C)&amp;=\\sum_{\\ell=1}^k\\dfrac{1}{2|S^{(\\ell)}|}\\sum_{\\mathbf{x,y}\\in\r\nS^{(\\ell)}:\\mathbf{x\\neq y}}\\Delta(\\mathbf{x,y})\\\\\r\n&amp;=\\sum_{\\ell=1}^k\\dfrac{1}{2|S^{(\\ell)}|}\\sum_{\\mathbf{x,y}\\in\r\nS^{(\\ell)}}\\Delta(\\mathbf{x,y})&amp;\\qquad(A)\\\\\r\n&amp;=\\sum_{\\ell=1}^k\\dfrac{1}{2|S^{(\\ell)}|}\\sum_{a=1}^d\\sum_{\\mathbf{x,y}\\in\r\nS^{(\\ell)}}(x_a-y_a)^2\\\\\r\n&amp;=\\sum_{\\ell=1}^k\\dfrac{1}{2|S^{(\\ell)}|}\\sum_{a=1}^d\\left(2|S^{(l)}|\\sum_{\\mathbf{x}\\in\r\nS^{(\\ell)}}x_a^2-2\\sum_{\\mathbf{x,y}\\in S^{(\\ell)}}x_ay_a\\right)\\\\\r\n&amp;=\\sum_{\\ell=1}^k\\dfrac{1}{2|S^{(\\ell)}|}\\sum_{a=1}^d\\left(2|S^{(l)}|\\sum_{\\mathbf{x}\\in\r\nS^{(\\ell)}}x_a^2-2\\left(\\sum_{\\mathbf{x}\\in\r\nS^{(\\ell)}}x_a\\right)^2\\right)\\\\\r\n&amp;=\\sum_{\\ell=1}^k\\dfrac{1}{2|S^{(\\ell)}|}\\sum_{a=1}^d\\left(2|S^{(l)}|\\sum_{\\mathbf{x}\\in\r\nS^{(\\ell)}}x_a^2-2|S^{(\\ell)}|^2(c_a^{(\\ell)})^2\\right)&amp;\\qquad(B)\\\\\r\n&amp;=\\sum_{\\ell=1}^k\\sum_{a=1}^d\\left(\\sum_{\\mathbf{x}\\in\r\nS^{(\\ell)}}x_a^2-|S^{(\\ell)}|(c_a^{(\\ell)})^2\\right)\\\\\r\n&amp;=\\sum_{\\ell=1}^k\\sum_{a=1}^d\\left(\\sum_{\\mathbf{x}\\in\r\nS^{(\\ell)}}x_a^2-2\\left(\\sum_{\\mathbf{x}\\in\r\nS^{\\ell}}\\right)c_a^{(\\ell)}+|S^{(\\ell)}|(c_a^{(\\ell)})^2\\right)&amp;\\qquad(C)\\\\\r\n&amp;=\\sum_{\\ell=1}^k\\sum_{a=1}^d\\sum_{\\mathbf{x}\\in\r\nS^{(\\ell)}}(x_a-c_a^{(\\ell)})^2\\\\\r\n&amp;=\\sum_{\\ell=1}^k\\sum_{\\mathbf{x}\\in\r\nS^{(\\ell)}}\\Delta(\\mathbf{x,c^{(\\ell)}})\r\n\\end{aligned}\\)\r\n其中，步骤\\((A)\\)是基于\\(\\Delta(\\mathbf{x,x})=0\\)这个事实，步骤\\((B),(C)\\)则使用了第1010页所给定的方程\\(\\displaystyle{-2\\sum_{\\mathbf{x}\\in\r\nS^{(\\ell)}}x_a+2|S^{(\\ell)}|c_a^{(\\ell)}=0}\\)进行移项，补项。\r\n33.1-2\r\n令\\(S=\\{(0,0),(1,0),(0,2),(1,2)\\},C=\\{(0,1),(1,1)\\}\\)，并且\\(\\mathbf{x^{(1)},x^{(3)}}\\in\r\nS^{(1)};\\mathbf{x^{(2)},x^{(4)}}\\in\r\nS^{(2)}\\)。经过一次迭代后，发现\\(S^{(1)}\\)的重心仍然是\\(\\mathbf{c^{(1)}}\\)，并且\\(S^{(2)}\\)的重心仍然是\\(\\mathbf{c^{(2)}}\\)，所有点的归属不会改变，算法终止，\\(f(S,C)=4\\)。\r\n然而实际上，如果\\(C&#39;=\\{(0.5,0),(0.5,2)\\}\\)，并且\\(\\mathbf{x^{(1)},x^{(2)}}\\in\r\nS&#39;^{(1)};\\mathbf{x^{(3)},x^{(4)}}\\in\r\nS&#39;^{(2)}\\)，那么实际上这个聚类更优，并且有\\(f(S,C&#39;)=1\\)。\r\n33.1-3\r\n首先使用一个哈希表，对这些点进行去重，最终以\\(O(n)\\)的算法得到一个单重集\\(X&#39;\\)，其中\\(|X&#39;|=m\\)。\r\n如果\\(m\\le k\\)，那么直接返回\\(m\\)个点和\\(k-m\\)个原点即可。返回原点的思想类似Lloyd程序的第4步。\r\n如果\\(m&gt;k\\)，那么使用练习5.3-5的算法返回一个只有大小为\\(k\\)的初始中心。由算法SAMPLE-K-CENTER给出。\r\nSAMPLE-K-CENTER(X&#x27;, m, k)  Let C be new array  S = ∅  for i = m - k + 1 to m    if i ∈ S      S = S ∪ &#123;k&#125;      INSERT(C, X&#x27;[k])    else      S = S ∪ &#123;i&#125;      INSERT(C, X&#x27;[i])  return C\r\n33.1-4\r\n我们首先需要证明，对于\\(X\\)中的任意\\(4\\)个数据\\(x_1,x_2,x_3,x_4\\)，其中有\\(x_1\\le x_2\\le x_3\\le\r\nx_4\\)。那么如果存在一种聚合方式是将\\(x_1,x_3\\)聚合到同一类\\(S^{(1)}\\)，\\(x_2,x_4\\)聚合到同一类\\(S^{(2)}\\)，那么这种聚合肯定不是最优的。因为更优的方式为\\((x_1,x_2),(x_3,x_4)\\)。考虑\r\n\\(\\begin{aligned}\r\n((x_4-x_2)^2+(x_3-x_1)^2)-((x_4-x_3)^2+(x_2-x_1)^2)&amp;=2(x_4-x_1)(x_3-x_2)\\\\\r\n&amp;\\ge 0\r\n\\end{aligned}\\)\r\n并且相对于\\(S^{(1)}\\)中的元素而言，\\(\\forall x\\in S-\\{x_3\\},x\\le\r\nx_1\\)都成立，那么令\\(S&#39;^{(1)}=(S-\\{x_3\\})\\cup\r\n\\{x_2\\}\\)，可以知道\\(\\sum_{x}\r\n\\Delta(x,c_1)\\)将会减少（\\(S&#39;^{(2)}\\)的过程同理）。\r\n这个证明说明了，在一个有序的序列中，只有连续的一整段才有可能是一个最优的聚类方式。也就是说，将一个排好序的数组划分成段一个个段，才是最优的做法。\r\n这给出了我们一个使用动态规划算法最小化\\(f(S,C)\\)的值。令\\(X\\)是一个长度为\\(n\\)的已排好序的数组（也就是这个数据集）。令状态\\(g[i,j](0\\le i\\le k,0\\le j\\le\r\nn)\\)表示将\\(X\\)的前\\(j\\)个值划分\\(i\\)个段时，最近中心平方距离和\\(f(X[1:i],C)\\)的最小值。那么可以得到\\(g\\)的状态转移方程：\r\n\\(g[i,j]=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0 &amp; &amp; \\text{if}\\quad  j=0 \\\\\r\n  &amp;\\infty &amp; &amp; \\text{if}\\quad  i = 0\\land j &gt; 0 \\\\\r\n  &amp;\\min_{l=0}^{j} \\{g[i-1,l]+w_X(l,j)\\} &amp; &amp;\r\n\\text{if}\\quad  i &gt; 0\\land j &gt; 0 \\\\\r\n\\end{aligned}\\right.\\)\r\n其中，\\(w(i,j)\\)表示数组\\(X[i+1:j]\\)被划分到同一块时，其产生的距离平方和。注意状态转移方程的第3行，当\\(l=j\\)时，表明这个集合是空的，\\(w(j,j)=0\\)。\r\n至于\\(w(i,j)\\)的计算，我们使用题目33.1-1给出的过程，有：\r\n\\(\\begin{aligned}\r\nw(i,j)&amp;=\\dfrac{1}{2(j-i)}\\left(2(j-i)\\sum_{k=i+1}^jX[i]^2-2\\left(\\sum_{k=i+1}^jX[i]\\right)^2\\right)\\\\\r\n&amp;=\\sum_{k=i+1}^jX[i]^2-\\dfrac{1}{j-i}\r\n\\left(\\sum_{k=i+1}^jX[i]\\right)^2\r\n\\end{aligned}\\)\r\n令\\(\\displaystyle{S[k]=\\sum_{i=1}^{k}\r\nX[i],T[k]=\\sum_{i=1}^k X[i]^2}\\)，那么可以将\\(w(i,j)\\)进一步化简成\\(w(i,j)=T[j]-T[i]-\\dfrac{(S[j]-S[i])^2}{j-i}\\)。也就是说，使用\\(O(n)\\)的运行时间预处理出\\(S,T\\)后，就可以以\\(O(1)\\)的时间计算\\(w\\)。\r\n那么最终答案为\\(g[k,n]\\)，求解的时间复杂度为\\(O(n^2k)\\)。求解划分的算法由程序CLUSTER-1-DIMENSION给出。\r\nCLUSTER-1-DIMENSION(X, n, k)  //先进行排序  RANDOMIZED-QUICKSORT(X, 1, n)  let S[0 : n], T[0 : n] be new arrays  for i = 1 to n    S[i] = S[i - 1] + X[i]    T[i] = T[i - 1] + X[i] * X[i]  let g[0 : k, 0 : n], pre[0 : k, 0 : n] be new matrices  for i = 0 to k    g[i, 0] = 0  for j = 1 to n    g[0, j] = ∞  for i = 1 to k    for j = 1 to n      g[i, j] = g[i - 1, j]      pre[i, j] = j      for l = 0 to j - 1          w = T[j] - T[i] + (S[j] - S[i]) * (S[j] - S[i]) / (j - i)        if g[i, j] &gt; g[i - 1, l] + w          g[i, j] = g[i - 1, l] + w          pre[i, j] = l  // 开始存储最终答案。  U = ∅  now = n  for i = k down to 1    p = pre[i, now]    if p != now      INSERT(U, X[p + 1 : now])    now = p  return g[k, n], U\r\n","categories":["算法导论"]},{"title":"算法导论33.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-33/exercises-2/","content":"\r\n33.2-1\r\n引理33.3说明了，只要至少有一次算法\\(A\\)进行了一次错误判断，那么整个集合就排除掉至少一半的专家。也就是说，\\(A\\)只要产生最多\\(\\lceil\\lg\r\nn\\rceil\\)次错误的答案，就清空一次集合\\(S\\)。考虑\\(A\\)回答错误了某个问题后，集合\\(S\\)是第\\(k\\)次被清空，这说明\\(A\\)最多回答错误了\\(k\\lceil\\lg n\\rceil\\)次。\r\n如果专家在某一次回答中被从\\(S\\)中移出去，那么它进行了一次错误的回答。由于\\(S\\)被清空\\(k\\)次，因此他至少在这个过程中回答错误了\\(k\\)次问题。也就是说，\\(\\forall i\\in[1,n],m_i\\ge\r\nk\\)均成立，因此有\\(m^{\\ast}\\ge\r\nk\\)。\r\n使用\\(k\\le\r\nm^{\\ast}\\)这个事实，回代到上面的\\(k\\)，我们可以知道\\(A\\)最多回答错误了\\(m^{\\ast}\\lceil\\lg n\\rceil\\)次。\r\n33.2-2\r\n令\\(f(x)=\\ln\r\n(1-x)+x^2+x\\)，那么我们只需要证明\\(\\forall x\\in[0,1/2],f(x)\\ge 0\\)即可。\r\n实际上，\\(f(0)=0,f(1/2)=\\dfrac{3}{4}-\\ln\r\n2&gt;0\\)。\r\n可以知道，\\(f&#39;(x)=-\\dfrac{1}{1-x}+2x+1=\\dfrac{x(2x-1)}{1-x}\\)。那么\\(\\forall x\\in[0,1/2],f&#39;(x)\\ge\r\n0\\)成立。\r\n因此\\(f(x)\\)在\\([0,1/2]\\)上是单调递增的，有\\(f(x)\\ge f(0)=0\\)，因此原结论成立。\r\n","categories":["算法导论"]},{"title":"算法导论34.5 Exercises 答案","url":"/introduction-to-algorithms/chapter-34/exercises-5/","content":"\r\n34.5-1\r\n先将子图同构问题定义成一种语言SUBGRAPH-ISOMORPHISM：\r\n\\[\\text{SUBGRAPH-ISOMORPHISM} = \\{\\langle\r\nG_1, G_2\\rangle : G_1\\text{ is isomorphic to a subgraph of\r\n}G_2\\}\\]\r\n首先证明SUBGRAPH-ISOMORPHISM属于\\(\\text{NP}\\)。对于\\(G_1=(V_1,E_1),G_2=(V_2,E_2),G_1\\)同构于\\(G_2\\)的一个子图意味着存在\\(V\\subseteq V_2,E\\subseteq E_2\\)（其中\\(E\\)是从\\(V\\)中产生的：\\(\\forall u\\in V,\\in V,(u,v)\\in\r\nE_2\\)，都有\\((u,v)\\in\r\nE\\)），以及一个双射函数\\(f:V_1\\rightarrow V,(u,v)\\in\r\nE_1\\)当且仅当\\((f(u),f(v))\\in\r\nE\\)。对于某个证据\\((V,f)\\)，检验程序需要先根据集合\\(V\\)计算出集合\\(|E|\\)，再判断是否满足\\(|V_1|=|V|,|E_1|=|E|\\)，并且\\(\\forall (u,v)\\in E_1\\)，都有\\((f(u),f(v))\\in\r\nE\\)即可。检验程序可以在多项式内完成检验，因此SUBGRAPH-ISOMORPHISM属于\\(\\text{NP}\\)。\r\n接下来证明SUBGRAPH-ISOMORPHISM是NP困难的，考虑使用团问题进行规约，即证明\\(\\text{CLIQUE}\\le_P\\text{SUBGRAPH-ISOMORPHISM}\\)。对于CLIQUE问题中的任意一个实例\\(\\langle G,k\\rangle\\)，规约算法\\(F\\)构造出如下一个SUBGRAPH-ISOMORPHISM问题的实例\\(\\langle G_1,G_2\\rangle\\)，使得\\(G\\)包含一个大小为\\(k\\)的团，当且仅当\\(G_1\\)和\\(G_2\\)的某个子图同构。\r\n规约过程是：\\(G_1\\)是\\(k\\)个节点的完全图，\\(G_2\\)是\\(G\\)本身。可见构造出这两个图所需要花费的时间都是多项式的。\r\n现在证明\\(G\\)包含一个大小为\\(k\\)的团，当且仅当\\(G_1\\)和\\(G_2\\)的某个子图同构。\r\n充分性：如果\\(G(G_2)\\)包含一个大小为\\(k\\)的团，那么取出这个团所代表的子图，它将是一个大小为\\(k\\)的完全图，因此这个子图明显和\\(G_1\\)同构。\r\n必要性：如果\\(G_1\\)和\\(G_2\\)中的某个子图同构，由于\\(G_1\\)是一个具有\\(k\\)个节点的完全图，那么\\(G(G_2)\\)也将包含一个边和节点一一对应的子图。因此它必定是\\(G\\)中一个大小为\\(k\\)的团。\r\n因此\\(\\text{CLIQUE}\\le_P\\text{SUBGRAPH-ISOMORPHISM}\\)。由于CLIQUE是NP完全的，那么SUBGRAPH-ISOMORPHISM是NP困难的，也是NP完全的，原结论成立。\r\n34.5-2\r\n先将0-1整数规划问题定义成一种语言0-1-INTEGER-PROGRAMMING：\r\n\\[\\begin{aligned}\r\n\\text{0-1-INTEGER-PROGRAMMING}=\\{\\langle A,b\\rangle:&amp;A\\text{ is a\r\n}m\\times n\\text{ matrix},\\\\\r\n&amp;b\\text{ is a }m\\text{-vector},\\text{ and}\\\\\r\n&amp;\\text{there exists a }n\\text{-0-1-vector }x\\text{ such that }Ax\\le\r\nb\r\n\\}\r\n\\end{aligned}\\]\r\n首先证明0-1整数规划问题0-1-INTEGER-PROGRAMMING属于\\(\\text{NP}\\)。对于一组输入\\(\\langle A,b\\rangle\\)和一个证书：\\(n\\)维向量\\(x\\)，检验算法只需要先判断\\(x\\)是否为一个\\(0\\text{-}1\\)向量，然后再计算\\(b&#39;=Ax\\)，并检验是否满足\\(b&#39;\\le\r\nb\\)即可。这个检验过程可以在多项式时间内完成，因此0-1-INTEGER-PROGRAMMING属于\\(\\text{NP}\\)。\r\n接下来证明0-1-INTEGER-PROGRAMMING是NP困难的，考虑使用3-CNF可满足行性问题进行规约，即证明\\(\\text{3-CNF-SAT}\\le_P\\text{0-1-INTEGER-PROGRAMMING}\\)。给定变量\\(x_1,x_2,\\dots,x_n\\)的一个3-CNF公式\\(\\phi\\)，它由子句\\(\\phi_1,\\phi_2,\\dots,\\phi_k\\)构成。规约算法\\(F\\)将构造0-1-INTEGER-PROGRAMMING问题的一个实例\\(\\langle A,b\\rangle\\)使得\\(\\phi\\)是可满足的，当且仅当存在0-1向量\\(x\\)，使得\\(Ax\\le\r\nb\\)。\r\n规约的过程如下：\r\n\r\n对于每一个变量\\(x_i\\)，在0-1整数规划中都用\\(2\\)个未知数\\(y_i,\\neg y_i\\)来表示，\\(x_i\\)对应了\\(y_i\\)；\\(\\neg\r\nx_i\\)对应着\\(\\neg\r\ny_i\\)。那么列出两条不等式：\\(y_i+\\neg\r\ny_i\\le 1,y_i+\\neg y_i\\ge 1\\)，这是为了保证\\(y_i+\\neg y_i=1\\)成立。\r\n对于每一个子句\\(\\phi_i=z_{i,1}\\lor\r\nz_{i,2}\\lor z_{i,3}\\)，将每个文字转换成对应的未知数后（设为\\(y_{i,1}, y_{i,2},\r\ny_{i,3}\\)），列出不等式\\(y_{i,1}+y_{i,2}+y_{i,3}\\ge\r\n1\\)。这意味着，每个公式中，至少有一个布尔变量的取值为\\(1\\)。\r\n\r\n接下来只需要将带有大于等于号的公式两侧取负，那么就转换成了都是小于等于号的公式。\r\n可见，规约算法构造出了\\(2n+k\\)条不等式，这些不等式的未知变量个数为\\(2n\\)。因此，矩阵\\(A\\)的大小为\\((2n+k)\\times 2n\\)。可见，规约算法\\(F\\)能够将矩阵\\(A\\)和向量\\(b\\)在多项式时间内能构造出来。\r\n现在证明\\(\\phi\\)是可满足的，当且仅当存在0-1向量\\(x\\)，使得\\(Ax\\le\r\nb\\)。\r\n充分性：首先假设\\(\\phi\\)存在着一组可满足性赋值\\(x_1,x_2,\\dots,x_n\\)，那么令\\(y_i=x_i,\\neg y_i=\\neg\r\nx_i\\)。在这个赋值下，\\(y_i+\\neg\r\ny_{i}=1\\)必定成立。由于每个子句\\(\\phi_i\\)都是为\\(1\\)，因此必定存在某个文字\\(z_{i,j}\\)所对应的未知变量\\(x_{i,j}\\)的赋值为\\(1\\)，从而使得下面\\(k\\)个不等式中大于等于\\(1\\)成立。因此如果\\(\\phi\\)是可满足的，可以对对应的0-1整数规划问题\\(\\langle A,b\\rangle\\)实例找到一组解。\r\n必要性：首先假设这组0-1整数规划问题实例\\(\\langle\r\nA,b\\rangle\\)存在一组解。在这组解中，构造一组\\(\\phi\\)上变量的赋值\\(x_i=y_i\\)。由于\\(\\forall i\\in[1,k],y_{i,1}+y_{i,2}+y_{i,3}\\ge\r\n1\\)均成立，这意味着所有子句\\(\\phi_i\\)中，都必有其中一个变量为\\(1\\)。因此\\(\\phi\\)是可满足的。\r\n因此\\(\\text{3-CNF-SAT}\\le_P\\text{0-1-INTEGER-PROGRAMMING}\\)。由于3-CNF-SAT是NP完全的，那么0-1-INTEGER-PROGRAMMING是NP困难的，也是NP完全的，原结论成立。\r\n34.5-3\r\n先将整数规划问题定义成一种语言INTEGER-LINEAR-PROGRAMMING：\r\n\\[\\begin{aligned}\r\n\\text{INTEGER-LINEAR-PROGRAMMING}=\\{\\langle A,b\\rangle:&amp;A\\text{ is a\r\n}m\\times n\\text{ matrix},\\\\\r\n&amp;b\\text{ is a }m\\text{-vector},\\text{ and}\\\\\r\n&amp;\\text{there exists a }n\\text{-vector }x\\text{ such that }Ax\\le b\r\n\\}\r\n\\end{aligned}\\]\r\n首先证明整数规划问题INTEGER-LINEAR-PROGRAMMING属于\\(\\text{NP}\\)。对于一组输入\\(\\langle A,b\\rangle\\)和一个证书：\\(n\\)维向量\\(x\\)，检验算法只需要先判断\\(x\\)是否为一个整数向量，然后再计算\\(b&#39;=Ax\\)，并检验是否满足\\(b&#39;\\le\r\nb\\)即可。这个检验过程可以在多项式时间内完成，因此INTEGER-LINEAR-PROGRAMMING属于\\(\\text{NP}\\)。\r\n不过，题目34.5-2所规约而来的实例\\(\\langle\r\nA,b\\rangle\\)恰好也是一个整数规划问题。因此，按照和题目34.5-2完全一样的论证过程，可以证明INTEGER-LINEAR-PROGRAMMING也是NP困难的，从而得知它是NP安全的，原结论成立。\r\n34.5-4\r\n如果目标值\\(t\\)可以表示成一元形式，那么可以构造出和0-1背包问题类似的动态规划算法进行解决（可以利用题目15.2-2所提到的算法）。将每一个数\\(x_i\\)视为物品的种类，将目标\\(t\\)视为背包的总重量，那么可以判断背包是否能否被恰好装满即可。\r\n算法0-1-KNAPSACK-PROBLEM'给出了整个过程，它是0-1-KNAPSACK-PROBLEM的改造，用于解决这个问题：\r\n0-1-KNAPSACK-PROBLEM(x, n, t)  let f[0 : t] be a new array by 0  f[0] = 1  for i = 1 to n    for j = t down to x[i]      if f[j - w] == 1        f[j] = 1  return f[t]\r\n可见，这个过程的时间复杂度为\\(O(nt)\\)。由于\\(t\\)是一元编码的，因此其输入规模取决于\\(t\\)值本身的大小。因此这个算法是一个多项式算法。\r\n34.5-5\r\n先将集合划分问题定义成一种语言SET-PARTITION：\r\n\\[\\text{SET-PARTITION} = \\left\\{\\langle\r\nS\\rangle : \\text{there exists a set }A\\subseteq S\\text{ such that\r\n}\\sum_{x\\in A} x=\\sum_{x\\in\\overline{A}}x\\right\\}\\]\r\n首先证明SET-PARTITION属于\\(\\text{NP}\\)。对于\\(S\\)和它的一个非空子集\\(A\\)，检验程序只需要判断\\(\\displaystyle{2\\sum_{x\\in A}x=\\sum_{x\\in\r\nS}x}\\)是否满足即可，它可以在多项式时间内运行，因此SET-PARTITION属于\\(\\text{NP}\\)。\r\n接下来证明SET-PARTITION是NP困难的，考虑使用子集和问题进行规约，即证明\\(\\text{SUBSET-SUM}\\le_P\\text{SET-PARTITION}\\)。对于SUBSET-SUM问题中的任意一个实例\\(\\langle S,t\\rangle\\)，规约算法\\(F\\)构造出如下一个SET-PARTITION问题的实例\\(\\langle S&#39;\\rangle\\)，使得\\(S\\)包含一个和为\\(t\\)的子集，当且仅当\\(S&#39;\\)能够划分成两个和值相等的子集。\r\n规约过程是：计算出\\(\\displaystyle{s=\\sum_{x\\in\r\nS}x}\\)后，令\\(S&#39;=S\\cup\\{2s-t,s+t\\}\\)，现在集合\\(S&#39;\\)的所有数之和为\\(4s\\)。\r\n现在证明\\(S\\)包含一个和为\\(t\\)的子集，当且仅当\\(S&#39;\\)能够划分成两个和值相等的子集。\r\n充分性：如果\\(S\\)包含一个和为\\(t\\)的子集\\(T\\)，那么令\\(T&#39;=T\\cup\\{2s-t\\}\\)，可见\\(T&#39;\\subseteq S&#39;\\)，并且\\(T&#39;\\)的和恰好是\\(S&#39;\\)的一半，故\\(T&#39;\\)为\\(\\langle S&#39;\\rangle\\)的一个证据。\r\n必要性：如果\\(S&#39;\\)可以划分为两个相等的子集\\(T&#39;\\)和\\(S&#39;-T&#39;\\)。那么考虑\\(2s-t,s+t\\)这两个数所属于的子集。由于\\((2s-t)+(s+t)=3s&gt;\\dfrac{1}{2}\\cdot\r\n4s\\)，因此\\(2s-t\\)和\\(s+t\\)在这种情况下，必定会划分在两个不同的子集。不失一般性，假设\\(2s-t\\)在\\(T&#39;\\)所处的子集，那么令\\(T=T&#39;-\\{2s-t\\}\\)，可以发现\\(T\\subseteq S\\)，并且\\(T\\)的元素之和为\\(t\\)，故\\(T\\)为\\(\\langle\r\nS,t\\rangle\\)的一个证据。\r\n因此\\(\\text{SUBSET-SUM}\\le_P\\text{SET-PARTITION}\\)。由于SUBSET-SUM是NP完全的，那么SET-PARTITION是NP困难的，也是NP完全的，原结论成立。\r\n34.5-6\r\n先将哈密顿路径问题定义成一种语言HAM-PATH:\r\n\\[\\text{HAM-PATH} = \\{\\langle G\\rangle :\r\n\\text{there exists a hamiltonian path in }G\\}\\]\r\n首先证明HAM-PATH属于\\(\\text{NP}\\)。对于图\\(G=(V,E)\\)和它的一个顶点序列\\(P\\)，检验程序只需要判断\\(P\\)是否为一条简单路径，并且经过了\\(V\\)中的所有顶点即可。它可以在多项式时间内运行，因此HAM-PATH属于\\(\\text{NP}\\)。\r\n接下来证明HAM-PATH是NP困难的，考虑使用哈密顿回路问题进行规约，即证明\\(\\text{HAM-CYCLE}\\le_P\\text{HAM-PATH}\\)。对于HAM-PATH问题中的任意一个实例\\(\\langle G\\rangle\\)，规约算法\\(F\\)构造出如下一个HAM-PATH问题的实例\\(\\langle G&#39;\\rangle\\)，使得\\(G=(V,E)\\)包含一条哈密顿回路，当且仅当\\(G&#39;=(V&#39;,E&#39;)\\)包含一条哈密顿路径。\r\n规约过程是：选择\\(V\\)中的一个顶点\\(u\\)，那么构造\\(V&#39;=V\\cup\r\n\\{s,t,u&#39;\\},E=E\\cup\\{(s,u),(t,u&#39;)\\}\\cup\\{(u&#39;,w):(u,w)\\in\r\nE\\}\\)。也就是说，\\(u&#39;\\)是\\(u\\)的一个复制点，其所有邻居都和\\(u\\)相同。可见\\(|E&#39;|\\le 2|E|+2\\)，因此图\\(G&#39;\\)可以在多项式时间内构造出来。\r\n现在证明\\(G=(V,E)\\)包含一条哈密顿回路，当且仅当\\(G&#39;=(V&#39;,E&#39;)\\)包含一条哈密顿路径。\r\n充分性：如果\\(G\\)包含了一条哈密顿回路\\(C=(u,v_1,v_2,\\dots,v_{n-1},u)\\)，那么考虑将\\(C\\)删去边\\((v_{n-1},u)\\)，并加上边\\((v_{n-1},u&#39;),(u&#39;,t),(s,u)\\)，得到路径\\(P\\)，那么路径\\(P\\)将是一条经过\\(G&#39;\\)中所有顶点的简单路径，因此\\(P\\)是\\(G&#39;\\)的一条哈密顿路径。\r\n必要性：假设\\(G&#39;\\)包含了一条哈密顿路径\\(P\\)。由于图\\(G&#39;\\)有且仅有两个顶点\\(s,t\\)的度数为\\(1\\)，因此\\(P\\)两端的节点必定是\\(s,t\\)。由于\\(s\\)和\\(u\\)相连，\\(t\\)和\\(u&#39;\\)相连，因此\\(P&#39;\\)为这个形式：\\((s,u,v_1&#39;,v_2&#39;,\\dots,v_{n-1}&#39;,u&#39;,t)\\)。对\\(P&#39;\\)删去边\\((s,u),(v_{n-1}&#39;,u&#39;),(u&#39;,t)\\)并加上边\\((v_{n-1}&#39;,u)\\)，得到回路\\(C\\)，那么回路\\(C\\)将是一条经过\\(G\\)中所有顶点的简单回路，因此\\(C\\)是\\(G\\)的一条哈密顿回路。\r\n因此\\(\\text{HAM-CYCLE}\\le_P\\text{HAM-PATH}\\)。由于HAM-CYCLE是NP完全的，那么HAM-PATH是NP困难的，也是NP完全的，原结论成立。\r\n34.5-7\r\n这个问题的判定性版本为：给定一个图\\(G\\)和一个正整数\\(k\\)，判断图\\(G\\)是否存在一个长度至少为\\(k\\)的简单回路？\r\n题目34.1-2将最长简单回路问题定义成一种语言CYCLE:\r\n\\[\\begin{aligned}\r\n\\text{CYCLE}=\\{\\langle G, k\\rangle:&amp;G = (V, E)\\text{ is an\r\nundirected graph, }\\\\\r\n&amp;k \\ge 0\\text{ is an integer, and}\\\\\r\n&amp;G\\text{ contains a cycle at least }k\\text{ edges}\\}\r\n\\end{aligned}\\]\r\n首先证明CYCLE属于\\(\\text{NP}\\)。对于问题的一个实例\\(\\langle\r\nG,k\\rangle,G=(V,E)\\)和它的一个顶点序列\\(P\\)，检验程序只需要判断\\(P\\)是否为一条首尾相接的简单回路，并且长度至少为\\(k\\)即可。它可以在多项式时间内运行，因此CYCLE属于\\(\\text{NP}\\)。\r\n接下来证明CYCLE是NP困难的，考虑使用哈密顿回路问题进行规约，即证明\\(\\text{HAM-CYCLE}\\le_P\\text{CYCLE}\\)。对于HAM-CYCLE问题中的任意一个实例\\(\\langle G\\rangle\\)，规约算法\\(F\\)构造出如下一个CYCLE问题的实例\\(\\langle G,k\\rangle\\)，使得\\(G\\)包含一条哈密顿回路，当且仅当\\(\\langle G,k\\rangle\\)包含一条长度至少为\\(k\\)的简单回路。\r\n规约过程是：如果HAM-CYCLE问题中的图为\\(G=(V,E)\\)，那么令CYCLE问题某个实例\\(\\langle G,k\\rangle\\)中的\\(k=|V|\\)即可。可见，只需要对HAM-CYCLE问题中的图再额外添加一个数\\(|V|\\)，\\(F\\)就完成工作，因此\\(F\\)是多项式算法。\r\n现在证明\\(G=(V,E)\\)包含一条哈密顿回路，当且仅当\\(\\langle\r\nG,|V|\\rangle\\)包含一条长度至少为\\(|V|\\)的简单回路。这是显而易见的，因为一条哈密顿回路，恰好正是一条长度为\\(|V|\\)的简单回路，反之亦然。\r\n因此\\(\\text{HAM-CYCLE}\\le_P\\text{CYCLE}\\)。由于HAM-CYCLE是NP完全的，那么CYCLE是NP困难的，也是NP完全的，原结论成立。\r\n34.5-8\r\n先将半3-CNF可满足性问题定义成一种语言HALF-3-CNF-SAT：这门语言和3-CNF-SAT定义类似，只是恰有一半的子句的值为\\(1\\)，一半的子句的值为\\(0\\)。\r\n首先证明HALF-3-CNF-SAT属于\\(\\text{NP}\\)。对于一条输入公式\\(\\phi\\)和一组输入赋值\\(x\\)，检验程序需要判断\\(\\phi\\)是否是\\(3\\)合取范式，然后再为\\(\\phi\\)的每个子句赋值，并计算出每个子句\\(\\phi_i\\)的输出值。统计这些子句输出值为\\(0\\)的个数\\(c_0\\)和为\\(1\\)的个数\\(c_1\\)，并判断是否有\\(c_0=c_1\\)。该检验程序多项式可以在多项式时间内完成，因此HALF-3-CNF-SAT属于\\(\\text{NP}\\)。\r\n接下来证明HALF-3-CNF-SAT是NP困难的，考虑使用3-CNF可满足行性问题进行规约，即证明\\(\\text{3-CNF-SAT}\\le_P\\text{HALF-3-CNF-SAT}\\)。对于3-CNF-SAT问题中的任意一个实例\\(\\langle \\phi\\rangle\\)，规约算法\\(F\\)构造出如下一个HALF-3-CNF-SAT问题的实例\\(\\langle \\phi&#39;\\rangle\\)，使得\\(\\phi\\)是可满足的，当且仅当\\(\\phi&#39;\\)是半可满足的。\r\n规约过程是：对于一个\\(n\\)个变量，\\(m\\)个子句公式\\(\\phi\\)添加\\(m\\)个恒真子句\\(x\\lor x\\lor\\neg x\\)，以及\\(2m\\)个取决于\\(x\\)的\\(x\\)子句\\(x\\lor\r\nx\\lor x\\)，那么就构造出了一个具有\\(4m\\)个子句的公式\\(\\phi&#39;\\)。由于\\(\\phi&#39;\\)的公式长度仅为\\(\\phi\\)的\\(4\\)倍，因此\\(F\\)是多项式算法。\r\n现在证明\\(\\phi\\)是可满足的，当且仅当\\(\\phi&#39;\\)是半可满足的。\r\n充分性：如果\\(\\phi\\)是可满足的，那么将同样对应的变量赋值到\\(\\phi&#39;\\)中，并且取\\(x=0\\)，那么原来的\\(m\\)个子句和\\(m\\)个恒真子句均为\\(1\\)，其余的\\(2m\\)个\\(x\\)子句的值为\\(0\\)。因此这个赋值说明公式\\(\\phi&#39;\\)是半3-CNF可满足的。\r\n必要性：假设\\(\\phi&#39;\\)是半3-CNF可满足的，并存在一组解。由于\\(\\phi&#39;\\)中有\\(m\\)个恒真子句，如果\\(x=1\\)，那么\\(\\phi&#39;\\)中有至少\\(3m\\)个子句的值为\\(1\\)，这是不可能的，因此只能有\\(x=0\\)。这说明属于\\(\\phi\\)的\\(m\\)个子句的值必定为\\(1\\)。取出这些变量的赋值赋给\\(\\phi\\)，那么\\(\\phi\\)的值必定为\\(1\\)，这说明公式\\(\\phi\\)是3-CNF可满足的。\r\n因此\\(\\text{3-CNF-SAT}\\le_P\\text{HALF-3-CNF-SAT}\\)。由于3-CNF-SAT是NP完全的，那么HALF-3-CNF-SAT是NP困难的，也是NP完全的，原结论成立。\r\n34.5-9\r\n在对定理34.13证明的时候，有一个步骤是将以下边集添加到\\(E&#39;\\)中：\r\n\\[\\{(s_j, [u, u^{(1)}, 1]) : u \\in V\r\n\\text{ and } 1 \\le j \\le k\\}\\cup \\{(s_j, [u, u^{(\\text{degree}(u))}, 6])\r\n: u \\in V\\text{ and }1 \\le j \\le k\\}\\]\r\n对于某个孤立节点\\(w\\)，并没有边与它相关联，因此并不存在节点\\([w,w^{(1)},1]\\)和\\([w,w^{(0)},6]\\)，但是又有\\(w\\in\r\nV\\)，最终这种情况下证明会产生错误。\r\n","categories":["算法导论"]},{"title":"算法导论33.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-33/exercises-3/","content":"\r\n33.3-1\r\n由于\\(f\\)是凸函数，因此改写不等式33.18，可以得到\r\n\\[f(\\mathbf{y}+\\lambda(\\mathbf{x}-\\mathbf{y}))\\le\\lambda\r\nf(\\mathbf{x})+(1-\\lambda)f(\\mathbf{y})\\]\r\n经过移项，可以写出\r\n\\[f(\\mathbf{y}+\\lambda(\\mathbf{x}-\\mathbf{y}))-f(\\mathbf{y})\\le\\lambda\r\nf(\\mathbf{x})-\\lambda f(\\mathbf{y})\\]\r\n假设\\(\\lambda\\neq 0\\)，那么有\r\n\\[\\dfrac{f(\\mathbf{y}+\\lambda(\\mathbf{x}-\\mathbf{y}))-f(\\mathbf{y})}{\\lambda}+f(\\mathbf{y})\\le\r\nf(\\mathbf{x})\\]\r\n当\\(\\lambda\\)无限接近于\\(0\\)时，也就是\r\n\\[\\lim_{\\lambda\\rightarrow\r\n0^{+}}\\dfrac{f(\\mathbf{y}+\\lambda(\\mathbf{x}-\\mathbf{y}))-f(\\mathbf{y})}{\\lambda}+f(\\mathbf{y})\\le\r\nf(\\mathbf{x})\\]\r\n最终得到\r\n\\[\\langle(\\nabla\r\nf)(\\mathbf{y}),\\mathbf{x-y}\\rangle+f(\\mathbf{y})\\le\r\nf(\\mathbf{x})\\]\r\n也就是有\r\n\\[f(\\mathbf{y})\\le\r\nf(\\mathbf{x})+\\langle(\\nabla\r\nf)(\\mathbf{y}),\\mathbf{y-x}\\rangle\\]\r\n交换变量\\(\\mathbf{x,y}\\)即可得到原结论。\r\n33.3-2\r\n为了方便，这题使用的下标范围是从\\(1\\)到\\(T\\)，即证明 \\[f\\left(\\dfrac{\\mathbf{x^{(1)}+x^{(2)}+\\dots+x^{(T)}}}{T}\\right)\\le\\dfrac{f(\\mathbf{x^{(1)}})+f(\\mathbf{x^{(2)}})+\\dots+f(\\mathbf{x^{(T)}})}{T}\\]\r\n令\\(\\displaystyle{\\mathbf{y^{(i)}}=\\dfrac{\\sum_{j=1}^i\r\n\\mathbf{x^{(j)}}}{T}}\\)，那么对\\(i=2,3,4,\\dots,T\\)，都有\r\n\\(\\begin{aligned}\r\nf(\\mathbf{y^{i}})&amp;=f\\left(\\dfrac{\\mathbf{x^{(i)}}}{i}+\\dfrac{(i-1)\\mathbf{y^{(i-1)}}}{i}\\right)\\\\\r\n&amp;\\le\r\n\\dfrac{f(\\mathbf{x^i})}{i}+\\dfrac{(i-1)f(\\mathbf{y^{(i-1)}})}{i}&amp;\\qquad(A)\r\n\\end{aligned}\\)\r\n其中步骤\\((A)\\)使用了凸函数\\(f\\)的性质，因为此时\\(\\lambda=\\dfrac{1}{i}\\)。\r\n考虑对\\(Tf(\\mathbf{y^{(T)}})\\)循环代入上面的不等式，那么得到\r\n\\(\\begin{aligned}\r\nT(\\mathbf{y^{(T)}})&amp;\\le\r\nf(\\mathbf{x^{(T)}})+(T-1)f(\\mathbf{y^{(T-1)}})\\\\\r\n&amp;\\le\r\nf(\\mathbf{x^{(T)}})+f(\\mathbf{x^{(T-1)}})+(T-2)f(\\mathbf{y^{(T-2)}})\\\\\r\n&amp;\\dots\\\\\r\n&amp;\\le f(\\mathbf{x^{(T)}})+f(\\mathbf{x^{(T-1)}})+\\dots+\r\nf(\\mathbf{y^{(1)}})\\\\\r\n&amp;\\le\r\nf(\\mathbf{x^{(T)}})+f(\\mathbf{x^{(T-1)}})+\\dots+f(\\mathbf{x^{(1)}})\r\n\\end{aligned}\\)\r\n重新将\\(\\mathbf{y^{(T)}}\\)回代到上面的不等式，并将\\(T\\)进行移项，即可得到 \\[f\\left(\\dfrac{\\mathbf{x^{(1)}+x^{(2)}+\\dots+x^{(T)}}}{T}\\right)\\le\\dfrac{f(\\mathbf{x^{(1)}})+f(\\mathbf{x^{(2)}})+\\dots+f(\\mathbf{x^{(T)}})}{T}\\]\r\n33.3-3\r\n令\\(\\mathbf{a}=(a_1,a_2,\\dots,a_n),\\mathbf{b}=(b_1,b_2,\\dots,b_n)\\)。考虑计算\\(\\lVert\\mathbf{a}+\\mathbf{b}\\rVert^2-\\lVert\\mathbf{a}\\rVert^2\\)的值，根据向量积和模长的定义，可以得到：\r\n\\(\\begin{aligned}\r\n\\lVert\\mathbf{a}+\\mathbf{b}\\rVert^2-\\lVert\\mathbf{a}\\rVert^2&amp;=\\sum_{i=1}^n(a_i+b_i)^2-\\sum_{i=1}^na_i^2\\\\\r\n&amp;=\\sum_{i=1}^n(2a_ib_i+b_i^2)\\\\\r\n&amp;=2\\sum_{i=1}^na_ib_i+\\sum_{i=1}^nb_i^2\\\\\r\n&amp;=2\\langle\\mathbf{a},\\mathbf{b}\\rangle+\\lVert\\mathbf{b}\\rVert^2\r\n\\end{aligned}\\)\r\n原结论得证。\r\n33.3-4\r\n令\\(\\mathbf{x}=(x_1,x_2,\\dots,x_n),\\mathbf{y}=(y_1,y_2,\\dots,y_n)\\)。考虑使用不等式33.18来证明\\(f(\\mathbf{x})\\)是凸函数。那么对于\\(\\lambda\\in[0,1]\\)，有以下两个值：\r\n\\(\\begin{aligned}\r\nf(\\lambda\\mathbf{x}+(1-\\lambda)\\mathbf{y})&amp;=w_0+\\sum_{i=1}^n\r\nw_i(\\lambda x_i+(1-\\lambda)y_i)\\\\\r\n&amp;=w_0+\\sum_{i=1}^n (w_iy_i+\\lambda w_i(x_i-y_i))\\\\\r\n\\\\\r\n\\lambda\r\nf(\\mathbf{x})+(1-\\lambda)f(\\mathbf{y})&amp;=\\lambda\\left(w_0+\\sum_{i=1}^{n}w_ix_i\\right)+(1-\\lambda)\\left(w_0+\\sum_{i=1}^{n}w_iy_i\\right)\\\\\r\n&amp;=w_0+\\sum_{i=1}^n \\lambda w_i x_i+(1-\\lambda)w_iy_i\\\\\r\n&amp;=w_0+\\sum_{i=1}^n (w_iy_i+\\lambda w_i(x_i-y_i))\\\\\r\n\\end{aligned}\\)\r\n因此有\\(f(\\lambda\\mathbf{x}+(1-\\lambda)\\mathbf{y})=\\lambda\r\nf(\\mathbf{x})+(1-\\lambda)f(\\mathbf{y})\\)。这满足了凸函数的等号特殊条件，因此\\(f(\\mathbf{x})\\)是凸函数。\r\n33.3-5\r\n令\\(\\displaystyle{g(\\mathbf{w})=\\dfrac{1}{m}\\sum_{i=1}^m\r\n(e^{(i)})^2}\\)，其中\\(\\displaystyle{e^{(i)}}=\\left(w_0+\\sum_{j=1}^nw_jx_j^{(i)}\\right)-y^{(i)}\\)。注意，\\(\\mathbf{w}\\)是未知的；但是\\(\\mathbf{x^{(i)}}\\)和\\(y^{(i)}\\)都是已知的，都将它们看作常数对待。\r\n先考虑计算\\(\\dfrac{\\partial g}{\\partial\r\nw_0}\\)的值，那么有：\r\n\\(\\begin{aligned}\r\n\\dfrac{\\partial g}{\\partial w_0}&amp;=\\sum_{i=1}^m \\dfrac{\\partial\r\n(e^{(i)})^2}{\\partial w_0}\\\\\r\n&amp;=\\dfrac{2}{m}\\sum_{i=1}^m\r\n\\left(w_0+\\sum_{j=1}^nw_jx_j^{(i)}\\right)-y^{(i)}\\\\\r\n&amp;=\\dfrac{2}{m}\\sum_{i=1}^m e^{(i)}\r\n\\end{aligned}\\)\r\n再考虑计算\\(\\dfrac{\\partial g}{\\partial\r\nw_k}\\)的值，其中\\(k\\in[1,n]\\)，那么有：\r\n\\(\\begin{aligned}\r\n\\dfrac{\\partial g}{\\partial w_k}&amp;=\\dfrac{1}{m}\\sum_{i=1}^m\r\n\\dfrac{\\partial (e^{(i)})^2}{\\partial w_k}\\\\\r\n&amp;=\\dfrac{2}{m}\\sum_{i=1}^m\r\nx_k^{(i)}\\cdot\\left(\\left(w_0+\\sum_{j=1}^nw_jx_j^{(i)}\\right)-y^{(i)}\\right)\\\\\r\n&amp;=\\dfrac{2}{m}\\sum_{i=1}^m x_k^{(i)}\\cdot e^{(i)}\r\n\\end{aligned}\\)\r\n那么计算方法非常简单。对于第\\(i\\)条数据，我们先以\\(O(n)\\)的时间计算出\\(e^{(i)}\\)的值，然后根据\\(e^{(i)}\\)，分别以\\(O(1)\\)的时间再计算出\\(\\dfrac{\\partial g}{\\partial w_0},\\dfrac{\\partial\r\ng}{\\partial w_1},\\dots,\\dfrac{\\partial g}{\\partial\r\nw_n}\\)的值，这总共需要\\(O(n)\\)的时间。对这\\(m\\)条数据都进行这样的操作，并将对应的梯度值相加即可得到结果，总共花费的时间为\\(O(nm)\\)。这个算法由NABLA-W给出。\r\nNABLA-W(W, X, Y, n, m)  let D[0 : n] be new array by 0  for i = 1 to m    e = 0    for j = 1 to n      e = e + W[j] * X[i, j]    e = e + W[0] - Y[i]    D[0] = D[0] + 2 * e    for j = 1 to n      D[j] = D[j] + 2 * e * X[i, j]  return D\r\n33.3-6\r\n令\\(\\mathbf{x}=(x_1,x_2,\\dots,x_n),\\mathbf{w}=(w_{\\mathbf{0}},w_1,w_2,\\dots,w_n)\\)。\r\n由于\\(\\displaystyle{f(\\mathbf{x})=w_0+\\sum_{i=1}^n\r\nw_ix_i}\\)，因此对于\\(\\forall i\\in\r\n[1,n]\\)，都有\\(\\dfrac{\\partial\r\nf}{\\partial x_i}=w_i\\)。也就是说，有\\((\\nabla\r\nf)(\\mathbf{x})=(w_1,w_2,\\dots,w_n)\\)。\r\n由于\\(\\lVert \\mathbf{w}\\rVert\\le\r\nB\\)，那么有\r\n\\(\\begin{aligned}\r\n\\lVert (\\nabla f)(\\mathbf{x})\\rVert &amp;=\\sqrt{\\sum_{i=1}^n w_i^2}\\\\\r\n&amp;\\le\\sqrt{w_0^2+\\sum_{i=1}^n w_i^2}\\\\\r\n&amp;=B\r\n\\end{aligned}\\)\r\n因此\\(\\lVert (\\nabla\r\nf)(\\mathbf{x})\\rVert\\le B\\)对于任意\\(\\mathbf{x}\\in\r\n\\mathbb{R}^n\\)都成立。只需要取\\(L=B\\)即可，因此\\(L=O(B)\\)。\r\n33.3-7\r\n本质上，我们的目标是将\\(\\displaystyle{f(S,C)=\\sum_{\\ell=1}^k\\sum_{\\mathbf{x}\\in\r\nS^{(\\ell)}}\\Delta(\\mathbf{c^{(\\ell)},x})}\\)最小化。对每个聚类中的重心\\(\\mathbf{c^{(\\ell)}}\\)，使用梯度下降来让重心朝某个方向移动一定距离，并且保证最终距离平方和减少。\r\n具体过程是，令\\(\\displaystyle{h(\\mathbf{c^{(\\ell)}})=\\sum_{\\mathbf{x}\\in\r\nS^{(\\ell)}}\\Delta(\\mathbf{c^{(\\ell)},x})}\\)。那么将\\(h(\\mathbf{c^{(\\ell)}})\\)当作是损失函数，对原来的重心\\(\\mathbf{c^{(\\ell)}}\\)移动\\(\\lambda \\cdot(\\nabla\r\nh)(\\mathbf{c^{(\\ell)}})\\)的一步。根据梯度下降的原理，\\(h(\\mathbf{c^{(\\ell)}})\\)值已经减小了。如果在下一步迭代中，某个点所属类别发生了变更（假设变更到了\\(S^{\\ell&#39;}\\)），那么说明\\(\\Delta(\\mathbf{x,c^{(\\ell)}})&gt;\\Delta(\\mathbf{x,c^{(\\ell&#39;)}})\\)，这将确保总体上\\(f(S,C)\\)的值是下降的。\r\n因此，使用梯度下降可以有效解决\\(k\\)-means问题。\r\n","categories":["算法导论"]},{"title":"算法导论34.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-34/exercises-1/","content":"\r\n34.1-1\r\n充分性：显而易见，只需要运行一次LONGEST-PATH-LENGTH算法就可以得到最长路径的值\\(l\\)，判定性问题LONGEST-PATH只需要以LONGEST-PATH-LENGTH作为子程序，计算出\\(l\\)的值，再比较\\(l\\)和\\(k\\)的大小即可。如果LONGEST-PATH-LENGTH的时间复杂度为\\(O(n^a)\\)，其中\\(a\\)是一个正常数，那么LONGEST-PATH的时间复杂度同样为\\(O(n^{a})\\)，由此充分性成立。\r\n必要性：对于图\\(G=(V,E)\\)，假设\\(n=|V|\\)。可见，一条简单路径的长度至多为\\(n-1\\)。由于判定性问题LONGEST-PATH-LENGTH满足单调性（即\\(\\langle\r\nG,u,v,k\\rangle\\)所有的路径都包含在\\(\\langle\r\nG,u,v,k-1\\rangle\\)中），因此可以考虑使用二分法来进行求解，需要进行\\(O(\\lg\r\nn)\\)次判定。如果某次LONGEST-PATH给出的结果为\\(1\\)，那么说明\\(k\\)还能增大；否则只能减小。因此，如果LONGEST-PATH的时间复杂度为\\(O(n^b)\\)，那么LONGEST-PATH-LENGTH的时间复杂度为\\(O(n^{b}\\cdot \\lg\r\nn)=O(n^{b+\\epsilon})\\)，其中\\(b,\\epsilon\\)是一个正常数。由此必要性成立。\r\n最终，原结论成立。\r\n34.1-2\r\nLONGEST-SIMPLE-CYCLE的形式化定义是：问题中的一个实例是一个图\\(G\\)，其解为图中的顶点序列，表示这个环。其判定性问题CYCLE是：给定一个图\\(G\\)和一个非负整数\\(k\\)，判断图\\(G\\)是否存在一个长度至少为\\(k\\)的环。如果存在，那么输出\\(1\\)；如果不存在，那么输出\\(0\\)。和这个判定问题对应的语言是：\r\n\\[\\begin{aligned}\r\n\\text{CYCLE}=\\{\\langle G, k\\rangle:&amp;G = (V, E)\\text{ is an\r\nundirected graph, }\\\\\r\n&amp;k \\ge 0\\text{ is an integer, and}\\\\\r\n&amp;G\\text{ contains a cycle at least }k\\text{ edges}\\}\r\n\\end{aligned}\\]\r\n34.1-3\r\n邻接矩阵的编码方式如下：首先输入一个\\(32\\)位无符号数表示这个图\\(G=(V,E)\\)的顶点数\\(n=|V|\\)，接下来输入\\(|V|^2\\)个比特，下标从\\(0\\)到\\(|V|^2-1\\)表示它们。那么，如果第\\(i\\)个比特为\\(1\\)，那么有一条边从\\(\\lfloor i/n\\rfloor\\)连向\\(i\\% n\\)，否则没有边从\\(\\lfloor i/n\\rfloor\\)连向\\(i\\% n\\)。\r\n邻接表的编码方式如下：首先输入一个\\(32\\)位无符号整数表示这个图\\(G=(V,E)\\)的顶点数\\(n=|V|\\)。令\\(m=\\lceil (\\lg n+1)\\rceil\\)，接下来循环\\(n\\)次这个过程，直到停止。在第\\(u\\)次循环中，首先读入一个\\(m\\)比特数\\(d_u\\)，表示和\\(u\\)相邻的节点数，接下来循环进行\\(d_u\\)次，每次读入一个\\(m\\)比特数\\(v\\)，表示\\(u\\)指向节点\\(v\\)，并记录。\r\n以下是两种编码的转换过程：\r\n// READ(S, k)表示接下来从S中读入k比特，并解析为一个数。BIN(n, k)表示将非负整数n编码成一个k比特数。ADJACENCY-MATRIX-TO-LIST(S)  T = &quot;&quot;  n = READ(S, 32)  T = T + BIN(n, 32)  m = ⌈lg(n + 1)⌉  for u = 0 to n - 1    E = READ(S, n)    cnt = 0    for v = 0 to n - 1      if E[v] == &#x27;1&#x27;        cnt = cnt + 1    T = T + BIN(cnt, m)    for i = 0 to n - 1      if E[v] == &#x27;1&#x27;        T = T + BIN(v, m)  return TADJACENCY-LIST-TO-MATRIX(S)  T = &quot;&quot;  n = READ(S, 32)  T = T + BIN(n, 32)  m = ⌈lg(n + 1)⌉  for u = 0 to n - 1    let P be a n-length bit string with &#x27;0&#x27;    d = READ(S, m)    for i = 0 to d - 1      v = READ(S, m)      P[v] = &#x27;1&#x27;    T = T + P  return T\r\n可见，无论图的稀疏程度如何，邻接矩阵所需要的比特数都是一样的，为\\(O(n^2)\\)。不过，当图\\(G\\)是完全图时，邻接表需要花费\\(O(n^2\\lg\r\nn)=O(n^{2+\\epsilon})\\)的比特来存储这些比特，其中\\(\\epsilon\\)是一个正常数。此外这两个转换算法仅仅是两层嵌套循环，而没有进行其它操作（如递归）。这两个算法是以\\(O(n^{2+\\epsilon})\\)的时间复杂度对这两种编码进行转换，因此它们是多项式相关的。\r\n34.1-4\r\n0-1背包问题的动态规划算法不是多项式时间的算法。这个问题的时间复杂度为\\(O(nW)\\)，其中\\(W\\)是背包的大小。考虑对这个问题进行编码，\\(n\\)可以编码成一个\\(32\\)位无符号整数。接下来需要对\\(n\\)个物品进行编码，无论如何编码，物品所需要的编码数\\(b_1\\)必定满足\\(\\Omega(n)\\)。接下来对背包重量\\(W\\)进行编码，用\\(b_2=\\Theta(\\lg W)\\)比特即可完成，即有\\(W=\\Theta(2^{b_2})\\)。因此，对于编码长度为\\(b_1+b_2\\)的问题所需要花费的时间为\\(\\Omega(b_1 \\cdot\r\n2^{b_2})\\)。因此，0-1背包问题的动态规划算法不是多项式时间的算法。\r\n34.1-5\r\n假设这个多项式算法为\\(A_1\\)，其子程序为\\(A_2\\)。假设\\(A_1\\)调用了至多\\(k\\)次算法\\(A_2\\)，设这\\(k\\)次调用中，规模最大的一次的大小为\\(n\\)。那么如果\\(A_2\\)的运行时间为\\(O(n^c)\\)，其中\\(c\\)是一个正常数，那么算法\\(A_1\\)在这\\(k\\)次调用中就有着\\(k\\cdot O(n^c)\\)的开销，再加上\\(A_1\\)本身也有额外的多项式次数的开销\\(O(n^d)\\)，因此\\(A_1\\)的运行时间为\\(k\\cdot\r\nO(n^c)+O(n^d)=O(n^{\\max(c,d)})\\)，因此它在多项式时间内运行。\r\n接下来考虑构造一个算法来说明，对多项式算法进行多项式次调用会导致一个指数时间算法出现。给定正整数\\(x\\)和\\(q\\)，我们希望计算\\(x^{2^q}\\)的值。由于\\(x^{2^q}=(x^{2^{q-1}})^2\\)，因此我们可以给出一个算法COMPUTE-X-2-Q来计算\\(x^{2^{q}}\\)：\r\nCOMPUTE-X-2-Q(x, q)  for i = 1 to q    x = x * x  return x\r\n将COMPUTE-X-2-Q视作算法\\(A_1\\)，其代码第2行的乘法视作\\(A_2\\)。那么可以知道，\\(A_1\\)实际上调用了\\(q\\)次\\(A_2\\)，并且对两个数进行乘法计算是一个多项式算法（使用第30章的FFT，可以以\\(O(n\\lg n)\\)的时间完成计算，其中\\(n\\)是数\\(x\\)的长度）。因此COMPUTE-X-2-Q是一个满足题目条件的算法，但是计算结果\\(x^{2^q}\\)经过编码后，需要\\(O(\\lg(x^{2^q}))=O(2^q\\cdot \\lg\r\nx)\\)的比特才能完成编码，这说明COMPUTE-X-2-Q本身需要指数时间完成计算。因此原结论成立，COMPUTE-X-2-Q算法为所求。\r\n34.1-6\r\n假设现在存在两个程序\\(A_1,A_2\\)可以分别在多项式时间\\(O(n^{k_1}),O(n^{k_2})\\)内分别能够判定是否接受语言\\(L_1,L_2\\)。那么可以构造出如下程序用于判定语言\\(L_1\\cup L_2,L_1\\cap\r\nL_2,L_1L_2,\\overline{L_1},L_1^{\\ast}\\)是否属于\\(P\\)：\r\n// 假设字符串的下标从1开始。A-UNION(A1, A2, x)  if A1(x) == 1 or A2(x) == 1    return 1  else    return 0  A-INTERSECTION(A1, A2, x)  if A1(x) == 1 and A2(x) == 1    return 1  else    return 0A-CONCATENATION(A1, A2, x)  // 考虑其中有一个为ε空字符串的情况。  if (A1(x) == 1 and A2(ε) == 1) or (A1(ε) == 1 and A2(x) == 1)    return 1  n = x.size()  for i = 1 to n - 1    if A1(x[1 : i]) == 1 and A2(x[i + 1 : n]) == 1      return 1  return 0A-COMPLEMENT(A1, x)  if A1(x) == 0    return 1  else    return 0A-KLEENE-STAR(A1, x)  n = x.size()  let f[0 : n] be a new array by 0  f[0] = 1  for i = 1 to n    for j = 1 to i      if f[j - 1] == 1 and A1(x[j : i]) == 1        f[i] = 1        break  return f[n]\r\n算法A-UNION和A-INTERSECTION分别调用了\\(1\\)次\\(A_1\\)和\\(A_2\\)，因此其时间复杂度均为\\(O(n^{\\max(k_1,k_2)})\\)。算法A-CONCATENATION对\\(A_1,A_2\\)分别至多调用了\\((n+1)\\)次，并且最大的规模为\\(n\\)，因此其时间复杂度为\\((n+1)\\cdot(O(n^{k_1})+O(n^{k_2}))=O(n^{\\max(k_1,k_2)+1})\\)。算法A-COMPLEMENT仅对\\(A_1\\)进行了\\(1\\)次调用，其时间复杂度为\\(n^{k_1}\\)。A-KLEENE-STAR算法对\\(A_1\\)进行了\\(\\dfrac{n(n+1)}{2}\\)次调用，最大的一次规模为\\(n\\)，因此其时间复杂度为\\(\\dfrac{n(n+1)}{2}\\cdot\r\nO(n^{k_1})=O(n^{k_1+2})\\)。综上所述，A-UNION, A-INTERSECTION, A-CONCATENATION, A-COMPLEMENT, A-KLEENE-STAR可以在多项式时间内对各自的语言完成判定，因此语言\\(L_1\\cup L_2,L_1\\cap\r\nL_2,L_1L_2,\\overline{L_1},L_1^{\\ast}\\in P\\)。\r\n","categories":["算法导论"]},{"title":"算法导论33 Problems 答案","url":"/introduction-to-algorithms/chapter-33/problems/","content":"\r\n33-1\r\na\r\n直线\\(y=f&#39;(x)(x-x^{(t)})+f(x^{(t)})\\)的\\(x\\)轴截距是，令\\(y=0\\)，然后计算出\\(x=-\\dfrac{f(x^{(t)})}{f&#39;(x^{(t)})}+x^{(t)}\\)。因此有\r\n\\[x^{(t+1)}=x^{(t)}-\\dfrac{f(x^{(t)})}{f&#39;(x^{(t)})}\\]\r\nb\r\n由于题中已经给定了，如果\\(x^{(0)}\\)满足方程33.34，那么对于距离比\\(x^{(0)}\\)更近的点，也满足这个方程。\r\n也就是说，对于迭代过程所得到的\\(x^{(1)},x^{(2)},\\dots,x^{(t)}\\)中的所有\\(t\\)，上述方程均成立，因为\\(x^{(1)},x^{(2)},\\dots,x^{(t)}\\)都将比\\(x^{(0)}\\)距离\\(x^{\\ast}\\)更近。因此只需要证明\\(t=0\\)的情况即可。\r\n考虑\\(\\epsilon^{(1)}\\)的值，有\r\n\\(\\begin{aligned}\r\n\\epsilon^{(1)}&amp;=|x^{(1)}-x^{\\ast}|\\\\\r\n&amp;=\\left|x^{(0)}-\\dfrac{f(x^{(0)})}{f&#39;(x^{(0)})}-x^{\\ast}\\right|\\\\\r\n&amp;=\\left|x^{(0)}+\\dfrac{f&#39;(x^{(0)})(x^{\\ast}-x^{(0)})+\\frac{1}{2}f&#39;&#39;(\\gamma^{(0)})(x^{\\ast}-x^{(0)})^2-f(x^{\\ast})}{f&#39;(x^{(0)})}-x^{\\ast}\\right|\\\\\r\n&amp;=\\left|\\dfrac{\\frac{1}{2}f&#39;&#39;(\\gamma^{(0)})(x^{\\ast}-x^{(0)})^2-f(x^{\\ast})}{f&#39;(x^{(0)})}\\right|\\\\\r\n&amp;=\\left|\\dfrac{f&#39;&#39;(\\gamma^{(0)})(x^{\\ast}-x^{(0)})^2}{2f&#39;(x^{(0)})}\\right|\\\\\r\n&amp;=\\left|\\dfrac{f&#39;&#39;(\\gamma^{(0)})}{2f&#39;(x^{(0)})}\\right|(\\epsilon^{(0)})^2\\\\\r\n&amp;=\\left|\\dfrac{f&#39;&#39;(\\gamma^{(0)})}{2f&#39;(\\gamma^{(0)})}\\right|\\epsilon^{(0)}&amp;\\qquad(?)\\\\\r\n\\end{aligned}\\)\r\n步骤\\((?)\\)暂时未知怎么得出，目前在此提问。\r\n因此对于\\(t=1,2,3,4,\\dots\\)，原结论都成立。\r\nc\r\n由于\\(\\dfrac{|f&#39;&#39;(\\gamma^{(t)})|}{2|f&#39;(\\gamma^{(t)})|}\\le\r\nc\\)，因此有\\(\\epsilon^{(t+1)}\\le\r\nc\\epsilon^{(t)}\\)。随着每一次代入，那么有\\(\\epsilon^{(t)}\\le c^t\\epsilon^{(0)}\\)。\r\n如果要令\\(\\epsilon^{(t)}\\le\r\n\\delta\\)，那么就有\r\n\\[c^t\\epsilon^{(0)}\\le \\delta\\]\r\n由于\\(c&lt;1\\)，那么对两边对\\(c\\)取对数，可以得到迭代轮数\\(t\\ge\\log_c(\\delta/\\epsilon^{(0)})\\)。也就是说迭代轮\\(t\\)必须至少要达到这个值。\r\nd\r\n可以知道，\\(f&#39;&#39;(x)=2,f&#39;(x)=2x-6\\)。并且不难知道，\\(x^{\\ast}=3,f(x^{\\ast})=0\\)。\r\n考虑使用梯度下降法最小化\\(f(x)\\)。由于\\(x_0=3.5,x^{\\ast}=3\\)，因此\\(R=0.5\\)。由于\\(x\\in[x^{\\ast},x^{(0)}]\\)，那么有\\(f&#39;(x)\\in[0,1]\\)，因此\\(L=1\\)。根据定理33.8，为了使\\(f(x-\\text{avg})-f(x^{\\ast})&lt;\\delta\\)，那么迭代轮数\\(T\\)必须满足\\(\\delta=\\dfrac{LR}{\\sqrt{T}}\\)，也就是\\(T=\\dfrac{1}{4\\delta^2}\\)，此时需要选择\\(\\gamma=\\dfrac{R}{L \\sqrt{T}}=\\delta\\)。\r\n考虑使用牛顿迭代法求解\\(f(x)=0\\)的根，那么考虑从\\(x^{(t)}\\)计算出\\(x^{(t+1)}\\)的值，并比较\\(\\epsilon^{(t)}=x^{(t)}-x^{\\ast}\\)和\\(\\epsilon^{(t+1)}=x^{(t+1)}-x^{\\ast}\\)。结合\\(x^{(t+1)}=x^{(t)}-\\dfrac{f(x^{(t)})}{f&#39;(x^{(t)})}\\)，有：\r\n\\(\\begin{aligned}\r\n\\epsilon^{(t+1)}&amp;=x^{(t+1)}-x^{\\ast}\\\\\r\n&amp;=x^{(t)}-\\dfrac{(x^{(t)}-3)^2}{2(x^{(t)}-3)}-3\\\\\r\n&amp;=x^{(t)}-\\dfrac{x^{(t)}-3}{2}-3\\\\\r\n&amp;=\\dfrac{x^{(t)}-3}{2}\\\\\r\n&amp;=\\dfrac{\\epsilon^{(t)}}{2}\r\n\\end{aligned}\\)\r\n也就是说，有\\(\\dfrac{\\epsilon^{(t+1)}}{\\epsilon^{(t)}}=\\dfrac{1}{2}\\)。同时可以知道，\\(\\epsilon^{(0)}=0.5\\)。因此有\\(\\epsilon^{(t)}=\\dfrac{1}{2^{t+1}}\\)。\r\n也就是说，为了达到一个精度\\(\\delta\\)，那么有\\(\\epsilon^{(t)}&lt;\\delta\\)，可以解得\\(t&gt;-1-\\lg\\delta\\)。也就是说，只有迭代轮数达到了\\(-1-\\lg\\delta\\)，这个精度才能达到。\r\n因此，当精度要求足够高时，使用牛顿迭代法求解方程的根的迭代轮数远远低于使用梯度下降法求最小值。\r\n33-3\r\n令\\(S=\\{0,1,2,3\\},k=2\\)。如果\\(S^{(1)}=\\{0\\},S^{(2)}=\\{1,2,3\\}\\)，那么实际上迭代一次后，这个聚类结果仍然不变（因为重心的位置一直没有产生变化），此时\\(c^{(1)}=0,c^{(2)}=2\\)，计算出\\(f(S,C)=2\\)，程序终止。\r\n实际上，\\(S&#39;^{(1)}=\\{0,1\\},S&#39;^{(2)}=\\{2,3\\}\\)才是最优的聚类结果，此时\\(c&#39;^{(1)}=0.5,c&#39;^{(2)}=2.5\\)，那么有\\(f(S,C&#39;)=1\\)。\r\n33-4\r\n整个算法的伪代码由程序STOCHASTIC-GRADIENT-DESCENT给出（这里给出的是更一般的情况，也就是这个向量有\\(n\\)维）。\r\nNABLA-W&#x27;(W, x, y, n)  let D[0 : n] be new array  e = 0  for j = 1 to n    e = e + W[j] * x[j]  e = e + W[0] - y  D[0] = 2 * e  for j = 1 to n    D[j] = 2 * e * x[j]  return DSTOCHASTIC-GRADIENT-DESCENT(w(0), X, Y, γ, n, T)  sum = 0  S = &#123;1, 2, 3, ..., T&#125;  for i = 0 to T - 1    sum = sum + w(i)    j = RANDOM(1, T)    w(i+1) = w(i) - γ ⋅ NABLA-W&#x27;(w(i), X[j], Y[j], n)  w-avg = sum / T  return w-avg \r\n由于是对每个点随机选择一个来进行梯度下降，考虑第一步过后梯度的期望步长\\(E[(\\Delta e)(\\mathbf{w^{(i)}})]\\)。\r\n先考虑计算\\(E\\left[\\dfrac{\\partial\r\ne}{\\partial w^{(i)}_0}\\right]\\)的值，有：\r\n\\(\\begin{aligned}\r\nE\\left[\\dfrac{\\partial e}{\\partial\r\nw^{(i)}_0}\\right]&amp;=\\dfrac{1}{T}\\sum_{i=1}^T\\dfrac{\\partial\r\ne^{(i)}}{\\partial w^{(i)}_0}\\\\\r\n&amp;=\\dfrac{2}{T}\\sum_{i=1}^T e^{(i)}\r\n\\end{aligned}\\)\r\n接下来考虑计算\\(E\\left[\\dfrac{\\partial\r\ne}{\\partial w^{(i)}_k}\\right]\\)的值，其中\\(k\\in[1,n]\\)，有：\r\n\\(\\begin{aligned}\r\nE\\left[\\dfrac{\\partial e}{\\partial\r\nw^{(i)}_k}\\right]&amp;=\\dfrac{1}{T}\\sum_{i=1}^T\\dfrac{\\partial\r\ne^{(i)}}{\\partial w^{(i)}_k}\\\\\r\n&amp;=\\dfrac{2}{T}\\sum_{i=1}^T x_k^{(i)}\\cdot e^{(i)}\r\n\\end{aligned}\\)\r\n可以发现，梯度的期望\\(E[(\\Delta\r\ne)(\\mathbf{w^{(i)}})]\\)和题目33.3-5计算出来的\\(\\dfrac{\\partial\r\ng}{\\partial\\mathbf{w}}\\)是一致的，其中\\(\\displaystyle{g(\\mathbf{w})=\\dfrac{1}{T}\\sum_{i=1}^T\r\n(e^{(i)})^2}\\)。因此我们可以认为，权重向量\\(\\mathbf{w^{(i+1)}}\\)的期望是和普通梯度下降算法是一样的，并且“走出”了这一小步。\r\n因此最终分析方式和定理33.8的一致，其误差值\\(\\delta\\)可以视为是值\\(\\dfrac{LR}{\\sqrt{T}}\\)。\r\n","categories":["算法导论"]},{"title":"算法导论35.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-35/exercises-1/","content":"\r\n35.1-1\r\n令图\\(G=(V,E),V=\\{a,b\\},E=\\{(a,b)\\}\\)。可见，算法APPROX-VERTEX-COVER对图\\(G\\)产生的点覆盖大小总是为\\(2\\)（因为它将会把边\\((a,b)\\)直接选出来，并将节点\\(a\\)和\\(b\\)添加到集合中），然而最小点覆盖仅仅是其中一个节点即可。因此在这个图上由APPROX-VERTEX-COVER产生的点覆盖总是次优的。\r\n35.1-2\r\n如果选出的边集\\(A\\)不是一个极大匹配，那么意味着存在一个匹配\\(A&#39;\\)，使得\\(A\\subsetneq A&#39;\\)。考虑某一条边\\((u,v)\\in A&#39;-A\\)。由于\\(A,A&#39;\\)都是一组匹配，因此每个节点在所有边中只出现最多一次。这意味着删去\\(G=(V,E)\\)中的\\(A\\)中这\\(2|A|\\)个节点所有关联的边后，至少还剩下一条边\\((u,v)\\)，算法APPROX-VERTEX-COVER的while循环不应该终止。因此，由算法APPROX-VERTEX-COVER第4行选出的编辑\\(A\\)是\\(G\\)的一个极大匹配。\r\n\\(\\star\\)\r\n35.1-3\r\n假设当前有\\(n=|L|\\)个左部节点，其中\\(n\\)是一个盈数（即\\(n\\)的因子之和大于\\(2n\\)），我们将按如下方式构造这个二分图\\(G=(V,E)\\)：\r\nCONSTRUCT-GRAPH(n):  generate new vertex set L = &#123;l_0, l_1, ..., l_&#123;n - 1&#125;&#125;  R = ∅  E = ∅  for each divisor d of n    k = n / d    generate new vertex set R&#x27; = &#123;r_0, r_1, ..., r_&#123;k - 1&#125;&#125;    R = R ∪ R&#x27;    for j = 0 to n - 1      E = E ∪ &#123;(l_&#123;j&#125;, r_&#123;⌊j / i⌋&#125;)&#125;  return (L ∪ R, E)\r\n也就是说，枚举\\(n\\)的每个因子\\(d\\)，令\\(k=n/d\\)，在右部生成\\(k\\)节点，这\\(k\\)个节点每个节点将连出\\(d\\)条边，连到这不相交的\\(n\\)个节点中。\r\n接下来证明，如果这个启发式算法在点的度数相同的情况下，优先选择\\(R\\)中的节点，那么这个算法将会不停选择\\(R\\)中的节点，并且在\\(|R|&gt;2|L|\\)的情况下，就会超过近似比\\(2\\)。\r\n接下来首先证明这个算法会不停选择\\(R\\)中的节点。假设\\(n\\)一共有\\(\\sigma_0(n)\\)个因子，其中从小到大的第\\(i\\)个因子为\\(d_i\\)，那么必定有\\(d_i\\ge\r\ni\\)，因为一个数的所有因子是正整数的子集。这意味着算法首先删除度数为\\(d_{\\sigma_0(n)}\\)的所有右部节点，删除完成后，\\(L\\)中所有节点的度数都减少\\(1\\)；接下来删除度数为\\(d_{\\sigma_0(n)-1}\\)的所有右部节点，删除完成后，\\(R\\)中所有节点的度数都减少\\(1\\)……一直删除下去。由于总有\\(d_i\\ge i\\)，因此删除的总是右部节点。\r\n由于\\(n\\)是盈数，因此\\(\\displaystyle{|R|=\\sum_{d\\mid n} d&gt;\r\n2n=2|L|}\\)。\r\n最终证明了这个算法只要打破平等的策略不恰当，那么这个算法的近似比将会超过\\(2\\)。\r\n35.1-4\r\n假设当前的这棵树\\(T=(V,E)\\)的节点数超过\\(2\\)，否则\\(T\\)不会存在边。假设\\(L_T\\)是\\(T\\)的叶子节点，那么对于一个必定存在一个最小点覆盖\\(V&#39;\\)使得\\(V&#39;\\cap\r\nL_T=\\varnothing\\)，因为使用叶子节点\\(l\\)覆盖和\\(l\\)唯一关联的边\\((l,u)\\)，不如使用\\(l\\)的唯一邻居\\(u\\)关联这条边，此外\\(u\\)还有可能覆盖其它边，因此选择\\(l\\)不会比选择\\(u\\)更优。由此这给出了一个贪心算法TREE-VERTEX-COVER-GREEDY，它的基本思想是，取出森林中某个度数为\\(1\\)的节点\\(l\\)，并得到和\\(l\\)唯一关联的边\\((l,u)\\)，将\\(u\\)加入点覆盖中，并删去和\\(u\\)关联的所有边。由于每个节点和每条边最多只会遍历一次，因此其时间复杂度为\\(O(V+E)\\)。\r\nTREE-VERTEX-COVER-GREEDY(G)  V = G.V  E = G.E  L = ∅  let V&#x27; be a new list  for each vetrex v in V    // 点v目前的度数为1    if G.deg(v) == 1      L = L ∪ &#123;v&#125;  while |L| != ∅    select leaf l from L randomly    let (l, u) be the incident edge of l    L = L - &#123;l&#125;    V = V - &#123;u, l&#125;    INSERT(V&#x27;, u)    while an edge (u, v) in E such that incident to u      E = E - &#123;(u, v)&#125;      if G.deg(v) == 1        L = L ∪ &#123;v&#125;      else if G.deg(v) == 0        L = L - &#123;v&#125;        V = V - &#123;v&#125;  return V&#x27;\r\n上面的算法也很容易用贪心选择性质证明：假设\\(T\\)的一个最小点覆盖\\(V&#39;\\)满足\\(V&#39;\\cap L_T\\neq\r\n\\varnothing\\)，那么令\\(l\\in V&#39;\\cap\r\nL_T,(l,u)\\in E\\)，可见\\(l\\)覆盖了边\\((u,l)\\)。首先不可能有\\(u\\in\r\nV&#39;\\)，否则可以构造一个更优的最小点覆盖\\(V&#39;-\\{ l\\}\\)。因此，令\\(V&#39;&#39;=(V&#39;-\\{l\\})\\cup\\{\r\nu\\}\\)，那么集合\\(V&#39;&#39;\\)仍然覆盖了边\\((u,l)\\)，并且有\\(|V&#39;&#39;|=|V&#39;|\\)。因此这种贪心策略成立。\r\n35.1-5\r\n如果使用APPROX-VERTEX-COVER的修改版本求解最大团，那么这个算法对最大团问题不存在固定是近似比\\(\\rho\\)。\r\n假设现在有一个\\(n\\)个节点的图\\(G\\)，它存在一个大小为\\(k\\)的最小点覆盖，那么算法APPROX-VERTEX-COVER构造出的点覆盖至少为\\(2k\\)。\r\n对于图\\(G\\)的补图\\(\\overline{G}\\)，定理34.12证明了\\(\\overline{G}\\)存在一个大小为\\(n-k\\)的最大团，那么这个算法的改版能够找到\\(\\overline{G}\\)中大小至少为\\(n-2k\\)的团。因此这个求解最大团算法的近似值为\\(\\rho=\\dfrac{n-k}{n-\\min\\{n,2k\\}}\\)。当\\(k\\ge n/2\\)时，可见这个近似比值\\(\\rho\\)的定义是毫无意义的。因此这种关系并不意味着它对最大团问题存在固定的近似比。\r\n","categories":["算法导论"]},{"title":"算法导论34.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-34/exercises-2/","content":"\r\n34.2-1\r\n对于图\\(G_1=(V_1,E_1),G_2=(V_2,E_2)\\)是否是同构的这个判断性问题，其证据是存在一个函数\\(f:V_1\\rightarrow V_2\\)，并且\\(\\forall (u,v)\\in E_1\\)当且仅当\\((f(u),f(v))\\in E_2\\)。\r\n为了方便，验证该语言的算法由GRAPH-ISOMORPHISM-VERIFY给出，并且这个算法以非编码的形式表示。\r\nGRAPH-ISOMORPHISM-VERIFY(G1, G2, f)  E1 = G1.E  E2 = G2.E  for each edge (u, v) in E1    if (u, v) in E2      remove edge (u, v) in E2    else      return 0  if E2 == ∅    return 1  else    return 0\r\n可见，如果将\\(E_2\\)视为一个哈希表，那么GRAPH-ISOMORPHISM-VERIFY能够以\\(O(E_2)\\)的时间复杂度完成。因此它是一个多项式可验证的算法，因此GRAPH-ISOMORPHISM属于\\(\\text{NP}\\)。\r\n34.2-2\r\n如果图\\(G=(V,E)\\)是一个哈密顿图，那么\\(G\\)必定存在一个经过所有顶点的环\\(C\\)，其长度为\\(|V|\\)。如果\\(|V|\\)是奇数，那么这意味着\\(C\\)是一个奇环，这个环不可能出现在一个二分图中。因此，任何带有奇数个顶点的二分图都是非哈密顿图。\r\n34.2-3\r\n将HAM-CYCLE作为子程序，我们可以构造出一个算法GEN-HAM-CYCLE来列出一条哈密顿回路的边的集合。\r\nGEN-HAM-CYCLE(G)  EC = ∅  E = G.E  V = G.V  while E != ∅    select (u, v) from E randomly    E = E - &#123;(u, v)&#125;    if HAM-CYCLE((V, E ∪ EC)) == 0      EC = EC ∪ &#123;(u, v)&#125;  parse EC into a path P  return P\r\n这个算法的基本思想是，遍历\\(E\\)中的每一条边\\((u,v)\\)，并尝试删去，如果删去边\\((u,v)\\)后的图仍然是一个哈密顿图，那么就真实地删去它；否则保留下来，它将是某条哈密顿回路中的关键的一条边。\r\n因此如果HAM-CYCLE属于\\(P\\)，意味着HAM-CYCLE的时间复杂度为\\(O(V^k)\\)，其中\\(k\\)是一个正常数。在GEN-HAM-CYCLE中，它对HAM-CYCLE最多进行了\\(|E|=O(V^2)\\)次的调用，因此GEN-HAM-CYCLE的时间复杂度为\\(O(V^k)\\cdot\r\nO(V^2)=O(V^{k+2})\\)，即列出一条哈密顿回路中的所有顶点是多项式可解的。\r\n34.2-4\r\n假设现在存在两个程序\\(B_1,B_2\\)可以分别在多项式时间\\(O(n^{k_1}),O(n^{k_2})\\)内分别能够检测\\(y\\)是否为\\(x\\)属于\\(L_1,L_2\\)的证据。那么可以构造出如下程序用于语言\\(L_1\\cup L_2,L_1\\cap\r\nL_2,L_1L_2,\\overline{L_1},L_1^{\\ast}\\)：\r\n// 假设字符串的下标从1开始。B-UNION(B1, B2, x, y)  if B1(x, y) == 1 or B2(x, y) == 1    return 1  else    return 0  B-INTERSECTION(B1, B2, x, y)  if B1(x, y) == 1 and B2(x, y) == 1    return 1  else    return 0B-CONCATENATION(B1, B2, x, y)  // 考虑其中有一个为ε空字符串的情况。  if (B1(x, y) == 1 and B2(ε, y) == 1) or (B1(ε, y) == 1 and B2(x, y) == 1)    return 1  n = x.size()  for i = 1 to n - 1    if B1(x[1 : i], y) == 1 and B2(x[i + 1 : n], y) == 1      return 1  return 0B-KLEENE-STAR(B1, x, y)  n = x.size()  let f[0 : n] be a new array by 0  f[0] = 1  for i = 1 to n    for j = 1 to i      if f[j - 1] == 1 and B1(x[j : i], 1) == 1        f[i] = 1        break  return f[n]\r\n算法B-UNION和B-INTERSECTION分别调用了\\(1\\)次\\(B_1\\)和\\(B_2\\)，因此其时间复杂度均为\\(O(n^{\\max(k_1,k_2)})\\)。算法B-CONCATENATION对\\(B_1,B_2\\)分别至多调用了\\((n+1)\\)次，并且最大的规模为\\(n\\)，因此其时间复杂度为\\((n+1)\\cdot(O(n^{k_1})+O(n^{k_2}))=O(n^{\\max(k_1,k_2)+1})\\)。B-KLEENE-STAR算法对\\(B_1\\)进行了\\(\\dfrac{n(n+1)}{2}\\)次调用，最大的一次规模为\\(n\\)，因此其时间复杂度为\\(\\dfrac{n(n+1)}{2}\\cdot\r\nO(n^{k_1})=O(n^{k_1+2})\\)。综上所述，B-UNION, B-INTERSECTION, B-CONCBTENBTION, B-KLEENE-STAR可以在多项式时间内对各自的语言完成判定，因此语言\\(L_1\\cup L_2,L_1\\cap L_2,L_1L_2,L_1^{\\ast}\\in\r\n\\text{NP}\\)。\r\n然而，对于一个输入\\(x\\)和其证据\\(y\\)，如果\\(A_1(x,y)=0\\)，那么这并不意味着\\(x\\in\r\n\\overline{L_1}\\)，这仅仅说明这并不能证明\\(x\\in\r\nL_1\\)（也就是说，可能还会有其它证据\\(y&#39;\\)说明\\(x\\in L_1\\)）。\r\n34.2-5\r\n考虑现在存在某个算法\\(A\\)判断字符串\\(x\\)是否在某个语言\\(L\\)中，其中\\(L\\in\\text{NP}\\)。\r\n由于\\(L\\in\r\n\\text{NP}\\)，因此存在一个时间复杂度为\\(O(n^k)\\)的检验算法\\(B\\)，用于检验\\(y\\)是否为\\(x\\)属于\\(L\\)的证据。这意味着，算法\\(B\\)至多只能查看\\(O(n^k)\\)比特，因此\\(y\\)的长度至多为\\(O(n^k)\\)。\r\n那么算法\\(A\\)最多只能枚举\\(2^{O(n^k)}\\)个字符串进行检验，每次检验所需要花费的时间为\\(O(n^k)\\)，因此算法\\(A\\)的运行时间为\\(O(n^k)\\cdot2^{O(n^k)}=2^{O(n^k)}\\)。\r\n34.2-6\r\n给定一个图\\(G=(V,E)\\)和一条路径\\(P\\)，判断其是否为哈密顿通路是很简单的：只需要判断\\(V\\)中的节点是否在\\(P\\)中都出现且仅出现一次，并且相邻的两个节点的边都在\\(E\\)中即可，花费的时间为\\(O(V)\\)。也就是说，这是一个多项式时间内能够检验路径\\(P\\)是否为哈密顿通路的算法。因此，HAM-PATH属于\\(\\text{NP}\\)。\r\n34.2-7\r\n当一个有向无环图包含一条哈密顿通路，图\\(G\\)有且仅有一个拓扑序列。因此只需要对图\\(G\\)进行拓扑排序，并将这个拓扑序列视为是一条路径\\(P\\)，然后判断路径\\(P\\)是否为哈密顿通路即可。程序HAM-PATH-DAG给出了大致过程：\r\nHAM-PATH-DAG(G)  topologically sort the vertices of G and get the topologically sorted order P  if P is a hamiltonian path of G    return 1  else    return 0\r\n整个过程主要在于对图\\(G\\)进行拓扑排序，因此整个算法的时间复杂度为\\(O(V+E)\\)，它是多项式时间算法。\r\n34.2-8\r\n令语言\\(\\overline{L}\\)表示除了重言式以外，其它所有公式所组成的语言。\r\n考虑\\(\\overline{L}\\)的检验问题：给定一个布尔公式\\(x\\)和一组输入变量\\(y\\)，如果布尔公式的值为\\(0\\)，那么输出\\(1\\)，否则输出\\(0\\)。\r\n可见，只要给定了这个一个布尔公式和其输入，那么这个布尔公式的值可以以线性（即多项式时间）内计算出来。因此，\\(\\overline{L}\\in \\text{NP}\\)。\r\n最终得到语言TAUTOLOGY属于\\(\\text{co-NP}\\)。\r\n34.2-9\r\n对于任意\\(L\\in\r\nP\\)，按照题目34.1-6的结论，都有\\(\\overline{L}\\in P\\)。由于\\(P\\subseteq \\text{NP}\\)，因此\\(\\overline{L}\\in \\text{NP}\\)，最终得到\\(L\\in\\text{co-NP}\\)。\r\n34.2-10\r\n由于\\(\\text{NP}\\neq\r\n\\text{no-NP}\\)，因此存在语言\\(L\\in\r\n\\text{NP}-\\text{co-NP}\\)，因此有\\(L\\not\\in\r\n\\text{NP}-\\text{co-NP}\\)。按照题目34.2-9的结论，以及\\(P\\in\\text{NP}\\)，因此有\\(P\\subseteq\r\n\\text{NP}\\cap\\text{co-NP}\\)。也就是说\\(L\\not\\in P\\)。因此\\(P\\neq \\text{NP}\\)。\r\n34.2-11\r\n首先考虑树版本下的这个问题，并使用归纳法进行证明。\r\n假设当前的一棵树为\\(T=(V,E)\\)，那么为这棵树每对距离至多为\\(3\\)的节点对相连后，得到的图为\\(T_3=(V,E_3)\\)。\r\n对于一棵\\(3\\)个节点的树，原结论明显成立，因为此时\\(T_3\\)是\\(3\\)个节点的完全图，因此存在了一条哈密顿回路，原结论成立。\r\n接下来考虑一棵\\(n(n&gt;3)\\)个节点的树\\(T=(V,E)\\)。假设对于\\(k=3,4,\\dots,n-1\\)，所有\\(k\\)个节点的树中，每对距离至多为\\(3\\)的节点对相连后所得到的图，都存在一条哈密顿回路。考虑将\\(T\\)中的某个内部节点\\(w\\)删去，那么\\(T\\)将形成\\(k(k&gt;1)\\)个连通块。考虑对第\\(i\\)个连通块\\(T^{(i)}\\)构造一个点二元组\\((u_i,v_i)\\)：\r\n\r\n如果\\(T^{(i)}\\)只有\\(1\\)个节点\\(w_i\\)，那么令\\(u_i=v_i=w_i\\)。\r\n如果\\(T^{(i)}\\)有\\(2\\)个节点，考虑\\(T\\)中\\(T^{(i)}\\)和\\(w\\)相连的那个节点为\\(w_i\\)，令\\(u_i=w_i,v_i\\)为另一个节点。\r\n如果\\(T^{(i)}\\)有超过\\(3\\)个节点，考虑\\(T\\)中\\(T^{(i)}\\)和\\(w\\)相连的那个节点为\\(w_i\\)，令\\(u_i=w_i\\)。根据假设，\\(T_3^{(i)}\\)必定存在一个哈密顿回路\\(C^{(i)}\\)，那么令\\(v_i\\)为\\(w_i\\)在\\(C^{(i)}\\)中其中一个相邻的节点。\r\n\r\n那么接下来可以将这\\(k\\)个节点对串接起来，从而得到图\\(T_3\\)中一条长度为\\(n-1\\)的简单回路\\(C\\)（也就是说，\\(w\\)不在里面）。构造方式如下：对于\\(\\forall i\\in[1,k]\\)，如果第\\(i\\)个连通块具有超过\\(3\\)个节点，那么将\\(T_3^{(i)}\\)中指定的哈密顿回路断开边\\((u_i,v_i)\\)，从而得到一条起点为\\(u_i\\)，终点为\\(v_i\\)的哈密顿通路\\(P_i\\)，并且有\\(P_i\\subset C\\)。接下来对\\(\\forall i\\in[1,k-1]\\)，有\\((v_{i},u_{i+1})\\in P_i\\)，同时让\\((v_k,u_1)\\in C\\)（这是因为\\(\\delta(u_i,w)=1,\\delta(v_i,w)\\le\r\n2\\)，因此\\((v_i,u_{i+1}),(v_k,u_1)\\in\r\nE_3\\)）。\r\n由此那么我们成功构造出了长度为\\(n-1\\)的一条简单回路\\(C\\)。需要注意的是，由于剩下的节点数至少为\\(3\\)，因此\\(C\\)必定不包含重边。\r\n接下来将\\(w\\)加入\\(C\\)中，最终构造出一条哈密顿回路。方式如下：选择一条边\\((v_{i},u_{i+1})\\)去除，并加入边\\((u_i,w),(v_{i+1},w)\\)即可得到\\(C&#39;\\)，此时\\(C&#39;\\)为\\(T\\)的一条哈密顿回路，原结论成立。\r\n因此，树版本下的这道题目得到解决。接下来一般连通图下的版本：对于一般的连通图\\(G=(V,E&#39;)\\)，总存在一棵生成树\\(T=(V,E)\\)，使得\\(E\\subseteq E&#39;\\)。也就是说，对于图\\(G_3=(V,E_3&#39;)\\)，也有\\(E_3\\subseteq\r\nE_3&#39;\\)。按照上面的结论，构造出的环\\(C&#39;\\)是\\(T_3=(V,E_3)\\)的一条哈密顿路，因此\\(C&#39;\\)也是\\(G_3\\)的一条哈密顿回路，原结论成立。\r\n","categories":["算法导论"]},{"title":"算法导论35.4 Exercises 答案","url":"/introduction-to-algorithms/chapter-35/exercises-4/","content":"\r\n35.4-1\r\n如果第\\(i\\)个子句同时包含了一个变量及其否定形式，那么这个子句的值恒为\\(1\\)，因此\\(\\Pr\\{\\text{clause }i\\text{ is not\r\nsatisûed}\\}=1\\)；否则有\\(\\Pr\\{\\text{clause }i\\text{ is not\r\nsatisûed}\\}=7/8\\).\r\n因此计算随机变量\\(\\displaystyle{Y=\\sum_{i=1}^m\r\nY_i}\\)的期望，有\r\n\\(\\begin{aligned}\r\nE[Y]&amp;=E\\left[\\sum_{i=1}^m Y_i\\right]\\\\\r\n&amp;=\\sum_{i=1}^m E[Y_i]\\\\\r\n&amp;\\ge 7m/8\r\n\\end{aligned}\\)\r\n这意味着这个算法的近似比例的上界为\\(m/(7m/8)=8/7\\)，因此原结论成立。\r\n35.4-2\r\n这个算法和定理35.6时的一样，即以\\(1/2\\)的概率将每个变量设置成\\(1\\)，以\\(1/2\\)的概率将每个变量设置成\\(0\\)。\r\n证明过程和定理35.6的类似，令示性随机变量\\(Y_i\\)表示第\\(i\\)个子句被满足。考虑如下行为：\r\n\r\n如果第\\(i\\)个子句同时包含了一个变量及其否定形式，那么其必定是满足的，因此有\\(E[Y_i]=1\\)。\r\n否则，如果第\\(i\\)个子句包含了\\(k\\)个变量对应的文字，那么可见子句\\(Y_i\\)中所有文字的设置都是相互独立的。只有这\\(k\\)个文字的值都被设置成\\(0\\)时，才会导致第\\(k\\)个不满足。因此，\\(E[Y_i]=1-1/2^k\\)。\r\n\r\n需要注意的是，无论哪种情况，都有\\(E[Y_i]\\ge\r\n1/2\\)。计算随机变量\\(\\displaystyle{Y=\\sum_{i=1}^m\r\nY_i}\\)的期望，有\r\n\\(\\begin{aligned}\r\nE[Y]&amp;=E\\left[\\sum_{i=1}^m Y_i\\right]\\\\\r\n&amp;=\\sum_{i=1}^m E[Y_i]\\\\\r\n&amp;\\ge m/2\r\n\\end{aligned}\\)\r\n这意味着这个算法的近似比例的上界为\\(m/(m/2)=m\\)，因此原结论成立。\r\n35.4-3\r\n对于图\\(G=(V,E)\\)中的每条边\\(e\\in E\\)，定义示性随机变量\\(X_e\\)表示\\(e\\)中的两个顶点处在不同的集合中。\r\n由于\\(e=(u,v)\\)都是随机将两个顶点以\\(1/2\\)概率独立地分配到集合\\(S\\)或者是\\(V-S\\)中，因此有\\(\\Pr\\{e\\text{ belongs to a cut}\\}=\\Pr\\{u\\in S\\land\r\nv\\in V-S\\}+\\Pr\\{v\\in S\\land u\\in V-S\\}=1/2\\)。因此有\\(E[X_e]=1/2\\)。\r\n定义示性随机变量\\(X\\)表示这个割的权值\\(\\displaystyle{X=\\sum_{e\\in E}\r\nX_e}\\)的期望值\\(E[X]\\)，那么有\r\n\\(\\begin{aligned}\r\nE[X]&amp;=E\\left[\\sum_{e\\in E} X_e\\right]\\\\\r\n&amp;=\\sum_{e\\in E} E[X_e]\\\\\r\n&amp;=|E|/2\r\n\\end{aligned}\\)\r\n对于图\\(G=(V,E)\\)，它最佳的一个割\\((S,V-S)\\)也就只能取出\\(E\\)中的所有边。最终这个算法的近似比例的上界为\\(|E|/(|E|/2)=2\\)，因此原结论成立。\r\n35.4-4\r\n证明的思路是：对于一组可行解\\(\\overline{x}\\)，其中某些节点\\(v\\)满足\\(\\overline{x}(v)&gt;1\\)，那么我们可以构造一组新可行解\\(\\overline{x&#39;}\\)，使得\\(\\displaystyle{\\sum_{v\\in\r\nV}\\overline{x}(v)w(v)&gt;\\sum_{v\\in\r\nV}\\overline{x&#39;}(v)w(v)}\\)。\r\n接下来构造可行解\\(\\overline{x&#39;}\\)：\r\n\\(\\overline{x&#39;}(v)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;x(v) &amp; &amp; \\text{if}\\quad  x(v)\\le 1 \\\\\r\n  &amp;1 &amp; &amp; \\text{if}\\quad  x(v)&gt;1 \\\\\r\n\\end{aligned}\\right.\\)\r\n由于我们需要最小化\\(\\displaystyle{\\sum_{v\\in\r\nV}x(v)w(v)}\\)的值，通过比较这两个可行解的优劣性，有：\r\n\\(\\begin{aligned}\r\n\\sum_{v\\in V}\\overline{x&#39;}(v)w(v)-\\sum_{v\\in\r\nV}\\overline{x}(v)w(v)&amp;=\\sum_{v\\in\r\nV,x(v)&gt;1}(\\overline{x&#39;}(v)-\\overline{x}(v))w(v)\\\\\r\n&amp;&lt;0\r\n\\end{aligned}\\)\r\n因此\\(\\overline{x&#39;}\\)比\\(\\overline{x}\\)更优。\r\n接下来证明其它约束仍然成立。首先证明不等式35.18，可行解\\(\\overline{x&#39;}\\)只是将\\(\\overline{x}\\)中超过\\(1\\)的可行解修改成\\(1\\)，因此不等式35.18仍然成立。接下里证明不等式35.16。由于\\(\\overline{x&#39;}\\)仍然是非负数，因此\\(\\forall v\\in V\\)，如果\\(x(v)&gt;1\\)，有\\(\\overline{x}(v)=1\\)，那么对于\\(\\forall(u,v)\\in E\\)，仍然有\\(\\overline{x&#39;}(u)+\\overline{x}(v)\\ge\r\n1\\)，不等式35.16仍然成立。\r\n因此，构造出的\\(\\overline{x&#39;}\\)是一个满足不等式35.17的可行解，因此不等式35.17是多余的。\r\n","categories":["算法导论"]},{"title":"算法导论35.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-35/exercises-3/","content":"\r\n35.3-1\r\n下表将给出对单词列表{arid, dash, drain, heard, lost, nose, shun, slate, snare, thread}的模拟过程：\r\n\\(\\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}\\hline\r\ni&amp;U_i&amp;\\mathscr{C}&amp;\\mathtt{arid}&amp;\\mathtt{dash}&amp;\\mathtt{drain}&amp;\\mathtt{heard}&amp;\\mathtt{lost}&amp;\\mathtt{nose}&amp;\\mathtt{shun}&amp;\\mathtt{slate}&amp;\\mathtt{snare}&amp;\\mathtt{thread}\\\\\\hline\r\n0&amp;\\mathtt{adehilnorstu}&amp;\\{\\}&amp;\\mathtt{\\underline{arid}}&amp;\\mathtt{\\underline{\\mathtt{dash}}}&amp;\\mathtt{\\underline{drain}}&amp;\\mathtt{\\underline{heard}}&amp;\\mathtt{\\underline{lost}}&amp;\\mathtt{\\underline{nose}}&amp;\\mathtt{\\underline{shun}}&amp;\\mathtt{\\underline{slate}}&amp;\\mathtt{\\underline{snare}}&amp;\\mathtt{\\underline{thread}}\\\\\\hline\r\n1&amp;\\mathtt{ilnosu}&amp;\\{\\mathtt{thread}\\}&amp;\\mathtt{ar\\underline{i}d}&amp;\\mathtt{da\\underline{\\mathtt{s}}h}&amp;\\mathtt{dra\\underline{in}}&amp;\\mathtt{heard}&amp;\\mathtt{\\underline{los}t}&amp;\\mathtt{\\underline{nos}e}&amp;\\mathtt{\\underline{s}h\\underline{un}}&amp;\\mathtt{\\underline{sl}ate}&amp;\\mathtt{\\underline{sn}are}&amp;\\mathtt{thread}\\\\\\hline\r\n2&amp;\\mathtt{inu}&amp;\\{\\mathtt{thread,lost}\\}&amp;\\mathtt{ar\\underline{i}d}&amp;\\mathtt{dash}&amp;\\mathtt{dra\\underline{in}}&amp;\\mathtt{heard}&amp;\\mathtt{lost}&amp;\\mathtt{\\underline{n}ose}&amp;\\mathtt{sh\\underline{un}}&amp;\\mathtt{slate}&amp;\\mathtt{s\\underline{n}are}&amp;\\mathtt{thread}\\\\\\hline\r\n3&amp;\\mathtt{u}&amp;\\{\\mathtt{thread,lost,drain}\\}&amp;\\mathtt{arod}&amp;\\mathtt{dash}&amp;\\mathtt{drain}&amp;\\mathtt{heard}&amp;\\mathtt{lost}&amp;\\mathtt{nose}&amp;\\mathtt{sh\\underline{u}n}&amp;\\mathtt{slate}&amp;\\mathtt{snare}&amp;\\mathtt{thread}\\\\\\hline\r\n4&amp;&amp;\\{\\mathtt{thread,lost,drain,shun}\\}&amp;\\mathtt{arod}&amp;\\mathtt{dash}&amp;\\mathtt{drain}&amp;\\mathtt{heard}&amp;\\mathtt{lost}&amp;\\mathtt{nose}&amp;\\mathtt{shun}&amp;\\mathtt{slate}&amp;\\mathtt{snare}&amp;\\mathtt{thread}\\\\\\hline\r\n\\end{array}\\)\r\n因此，选择出来的集合\\(\\mathscr{C}=\\{\\mathtt{thread,lost,drain,shun}\\}\\)。\r\n35.3-2\r\n先将判定性集合覆盖问题定义成一种语言SET-COVER：\r\n\\[\\text{SET-COVER} = \\left\\{\\langle X,\r\n\\mathcal{F},k\\rangle : \\text{there exists a set }\\mathscr{C}\\subseteq\r\n\\mathcal{F}\\text{ such that }|\\mathscr{C}|\\le k\\text{ and\r\n}X=\\bigcup_{S\\in \\mathscr{C}} S\\right\\}\\]\r\n首先证明SET-COVER属于\\(\\text{NP}\\)。问题实例\\(\\langle X,\r\n\\mathcal{F},k\\rangle\\)的一个证据是一个集合\\(\\mathscr{C}\\)，检验程序只需要判断是否满足\\(\\mathscr{C}\\subseteq \\mathcal{F},|\\mathscr{C}|\\le\r\nk\\)以及\\(\\displaystyle{X=\\bigcup_{S\\in\r\n\\mathscr{C}}\r\nS}\\)。可见，这个验证程序可以在多项式时间内完成，因此SET-COVER属于\\(\\text{NP}\\)。\r\n接下来证明SET-COVER是NP困难的，考虑使用顶点覆盖问题进行规约，即证明\\(\\text{VERTEX-COVER}\\le_P\\text{SET-COVER}\\)。对于VERTEX-COVER问题中的任意一个实例\\(\\langle G,k\\rangle\\)，规约算法\\(F\\)构造出如下一个SET-COVER问题的实例\\(\\langle X,\r\n\\mathcal{F},k\\rangle\\)，使得\\(G\\)包含一个大小为\\(k\\)的点覆盖，当且仅当\\(X\\)关于集合族\\(\\mathcal{F}\\)包含一个大小为\\(k\\)的集合覆盖。\r\n规约过程是：令\\(X=E\\)。对于每个节点\\(v\\in V\\)，构造集合\\(S_v=\\{(w,v):w\\in V,(w,v)\\in\r\nE\\}\\)，并将集合\\(S_v\\)添加到\\(\\mathcal{F}\\)中。并且两个问题实例的\\(k\\)值相同。可见\\(\\langle X,\r\n\\mathcal{F},k\\rangle\\)三个参数都能够在多项式时间内构造出来，因此规约算法是多项式时间的。\r\n现在证明\\(G\\)包含一个大小为\\(k\\)的点覆盖，当且仅当\\(X\\)关于集合族\\(\\mathcal{F}\\)包含一个大小为\\(k\\)的集合覆盖。\r\n充分性：如果\\(G\\)包含一个大小为\\(k\\)的点覆盖\\(V&#39;\\)，也就是说，\\(\\forall (u,v)\\in E\\)，都有\\((u,v)\\)被某个点覆盖，不失一般性，假设这个点是\\(u\\)。那么\\(\\mathscr{C}\\)中就有一个集合\\(S_u\\)，它包含了边\\((u,v)\\)。由于\\(X=E\\)，因此\\(\\mathscr{C}\\)也是一个大小为\\(k\\)的集合覆盖。\r\n必要性：如果集合\\(X\\)包含一个大小为\\(k\\)的集合覆盖\\(\\mathscr{C}\\)，那么意味着\\(\\forall(u,v)\\in X\\)，必定存在一个集合\\(S_u\\)或者是\\(S_v\\)，其中一个在\\(\\mathscr{C}\\)中。不失一般性，假设\\(S_u\\)在\\(\\mathscr{C}\\)中，那么在图\\(G\\)中，边\\((u,v)\\)被点\\(u\\)覆盖。因此令\\(V&#39;=\\{v:S_v\\in\\mathscr{C}\\}\\)，那么\\(V&#39;\\)就是\\(G\\)的一个大小为\\(k\\)的点覆盖。\r\n因此\\(\\text{VERTEX-COVER}\\le_P\\text{SET-COVER}\\)。由于VERTEX-COVER是NP完全的，那么SET-COVER是NP困难的，也是NP完全的，原结论成立。\r\n35.3-3\r\n考虑对\\(X\\)中的每个元素和\\(\\mathcal{F}\\)中的所有集合\\(S\\)建立对应关系，并且将集合\\(S\\)放进第\\(|S|\\)个桶中。每次取出元素最多的集合\\(S&#39;\\)时，需要对于所有\\(x\\in S\\)，其它包含\\(x\\)的集合\\(T\\)都需要删去\\(x\\)，并且将它们放进前一个桶\\(|T|-1\\)中。更具体的过程由GREEDY-SET-COVER'给出。\r\n// INSERT-SET和DELETE-SET都是对哈希表进行增加和删除关键字操作。GREEDY-SET-COVER&#x27;(X, F)  M = max&#123;|S| : S ∈ F&#125;  let B[0 : M] be a new array by empty set  let D be a hash-table  for each S in F    INSERT-SET(B[|S|], S)    for each x in S      INSERT(D[x], S)  C = Ø  for i = M downto 1    while B[i] != Ø      select a set S from B[i] randomly and remove it      C = C ⋃ &#123;S&#125;      for each x in S        for each T in D[x]          if T != S            DELETE-SET(B[|T|], T)            T = T - &#123;x&#125;            INSERT-SET(B[|T|], T)  recover each set S in C  return C\r\n考虑GREEDY-SET-COVER'的运行时间，前7行都是为每个集合\\(S\\in\r\n\\mathcal{F}\\)和它们的所有元素都建立二元关系\\(x\\)，因此这一部分的运行时间为\\(\\displaystyle{O\\left(\\sum_{S\\in \\mathcal{F}}\r\n|S|\\right)}\\)。对于第9行的for循环，它只是从后往前遍历每个桶。第10行的while循环则是取出一个候选集合\\(S\\)并添加到\\(\\mathscr{C}\\)中。接下来枚举\\(S\\)中剩余的元素\\(x\\)，并在\\(\\mathcal{F}\\)中剩下的集合删去它们。可见，每个集合\\(S\\)只会被第11行代码最多选择一次，并且删去了其它集合中关于这个集合中的所有元素。因此每个元素\\(x\\)只会被第13行的for循环遍历一次。计算出集合\\(\\mathscr{C}\\)后，需要对它进行恢复。因此第8-20行代码的运行时间为\\(\\displaystyle{O\\left(\\sum_{S\\in \\mathcal{F}}\r\n|S|\\right)}\\)。\r\n因此，GREEDY-SET-COVER'的运行时间为\\(\\displaystyle{O\\left(\\sum_{S\\in \\mathcal{F}}\r\n|S|\\right)}\\)。\r\n35.3-4\r\n考虑GREEDY-SET-COVER的第5行代码，只要\\(U_i\\neq\r\n\\varnothing\\)，那么必定需要选出一个集合\\(S\\)，使得\\(U_i\\)中的元素减少（否则算法直接结束）。因此，对于从GREEDY-SET-COVER产生的覆盖\\(\\mathscr{C}\\)，有\\(|\\mathscr{C}|\\le |X|\\)。\r\n由于最优覆盖\\(|\\mathscr{C}^{\\ast}|\\)是\\(X\\)的最优覆盖，因此\\(X\\)中所有元素都出现在\\(\\mathscr{C^{\\ast}}\\)中的某些集合中，也就是\\(\\displaystyle{|X|\\le \\sum_{S\\in\r\n\\mathscr{C}^{\\ast}}|S|}\\)。那么有：\r\n\\(\\begin{aligned}\r\n|\\mathscr{C}|&amp;\\le |X|\\\\\r\n&amp;\\le \\sum_{S\\in \\mathscr{C}^{\\ast}}|S|\\\\\r\n&amp;\\le \\sum_{S\\in \\mathscr{C}^{\\ast}}\\max\\{|S|:S\\in\\mathcal{F}\\}\\\\\r\n&amp;=|\\mathscr{C}^{\\ast}|\\max\\{|S|:S\\in\\mathcal{F}\\}\r\n\\end{aligned}\\)\r\n因此原结论成立。\r\n35.3-5\r\n给出的算法BAD-SET-COVER-INSTANCE如下描述：\r\nBAD-SET-COVER-INSTANCE(n)  X = &#123;0, 1, 2, ..., n - 1&#125;  F = Ø  m = ⌊n / 3⌋  for i = 0 to m - 1    F = F ⋃ &#123;&#123;3 * i, 3 * i + 1&#125;, &#123;3 * i, 3 * i + 2&#125;, &#123;3 * i + 1, 3 * i + 2&#125;&#125;  if n % 3 == 1    F = F ⋃ &#123;&#123;n - 1&#125;&#125;  else if n % 3 == 2    F = F ⋃ &#123;&#123;n - 1, n - 2&#125;&#125;  return X, F\r\n对于任意形如\\(3i,3i+1,3i+2\\)的这\\(3\\)个元素，有且仅有\\(2\\)个集合覆盖这\\(3\\)个元素之一。对于这\\(3\\)个元素，有\\(3\\)种不同的选择集合方法能够覆盖到这\\(3\\)个元素。\r\n因此，构造出的这个问题实例一共有\\(3^{\\lfloor\r\nn/3\\rfloor}=O(3^{n/3})\\)种不同数量的最优解，它是\\(n\\)的指数。\r\n","categories":["算法导论"]},{"title":"算法导论35 Problems 答案","url":"/introduction-to-algorithms/chapter-35/problems/","content":"\r\n35-1\r\na\r\n首先先为这个问题构造出一个判定性问题：对于这组物体\\(T=\\{s_i\\}\\)，是否至多可以用\\(k\\)个大小为\\(1\\)的箱子，可以将这些物品全部装入其中。假设判定性问题的语言定义为BIN：\r\n\\[\\begin{aligned}\r\n\\text{BIN}=\\{\\langle T, k\\rangle:&amp;T\\text{ is a set of values in\r\n}(0,1),\\\\\r\n&amp;k \\ge 1\\text{ is an integer, and}\\\\\r\n&amp;\\text{all objects in $T$ can be place can be placed in $k$ or fewer\r\nbins.}\r\n\\end{aligned}\\]\r\n注意到BIN问题并没有限制每个箱子有多满。BIN问题的其中一个特殊问题EX-BIN，则要求了其中一个箱子恰好装满：\r\n\\[\\begin{aligned}\r\n\\text{EX-BIN}=\\{\\langle T, k\\rangle:&amp;T\\text{ is a set of values in\r\n}(0,1),\\\\\r\n&amp;k \\ge 1\\text{ is an integer, and}\\\\\r\n&amp;\\text{all objects in $T$ can be place can be placed in $k$ or fewer\r\nbins, at least one of them is exactly full.}\r\n\\end{aligned}\\]\r\n首先证明EX-BIN属于\\(\\text{NP}\\)。考虑某个问题实例\\(\\langle T,\r\nk\\rangle\\)，以及其某个证据，即一个装箱方案\\(P\\)，检验程序只需要检验\\(P\\)是否大小至多为\\(k\\)，并且对于\\(P\\)中的每个箱子，是否所有物品大小之和都不超过\\(1\\)即可。检验程序可以在多项式内完成检验，因此EX-BIN属于\\(\\text{NP}\\)。\r\n接下来证明EX-BIN是NP困难的，考虑使用子集和问题进行规约，即证明\\(\\text{SUBSET-SUM}\\le_P\\text{EX-BIN}\\)。对于SUBSET-SUM问题中的任意一个实例\\(\\langle S, t\\rangle\\)，规约算法\\(F\\)构造出如下一个EX-BIN问题的实例\\(\\langle T,k\\rangle\\)，使得\\(S\\)包含一个和为\\(t\\)的子集，当且仅当物品\\(T\\)可以装在\\(k\\)个箱子中，并且其中一个箱子恰好装满。\r\n规约过程是：令\\(T=\\{x/t:x\\in\r\nS\\},k=|S|\\)。可见构造出集合\\(S\\)所需要花费的时间是多项式的。\r\n现在证明\\(S\\)包含一个和为\\(t\\)的子集，当且仅当物品\\(T\\)可以装在\\(k\\)个箱子中，并且其中一个箱子恰好装满。\r\n充分性：如果\\(S\\)包含一个子集和为\\(t\\)的子集\\(S&#39;\\)，那么在\\(T\\)对应的子集\\(T&#39;=\\{x/t:s\\in\r\nS&#39;\\}\\)中，其和值为\\(1\\)。由于\\(k=|S|\\)，因此这意味着\\(S\\)中所有物品必定能够被装得下，因此\\(T&#39;\\)以及其它物品各自放在一个盒子中，是问题EX-BIN的一个解。\r\n必要性：可见这\\(|S|\\)个盒子必定能够装满这\\(|S|\\)个物品。如果存在一个子集\\(T&#39;\\subseteq\r\nT\\)，其中恰好能够装在一个盒子中，那么对\\(T&#39;\\)构建对应在\\(S\\)中的子集\\(T&#39;=\\{xt:x\\in T&#39;\\}\\)，那么\\(S&#39;\\)是\\(S\\)的一个和为\\(t\\)的子集。\r\n因此\\(\\text{SUBSET-SUM}\\le_P\\text{EX-BIN}\\)。由于SUBSET-SUM是NP完全的，那么EX-BIN是NP困难的，也是NP完全的。从而得知它的一般化问题BIN也是NP完全的，因此原问题是NP困难的。\r\nb\r\n由于所有物品总共的大小为\\(S\\)，然而每个箱子的大小为\\(1\\)，因此哪怕是最优的解法，都需要保证箱子的总大小不低于物品的总大小。因此\r\n最优解法至少需要\\(\\lceil S\\rceil\r\nS\\)个箱子。\r\nc\r\n将使用反证法来证明。不失一般性，假设某个时刻中存在两个箱子\\(B_1,B_2\\)，它们都是不到半满的。并且不失一般性，在这个时刻之前，假设在\\(B_1\\)放置最后一个物品时刻后，有一个新物品\\(s_i\\)放置到了\\(B_2\\)。由于放置\\(s_i\\)到\\(B_2\\)后，\\(B_2\\)仍然不到半满的，因此\\(s_i&lt; 0.5\\)。在放置\\(s_i\\)到\\(B_2\\)之前，由于\\(B_1\\)也尚未达到半满，因此按照首先适合的策略，\\(s_i\\)应该放在\\(B_1\\)而不是\\(B_2\\)。因此放置\\(s_i\\)到\\(B_2\\)违背了首先适合策略。因此原结论成立。\r\nd\r\n按照题目35-1-c的结论，由于至多一个箱子不是半满的，其余箱子都至少是半满的，因此哪怕除了最后一个箱子，其余箱子都至少需要装上大小之和为\\(0.5\\)的物品。因此这种首先适合策略最多只需要\\(\\lceil S/0.5\\rceil=\\lceil\r\n2S\\rceil\\)个箱子。\r\ne\r\n根据题目35-1-d可知首先适合算法所求出的解至多使用\\(\\lceil\r\n2S\\rceil\\)个箱子；并且根据题目35-1-b可知最优解至少使用\\(\\lceil\r\nS\\rceil\\)个箱子。因此首先适合算法的近似比至多为\\(\\lceil 2S\\rceil/\\lceil S\\rceil\\le2\\lceil\r\nS\\rceil/\\lceil S\\rceil=2\\)，即它是一个\\(2\\)近似比的算法。\r\nf\r\n装箱问题的首先适应算法由BIN-PACKING-FIRST-FIT给出。由于这个算法每次都是按顺序寻找第一个能够放置它的算法，因此其时间复杂度为\\(O(n^2)\\)。\r\nBIN-PACKING-FIRST-FIT(S, n)  let A be a new array by set  let sum be a new array by 0  for i = 1 to n    index = -1    for j = 1 to A.size      if sum[j] + S[i] &lt;= 1      sum[j] = sum[j] + S[i]      index = j      break    if index == -1      // 需要另开箱子      INSERT(A, Ø)      INSERT(sum, S[i])      index = A.size    A[index] = A[index] ⋃ &#123;S[i]&#125;  return A\r\n另外一种解法可以使用最小堆进行解决，每次选择现有的并且占用容量最小的箱子，装一个物品进去。如果装不下，那么再新开一个箱子。这个改编后的首先适应算法由BIN-PACKING-FIRST-FIT'给出，其时间复杂度为\\(O(n\\lg n)\\)。\r\nBIN-PACKING-FIRST-FIT&#x27;(S, n)  let A be a new array by set  let Q be a new array  // 堆中的每个节点包含两个属性key和id，其中key表示节点  for i = 1 to n    if Q.qize == 0 or MIN-HEAP-MINIMUN(Q).key + S[i] &gt; 1      INSERT(A, Ø)      let z be a new node      z.id = A.size      z.key = S[i]      MIN-HEAP-INSERT(A, z, n)      index = z.id    else      z = MIN-HEAP-EXTRACT-MIN(Q)      z.key = z.key + S[i]      index = z.id      MIN-HEAP-INSERT(A, z, n)    A[index] = A[index] ⋃ &#123;S[i]&#125;  return A\r\n35-2\r\na\r\n假设\\(G\\)中有一个大小为\\(m\\)的最大团\\(C\\)，令\\(C^{(k)}\\)表示\\(C\\)中顶点的所有有序\\(k\\)元组的构成的集合，可以知道\\(C^{(k)}\\subseteq V^k\\)，并且\\(C^{(k)}\\)是\\(G^{(k)}\\)的一个最大团，其大小为\\(m^k\\)。因为对于任意\\(u^{(k)},v^\\in C^{(k)},\\forall\r\ni\\in[1,k]\\)，都有\\((u_i^{(k)},v_i^{(k)})\\in E\\)，所以\\((u^{(k)},v^)\\in\r\nE^{(k)}\\)。故\\(C^{(k)}\\)是\\(G^{(k)}\\)中一个大小为\\(m^k\\)的团。\r\n接下来证明\\(G^{(k)}\\)中最大团的大小为\\(m^k\\)，使用归纳法来证明。\r\n当\\(k=1\\)时，\\(V^{(1)}=V,E^{(1)}=E\\)，那么\\(G^{(1)}=G\\)，因此\\(G^{(1)}\\)的最大团大小为\\(m\\)。\r\n当\\(k&gt;1\\)时，假设图\\(G^{(k-1)}\\)的最大团大小为\\(m^{k-1}\\)。令\\(u&#39;^{(k)}\\in V^{(k-1)}\\)是节点\\(u^{(k)}\\)的前\\(k-1\\)个元素所构成的节点，如果\\((u^{(k)},v^{(k)})\\in E^{(k)}\\)，那么\\((u&#39;^{(k)},v&#39;^{(k)})\\in\r\nE^{(k-1)}\\)。假设\\(G^{(k)}\\)存在一个团\\(C^{(k)}\\)，其大小为\\(c\\)，满足\\(c&gt;m^k\\)，那么令\\(C&#39;=\\{u&#39;^{(k)}\\mid u^{(k)}\\in\r\nC^{(k)}\\}\\)，可见\\(C&#39;\\)是图\\(G^{(k-1)}\\)中的一个团，按照假设，\\(|C&#39;|\\le m^{k-1}&lt;c/m\\)。由于\\(C&#39;\\)中的任意一个节点都是由\\(C\\)中的每个节点的前\\(k-1\\)个元素得来，因此\\(C\\)中的所有节点的第\\(k\\)个元素必须有超过\\(m\\)种不同的选择才能使\\(C&#39;\\)的大小超过\\(m^{k}\\)。如果是这样，那么按照\\(G^{(k)}\\)的定义，意味着\\(G\\)有一个大小超过\\(m\\)的团，这和最大团大小为\\(m\\)矛盾，因此原结论成立。\r\nb\r\n假设现在存在一个近似比为常数\\(\\rho\\)的算法\\(A\\)用于找出一个图的团，令图\\(G=(V,E)\\)，假设其最大团的大小为\\(m\\)。按照整数\\(k\\)构造出图\\(G^{(k)}\\)后，通过对图\\(G^{(k)}\\)使用算法\\(A\\)，可以找到一个大小为\\(n\\)的团，并满足\\(m^k/n\\le c\\)。那么这将在图\\(G\\)中可以找到一个大小为\\(n^{1/k}\\)的团，其中满足\\(m/c^{1/k}\\le\r\nn^{1/k}\\)。对于给定的一个近似参数\\(\\epsilon\\)，令\\(k=1/\\log_c (1+\\epsilon)\\)，那么算法\\(A\\)就能找到图\\(G\\)一个接近\\(\\dfrac{m}{1+\\epsilon}\\)的团，这也符合了近似参数\\(\\epsilon\\)越低，找到的团越大的直觉。\r\n接下来证明\\(k\\)是\\(1/\\epsilon\\)的一个多项式。可以知道：\r\n\\(\\begin{aligned}\r\nk&amp;=1/\\log_c(1+\\epsilon)\\\\\r\n&amp;=\\dfrac{\\ln c}{\\ln 1+\\epsilon}\\\\\r\n&amp;\\ge \\dfrac{\\ln c}{\\epsilon}\r\n\\end{aligned}\\)\r\n因此，对图\\(G^{(k)}\\)，其中\\(k=1/\\log_c(1+\\epsilon)\\)使用算法\\(A\\)求取最大团，从而构建出图\\(G\\)的一个团\\(C\\)的算法\\(A&#39;\\)是一个\\(1+\\epsilon\\)近似的算法。由于这个近似模式是输入规模的多项式，也是一个\\(1/\\epsilon\\)的多项式，因此这是一个完全多项式时间近似模式。\r\n35-3\r\n一个贪心的带权集合覆盖启发式算法是：每次选择单位费用下能够加入尽量多元素到\\(U\\)中的集合。更具体的，这个算法的伪代码由GREEDY-SET-COVER-WEIGHTED给出。\r\nGREEDY-SET-COVER-WEIGHTED(X, F, w)  U_0 = X  C = Ø  i = 0  while U_i != Ø    select select S ∈ F that maximizes |S ∩ U_i| / w(S)    U_&#123;i + 1&#125; = U_i - S    C = C ⋃ &#123;S&#125;    i = i + 1  return C\r\n接下来证明这个算法具有近似比\\(H(d)\\)，其中\\(d=\\max\\{|S|:S\\in\r\n\\mathcal{F}\\}\\)。证明过程参考了这篇文章\r\n令\\(c_x\\)表示分配给元素\\(x\\)的代价。每一个元素\\(x\\)在第一次被某个集合\\(S_i\\)覆盖时，才会被分配代价，其分配的代价为\r\n\\[c_x=\\dfrac{w_i}{|S_i-(S_1\\cup\r\nS_2\\cup\\dots \\cup S_{i-1})|}\\]\r\n直观上，这个代价比例就是为了使用集合\\(S_i\\)覆盖\\(S_i-(S_1\\cup S_2\\cup\\dots \\cup\r\nS_{i-1})\\)中的每个元素时所均摊的代价。\r\n令\\(\\mathscr{C}\\)是一个由GREEDY-SET-COVER-WEIGHTED产生的带权集合覆盖，\\(\\mathscr{C}^{\\ast}\\)是一个带权最优集合覆盖。\r\n按照代价等价的定义，有\r\n\\[\\sum_{S_i\\in \\mathscr{C}}w_i=\\sum_{x\\in\r\nX}c_x\\]\r\n考虑任意在\\(\\mathscr{C}^{\\ast}\\)中选中的一个集合\\(S_i=\\{x_k,x_{k-1},\\dots,x_1\\}\\)。不失一般性，假设这个贪心算法按照\\(x_k,x_{k-1},\\dots,x_1\\)的顺序依次覆盖这些元素。在这个算法从\\(x_j\\)开始覆盖\\(S_i\\)的元素时，\\(S_i\\)中至少仍然有\\(j\\)个元素仍然未被覆盖。因此，如果贪心算法在某个迭代时刻选择了集合\\(S_i\\)，那么对于\\(\\forall p\\in[1,k],c_{x_p}\\le\r\nw_i/j\\)，即贪心算法将会最多会为每个元素支付\\(w_i/j\\)的代价用于覆盖\\(S_i\\)中剩余的元素。这意味着元素\\(x_j\\)被使用了\\(w_i/j\\)代价进行覆盖。由于\\(j\\)的取值从\\(1\\)至多为\\(d\\)，因此计算\\(\\displaystyle{H(d)=\\sum_{i=1}^d\\dfrac{1}{i}}\\)，以求覆盖到任何情况。\r\n因此一个贪心算法的权值之和最多为\\(\\displaystyle{\\sum_{S_i\\in\r\n\\mathscr{C}^{\\ast}}w_iH(d)=H(d)\\cdot{\\sum_{S_i\\in\r\n\\mathscr{C}^{\\ast}}w_i}}\\)，因此它是一个\\(H(d)\\)近似的算法。\r\n35-4\r\na\r\n考虑图\\(G=(V,E),V=\\{a,b,c,d\\},E=\\{(a,b),(c,d),(b,c)\\}\\)。那么其中一个极大匹配是\\(\\{(b,c)\\}\\)，但它不是一个最大匹配（最大匹配是\\(\\{(a,b),(c,d)\\}\\)）。\r\nb\r\n只需要将算法APPROX-VERTEX-COVER修改成以边返回即可。题目35.1-2证明了这个算法生成的边集是一个极大匹配。修改后的算法由程序MAXIMAL-MATCHING给出。\r\nMAXIMAL-MATCHING(G)  M = Ø  E&#x27; = G.E  while E&#x27; ≠ Ø    let (u, v) be an arbitrary edge of E&#x27;    M = M ∪ &#123;(u, v)&#125;    remove from E&#x27; edge (u, v) and every edge incident on either u or  return M\r\nc\r\n由于\\(G\\)中的一组匹配\\(|M|\\)，任意两条边都不和同一顶点关联。因此至少需要\\(|M|\\)个节点才能覆盖这\\(|M|\\)条边，故\\(G\\)的一个最大匹配的规模是\\(G\\)中任何顶点覆盖规模的下界。\r\nd\r\n这意味着这个图只有一些孤立节点，没有边。如果仍然存在一条边\\((u,v)\\)，那么说明匹配\\(M\\)不是一个极大匹配，可以把\\((u,v)\\)加入到\\(M\\)中。\r\ne\r\n根据题目35-4-d的结论，一组极大匹配中的所有节点\\(T\\)，关联了\\(G=(V,E)\\)中的所有边。因此\\(T\\)是一个大小为\\(|T|=2|M|\\)的点覆盖。\r\nf\r\n令\\(|M^{\\ast}|\\)是一组最大匹配，令\\(|C^{\\ast}|\\)是一组最小点覆盖。那么根据题目34-4-c的结论，有\\(|C^{\\ast}|\\ge |M^{\\ast}|\\)。\r\n根据题目35-4-e的结论，\\(T\\)是\\(G\\)中的一个点覆盖，因此\\(|T|\\ge |C^{\\ast}|\\)。\r\n由于\\(|T|=2|M|\\)，因此有\\(2|M|\\ge\r\n|M^{\\ast}|\\)，因此算法MAXIMAL-MATCHING是一个近似比为\\(2\\)的最大匹配算法。\r\n35-5\r\na\r\n由于这些调度是非抢占式的，并且一台机器完整地运行任务\\(J_i\\)需要花费\\(p_i\\)的时间。因此一个任务\\(J_i\\)的结束时间至少为\\(p_i\\)，即\\(C_i\\ge\r\np_i\\)。\r\n由于\\(\\displaystyle{C_{\\max}=\\max_{k=1}^m\r\nC_k}\\)，因此有\\(\\displaystyle{C_{\\max}^{\\ast}\\ge \\max_{k=1}^m\r\np_k}\\)。\r\nb\r\n使用反证法证明。如果\\(\\displaystyle{C_{\\max}&lt;\\dfrac{1}{m}\\sum_{k=1}^m\r\np_k}\\)，那么意味着\\(\\displaystyle{m\\cdot C_{\\max}&lt;\\sum_{k=1}^m\r\np_k}\\)。也就是说，哪怕每台机器都使用\\(C_{\\max}\\)的时间进行处理，都无法完成处理所有任务（因为每个任务在每台机器上需要执行的单位时间为\\(1\\)），因此这是不可能的，最终原结论成立。\r\nc\r\n考虑使用一个最小堆进行实现。堆中的每一个节点\\(x\\)有两个属性\\(id\\)和\\(key\\)，分别表示机器编号和当前机器完成当前任务的最后时间。每次取出堆顶的机器\\(m\\)（因为它是所有机器中，当前最早结束的），然后选择一个任务\\(J_i\\)，并赋予给机器\\(m\\)，那么将\\(m\\)对应的节点的关键字加上\\(p_i\\)后，重新加入最小堆中。\r\n具体过程由PARALLEL-TASKS-ASSIGNED给出。由于进行了\\(O(n+m)\\)次堆操作，并且堆的大小至多为\\(O(m)\\)，因此总时间复杂度为\\(O((n+m)\\log m)\\)。\r\nPARALLEL-TASKS-ASSIGNED(J, n, m)  let Q[1 : m] be a new array  let L[1 : m] be a new array by empty array  for i = 1 to m    let Q[i] be a new node    Q[i].id = i    Q[i].key = 0  BUILD-MIN-HEAP(Q, m)  for i = 1 to n    x = MIN-HEAP-EXTRACT-MIN(Q)    INSERT(L[x.id], J_i)    x = x.key + p_i    MIN-HEAP-INSERT(Q, x, m)  return L\r\nd\r\n定理26.1证明了这个问题的更一般的结论（因为这里任务间是不构成依赖的，定理26.1任务间可能会构成依赖）。\r\n因此，根据题目35-5-a和35-5-b的结论，最终有\r\n\\(\\begin{aligned}\r\nC_{\\max}&amp;\\le \\dfrac{1}{m}\\sum_{k=1}^n p_k+\\max\\{p_k:1\\le k\\le n\\}\\\\\r\n&amp;\\le\\max\\left\\{\\dfrac{1}{m}\\sum_{k=1}^n p_k,\\max\\{p_k:1\\le k\\le\r\nn\\}\\right\\}+\\max\\left\\{\\dfrac{1}{m}\\sum_{k=1}^n p_k,\\max\\{p_k:1\\le k\\le\r\nn\\}\\right\\}\\\\\r\n&amp;=2\\cdot \\max\\left\\{\\dfrac{1}{m}\\sum_{k=1}^n p_k,\\max\\{p_k:1\\le k\\le\r\nn\\}\\right\\}\\\\\r\n&amp;=2\\cdot C_{\\max}^{\\ast}\r\n\\end{aligned}\\)\r\n因此这个贪心调度算法是\\(2\\)近似的。\r\n35-6\r\na\r\n令图\\(G=(V,E),V=\\{a,b,c,d\\},E=\\{(a,b),(b,c),(c,d)\\},w(a,b)=1,w(b,c)=2,w(c,d)=3\\)。那么对于这个边权，有\\(S_G=E=T_G\\)。图\\(G\\)和权值函数\\(w\\)为题目所求。\r\nb\r\n令图\\(G=(V,E),V=\\{a,b,c,d\\},E=\\{(a,b),(b,c),(c,d)\\},w(a,b)=2,w(b,c)=1,w(c,d)=3\\)。那么对于这个边权，有\\(S_G=\\{(a,b),(c,d)\\}\\)；然而\\(T_G=E\\)，因此有\\(S_G\\neq T_G\\)。图\\(G\\)和权值函数\\(w\\)为题目所求。\r\nc\r\n使用反正法进行证明。假设\\(G=(V,E)\\)存在一棵最大生成树的边集\\(T_G\\)以及一条边\\((u,v)\\in S_G\\)，并且\\((u,v)\\not\\in T_G\\)。\r\n不失一般性，假设\\(\\max(u)=(u,v)\\)，考虑\\(T_G\\)上的一条从\\(u\\)到\\(v\\)的路径，令\\(x\\)是这条路径上和\\(w\\)相邻的那个节点（也就是这条路径的第二个节点。由于每条边都有不同边权，并且\\(\\max(u)=(u,v)\\)，因此有\\(w(u,x)&lt;w(u,v)\\)。从\\(T_G\\)去除这条边后，整棵树就变成了两棵森林，再连上边\\((u,v)\\)后，又成为了一棵新树。因此，令\\(T_G&#39;=(T_G-\\{(u,w)\\})\\cup\r\n\\{(u,v)\\}\\)，可见\\(w(T_G&#39;)&gt;w(T_G)\\)，由此构造出了一棵更优的生成树，这和\\(T_G\\)是最大生成树是矛盾的。因此原结论成立。\r\nd\r\n可见，由于\\(V\\)中的所有节点在边集\\(S_G\\)中都有边关联着，因此有\\(|S_G|\\ge |V|/2\\)，也就是有\\(|T_G-S_G|&lt;|V|/2\\)。\r\n按照题目35-6-c的结论，我们可以从森林\\(S_G\\)构造出一棵最大生成树。接下来证明，对于所有边\\(T_G-S_G\\)，在\\(S_G\\)中存在一组边的子集\\(S_G&#39;\\subseteq S_G\\)，且\\(|S_G&#39;|=|T_G-S_G|\\)，在\\(T_G-S_G\\)中的每一条边\\(e\\)都和\\(S_G&#39;\\)中的一条边\\(e&#39;\\)对应，并且有\\(w(e)\\le w(e&#39;)\\)。\r\n可见，为了连接森林\\(S_G\\)中的任意连通块，需要从\\(E\\)中寻找边进行连接。可见，在整个迭代过程中，每个森林的连通块中都会有一条\\(S_G\\)中的边\\(e&#39;\\)仍未被对应。当每次从\\(E\\)中加入一条边\\(e\\)连通两个块时，总存在一条从\\(e\\)到\\(e&#39;\\)的“增广路径”（这条路径中，\\(S_G\\)的边和非\\(S_G\\)中的边交叉出现），使得对应关系改变。因此这组对应关系总是存在的。因此得到\\(w(S_G&#39;)\\ge w(T_G-S_G)\\)。\r\n也就是说，\\(w(S_G)\\ge w(S_G&#39;)\\ge\r\nw(T_G-S_G)=w(T_G)-w(S_G)\\)，因此有\\(w(S_G)\\ge w(T_G)/2\\)，原结论成立。\r\ne\r\n这个贪心算法首先求出\\(S_G\\)中的所有边，然后再寻找\\(|V|-1-|S_G|\\)中条边，构建出一棵近似最大生成树。按照题目35-6-c的结论，这棵最大生成树\\(T_G&#39;\\)的权值满足\\(w(T_G&#39;)\\ge w(S_G)\\)。也就是有\\(w(T_G&#39;)\\ge\r\nw(T_G)/2\\)，因此这是一个\\(2\\)近似算法。\r\n具体过程由APPROX-MAX-SPANNING-TREE给出，其内部使用了并查集进行实现。这个算法时间复杂度为\\(O(V+E)\\)。\r\nAPPROX-MAX-SPANNING-TREE(G, w)  SG = Ø  for each vertex u in G.V    v = NIL    max = -∞    for each vertex x in G.Adj[u]      if w(u, x) &gt; max        max = w(u, x)        v = x    SG = SG ∪ &#123;(u, v)&#125;  TG = SG  for each vertex u in G.V    MAKE-SET(u)  for each edge (u, v) in TG    UNION(u, v)  for each vertex u in G.V    for each vertex v in G.Adj[u]      if FIND-SET(u) != FIND-SET(V)        TG = TG ∪ &#123;(u, v)&#125;        UNION(u, v)  return TG \r\n35-7\r\na\r\n对于问题实例\\(I_j\\)，其0-1背包问题的解的选择方式（包括超出背包容量的解）一共有\\(2^{n-j}\\)个（即物品\\(j+1,j+2,\\dots,n\\)可以自由选择是否存放在背包中）。对于问题实例\\(I_k(k&gt;0)\\)，任意一个0-1背包问题的解选择方式都必定和\\(I_j\\)的解选择方式必定不一样，因为\\(I_k\\)要求选择物品\\(k\\)，\\(I_j\\)要求不选择物品\\(k\\)。因此，问题实例\\(I_1,I_2,\\dots,I_n\\)一共包含了\\(2^{n-1}+2^{n-2}+\\dots+2^{0}=2^n-1\\)个不同的解选择方式，它们的最优解分别由\\(P_1,P_2,\\dots,P_n\\)代表。这\\(2^n-1\\)个解选择方式对应了原本问题实例\\(I\\)的解选择方式。\r\n因此，问题\\(I\\)的0-1背包最优解必定是\\(P_1,P_2,\\dots,P_n\\)之一。\r\nb\r\n问题实例\\(I_j\\)要求强制装入物品\\(j\\)装入背包中，那么接下来就是将物品\\(\\{j+1,j+2,\\dots,n\\}\\)选择装入一个大小为\\(W-w_i\\)背包中。对于这个分数背包问题实例，题目15.2-1证明了这种选择策略的贪心选择性质，从而完成了本题的证明。\r\nc\r\n按照题目35-7-b的思想，可以先按照\\(v_i/w_i\\)将每个物品进行排序。由于是尽量取价值较大的物品，因此只需要尽量地完整取一个价值最大物品即可。因此一直迭代下来，如果能够完整地取完一个大价值的物品，那么就继续往下取；否则只尽量取完这个物品的一部分后，算法终止。因此，最多只有一个物品会被部分装进背包。\r\nd\r\n对于任意0-1背包问题的解，它都是分数背包中的一个解。也就是说，对于同一问题实例下，0-1背包的解空间是分数背包解空间的子集，从0-1背包问题放松限制而来的分数背包问题将会存在更优的解，因此有\\(v(Q_j)\\ge v(P_j)\\)。\r\n接下来证明\\(v(R_j)\\ge\r\nv(Q_j)/2\\)。对于问题实例\\(I_j\\)，由于物品\\(j\\)必须完整地放进这个背包，因此这个背包必定包含了价值\\(v_j\\)。由于对于其他\\(i&gt;j\\)的物品而言，都有\\(v_j\\ge\r\nv_i\\)，并且根据题目37-7-c的结论，所移除的被放进背包的物品必定是\\(J_i\\)中的某一部分。因此，移除的这一部分价值必定不会超过\\(v_j\\)。由于\\(R_j\\)相比\\(Q_j\\)而言，仅仅是移除了被部分装入的那个物品\\(i\\)，因此有\\(v(R_j)\\ge V(Q_j)/2\\)。\r\n最终证明得到\\(V(R_j)\\ge v(Q_j)/2\\ge\r\nv(P_j)/2\\)，\r\ne\r\n首先依次求解每个问题实例\\(I_j\\)的0-1背包近似解\\(Q_j\\)，然后在这\\(n\\)个近似解中选取最优的一个即可。\r\n具体过程由APPROX-0-1-KNAPSACK-PROBLEM给出，可见这是一个\\(O(n^2\\log\r\nn)\\)的简单实现，它是多项式的。\r\n// 数组J中的每个元素J[i]都含有两个属性w和v，分别表示物品的重量和价值。FRACTIONAL-KNAPSACK-PROBLEM-DELETE-FRACTIONAL-ITEM(J, n, W)  sort J in descending order by J[i].v / J[i].s  p = n  sum = 0  for i = 1 to n    sum += J[i].s    if sum &gt; W      p = i - 1      break  return J[1 : m]APPROX-0-1-KNAPSACK-PROBLEM(J, n, W)  sort J in ascending order by J[i].s  let now be a new array  for i = n down to 1    sol = FRACTIONAL-KNAPSACK-PROBLEM-DELETE-FRACTIONAL-ITEM(J[i + 1: n], n - i, W - J[i].s)    INSERT(sol, J[i])    if sol is better then now      now = sol  return sol\r\n接下来分析这个算法的近似比例。在每一次迭代中，都求出了问题实例\\(I_j\\)的0-1背包问题的一个近似解\\(Q_i\\)。按照题目37-7-d的结论，这是一个近似比例为\\(2\\)的解。根据题目37-7-a的结论，问题实例\\(I\\)的0-1背包问题的最优解\\(P\\)必定是某个解\\(P_j\\)，那么意味着\\(Q_j\\)也是问题实例\\(I\\)的0-1背包问题的一个近似比为\\(2\\)的解。因此算法APPROX-0-1-KNAPSACK-PROBLEM是一个0-1背包问题近似比为\\(2\\)的多项式时间算法。\r\n","categories":["算法导论"]},{"title":"算法导论4.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-4/exercises-3/","content":"\r\n4.3-1\r\na\r\n假设\\(T(n)\\le cn^2\\)，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=T(n-1)+n\\\\\r\n&amp;\\le c(n-1)^2+n\\\\\r\n&amp;\\le c(n^2-n+1)\\\\\r\n&amp;\\le cn^2\r\n\\end{aligned}\\)\r\n令\\(c=\\max(1,T(1)),n_0=1\\)。由于\\(T(1)\\le c\\le\r\ncn^2\\)，那么由数学归纳法，原结论\\(T(n)=O(n^2)\\)成立。\r\nb\r\n假设\\(T(n)\\le c\\lg\r\n(n-d)\\)，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=T(n/2)+\\Theta(1)\\\\\r\n&amp;\\le c\\lg (n / 2 - d)+\\Theta(1)\\\\\r\n&amp;=c\\lg (n / 2 - d) + c - c+\\Theta(1)\\\\\r\n&amp;=c(\\lg (n / 2 - d) + 1) - c+\\Theta(1)\\\\\r\n&amp;=c\\lg (n - 2d) - c+\\Theta(1)\\\\\r\n&amp;=c\\lg (n - 2d)  &amp; \\qquad(A)\\\\\r\n&amp;\\le c\\lg (n-d) &amp; \\qquad (B)\r\n\\end{aligned}\\)\r\n其中，步骤\\((A)\\)假设\\(c\\)充分大，大于\\(\\Theta(1)\\)的上界时，那么\\((A)\\)步骤就成立。步骤\\((B)\\)假设\\(d&gt;0\\)。\r\n如果\\(n_0=2\\)，那么\\(c\\)的值仍需比\\(T(2),T(3)\\)大。由数学归纳法，原结论\\(T(n)=O(\\lg n)\\)成立。\r\nc\r\n假设\\(T(n)\\le cn\\lg n\\)，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=2T(n/2)+n\\\\\r\n&amp;\\le 2c(n/2)\\lg (n/2) + n\\\\\r\n&amp;=cn\\lg (n/2) + n\\\\\r\n&amp;=cn\\lg n - cn + n\\\\\r\n&amp;=cn\\lg n-(c-1) n\\\\\r\n&amp;\\le cn\\lg n\r\n\\end{aligned}\\)\r\n假设\\(n_0=2\\)，那么令\\(c=\\max\\{1,T(2)/2,T(3)/(3\\lg\r\n3)\\}\\)，由数学归纳法，\\(T(n)=O(n\\lg\r\nn)\\)成立。\r\n假设\\(T(n)\\ge c&#39;n\\lg\r\nn\\)，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=2T(n/2)+n\\\\\r\n&amp;\\ge 2c&#39;(n/2)\\lg (n/2) + n\\\\\r\n&amp;=c&#39;n\\lg (n/2) + n\\\\\r\n&amp;=c&#39;n\\lg n - c&#39;n + n\\\\\r\n&amp;=c&#39;n\\lg n-(c&#39;-1) n\\\\\r\n&amp;\\ge c&#39;n\\lg n\r\n\\end{aligned}\\)\r\n假设\\(n_0=2\\)，那么令\\(c=\\min\\{1,T(2)/2,T(3)/(3\\lg\r\n3)\\}\\)。由数学归纳法，\\(T(n)=\\Omega(n\\lg n)\\)成立。\r\n因此，\\(T(n)=\\Theta(n\\lg n)\\)。\r\nd\r\n可以发现，当\\(n/2+17\\le\r\n2n/3\\)时，即有\\(n\\ge102\\)，因此，我们假设\\(n\\ge 102\\)。假设\\(T(n)\\le cn\\lg n-d-en-f\\lg n\\)，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=2T(n/2+17)+n\\\\\r\n&amp;=2c(n/2+17) \\lg(n/2+17)-2d-2en-2f\\lg n+n\\\\\r\n&amp;=c(n+34) \\lg(n/2+17)-2d-2en-2f\\lg n+n\\\\\r\n&amp;=cn\\lg(n/2+17)+34c\\lg(n/2+17) -2d-2en-2f\\lg n+n\\\\\r\n&amp;\\le cn\\lg(3n/4)+34c\\lg(3n/4) -2d-2en-2f\\lg n+n\\\\\r\n&amp;=cn\\lg n+cn\\lg(3/4) + 34 c\\lg n+34c\\lg(3/4)-2d-2en-2f\\lg n+n\\\\\r\n&amp;=cn\\lg n-(2e-(c\\lg(3/4)+1)) n-(2f-c\\lg(3/4))\\lg\r\nn-(2d-34c\\lg(3/4))\\\\\r\n&amp;\\le cn\\lg n-d-en-f\\lg n &amp;\\qquad(A)\r\n\\end{aligned}\\)\r\n其中，步骤\\((A)\\)假设了\\(2e-(c\\lg(3/4)+1)\\ge e,2f-c\\lg(3/4)\\ge\r\nf,2d-34c\\lg(3/4)\\ge d\\)。\r\n因此，只需要确定好\\(c=\\max\\{1,T(102)/(102\\lg\r\n102),T(103)/(103\\lg103)\\}\\)，那么就可以确定好\\(d,e,f\\)的值。由数学归纳法，\\(T(n)=O(n\\lg n)\\)成立。\r\ne\r\n假设\\(T(n)\\le (c-d)n\\)，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=2T(n/3)+\\Theta(n)\\\\\r\n&amp;\\le \\dfrac{2c-2d}{3}n+\\Theta(n)\\\\\r\n&amp;=\\dfrac{2c+d}{3}n+(\\Theta(n)-dn)\\\\\r\n&amp;\\le \\dfrac{2c+d}{3}n&amp;\\qquad(A)\\\\\r\n&amp;\\le (c-d)n&amp;\\qquad(B)\r\n\\end{aligned}\\)\r\n其中步骤\\((A)\\)是假定了\\(dn\\)是\\(\\Theta(n)\\)的上限值，因此可以消去。步骤\\((B)\\)则是假设\\(\\dfrac{2c+d}{3}\\le c-d\\)，即\\(c\\ge 5d\\)。\r\n此外\\(c\\)值还需要超过\\(\\max\\{1,T(1)+d,T(2)/2+d\\}\\)。由数学归纳法，\\(T(n)=O(n)\\)成立。\r\n假设\\(T(n)\\ge c&#39;n\\)，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=2T(n/3)+\\Theta(n)\\\\\r\n&amp;\\ge \\dfrac{2c&#39;}{3}n+\\Theta(n)\\\\\r\n&amp;\\ge \\dfrac{2c&#39;}{3}n&amp;\\qquad(A)\\\\\r\n&amp;\\ge c&#39;n\\\\\r\n\\end{aligned}\\)\r\n其中步骤\\((A)\\)使用了渐进函数的函数值都非负的事实。\r\n因此只要令\\(c&#39;=\\min\\{1,T(1),T(2)/2\\}\\)。由数学归纳法，\\(T(n)=\\Omega(n)\\)成立。\r\n因此，\\(T(n)=\\Theta(n)\\)。\r\nf\r\n假设\\(T(n)\\le cn^2 -\r\ndn\\)，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=4T(n/2)+\\Theta(n)\\\\\r\n&amp;\\le 4(c(n/2)^2 - d(n/2))+\\Theta(n)\\\\\r\n&amp;=cn^2-2dn +\\Theta(n)\\\\\r\n&amp;=cn^2-dn +(\\Theta(n)-dn)\\\\\r\n&amp;\\le cn^2-dn &amp;\\qquad(A)\r\n\\end{aligned}\\)\r\n其中步骤\\((A)\\)是假定了\\(dn\\)是\\(\\Theta(n)\\)的上限值，因此可以消去。\r\n那么令\\(c=\\max\\{1,T(1)+d,(T(2)+2d)/4\\}\\)。由数学归纳法，\\(T(n)=O(n^2)\\)成立。\r\n假设\\(T(n)\\ge\r\nc&#39;n^2\\)，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=4T(n/2)+\\Theta(n)\\\\\r\n&amp;\\ge c&#39;n^2+\\Theta(n)\\\\\r\n&amp;\\ge c&#39;n^2&amp;\\qquad(A)\r\n\\end{aligned}\\)\r\n其中步骤\\((A)\\)使用了渐进函数的函数值都非负的事实。\r\n那么令\\(c&#39;=\\max\\{1,T(1),T(2)/4\\}\\)。由数学归纳法，\\(T(n)=\\Omega(n^2)\\)成立。\r\n因此，\\(T(n)=\\Theta(n^2)\\)。\r\n4.3-2\r\n假设\\(T(n)\\le cn^2\\)，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=4T(n/2)+n\\\\\r\n&amp;\\le 4 c(n/2)^2+n\\\\\r\n&amp;=cn^2+n\r\n\\end{aligned}\\)\r\n最终得出的是\\(T(n)\\le\r\ncn^2+n\\)，无法得到\\(T(n)\\le\r\ncn^2\\)。\r\n重新考虑\\(T(n)\\le cn^2 -\r\ndn\\)，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=4T(n/2)+n\\\\\r\n&amp;\\le 4(c(n/2)^2 - d(n/2))+n\\\\\r\n&amp;=cn^2+(1-2d)n\\\\\r\n&amp;\\le cn^2-dn &amp;\\qquad(d\\ge 1)\r\n\\end{aligned}\\)\r\n取好\\(d\\)后，令\\(c=\\max\\{1,T(1)+d,(T(2)+2d)/4\\}\\)。由数学归纳法，\\(T(n)=O(n^2)\\)成立。\r\n4.3-3\r\n假设\\(T(n)\\le c2^n\\)，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=2T(n-1)+1\\\\\r\n&amp;\\le 2c\\cdot 2^{n-1}+1\\\\\r\n&amp;=c2^n+1\r\n\\end{aligned}\\)\r\n最终得出的是\\(T(n)\\le\r\nc2^n+1\\)，无法得到\\(T(n)\\le\r\nc2^n\\)。\r\n重新考虑\\(T(n)\\le\r\nc2^n-d\\)，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=2T(n-1)+1\\\\\r\n&amp;\\le 2(c\\cdot 2^{n-1}-d)+1\\\\\r\n&amp;=c2^n-(2d-1)\\\\\r\n&amp;\\le c2^n-d &amp; \\qquad(A)\r\n\\end{aligned}\\)\r\n其中步骤\\((A)\\)假设了\\(2d-1\\ge d\\)，即\\(d\\ge 1\\)。\r\n确定好\\(d\\)值后，令\\(c=\\max\\{1,(T(1)+d)/2\\}\\)。由数学归纳法，\\(T(n)=O(2^n)\\)成立。\r\n","categories":["算法导论"]},{"title":"算法导论35.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-35/exercises-2/","content":"\r\n35.2-1\r\n使用反证法证明。假设存在边\\((u,v)\\)，其代价为负数，并且存在节点\\(w\\)，满足\\(c(u,v)+c(v,w)\\ge c(u,w)\\)。\r\n那么两边减去\\(c(u,v)\\)，得到不等式\\(c(v,w)\\ge c(u,w)-c(u,v)\\)。\r\n由于\\(c(u,v)\\)是负数，因此\\(-c(u,v)&gt;c(u,v)\\)，那么得到\\(c(v,w)\\ge\r\nc(u,w)-c(u,v)&gt;c(u,w)+c(u,v)\\)，即\\(c(u,v)+c(u,w)&lt;c(v,w)\\)。这和固有的三角不等式\\(c(u,v)+c(u,w)\\ge c(v,w)\\)矛盾。\r\n因此\\(\\forall u,v\\in V,c(u,v)\\ge\r\n0\\)均成立。\r\n35.2-2\r\n接下来考虑将任意一个旅行商问题实例在多项式时间内转化成另一个代价函数满足三角不等式的旅行商问题实例。\r\n对于图\\(G=(V,E)\\)和代价函数\\(c\\)，定义\\(\\displaystyle{M=\\max_{(u,v)\\in\r\nE}\\{c(u,v)\\}}\\)。对于同样的图，定义代价函数\\(c&#39;(u,v)=c(u,v)+M\\)。\r\n可以知道问题实例\\(\\langle\r\nG,c\\rangle\\)中所有哈密顿回路\\(C\\)都和\\(\\langle\r\nG,c&#39;\\rangle\\)的哈密顿回路一一对应。由于哈密顿回路仅包含\\(|V|\\)条边，因此\\(c&#39;(C)-c(C)=|V|\\cdot\r\nM\\)。也就是说，如果\\(C\\)是问题实例\\(\\langle\r\nG,c\\rangle\\)中的最优旅行路线，那么也是\\(\\langle\r\nG,c&#39;\\rangle\\)的最优旅行路线。\r\n接下来证明\\(c&#39;\\)是满足三角不等式的。对应任意\\(3\\)个节点\\(u,v,w\\)，考虑\\(c&#39;(u,v)+c&#39;(v,w)-c&#39;(u,w)\\)的正负，有\r\n\\(\\begin{aligned}\r\nc&#39;(u,v)+c&#39;(v,w)-c&#39;(u,w)&amp;=\r\n(c(u,v)+M)+(c(v,w)+M)-(c(u,w)+M)\\\\\r\n&amp;=c(u,v)+c(v,w)-c(u,w)+M\\\\\r\n&amp;\\ge c(u,v)+c(v,w)\\\\\r\n&amp;\\ge 0\r\n\\end{aligned}\\)\r\n因此必定有\\(c&#39;(u,v)+c&#39;(v,w)\\ge\r\nc&#39;(u,w)\\)。\r\n可见代价函数\\(c&#39;\\)可以在多项式时间内构造出来。\r\n接下来说明这和定理35.3的证明不冲突。假设\\(C\\)是问题实例\\(\\langle G,c&#39;\\rangle\\)一条从某个\\(\\rho\\)近似算法获得的旅行路线，而\\(C^{\\ast}\\)是最优旅行路线。那么有\\(c&#39;(C)\\le \\rho\\cdot\r\nc&#39;(C^{\\ast})\\)。现在将问题\\(\\langle\r\nG,c&#39;\\rangle\\)转换成\\(\\langle\r\nG,c\\rangle\\)。那么有\\(c(C)+|V|\\cdot\r\nM\\le \\rho\\cdot (c(C^{\\ast})+|V|\\cdot M)\\)，化简后得\\(c(C)\\le \\rho\\cdot\r\nc(C^{\\ast})+(\\rho-1)\\cdot|V|\\cdot M\\)。由于\\(\\rho&gt;1\\)，因此并不存在一个常数近似比的近似算法，原结论成立。\r\n35.2-3\r\n回顾第21.2章所介绍的Prim算法。Prim算法是维护一个最佳的连通块\\(B\\)（代表一棵树），然后每次添加一棵节点到这棵树中，从而逐渐让它成为一棵最小生成树。\r\n题目中所给出的最近点启发式算法和Prim算法的思想相同，只是维护的最佳连通块\\(B\\)代表的是一个环。如果在打破平等策略也相同，那么可以知道，这两个算法中，每个点进入\\(B\\)的顺序都是相同的（因为每次迭代都是找到一个节点\\(u\\)，不在\\(B\\)中，并且距离\\(B\\)中的所有节点距离最短）。\r\n接下来同时模拟这两个算法的过程，维护\\(B\\)中的树\\(T\\)，还有\\(T\\)的一个完全遍历\\(W\\)，以及将\\(W\\)去重后的一个旅行线路\\(C\\)，并假设当前块\\(B\\)中的最优旅行线路为\\(C^{\\ast}\\)。可见，旅行\\(C\\)就是最近点启发式算法的运行过程。考虑使用循环不变量来说明\\(c(C)\\le 2c(C^{\\ast})\\)均成立：\r\n初始化：\\(T,W,C\\)中只包含一个初始节点\\(u\\)，\\(c(C)=c(C^{\\ast})=0\\)。\r\n保持：假设现在距离\\(B\\)中最近的节点\\(v\\)，在\\(B\\)中距离最近\\(v\\)最近的节点为\\(w\\)。那么接下来进行如下操作：节点\\(v\\)添加到\\(B\\)中；边\\((v,w)\\)添加到树\\(T\\)中；在\\(W\\)中找到节点\\(w\\)第一次出现的位置，并在这个位置前面插入序列\\([w,v]\\)；然后重新产生旅行\\(C\\)，可以发现和原来的区别在于\\(w\\)后面添加了一个\\(v\\)节点。可见，对于连通块\\(B\\)中对应的树\\(T\\)，完全遍历\\(W\\)，旅行线路\\(C\\)，都是和定理35.2证明过程中一一对应的。因此对于块\\(B\\)的最优旅行线路\\(C^{\\ast}\\)，都有\\(c(C)\\le 2c(C^{\\ast})\\)。\r\n终止：最终构造出了\\(G\\)的一棵最小生成树\\(T\\)，还有其对应的完全遍历\\(W\\)，以及将\\(W\\)去重后的一个旅行线路\\(C\\)，因此仍然保持\\(c(C)\\le 2c(C^{\\ast})\\)。\r\n也就是说，这个算法构造的旅行路线也是\\(2\\)近似的，原结论成立。\r\n35.2-4\r\n令\\(c(H)\\)表示路径\\(H\\)中最长一条边的权值。根据题目21-4，通过完全图\\(G\\)，我们可以在线性时间内求出一个瓶颈生成树\\(T\\)。对于一条最优的瓶颈旅行商问题中的线路\\(C^{\\ast}\\)，去掉\\(C^{\\ast}\\)的其中一条边后，得到的一条链是也是一棵树，但不一定是一棵瓶颈生成树，因此有\\(c(C^{\\ast})\\ge c(T)\\)。通过树\\(T\\)，使用题目34.2-11的算法，我们可以构造\\(G\\)上的一条哈密顿回路\\(C\\)，那么这条哈密顿回路为所求。可见这个算法是多项式时间内可运行完成的。\r\n接下来证明这个多项式算法是具有3近似比的。题目34.2-11说明了，构造的哈密顿回路\\(C\\)，任意相邻两点在\\(T\\)上都不超过\\(3\\)条边，因此有\\(c(C)\\le 3c(T)\\)。\r\n最终得到\\(c(C)\\le\r\n3c(C^{\\ast})\\)。因此如上构造的一个算法为一个近似比为\\(3\\)的多项式时间近似算法，结论成立。\r\n35.2-5\r\n\r\n如图所示，不失一般性，假设一段旅行\\(C\\)中，边\\((w,z)\\)和边\\((x,y)\\)相交在平面上相交，假设交点为\\(o\\)。那么可以知道，对于三角形\\(wxo,xzo,zyo,ywo\\)，可以写出下列\\(4\\)个不等式：\r\n\\(\\begin{aligned}\r\nc(w,o)+c(x,o)&amp;&gt; c(w,x)\\\\\r\nc(x,o)+c(z,o)&amp;&gt; c(x,z)\\\\\r\nc(z,o)+c(y,o)&amp;&gt; c(z,y)\\\\\r\nc(y,o)+c(w,o)&amp;&gt; c(y,w)\\\\\r\n\\end{aligned}\\)\r\n因此可以得到\r\n\\(\\begin{aligned}\r\nc(w,z)+c(x,y)&amp;&gt; c(w,x)+c(y,z)\\qquad(1)\\\\\r\nc(w,z)+c(x,y)&amp;&gt; c(x,z)+c(y,w)\\qquad(2)\\\\\r\n\\end{aligned}\\)\r\n并且，边\\((w,x)\\)和边\\((y,z)\\)不相交；边\\((x,z)\\)和边\\((y,w)\\)也不相交。\r\n接下来将\\(C\\)删去边\\((w,z),(x,y)\\)，\\(C\\)中将会有两个连通块。考虑如下两种情况：\r\n\r\n\\(w\\)和\\(x\\)连通，\\(y\\)和\\(z\\)连通，那么构造\\(C&#39;=(C-\\{(w,z),(x,y)\\})\\cup\\{(x,z),(y,w)\\}\\)。可见\\(C&#39;\\)仍然是一个环。根据不等式\\((2)\\)，可以得到\\(c(C&#39;)&lt;c(C)\\)，原结论成立。\r\n\\(x\\)和\\(z\\)连通，\\(y\\)和\\(w\\)连通，那么构造\\(C&#39;=(C-\\{(w,z),(x,y)\\})\\cup\\{(w,x),(y,z)\\}\\)。可见\\(C&#39;\\)仍然是一个环。根据不等式\\((1)\\)，可以得到\\(c(C&#39;)&lt;c(C)\\)，原结论成立。\r\n\r\n因此，一个最优的旅行线路不会自我相交，否则将会找到一条更优的旅行线路。\r\n35.2-6\r\n假设该非负整数\\(c\\)存在，在证明定理35.3的时候，只需要代入\\(\\rho=|V|^c\\)即可，即证明不存在关于多项式时间内有近似比例\\(|V|^c\\)的算法来求解一般旅行商问题。接下来是修改后的简要证明。\r\n如果存在多项式时间内有近似比例\\(|V|^c\\)的算法来求解一般旅行商问题。那么我们可以使用这个算法求解任意图\\(G=(V,E)\\)的哈密顿回路。考虑将图\\(G=(V,E)\\)转化成一个旅行商问题的实例\\(G&#39;=(V,E&#39;)\\)，其中\\(E&#39;=\\{(u,v):u,v\\in V\\land u\\neq\r\nv\\}\\)。并且对\\(E&#39;\\)中的每条边赋予一个整数代价\\(c\\)：\r\n\\(c(u,v)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1 &amp; &amp; \\text{if}\\quad  (u,v)\\in E \\\\\r\n  &amp;|V|^{c+1}+1 &amp; &amp; \\text{if}\\quad  (u,v)\\in E \\\\\r\n\\end{aligned}\\right.\\)\r\n如果\\(G\\)中存在一条哈密顿回路，那么使用该多项式算法求解\\(G&#39;\\)的旅行商问题，能够求解出来一条权值为\\(|V|\\)的旅行路线。否则，在图\\(G&#39;\\)中的一条旅行路线就至少用到一条不属于\\(E\\)的边，那么这条旅行路线的权值至少为：\r\n\\[|V|^{c+1}+1+(|V|-1)=|V|^{c+1}+|V|&gt;|V|^c\\cdot\r\n|V|\\]\r\n也就是说，如果\\(G\\)不存在一条哈密顿回路，那么任何一条旅行线路的边权都将超过\\(|V|^c\\cdot |V|\\)。因此，可以使用这个\\(|V|^c\\)近似比的多项式近似算法来寻找\\(G\\)中的一条哈密顿回路，然而这是不可能的。\r\n","categories":["算法导论"]},{"title":"算法导论4.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-4/exercises-1/","content":"\r\n4.1-1\r\n令\\(n&#39;=2^{\\lceil\\lg\r\nn\\rceil}\\)。那么不难发现，有\\(\\dfrac{1}{2}&lt;\\dfrac{n}{n&#39;}\\le\r\n1\\)成立。\r\n为矩阵\\(A,B\\)补\\(0\\)到\\(n&#39;\\)的大小，那么可以得到新矩阵\\(A&#39;,B&#39;\\)。也就是说，对于矩阵\\(A&#39;\\)中的新元素\\(a_{ij}&#39;\\)，有：\r\n\\(a_{i,j}&#39;=\r\n\\left \\{\\begin{aligned}\r\n  &amp;a_{i,j} &amp; &amp; \\text{if}\\quad i\\le n \\land j\\le n \\\\\r\n  &amp;0 &amp; &amp; \\text{if}\\quad  i&gt; n \\lor j&gt; n \\\\\r\n\\end{aligned}\\right.\\)\r\n矩阵\\(B&#39;\\)同理。\r\n递推式仍然为\\(T&#39;(n)=8T&#39;(n/2)+\\Theta(1)\\)。\r\n由于传统算法MATRIX-MULTIPLY-RECURSIVE的时间复杂度是\\(T(n)=\\Theta(n^3)\\)，因此\\(\\exists c_1,c_2,n_0\\in \\mathbb{R}^{+},\\forall\r\nn&#39;\\ge n_0,0\\le c_1n&#39;^3\\le f(n&#39;)\\le\r\nc_2n&#39;^3\\)。回代\\(n\\)，得到\\(0\\le\r\n\\dfrac{c_1}{8}\\cdot n^3\\le f(n)\\le c_2n^3\\)。因此\\(T&#39;(n)=\\Theta(n^3)\\)。\r\n4.1-2\r\n使用这个程序作为子程序计算\\(kn \\times\r\nn\\)和\\(n\\times\r\nkn\\)大小的矩阵相乘需要花费\\(\\Theta(k^2n^3)\\)的时间。如果是\\(n \\times kn\\)和\\(kn\\times n\\)大小的矩阵相乘，则需要花费\\(\\Theta(kn^3)\\)的时间。\r\n4.1-3\r\n由于涉及到矩阵的复制操作，因此每次调用都会有\\(\\Theta(n^2)\\)的操作时间。\r\n因此运行时间的递推式就写成\\(T(n)=8T(n/2)+\\Theta(n^2)\\)。\r\n根据主定理，\\(a=8,b=2,\\log _b\r\na=3\\).\r\n因此根据第一个条件，\\(T(n)=\\Theta(n^3)\\)。\r\n4.1-4\r\nMATRIX-ADD-RECURSIVE(A, B, C, n)  if n == 1  // Base case.    c11 = c11 + a11 + b11    return  // Divide.  partition A, B, and C into n/2 × n/2 submatrices A11, A12, A21, A22; B11, B12, B21, B22; and C11, C12, C21, C22; respectively   // Conquer.  MATRIX-ADD-RECURSIVE(A11, B11, C11, n/2)  MATRIX-ADD-RECURSIVE(A12, B12, C12, n/2)  MATRIX-ADD-RECURSIVE(A21, B21, C21, n/2)  MATRIX-ADD-RECURSIVE(A22, B22, C22, n/2)\r\n如果使用的方法是直接基于索引的计算，那么运行时间的递推式就写成\\(T(n)=4T(n/2)+\\Theta(1)\\)。\r\n根据主定理，\\(a=4,b=2,\\log _b\r\na=2\\).\r\n因此根据第一个条件，\\(T(n)=\\Theta(n^2)\\)。\r\n如果使用的方法是直接基于索引的计算，那么运行时间的递推式就写成\\(T(n)=4T(n/2)+\\Theta(n^2)\\)。\r\n因此根据第二个条件，得到\\(k=0\\)，最终\\(T(n)=\\Theta(n^{2}\\lg ^1 n)=\\Theta(n^2 \\lg\r\nn)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论4.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-4/exercises-2/","content":"\r\n4.2-1\r\n\\(\\begin{aligned}\r\nS_{1} &amp;= B_{12} - B_{22}=[8]-[2]=[6]\\\\\r\nS_{2} &amp;= A_{11} + A_{12}=[1]+[3]=[4]\\\\\r\nS_{3} &amp;= A_{21} + A_{22}=[7]+[5]=[12]\\\\\r\nS_{4} &amp;= B_{21} - B_{11}=[4]-[6]=[-2]\\\\\r\nS_{5} &amp;= A_{11} + A_{22}=[1]+[5]=[6]\\\\\r\nS_{6} &amp;= B_{11} + B_{22}=[6]+[2]=[8]\\\\\r\nS_{7} &amp;= A_{12} - A_{22}=[3]-[5]=[-2]\\\\\r\nS_{8} &amp;= B_{21} + B_{22}=[4]+[2]=[6]\\\\\r\nS_{9} &amp;= A_{11} - A_{21}=[1]-[7]=[-6]\\\\\r\nS_{10} &amp;= B_{11} + B_{12}=[6]+[8]=[14]\\\\\r\n\\\\\r\nP_{1} &amp;= A_{11} \\cdot S_{1}=[1]\\cdot [6]=[6] \\\\\r\nP_{2} &amp;= S_{2} \\cdot B_{22}=[4]\\cdot [2]=[8] \\\\\r\nP_{3} &amp;= S_{3} \\cdot B_{11}=[12]\\cdot [6]=[72] \\\\\r\nP_{4} &amp;= A_{22} \\cdot S_{4}=[5]\\cdot[-2]=[-10] \\\\\r\nP_{5} &amp;= S_{5} \\cdot S_{6}=[6]\\cdot [8]=[48] \\\\\r\nP_{6} &amp;= S_{7} \\cdot S_{8}=[-2]\\cdot [6]=[-12] \\\\\r\nP_{7} &amp;= S_{9} \\cdot S_{10}=[-6]\\cdot [14]=[-84]\\\\\r\n\\\\\r\nC_{11} &amp;= P_{5} + P_{4} - P_{2} + P_{6}=[48]+[-10]-[8]+[-12]=[18]\\\\\r\nC_{12} &amp;= P_{1} + P_{2}=[6]+[8]=[14]\\\\\r\nC_{21} &amp;= P_{3} + P_{4}=[72]+[-10]=[62]\\\\\r\nC_{22} &amp;= P_{5} + P_{1} - P_{3} - P_{7}=[48]+[6]-[72]-[-84]=[66]\\\\\r\n\\end{aligned}\\)\r\n因此计算结果为\\(\\left[\\begin{aligned} 18\r\n&amp;&amp; 14\\\\62&amp;&amp;66\\end{aligned}\\right]\\)。\r\n4.2-2\r\nStrassen(A, B, n)  Let C be a new n × n matrix.  if n == 1  // Base case.    c11 = a11 * b11    return C  // Divide.  partition A, B, and C into n/2 × n/2 submatrices A11, A12, A21, A22; B11, B12, B21, B22; and C11, C12, C21, C22; respectively  S1 = B12 − B22  S2 = A11 + A12  S3 = A21 + A22  S4 = B21 − B11  S5 = A11 + A22  S6 = B11 + B22  S7 = A12 − A22  S8 = B21 + B22  S9 = A11 − A21  S10 = B11 + B12  P1 = Strassen(A11, S1, n)  P2 = Strassen(S2, B22, n)  P3 = Strassen(S3, B11, n)  P4 = Strassen(A22, S4, n)  P5 = Strassen(S5, S6, n)  P6 = Strassen(S7, S8, n)  P7 = Strassen(S9, S10, n)  // Conquer.  C11 = P5 + P4 - P2 + P6  C12 = P1 + P2  C21 = P3 + P4  C22 = P5 + P1 - P3 - P7  return C\r\n4.2-3\r\n如果矩阵的大小\\(n\\)是\\(3\\)的幂，将它划分成\\(3\\times3\\)部分计算，如果计算乘法的次数为\\(k\\)，那么运行时间有递推式：\\(T(n)=k T(n/3)+\\Theta(n^2)\\)。\r\n那么根据主定理的第一个条件，有\\(T(n)=\\Theta(n^{\\log _3\r\nk})\\)。为了快于Strassen算法，需要满足\\(\\log_3k&lt;\\lg 7\\)。可以计算得到：\\(k=21\\)。\r\n4.2-4\r\n通过计算，得到：\r\n\\(\\begin{aligned}\r\n&amp;\\log_{68} 132464 \\approx 2.7951285\\\\\r\n&amp;\\log_{70} 143640 \\approx 2.7951227\\\\\r\n&amp;\\log_{72} 155424 \\approx 2.7951474\\\\\r\n\\end{aligned}\\)\r\n可以发现，第二个效果最好。\r\n4.2-5\r\n程序输入MULTIPLY-COMPLEX输入四个数\\(a,b,c,d\\)分别表示复数\\(a+bi,c+di\\)。\r\n输出两个数表示乘法计算结果的实部和虚部。\r\nMULTIPLY-COMPLEX(a, b, c, d)  A = (a + b) * (c + d)  B = a * c  C = b * d  e = B - C  f = A - B - C  return (e, f)\r\n其中有：\r\n\\(\\begin{aligned}\r\ne &amp;= B-C= ac-bd\\\\\r\nf &amp;= A-B-C=ac+ad+bc+bd-ac-bd=ad+bc\r\n\\end{aligned}\\)\r\n4.2-6\r\n假设这个程序MATRIX-SQUARE(A, n)可以以\\(\\Theta(n^{\\alpha})\\)的时间复杂度求矩阵的平方，那么可以用来设计程序MATRIX-MULTIPLY2(A, B, n)来以\\(\\Theta(n^{\\alpha})\\)来计算矩阵乘法。伪代码如下：\r\nMATRIX-MULTIPLY2(A, B, n)  C = A + B  A2 = MATRIX-SQUARE(A, n)  B2 = MATRIX-SQUARE(B, n)  C2 = MATRIX-SQUARE(C, n)  D = (C2 - A2 - B2) / 2  return D\r\n\\(D=((A+B)^2-A^2-B^2)=(A^2+2AB+B^2-A^2-B^2)/2=AB\\)\r\n可以发现，这个程序仅仅执行了\\(3\\)次程序MATRIX-SQUARE，其余步骤都是执行固定次数的矩阵加法和标量乘法。因此执行的时间复杂度仍为\\(\\Theta(n^{\\alpha})\\)。\r\n","categories":["算法导论"]},{"title":"算法导论4.4 Exercises 答案","url":"/introduction-to-algorithms/chapter-4/exercises-4/","content":"\r\n4.4-1\r\na\r\n\r\n第\\(0\\)层有\\(1\\)个节点，每个节点的权值为\\(n^3\\)，权值之和为\\(n^3\\)。\r\n第\\(1\\)层有\\(1\\)个节点，每个节点的权值为\\(\\dfrac{n^3}{8}\\)，权值之和为\\(\\dfrac{n^3}{8}\\)。\r\n第\\(2\\)层有\\(1\\)个节点，每个节点的权值为\\(\\dfrac{n^3}{64}\\)，权值之和为\\(\\dfrac{n^3}{64}\\)。\r\n……\r\n第\\(i\\)层有\\(1\\)个节点，每个节点的权值为\\(\\dfrac{n^3}{8^i}\\)，权值之和为\\(\\dfrac{n^3}{8^i}\\)。\r\n\r\n可以知道，这棵树有\\(\\lg\r\nn\\)层，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;= \\sum_{i=0}^{\\lg n} \\dfrac{n^3}{8^i}\\\\\r\n&amp;\\le n^3 \\sum_{i=0}^{\\infty} \\dfrac{1}{8^i}\\\\\r\n&amp;=\\dfrac{8}{7} n^3\r\n\\end{aligned}\\)\r\n那么猜测\\(T(n)=O(n^3)\\)。使用代入法验证，假设\\(T(n)\\le cn^3\\)，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;= T(n/2)+n^3\\\\\r\n&amp;\\le\\left(\\dfrac{c}{8}+1\\right)n^3\\\\\r\n&amp;\\le cn^3 &amp;\\qquad(A)\r\n\\end{aligned}\\)\r\n其中步骤\\((A)\\)假设了\\(\\dfrac{c}{8}+1\\le c\\)，即\\(c\\ge\\dfrac{8}{7}\\)。\r\n那么令\\(c=\\max\\{8/7,T(1),T(2)/8\\}\\)。由数学归纳法，\\(T(n)=O(n^3)\\)成立。\r\nb\r\n\r\n第\\(0\\)层有\\(1\\)个节点，每个节点的权值为\\(n\\)，权值之和为\\(n\\)。\r\n第\\(1\\)层有\\(4\\)个节点，每个节点的权值为\\(\\dfrac{n}{3}\\)，权值之和为\\(\\dfrac{4n}{3}\\)。\r\n第\\(2\\)层有\\(16\\)个节点，每个节点的权值为\\(\\dfrac{n}{9}\\)，权值之和为\\(\\dfrac{16n}{9}\\)。\r\n……\r\n第\\(i\\)层有\\(4^i\\)个节点，每个节点的权值为\\(\\dfrac{n}{3^i}\\)，权值之和为\\(\\left(\\dfrac{4}{3}\\right)^in\\)。\r\n\r\n可以知道，这棵树有\\(\\log_3n\\)层，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;= \\sum_{i=0}^{\\log_3 n} \\left(\\dfrac{4}{3}\\right)^in\\\\\r\n&amp;= n \\sum_{i=0}^{\\log _3 n} \\left(\\dfrac{4}{3}\\right)^i\\\\\r\n&amp;=n\\left(\\left(\\dfrac{4}{3}\\right)^{\\log_3 n+1} - 3\\right) \\\\\r\n&amp;\\le n \\left(\\dfrac{4}{3}\\right)^{\\log_3 n+1}\\\\\r\n&amp;=\\dfrac{4}{3} \\cdot 4^{\\log_3 n}\\\\\r\n&amp;=\\dfrac{4}{3} \\cdot n^{\\log_3 4}\\\\\r\n\\end{aligned}\\)\r\n那么猜测\\(T(n)=O(n^{\\log_3\r\n4})\\)。使用代入法验证，假设\\(T(n)\\le\r\ncn^{\\log_3 4}-dn\\)，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;= 4T(n/3)+n\\\\\r\n&amp;\\le 4c\\left(\\dfrac{n}{3}\\right)^{\\log_3 4}-4dn+n\\\\\r\n&amp;= 4c\\cdot\\dfrac{n^{\\log_3 4}}{4}-4dn+n\\\\\r\n&amp;= c\\cdot n^{\\log_3 4}-(4d-1)n\\\\\r\n&amp;= cn^{\\log_3 4}&amp;\\qquad(A)\r\n\\end{aligned}\\)\r\n其中步骤\\((A)\\)假设了\\(4d-1\\ge d\\)，即\\(d\\ge\\dfrac{1}{3}\\)。\r\n那么最终令\\(c=\\max\\{1,T(1),T(2)/2^{\\log_3\r\n4},T(3)/4\\}\\)。由数学归纳法，\\(T(n)=O(n^{\\log_3 4})\\)成立。\r\nc\r\n\r\n第\\(0\\)层有\\(1\\)个节点，每个节点的权值为\\(n\\)，权值之和为\\(n\\)。\r\n第\\(1\\)层有\\(4\\)个节点，每个节点的权值为\\(\\dfrac{n}{2}\\)，权值之和为\\(2n\\)。\r\n第\\(2\\)层有\\(16\\)个节点，每个节点的权值为\\(\\dfrac{n}{4}\\)，权值之和为\\(4n\\)。\r\n……\r\n第\\(i\\)层有\\(4^i\\)个节点，每个节点的权值为\\(\\dfrac{n}{2^i}\\)，权值之和为\\(2^in\\)。\r\n\r\n可以知道，这棵树有\\(\\lg\r\nn\\)层，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;= \\sum_{i=0}^{\\lg n} 2^i n\\\\\r\n&amp;= n \\sum_{i=0}^{\\lg n} 2^i\\\\\r\n&amp;=n \\cdot (2^{\\lg n+1} - 1)\\\\\r\n&amp;\\le n  2^{\\lg n+1} \\\\\r\n&amp;=2n^2\r\n\\end{aligned}\\)\r\n那么猜测\\(T(n)=O(n^2)\\)。使用代入法验证，假设\\(T(n)\\le cn^2 - dn\\)，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=4T(n/2)+n\\\\\r\n&amp;\\le 4(c(n/2)^2 - d(n/2))+n\\\\\r\n&amp;=cn^2+(1-2d)n\\\\\r\n&amp;\\le cn^2-dn &amp;\\qquad(d\\ge 1)\r\n\\end{aligned}\\)\r\n取好\\(d\\)后，令\\(c=\\max\\{1,T(1)+d,(T(2)+2d)/4\\}\\)。由数学归纳法，\\(T(n)=O(n^2)\\)成立。\r\nd\r\n\r\n第\\(0\\)层有\\(1\\)个节点，每个节点的权值为\\(1\\)，权值之和为\\(1\\)。\r\n第\\(1\\)层有\\(3\\)个节点，每个节点的权值为\\(1\\)，权值之和为\\(3\\)。\r\n第\\(3\\)层有\\(9\\)个节点，每个节点的权值为\\(1\\)，权值之和为\\(9\\)。\r\n……\r\n第\\(i\\)层有\\(3^i\\)个节点，每个节点的权值为\\(3^i\\)，权值之和为\\(3^i\\)。\r\n\r\n可以知道，这棵树有\\(n\\)层，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;= \\sum_{i=0}^{n} 3^i\\\\\r\n&amp;=\\dfrac{3^{i+1}-1}{2}\\\\\r\n&amp;\\le\\dfrac{3^{i+1}}{2}\\\\\r\n\\end{aligned}\\)\r\n那么猜测\\(T(n)=O(3^n)\\)。使用代入法验证，假设\\(T(n)\\le c3^n - d\\)，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=3T(n-1)+1\\\\\r\n&amp;\\le 3(c\\cdot 3^{n-1}-d)+1\\\\\r\n&amp;=c3^n-(3d-1)\\\\\r\n&amp;\\le c3^n-d &amp; \\qquad(A)\r\n\\end{aligned}\\)\r\n其中步骤\\((A)\\)假设了\\(3d-1\\ge d\\)，即\\(d\\ge \\dfrac{1}{2}\\)。\r\n确定好\\(d\\)值后，令\\(c=\\max\\{1,(T(1)+d)/3\\}\\)。由数学归纳法，\\(T(n)=O(3^n)\\)成立。\r\n4.4-2\r\n假设\\(L(n)\\ge cn\\)，那么有\r\n\\(L(n)=L(2n/3)+L(n/3)\\ge\r\n2cn/3+cn/3=cn\\)\r\n考虑当\\(n\\ge n_0\\)时，令\\(c=\\min\\{1,\\min_{i=n_0}^{3n_0}\\{T(i)/i\\}\\}\\)。由数学归纳法，\\(L(n)=\\Omega(n)\\)成立。\r\n由于已知\\(L(n)=O(n)\\)，因此\\(L(n)=\\Theta(n)\\)。\r\n4.4-3\r\n假设\\(L(n)\\ge cn\\lg n\\)，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=T(n/3)+T(2n/3)+\\Theta(n)\\\\\r\n&amp;\\ge c(n/3) \\lg(n/3) + c(2n/3)\\lg(2n/3)+\\Theta(n)\\\\\r\n&amp;=cn\\lg n - \\dfrac{\\lg (27/4)}{3} cn+\\Theta(n)\\\\\r\n&amp;\\ge cn\\lg n &amp; \\qquad(A)\\\\\r\n\\end{aligned}\\)\r\n其中步骤\\((A)\\)假设了\\(\\dfrac{\\lg (27/4)}{3} cn\\)不超过\\(\\Theta(n)\\)的上界。\r\n在此基础上，如果\\(c\\le\r\n\\min\\{T(2)/2,T(3)/(3\\lg 3)\\}\\)。由数学归纳法，\\(T(n)=\\Omega(n\\lg n)\\)成立。\r\n由于已知\\(L(n)=O(n\\lg\r\nn)\\)，因此\\(L(n)=\\Theta(n \\lg\r\nn)\\)。\r\n4.4-4\r\n不失一般性，假设\\(0.5\\le \\alpha\r\n&lt;1\\)，因为\\(\\alpha\r\n&#39;=1-\\alpha\\)时的情形是一样的。\r\n可以知道，这棵树的每一层的节点权值之和都为\\(\\Theta(n)\\)。并且这一棵树的高度为\\(\\log_\\alpha (1/n)=\\log_{1/\\alpha}\r\nn\\)，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=\\sum_{i=0}^{\\log_{1/\\alpha} n-1}\\Theta(n)\\\\\r\n&amp;=\\log_{1/\\alpha} n \\cdot \\Theta(n) \\\\\r\n&amp;=\\Theta(n\\lg n) \\\\\r\n\\end{aligned}\\)\r\n猜测\\(T(n)=O(n\\lg\r\nn)\\)。使用代入法验证，假设\\(T(n)\\le\r\ncn\\lg n\\)，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=T(\\alpha n)+T((1-\\alpha)n)+\\Theta(n)\\\\\r\n&amp;\\le c\\alpha n\\lg(\\alpha n) + c((1-\\alpha) n)\\lg((1-\\alpha)\r\nn)+\\Theta(n)\\\\\r\n&amp;=cn\\lg n+c(\\alpha\\lg \\alpha +(1-\\alpha)\\lg(1-\\alpha)) n +\r\n\\Theta(n)\\\\\r\n&amp;\\le cn\\lg n &amp; \\qquad(A)\r\n\\end{aligned}\\)\r\n其中\\((A)\\)步骤基于以下假设，\\(\\alpha\\lg \\alpha\r\n+(1-\\alpha)\\lg(1-\\alpha)&lt;0\\)，因此取恰当大的\\(c\\)，使得\\(-c(\\alpha\\lg \\alpha\r\n+(1-\\alpha)\\lg(1-\\alpha))n\\)超过\\(\\Theta(n)\\)的上界。\r\n此外，\\(c\\)还需要满足\\(c\\ge \\max\\{1,T(2)/2,T(3)/(3\\lg\r\n3)\\}\\)。由数学归纳法，\\(T(n)=O(n\\lg\r\nn)\\)成立。\r\n猜测\\(T(n)=\\Omega(n\\lg\r\nn)\\)。使用代入法验证，假设\\(T(n)\\ge\r\nc&#39;n\\lg n\\)，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=T(\\alpha n)+T((1-\\alpha)n)+\\Theta(n)\\\\\r\n&amp;\\ge c&#39;\\alpha n\\lg(\\alpha n) + c&#39;((1-\\alpha)\r\nn)\\lg((1-\\alpha) n)+\\Theta(n)\\\\\r\n&amp;=c&#39;n\\lg n+c&#39;(\\alpha\\lg \\alpha +(1-\\alpha)\\lg(1-\\alpha)) n +\r\n\\Theta(n)\\\\\r\n&amp;\\ge cn\\lg n &amp; \\qquad(A)\r\n\\end{aligned}\\)\r\n其中\\((A)\\)步骤基于以下假设，\\(\\alpha\\lg \\alpha\r\n+(1-\\alpha)\\lg(1-\\alpha)&lt;0\\)，因此取恰当小的\\(c\\)，使得\\(-c(\\alpha\\lg \\alpha\r\n+(1-\\alpha)\\lg(1-\\alpha))n\\)不超过\\(\\Theta(n)\\)的上界。\r\n此外，\\(c&#39;\\)还需要满足\\(c\\le \\min\\{1,T(2)/2,T(3)/(3\\lg\r\n3)\\}\\)。由数学归纳法，\\(T(n)=\\Omega(n\\lg n)\\)成立。\r\n因此，\\(T(n)=\\Theta(n\\lg n)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论35.5 Exercises 答案","url":"/introduction-to-algorithms/chapter-35/exercises-5/","content":"\r\n35.5-1\r\n首先证明\\(P_i\\)包含了\\(\\{x_1,x_2,\\dots,x_{i-1},x_i\\}\\)中所有子集的元素之和。\r\n当\\(i=1\\)时，\\(P_1=\\{0,x_1\\}\\)，也就是包含了空集，以及只有一个元素\\(x_1\\)的集合的元素之和。\r\n当\\(i&gt;1\\)时，假设\\(P_{i-1}\\)包含了\\(\\{x_1,x_2,\\dots,x_{i-1}\\}\\)中所有子集的元素之和。将\\(\\{x_1,x_2,\\dots,x_{i-1},x_{i}\\}\\)中的所有子集分成两部分：包含\\(x_i\\)的和不包含\\(x_i\\)的。对于不包含\\(x_i\\)的任何子集，这些子集和将和\\(P_{i-1}\\)中的和值对应；对于包含\\(x_{i}\\)的任何子集，只需要将不包含\\(x_i\\)的任何子集都添加上一个元素\\(x_i\\)，那么这一部分的子集和将和\\(P_{i-1}+x_i\\)中的对应。因此，\\(P_i=P_{i-1}\\cup (P_{i-1}+x_i)\\)包含了\\(\\{x_1,x_2,\\dots,x_{i-1},x_i\\}\\)中所有子集的元素之和，原结论成立。\r\n接下来证明EXACT-SUBSET-SUM的第4行执行结束之后，\\(L_i\\)是\\(P_i\\)中不超过\\(t\\)的有序列表，将采用归纳法进行证明。\r\n当\\(i=0\\)时，\\(L_0=\\langle\r\n0\\rangle\\)，也就是只包含了空集的元素之和，即为\\(0\\)。\r\n当\\(i&gt;0\\)时，假设\\(L_{i-1}\\)包含了\\(\\{x_1,x_2,\\dots,x_{i-1}\\}\\)中所有子集的元素之和不超过\\(t\\)的一个有序列表，接下来考虑\\(L_i\\)。可见，集合\\(P_{i-1}-L_{i-1}\\)包含的都是大于\\(t\\)的元素，由于\\(x_i&gt; 0\\)，因此\\((P_{i-1}-L_{i-1})+x_i\\)包含的仍然是大于\\(t\\)的元素，它们必定不会存在于\\(L_i\\)中。对于\\(L_{i-1}\\)中的所有元素，加上\\(x_i\\)后那么就要判断是否超过\\(t\\)，如果超过了那么就舍去。因此，通过归并时的合并策略，EXACT-SUBSET-SUM的第4行执行结束之后可以得到\\(P_i\\)中不超过\\(t\\)的元素的列表，原结论成立。\r\n35.5-2\r\n将使用归纳法进行证明。不失一般性，假设\\(x_1,x_2,\\dots,x_i\\le\r\nt\\)均成立，否则可以直接抛弃掉\\(x_i&gt;t\\)的元素，因为它必定不可能在集合中。\r\n当\\(i=0\\)时，可见\\(P_0=\\{0\\},L_0=\\langle\r\n0\\rangle\\)。原结论必定成立。\r\n当\\(i=1\\)时，可见\\(P_1=\\{0,x_1\\}\\)。由于\\(x_1&gt;0\\cdot(1+\\epsilon/2n),x_1\\le\r\nt\\)，因此\\(L_1=\\langle0,x_1\\rangle\\)。对于元素\\(x_1\\)，有\\(x_1/(1+\\epsilon/2n)\\le x_1\\le\r\nx_1\\)，因此原结论成立。\r\n当\\(i&gt;1\\)时，假设对于集合\\(P_{i-1}\\)中所有不超过\\(t\\)的元素\\(y\\)，在\\(L_{i-1}\\)中都存在元素\\(z\\)使得\\(\\dfrac{y}{(1+\\epsilon/2n)^{i-1}}\\le z\\le\r\ny\\)。考虑\\(P_i\\)中元素的情况。\r\n对于\\(P_i\\)中的元素，根据等式35.21，它们无非要么来自\\(P_{i-1}\\)，要么来自\\(P_{i-1}+x_i\\)。考虑如下两种情况：\r\n\r\n考虑\\(P_{i-1}\\)中的元素，题目中的假设说明了\\(P_{i-1}\\)中所有不超过\\(t\\)的所有元素\\(y\\)，在\\(L_{i-1}\\)必定存在\\(z\\)，使得\\(\\dfrac{y}{(1+\\epsilon/2n)^{i-1}}\\le z\\le\r\ny\\)。如果\\(z\\)在\\(L_i\\)中，那么由于\\(\\dfrac{y}{(1+\\epsilon/2n)^{i}}\\le\\dfrac{y}{(1+\\epsilon/2n)^{i-1}}\\le\r\nz\\le y\\)，因此结论成立。如果\\(z\\)不在\\(L_i\\)中，那么说明\\(z\\)在第4行TRIM的调用过程中被另外一个元素\\(z&#39;\\)替代了，且\\(z&#39;\\le\r\n\\dfrac{z}{1+\\epsilon/2n}\\)，因此有\\(\\dfrac{y}{(1+\\epsilon/2n)^{i}}=z&#39;\\le\\dfrac{y}{(1+\\epsilon/2n)^{i-1}}\\le\r\nz\\le y\\)。那么\\(z&#39;\\)在\\(L_i\\)的存在说明\\(y\\)也满足题目条件，原结论成立。\r\n考虑\\(P_{i-1}+x_i\\)的元素，题目中的假设说明了\\(P_{i-1}\\)中所有不超过\\(t\\)的所有元素\\(y\\)，其中令\\(y=y&#39;+x_i\\)，那么在\\(L_{i-1}\\)必定存在\\(z&#39;\\)，使得\r\n\r\n\\[\\dfrac{y&#39;}{(1+\\epsilon/2n)^{i-1}}\\le\r\nz&#39;\\le y&#39;\\qquad(1)\\]\r\n对不等式\\((1)\\)中第一项添加\\(\\dfrac{x_i}{(1+\\epsilon/2n)^{i-1}}\\)，第二、三项添加\\(x_i\\)，可见该不等式仍然成立：\r\n\\[\\dfrac{y&#39;+x_i}{(1+\\epsilon/2n)^{i-1}}\\le\r\nz&#39;+x_i\\le y&#39;+x_i\\qquad(2)\\]\r\n在第3行对MERGE-LISTS调用后，\\(L_{i-1}+x_i\\)将会产生一个元素\\(z=z&#39;+x_i\\)，并将其添加到\\(L_i\\)中。接下来考察\\(z\\)是否会被第4行TRIM的调用过程中被另外一个元素替代。如果\\(z\\)没有被替代，那么由不等式\\((2)\\)可以得到\\(\\dfrac{y}{(1+\\epsilon/2n)^{i-1}}\\le z\\le\r\ny\\)。同样的，可以得到\\(\\dfrac{y}{(1+\\epsilon/2n)^{i}}\\le\\dfrac{y}{(1+\\epsilon/2n)^{i-1}}\\le\r\nz\\le y\\)，因此原结论成立。如果\\(z\\)被替代了，那么必定是被某个元素\\(z&#39;&#39;\\)替代了，且\\(z&#39;&#39;\\le\r\n\\dfrac{z}{1+\\epsilon/2n}\\)，因此有\\(\\dfrac{y}{(1+\\epsilon/2n)^{i}}=z&#39;&#39;\\le\\dfrac{y}{(1+\\epsilon/2n)^{i-1}}\\le\r\nz\\le y\\)。那么\\(z&#39;&#39;\\)在\\(L_i\\)的存在说明\\(y\\)也满足题目条件，原结论成立。\r\n最终原结论是成立的。\r\n35.5-3\r\n令\\(f(x)=\\left(1+\\dfrac{\\epsilon}{2x}\\right)^x\\)，考虑\\(\\dfrac{df(x)}{dx}\\)，有\r\n\\(\\begin{aligned}\r\n\\ln f(x) &amp;= x\\ln \\left(1+\\dfrac{\\epsilon}{2x}\\right)\\\\\r\n\\dfrac{d\\ln f(x)}{dx} &amp;=\\ln \\left(1+\\dfrac{\\epsilon}{2x}\\right)-\r\n\\dfrac{\\epsilon}{\\epsilon+2x}\\\\\r\n\\dfrac{df(x)}{dx}\\cdot\\dfrac{1}{f(x)}&amp;=\\ln\r\n\\left(1+\\dfrac{\\epsilon}{2x}\\right)- \\dfrac{\\epsilon}{\\epsilon+2x}\\\\\r\n\\dfrac{df(x)}{dx}&amp;=f(x)\\cdot\\left(\\ln\r\n\\left(1+\\dfrac{\\epsilon}{2x}\\right)-\r\n\\dfrac{\\epsilon}{\\epsilon+2x}\\right)\r\n\\end{aligned}\\)\r\n由于\\(\\epsilon,x&gt;0\\)，因此有\\(\\ln \\left(1+\\dfrac{\\epsilon}{2x}\\right)-\r\n\\dfrac{\\epsilon}{\\epsilon+2x}\\ge\r\n\\dfrac{\\epsilon}{2x}-\\dfrac{\\epsilon}{\\epsilon+2x}&gt;0\\)。\r\n由于\\(f(x)&gt;0\\)，因此\\(\\dfrac{df(x)}{dx}&gt;0\\)，原结论成立。\r\n35.5-4\r\n只需要将整个过程进行的过程求“补”即可，相当于是在删或不删子集中的元素\\(x_i\\)。在每步的最后迭代中，将小于\\(t\\)的元素全部删除即可。\r\n修改后的算法由TRIM'和APPROX-SUBSET-SUM'给出。对算法APPROX-SUBSET-SUM'的性能分析和APPROX-SUBSET-SUM完全相同。\r\nTRIM&#x27;(L, δ)  let m be the length of L  L&#x27; = [y_1]  last = y_1  for i = 2 to m  if y_i &lt; last / (1 + δ)    append y_i onto the end of L&#x27;    last = y_i  return L&#x27;APPROX-SUBSET-SUM&#x27;(S, n, t, ϵ)  s = 0  for i = 1 to n    s = s + x_i  L_0 = [s]  for i = 1 to n    // MERGE-LISTS&#x27;优先选较大值进行合并    L_i = MERGE-LISTS&#x27;(L_&#123;i-1&#125;, L_&#123;i-1&#125; - x_i)    L_i = TRIM&#x27;(Li, ϵ/2n)    remove from L_i every element that is smaller than t  let z* be the smallest value in L_n  return z*\r\n35.5-5\r\n基本思想是，为\\(L_i\\)中的每个子集和\\(s\\)添加一个新的数据\\(p\\)，用于表示它之前是从子集和中\\(p\\)得到的，也即是说，将某个子集和为\\(p\\)的某个子集添加了一个元素\\(p-s\\)，从而达到了子集和\\(s\\)。\r\n最终取到最大的\\(s\\)后，访问其对应的\\(p\\)，并对\\(s\\)值减去\\(p\\)，直到最终\\(s=0\\)时，构造出了一个和为\\(z^{\\ast}\\)的子集。\r\n由于只是多维护了一组数据，因此这个算法和APPROX-SUBSET-SUM是一样的。\r\n具体过程由APPROX-SUBSET-SUM'', TRIM''给出。\r\nTRIM&#x27;&#x27;(L, δ)  let m be the length of L  L&#x27; = [y_1]  last = y_1.s  for i = 2 to m  if y_i.s &gt; last · (1 + δ)    append y_i onto the end of L&#x27;    last = y_i.s  return L&#x27;APPROX-SUBSET-SUM&#x27;(S, n, t, ϵ)  let o be a new object  o.p = -1  o.s = 0  L_0 = [o]  for i = 1 to n    // MERGE-LISTS&#x27;&#x27;和MERGE-LISTS的操作一致，仅仅是对对象的$s$属性进行比较。    let L&#x27; be a new array    for j = 1 to L_&#123;i-1&#125;.size      let o be a new object      o.s = L_&#123;i-1&#125;[j].s + x_i      o.p = L_&#123;i-1&#125;[j].s      INSERT(L&#x27;, o)    L_i = MERGE-LISTS&#x27;&#x27;(L_&#123;i-1&#125;, L&#x27;)    L_i = TRIM&#x27;&#x27;(Li, ϵ/2n)    remove from L_i every element that the attribute of s is smaller than t  z* = L_n[L_n.size].s  let A be a new array  for i = L_n.size down to 2    if z* == L_n[i].s      INSERT(A, z* - L_n[i].p)      z* = L_n[i].p  return A\r\n","categories":["算法导论"]},{"title":"算法导论4.7 Exercises 答案","url":"/introduction-to-algorithms/chapter-4/exercises-7/","content":"\r\n\\(\\star\\)\r\n4.7-1\r\n考虑使用归纳法的思想进行证明。\r\n假设\\(\\exists n_0,\\forall n \\in\r\n(0,n_0]\\)，构造出一个函数\\(T&#39;(n)\\)使得\\(T&#39;(n)=cT(n)\\)都成立。考虑证明\\(\\forall n\\in\r\n(0,+\\infty),T&#39;(n)=cT(n)\\)都成立。\r\n令\\(\\displaystyle{b = \\min_{i=1}^k\r\nb_i}\\)。当\\(n&gt;\r\nn_0\\)时，假设\\(\\forall\r\nm\\in(0,n/b]\\)时，\\(T&#39;(m)=cT(m)\\)都成立，那么对于\\(\\forall n\\in(n/b,n]，\\)有\r\n\\(\\begin{aligned}\r\nT&#39;(n) &amp;= cf(n)+\\sum_{i=1}^k a_iT&#39;(n/b_i)\\\\\r\n&amp;= cf(n)+\\sum_{i=1}^k cT(n/b_i)\\\\\r\n&amp;= c\\left(f(n)+\\sum_{i=1}^k T(n/b_i)\\right)\\\\\r\n&amp;=cT(n)\r\n\\end{aligned}\\)\r\n因此根据归纳法，\\(\\forall n\\in\r\n(0,+\\infty),T&#39;(n)=cT(n)\\)都成立。\r\n4.7-2\r\n首先证明\\(f(n)=n^2\\)满足多项式增长条件。化简\\(f(n)/d\\le f(\\varPsi n)\\le\r\ndf(n)\\)，得到两个不等式：\\(d\\ge\r\n\\dfrac{1}{\\varPsi^2},d\\ge \\varPsi^2\\)。取\\(d(\\varPsi)=\\sqrt{\\varPsi}\\)。如果\\(\\forall 1 \\le \\varPsi\\le\r\n\\phi\\)，不等式\\(d\\ge\r\n\\dfrac{1}{\\varPsi^2},d\\ge \\varPsi^2\\)都成立，那么\\(d\\)需要满足\\(d\\ge\r\n\\phi^2\\)。此时令\\(d\\)有关于\\(\\phi\\)的函数\\(D(\\phi)=\\phi^2\\)，\\(d\\)值存在并且仅依赖于\\(\\phi\\)，因此函数\\(f(n)=n^2\\)是满足多项式增长条件。\r\n接下来证明\\(f(n)=2^n\\)不满足多项式增长条件。化简\\(f(n)/d\\le f(\\varPsi n)\\le\r\ndf(n)\\)，得到两个不等式：\\(d\\ge\r\n2^{(1-\\varPsi)n},d\\ge 2^{(\\varPsi-1)n}\\)。如果\\(\\forall 1 \\le \\varPsi\\le\r\n\\phi\\)，不等式\\(d\\ge\r\n2^{(1-\\varPsi)n},d\\ge 2^{(\\varPsi-1)n}\\)都成立，那么\\(d\\)需要满足\\(d\\ge\r\n2^{(\\phi-1)n}\\)。由于确定好\\(d\\)值后，总能存在足够大的\\(n\\)，使得不等式\\(d\\ge 2^{(\\phi-1)n}\\)不成立。因此函数\\(f(n)=2^n\\)不满足多项式增长条件。\r\n4.7-3\r\n由于\\(f(n)\\)满足多项式增长条件，因此可以构造出一组\\((d_0,\\phi_0,\\hat{n})\\)，其中\\(d_0&gt; 1,\\phi_0 \\ge\r\n1,\\hat{n}&gt;0\\)，使得\\(\\forall n\\ge\r\n\\hat{n}\\)，都有\\(f(n)/d_0\\le f(\\phi_0\r\nn)\\le d_0f(n)\\)成立。\r\n那么得到\\(d_0f(n)\\ge\r\nf(n)/d_0\\)，即\\(f(n)\\cdot\\left(d_0-\\dfrac{1}{d_0}\\right)\\ge\r\n0\\)。由于\\(d_0&gt;1\\)，那么\\(d_0-\\dfrac{1}{d_0}&gt;0\\)，从而得到\\(f(n)\\ge 0\\)。\r\n那么构造出的这一组\\((d_0,\\phi_0,\\hat{n})\\)说明\\(\\forall n\\ge \\hat{n},f(n)\\ge\r\n0\\)都成立，因此\\(f(n)\\)是渐进为正的。\r\n\\(\\star\\)\r\n4.7-4\r\n构造\\(f(n)=n-\\lfloor\r\nn\\rfloor\\)。可以发现\\(f(\\Theta(n))=\\Theta(f(n))=\\Theta(1)\\)。\r\n接下来证明\\(f(n)\\)不满足多项式增长条件。化简\\(f(n)/d\\le f(\\varPsi n)\\le\r\ndf(n)\\)，得到两个不等式：\\(d\\ge\r\n\\dfrac{n-\\lfloor n\\rfloor}{\\varPsi n-\\lfloor\\varPsi n\\rfloor},d\\ge\r\n\\dfrac{\\varPsi n-\\lfloor\\varPsi n\\rfloor}{n-\\lfloor\r\nn\\rfloor}\\)。\r\n对于某个固定的\\(\\phi=\\phi_0\\)，此时\\(d=d_0\\)应该是个定值，那么考虑某个无理数\\(\\varPsi_0\\le \\phi_0\\)。对于所有正整数\\(n\\)，当\\(m\\)从右向左无限趋近于\\(n\\)时，\\(\\dfrac{\\varPsi_0 m-\\lfloor\\varPsi_0\r\nm\\rfloor}{m-\\lfloor m\\rfloor}\\)将趋向于无穷大（因为\\(\\varPsi_0\\)是无理数，分子\\(\\varPsi_0 m-\\lfloor\\varPsi_0\r\nm\\rfloor\\)必定不会趋向于\\(0\\)）。\r\n也就是说，存在无穷多个足够大的\\(m\\)，使得不等式\\(d_0\\ge\\max\\left\\{ \\dfrac{n-\\lfloor\r\nn\\rfloor}{\\varPsi n-\\lfloor\\varPsi n\\rfloor}, \\dfrac{\\varPsi\r\nn-\\lfloor\\varPsi n\\rfloor}{n-\\lfloor\r\nn\\rfloor}\\right\\}\\)不成立。因此，\\(f(n)\\)不满足多项式增长条件。\r\n4.7-5\r\na\r\n由于\\(\\displaystyle{\\sum_{i=1}^k\r\n\\dfrac{a_i}{b_i}=\\dfrac{1}{2}+\\dfrac{1}{3}+\\dfrac{1}{6}=1}\\)，因此\\(p=1\\)。并且由于\\(f(n)=n\\lg n\\)。那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=\\Theta\\left(n^p\\left(1+\\int_{1}^n\r\n\\dfrac{f(x)}{x^{p+1}}dx\\right)\\right) \\\\\r\n&amp;=\\Theta\\left(n\\left(1+\\int_{1}^n \\dfrac{\\lg x}{x}dx\\right)\\right)\r\n\\\\\r\n&amp;=\\Theta\\left(n\\left(1+\\left(\\left.\\dfrac{\\ln^2 x}{2\\ln\r\n2}\\right|_{1}^n\\right)\\right)\\right) \\\\\r\n&amp;=\\Theta\\left(n\\left(1+\\dfrac{\\ln^2n}{2\\ln 2}\\right)\\right) \\\\\r\n&amp;=\\Theta(n\\lg ^2n)\r\n\\end{aligned}\\)\r\nb\r\n由于\\(\\displaystyle{\\sum_{i=1}^k\r\n\\dfrac{a_i}{b_i}=\\dfrac{3}{3}+\\dfrac{8}{4}=3}\\)，因此\\(p&gt;1\\)。如果精确解方程\\(\\displaystyle{\\sum_{i=1}^k\r\n\\dfrac{a_i}{b_i^p}=1}\\)，那么可以得到\\(p\\approx1.856738\\)。并且由于\\(f(n)=n^2/ \\lg n\\)。那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=\\Theta\\left(n^p\\left(1+\\int_{1}^n\r\n\\dfrac{f(x)}{x^{p+1}}dx\\right)\\right) \\\\\r\n&amp;=\\Theta\\left(n^p\\left(1+\\int_{1}^n \\dfrac{x^{1-p}}{\\lg\r\nx}dx\\right)\\right) \\\\\r\n\\end{aligned}\\)\r\n可以发现，直接使用Akra-Bazzi方法并不可行。\r\n考虑使用普通的代入法求出。由于\\(T(n)=3T(n/3)+8T(n/4)+n^2/\\lg n\\ge n^2/\\lg\r\nn\\)，因此有\\(T(n)=\\Omega(n^2/\\lg\r\nn)\\)。\r\n假设\\(T(n)\\le cn^2/\\lg\r\nn\\)，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=3T(n/3)+8T(n/4)+n^2/\\lg n\\\\\r\n&amp;\\le \\dfrac{c n^2}{3\\lg (n/2)}+\\dfrac{c n^2}{2\\lg\r\n(n/4)}+\\dfrac{n^2}{\\lg n}\\\\\r\n&amp;\\le \\dfrac{c n^2}{3\\lg (n/4)}+\\dfrac{c n^2}{2\\lg\r\n(n/4)}+\\dfrac{n^2}{\\lg (n/4)}\\\\\r\n&amp;= \\left(\\dfrac{5c}{6}+1\\right) \\dfrac{n^2}{\\lg n - 2}\\\\\r\n&amp;\\le \\left(\\dfrac{5c}{6}+1\\right) \\dfrac{n^2}{0.9\\lg\r\nn}&amp;\\qquad(A)\\\\\r\n&amp;=\\left(\\dfrac{25c}{27}+\\dfrac{10}{9}\\right) \\dfrac{n^2}{\\lg n}\\\\\r\n&amp;\\le \\dfrac{cn^2}{\\lg n} &amp;\\qquad(B)\\\\\r\n\\end{aligned}\\)\r\n其中，步骤\\((A)\\)假设了\\(\\lg n-2\\ge 0.9\\lg n\\)，即\\(n\\ge 2^{20}\\)，实际上不需要\\(0.9\\)，只需要这个数大于\\(5/6\\)且小于\\(1\\)即可。步骤\\((B)\\)假设了\\(\\dfrac{25c}{27}+\\dfrac{10}{9}\\le\r\nc\\)，即\\(c\\ge 15\\)。\r\n因此如果满足\\(c\\ge\r\n15\\)的基础上，\\(\\forall\r\nn&lt;2^{20}\\)，都有\\(c\\ge\r\n\\dfrac{T(n)\\lg n}{n^2}\\)。那么由数学归纳法，可以得到\\(T(n)=O(n^2/\\lg n)\\)。\r\n最终有\\(T(n)=\\Theta(n^2/\\lg\r\nn)\\)。遗憾的是，仍未知如何改变递推式的形式使其可以直接使用Akra-Bazzi方法。\r\nc\r\n由于\\(\\displaystyle{\\sum_{i=1}^k\r\n\\dfrac{a_i}{b_i}=\\dfrac{4}{9}}\\)，因此\\(p&lt;1\\)。如果精确解方程\\(\\displaystyle{\\sum_{i=1}^k\r\n\\dfrac{a_i}{b_i^p}=1}\\)，那么可以得到\\(p=0\\)。并且由于\\(f(n)=\\lg n\\)。那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=\\Theta\\left(n^p\\left(1+\\int_{1}^n\r\n\\dfrac{f(x)}{x^{p+1}}dx\\right)\\right) \\\\\r\n&amp;=\\Theta\\left(1+\\int_{1}^n \\dfrac{\\lg x}{x}dx\\right)\\\\\r\n&amp;=\\Theta\\left(1+\\left(\\left.\\dfrac{\\ln^2 x}{2\\ln\r\n2}\\right|_{1}^n\\right)\\right)\\\\\r\n&amp;=\\Theta\\left(1+\\dfrac{\\ln^2n}{2\\ln 2}\\right) \\\\\r\n&amp;=\\Theta(\\lg ^2 n)\r\n\\end{aligned}\\)\r\nd\r\n由于\\(\\displaystyle{\\sum_{i=1}^k\r\na_i=\\dfrac{1}{3}}\\)，因此\\(p&lt;0\\)。如果精确解方程\\(\\displaystyle{\\sum_{i=1}^k\r\n\\dfrac{a_i}{b_i^p}=1}\\)，那么可以得到\\(p=-1\\)。并且由于\\(f(n)=1/n\\)。那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=\\Theta\\left(n^p\\left(1+\\int_{1}^n\r\n\\dfrac{f(x)}{x^{p+1}}dx\\right)\\right) \\\\\r\n&amp;=\\Theta\\left(n^{-1}\\left(1+\\int_{1}^n \\dfrac{1}{x}dx\\right)\\right)\r\n\\\\\r\n&amp;=\\Theta\\left(n^{-1}\\left(1+\\left(\\left.\\ln\r\nx\\right|_{1}^n\\right)\\right)\\right) \\\\\r\n&amp;=\\Theta\\left(n^{-1}\\left(1+\\ln n\\right)\\right) \\\\\r\n&amp;=\\Theta\\left(\\dfrac{\\lg n}{n}\\right)\r\n\\end{aligned}\\)\r\ne\r\n由于\\(\\displaystyle{\\sum_{i=1}^k\r\n\\dfrac{a_i}{b_i}=3}\\)，因此\\(p&gt;1\\)。如果精确解方程\\(\\displaystyle{\\sum_{i=1}^k\r\n\\dfrac{a_i}{b_i^p}=1}\\)，那么可以得到\\(p=3\\)。并且由于\\(f(n)=n^2\\)。那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=\\Theta\\left(n^p\\left(1+\\int_{1}^n\r\n\\dfrac{f(x)}{x^{p+1}}dx\\right)\\right) \\\\\r\n&amp;=\\Theta\\left(n^{3}\\left(1+\\int_{1}^n \\dfrac{1}{x^2}dx\\right)\\right)\r\n\\\\\r\n&amp;=\\Theta\\left(n^{3}\\left(1+\\left(\\left.-\\dfrac{1}{x^2}\\right|_{1}^n\\right)\\right)\\right)\r\n\\\\\r\n&amp;=\\Theta\\left(n^{3}\\left(2-\\dfrac{1}{n^2}\\right)\\right) \\\\\r\n&amp;=\\Theta\\left(n^3\\right)\r\n\\end{aligned}\\)\r\n\\(\\star\\)\r\n4.7-6\r\n证明的过程将由两部分组成：先证明\\(n_0=1\\)时的情况，再通过\\(n_0=1\\)时的情况推广到\\(n_0&gt;1\\)时的情况。由于第二部分的证明过程和定理4.4的证明过程完全相同，因此此处只使用Akra-Bazzi方法证明第一部分。\r\n连续主定理中，子问题只有一个项。因此解方程\\(\\dfrac{a}{b^p}=1\\)，得到\\(p=\\log_b\r\na\\)。接下来同样地分三种情况进行考虑。\r\n1\r\n证明如果\\(\\exists\r\n\\epsilon&gt;0,f(n)=O(n^{\\log_b a-\\epsilon})\\)，那么\\(T(n)=\\Theta(n^{\\log_b a})\\)。\r\n由于此处假定了\\(n_0=1\\)，因此\\(\\exists c&gt;0,\\forall n\\ge 1,f(n)\\le cn^{\\log_b\r\na-\\epsilon}\\)成立。那么代入\r\n\\(\\begin{aligned}\r\nn^p\\left(1+\\int_{1}^n \\dfrac{f(x)}{x^{p+1}}dx\\right)&amp;\\le n^{\\log_b\r\na}\\left(1+\\int_1^n\\dfrac{cx^{\\log_b a-\\epsilon}}{x^{\\log_b\r\na+1}}dx\\right)\\\\\r\n&amp;= n^{\\log_b a}\\left(1+\\int_1^n cx^{-\\epsilon-1}dx\\right)\\\\\r\n&amp;= n^{\\log_b\r\na}\\left(1+c\\left(\\left.\\dfrac{x^{-\\epsilon}}{-\\epsilon}\\right|_{1}^{n}\\right)\\right)\\\\\r\n&amp;= n^{\\log_b a}\\left(1+\\dfrac{c}{\\epsilon}(1-n^{-\\epsilon})\\right)\\\\\r\n&amp;= n^{\\log_b a}(1+O(1))\\\\\r\n\\end{aligned}\\)\r\n因此有\\(T(n)=O(n^{\\log_b\r\na})\\)。注意这里不使用\\(\\Theta\\)符号，因为前面进行了放缩。\r\n再根据\\(\\displaystyle{n^p\\left(1+\\int_{1}^n\r\n\\dfrac{f(x)}{x^{p+1}}dx\\right)\\ge n^p}\\)，那么得到\\(T(n)=\\Omega(n^{\\log_b a})\\)。\r\n最终得到\\(T(n)=\\Theta(n^{\\log_b\r\na})\\)。\r\n2\r\n证明如果\\(k\\ge 0,f(n)=\\Theta(n^{\\log_b\r\na}\\lg^k n)\\)，那么\\(T(n)=\\Theta(n^{\\log_b a} \\lg^{k+1}\r\nn)\\)。\r\n那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=\\Theta\\left(n^p\\left(1+\\int_{1}^n\r\n\\dfrac{f(x)}{x^{p+1}}dx\\right)\\right)\\\\\r\n&amp;=\\Theta\\left(n^{\\log_b a}\\left(1+\\Theta\\left(\\int_{1}^n\r\n\\dfrac{f(x)}{x^{\\log_b a+1}}dx\\right)\\right)\\right)\\\\\r\n&amp;=\\Theta\\left(n^{\\log_b a}\\left(1+\\Theta\\left(\\int_{1}^n\r\n\\dfrac{x^{\\log_b a}\\lg^{k} x}{x^{\\log_b a+1}}dx\\right)\\right)\\right)\\\\\r\n&amp;=\\Theta\\left(n^{\\log_b a}\\left(1+\\Theta\\left(\\int_{1}^n\r\n\\dfrac{\\lg^{k} x}{x}dx\\right)\\right)\\right)\\\\\r\n&amp;=\\Theta\\left(n^{\\log_b a}\\left(1+\\Theta\\left(\\ln 2\\cdot\\int_{1}^n\r\n\\lg^{k} x d\\lg x\\right)\\right)\\right)\\\\\r\n&amp;=\\Theta\\left(n^{\\log_b\r\na}\\left(1+\\Theta\\left(\\lg^{k+1}x\\right)\\right)\\right)\\\\\r\n&amp;=\\Theta\\left(n^{\\log_b a}\\left(1+\\lg^{k+1}x\\right)\\right)\\\\\r\n&amp;=\\Theta\\left(n^{\\log_b a}\\lg^{k+1}x\\right)\\\\\r\n\\end{aligned}\\)\r\n3\r\n这一部分的证明沿用引理4.2，引理4.3的证明，证明步骤完全一致，此处忽略。\r\n最终，将如上结论代入定理4.4中的推广到\\(n_0&gt;1\\)的情况，整个证明完成。\r\n","categories":["算法导论"]},{"title":"算法导论4.5 Exercises 答案","url":"/introduction-to-algorithms/chapter-4/exercises-5/","content":"\r\n4.5-1\r\na\r\n\\(a=2,b=4,f(n)=1,\\log _b\r\na=\\dfrac{1}{2}\\)\r\n因此根据第一个条件，\\(T(n)=\\Theta(n^{\\frac{1}{2}})=\\Theta(\\sqrt{n})\\)\r\nb\r\n\\(a=2,b=4,f(n)=\\sqrt{n},\\log _b\r\na=\\dfrac{1}{2}\\)\r\n因此根据第二个条件，得到\\(k=0\\)，最终\\(T(n)=\\Theta(n^{\\frac{1}{2}}\\lg ^1\r\nn)=\\Theta(\\sqrt{n}\\cdot \\lg n)\\)\r\nc\r\n\\(a=2,b=4,f(n)=\\sqrt{n}\\lg^2 n,\\log _b\r\na=\\dfrac{1}{2}\\)\r\n因此根据第二个条件，得到\\(k=2\\)，最终\\(T(n)=\\Theta(n^{\\frac{1}{2}}\\lg ^3\r\nn)=\\Theta(\\sqrt{n}\\cdot \\lg^3 n)\\)\r\nd\r\n\\(a=2,b=4,f(n)=n,\\log _b\r\na=\\dfrac{1}{2}\\)\r\n因此根据第三个条件，可以构造出\\(c=\\dfrac{1}{2}\\)，最终\\(T(n)=\\Theta(n)\\)\r\ne\r\n\\(a=2,b=4,f(n)=n^2,\\log _b\r\na=\\dfrac{1}{2}\\)\r\n因此根据第三个条件，可以构造出\\(c=\\dfrac{1}{8}\\)，最终\\(T(n)=\\Theta(n^2)\\)\r\n4.5-2\r\n新设计的算法的运行时间递推式为\\(T(n)=aT(n/4)+\\Theta(n^2)\\)。\r\n假设运用主定理的第一个条件，那么其时间复杂度为\\(\\Theta(n^{\\log_4\r\na})\\)。那么如果要比Strassen算法快，那么就有\\(\\log _4 a&lt;\\lg 7\\)，最终得到\\(a&lt;49\\)，即\\(a=48\\)。\r\n4.5-3\r\n\\(a=1,b=2,f(n)=\\Theta(1),\\log _b\r\na=0\\)\r\n因此根据第二个条件，得到\\(k=0\\)，最终\\(T(n)=\\Theta(n^{0}\\lg ^1 n)=\\Theta(\\lg\r\nn)\\)\r\n4.5-4\r\n化简后，问题变成证明\\(\\forall\r\nc&lt;1,\\exists n_0&gt;0,\\forall n\\ge n_0,\\lg (n/2)\\le c\\lg\r\nn\\)都不成立。\r\n即证明\\(\\forall c&lt;1,\\exists\r\nn_0&gt;0,\\forall n\\ge n_0,(1-c)\\lg n-1&gt;0\\)均成立。\r\n令\\(f(n)=(1-c)\\lg n-1\\)。那么\\(f&#39;(n)=\\dfrac{1}{(1-c)\\cdot\\ln 2\\cdot\r\nn}\\)。由于\\(1-c&gt;0\\)，因此\\(f&#39;(n)&gt;0\\)，故\\(f(n)\\)是单调递增的。\r\n那么构造出\\(n_0=\\left\\lceil2^{1/(1-c)}\\right\\rceil+1\\)，对于\\(\\forall n\\ge n_0,f(n)\\ge\r\n0\\)均成立。原结论得证。\r\n为了方便证明，假设\\(a\\ge\r\n1\\)（因为子问题的个数不能是\\(0\\sim\r\n1\\)直接的小数。）由于\\(\\epsilon &gt;\r\n0\\)，因此\\(\\lg n=o(n^{\\log _b\r\na+\\epsilon})\\)，故不满足题目中的条件。\r\n4.5-5\r\n可以发现，\\(0\\le\\lceil x\\rceil -\r\nx&lt;1\\)总成立，因此函数\\(f(n)=2^{\\lceil\\lg n\\rceil}\\)总满足\\(n\\le f(n) &lt; 2n\\)，不难发现有\\(f(n)=\\Theta(n)\\)。也就是说，存在\\(a\\ge 1,b&gt;1,\\epsilon&gt;0\\)使得\\(f(n)=\\Omega(n^{\\log _b\r\na+\\epsilon})\\)成立，即只需要满足\\(\\log_b a+\\epsilon \\le\r\n1\\)即可。由于要求\\(\\epsilon&gt;0\\)，因此只需要构造出来的\\(a&lt; b\\)即可。\r\n为证明\\(a=2,b=3\\)时不满足正则条件，那么只需要证明存在无数个充分大的\\(n,2\\cdot 2^{\\lceil \\lg n/3\\rceil}&gt;2^{\\lceil \\lg\r\nn\\rceil}\\)成立即可。\r\n经过代数转换后，最终也就是证明\\(\\lceil \\lg\r\nn-\\lg (2/3) \\rceil-\\lceil\\lg n\\rceil&gt;0\\)即可。\r\n可以发现，对于所有正整数\\(m\\)，如果正整数\\(n\\in\\left[\\dfrac{2^{m+1}}{3},2^m\\right)\\)，那么上面的不等式便成立。这样的\\(n\\)有无穷多个，并且充分大。\r\n只要\\(c\\)取的足够小（逼近但大于\\(1\\)），那么存在无数个充分大的\\(n,2\\cdot 2^{\\lceil \\lg\r\nn/3\\rceil}&gt;c\\cdot2^{\\lceil \\lg n\\rceil}\\)成立。\r\n因此，当\\(a=2,b=3\\)时，不存在\\(c&lt;1\\)使得对于所有充分大的\\(n,af(n/b)\\le\r\ncf(n)\\)都成立。此时不满足该正则条件。而\\(\\epsilon\\)仅需要满足\\(\\log_b a+\\epsilon \\le 1\\)。那么可以取\\(\\epsilon=1-\\log_3 2\\)。\r\n","categories":["算法导论"]},{"title":"算法导论4.6 Exercises 答案","url":"/introduction-to-algorithms/chapter-4/exercises-6/","content":"\r\n4.6-1\r\n\\(\\begin{aligned}\r\n\\sum_{j=0}^{\\lfloor\\log_b n\\rfloor}(\\log_b n-j)^k&amp;\\ge\r\n\\sum_{j=0}^{\\lfloor\\log_b n\\rfloor}(\\lfloor\\log_b n\\rfloor-j)^k\\\\\r\n&amp;=\\sum_{j=0}^{\\lfloor\\log_b n\\rfloor}j^k\\\\\r\n&amp;=\\Omega(\\lfloor\\log_b n\\rfloor^{k+1})\r\n\\end{aligned}\\)\r\n因此，最终有\\(\\displaystyle{\\sum_{j=0}^{\\lfloor\\log_b\r\nn\\rfloor}(\\log_b n-j)^k=\\Omega(\\log_b^{k+1} n)}\\)。\r\n\\(\\star\\)\r\n4.6-2\r\n考虑使用归纳法的思想证明。\r\n我们希望得出的结论是\\(f(n)=\\Omega(n^{\\log_b\r\na+\\epsilon})\\)，即\\(\\exists\r\nd,n_0,\\epsilon,\\forall n\\ge n_0,f(n)\\ge dn^{\\log_b\r\na+\\epsilon}\\)均成立。\r\n根据正则条件，假设\\(\\forall n\\ge n_0,\r\nf(n)\\ge \\dfrac{a}{c} f\\left(\\dfrac{n}{b}\\right)\\)成立。令\\(m=\\dfrac{n}{b}\\)，可以得到\\(f(bm)\\ge \\dfrac{a}{c} f(m)\\)，如果假设\\(m\\)也是足够大的，再联立\\(f(m)\\ge \\dfrac{a}{c}\r\nf\\left(\\dfrac{m}{b}\\right)\\)，那么可以得到\\(f(b^2m)\\ge \\left(\\dfrac{a}{c}\\right)^2\r\nf(m)\\)。最终经过多重迭代，可以得到\\(f(b^im)\\ge \\left(\\dfrac{a}{c}\\right)^i\r\nf(m)\\)，其中\\(i\\)是一个正整数。\r\n任意指定好\\(n_0\\)的值后（可以随意指定，如\\(n_0=1\\)），令\\(d\\)为函数\\(g(n)=\\dfrac{f(n)}{n^{\\log_b\r\na+\\epsilon}}\\)在区间\\([n_0,b\\cdot\r\nn_0)\\)上的最小值，那么我们构造除了一组\\((n_0,d)\\)，对于\\(\\forall n\\in[n_0,b\\cdot n_0),f(n)\\ge dn^{\\log_b\r\na+\\epsilon}\\)均成立。\r\n那么考虑\\(n&gt;b\\cdot\r\nn_0\\)时的情况。可以发现每一个\\(n\\)都可以写成\\(n=x\\cdot b^i\\)，其中\\(i\\)是一个正整数，\\(x\\in[n_0,b\\cdot n_0)\\)。那么有\\(f(n)\\ge\r\n\\left(\\dfrac{a}{c}\\right)^if(x)\\)。那么由于\\(f(x)\\ge dx^{\\log_b\r\na+\\epsilon}\\)成立。那么有接下来的变化：\r\n\\(\\begin{aligned}\r\nf(n) &amp;\\ge \\left(\\dfrac{a}{c}\\right)^if(x)\\\\\r\n&amp;\\ge \\left(\\dfrac{a}{c}\\right)^i dx^{\\log_b a+\\epsilon}\\\\\r\n&amp;=\\left(\\dfrac{a}{c}\\right)^i d\\left(\\dfrac{n}{b^i}\\right)^{\\log_b\r\na+\\epsilon}\\\\\r\n&amp;=d \\cdot \\dfrac{n^{\\log_b a+\\epsilon}}{a^i\\cdot b^{i\\epsilon}}\\\\\r\n&amp;=d \\cdot \\dfrac{n^{\\log_b a+\\epsilon}}{c^i\\cdot b^{i\\epsilon}}\\\\\r\n&amp;= d \\cdot n^{\\log_b a+\\epsilon} &amp; \\qquad(A)\r\n\\end{aligned}\\)\r\n其中步骤\\((A)\\)将\\(\\epsilon\\)构造除了满足\\(c^i\\cdot\r\nb^{i\\epsilon}=1\\)的值，对于所有\\(i\\)第成立。这个值为\\(\\epsilon=-\\log_b c\\)。\r\n那么，我们构造出了一组值\\(n_0,d,\\epsilon\\)，使得\\(\\forall n\\ge n_0,f(n)\\ge dn^{\\log_b\r\na+\\epsilon}\\)都成立。即有\\(f(n)=\\Omega(n^{\\log_b a+\\epsilon})\\)。\r\n\\(\\star\\)\r\n4.6-3\r\n本题需要基于一个假设才能运算：\\(n\\)不是\\(b\\)的整数次幂，否则\\(g(n)=+\\infty\\)。原因如下：\r\n如果\\(n\\)是\\(b\\)的整数次幂，那么\\(\\lfloor\\log_b n\\rfloor=\\log_b n\\)。\\(g(n)\\)中的最后一项是\\(a^{\\lfloor\\log_b\r\nn\\rfloor}\\left(\\dfrac{n}{b^{\\lfloor\\log_b n\\rfloor}}\\right)^{\\log_b\r\na}\\lg^{-1}\\left(\\dfrac{n}{b^{\\lfloor\\log_b\r\nn\\rfloor}}\\right)\\)，化简后得到\\(a^{\\log_b n}\\lg^{-1}(1)\\)。注意\\(\\lg^{-1}(1)=+\\infty\\)。因此，本题需要有开头的那段假设才能进行。\r\n如果\\(n\\)不是\\(b\\)的整数次幂，那么有\r\n\\(\\begin{aligned}\r\ng(n)&amp;=\\Theta\\left(\\sum_{j=0}^{\\lfloor\\log_b n\\rfloor}\r\na^j\\left(\\dfrac{n}{b^j}\\right)^{\\log_b\r\na}\\lg^{-1}\\left(\\dfrac{n}{b^j}\\right)\\right)\\\\\r\n&amp;=\\Theta \\left(n^{\\log_b a}\\sum_{j=0}^{\\lfloor\\log_b n\\rfloor}\r\n\\dfrac{a^j}{b^{j\\log_b a}}\\lg^{-1}\\left(\\dfrac{n}{b^j}\\right)\\right)\\\\\r\n&amp;=\\Theta \\left(n^{\\log_b a}\\sum_{j=0}^{\\lfloor\\log_b n\\rfloor}\r\n\\lg^{-1}\\left(\\dfrac{n}{b^j}\\right)\\right)\\\\\r\n&amp;=\\Theta \\left(n^{\\log_b a}\\sum_{j=0}^{\\lfloor\\log_b n\\rfloor}\r\n\\left(\\dfrac{\\log_b (n/b^j)}{\\log_b 2}\\right)^{-1}\\right)\\\\\r\n&amp;=\\Theta \\left(n^{\\log_b a}\\sum_{j=0}^{\\lfloor\\log_b n\\rfloor}\r\n\\dfrac{\\log_b 2}{\\log_b n-j}\\right)\\\\\r\n&amp;=\\Theta \\left(n^{\\log_b a}\\cdot \\log_b\r\n2\\cdot\\sum_{j=0}^{\\lfloor\\log_b n\\rfloor} \\dfrac{1}{\\log_b n-j}\\right)\\\\\r\n&amp;=\\Theta \\left(n^{\\log_b a}\\sum_{j=0}^{\\lfloor\\log_b n\\rfloor}\r\n\\dfrac{1}{\\log_b n-j}\\right)\\\\\r\n\\end{aligned}\\)\r\n接下来的问题是证明\\(\\displaystyle{\\sum_{j=0}^{\\lfloor\\log_b n\\rfloor}\r\n\\dfrac{1}{\\log_b n-j}=\\Theta(\\lg \\lg n)}\\)。\r\n首先证明\\(\\displaystyle{\\sum_{j=0}^{\\lfloor\\log_b n\\rfloor}\r\n\\dfrac{1}{\\log_b n-j}=\\Omega(\\lg \\lg n)}\\)。可以知道有：\r\n\\(\\begin{aligned}\r\n\\sum_{j=0}^{\\lfloor\\log_b n\\rfloor} \\dfrac{1}{\\log_b n-j}&amp;\\ge\r\n\\sum_{j=0}^{\\lfloor\\log_b n\\rfloor} \\dfrac{1}{\\lfloor\\log_b n\\rfloor+1\r\n-j}\\\\\r\n&amp;=\\sum_{j=1}^{\\lfloor\\log_b n\\rfloor+1} \\dfrac{1}{j}\\\\\r\n&amp;=\\ln(\\lfloor\\log_b n\\rfloor+1) + O(1) \\\\\r\n&amp;=\\Omega(\\lg \\lg n)\r\n\\end{aligned}\\)\r\n因此有\\(\\displaystyle{\\sum_{j=0}^{\\lfloor\\log_b n\\rfloor}\r\n\\dfrac{1}{\\log_b n-j}=\\Omega(\\lg \\lg n)}\\)。\r\n可以知道函数\\(\\displaystyle{f(j)=\\sum_{j=0}^{\\lfloor\\log_b\r\nn\\rfloor} \\dfrac{1}{\\log_b n-j}}\\)是一个递减函数，那么有\r\n\\(\\begin{aligned}\r\n\\sum_{j=0}^{\\lfloor\\log_b n\\rfloor} \\dfrac{1}{\\log_b n-j}&amp;\\le\r\n\\int_{-1}^{\\lfloor\\log_b n\\rfloor} \\dfrac{1}{\\log_b n-x}dx\\\\\r\n&amp;=\\left.-\\ln(\\log_b n-x)\\right|_{-1}^{\\lfloor\\log_b n\\rfloor}\\\\\r\n&amp;=\\ln(\\log_b n+1)-\\ln(\\log_b n-\\lfloor\\log_b n\\rfloor)\\\\\r\n&amp;=O(\\lg \\lg n)\r\n\\end{aligned}\\)\r\n因此有\\(\\displaystyle{\\sum_{j=0}^{\\lfloor\\log_b n\\rfloor}\r\n\\dfrac{1}{\\log_b n-j}=O(\\lg \\lg n)}\\)。\r\n最终\\(\\displaystyle{\\sum_{j=0}^{\\lfloor\\log_b n\\rfloor}\r\n\\dfrac{1}{\\log_b n-j}=\\Theta(\\lg \\lg n)}\\)得证。\r\n那么有\\(g(n)=\\Theta(n^{\\log_b a}\r\n\\cdot\\Theta(\\lg\\lg n))=\\Theta(n^{\\log_b a}\\lg\\lg n)\\)。\r\n最终，\\(T(n)=\\Theta(n^{\\log_b\r\na})+\\Theta(n^{\\log_b a}\\lg \\lg n)=\\Theta(n^{\\log_b a}\\lg \\lg\r\nn)\\)。\r\n对于以上结论，都是假定了\\(T,g\\)中所隐含的\\(n_0\\)都满足\\(n_0=1\\)。\r\n假设真正的主递推式\\(U(n)=aU(n/b)+n/\\lg\r\nn\\)，对于\\(n_0\\neq 1\\)，有\r\n\\(U(n)=\\left\\{\\begin{aligned}\r\n  &amp;\\Theta(1) &amp; &amp; \\text{if}\\quad  n&lt; n_0 \\\\\r\n  &amp;aU(n/b)+n/\\lg n &amp; &amp; \\text{if}\\quad  n\\ge n_0 \\\\\r\n\\end{aligned}\\right.\\)\r\n那么有\r\n\\(\\begin{aligned}\r\nU(n)&amp;=T(n/n_0)\\\\\r\n&amp;=\\Theta((n/n_0)^{\\log_b a})+\\Theta((n/n_0)^{\\log_b a} \\lg\\lg\r\nn/n_0)\\\\\r\n&amp;=\\Theta(n^{\\log_b a})+\\Theta(n^{\\log_b a}\\lg \\lg n)\\\\\r\n&amp;=\\Theta(n^{\\log_b a}\\lg \\lg n)\r\n\\end{aligned}\\)\r\n","categories":["算法导论"]},{"title":"算法导论5.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-5/exercises-3/","content":"\r\n5.3-1\r\n这份代码可以修改成如下：\r\nRANDOMLY-PERMUTE(A, n)  swap A[1] with A[RANDOM(1, n)]  for i = 2 to n    swap A[i] with A[RANDOM(i, n)]\r\n初始化过后，位于\\(A[1]\\)的元素是均匀从\\(n\\)个元素中产生的。因此，初始化时从i = 2开始考虑，因为此时我们已经知道，在第\\(2\\)次循环进行之前就已经保持了正确性。\r\n5.3-2\r\n不能。\r\n以\\(A[1]\\)为例，经历过第一次循环之后，\\(A&#39;[1]\\neq\r\nA[1]\\)必定成立。使用这个算法，由排列\\(\\langle\r\n1,2,4,3\\rangle\\)必定不能生成排列\\(\\langle 1,4,2,3\\rangle\\)。\r\n虽然这个算法不会生成恒等排列，但也无法生成一部分非恒等排列。\r\n5.3-3\r\n不能。\r\n根据这个随机算法，可以发现，最终会均匀生成\\(n^n\\)种结果。但是当\\(n\\ge 3\\)时，\\(n!\\nmid n^n\\)，也就是说，这\\(n^n\\)个均匀生成的结果无法均匀地分配给\\(n!\\)个排列。因此这份代码无法做到随机均匀产生排列。\r\n5.3-4\r\n对于一个特定的元素\\(i\\)，如果offset是从\\(1\\sim\r\nn\\)中均匀生成的，那么代码第4行的dest是从\\(i+1,i+2,\\dots,i+n-1,i+n\\)中均匀生成的。经过第6行的操作后，dest是从\\(i+1,i+2,\\dots,n-1,n,1,2,i-1\\)中均匀生成的，因此\\(i\\)出现在\\(B\\)的任何位置的概率都是\\(\\dfrac{1}{n}\\)。\r\n然而，这个算法仅仅是随机均匀生成了恒等排列循环右移\\(1,2,3,\\dots,n\\)个下标的排列，并非随机均匀产生所有排列。\r\n5.3-5\r\n考虑使用循环不变量证明：在值为\\(k\\)的循环完成前，集合\\(S\\)是从前\\(k-1\\)个元素中均匀取样大小为\\(k-(n-m+1)\\)的子集所得到的集合；在值为\\(k\\)的循环完成后，集合\\(S\\)是从前\\(k\\)个元素中均匀取样大小为\\(k-(n-m)\\)的子集所得到的集合。\r\n初始化：在值为\\(n-m+1\\)的循环开始前，\\(S\\)恰好为空集，从\\(n-m\\)个元素中均匀取样大小为\\(0\\)的子集为空集的概率为\\(1\\)，因为大小为\\(0\\)的子集恰好只有\\(1\\)个，因此是均匀取样的。\r\n保持：在值为\\(k\\)的循环开始前，集合\\(S\\)是从前\\(k-1\\)个元素中均匀取样大小为\\(k-(n-m+1)\\)的子集所得到的集合，每个这样的集合产生的概率为\\(\\dbinom{k-1}{k-(n-m+1)}^{-1}\\)。按照这个算法，在这一次循环中，值\\(k\\)被添加到集合\\(S\\)的概率为\\(\\dfrac{1+(k-(n-m+1))}{k}=\\dfrac{k-(n-m)}{k}\\)。最终生成一个确切含\\(k\\)的大小为\\(k-(n-m)\\)的集合的概率为\\(\\dbinom{k-1}{k-(n-m+1)}^{-1}\\cdot\r\n\\dfrac{k-(n-m)}{k}=\\dbinom{k}{k-(n-m)}^{-1}\\)。\r\n如果在这这一次循环中，并不是值\\(k\\)被添加到集合\\(S\\)，那么由于当前集合大小为\\(k-(n-m)\\)，因此有潜在的\\(k-(n-m)\\)个大小为\\(k-(n-m+1)\\)的集合，以\\(\\dfrac{1}{k}\\)的概率抽样到了一个不属于集合\\(S\\)的数添加到\\(S\\)中，从而变成现在的集合\\(S\\)。最终生成一个确切不含\\(k\\)的大小为\\(k-(n-m)\\)的集合的概率为\\((k-(n-m))\\cdot\\dbinom{k-1}{k-(n-m+1)}^{-1}\\cdot\r\n\\dfrac{1}{k}=\\dbinom{k}{k-(n-m)}^{-1}\\)。\r\n也就是说，在值为\\(k\\)的循环完成后，集合\\(S\\)是从前\\(k\\)个元素中均匀取样大小为\\(k-(n-m)\\)的子集所得到的集合。\r\n终止：最终程序停止时，集合\\(S\\)相当于是从\\(n\\)个元素中均匀取样大小为\\(m\\)的子集所得到的集合。\r\n","categories":["算法导论"]},{"title":"算法导论5.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-5/exercises-1/","content":"\r\n5.1-1\r\n如果我们可以确定排名最高的某个候选人；那么去掉这个人后，我们依旧可以确定出当前排名最高的某个候选人（也就是次高）……一直去掉最后一个人之后，那么就可以得到这些候选人的排名。\r\n由于这种好的关系具有传递性，因此可以确定出这一些候选人的全序关系。\r\n\\(\\star\\)\r\n5.1-2\r\nRANDOM(a, b)  r = b - a + 1  // beta是r的比特数。  beta = ceil(log(2, r))  while True    s = 0    for i = 0 to beta      t = RANDOM(0, 1)      s = (s &lt;&lt; 1) | t    if s &lt; r      return s + a\r\n从RANDOM(a, b)中获取随机数，相当于从a + RANDOM(0, b - a)中获取随机数。令\\(r=b-a+1,\\beta=\\lceil\\lg\r\nr\\rceil\\)。考虑生成一个\\(\\beta\\)比特数\\(s\\)，如果\\(s&lt;\r\nr\\)，那么返回\\(s+a\\)，否则重复进行即可。\r\n那么，生成一个小于\\(r\\)的\\(\\beta\\)比特数的概率为\\(\\dfrac{r}{2^\\beta}=2^{\\lg r-\\lceil\\lg\r\nr\\rceil}&gt;\\dfrac{1}{2}\\)。\r\n可以发现第4行的while循环运行次数服从参数为\\(\\dfrac{r}{2^\\beta}\\)的指数分布，因此其期望运行次数为\\(\\dfrac{2^\\beta}{r}\\)。那么，RANDOM(0, 1)的被调用期望次数为\\(\\beta\\cdot\r\n\\dfrac{2^\\beta}{r}&lt;2\\beta\\)。因此RANDOM(a, b)的时间复杂度为\\(O(\\lg(b-a))\\)。\r\n\\(\\star\\)\r\n5.1-3\r\nRANDOM()  while True    x = BIASED-RANDOM()    y = BIASED-RANDOM()    if x != y      return x\r\n在单次循环中，考虑两次调用BIASED-RANDOM()，其结果分别为\\(x,y\\)。可以发现一共有\\(4\\)种结果，分别为\\(00,01,10,11\\)，那么接下来进行的操作如下：\r\n\r\n\\(00\\)，继续进行下一次循环。\r\n\\(01\\)，返回\\(0\\)。\r\n\\(10\\)，返回\\(1\\)。\r\n\\(11\\)，继续进行下一次循环。\r\n\r\n这里用到的是输出\\(01\\)和\\(10\\)的概率都是\\(p(1-p)\\)。\r\n将这两部分的概率值相加，可以发现这个while循环运行次数服从参数为\\(2p(1-p)\\)的指数分布，因此其期望运行次数为\\(\\dfrac{1}{2p(1-p)}\\)。那么，BIASED-RANDOM的被调用期望次数为\\(\\dfrac{1}{p(1-p)}\\)。因此RANDOM的时间复杂度为\\(\\Theta\\left(\\dfrac{1}{p(1-p)}\\right)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论5.4 Exercises 答案","url":"/introduction-to-algorithms/chapter-5/exercises-4/","content":"\r\n5.4-1\r\n假设班上有其它\\(n\\)个人，其和我生日相同的人数是\\(X\\)。由于某一个人和我生日的概率是\\(p=\\dfrac{1}{365}\\)，因此\\(X\\)服从二项分布\\(b(k;n,p)=\\dbinom{n}{k}p^k(1-p)^{n-k}\\)。\r\n如果是求出\\(n\\)，使得\\(n\\)个人中和自己生日相同的概率超过\\(\\dfrac{1}{2}\\)，那么和自己都不同的概率少于\\(\\dfrac{1}{2}\\)，可以得到\\(b\\left(0;n,\\dfrac{1}{365}\\right)\\ge\r\n\\dfrac{1}{2}\\)。\r\n解方程得到\\(n\\ge \\log_{364/365}\r\n1/2\\approx252.651989\\)。\r\n因此，加上自身，班上至少有\\(254\\)个人。\r\n对于另一道题，如果班上至少两个人的生日为7月4日的概率大于等于\\(\\dfrac{1}{2}\\)，那么得到\\(1-b\\left(0;n,\\dfrac{1}{365}\\right)-b\\left(1;n,\\dfrac{1}{365}\\right)\\ge\r\n\\dfrac{1}{2}\\)。\r\n解方程得到\\(n\\ge 612.257413\\)。\r\n因此，班上至少有\\(613\\)人。\r\n5.4-2\r\n假设事件\\(B_k\\)如书上所定义的那样，表示\\(n\\)个人中，\\(k\\)个人不同生日的概率，那么得出了不等式\\(\\Pr\\{B_k\\}\\le e^{-k(k-1)/2n}\\)。\r\n解方程\\(e^{-k(k-1)/2n}\\le\r\n0.01\\)，得到\\(k\\ge (1+\\sqrt{1+(16\\ln\r\n10)n})/2\\)。代入\\(n=365\\)，得到\\(k\\ge 59\\)。即 这个班至少\\(59\\)人。\r\n令随机变量\\(X\\)表示有多少对人的生日相同，示性随机变量\\(X_{i,j}\\)表示\\(i,j\\)这两个人的生日相同。可以知道，\\(E[X_{i,j}]=\\dfrac{1}{n}\\)。那么有\r\n\\(\\begin{aligned}\r\nE[X]&amp;=E\\left[\\sum_{i=1}^{k-1} \\sum_{j=i+1}^k X_{i,j}\\right]\\\\\r\n&amp;=\\sum_{i=1}^{n-1} \\sum_{j=i+1}^k E[X_{i,j}]\\\\\r\n&amp;=\\dbinom{k}{2} \\dfrac{1}{n}\\\\\r\n&amp;\\approx 4.6877\r\n\\end{aligned}\\)\r\n5.4-3\r\n将球视为同学，将箱子视为日期数，那么问题转化成生日悖论。根据抽屉原理，最多只需要投掷\\(b+1\\)次。\r\n假设\\(X\\)是期望投掷次数，那么如果投掷\\(k\\)次时，前\\(k-1\\)次必须投掷到不同的地方，并且第\\(k\\)次投掷到这\\(k-1\\)个箱子之一，那么可以得到\\(\\Pr\\{X=k\\}=\\dfrac{\\binom{b}{k-1}}{b^{k-1}}\\cdot\r\n\\dfrac{k-1}{b}=\\dfrac{k-1}{b^k}\\dbinom{b}{k-1}\\)。\r\n那么根据定义，可以计算\\(X\\)的期望\\(E[X]\\)为\r\n\\(\\begin{aligned}\r\nE[X]&amp;=\\sum_{k=2}^{b+1}k\\Pr\\{X=k\\}\\\\\r\n&amp;=\\sum_{k=2}^{b+1}\\dfrac{k(k-1)}{b^k}\\dbinom{b}{k-1}\\\\\r\n&amp;=\\sum_{k=1}^{b}\\dfrac{k(k+1)}{b^k}\\dbinom{b}{k}\\\\\r\n&amp;=\\dfrac{(b+1)^{b-2}(3b+1)}{b^{b-1}} &amp;\\qquad(A)\r\n\\end{aligned}\\)\r\n其中，步骤\\((A)\\)得出的式子是基于将二项式定理两边求导取得的。\r\n\\(\\star\\)\r\n5.4-4\r\n两两独立即可。因为等式5.7的推导都基于条件\\(\\Pr\\{b_i=r\\land b_j= r\\}=\\Pr\\{b_i=r\\}\\cdot\r\n\\Pr\\{b_j=r\\}\\)进行，并没有考虑\\(3\\)或以上的人数的情况，因此不需要相互独立这个更强的条件。\r\n\\(\\star\\)\r\n5.4-5\r\n令随机变量\\(X\\)表示有多少个三人组，使得他们的生日相同，示性随机变量\\(X_{i,j,k}\\)表示\\(i,j,k\\)这两个人的生日相同。可以知道，\\(E[X_{i,j,k}]=\\dfrac{1}{n^2}\\)，其中\\(n=365\\)表示一年的天数。那么有\r\n\\(\\begin{aligned}\r\nE[X]&amp;=E\\left[\\sum_{i=1}^{k-2} \\sum_{j=i+1}^{k-1}\r\n\\sum_{r=j+1}^{k}  X_{i,j,r}\\right]\\\\\r\n&amp;=\\sum_{i=1}^{k-2} \\sum_{j=i+1}^{k-1}\r\n\\sum_{r=j+1}^{k}  E[X_{i,j,r}]\\\\\r\n&amp;=\\dbinom{k}{3} \\dfrac{1}{n^2}\\\\\r\n&amp;=\\dfrac{k(k-1)(k-2)}{6n^2}\r\n\\end{aligned}\\)\r\n当\\(E[X]&gt;1\\)时，就有相当的概率使得三个人同一天生日。令\\(n=365\\)，解方程\\(E[X]&gt;1\\)得到\\(k\\ge 94\\)。当这个群体至少有\\(94\\)人时即可。\r\n\\(\\star\\)\r\n5.4-6\r\n如果一个长度为\\(k\\)的字符串各个字符不相同，那么第一个字符可以拥有\\(n\\)种选择，第二个字符拥有\\(n-1\\)个选择……最终，第\\(k\\)个字符有\\(n-k+1\\)种选择。因此为了构成一个\\(k\\)阶排列的概率为\r\n\\(\\begin{aligned}\r\np&amp;=\\sum_{i=1}^k \\dfrac{n-i+1}{n}\\\\\r\n&amp;=\\dfrac{n!}{n^k(n-k)!}\r\n\\end{aligned}\\)\r\n将字符集合对应到生日天数，将字符串的每一个位置对应到每一个人，那么由此转化成了生日悖论的场景。这个问题和生日悖论相同。\r\n\\(\\star\\)\r\n5.4-7\r\n令随机变量\\(X_i\\)表示\\(n\\)次投掷后，落入第\\(i\\)个球的数量。那么\\(X_i\\)服从二项分布\\(b\\left(k;n,\\dfrac{1}{n}\\right)=\\dbinom{n}{k}\\left(\\dfrac{1}{n}\\right)^k\\left(1-\\dfrac{1}{n}\\right)^{n-k}\\)。\r\n令\\(Y\\)表示空桶的个数的期望，令示性随机变量\\(Y_i\\)表示\\(X_i=0\\)。那么可以知道\\(E[X_i]=b\\left(0;n,\\dfrac{1}{n}\\right)=\\left(1-\\dfrac{1}{n}\\right)^{n}\\)。\r\n那么有\\(\\displaystyle{E[Y]=\\sum_{i=1}^{n}\r\nE[Y_i]=\\dfrac{(n-1)^n}{n^{n-1}}}\\)。\r\n令\\(Z\\)表示只包含一个球的桶的个数的期望，令示性随机变量\\(Z_i\\)表示\\(X_i=1\\)。那么可以知道\\(E[Z_i]=b\\left(1;n,\\dfrac{1}{n}\\right)=\\left(1-\\dfrac{1}{n}\\right)^{n-1}\\)。\r\n那么有\\(\\displaystyle{E[Z]=\\sum_{i=1}^{n}\r\nE[Z_i]=\\dfrac{(n-1)^{n-1}}{n^{n-2}}}\\)。\r\n\\(\\star\\)\r\n5.4-8\r\n令\\(s=\\lg n-2\\lg\\lg\r\nn\\)。假设事件\\(A_{i,l}\\)表示事件：从第\\(i\\)个位置起，接下来所有硬币都是头部朝上。那么\\(\\Pr\\{A_{i,s}\\}=2^{2\\lg\\lg n-\\lg n}=2^{\\lg\r\n\\lg^2n-\\lg n}=\\dfrac{\\lg^2 n}{n}\\)。考虑将这一个硬币序列分成\\(n/s\\)个区间，每个区间含有\\(s\\)个硬币。\r\n假设事件\\(L\\)表示存在超过长度\\(s\\)的最长的连胜序列，\\(\\overline{L}\\)则不存在，事件\\(F\\)表示并不存在一个区间，所有硬币头部朝上。可以发现，事件\\(F\\)比事件\\(\\overline{L}\\)要强，因此\\(\\Pr\\{F\\}\\le \\Pr\\{\\overline{L}\\}\\)。\r\n考虑\\(\\Pr\\{F\\}\\)的值，那么有\r\n\\(\\begin{aligned}\r\n\\Pr\\{F\\}&amp;=\\prod_{j=1}^{n/s}(1-\\Pr\\{A_{j,s}\\})\\\\\r\n&amp;=\\left(1-\\dfrac{\\lg^2n}{n}\\right)^{n/s}\\\\\r\n&amp;\\le e^{\\frac{-\\lg^2n}{n}\\cdot\\frac{n}{s}}\\\\\r\n&amp;=e^{-\\lg^2n/s}\\\\\r\n&amp;=2^{-\\lg e\\lg ^2 n/s}\\\\\r\n&amp;=\\dfrac{1}{n^{\\lg n/s}}\\\\\r\n&amp;=\\dfrac{1}{n^{\\lg n/(\\lg n-2\\lg\\lg n)}}\\\\\r\n&amp;\\le \\dfrac{1}{n}\r\n\\end{aligned}\\)\r\n那么原来题目中所求概率为事件\\(\\Pr\\{L\\}\\)的概率值上界，那么有\r\n\\(\\begin{aligned}\r\n\\Pr\\{L\\}&amp;=1-\\Pr\\{\\overline{L}\\}\\\\\r\n&amp;\\ge 1-\\Pr\\{F\\}\\\\\r\n&amp;\\ge 1-\\dfrac{1}{n}\r\n\\end{aligned}\\)\r\n从而完成证明。\r\n","categories":["算法导论"]},{"title":"算法导论5.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-5/exercises-2/","content":"\r\n5.2-1\r\n如果只雇佣了一次，说明排名最高的候选人恰好在第一个，这样的排列一共有\\((n-1)!\\)个，因此雇佣恰好一次的概率为\\(\\dfrac{(n-1)!}{n!}=\\dfrac{1}{n}\\)。\r\n如果雇佣了\\(n\\)次，说明这个排列是按排名顺序递增的，这样的排列一共有\\(1\\)个，因此雇佣恰好一次的概率为\\(\\dfrac{1}{n!}\\)。\r\n5.2-2\r\n由于只能雇佣两次，并且第一个人是必定被雇佣的，因此这个排列只能满足以下情况：在第一位候选人和最高排名候选人之间的所有候选人的排名，必定比第一位候选人的排名低。\r\n那么，对于所有候选人而言，出现在第一位的概率都是相等的，为\\(\\dfrac{1}{n}\\)。假设第一位候选人的排名是\\(i\\)，那么对于\\(j\\le i\\)，第一位候选人是前\\(j\\)个候选人中排名最高的概率为\\(\\dfrac{1}{j}\\)，那么在第\\(j\\)个候选人后面紧接着最高排名的候选人的概率为\\(\\dfrac{1}{n-j}\\)。因此可以列出如下式子：\r\n\\(\\begin{aligned}\r\n\\sum_{i=1}^{n-1}\\dfrac{1}{n}\\cdot \\sum_{j=1}^{i} \\dfrac{1}{j} \\cdot\r\n\\dfrac{1}{n-j}&amp;=\\dfrac{1}{n}\\sum_{i=1}^{n-1} (n-i)\\cdot \\dfrac{1}{i}\r\n\\cdot \\dfrac{1}{n-i}\\\\\r\n&amp;=\\dfrac{1}{n}\\sum_{i=1}^{n-1} \\dfrac{1}{i}\\\\\r\n\\end{aligned}\\)\r\n5.2-3\r\n令\\(X_i\\)表示第\\(i\\)颗骰子投出的点数，那么总点数\\(X=X_1+X_2+\\dots+X_n\\)。\r\n不难计算出\\(E[X_i]\\)的期望为\r\n\\(\\begin{aligned}\r\nE[X_i]=\\sum_{j=1}^6 j\\cdot \\Pr\\{X_k=j\\} = 3.5\r\n\\end{aligned}\\)\r\n因此\\(\\displaystyle{E[X]=E\\left[\\sum_{i=1}^nX_i\\right] =\r\n\\sum_{i=1}^nE[X_i]= 3.5n}\\)。\r\n5.2-4\r\n令\\(X_i\\)表示第\\(i\\)个骰子投出的点数，\\(i=1,2\\)。\r\n如果两个骰子是独立的，那么有\r\n\\(\\begin{aligned}\r\nE[X_1+X_2]&amp;=\\sum_{i=1}^6\\sum_{j=1}^6 (i+j)\\Pr\\{X_1=i,X_2=j\\}\\\\\r\n&amp;=\\dfrac{1}{36}\\sum_{i=1}^6\\sum_{j=1}^6 (i+j)\\\\\r\n&amp;=7\r\n\\end{aligned}\\)\r\n如果\\(X_2=X_1\\)，可以知道样本空间中只有\\(6\\)个事件，那么有\r\n\\(\\begin{aligned}\r\nE[X_1+X_2]&amp;=E[2X_1]\\\\\r\n&amp;=2E[X_1]\\\\\r\n&amp;=2\\sum_{i=1}^6 i\\Pr\\{X_1=i\\}\\\\\r\n&amp;=7\r\n\\end{aligned}\\)\r\n如果\\(X_2=7-X_1\\)，那么\\(X=7\\)，此时\\(X_1+X_2\\)是一个常量，故\\(E[X_1+X_2]=7\\)。\r\n5.2-5\r\n令示性随机变量\\(X_i\\)表示第\\(i\\)个顾客拿到了自己的帽子，令\\(X\\)表示拿到自己的帽子的顾客数，那么有\\(X=X_1+X_2+\\dots+X_n\\)。不难发现，在\\(n\\)顶帽子中，顾客能够找到拿回自己的帽子的概率是\\(\\dfrac{1}{n}\\)，因此\\(E[X_i]=\\dfrac{1}{n}\\)。\r\n因此\\(\\displaystyle{E[X]=E\\left[\\sum_{i=1}^nX_i\\right] =\r\n\\sum_{i=1}^nE[X_i]= n\\cdot \\dfrac{1}{n}=1}\\)。\r\n5.2-6\r\n令示性随机变量\\(X_{i,j}(i&lt;\r\nj)\\)表示在一个随机排列中，数\\(i\\)排在了数\\(j\\)的前面。\r\n对于一个\\(n\\)阶全排列，可以得知有一半的全排列使得\\(i\\)在\\(j\\)后面，另一半排列则使得\\(i\\)在\\(j\\)前面。因此\\(E[X_{i,j}]=\\dfrac{1}{2}\\)。\r\n因此\\(\\displaystyle{E[X]=E\\left[\\sum_{i=1}^n\\sum_{j=i+1}^nX_{i,j}\\right]\r\n= \\sum_{i=1}^n\\sum_{j=i+1}^n E[X_{i,j}]= \\dfrac{n(n-1)}{2}\\cdot\r\n\\dfrac{1}{2}=\\dfrac{n(n-1)}{4}}\\)。\r\n","categories":["算法导论"]},{"title":"算法导论5 Problems 答案","url":"/introduction-to-algorithms/chapter-5/problems/","content":"\r\n5-1\r\na\r\n假设第\\(i\\)执行INCREMENT操作提升的计数为\\(X_i\\)。那么最终\\(n\\)次操作完成后，提升的计数为\\(X=X_1+X_2+\\dots+X_n\\)。\r\n对于任何一个计数器值\\(j\\)，有\\(\\dfrac{1}{n_{j+1}-n_j}\\)的概率提升\\(n_{j+1}-n_j\\)，有\\(1-\\dfrac{1}{n_{j+1}-n_j}\\)的概率没有任何提升，因此有\r\n\\(\\begin{aligned}\r\nE[X_i]&amp;=0\\cdot\\Pr\\{\\text{unchange}\\}+(n_{j+1}-n_j)\\cdot\\Pr\\{\\text{increase}\\}\\\\\r\n&amp;=0\\cdot\\left(1-\\dfrac{1}{n_{j+1}-n_j}\\right) + (n_{j+1}-n_j)\\cdot\r\n\\dfrac{1}{n_{j+1}-n_j}\\\\\r\n&amp;=1\r\n\\end{aligned}\\)\r\n最终消去了\\(j\\)值。\r\n因此\\(\\displaystyle{E[X]=E\\left[\\sum_{i=1}^nX_i\\right] =\r\n\\sum_{i=1}^nE[X_i]= n\\cdot 1=n}\\)。\r\nb\r\n\\(\\begin{aligned}\r\nE[X_i^2]&amp;=0\\cdot\\Pr\\{\\text{unchange}\\}+(n_{j+1}-n_j)^2\\cdot\\Pr\\{\\text{increase}\\}\\\\\r\n&amp;=0\\cdot\\left(1-\\dfrac{1}{n_{j+1}-n_j}\\right) + (n_{j+1}-n_j)^2\\cdot\r\n\\dfrac{1}{n_{j+1}-n_j}\\\\\r\n&amp;=n_{j+1}-n_j\\\\\r\n&amp;=100(j+1)-100j\\\\\r\n&amp;=100\\\\\r\n\\\\\r\n\\text{Var}[X_i]&amp;=E[X^2_i]-E^2[X_i]\\\\\r\n&amp;=100-1\\\\\r\n&amp;=99\r\n\\end{aligned}\\)\r\n由于\\(X_1,X_2,\\dots,X_n\\)是相互独立的，因此\\(\\displaystyle{\\text{Var}[X]=\\text{Var}\\left[\\sum_{i=1}^nX_i\\right]\r\n= \\sum_{i=1}^n\\text{Var}[X_i]= n\\cdot 99=99n}\\)。\r\n5-2\r\na\r\nRANDOM-SEARCH(A, n, x)  //假设FLAG是一个标志，它和A中的所有数都不相同。  c = 0  while c &lt; n    p = RANDOM(1, n)      if A[p] == x        return p    if A[p] != FLAG      A[p] = FLAG      c = c + 1  return &quot;NOT FOUND&quot;\r\nb\r\n可以发现，每一次while循环的执行过程相当于在参数为\\(\\dfrac{1}{n}\\)的指数分布中进行抽样，因此需要抽样\\(A\\)的下标的期望次数为\\(n\\)。\r\nc\r\n可以发现，每一次while循环的执行过程相当于在参数为\\(\\dfrac{k}{n}\\)的指数分布中进行抽样，因此需要抽样\\(A\\)的下标的期望次数为\\(\\dfrac{n}{k}\\)。\r\nd\r\n假设随机变量\\(X_i\\)表示仍然剩下\\(i\\)个坐标仍然未被访问时，随机访问到这\\(i\\)个坐标的期望值。那么在整个RANDOM-SEARCH的调用过程中，访问下标的总次数为\\(X=X_1+X_2+\\dots+X_n\\)。\r\n可以发现，\\(X_i\\)服从参数为\\(\\dfrac{i}{n}\\)的指数分布，因此\\(E[X_i]=\\dfrac{n}{i}\\)。因此有\\(\\displaystyle{E[X]=E\\left[\\sum_{i=1}^nX_i\\right]=\\sum_{i=1}^nE[X_i]=\\sum_{i=1}^n\\dfrac{n}{i}=n\\sum_{i=1}^n\\dfrac{1}{i}=n(\\ln\r\nn+O(1))}\\)。\r\ne\r\n由于出现的排列都是等可能的，因此\\(x\\)在每个位置出现的概率都相同，因此平均查找时间为\\(\\displaystyle{\\sum_{i=1}^n i\\cdot\r\n\\dfrac{1}{n}}=\\dfrac{n+1}{2}\\)。最坏查找时间明显为\\(n\\)。\r\nf\r\n最坏查找时间为\\(n-k+1\\)。\r\n假设示性变量\\(X_i\\)表示下标元素\\(A[i]\\)中被访问过，那么总共访问的下标数为\\(X=X_1+X_2+\\dots+X_n\\)。\r\n对于\\(A[i]\\neq x\\)的\\(i\\)，\\(A[i]\\)一定要放在\\(k\\)个\\(x\\)元素前面才能访问到，如果放在任何一个的后面，那么就会因为提前返回而无法访问，此时\\(E[X_i]=\\dfrac{1}{k+1}\\)。\r\n对于\\(A[i&#39;]=x\\)的\\(i&#39;\\)，\\(A[i&#39;]\\)一定要放在这\\(k\\)个\\(x\\)中的第一个才能被访问到，如果放在任何一个的后面，那么就会因为提前返回而无法访问，此时\\(E[X_{i&#39;}]=\\dfrac{1}{k}\\)。\r\n因此\\(\\displaystyle{E[X]=E\\left[\\sum_{i=1}^nX_i\\right] =\r\n\\sum_{i=1}^nE[X_i]= k\\cdot \\dfrac{1}{k} + (n-k)\\cdot\r\n\\dfrac{1}{k+1}=\\dfrac{n+1}{k+1}}\\)。\r\ng\r\n无论是平均还是最坏查找时间，都为\\(n\\)。\r\nh\r\n和算法DETERMINISTIC-SEARCH一样，如果\\(k=0\\)，那么无论平均还是最坏查找时间，都为\\(n\\)；如果\\(k\\ge\r\n1\\)，那么最坏查找时间为\\(n-k+1\\)，平均查找时间为\\(\\dfrac{n+1}{k+1}\\)。\r\ni\r\n使用算法DETERMINISTIC-SEARCH最好。\r\n\r\n对于算法DETERMINISTIC-SEARCH。在平均情况下，DETERMINISTIC-SEARCH的平均时间是算法RANDOM-SEARCH的一半。如果\\(A\\)不存在目标元素\\(x\\)，算法DETERMINISTIC-SEARCH能够更快地结束。\r\n对于算法of SCRAMBLE-SEARCH。与其先对数组\\(A\\)进行乱序，还不如直接像DETERMINISTIC-SEARCH那样直接查找。由于平均查找时间和最坏查找时间都一样，这个算法先对\\(A\\)乱序显得多余。\r\n\r\n","categories":["算法导论"]},{"title":"算法导论4 Problems 答案","url":"/introduction-to-algorithms/chapter-4/problems/","content":"\r\n4-1\r\na\r\n\\(a=2,b=2,f(n)=n^3,\\log _b a=1\\)\r\n因此根据第三个条件，可以构造出\\(c=\\dfrac{1}{8}\\)，最终\\(T(n)=\\Theta(n^3)\\)\r\nb\r\n\\(a=1,b=\\dfrac{11}{8},f(n)=n,\\log _b\r\na=0\\)\r\n因此根据第三个条件，可以构造出\\(c=\\dfrac{8}{11}\\)，最终\\(T(n)=\\Theta(n)\\)\r\nc\r\n\\(a=16,b=4,f(n)=n^2,\\log _b\r\na=2\\)\r\n因此根据第二个条件，得到\\(k=0\\)，最终\\(T(n)=\\Theta(n^2\\cdot \\lg n)\\)\r\nd\r\n\\(a=4,b=2,f(n)=n^2\\lg n,\\log _b\r\na=2\\)\r\n因此根据第二个条件，得到\\(k=1\\)，最终\\(T(n)=\\Theta(n^2\\cdot \\lg^2 n)\\)\r\ne\r\n\\(a=8,b=3,f(n)=n^2,\\log _b a=\\log_3\r\n8&lt;2\\)\r\n因此根据第三个条件，可以构造出\\(c=\\dfrac{8}{9}\\)，最终\\(T(n)=\\Theta(n^2)\\)\r\nf\r\n\\(a=7,b=2,f(n)=n^2\\lg n,\\log _b a=\\log_2\r\n7&gt;2\\)\r\n因此根据第一个条件，\\(T(n)=\\Theta(n^{\\lg\r\n7})\\)\r\ng\r\n\\(a=2,b=4,f(n)=\\sqrt{n},\\log _b a=\\log_4\r\n2=\\dfrac{1}{2}\\)\r\n因此根据第二个条件，得到\\(k=0\\)，最终\\(T(n)=\\Theta(\\sqrt{n}\\cdot \\lg n)\\)\r\nh\r\n令 \\(m=n\\bmod 2\\)，可以知道，\\(m\\in\\{0,1\\}\\)。\r\n那么有：\r\n\\(\\begin{aligned}\r\nT(n)&amp;=\\sum_{k=0}^{n/2} (2k+m)^2\\\\\r\n&amp;=\\sum_{k=0}^{n/2} (4k^2+4km+m^2)\\\\\r\n&amp;=\\dfrac{m^2n}{2}+\\sum_{k=0}^{n/2} (4k^2+4km)\\\\\r\n&amp;=\\dfrac{m^2n}{2}+4\\sum_{k=0}^{n/2} k^2+4m\\sum_{k=0}^{n/2} k\\\\\r\n&amp;=\\dfrac{m^2n}{2}+4\\cdot\\dfrac{n/2\\cdot(n/2+1)(n+1)}{6} +\r\n4m\\cdot\\dfrac{n/2\\cdot(n/2+1)}{2}\\\\\r\n&amp;=\\Theta(n^3)\r\n\\end{aligned}\\)\r\n4-2\r\n\\(\\begin{aligned}\r\n&amp;T_{a1}(N,n)=T_{a1}(N,n/2)+\\Theta(1)\\\\\r\n&amp;T_{a2}(N,n)=T_{a2}(N,n/2)+\\Theta(N)\\\\\r\n&amp;T_{a3}(N,n)=T_{a3}(N,n/2)+\\Theta(n)\\\\\r\n&amp;T_{b1}(N,n)=2T_{b1}(N,n/2)+\\Theta(1)+\\Theta(n)\\\\\r\n&amp;T_{b2}(N,n)=2T_{b2}(N,n/2)+\\Theta(N)\\\\\r\n&amp;T_{b3}(N,n)=2T_{b3}(N,n/2)+\\Theta(n)\\\\\r\n&amp;T_{c1}(N,n)=8T_{c1}(N,n/2)+\\Theta(1)\\\\\r\n&amp;T_{c2}(N,n)=8T_{c2}(N,n/2)+\\Theta(N^2)\\\\\r\n&amp;T_{c3}(N,n)=8T_{c3}(N,n/2)+\\Theta(n^2)\\\\\r\n\\end{aligned}\\)\r\n\\(T_{a1}:a=1,b=2,f(n)=\\Theta(1),\\log_ba=0\\)。因此根据第二个条件，得到\\(k=0\\)，最终\\(T_{a1}(N,n)=\\Theta(\\lg n)\\)。\r\n\\(\\begin{aligned}\r\nT_{a2}(N,n)&amp;=T_{a2}(N,n/2)+\\Theta(N)\\\\\r\n&amp;=T_{a2}(N,n/4)+\\Theta(N)+\\Theta(N)\\\\\r\n&amp;=T_{a2}(N,n/8)+\\Theta(N)+\\Theta(N)+\\Theta(N)\\\\\r\n&amp;\\dots\\\\\r\n&amp;=\\sum_{i=0}^{\\lfloor\\lg n\\rfloor-1} \\Theta(N)\\\\\r\n&amp;=\\Theta(N\\cdot \\lg n)\r\n\\end{aligned}\\)\r\n\\(T_{a3}:a=1,b=2,f(n)=\\Theta(n),\\log_ba=0\\)。因此根据第三个条件，可以构造出\\(c=\\dfrac{1}{2}\\)，最终\\(T_{a3}(N,n)=\\Theta(n)\\)。\r\n\\(T_{b1}:a=2,b=2,f(n)=\\Theta(n),\\log_ba=1\\)。因此根据第二个条件，得到\\(k=0\\)，最终\\(T_{b1}(N,n)=\\Theta(n\\lg n)\\)。\r\n\\(\\begin{aligned}\r\nT_{b2}(N,n)&amp;=2T_{b2}(N,n/2)+\\Theta(N)\\\\\r\n&amp;=4T_{a2}(N,n/4)+2\\Theta(N)+\\Theta(N)\\\\\r\n&amp;=8T_{a2}(N,n/8)+4\\Theta(N)+2\\Theta(N)+\\Theta(N)\\\\\r\n&amp;\\dots\\\\\r\n&amp;=\\sum_{i=0}^{\\lfloor\\lg n\\rfloor-1} 2^i\\cdot\\Theta(N)\\\\\r\n&amp;=\\Theta(Nn)\r\n\\end{aligned}\\)\r\n\\(T_{b3}:T_{b3}(N,n)=T_{b1}(N,n)=\\Theta(n\\lg\r\nn)\\)。\r\n\\(T_{c1}:a=8,b=2,f(n)=\\Theta(1),\\log_ba=3\\)。因此根据第一个条件，\\(T_{c1}(N,n)=\\Theta(n^3)\\)。\r\n\\(\\begin{aligned}\r\nT_{c2}(N,n)&amp;=8T_{c2}(N,n/2)+\\Theta(N^2)\\\\\r\n&amp;=64T_{a2}(N,n/4)+8\\Theta(N)+\\Theta(N)\\\\\r\n&amp;=512T_{a2}(N,n/8)+64\\Theta(N)+8\\Theta(N)+\\Theta(N)\\\\\r\n&amp;\\dots\\\\\r\n&amp;=\\sum_{i=0}^{\\lfloor\\lg n\\rfloor-1} 8^i\\cdot\\Theta(N)\\\\\r\n&amp;=\\Theta(Nn^3)\r\n\\end{aligned}\\)\r\n\\(T_{c3}:a=8,b=2,f(n)=\\Theta(n^2),\\log_ba=3\\)。因此根据第一个条件，\\(T_{c1}(N,n)=\\Theta(n^3)\\)。\r\n4-3\r\na\r\n代入\\(n=2^m\\)。那么可以写成\\(T(2^m)=2T(2^{m/2})+\\Theta(m)\\)。\r\n再代入\\(S(m)=T(2^m)\\)，那么有\\(S(m)=2S(m/2)+\\Theta(m)\\)。\r\nb\r\n\\(a=2,b=2,f(n)=\\Theta(n),\\log_ba=1\\)。因此根据第二个条件，得到\\(k=0\\)，最终\\(S(m)=\\Theta(m\\lg m)\\)。\r\nc\r\n由于\\(S(2^m)=\\Theta(m\\lg\r\nm)\\)，回代\\(n=2^m\\)，即\\(m=\\lg n\\)，得到\\(T(n)=\\Theta(\\lg n\\cdot \\lg \\lg n)\\)。\r\nd\r\n可以发现，整个递归树一共只有\\(\\Theta(\\lg\r\n\\lg n)\\)层。\r\n\r\n如图所示，最终有\\(T(n)=\\lg\\lg n\\cdot\r\n\\Theta(\\lg n)=\\Theta(\\lg n\\cdot\\lg \\lg n)\\)。\r\ne\r\n代入\\(n=2^m\\)。那么可以写成\\(T(2^m)=2T(2^{m/2})+\\Theta(1)\\)。\r\n再代入\\(S(m)=T(2^m)\\)，那么有\\(S(m)=2S(m/2)+\\Theta(1)\\)。\r\n\\(a=2,b=2,f(m)=\\Theta(1),\\log_ba=1\\)。因此根据第一个条件，\\(S(m)=\\Theta(m)\\)。\r\n回代\\(n=2^m\\)，即\\(m=\\lg n\\)，得到\\(T(n)=\\Theta(\\lg n)\\)。\r\nf\r\n代入\\(n=3^m\\)。那么可以写成\\(T(3^m)=3T(3^{m/3})+\\Theta(3^m)\\)。\r\n再代入\\(S(m)=T(3^m)\\)，那么有\\(S(m)=3S(m/3)+\\Theta(3^m)\\)。\r\n\\(\\begin{aligned}\r\nS(m)&amp;=3S(m/3)+\\Theta(3^m)\\\\\r\n&amp;=9S(m/9)+3\\cdot \\Theta(3^{m-1})+\\Theta(3^m)\\\\\r\n&amp;=27S(m/27)+9\\cdot \\Theta(3^{m-2})+3\\cdot\r\n\\Theta(3^{m-1})+\\Theta(3^m)\\\\\r\n&amp;\\dots\\\\\r\n&amp;=\\sum_{i=0}^{\\lfloor\\log_3 m\\rfloor-1} \\Theta(3^m)\\\\\r\n&amp;=\\Theta(\\lg m\\cdot3^m)\r\n\\end{aligned}\\)\r\n回代\\(n=3^m\\)，即\\(m=\\log_3 n\\)，得到\\(T(n)=\\Theta(n\\cdot \\lg \\lg n)\\)。\r\n4-4\r\na\r\n考虑使用主定理，那么有\\(a=5,b=3,f(n)=n\\lg\r\nn,\\log _b a=\\log_3 5&gt;1\\)\r\n因此根据第一个条件，\\(T(n)=\\Theta(n^{\\log_3\r\n5})\\)\r\nb\r\n由于\\(a=3,b=3,f(n)=n/\\lg n=\\Theta(n^{\\log_b\r\na}/\\lg n)\\)。\r\n那么使用题目4.6-3的结论，得到\\(T(n)=n\\lg\\lg\r\nn\\)。\r\nc\r\n考虑使用主定理，那么有\\(a=8,b=2,f(n)=n^{7/2},\\log _b a=3\\)\r\n因此根据第三个条件，可以构造出\\(c=\\dfrac{\\sqrt{2}}{2}\\)，最终\\(T(n)=\\Theta(n^{7/2})\\)。\r\nd\r\n根据4-3节的结论，常数附加项不会对递推式的渐进结果产生影响。\r\n因此令\\(T&#39;(n)=2T&#39;(n/2)+n/2\\)，那么\\(T(n)=\\Theta(T&#39;(n))\\)。\r\n考虑使用主定理求解\\(T&#39;(n)\\)，那么有\\(a=2,b=2,f(n)=n/2,\\log _b a=\\log_2 2=1\\)\r\n因此根据第二个条件，得到\\(k=0\\)，最终\\(T&#39;(n)=\\Theta(n\\lg n)\\)。\r\n也就是说，\\(T(n)=\\Theta(n\\lg\r\nn)\\)。\r\ne\r\n由于\\(a=2,b=2,f(n)=n/\\lg n=\\Theta(n^{\\log_b\r\na}/\\lg n)\\)。\r\n那么使用题目4.6-3的结论，得到\\(T(n)=n\\lg\\lg\r\nn\\)。\r\nf\r\n考虑使用Akra-Bazzi方法。\r\n由于\\(\\displaystyle{\\sum_{i=1}^k\r\n\\dfrac{a_i}{b_i}=\\dfrac{7}{8}}\\)，因此\\(p&lt;1\\)。如果精确解方程\\(\\displaystyle{\\sum_{i=1}^k\r\n\\dfrac{a_i}{b_i^p}=1}\\)，那么可以得到\\(p\\approx 0.879146\\)。并且由于\\(f(n)=n\\)。那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=\\Theta\\left(n^p\\left(1+\\int_{1}^n\r\n\\dfrac{f(x)}{x^{p+1}}dx\\right)\\right) \\\\\r\n&amp;=\\Theta\\left(n^p\\left(1+\\int_{1}^n x^{-p}dx\\right)\\right)\\\\\r\n&amp;=\\Theta\\left(n^p\\left(1+\\left(\\left.\\dfrac{x^{1-p}}{1-p}\\right|_{1}^n\\right)\\right)\\right)\\\\\r\n&amp;=\\Theta\\left(n^p\\left(1+\\left(\\dfrac{n^{1-p}-1}{1-p}\\right)\\right)\\right)\\\\\r\n&amp;=\\Theta\\left(n^p+\\dfrac{n-n^p}{1-p}\\right)\\\\\r\n&amp;=\\Theta(n)\r\n\\end{aligned}\\)\r\ng\r\n\\(\\begin{aligned}\r\nT(n)&amp;=T(n-1)+\\dfrac{1}{n}\\\\\r\n&amp;=T(n-2)+\\dfrac{1}{n-1}+\\dfrac{1}{n}\\\\\r\n&amp;=\\sum_{i=1}^n\\dfrac{1}{i}\\\\\r\n&amp;=\\ln n+O(1)\\\\\r\n&amp;=\\Theta(\\lg n)\r\n\\end{aligned}\\)\r\nh\r\n\\(\\begin{aligned}\r\nT(n)&amp;=T(n-1)+\\lg n\\\\\r\n&amp;=T(n-2)+\\lg (n-1)+\\lg n\\\\\r\n&amp;=\\sum_{i=1}^n\\lg i\\\\\r\n&amp;=\\lg n!\\\\\r\n&amp;=\\Theta(n\\lg n)\r\n\\end{aligned}\\)\r\ni\r\n本题目答案参考了此页面的内容，并且更加严谨了一些。\r\n可以发现，\\(T(n)\\)可以写成如下分段等式：\r\n\\[\r\nT(n)=\r\n\\left \\{\\begin{aligned}\r\n&amp;T(0)+\\sum_{k=1}^{n/2}\\dfrac{1}{\\lg(2k)} &amp; &amp;\\text{if }n\r\n\\equiv 0 \\pmod 2\\\\\r\n&amp;T(1)+\\sum_{k=1}^{(n-1)/2}\\dfrac{1}{\\lg(2k+1)}&amp; &amp;\\text{if }n\r\n\\equiv 1 \\pmod 2\r\n\\end{aligned}\\right.\r\n\\]\r\n接下来证明\\(T(n)=\\Omega\\left(\\dfrac{n}{\\lg\r\nn}\\right).\\)\r\n当\\(n\\)为偶数时，有\\(\\displaystyle{T(n)=T(0)+\\sum_{k=1}^{n/2}\\dfrac{1}{\\lg(2k)}\\ge\r\nT(0)+\\sum_{k=1}^{n/2}\\dfrac{1}{\\lg n}=T(0)+\\dfrac{n}{2\\lg n}\\ge\r\n\\dfrac{n}{2\\lg n}}.\\)不难发现在这种情况下有\\(T(n)=\\Omega\\left(\\dfrac{n}{\\lg\r\nn}\\right).\\)\r\n当\\(n\\)为奇数时，有\\(\\displaystyle{T(n)=T(1)+\\sum_{k=1}^{(n-1)/2}\\dfrac{1}{\\lg(2k+1)}\\ge\r\nT(1)+\\sum_{k=1}^{(n-1)/2}\\dfrac{1}{\\lg n}=T(1)+\\dfrac{n-1}{2\\lg n}\\ge\r\n\\dfrac{n}{2\\lg n}}.\\)不难发现在这种情况下有\\(T(n)=\\Omega\\left(\\dfrac{n}{\\lg\r\nn}\\right).\\)\r\n因此综上所述，\\(T(n)=\\Omega\\left(\\dfrac{n}{\\lg\r\nn}\\right).\\)\r\n接下来证明\\(T(n)=O\\left(\\dfrac{n}{\\lg\r\nn}\\right).\\)以下变换基于\\(n\\ge\r\ne^2\\)的假设进行。\r\n当\\(n\\)为偶数时，有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=\\sum_{k=1}^{n/2}\\dfrac{1}{\\lg(2k)}\\\\\r\n&amp;=\\dfrac{1}{\\lg 2}+\\sum_{k=2}^{n/2}\\dfrac{1}{\\lg(2k)}\\\\\r\n&amp;\\le 1+\\int_1^{n/2}\\dfrac{dx}{\\lg(2x)}\\\\\r\n&amp;= 1+\\dfrac{1}{2}\\int_2^{n}\\dfrac{dx}{\\lg x}\\\\\r\n&amp;={\\color{red}1+\\dfrac{1}{2}\\int_2^{e^2}\\dfrac{dx}{\\lg\r\nx}}+\\dfrac{1}{2}\\int_{e^2}^n\\dfrac{dx}{\\lg x}\r\n\\end{aligned}\\)\r\n当\\(n\\)为奇数时，有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=\\sum_{k=1}^{(n-1)/2}\\dfrac{1}{\\lg(2k+1)}\\\\\r\n&amp;=\\dfrac{1}{\\lg 3}+\\sum_{k=2}^{(n-1)/2}\\dfrac{1}{\\lg(2k+1)}\\\\\r\n&amp;\\le \\dfrac{1}{\\lg 3}+\\int_1^{(n-1)/2}\\dfrac{dx}{\\lg(2x+1)}\\\\\r\n&amp;= \\dfrac{1}{\\lg 3}+\\dfrac{1}{2}\\int_3^{n}\\dfrac{dx}{\\lg x}\\\\\r\n&amp;={\\color{red}\\dfrac{1}{\\lg\r\n3}+\\dfrac{1}{2}\\int_3^{e^2}\\dfrac{dx}{\\lg\r\nx}}+\\dfrac{1}{2}\\int_{e^2}^n\\dfrac{dx}{\\lg x}\r\n\\end{aligned}\\)\r\n因此，令\\(\\displaystyle{c_0=\\max\\left\\{1+\\dfrac{1}{2}\\int_2^{e^2}\\dfrac{dx}{\\lg\r\nx},\\dfrac{1}{\\lg 3}+\\dfrac{1}{2}\\int_3^{e^2}\\dfrac{dx}{\\lg\r\nx}\\right\\}}\\)。那么可以写成\r\n\\[T(n)\\le\r\nc+\\dfrac{1}{2}\\int_{e^2}^n\\dfrac{dx}{\\lg x}=c+\\dfrac{\\ln\r\n2}{2}\\int_{e^2}^n\\dfrac{dx}{\\ln x}\\]\r\n当\\(n\\ge\r\ne^2\\)时，不难得到不等式\\(\\ln n\\le 2(\\ln\r\nn -1)\\)。故此有\r\n\\(\\begin{aligned}\r\nT(n)&amp;\\le c+\\dfrac{\\ln 2}{2}\\int_{e^2}^n\\dfrac{dx}{\\ln x}\\\\\r\n&amp;\\le c+\\ln 2\\cdot\\int_{e^2}^n\\dfrac{(\\ln x-1)dx}{\\ln^2 x}\\\\\r\n&amp;= c+\\ln 2\\cdot\\left(\\left.\\dfrac{x}{\\ln x}\\right|_{e^2}^n\\right)\\\\\r\n&amp;= c+\\dfrac{n\\cdot\\ln 2}{\\ln n}-\\dfrac{e^2\\cdot \\ln 2 }{2}\r\n\\end{aligned}\\)\r\n因此综上所述，\\(T(n)=O\\left(\\dfrac{n}{\\lg\r\nn}\\right).\\)\r\n最终有\\(T(n)=\\Theta\\left(\\dfrac{n}{\\lg\r\nn}\\right).\\)\r\nj\r\n令\\(U(n)=\\dfrac{T(n)}{n}\\)。将\\(U(n)\\)代入到原式，那么得到\r\n\\[U(n)=U(\\sqrt{n})+1\\]\r\n令\\(V(m)=U(2^m)\\)。将\\(V(m)\\)带入到上式，那么得到\r\n\\[V(m)=V(m/2)+1\\]\r\n根据主定理的第二个条件，可以得到\\(V(m)=\\Theta(\\lg m)\\)。\r\n回代到\\(U\\)中，得到\\(U(n)=\\Theta(\\lg \\lg n)\\)。\r\n因此有\\(T(n)=\\Theta(n\\lg \\lg\r\nn)\\)。\r\n4-5\r\na\r\n将一次项和常数项目全部分离出来，那么等式右边三项可以写成：\r\n\\(\\begin{aligned}\r\n&amp;z=z\\\\\r\n&amp;z\\mathcal{F}(z)=\\sum_{i=0}^{\\infty} F_iz^{i+1}=\\sum_{i=1}^{\\infty}\r\nF_{i-1} z^i=F_0 z+\\sum_{i=2}^{\\infty} F_{i-1}z^i\\\\\r\n&amp;z^2\\mathcal{F}(z)=\\sum_{i=0}^{\\infty}\r\nF_iz^{i+2}=\\sum_{i=2}^{\\infty} F_{i-2} z^i\\\\\r\n\\end{aligned}\\)\r\n三项相加，得到\\(\\displaystyle{z+\\sum_{i=2}^{\\infty}\r\n(F_{i-1}+F_{i-2})z^i=z+\\sum_{i=2}^{\\infty}F_iz^i}\\)。\r\n代入\\(F_0=0,F_1=1\\)，最终这个式子可以写成\\(\\displaystyle{\\sum_{i=0}^{\\infty}F_iz^i}\\)，也就是\\(\\mathcal{F}(z)\\)。\r\nb\r\n将a的结论整理得到\\(\\mathcal{F}(z)-z\\mathcal{F}(z)-z^2\\mathcal{F}(z)=z\\)，提取\\(\\mathcal{F}(z)\\)公因式，得到\\(\\mathcal{F}(z)(1-z-z^2)=z\\)，最终得到：\r\n\\(\\mathcal{F}(z)=\\dfrac{z}{1-z-z^2}\\)\r\n由于\\(\\phi=\\dfrac{1+\\sqrt{5}}{2},\\hat{\\phi}=\\dfrac{1-\\sqrt{5}}{2}\\)，那么得到\\(\\phi\\cdot\r\n\\hat{\\phi}=-1,\\phi+\\hat{\\phi}=1,\\phi-\\hat{\\phi}=\\sqrt{5}\\)。\r\n由于\\((1-\\phi z)(1-\\hat{\\phi z})=\\phi\\cdot\r\n\\hat{\\phi} \\cdot z^2-(\\phi + \\hat{\\phi}) z+1=1-z-z^2\\)，因此\\(\\mathcal{F}(z)\\)还可以写成：\\(\\mathcal{F}(z)=\\dfrac{z}{(1-\\phi\r\nz)(1-\\hat{\\phi}z)}\\)\r\n由于有如下变换：\r\n\\(\\begin{aligned}\r\n\\dfrac{1}{\\sqrt{5}}\\left(\\dfrac{1}{1-\\phi\r\nz}-\\dfrac{1}{1-\\hat{\\phi}z}\\right)&amp;=\\dfrac{1}{\\sqrt{5}}\\left(\\dfrac{(1-\\hat{\\phi}\r\nz)-(1-\\phi z)}{(1-\\phi z)(1-\\hat{\\phi}z)}\\right)\\\\\r\n&amp;=\\dfrac{1}{\\sqrt{5}}\\left(\\dfrac{\\phi-\\hat{\\phi}}{(1-\\phi\r\nz)(1-\\hat{\\phi}z)}\\right)\\\\\r\n&amp;=\\dfrac{1}{(1-\\phi z)(1-\\hat{\\phi}z)}\r\n\\end{aligned}\\)\r\n因此\\(\\mathcal{F}(z)\\)还可以写成：\\(\\mathcal{F}(z)=\\dfrac{1}{\\sqrt{5}}\\left(\\dfrac{1}{1-\\phi\r\nz}-\\dfrac{1}{1-\\hat{\\phi}z}\\right)\\).\r\nc\r\n\\(\\begin{aligned}\r\n\\mathcal{F}(z)&amp;=\\dfrac{1}{\\sqrt{5}}\\left(\\dfrac{1}{1-\\phi\r\nz}-\\dfrac{1}{1-\\hat{\\phi}z}\\right)\\\\\r\n&amp;=\\dfrac{1}{\\sqrt{5}}\\left(\\sum_{i=0}^{\\infty}\r\n\\phi^iz^i-\\sum_{i=0}^{\\infty} \\hat{\\phi}^iz^i\\right)\\\\\r\n&amp;=\\dfrac{1}{\\sqrt{5}}\\sum_{i=0}^{\\infty} (\\phi^i- \\hat{\\phi}^i)z^i\\\\\r\n\\end{aligned}\\)\r\nd\r\n由题目c得到的等式，代入题目求和项中的\\(F_i\\)，有\\(F_i=\\dfrac{\\phi^i-\r\n\\hat{\\phi}^i}{\\sqrt{5}}=\\dfrac{\\phi^i}{\\sqrt{5}}-\\dfrac{\\hat{\\phi}^i}{\\sqrt{5}}\\)。\r\n可以发现，对于\\(\\forall i\\ge\r\n0,\\left|\\dfrac{\\hat{\\phi}^i}{\\sqrt{5}}\\right|&lt;0.5\\)均成立。因此，\\(F_i&#39;=\\dfrac{\\hat{\\phi}^i}{\\sqrt{5}}\\)最接近的整数即为\\(F_i\\)。\r\ne\r\n考虑式子\\(F_{i+2}-\\phi^i\\)的值。那么有\r\n\\(F_{i+2}-\\phi\r\n^i=\\dfrac{1}{\\sqrt{5}}\\left(\\phi^{i+2}-\\hat{\\phi}^{i+2}\\right)-\\phi^i=\\dfrac{3\\sqrt{5}-5}{10}\r\n\\phi^i-\\dfrac{3\\sqrt{5}-5}{10}\\hat{\\phi}^{i}=\\dfrac{3\\sqrt{5}-5}{10}(\\phi^i-\\hat{\\phi}^i)\\)\r\n由于\\(\\phi&gt;\\hat{\\phi}\\)，因此\\(F_{i+2}-\\phi^i\\ge 0\\)，即有\\(F_{i+2}\\ge \\phi^i\\)。\r\n4-6\r\na\r\n假设好的芯片一共有\\(k\\)个，其中满足\\(k\\le n-k\\)。\r\n那么从这\\(n-k\\)个坏芯片中选择出\\(k\\)个坏芯片。这\\(k\\)个坏芯片的策略是：如果另一个芯片是好芯片，那么显示为坏结果如果另一个芯片是坏芯片，那么显示为好结果。\r\n按照这种策略，只要从这\\(2k\\)个芯片中取出任意\\(2\\)个芯片检测，那么教授旧无法区分哪\\(k\\)个芯片是好的，哪\\(k\\)个芯片是坏的，因为两个芯片互相检测结果总是一致的，\r\nb\r\n现在题目的假设是：好芯片严格多于坏芯片。\r\n整个策略如下：首先，如果当前芯片个数\\(n\\)是奇数，那么均匀随机选择一个芯片留下，对剩下的\\(n-1\\)个芯片进行递归操作，等操作完成再回头考虑这个被留下的芯片；否则什么都不用做。在一轮中，每次随机取出\\(2\\)个芯片进行测试。如果\\(2\\)个芯片的测试结果是“\\(2\\)个都是好芯片”，那么丢弃其中\\(1\\)个芯片，另\\(1\\)个芯片留到下一轮测试；否则\\(2\\)个芯片都丢弃。这个过程由算法GET-GOOD描述。\r\n// 子程序`TEST(c1, c2)`表示对芯片c1, c2进行测试的结果。用True表示全好的报告，用False表示存在1个芯片是坏的报告。GET-GOOD(chips)  if chips.size == 0    return NIL  else if chips.size == 1    return chip[0]  else if chips.size % 2 == 0    let C be new array    for i = 0 to chips.size - 1 by 2      if TEST(chips[i], chips[i + 1]) == True        INSERT(C, chips[i])    return GET-GOOD(C)  else    // chips[0]是保留的那个芯片。    let C be new array    for i = 1 to chips.size - 1 by 2      if TEST(chips[i], chips[i + 1]) == True        INSERT(C, chips[i])    now = GET-GOOD(C)    if now == NIL      return chips[0]    else      return now\r\n因此在一轮测试中，需要进行\\(\\left\\lfloor\\dfrac{n}{2}\\right\\rfloor\\)次测试。在一轮测试完成后，最多剩下\\(\\left\\lceil\\dfrac{n}{2}\\right\\rceil\\)个芯片。\r\n接下来说明：经过一轮的测试后，剩下的芯片仍然满足：好芯片仍然严格多于坏芯片。\r\n可以知道，如果算法GET-GOOD传入的芯片中，好坏的个数相同，那么最终这个算法的递归终点将是第2行的NIL。因为在第7行的for循环完成后，得到的C数组中，好芯片和坏芯片的个数仍然相同。最终随着递归的进行，每一对好坏芯片都将被抵消，最终找不到任何一个好芯片。\r\n如果算法GET-GOOD传入的芯片中，好芯片要比坏芯片多，那么在这一轮测试中，假设芯片的个数为\\(n\\)，那么考虑如下\\(2\\)个情况：\r\n如果\\(n\\)是偶数，在这\\(\\dfrac{n}{2}\\)次测试中，有\\(a\\)次是拿出了\\(2\\)个好芯片进行测试，有\\(b\\)次是拿出了\\(1\\)个好芯片，\\(1\\)个坏芯片进行测试，有\\(c\\)次是拿出了\\(2\\)个坏芯片进行测试，需要注意的是，在测试的过程中，\\(a,b,c\\)的值是无法被统计。那么可以知道好芯片的个数为\\(2a+b\\)，坏芯片的个数为\\(2c+b\\)。按照假设，有\\(2a+b&gt;2c+b\\)，即得出\\(a&gt;c\\)。在\\(b\\)次不同好坏芯片的测试中，所有芯片都丢弃；\\(a\\)次全好芯片测试中，将会恰好保留\\(a\\)个好芯片；在\\(c\\)次全坏芯片测试中，将会至多保留\\(c\\)个坏芯片（因为两个坏芯片同样会有可能报告对方是坏的）。由于\\(a&gt;c\\)，因此这一轮测试完成后，保留的好芯片必然严格多于坏芯片。最终递归终止时，所有坏芯片将会被丢弃，通过第4行的代码找到一个好芯片。\r\n如果\\(n\\)是奇数，那么有如下\\(2\\)种情况进行讨论，注意需要随机留出一个芯片，假设为chips[0]。\r\n1\r\n如果算法GET-GOOD传入的芯片中，好芯片要比坏芯片多出\\(3\\)个或以上，那么无论留下来的是好芯片还是坏芯片，按照偶数时的情况，第16行代码中，变量now必定是一个好芯片，直接返回。\r\n2\r\n如果算法GET-GOOD传入的芯片中，好芯片要比坏芯片多出恰好\\(1\\)个，那么有如下\\(2\\)情况讨论。\r\n如果留下来的是好芯片，那么剩下的\\(n-1\\)个芯片中，好坏的个数相同。上面13行的for循环完成后，数组C的好坏芯片个数相同。按照上面的结论，第16行代码对数组C进行递归调用后，得到的必定是NIL。那么返回留下的好芯片chips[0]即可。\r\n如果留下来的是坏芯片，那么剩下的\\(n-1\\)个芯片中，好芯片多于坏芯片。按照偶数时的结论，第16行代码中，变量now必定是一个好芯片，直接返回。\r\n故在好芯片严格多于坏芯片的情况下，算法GET-GOOD总能找到一个好芯片。\r\nc\r\n根据题目4-6-b的结论，假设\\(n\\)个芯片的比较次数为\\(T(n)\\)，那么可以给出下列不等式：\r\n\\(T(n)\\le\r\nT\\left(\\left\\lfloor\\dfrac{n}{2}\\right\\rfloor\\right)+\\left\\lfloor\\dfrac{n}{2}\\right\\rfloor\\)\r\n根据主定理的第二个条件，不难得到\\(T(n)=O(n)\\)。\r\nd\r\n由于找出一个好的芯片需要\\(O(n)\\)次比较，那么使用这个好的芯片对其它芯片进行测试就能够找到所有好芯片，总共需要\\(n-1\\)次比较。\r\n因此，最终找到所有好芯片的次数为\\(O(n)+n-1=\\Theta(n)\\)次。\r\n4-7\r\na\r\n充分性：\r\n令\\(k=i+1,k=j+1\\)，那么得到等式\\(A[i,j]+A[i+1,j+1]\\le\r\nA[i,j+1]+A[i+1,j]\\)。充分性成立。\r\n必要性：\r\n由\\(A[i,j]+A[i+1,j+1]\\le\r\nA[i,j+1]+A[i+1,j]\\)通过移项，得到：\r\n\\(A[i,j]-A[i,j+1]\\le\r\nA[i+1,j]-A[i+1,j+1]\\)。\r\n令函数\\(f_j(x)=A[x,j]-A[x,j+1]\\)，那么对于\\(1\\le x&lt;m\\)，由上面的等式，发现\\(f_j(i)\\)是一个递增函数。因此，\\(\\forall 1\\le i&lt; k\\le m\\)，都有\\(f_j(i)\\le f_j(k)\\)成立。即有\\(A[i,j]+A[k,j+1]\\le\r\nA[i,j+1]+A[k,j]\\)都成立。\r\n同理，可以得出\\(\\forall 1\\le j&lt; l\\le\r\nn\\)，都有\\(A[i,j]+A[i+1,l]\\le\r\nA[i,l]+A[i+1,j]\\)。\r\n最终根据传递性，总有\\(A[i,j]+A[k,l]\\le\r\nA[i,l]+A[l,j]\\)成立，因此必要性成立。\r\nb\r\n\\(\\begin{aligned}\r\n&amp;&amp;37 &amp;&amp;23 &amp;&amp;\\mathbf{29} &amp;&amp;32 \\\\\r\n&amp;&amp;21 &amp;&amp;6 &amp;&amp;7 &amp;&amp;10 \\\\\r\n&amp;&amp;53 &amp;&amp;34 &amp;&amp;30 &amp;&amp;31 \\\\\r\n&amp;&amp;32 &amp;&amp;13 &amp;&amp;9 &amp;&amp;6 \\\\\r\n&amp;&amp;43 &amp;&amp;21 &amp;&amp;15 &amp;&amp;6 \\\\\r\n\\end{aligned}\\)\r\nc\r\n本题使用反正法进行证明。\r\n假设存在\\(a,b\\)满足\\(1\\le a&lt; b\\le m\\)，有\\(f(a)&gt;f(b)\\)。\r\n根据\\(f\\)函数的定义：\\(f(i)\\)是第\\(i\\)行中最左的最小元素的列下标，可以得到：\\(A[a,f(b)]&gt;A[a,f(a)]\\)，注意此式子不能取等号；还可以得到\\(A[b,f(b)]\\le A[b,f(a)]\\).\r\n根据这两条不等式可以得到\\(A[b,f(a)]+A[a,f(b)]&gt;A[a,f(a)]+A[b,f(b)]\\)，与Monge矩阵的定义矛盾。\r\n因此\\(\\forall 1\\le a&lt; b\\le\r\nm\\)，都有\\(f(a)\\le f(b)\\)。\r\nd\r\n由于目前已经知道\\(f(2),f(4),f(6),\\dots,f(2k)\\)的值，并且由于已知\\(f(0)\\le f(1)\\le f(2)\\le f(3)\\le \\dots \\le\r\nf(m)\\)。为了计算\\(f(1),f(3),f(5),\\dots,f(2k+1)\\)的值，假设\\(f(0)=1\\)，有：\r\n\\(\\begin{aligned}\r\nS(n,m)&amp;=\\sum_{i=1}^{m/2} (f(2i)-f(2i-2)+1)\\\\\r\n&amp;=f(m)-f(0)+m/2\\\\\r\n&amp;=O(n+m)\r\n\\end{aligned}\\)\r\ne\r\n为了解决整个求解问题，可以写出\\(S(m)=S(m/2)+T(n,m)\\)。\r\n由于\\(T(n,m)=O(n+m)\\)，那么可以假设\\(T(n,m)\\le an+bm\\)\r\n\\(\\begin{aligned}\r\nS(m)&amp;\\le S(m/2)+an+bm\\\\\r\n&amp;\\le S(m/4)+an+bm+an+bm/2\\\\\r\n&amp;\\le S(m/8)+an+bm+an+bm/2+an+bm/4\\\\\r\n&amp;\\le \\dots\\\\\r\n&amp;=\\sum_{i=0}^{\\lfloor\\lg m\\rfloor} an+\\dfrac{bm}{2^i}\\\\\r\n&amp;= bm+an\\lg m\r\n\\end{aligned}\\)\r\n因此\\(S(m)=O(m+n\\lg m)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论6.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-6/exercises-1/","content":"\r\n6.1-1\r\n最少为\\(2^h\\)，最多为\\(2^{h+1}-1\\)。\r\n一棵高度为\\(h\\)的满二叉树一共有\\(2^h-1\\)个节点。\r\n因此，在一棵高度为\\(h-1\\)的满二叉树上多添加一个节点，就成为了一棵高度为\\(h\\)的二叉树，故最少为\\(2^h\\)。\r\n一棵高度为\\(h\\)的满二叉树则对应着最多的情况，即\\(2^{h+1}-1\\)个节点。\r\n6.1-2\r\n由题目6.1-1可知，对于任意\\(n\\)个节点的堆，存在高度\\(h\\)使得\\(2^h\\le\r\nn\\le 2^{h+1}-1\\)，即\\(2^h\\le\r\nn&lt;2^{h+1}\\)。\r\n对等式两边对\\(2\\)取对数，得到\\(h\\le \\lg n&lt; h+1\\)。因此可以得到\\(h=\\lfloor\\lg n\\rfloor\\)。\r\n6.1-3\r\n考虑使用归纳法进行证明。\r\n当一棵子树只有一个节点（没有后代）时，这棵子树的最大元素是这个节点的元素，因此原结论成立。\r\n当一棵子树有多个节点时，假设这个子树的根的直系后代各自的子树都满足这个结论。那么根据最大堆的定义，父亲节点的元素必须大于等于子节点的元素，可以得出，这个子树的根节点的元素都大于等于其子树内的所有元素。\r\n因此原结论得证。\r\n6.1-4\r\n它将会出现在任意一个叶节点之中。\r\n6.1-5\r\n第\\(k\\)大的节点至少可以放在第\\(1\\)层的\\(A[3]\\)位置。根据这个堆结构的性质不难看出，根节点（\\(1\\)个节点）与根节点的左子树的节点个数之和已经超过了\\(\\dfrac{n}{2}\\)，并且\\(k\\)已经满足\\(2\\le\r\nk\\le \\lfloor n/2\\rfloor\\)，因此先将第\\(1\\sim\r\nk-1\\)大的元素按照堆的性质在这一部分放置好，然后再将第\\(k\\)大的元素放置在\\(A[3]\\)，再将接下来的其它数按照堆的性质进行放置即可。\r\n第\\(k\\)大的节点至多可以放在第\\(\\min\\{k-1,\\lfloor\\lg\r\nn\\rfloor\\}\\)层。放置方式如下：从根节点到这个节点的路径上，分别是第\\(1\\)大，第\\(2\\)大，……，第\\(k\\)大的值。\r\n6.1-6\r\n是的，因为对于任意\\(i \\ge\r\n2\\)，PARENT(i) &lt;= i总成立。如果数组\\(A\\)是已经排序的，那么就有A[PARENT(i)] &lt;= A[i]，这满足了最小堆的性质。\r\n6.1-7\r\n不是，因为\\(A[4]=15,A[9]=16\\)，不满足A[PARENT(9)] &lt;= A[9]。\r\n6.1-8\r\n对于二叉堆中的所有非根节点\\(t=2,3,\\dots,n\\)，它们的父节点是\\(\\lfloor t/2\\rfloor\\)，即\\(1,1,2,2,\\dots,\\lfloor\r\nn/2\\rfloor\\)。也就是说，\\(\\forall\r\nt,\\lfloor n/2\\rfloor&lt; t \\le\r\nn\\)，均没有后继节点。因此，这一部分节点都是叶节点。\r\n","categories":["算法导论"]},{"title":"算法导论6.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-6/exercises-3/","content":"\r\n6.3-1\r\n用数组来表示这个堆的变化（横线标出变化之处）：\r\n\\(\\begin{aligned}\r\n\\langle5,3,17,\\underline{10},84,19,6,22,9\\rangle\\\\\r\n\\langle5,3,17,\\underline{22},84,19,6,\\underline{10},9\\rangle\\\\\r\n\\langle5,3,\\underline{19},22,84,\\underline{17},6,10,9\\rangle\\\\\r\n\\langle5,\\underline{84},19,22,\\underline{3},17,6,10,9\\rangle\\\\\r\n\\langle\\underline{84},\\underline{22},19,\\underline{10},3,17,6,\\underline{5},9\\rangle\r\n\\end{aligned}\\)\r\n6.3-2\r\n由于\\(n&gt;0,h\\ge 0\\)，因此\\(n/2^{h+1}&gt;0\\)，那么有\\(\\lceil n/2^{h+1}\\rceil\\ge 1\\ge 1/2\\)。\r\n6.3-3\r\n如果如此迭代循环，那么这个算法是错误的，原因如下：\r\n如果建堆前，最大值恰好在堆中某个叶节点，那么按照这个方式进行建堆，第一次循环完成后，这个叶子节点的值不可能直接上升到根节点（最多只能上升\\(1\\)个高度）。在剩下的循环中，根节点永远不会被访问到，因此循环完成后，最大值不能上升到根节点处，这违反了最大堆的性质。\r\n6.3-4\r\n考虑使用归纳法进行证明。\r\n令\\(n\\)个节点的堆中，高度为\\(h\\)的节点个数为\\(f_n(h)\\)。\r\n当\\(h=0\\)时，\\(f_n(h)=\\lceil n/2\r\n\\rceil\\)成立。这是利用了题目6.1-8的结论：\\(\\lfloor n/2\\rfloor+1,\\lfloor\r\nn/2\\rfloor+2,\\dots,n\\)都是叶节点。\r\n当\\(h&gt;0\\)时，假设当\\(h&#39;=0,1,\\dots,h-1\\)时，\\(f_n(h&#39;)\\le\r\n\\left\\lceil\\dfrac{n}{2^{h&#39;+1}}\\right\\rceil\\)均成立。当我们删去这个堆上当前的叶节点后，可以发现，剩下的所有节点高度都下降了\\(1\\)，剩下的节点一共有\\(\\lfloor\r\nn/2\\rfloor\\)个，那么删去节点后的树可以套用原来的假设。因此有\r\n\\(f_n(h)=f_{\\lfloor\r\nn/2\\rfloor}(h-1)\\le\\left\\lceil\\dfrac{\\lfloor\r\nn/2\\rfloor}{2^{(h-1)+1}}\\right\\rceil \\le\r\n\\left\\lceil\\dfrac{n/2}{2^{h}}\\right\\rceil=\r\n\\left\\lceil\\dfrac{n}{2^{h+1}}\\right\\rceil\\)\r\n最终原结论成立。\r\n","categories":["算法导论"]},{"title":"算法导论6.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-6/exercises-2/","content":"\r\n6.2-1\r\n用数组来表示这个堆的变化（横线标出变化之处）：\r\n\\(\\begin{aligned}\r\n\\langle 27,17,\\underline{3},16,13,10,1,5,7,12,4,8,9,0\\rangle\\\\\r\n\\langle\r\n27,17,\\underline{10},16,13,\\underline{3},1,5,7,12,4,8,9,0\\rangle\\\\\r\n\\langle 27,17,10,16,13,\\underline{9},1,5,7,12,4,8,\\underline{3},0\\rangle\r\n\\end{aligned}\\)\r\n6.2-2\r\n根据堆在同一层上，从左到右铺满节点的特点，可以发现，根的左子树节点数一定不会低于根的右子树节点数，因此仅需要考虑根的左子树节点数。\r\n而当这个堆是半满（也就是说在这一层中，根的左子树已经铺满所有节点，根的右子树没有任何一个节点）的时候，根的左子树节点数比重将达到最大。此时根的左子树可以视为是高度为\\(h+1\\)的满二叉树，有\\(2^{h+1}-1\\)个节点；根的右子树可以视为是高度为\\(h\\)的满二叉树，有\\(2^{h}-1\\)个节点；整个堆一共有\\(2^{h+1}-1+2^h-1+1=3\\cdot\r\n2^h-1\\)个节点。那么考虑左子树占整个堆的比重，有：\r\n\\(\\dfrac{2^{h+1}-1}{3\\cdot\r\n2^h-1}=\\dfrac{2\\cdot 2^h-1}{3\\cdot 2^h-1}&lt;\\dfrac{2\\cdot 2^h}{3\\cdot\r\n2^h}=\\dfrac{2}{3}\\)\r\n因此左子树占整个堆的比重至多为\\(\\dfrac{2}{3}\\)，即至多\\(\\dfrac{2n}{3}\\)的节点。\r\n当这个堆是一个满二叉树时，根的左子树节点数比重将达到最小，因此\\(\\alpha=\\dfrac{1}{2}\\)。\r\n因此，\\(\\alpha\\)仍为\\(\\dfrac{2}{3}\\)，对递推式没有什么影响，因为堆的子树最坏情况也只能是半满。\r\n6.2-3\r\nMIN-HEAPIFY(A, i)  l = LEFT(i)  r = RIGHT(i)  if l &lt;= A.heap-size and A[l] &lt; A[i]    smallest = l  else smallest = i  if r &lt;= A.heap-size and A[r] &lt; A[smallest]    smallest = r  if smallest != i    exchange A[i] with A[smallest]    MAX-HEAPIFY(A, smallest)\r\n运行时间和算法MAX-HEAPIFY相同，都为\\(O(\\lg n)\\)。\r\n6.2-4\r\n没有任何变化，因为节点\\(i\\)和其子节点已经满足了最大堆的性质。\r\n6.2-5\r\n没有任何变化，因为按照题目6.1-8的结论，此时\\(i\\)是叶子节点。\r\n6.2-6\r\nMAX-HEAPIFY-NONRECURSIVE(A, i)  while i &lt;= ⌊A.heap-size / 2⌋    l = LEFT(i)    r = RIGHT(i)    if l &lt;= A.heap-size and A[l] &gt; A[i]      largest = l    else largest = i    if r &lt;= A.heap-size and A[r] &gt; A[largest]      largest = r    if largest ≠ i      exchange A[i] with A[largest]      i = largest    else      break\r\n6.2-7\r\n调用MAX-HEAPIFY(A, 1)，也就是让根节点的值下降。那么当这个节点的值下降到最深的一排的叶节点时，才能达到最坏情况。由于\\(n\\)个节点的堆的高度为\\(\\lfloor\\lg\r\nn\\rfloor\\)，因此最坏情况下的时间复杂度为\\(\\Omega(\\lg n)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论6.5 Exercises 答案","url":"/introduction-to-algorithms/chapter-6/exercises-5/","content":"\r\n6.5-1\r\n用数组来表示这个堆的变化（横线标出变化之处）：\r\n\\(\\begin{aligned}\r\n&amp; \\langle 15, 13, 9, 5, 12, 8, 7, 4, 0, 6, 2, 1\\rangle\\\\\r\n&amp; \\langle \\underline{1}, 13, 9, 5, 12, 8, 7, 4, 0, 6, 2 \\rangle\\\\\r\n&amp; \\langle 13, \\underline{1}, 9, 5, 12, 8, 7, 4, 0, 6, 2 \\rangle\\\\\r\n&amp; \\langle 13, 12, 9, 5, \\underline{1}, 8, 7, 4, 0, 6, 2 \\rangle\\\\\r\n&amp; \\langle 13, 12, 9, 5, 6, 8, 7, 4, 0, \\underline{1}, 2 \\rangle\\\\\r\n\\end{aligned}\\)\r\n6.5-2\r\n用数组来表示这个堆的变化（横线标出变化之处）：\r\n\\(\\begin{aligned}\r\n&amp; \\langle 15, 13, 9, 5, 12, 8, 7, 4, 0, 6, 2, 1\\rangle\\\\\r\n&amp; \\langle 15, 13, 9, 5, 12, 8, 7, 4, 0, 6, 2, 1, \\underline{-\\infty}\r\n\\rangle\\\\\r\n&amp; \\langle 15, 13, 9, 5, 12, 8, 7, 4, 0, 6, 2, 1, \\underline{10}\r\n\\rangle\\\\\r\n&amp; \\langle 15, 13, 9, 5, 12, \\underline{10}, 7, 4, 0, 6, 2, 1, 8\r\n\\rangle\\\\\r\n&amp; \\langle 15, 13, \\underline{10}, 5, 12, 9, 7, 4, 0, 6, 2, 1, 8\r\n\\rangle\\\\\r\n\\end{aligned}\\)\r\n6.5-3\r\nMIN-HEAP-MINIMUM(A)  if A.heap-size &lt; 1    error “heap underflow”  return A[1]MIN-HEAP-EXTRACT-MIN(A)  min = MIN-HEAP-MINIMUM(A)  A[1] = A[A.heap-size]  A.heap-size = A.heap-size – 1  MIN-HEAPIFY(A, 1)  return minMIN-HEAP-INCREASE-KEY(A, x, k)  if k &gt; x.key    error “new key is larger than current key”  x.key = k  find the index i in array A where object x occurs  while i &gt; 1 and A[PARENT(i)].key &gt; A[i].key  exchange A[i] with A[PARENT(i)], updating the information that maps priority queue objects to array indices  i = PARENT(i)MIN-HEAP-INSERT(A, x, n)  if A.heap-size == n    error “heap overflow”  A.heap-size = A.heap-size + 1  k = x.key  x.key = ∞  A[A.heap-size] = x  map x to index heap-size in the array  MIN-HEAP-INCREASE-KEY(A, x, k)\r\n6.5-4\r\nMAX-HEAP-DECREASE-KEY(A, x, k)  if k &gt; x.key    error “new key is larger than current key”  x.key = k  find the index i in array A where object x occurs  while i &lt;= ⌊A.heap-size / 2⌋    l = LEFT(i)    r = RIGHT(i)    if l &lt;= A.heap-size and A[l] &gt; A[i]      largest = l    else largest = i    if r &lt;= A.heap-size and A[r] &gt; A[largest]      largest = r    if largest ≠ i      exchange A[i] with A[largest], updating the information that maps priority queue objects to array indices      i = largest    else      break\r\n6.5-5\r\n为了方便复用MAX-HEAP-INCREASE-KEY中的代码，并且让其通过算法MAX-HEAP-INCREASE-KEY中的第一行合法性判断。\r\n6.5-6\r\n算法MAX-HEAP-INCREASE-KEY的第5-7行代码最终的目的是将过大的值逐步移向根节点，而算法MAX-HEAPIFY则是将一个过小的值移向叶节点，两者是完全不一样的功能，无法替代。\r\n6.5-7\r\n初始化：程序开始前，整个优先队列符合最大堆的结构，因此题中三个循环不变量都符合题意。在while循环开始前，A[i].key增大了，有可能会超过A[PARENT(i)].key，循环不变量c依旧满足。\r\n保持：假设在值为\\(i\\)的循环执行之前\\(3\\)个循环不变量仍然保持。令pi = PARENT(i), ppi = PARENT(pi)。交换了节点i和pi后，根据循环不练量a,\r\nb，那么新节点i'满足A[i'] &gt;= A[LEFT(i)].key, A[i'] &gt;= A[RIGHT(i)].key。交换后节点i'保持了最大堆性质。新节点pi'的值相比pi时增大，因此可能发生A[ppi'].key &lt; A[pi'].key的情况，循环不变量c对于pi'仍然成立；在交换之前，根据最大堆性质，A[ppi].key &gt;= A[pi].key, A[ppi].key &gt;= A[i xor 1].key成立。交换后，那么有A[ppi].key &gt;= A[LEFT(pi')].key, A[ppi].key &gt;= A[RIGHT(pi')].key成立，由此循环不变量a,\r\nb保持成立。\r\n终止：最终，循环不变量c中所指出的最多一次冲突将不会存在，此时已经维护好整个最大堆。\r\n6.5-8\r\nMAX-HEAP-INCREASE-KEY(A, x, k)  if k &lt; x.key    error “new key is smaller than current key”  x.key = k  find the index i in array A where object x occurs  tmp = A[i]  while i &gt; 1 and A[PARENT(i)].key &lt; tmp.key    A[i] = A[PARENT(i)]    updating the information that maps priority queue objects to array indices    i = PARENT(i)  A[i] = tmp  updating the information that maps priority queue objects to array indices\r\n6.5-9\r\n我们将假设队列Q，栈S都有一个属性H，表示内置的最大优先队列，还有一个属性stamp，表示当前入栈/入队时应赋予的优先级。问题本质上是插入的元素按照单调递增还是单调递减的方式来赋予优先级。\r\n// 这里的N是指栈/队列默认的最大容量ENQUEUE(Q, x)  x.key = Q.stamp  MAX-HEAP-INSERT(Q.H, x, N)  Q.stamp = Q.stamp - 1DEQUEUE(Q)  x = MAX-HEAP-EXTRACT-MAX(Q.H)  return xPUSH(S, x)  x.key = Q.stamp  MAX-HEAP-INSERT(S.H, x, N)  Q.stamp = Q.stamp + 1POP(Q)  x = MAX-HEAP-EXTRACT-MAX(Q.H)  return x\r\n6.5-10\r\nMAX-HEAP-DELETE(A, x)  find the index i in array A where object x occurs  A[i] = A[A.heap-size]  A.heap-size = A.heap-size - 1  updating the information that maps priority queue objects to array indices  MAX-HEAPIFY(A, i)\r\n可以发现这个伪代码仅有第1行和第4行涉及索引表上的操作，第5行则用于维护最大堆的性质，时间复杂度为\\(O(\\lg n)\\)。因此整体时间复杂度为\\(O(\\lg n)\\)。\r\n6.5-11\r\n需要注意一些细节：\r\n\r\n\\(A[1 : k]\\)是由\\(k\\)个长度不一的已排序数组组成，其中第\\(i\\)个数组的长度表示为A[i].size()。并且下标都是从\\(1\\)开始。\r\n本处使用最小堆的节点中，除了key以外，还有两个卫星数据r, c分别表示key是来自第r个数组的第c个元素。\r\n\r\n第10行的while循环的执行次数恰好为\\(n\\)，因为每一次迭代最小堆弹出了这\\(n\\)个元素中的一个。并且，最小堆最大时的大小只有\\(k\\)，因此整个算法的时间复杂度为\\(O(n\\lg k)\\)。\r\nMERGE-K-SORTED-LISTS(A, k)  Let H be new min-heap  Let B be new array  // n是全部序列长度总和。  n = 0  for i = 1 to k    n = n + A[i].size()  for i = 1 to k    // 堆上的节点x的属性结构是(r, c, key)    MIN-HEAP-INSERT(H, (i, 1, A[i, 1]), n)  while H.heap-size() &gt; 0    r, c, key = MIN-HEAP-EXTRACT-MIN(H)    INSERT(B, key)    if c + 1 &lt;= A[r].size()      MIN-HEAP-INSERT(H, (r, c + 1, A[r, c + 1]), n)  return B\r\n","categories":["算法导论"]},{"title":"算法导论6 Problems 答案","url":"/introduction-to-algorithms/chapter-6/problems/","content":"\r\n6-1\r\na\r\n不会。以数组\\(\\langle1,2,3,4\\rangle\\)为例，使用BUILD-MAX-HEAP建堆的结果为\\(\\langle4,1,3,2\\rangle\\)，使用BUILD-MAX-HEAP'建堆的结果为\\(\\langle4,3,2,1\\rangle\\)。\r\nb\r\n当元素\\(A\\)的顺序是有序时，将达到最坏情况，因为此时新加入的元素都会从叶节点上升到根节点，第\\(i\\)次加入的元素在第$ i \\(层，因此其运行时间\\)T(n)$满足：\r\n\\(\\displaystyle{T(n)=\\sum_{k=2}^n \\lg k =\r\n\\lg n! = \\Theta(n\\lg n)}\\)\r\n6-2\r\na\r\n使用数组来表示\\(d\\)叉堆的方式如下：\r\n// 参数d假设已经存在。D-PARENT(i)  return ⌊(i - 2) / d⌋ + 1// 求下标为i的第j个孩子节点的下标，1 &lt;= j &lt;= dD-CHILD(i, j)  return d * (i - 1) + j + 1\r\n正确性：自己的孩子的父亲必定为自身：\\(\\left\\lfloor\\dfrac{(d(i-1)+j+1)-2}{d}\\right\\rfloor+1=i-1+\\left\\lfloor\\dfrac{j-1}{d}\\right\\rfloor+1=i\\)。\r\nb\r\n每个节点的都会有\\(d\\)个，它的高度将会以\\(d\\)为底数的速度增长，即\\(\\Theta(\\log_d n)\\)。\r\nc\r\nD-MAX-HEAP-EXTRACT-MAX(A)  if A.heap-size &lt; 1    error “heap underflow”  max = A[1]  A[1] = A[A.heap-size]  A.heap-size = A.heap-size – 1  D-MAX-HEAPIFY(A, 1)  return maxD-MAX-HEAPIFY(A, i)  largest = i  for j = 1 to d    son = D-CHILD(i, j)    if son &lt;= A.heap-size and A[son] &gt; A[largest]      largest = son  if largest ≠ i    exchange A[i] with A[largest]    D-MAX-HEAPIFY(A, largest)\r\n算法D-MAX-HEAP-EXTRACT-MAX没有循环制语句，仅仅第6行调用了子程序D-MAX-HEAPIFY。因此处主要分析算法D-MAX-HEAPIFY的效率。\r\n算法D-MAX-HEAPIFY是个递归的程序，第8行表明每进行一次递归它将会向叶节点移动，因此按照题目6-1-b的结论，这个算法最多递归\\(\\Theta(\\log_d\r\nn)\\)次。第2行的for循环用于维护最大堆的结构，查找最大的子节点，并且循环结束后将会和父节点交换，其循环的次数为\\(d\\)。\r\n因此，整个算法的时间复杂度为\\(\\Theta(d\\log_d n)\\)。\r\nd\r\nD-MAX-HEAP-INCREASE-KEY(A, x, k)  if k &lt; x.key    error “new key is smaller than current key”  x.key = k  find the index i in array A where object x occurs  while i &gt; 1 and A[PARENT(i)].key &lt; A[i].key    exchange A[i] with A[PARENT(i)], updating the information that maps priority queue objects to array indices  i = D-PARENT(i)\r\n算法D-MAX-HEAP-INCREASE-KEY的时间复杂度为\\(O(\\log_d\r\nn)\\)，因为while执行的次数不超过整个\\(d\\)叉堆的高度。\r\ne\r\nD-MAX-HEAP-INSERT(A, x, n)  if A.heap-size == n    error “heap overflow”  A.heap-size = A.heap-size + 1  k = x.key  x.key = –∞  A[A.heap-size] = x  map x to index heap-size in the array  D-MAX-HEAP-INCREASE-KEY(A, x, k)\r\n算法D-MAX-HEAP-INSERT没有循环制语句，仅仅第8行调用了子程序D-MAX-HEAP-INCREASE-KEY。因此这个算法的时间复杂度和D-MAX-HEAP-INCREASE-KEY一样，为\\(O(\\log_d n)\\)。\r\n6-3\r\na\r\n\\(\\begin{aligned}\r\n&amp; 2 &amp;&amp; 3 &amp;&amp; 4 &amp;&amp; 5\\\\\r\n&amp; 8 &amp;&amp; 9 &amp;&amp; 12 &amp;&amp; 14\\\\\r\n&amp; 16 &amp;&amp; \\infty &amp;&amp; \\infty &amp;&amp; \\infty\\\\\r\n&amp; \\infty &amp;&amp; \\infty &amp;&amp; \\infty &amp;&amp; \\infty\r\n\\end{aligned}\\)\r\nb\r\n如果\\(Y[1,1]=\\infty\\)，由于\\(Y\\)矩阵的第\\(1\\)行是从小到大排序的，那么只能有\\(Y[1,2]=Y[1,3]=\\dots=Y[1,n]=\\infty\\)。由于\\(Y\\)矩阵每列都是从小到大排序的，那么整个矩阵全部元素都为\\(\\infty\\)，因此整个矩阵为空。\r\n类似的，如果\\(Y[m,n]&lt;\\infty\\)，那么由于\\(Y\\)矩阵的第\\(m\\)行是从小到大排序的，那么有\\(Y[m,1]&lt;\\infty,T[m,2]&lt;\\infty,\\dots,Y[m,n-1]&lt;\\infty\\)。由于\\(Y\\)矩阵每列都是从小到大排序的，那么整个矩阵全部元素都不为\\(\\infty\\)，因此整个矩阵为满。\r\nc\r\nMIN-Y(A, m, n, i, j)  if j &lt; n and A[i, j + 1] &lt; A[i, j]    (smallesti, smallestj) = (i, j + 1)  else    (smallesti, smallestj) = (i, j)  if i &lt; m and A[i + 1, j] &lt; A[smallesti, smallestj]    (smallesti, smallestj) = (i + 1, j)  if (i, j) != (smallesti, smallestj)    exchange A[i, j] and A[smallesti, smallestj]    MIN-Y(A, m, n, smallesti, smallestj)EXTRACT-MIN-Y(A, m, n)  min = A[1, 1]  A[1, 1] = ∞  MIN-Y(A, m, n, 1, 1)  return min\r\n算法EXTRACT-MIN-Y没有循环制语句，仅仅第3行调用了子程序MIN-Y。因此处主要分析算法MIN-Y的效率。\r\n算法MIN-Y是个递归的程序，它每调用自身一次后，要么\\(i\\)增加\\(1\\)，要么\\(j\\)增加\\(1\\)。因此这个程序最多有\\(n+m-1\\)次递归调用。因此整个程序的时间复杂度为\\(O(n+m)\\)。\r\nd\r\nMIN-Y&#x27;(A, m, n, i, j)  if j &gt; 1 and A[i, j - 1] &gt; A[i, j]    (largesti, largestj) = (i, j - 1)  else    (largesti, largestj) = (i, j)  if i &gt; 1 and A[i - 1, j] &gt; A[largesti, largestj]    (largesti, largestj) = (i - 1, j)  if (i, j) != (largesti, largestj)    exchange A[i, j] and A[largesti, largestj]    MIN-Y&#x27;(A, m, n, largesti, largestj)INSERT-Y(A, m, n, x)  if A[m, n] != ∞    error “heap overflow”  A[m, n] = x  MIN-Y&#x27;(A, m, n, m, n)\r\n本题和题目6-3-c非常相似。\r\n算法INSERT-Y没有循环制语句，仅仅第4行调用了子程序MIN-Y'。因此处主要分析算法MIN-Y'的效率。\r\n算法MIN-Y'是个递归的程序，它每调用自身一次后，要么\\(i\\)减少\\(1\\)，要么\\(j\\)减少\\(1\\)。因此这个程序最多有\\(n+m-1\\)次递归调用。因此整个程序的时间复杂度为\\(O(n+m)\\)。\r\ne\r\n// A是一个含有n^2个元素的序列SORT-BY-Y(A, n)  lew B[1 : n, 1 : n] be new table with ∞  for i = 1 to n * n    INSERT-Y(B, n, n, A[i])  for i = 1 to n * n    A[i] = EXTRACT-MIN-Y(A, n, n)  return A\r\n由于第2, 4行中的循环长度都是\\(n^2\\)，算法INSERT-Y, EXTRACT-MIN的时间复杂度都是\\(O(n)\\)，因此算法SORT-BY-Y的时间度为\\(O(n^3)\\)。\r\nf\r\nFIND-Y(A, m, n, x)  i = m  j = 1  while i &gt;= 1 and j &lt;= n    if A[i, j] == x      return True    else if A[i, j] &lt; x      j = j + 1    else      i = i - 1  return 0\r\n这个算法的基本思想是从左下角查找到右上角，查找每一行\\(A[i,j]&lt;\r\nx,a[i,j+1]&gt;x\\)的边界。由于每一轮循环中，要么\\(i\\)减去\\(1\\)，要么\\(j\\)增加\\(1\\)，因此这个循环最多执行\\(n+m-1\\)次。算法FIND-Y时间复杂度为\\(O(n+m)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论8.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-8/exercises-1/","content":"\r\n8.1-1\r\n当\\(a\\)具有单调性，即\\(a_1\\le a_2\\le \\dots\\le a_n\\)或\\(a_1\\ge a_2\\ge \\dots\\ge\r\na_n\\)时，这时仅需要\\(n-1\\)次决策决定出这个序列，其深度为\\(n-1\\)。\r\n8.1-2\r\n可以发现，函数\\(f(x)=\\lg\r\nx\\)是单调递增函数。因此根据不等式\\(A.18\\)，有\r\n\\(\\begin{aligned}\r\n\\lg n! =\\sum_{k=1}^{n} \\lg k \\le \\int_{1}^{n+1} \\lg x dx = \\left. x\\lg\r\nx-\\dfrac{x}{\\ln 2}\\right|_1^{n+1} = (n+1)\\lg (n+1)-\\dfrac{n}{\\ln 2} \\le\r\n(n+1)\\lg (n+1)\r\n\\end{aligned}\\)\r\n同时有\r\n\\(\\begin{aligned}\r\n\\lg n! =\\sum_{k=1}^{n}\\lg k=\\sum_{k=2}^{n}\\lg k \\ge \\int_{1}^{n} \\lg x\r\ndx = \\left. x\\lg x-\\dfrac{x}{\\ln 2}\\right|_1^{n} = n\\lg\r\nn-\\dfrac{n-1}{\\ln 2}\r\n\\end{aligned}\\)\r\n因此可以得出\\(\\lg n! = \\Theta(n\\lg\r\nn)\\)。\r\n8.1-3\r\n至少\\(\\dfrac{n!}{2}\\)个叶节点的树的高度\\(h\\)满足\\(2^h\\ge\r\nl\\ge \\dfrac{n!}{2}\\)，可以得到\\(h\\ge\r\n\\lg n!-1=\\Theta(n\\lg n) - 1=\\Theta(n\\lg\r\nn)\\)。由此可知，不存在排序算法使得至少一半的排列拥有线性排序的算法。\r\n类似的，至少\\(\\dfrac{1}{n}\\cdot\r\nn!\\)个叶节点的树的高度\\(h\\)满足\\(2^h\\ge\r\nl\\ge (n-1)!\\)，可以得到\\(h\\ge \\lg\r\n(n-1)!=\\Theta((n-1)\\lg (n-1)) -=\\Theta(n\\lg\r\nn)\\)。得出的结论与之前相同。\r\n至少\\(\\dfrac{1}{2^n}\\cdot\r\nn!\\)个叶节点的树的高度\\(h\\)满足\\(2^h\\ge\r\nl\\ge \\dfrac{n!}{2^n}\\)，可以得到\\(h\\ge\r\n\\lg n! - n=\\Theta(n\\lg n)-n =\\Theta(n\\lg\r\nn)\\)。得出的结论与之前仍然相同。\r\n8.1-4\r\n为了方便进行分析，假设长度\\(n\\)是\\(4\\)的倍数。\r\n那么对于每个第\\(k\\)小（注意\\(k\\)是\\(4\\)的倍数），那么除了最后一个元素仅有\\(2\\)种，每个元素都有\\(3\\)种选择。剩下的\\(3n/4\\)个元素任意排列，因此这种序列一共有\\((3n/4)!\\cdot\r\n3^{n/4-1}\\cdot2\\)个。哪怕忽略掉不符合这些条件的序列，这\\((3n/4)!\\cdot\r\n3^{n/4-1}\\cdot2\\)个叶节点，组成的决策树的高度\\(h\\)至少为\\(2^h\\ge\r\nl\\ge (3n/4)!\\cdot 3^{n/4-1}\\cdot2\\)。即\\(h\\ge 3n/4\r\n\\lg(3n/4)+(n/4-1)\\lg3+1\\)，最终得到\\(h=\r\n\\Omega(n\\lg n)\\)。\r\n因此，如果这种排序算法，它的时间复杂度依然有下界\\(\\Omega(n\\lg n)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论6.4 Exercises 答案","url":"/introduction-to-algorithms/chapter-6/exercises-4/","content":"\r\n6.4-1\r\n完成建堆后，数组变成\\(\\langle25,13,20,8,7,17,2,5,4\\rangle\\)。\r\n在排序过程中，用数组来表示这个堆的变化（横线标出变化之处）：\r\n\\(\\begin{aligned}\r\n\\langle\\underline{25},13,20,8,7,17,2,5,4\\rangle\\\\\r\n\\langle\r\n\\underline{20},13,\\underline{17},8,7,\\underline{4},2,5|25\\rangle\\\\\r\n\\langle \\underline{17},13,\\underline{5},8,7,4,2|20,25\\rangle\\\\\r\n\\langle\r\n\\underline{13},\\underline{8},5,\\underline{2},7,4|17,20,25\\rangle\\\\\r\n\\langle\r\n\\underline{8},\\underline{7},5,2,\\underline{4}|13,17,20,25\\rangle\\\\\r\n\\langle \\underline{7},\\underline{4},5,2|8,13,17,20,25\\rangle\\\\\r\n\\langle \\underline{5},4,\\underline{2}|7,8,13,17,20,25\\rangle\\\\\r\n\\langle \\underline{4},\\underline{2}|5,7,8,13,17,20,25\\rangle\\\\\r\n\\langle 2,4,5,7,8,13,17,20,25\\rangle\\\\\r\n\\end{aligned}\\)\r\n6.4-2\r\n初始化：在第\\(n\\)次循环开始前，堆已经建好，满足最大堆的情况，所有\\(n\\)个最小的数都在里面；数组\\(A[n+1:n]\\)为空，包含\\(0\\)个最大元素，已经是有序的。\r\n保持：完成了第\\(k\\)个值\\(A[k]\\)和最大堆的值\\(A[1]\\)的交换后，那么现在数组\\(A[k:n]\\)是\\(A\\)中最大的\\(n-k+1\\)个数，并且将堆的大小减少了\\(1\\)，保证属于堆的部分和已排序部分不相交。交换完成后，此时只有根节点可能并不满足最大堆的性质，调用一次MAX-HEAPIFY(A, 1)即可使得\\(A[1:k-1]\\)保持最大堆的性质。\\(A[k:n]\\)一部分是有序的。\r\n终止：堆中只剩下\\(1\\)个最小值，已排序部分则是\\(n-1\\)个最大的数。因此最终整个序列是有序的。\r\n6.4-3\r\n两者的的时间复杂度均为\\(O(n\\lg\r\nn)\\)。建堆后，那么只考虑单次的MAX-HEAPIFY操作为\\(O(\\lg n)\\)。整个过程运行时间为\\(O(n\\lg n)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论8.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-8/exercises-2/","content":"\r\n8.2-1\r\n第一次循环结束后，得到数组\\(C=\\langle2,2,2,2,1,0,2\\rangle\\).\r\n第二次循环结束后，得到数组\\(C=\\langle2,4,6,8,9,9,11\\rangle\\).\r\n那么第三次循环，依次得到：\r\n\\(\\begin{array}{ll}\r\nB&amp;C\\\\\r\n\\langle\\phantom{2},\\phantom{2},\\phantom{2},\\phantom{2},\\phantom{2},\\phantom{2},\\phantom{2},\\phantom{2},\\phantom{2},\\phantom{2},\\phantom{2}\\rangle\r\n&amp; \\langle2,4,6,8,9,9,11\\rangle\\\\\r\n\\langle\\phantom{2},\\phantom{2},\\phantom{2},\\phantom{2},\\phantom{2},2,\\phantom{2},\\phantom{2},\\phantom{2},\\phantom{2},\\phantom{2}\\rangle\r\n&amp; \\langle2,4,5,8,9,9,11\\rangle\\\\\r\n\\langle\\phantom{2},\\phantom{2},\\phantom{2},\\phantom{2},\\phantom{2},2,\\phantom{2},3,\\phantom{2},\\phantom{2},\\phantom{2}\\rangle\r\n&amp; \\langle2,4,5,7,9,9,11\\rangle\\\\\r\n\\langle\\phantom{2},\\phantom{2},\\phantom{2},1,\\phantom{2},2,\\phantom{2},3,\\phantom{2},\\phantom{2},\\phantom{2}\\rangle\r\n&amp; \\langle2,3,5,7,9,9,11\\rangle\\\\\r\n\\langle\\phantom{2},\\phantom{2},\\phantom{2},1,\\phantom{2},2,\\phantom{2},3,\\phantom{2},\\phantom{2},6\\rangle\r\n&amp; \\langle2,3,5,7,9,9,10\\rangle\\\\\r\n\\langle\\phantom{2},\\phantom{2},\\phantom{2},1,\\phantom{2},2,\\phantom{2},3,4,\\phantom{2},6\\rangle\r\n&amp; \\langle2,3,5,7,8,9,10\\rangle\\\\\r\n\\langle\\phantom{2},\\phantom{2},\\phantom{2},1,\\phantom{2},2,3,3,4,\\phantom{2},6\\rangle\r\n&amp; \\langle2,3,5,6,8,9,10\\rangle\\\\\r\n\\langle\\phantom{2},\\phantom{2},1,1,\\phantom{2},2,3,3,4,\\phantom{2},6\\rangle\r\n&amp; \\langle2,2,5,6,8,9,10\\rangle\\\\\r\n\\langle\\phantom{2},0,1,1,\\phantom{2},2,3,3,4,\\phantom{2},6\\rangle &amp;\r\n\\langle1,2,5,6,8,9,10\\rangle\\\\\r\n\\langle\\phantom{2},0,1,1,2,2,3,3,4,\\phantom{2},6\\rangle &amp;\r\n\\langle1,2,4,6,8,9,10\\rangle\\\\\r\n\\langle0,0,1,1,2,2,3,3,4,\\phantom{2},6\\rangle &amp;\r\n\\langle0,2,4,6,8,9,10\\rangle\\\\\r\n\\langle0,0,1,1,2,2,3,3,4,6,6\\rangle &amp; \\langle0,2,4,6,8,9,9\\rangle\\\\\r\n\\end{array}\\)\r\n8.2-2\r\n考虑两个下标\\(i,j\\)满足\\(A[i]=A[j]=x,i&lt;\r\nj\\)。第11行的逆序for循环将会使得\\(A[j]\\)先被访问，\\(A[i]\\)后被访问。当访问到\\(A[j]\\)时，数\\(A[j]\\)被放置到了数组\\(B\\)中的位置\\(C[x]\\)，接下来\\(C[x]\\)将会自减\\(1\\)。由于这个for循环中，\\(C\\)数组中的所有值只会递减，不会递增，因此当访问到\\(A[i]\\)时，此时的\\(C&#39;[x]&lt;C[x]\\)，即彼时访问\\(A[j]\\)前的\\(C[x]\\)。因此，\\(A[i]\\)将会放置到位置\\(C&#39;[x]\\)中，保持了相对顺序。因此，这种实现下的计数排序是稳定的。\r\n8.2-3\r\n将循环正序，并不会影响排序的正确性。只要键相同，先后放置顺序并不重要，不同元素间的顺序将仍然保持。排序程序转换成不稳定的原因是对于两个下标\\(i,j\\)满足\\(A[i]=A[j]=x,i&lt; j\\)，由于\\(i\\)先被遍历，\\(j\\)后被遍历，但是第11行的for循环下，\\(C\\)数组仍然是递减的，这将导致排序后，\\(A[i]\\)会被放置在\\(A[j]\\)的后面，因此仍然是不稳定的。\r\nCOUNTING-SORT&#x27;(A, n, k)  let B[1 : n] and C[0 : k] be new arrays    for i = 0 to k      C[i] = 0  for j = 1 to n    C[A[j]] = C[A[j]] + 1  // C[i] now contains the number of elements equal to i.  s = 0  for i = 0 to k    c = C[i]    C[i] = s    s += c  // Copy A to B, starting from the end of A.  for j = 1 to n    C[A[j]] = C[A[j]] + 1 // to handle duplicate values    B[C[A[j]]] = A[j]  return B\r\n8.2-4\r\n初始化：一开始值为\\(n\\)的循环迭代前，\\(C[i]\\)表示数组\\(A\\)中有多少个数小于等于\\(i\\)，也就是最后一个\\(i\\)所放置的位置，循环不变量成立。\r\n保持：在值为\\(i\\)的循环开始前，\\(C[A[i]]\\)代表着当前数\\(C[A[i]]\\)中应该放置的位置。第12行的代码将\\(A[i]\\)放置到正确的位置，第13行将\\(C[A[i]]\\)自减\\(1\\)，如果存在下一个\\(A[j]=A[i]=x,j&lt;\r\ni\\)，那么它确实应该放置在\\(C[A[i]]-1\\)处，因为两个数相同，应该放在一起；如果不存在，那么\\(C[A[i]]\\)的值永远不会被访问到，可以忽略。因此，值为\\(i\\)的循环完成后，数组\\(C\\)的含义仍然保持，循环不变量成立。\r\n终止，循环完成后，数组\\(C\\)中所有值都将被忽略，数组\\(B\\)是个有序的数组，循环正确终止。\r\n8.2-5\r\n// 没有卫星数据，意味着不需要考虑排序的稳定性，直接赋值即可。COUNTING-SORT&#x27;&#x27;(A, n, k)  let C[0 : k] be new array    for i = 0 to k      C[i] = 0  for j = 1 to n    C[A[j]] = C[A[j]] + 1  // C[i] now contains the number of elements equal to i.  p = 0  for i = 0 to k    for j = 1 to C[i]      p += 1      A[p] = i  return A\r\n8.2-6\r\n可以发现，算法ANSWER-QUERY的第10行中，每次循环都是\\(O(1)\\)常数级别的。\r\n//数组Q表示询问列表，Q[i].a和Q[i].b表示题中的a和b。 ANSWER-QUERY(A, n, k, Q, q)  let B[1 : q], C[0 : k] be new array    for i = 0 to k      C[i] = 0  for j = 1 to n    C[A[j]] = C[A[j]] + 1  // C[i] now contains the number of elements equal to i.  for i = 1 to k    C[i] = C[i] + C[i – 1]  // C[i] now contains the number of elements less than or equal to i.  for i = 1 to q    s = C[Q[i].b]    // 减去区间[0, a)中的所有数，为了避免越界，需要进行判断。    if Q[i].a &gt; 0      s = s - C[Q[i].a - 1]    B[i] = s  return B\r\n8.2-7\r\n基本思想是：通过对每个浮点数乘以\\(10^d\\)转换成整数，再统计到下标中，然后排序完成后再转换成浮点数。\r\nCOUNTING-SORT-FLOAT(A, n, k, d)  // 假设POW(10, d)是一个常数，能以O(1)的时间被计算出。  K = k * POW(10, d)  let B[1 : n], C[0 : K] be new array    for i = 0 to K      C[i] = 0  for j = 1 to n    t = A[j] * POW(10, d)    C[t] = C[t] + 1  // C[i] now contains the number of elements equal to i.  for i = 1 to K    C[i] = C[i] + C[i – 1]  // C[i] now contains the number of elements less than or equal to i.  for j = n downto 1    t = A[j] * POW(10, d)    B[C[t]] = A[j]    C[t] = C[t] – 1  return B\r\n","categories":["算法导论"]},{"title":"算法导论8.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-8/exercises-3/","content":"\r\n8.3-1\r\n\\(\\begin{aligned}\r\n\\mathtt{COW} \\\\ \\mathtt{DOG} \\\\ \\mathtt{SEA} \\\\ \\mathtt{RUG} \\\\\r\n\\mathtt{ROW} \\\\ \\mathtt{MOB} \\\\ \\mathtt{BOX} \\\\ \\mathtt{TAB} \\\\\r\n\\mathtt{BAR} \\\\ \\mathtt{EAR} \\\\ \\mathtt{TAR} \\\\ \\mathtt{DIG} \\\\\r\n\\mathtt{BIG} \\\\ \\mathtt{TEA} \\\\ \\mathtt{NOW} \\\\ \\mathtt{FOX} \\\\\r\n\\end{aligned}\\quad\\rightarrow\\quad\r\n\\begin{aligned}\r\n\\mathtt{SE\\underline{A}} \\\\ \\mathtt{TE\\underline{A}} \\\\\r\n\\mathtt{MO\\underline{B}} \\\\ \\mathtt{TA\\underline{B}} \\\\\r\n\\mathtt{RU\\underline{G}} \\\\ \\mathtt{DO\\underline{G}} \\\\\r\n\\mathtt{DI\\underline{G}} \\\\ \\mathtt{BI\\underline{G}} \\\\\r\n\\mathtt{BA\\underline{R}} \\\\ \\mathtt{EA\\underline{R}} \\\\\r\n\\mathtt{TA\\underline{R}} \\\\ \\mathtt{CO\\underline{W}} \\\\\r\n\\mathtt{RO\\underline{W}} \\\\ \\mathtt{NO\\underline{W}} \\\\\r\n\\mathtt{BO\\underline{X}} \\\\ \\mathtt{FO\\underline{X}} \\\\\r\n\\end{aligned}\\quad\\rightarrow\\quad\r\n\\begin{aligned}\r\n\\mathtt{T\\underline{A}B} \\\\ \\mathtt{B\\underline{A}R} \\\\\r\n\\mathtt{E\\underline{A}R} \\\\ \\mathtt{T\\underline{A}R} \\\\\r\n\\mathtt{S\\underline{E}A} \\\\ \\mathtt{T\\underline{E}A} \\\\\r\n\\mathtt{D\\underline{I}G} \\\\ \\mathtt{B\\underline{I}G} \\\\\r\n\\mathtt{M\\underline{O}B} \\\\ \\mathtt{D\\underline{O}G} \\\\\r\n\\mathtt{C\\underline{O}W} \\\\ \\mathtt{R\\underline{O}W} \\\\\r\n\\mathtt{N\\underline{O}W} \\\\ \\mathtt{B\\underline{O}X} \\\\\r\n\\mathtt{F\\underline{O}X} \\\\ \\mathtt{R\\underline{U}G} \\\\\r\n\\end{aligned}\\quad\\rightarrow\\quad\r\n\\begin{aligned}\r\n\\mathtt{\\underline{B}AR} \\\\ \\mathtt{\\underline{B}IG} \\\\\r\n\\mathtt{\\underline{B}OX} \\\\ \\mathtt{\\underline{C}OW} \\\\\r\n\\mathtt{\\underline{D}IG} \\\\ \\mathtt{\\underline{D}OG} \\\\\r\n\\mathtt{\\underline{E}AR} \\\\ \\mathtt{\\underline{F}OX} \\\\\r\n\\mathtt{\\underline{M}OB} \\\\ \\mathtt{\\underline{N}OW} \\\\\r\n\\mathtt{\\underline{R}OW} \\\\ \\mathtt{\\underline{R}UG} \\\\\r\n\\mathtt{\\underline{S}EA} \\\\ \\mathtt{\\underline{T}AB} \\\\\r\n\\mathtt{\\underline{T}AR} \\\\ \\mathtt{\\underline{T}EA} \\\\\r\n\\end{aligned}\\)\r\n8.3-2\r\n插入排序和归并排序是稳定的，堆排序和快速排序是不稳定的。\r\n为了强迫这两种排序是稳定的，可以考虑将每一个数\\(A[i]\\)和它的下标\\(i\\)组合成为一个二元组\\((A[i],i)\\)，然后再进行排序，这些二元组的比较规则是如果第\\(1\\)关键字不一样，那么以第\\(1\\)关键字比较结果为最终结果，否则以第\\(2\\)关键比较结果为最终结果（即字典序）。如对数组\\(\\langle\r\n2,2,3,1,1\\rangle\\)就转化成了对二元组\\(\\langle\r\n(2,1),(2,2),(3,3),(1,4),(1,5)\\rangle\\)进行排序。由于第\\(2\\)关键字必定不一样（因为是下标），所以每一对二元组都是不一样的，从而保证了第\\(1\\)关键字的稳定性。\r\n附加的代价：每一个元素都需要多一个值来代替，空间占用多了一倍；如果数值相同，那么还需要多进行一次比较，但是不考虑常数的情况下，时间复杂度仍然相同。\r\n8.3-3\r\n使用归纳法的证明过程如下。\r\n假设第\\(i\\)次循环开始前，所有数已经按照第前\\(i-1\\)位完成排序，第\\(i\\)次循环完成后，所有数已经按照第前\\(i\\)位完成排序。\r\n当\\(i=1\\)的循环进行前，已经按照\\(0\\)个关键字进行排序，原结论成立。\r\n当\\(i&gt;1\\)时，假设已经按照前\\(i-1\\)位完成排序，那么考虑第\\(i\\)位。如果两个数的第\\(i\\)位相同，那么由于这个调用的排序算法是一个稳定排序算法，那么它们的顺序仍然保持不变；如果两个数的第\\(i\\)位不同，那么这两个数按照这个数位进行排序。最终排序完成后，所有数已经按照第前\\(i\\)位完成排序。\r\n因此，基数排序算法是正确的。\r\n8.3-4\r\n计数排序中，子程序计算\\(C\\)数组的部分可以离线\\(1\\)次完成，在这\\(1\\)次中，只需要计算\\(d\\)次即可，将\\(C\\)数组保存成一个\\(d\\times b\\)（这里的\\(b\\)将会非常小）的表留给算法COUNTING-SORT的第11行for循环使用。\r\n计算\\(C\\)数组只需要\\(1\\)次传递，算法COUNTING-SORT的第11行for循环使用了\\(d\\)次，一共仅需\\(d+1\\)次转递。\r\n8.3-5\r\n将每一个数视为一个\\(n\\)进制数。那么由于最大值仅有\\(n^3-1\\)，那么这些数在\\(n\\)进制下仅有\\(3\\)位数，将每个数\\(d_i\\)视为三元组\\((d_{i,2},d_{i,1},d_{i,0})\\)，再进行基数排序即可。\r\n在这种情况下，基数排序的轮数为\\(3\\)次，如果子排序算法使用计数排序，那么每次调用计数排序的值域参数大小为\\(n\\)，而且这个数组的长度也为\\(n\\)。因此整个排序的时间复杂度为\\(O(n)\\)。\r\n\\(\\star\\)\r\n8.3-6\r\n如果一共要给\\(n\\)个数排序，当所有数都不相同时，达到那么最坏情况。此时至少需要\\(n\\)轮的排序；如果这个算法机械地检查到最低位才返回（哪怕是只剩下一个数也不返回），那么可以达到\\(\\Theta(10^d)\\)轮。递归达到最深时，最坏情况下每一位所有数的卡片都要保存一次，即\\(\\Theta(dn)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论7.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-7/exercises-1/","content":"\r\n7.1-1\r\n\\(\\begin{aligned}\r\n&amp;\\langle13, 19, 9, 5, 12, 8, 7, 4, 21, 2, 6, 11\\rangle\\\\\r\n&amp;\\langle[9, 5, 8, 7, 4, 2, 6, \\underline{11}, 21, 13, 19,\r\n12]\\rangle\\\\\r\n&amp;\\langle[5, 4, 2, \\underline{6}, 9, 8, 7], 11, 21, 13, 19,\r\n12\\rangle\\\\\r\n&amp;\\langle[\\underline{2}, 4, 5], 6, 9, 8, 7, 11, 21, 13, 19,\r\n12\\rangle\\\\\r\n&amp;\\langle2, [4, \\underline{5}], 6, 9, 8, 7, 11, 21, 13, 19,\r\n12\\rangle\\\\\r\n&amp;\\langle2, 4, 5, 6, [\\underline{7}, 8, 9], 11, 21, 13, 19,\r\n12\\rangle\\\\\r\n&amp;\\langle2, 4, 5, 6, 7, [8, \\underline{9}], 11, 21, 13, 19,\r\n12\\rangle\\\\\r\n&amp;\\langle2, 4, 5, 6, 7, 8, 9, 11, [\\underline{12}, 13, 19,\r\n21]\\rangle\\\\\r\n&amp;\\langle2, 4, 5, 6, 7, 8, 9, 11, 12, [13, 19,\r\n\\underline{21}]\\rangle\\\\\r\n&amp;\\langle2, 4, 5, 6, 7, 8, 9, 11, 12, [13, \\underline{19}],\r\n21\\rangle\\\\\r\n&amp;\\langle2, 4, 5, 6, 7, 8, 9, 11, 12, 13, 19, 21\\rangle\\\\\r\n\\end{aligned}\\)\r\n7.1-2\r\n将会返回\\(r\\)，因为所有元素都小于等于同一个值，它们都被划分到左半部分。\r\n考虑使用HOARE-PARTITION可以解决这个问题。\r\nHOARE-PARTITION(A, p, r)  x = A[p]  i = p – 1  j = r + 1  while TRUE  repeat    j = j – 1  until A[j] ≤ x  repeat    i = i + 1  until A[i] ≥ x  if i &lt; j    exchange A[i] with A[j]  else return j\r\n7.1-3\r\n算法PARTITION仅有一个轮数为\\(r-p\\)的for循环，在第3行。其余代码都是常数时间的操作，因此算法PARTITION的时间复杂度为\\(\\Theta(r-p)=\\Theta(n)\\)。\r\n7.1-4\r\nPARTITION-DECREASE(A, p, r)  x = A[r] // the pivot  i = p – 1 // highest index into the low side  for j = p to r – 1 // process each element other than the pivot    if A[j] ≥ x // does this element belong on the low side?      i = i + 1 // index of a new slot in the low side      exchange A[i] with A[j] // put this element there  exchange A[i + 1] with A[r] // pivot goes just to the right of the low side  return i + 1\r\n","categories":["算法导论"]},{"title":"算法导论7.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-7/exercises-2/","content":"\r\n7.2-1\r\n假设\\(T(n)\\le cn^2-d\\)，那么有\r\n针对\\(f(n)=\\Theta(n)\\)，可以知道\\(\\exists c_0,n_0&gt;0,\\forall n\\ge n_0,0\\le n\\le\r\nc_0n\\)成立。因此假设\\(n\\ge\r\nn_0\\)，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=T(n-1)+\\Theta(n)\\\\\r\n&amp;\\le c(n-1)^2-d+c_0n\\\\\r\n&amp;\\le cn^2-2cn+c-d+c_0n\\\\\r\n&amp;= cn^2-(d-c)-(2cn-c_0n)\\\\\r\n&amp;\\le cn^2-(2cn-c_0n)&amp;\\qquad(A)\\\\\r\n&amp;\\le cn^2&amp;\\qquad(B)\r\n\\end{aligned}\\)\r\n其中，步骤\\((A)\\)假设了\\(d\\ge c\\)成立。步骤\\((B)\\)假设了\\(2c\\ge\r\nc_0\\)。最终，由数学归纳法，原结论\\(T(n)=O(n^2)\\)成立。\r\n假设\\(T(n)\\ge\r\nc&#39;n^2\\)，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=T(n-1)+\\Theta(n)\\\\\r\n&amp;\\ge c&#39;(n-1)^2+\\Theta(n)\\\\\r\n&amp;= c&#39;n^2-2c&#39;n+c&#39;+\\Theta(n)\\\\\r\n&amp;\\ge c&#39;n^2-2c&#39;n+\\Theta(n)\\\\\r\n&amp;= c&#39;n^2-(2c&#39;n-\\Theta(n))\\\\\r\n&amp;\\ge c&#39;n^2&amp;\\qquad(A)\r\n\\end{aligned}\\)\r\n其中步骤\\((A)\\)假设了\\(2c&#39;n\\)渐进上界比\\(\\Theta(n)\\)大。\r\n令\\(c&#39;=\\min(1,T(1)),n_0=1\\)。由于\\(T(1)\\ge c&#39;\\ge\r\nc&#39;n^2\\)，那么由数学归纳法，结论\\(T(n)=\\Omega(n^2)\\)成立。\r\n因此，最终得到\\(T(n)=\\Theta(n^2)\\)。\r\n7.2-2\r\n\\(\\Theta(n^2)\\)，因为每一次的划分都会将所有元素划分到同一侧。每进行一层递归只划分出了一个空数组和一个长度为\\(n-1\\)的数组。因此根据题目7.2-1的结论，时间复杂度为\\(\\Theta(n^2)\\)。\r\n7.2-3\r\n由于序列已经排好序，因此算法PARTITION每次选择的支点都将会是最小值。最终算法PARTITION完成后，支点到达了最左端，并且所有元素都在右侧，依然保持降序。和题目7.2-2一样，每进行一层递归只划分出了一个空数组和一个长度为\\(n-1\\)的数组。因此根据题目7.2-1的结论，时间复杂度为\\(\\Theta(n^2)\\)。\r\n7.2-4\r\n以下是插入排序算法的代码：\r\nINSERTION-SORT(A, n)  for i = 2 to n    key = A[i]    j = i – 1    while j &gt; 0 and A[j] &gt; key      A[j + 1] = A[j]      j = j – 1    A[j + 1] = key\r\n考虑使用逆序数\\(I\\)来衡量一个序列的排序程度。如果逆序数越小，可以认为排序程度越小。\r\n根据题目2-4-c的结论，插入排序的时间复杂度为\\(O(n+I)\\)。如果逆序数越小，说明插入排序的效率越高。\r\n如果一个序列\\(A\\)排序程度越高，那么在使用算法PARTITION进行划分时，在\\(A[p:r]\\)取到的支点\\(A[r]\\)可能在\\(A[p:r]\\)中是比较接近最大值的。那么最终划分完成后，左侧元素数量比右侧多很多，从而划分情况不是特别理想。此时糟糕的划分将会导致快速排序算法效率不会太好。\r\n因此，总而言之，对一个接近排序的数组进行排序使用插入排序效果比快速排序好。\r\n7.2-5\r\n不失一般性，假设分得的\\(\\alpha\\)一直在左侧，否则可以旋转整个区间。\r\n那么，递归树的左侧深度是满足最小的\\(h\\)，使得\\(n\\cdot\\alpha ^h\\le 1\\)成立，从而得到\\(h\\ge \\log_{\\alpha}\r\n1/n\\)。经过对数的变换，最终得到\\(h\\ge\r\n\\log_{1/\\alpha} n\\)。因此最浅的叶子节点高度为\\(h\\ge \\log_{1/\\alpha}\r\nn\\)。同理，可以计算出最深叶子节点高度为\\(\\log_{1/\\beta} n\\)。\r\n7.2-6\r\n由于所有排列出现的概率都均等，因此出现在数组\\(A\\)最后一个数的概率是均等的。对于一个长度为\\(n\\)的数组，如果最后一个数是第\\(i\\)小的，那么使用算法PARTITION进行划分后，将会有\\(i\\)个元素在左侧（包括支点），\\(n-i\\)个元素在右侧，划分比例为\\(\\dfrac{i}{n}:\\dfrac{n-i}{n}\\)。可以发现，当\\(j=n+1-i\\)时，划分比例是一样的。\r\n因此，不失一般性，仅仅考虑\\(i\\le\r\nn/2\\)时的情况。划分的元素是第\\(i\\)小时，只有当\\(j\\)满足\\(i&lt;\r\nj&lt; n+1-i\\)时，以\\(j\\)划分才会更均匀，这样的\\(j\\)一共有\\(n+1-i-i-1=n-2i\\)个，占比\\(\\dfrac{n-2i}{n}=1-\\dfrac{2i}{n}\\)。\r\n因此令\\(\\alpha=i/n\\)。对于任意常数\\(\\alpha\\)产生比\\(1-\\alpha:\\alpha\\)更好的划分的概率为\\(1-2\\alpha\\)。\r\n","categories":["算法导论"]},{"title":"算法导论8 Problems 答案","url":"/introduction-to-algorithms/chapter-8/problems/","content":"\r\n8-1\r\na\r\n由于数组\\(A\\)将会有\\(n!\\)个不同的输入，这些输入都会以等概率的形式出现，而且这些原始输入都是决策树\\(T_A\\)的叶节点。因此\\(T_A\\)中每个叶节点都有\\(\\dfrac{1}{n!}\\)的概率被原始输入命中，而其它内部节点由于不是来自原始输入，因此它们不会被原始输入命中，概率值为\\(0\\)。\r\nb\r\n当一棵树\\(LT\\)和另外一颗树\\(RT\\)与一个祖先节点共同构成一棵树\\(T\\)后，\\(LT,RT\\)中所有节点的深度都增加了\\(1\\)（当然也包括了叶节点）。由于祖先节点必定不是\\(T\\)的叶节点，因此\\(T\\)的叶节点必定来自于\\(LT,RT\\)中的叶节点，并且两棵子树的叶节点总数为\\(k\\)。由于所有非祖先节点都增加了\\(1\\)，那么按照\\(D\\)的定义，在\\(D(LT),D(RT)\\)的基础上，\\(D(T)\\)中所有的叶节点的深度都要增加\\(1\\)。因此\\(D(T)=D(LT)+D(RT)+k\\)。\r\nc\r\n如果树\\(T\\)的叶子节点的总数为\\(k\\)，那么必有\\(i\\)个节点来自左子树\\(T_{L}\\)，\\(k-i\\)个节点来自右子树\\(T_{R}\\)。如果\\(D(T)\\)需要最小化，那么各自独立的\\(D(T_L),D(T_R)\\)也需要最小化，根据\\(d,D\\)的定义，有：\r\n\\(\\begin{aligned}\r\nd(k)&amp;=\\min _{T \\text{ have } k \\text{ leaves}} \\{D(T)\\}\\\\\r\n&amp;=\\min_{T \\text{ have } k \\text{ leaves}} \\{D(T_{L}) + D(T_{R}) +\r\nk\\}\\\\\r\n&amp;=\\min_{i=1}^{k-1} \\{\\min_{LT \\text{ have } i \\text{ leaves}}\r\n\\{D(LT)\\} + \\min_{T \\text{ have } k-i \\text{ leaves}} \\{D(RT)\\} +k\\}\\\\\r\n&amp;=\\min_{i=1}^{k-1} \\{d(i)+d(k-i) +k\\}\\\\\r\n\\end{aligned}\\)\r\nd\r\n令\\(f(i)=i\\lg\r\ni+(k-i)\\lg(k-i)\\)，那么\\(f&#39;(i)=\\lg\r\ni-\\lg(k-i),f&#39;&#39;(i)=\\dfrac{1}{i\\cdot \\ln 2}+\\dfrac{1}{(k-i)\\cdot\r\n\\ln 2}\\)。\r\n当\\(f&#39;(i)=0\\)时，得到\\(i=\\dfrac{k}{2}\\)，此时得到\\(f&#39;&#39;\\left(\\dfrac{k}{2}\\right)=\\dfrac{1}{k\\cdot\r\n\\ln 2}&gt;0\\)，也就是说\\(f(i)\\)在\\(i=\\dfrac{k}{2}\\)处取到最小值\\(f\\left(\\dfrac{k}{2}\\right)=k\\lg k-k\\)。\r\n假设\\(d(k_0)\\ge ck_0\\lg\r\nk_0\\)，对于\\(k_0&lt;\r\nk\\)都成立，那么有\r\n\\(\\begin{aligned}\r\nd(k)&amp;=\\min_{i=1}^{k-1} \\{d(i)+d(k-i) +k\\}\\\\\r\n&amp;\\ge \\min_{i=1}^{k-1} \\{ci\\lg i+c(n-i)\\lg (n-i) +k\\}\\\\\r\n&amp;= c\\cdot \\min_{i=1}^{k-1} \\{i\\lg i+(n-i)\\lg (n-i) \\} + k\\\\\r\n&amp;= c(k\\lg k-k)+k\\\\\r\n&amp;= ck\\lg k+(1-c)k\\\\\r\n&amp;\\ge ck\\lg k&amp;\\qquad(A)\r\n\\end{aligned}\\)\r\n其中，步骤\\((A)\\)假设了\\(c\\le 1\\)。\r\n那么最终令\\(c=\\min\\{1,d(2)/2\\}\\)。由数学归纳法，\\(d(k)=\\Omega(k\\lg k)\\)成立。\r\ne\r\n由于决策树\\(T_A\\)一共有\\(n!\\)个叶节点，因此\\(D(T_A)\\ge\r\nd(n!)=\\Omega(n!\\lg(n!))\\)，即\\(D(T_A)=\r\n\\Omega(n!\\lg(n!))\\).\r\n那么平均时间复杂度满足\\(T(n)\\)满足\\(T(n)=\\dfrac{D(T_A)}{n!}=\\Omega(\\lg\r\n(n!))=\\Omega(n\\lg n)\\)。\r\nf\r\n以上证明说明了确定性算法\\(A\\)中，每一个决策都是最优的。如果算法\\(B\\)采用随机决策，那么算法\\(B\\)可能会选到不是最优的决策，从而导致算法\\(B\\)的平均时间复杂度比\\(A\\)高。在这时，原本的算法\\(A\\)就比算法\\(B\\)优秀。\r\n8-2\r\na\r\n直接使用计数排序，其中参数\\(k=1\\)，时间复杂度为\\(\\Theta(n+1)=\\Theta(n)\\)。\r\nb\r\n直接使用快速排序，严格来说只需要调用一次算法PARTITION就可以完成。\r\nSORT-0-1(A, n)  for i = 1 to n    if A[i] == 0      exchange A[i] and A[n]      PARTITION(A, 1, n)      break  \r\nc\r\n直接使用插入排序，不过算法的时间复杂度为\\(\\Theta(n^2)\\)。\r\nd\r\n可以使用算法(a)解决，因为它同时满足了稳定性和时间复杂度的要求，直接以键的形式调用即可。\r\n算法(b)不能的原因是不保证稳定性，算法(c)不能的原因是时间复杂度不满足要求。\r\ne\r\n如下算法做到了原地交换排序，并且是\\(O(n+k)\\)的时间复杂度，但是不是稳定的，第13行的while循环每执行一次那么总会有一个数到达了正确的位置。\r\nCOUNT-SORT&#x27;&#x27;&#x27;(A, n, k)  let B[0 : k], C[0 : k] and D[0 : k] be new arrays  for i = 0 to k    C[i] = 0  for j = 1 to n    C[A[j]] = C[A[j]] + 1  // C[i] now contains the number of elements equal to i.  for i = 1 to k    C[i] = C[i] + C[i – 1]    B[i] = C[i - 1] + 1    D[i] = C[i]  // C [i] now contains the number of elements less than or equal to i.  // B是每一段的起点，C是每一段的终点，当B[i] &gt; C[i]说明这一段所有数已经复位。  for i = 1 to n    while B[A[i]] &lt;= C[A[i]] and (i &lt;= C[A[i]] or i &gt; D[A[i]])      k = A[i]      exchange A[i] and A[C[k]]      C[k] = C[k] - 1\r\n8-3\r\na\r\n先将每个数中按照数位个数放入每个桶中，然后每个桶内部使用基数排序即可（注意这里的基数排序算法RADIX-SORT'相比普通的基数排序算法RADIX-SORT，多了一个判断数组\\(A\\)是否为空的操作，如果为空那么立即返回。如果盲目运行RADIX-SORT，那么时间复杂度将会达到\\(\\Theta(n^2)\\)）。\r\n// m是数组长度。假设每个数x都有属性digits表示位数个数。BUCKET-SORT`(A, m, n)  let B[1 : n] be a new array  for i = 1 to n    make B[i] an empty list  for i = 1 to m    insert A[i] into list B[A[i].digits]  for i = 1 to n    RADIX-SORT&#x27;(B[i], B[i].size, i)  concatenate the lists B[1], B[2], ... , B[n] together in order  return the concatenated lists\r\n最终，算法的时间复杂度为\\(\\displaystyle{O\\left(\\sum_{i=1}^n i\\cdot\r\nc_i\\right)=O(n)}\\)，其中\\(c_i\\)表示数位为\\(i\\)的数的个数。\r\nb\r\n本算法使用的是自顶向下的桶排序算法，先考虑第一个字母，按照字母将它们分到不同的桶中，然后再递归处理每一个桶。将每个桶的字符串排好序后，再将这些字符串数组拼接在一起，从而保证了字典序。\r\n由于每个字符串的每个字符都只会被访问一次，因此排序的时间复杂度为\\(O(n)\\)。\r\nBUCKET-SORT`(S, pos)  if S.size == 0    return  let B[&#x27;a&#x27; : &#x27;z&#x27;] be a new array  let B0 be a new empty list  for i = &#x27;a&#x27; to &#x27;z&#x27;    make B[i] an empty list  for i = 1 to S.size    if pos &lt;= S[i].size      insert S[i] into list B[S[i, pos]]    else      insert S[i] into list B0  for i = &#x27;a&#x27; to &#x27;z&#x27;    BUCKET-SORT&#x27;(B[i], pos + 1)  concatenate the lists B0, B[&#x27;a&#x27;], B[&#x27;b&#x27;], ... , B[&#x27;z&#x27;] together in order  return the concatenated lists\r\n8-4\r\na\r\n对于每一个红色水瓶，遍历每个蓝色水瓶进行倒水实验。如果发现一样多，那么相当于是匹配的，将这两个瓶子挪开并放到一边，拿下一个红色水瓶进行同样的尝试；如果尝试到只剩下一个，那么就不用尝试了。这个算法需要的次数最坏达到\\(\\dbinom{n}{2}=\\dfrac{n(n-1)}{2}=\\Theta(n^2)\\)次。\r\nb\r\n将红色水壶先随机摆放成一个排列\\(r\\)，那么此时的问题就变成了确定一个排列\\(b\\)，使得\\(\\forall 1\\le i\\le\r\nn,r_i=b_i\\)都成立。潜在的序列\\(b\\)的输入一共有\\(n!\\)个。而每一次比较，都会产生小于、等于和大于三种结果。因此假设这棵决策树是一个三叉树，其叶节点表示原始输入，内部节点表示比较的决策过程，那么其高度\\(h\\)满足\\(3^h\\ge\r\nl\\ge n!\\)，因此\\(h\\ge n \\log_3\r\nn\\)。因此对于原始输入中的叶节点而言，比较次数的期望至少为\\(n\\log_3 n\\)，即\\(\\Omega(n\\lg n)\\)。\r\nc\r\n这个匹配算法如下进行：在\\(n\\)个蓝色水壶中随机选择一个出来，假设为\\(b_i\\)，然后将每个红色水壶逐个和\\(b_i\\)比较，并且按照比较结果分别归类到小于，等于，大于三部分。其中等于的那一部分恰好仅有一个，与\\(b_i\\)匹配，假设其为\\(r_i\\)。那么此时划分出了小于部分\\(r_{1:i-1}\\)，大于部分\\(r_{i+1:n}\\)。那么接下来使用\\(r_i\\)同样对剩下的\\(n-1\\)个蓝色水壶进行比较和划分，假设小于部分为\\(b_{1:i-1}\\)，大于部分为\\(b_{i+1:n}\\)。那么当前步骤总共花费了\\(2n-1=\\Theta(n)\\)次比较。接下来分别对\\((r_{1:i-1},b_{1:i-1}),(r_{i+1:n},b_{i+1:n})\\)进行递归操作即可。\r\n由于这个比较过程的行为和算法RANDOMIZED-QUICKSORT完全一致，因此期望比较次数为\\(O(n\\lg n)\\)。\r\n当每次选到的蓝色水壶都是当前堆中最大或者是最小的一个，那么比较次数将达到最大，为\\(\\displaystyle{\\sum_{i=1}^n\r\n(2i-1)=n^2=\\Theta(n^2)}\\)次。\r\n8-5\r\na\r\n此时式子可以转化为\\(A[i]\\le\r\nA[i+1]\\)，即有序。\r\nb\r\n其中一个为\\(\\langle6, 1, 7, 2, 8, 3, 9, 4,\r\n10, 5\\rangle\\)。\r\nc\r\n整个不等式两边同乘\\(k\\)，得到\\(\\displaystyle{\\sum_{j=i}^{i+k-1} A[j]\\le\r\n\\sum_{j=i+1}^{i+k} A[j]}\\)。消去中间项\\(A[i+1],A[i+2],\\dots,A[i+k-1]\\)，最终得到\\(A[i]\\le A[i+k]\\)。\r\nd\r\n这个算法将使用改进的快速排序算法QUICKSORT作为子程序进行排序，其平均、最坏时间复杂度为\\(O(n\\lg n)\\)。\r\nK-SORTED(A, n, k)  for i = 1 to k    let B be new array    for j = i to n by k      INSERT(B, A[j])    QUICKSORT(B, B.size)    p = 0    for j = i to n by k      p = p + 1      A[j] = B[p]\r\n算法K-SORTED将数组\\(A\\)均匀地划分了\\(k\\)块，每块的长度为\\(\\Theta(n/k)\\)。那么对每一段数组使用算法QUICKSORT进行排序，其时间复杂度为\\(O(n/k\\lg (n/k))\\)。将这\\(k\\)段进行综合，那么最终时间复杂度为\\(k\\cdot O(n/k\\lg (n/k))=O(n\\lg\r\n(n/k))\\)。\r\ne\r\n我们可以将数组\\(A\\)均匀地拆分成\\(k\\)个有序的，其中第\\(j\\)个数组为\\(\\langle\r\nA[j],A[j+k],A[j+2k],\\dots\\rangle\\)，这些数组的长度总和为\\(n\\)。接下来，使用题目6.5-11对\\(k\\)个有序数组进行\\(k\\)路归并的算法（基于堆排序实现），即可以以\\(O(n\\lg k)\\)的时间复杂度对\\(k-\\)排序算法进行排序。\r\nf\r\n算法K-SORTED将数组\\(A\\)均匀地划分了\\(k\\)块，每块的长度为\\(\\Theta(n/k)\\)。那么对每一段数组使用算法QUICKSORT进行排序，其时间复杂度同样有下界\\(\\Omega(n/k\\lg (n/k))\\)。将这\\(k\\)段进行综合，那么最终整个算法K-SORTED有下界\\(k\\cdot \\Omega(n/k\\lg (n/k))=\\Omega(n\\lg\r\n(n/k))\\)。舍弃常数\\(k\\)后，即为\\(\\Omega(n\\lg n)\\)。\r\n8-6\r\na\r\n如果两个数组长度为\\(n\\)的数组是有序的（即对于数组\\(\\langle1,2\\rangle\\)，划分\\(\\langle[1],[2]\\rangle\\)和\\(\\langle[2],[1]\\rangle\\)视为不同的划分），那么一共有\\(\\dbinom{2n}{n}\\)种划分方式。\r\nb\r\n至少\\(\\dbinom{2n}{n}\\)个叶节点的树的高度\\(h\\)满足\\(2^h\\ge\r\nl\\ge \\dbinom{2n}{n}\\)，可以得到\\(h\\ge\r\n\\lg \\dbinom{2n}{n}\\)。根据斯特林公式，可以将值\\(\\dbinom{2n}{n}\\)如下进行近似：\r\n\\(\\begin{aligned}\r\n\\dbinom{2n}{n}&amp;=\\dfrac{\\sqrt{4\\pi\r\nn}\\cdot\\left(\\dfrac{2n}{e}\\right)^{2n}\\cdot\\left(1+\\Theta\\left(\\dfrac{1}{n}\\right)\\right)}{\\left(\\sqrt{2\\pi\r\nn}\\cdot\\left(\\dfrac{n}{e}\\right)^{n}\\cdot\\left(1+\\Theta\\left(\\dfrac{1}{n}\\right)\\right)\\right)^2}\\\\\r\n&amp;=\\dfrac{2\\sqrt{\\pi\r\nn}\\cdot\\left(2n\\right)^{2n}\\cdot\\dfrac{1}{e^{2n}}}{2\\pi n\\cdot\r\nn^{2n}\\cdot \\dfrac{1}{e^{2n}}}\r\n\\cdot\\left(1+\\Theta\\left(\\dfrac{1}{n}\\right)\\right)\\\\\r\n&amp;=\\dfrac{2^{2n}}{\\sqrt{\\pi n}}\\cdot\r\n\\left(1+\\Theta\\left(\\dfrac{1}{n}\\right)\\right)\\\\\r\n&amp;=\\dfrac{2^{2n}}{\\sqrt{\\pi n}}\\cdot\r\n\\left(1+O\\left(\\dfrac{1}{n}\\right)\\right) \\end{aligned}\\)\r\n那么可以得到\\(h\\ge 2n -\r\n\\Theta(\\sqrt{n})\\)，即\\(h\\ge\r\n2n-o(n)\\)。由于这个决策树的高度至少为\\(2n-o(n)\\)，因此比较次数至少为\\(2n-o(n)\\)。\r\nc\r\n不失一般性，假设\\(A[i],B[j]\\)是原本在序列\\(A,B\\)中的两个元素，并且合并后，\\(B[j]\\)紧接在\\(A[i]\\)的后面。那么在合并过程中，如果不对\\(A[i]\\)和\\(B[j]\\)进行比较，那么将无法确定\\(A[i]\\)和\\(B[j]\\)在合并的序列后哪一个数在前面，哪一个数在后面，那么忽略掉这两个数，哪怕是之后的所有数\\(A[i+1:],B[j+1:]\\)相互都进行比较了，仍然无法确定出一个有序的序列。因此\\(A[i]\\)和\\(B[j]\\)必须相互进行比较。\r\nd\r\n每一次迭代，两个序列中的其中一个数将会被安排位置。由于一共有\\(2n\\)个数，因此至少需要进行\\(2n-1\\)次比较，才能够确定出整个有序序列。当\\(A=\\langle1,3,\\dots,2n-3,2n-1\\rangle,B=\\langle2,4,\\dots,2n-2,2n\\rangle\\)时，按照题目8-6-c的结论，比较次数将会达到\\(2n-1\\)的最大值。\r\n8-7\r\na\r\n由于\\(A[p]\\)是最小的无法排序到正确的位置的元素，那么说明小于\\(A[p]\\)的所有元素都已经排序到了正确的位置。而\\(A[q]\\)却占据了\\(A[p]\\)原有的位置，此时\\(A[q]\\)放置的位置也是不正确的，那么说明\\(A[q]\\ge A[p]\\)。如果\\(A[q]=A[p]\\)，那么序列的有序性不会受到影响，这个位置也是\\(A[q]\\)的正确位置。因此仅存在\\(A[q]&gt;A[p]\\)的可能性。\r\n根据数组\\(B\\)的定义，\\(A[p]\\le A[p]\\)必定成立，所以\\(B[p]=0\\)；由于\\(A[q]&gt;A[p]\\)，所以\\(B[q]=1\\)。\r\nb\r\n运行算法\\(X\\)后，如果\\(A[p]\\)排序后没有到达正确的位置，那么说明\\(A[p]\\)排序后的位置\\(p&#39;\\)位于比真正位置的\\(q&#39;\\)靠后，即\\(p&#39;&gt;q&#39;\\)。\r\n更进一步的说明：算法\\(X\\)是不经意比较-交换排序算法，算法\\(X\\)内部是将子程序COMPARE-EXCHANGE作为一系列指令，直接对数组进行操作。也就是说，算法\\(X\\)没有分支判断结构，循环结构也可以转化为顺序结构。舍去循环结构后，算法\\(X\\)的伪代码将会是如下的样子：\r\nX(A, n)  COMPARE-EXCHANGE(A, ?, ?)  COMPARE-EXCHANGE(A, ?, ?)  COMPARE-EXCHANGE(A, ?, ?)  COMPARE-EXCHANGE(A, ?, ?)  ...\r\n因此，本题的证明思路是，比较数组\\(A\\)和由\\(A\\)构造出来的数组\\(B\\)在运行这个算法\\(X\\)上的行为是一致的。\r\n以下讨论三种情况：\r\n\r\n\\(A[i],A[j]\\le\r\nA[p]\\)，那么有\\(B[i]=B[i]=0\\)。如果\\(A[i]&gt;A[j]\\)，那么调用COMPARE-EXCHANGE(A, i, j)时，\\(A[i]\\)和\\(A[j]\\)将会被交换，此时\\(B[i]=B[j]=0\\)；虽然调用COMPARE-EXCHANGE(B, i, j)不会真正交换，但是并不影响调用完成后保持\\(B[i]\\le B[j]=0\\)的性质，我们可以视为\\(B[i]\\)与\\(B[j]\\)发生了交换。如果\\(A[i]\\le\r\nA[j]\\)，那么无论调用COMPARE-EXCHANGE(A, i, j)还是COMPARE-EXCHANGE(B, i, j)，\\(A[i]\\)与\\(A[j]\\)以及\\(B[i]\\)与\\(B[j]\\)都不会发生交换。因此，当\\(A[i],A[j]\\le A[p]\\)时，算法\\(X\\)中针对这一类满足\\(A[i],A[j]\\le\r\nA[p]\\)的指令COMPARE-EXCHANGE(A, i, j)和COMPARE-EXCHANGE(B, i, j)的行为是一致的。\r\n同样的，当\\(A[i],A[j]&gt;\r\nA[p]\\)，那么有\\(B[i]=B[i]=1\\)。对这类满足\\(A[i],A[j]&gt;A[p]\\)的指令的分析和第1种情况完全相同，只是\\(B[i]=B[j]=1\\)。故有结论：当\\(A[i],A[j]&gt; A[p]\\)时，算法\\(X\\)中针对这一类满足\\(A[i],A[j]&gt;A[p]\\)的指令COMPARE-EXCHANGE(A, i, j)和COMPARE-EXCHANGE(B, i, j)的行为是一致的。\r\n当\\(A[i]\\le\r\nA[p],A[j]&gt;A[p]\\)时，\\(B[i]=0,B[j]=1\\)，此时调用COMPARE-EXCHANGE(A, i, j)和COMPARE-EXCHANGE(B, i, j)时，都不会发生交换；当\\(A[i] &gt; A[p],A[j]\\le A[p]\\)时，\\(B[i]=1,B[j]=0\\)，此时调用COMPARE-EXCHANGE(A, i, j)和COMPARE-EXCHANGE(B, i, j)时，都会发生交换。\r\n\r\n因此，对于数组\\(A\\)和数组\\(B\\)，对于任意一条COMPARE-EXCHANGE指令，可以看作要么\\(A[i]\\)和\\(A[j]\\)与\\(B[i]\\)和\\(B[j]\\)都发生交换，要么\\(A[i]\\)和\\(A[j]\\)与\\(B[i]\\)和\\(B[j]\\)都不发生交换，行为是一致的。最终，由于\\(A[p]\\)不在原来的位置\\(q&#39;\\)上，在\\(p&#39;\\)上，那么类似的，对\\(B\\)运行算法\\(X\\)后，有\\(B[p&#39;]=0,B[q&#39;]=1\\)；由于\\(p&#39;&gt;q&#39;\\)，因此算法\\(X\\)未能对数组\\(B\\)完成排序。\r\nc\r\n因为奇数步骤才对数组\\(A\\)的元素进行排序，此时使用的排序算法中将会对数组\\(A\\)中的元素进行访问，并且进行交换。而偶数步骤中，仅仅是涉及了对数组\\(A\\)本身形状的变换，并没有对数组元素进行操作。事实上，偶数步的操作仅仅是对数组元素的位置进行重新排列，因此在每个步骤，我们可以列出一个映射\\(f\\)，表示每个旧位置到新位置的变换，然后在下一步奇数步骤上执行排序时，使用的排序指令是经过映射变换后的数组的下标。\r\n例如，一开始输入的数据的下标如下：\r\n1  2  34  5  67  8  910 11 1213 14 1516 17 18\r\n那么在第3步中，执行的每行排序算法中将会包含指令：COMPARE-EXCHANGE(A, 1, 2), COMPARE-EXCHANGE(A, 1, 3), COMPARE-EXCHANGE(A, 2, 3)。\r\n经过第2个步骤的变换后，对应数的下标位置如下：\r\n1  7  132  8  143  9  154  10 165  11 176  12 18\r\n那么在第3步中，执行的每行排序算法中将会包含指令：COMPARE-EXCHANGE(A, 1, 7), COMPARE-EXCHANGE(A, 1, 13), COMPARE-EXCHANGE(A, 7, 13)。\r\n因此本质上这个列排序算法\\(X&#39;\\)仍然可以视为是一系列COMPARE-EXCHANGE指令的集合，因此它可以视为一个不经意比较-交换排序算法。\r\nd\r\n在第一个步骤完成后，第\\(j\\)列从上到下都是由一些\\(0\\)紧跟着一些\\(1\\)。如果第\\(j\\)列上面有\\(c_j\\)个\\(0\\)，那么第\\(j\\)列下面有\\(r-c_j\\)个\\(1\\)。由于每一列排完序后，\\(0\\)和\\(1\\)相邻的坐标个数最多只有\\(1\\)个，因此将每一列的\\(r\\)个元素均匀划分成\\(s\\)个区间后，前\\(\\left\\lfloor\\dfrac{c_j}{s}\\right\\rfloor\\)个区间全部为\\(0\\)，后\\(\\dfrac{r}{s}-\\left\\lfloor\\dfrac{c_j}{s}\\right\\rfloor-1\\)个区间全部区间全部为\\(1\\)。那么第2个步骤完成后，整个矩阵至少有\\(\\displaystyle{\\sum_{j=1}^s\\left\\lfloor\\dfrac{c_j}{s}\\right\\rfloor}\\)个全\\(0\\)行，至少\\(\\displaystyle{\\sum_{j=1}^s\\left\\lfloor\\dfrac{r}{s}-\\left\\lfloor\\dfrac{c_j}{s}\\right\\rfloor-1\\right\\rfloor}=r-\\sum_{j=1}^s\\left\\lfloor\\dfrac{c_j}{s}\\right\\rfloor-s\\)个全\\(1\\)行。\r\n那么接下来每一列的排序可以进行如下变换：将\\(\\displaystyle{\\sum_{j=1}^s\\left\\lfloor\\dfrac{c_j}{s}\\right\\rfloor}\\)个全\\(0\\)行向顶部转移并合并，形成\\(\\displaystyle{\\sum_{j=1}^s\\left\\lfloor\\dfrac{c_j}{s}\\right\\rfloor}\\)个全\\(0\\)干净行；将\\(\\displaystyle{r-\\sum_{j=1}^s\\left\\lfloor\\dfrac{c_j}{s}\\right\\rfloor\r\n-s}\\)个全\\(1\\)行。向底部转移并合并，形成\\(\\displaystyle{r-\\sum_{j=1}^s\\left\\lfloor\\dfrac{c_j}{s}\\right\\rfloor\r\n-s}\\)个全\\(1\\)干净行。剩下的至多\\(s\\)行都是脏行，直接对这个\\(s\\times\r\ns\\)的区域每一列进行列排序即可。可以发现这种操作和对整个列的\\(r\\)个元素进行排序是相同的（因为之前对全\\(0\\)行和全\\(1\\)行的操作保证了顶部已经都是\\(0\\)，底部都是\\(1\\)。）\r\n因此，最终结论是至少\\(\\displaystyle{\\sum_{j=1}^s\\left\\lfloor\\dfrac{c_j}{s}\\right\\rfloor}\\)行的全\\(0\\)干净行，至多\\(s\\)行的脏行，以及至少\\(\\displaystyle{r-\\sum_{j=1}^s\\left\\lfloor\\dfrac{c_j}{s}\\right\\rfloor\r\n-s}\\)行的全\\(1\\)干净行。\r\ne\r\n按列优先的方式读取步骤4后得到的矩阵，相当于是按行优先读取步骤3后得到的矩阵。正如题目8-7-d的结论，中间有一个\\(s\\times\r\ns\\)的脏区域，因此按行优先的顺序读取步骤3得到的矩阵后，将会有一个长度至多为\\(s^2\\)的脏区域序列，前面的是全\\(0\\)干净区域，后面的是全\\(1\\)干净区域的序列。\r\nf\r\n由于\\(r\\ge\r\n2s^2\\)成立。因此，题目8-7-e中间的\\(s^2\\)个脏区域序列最多处在\\(2\\)个不同的列中。接下来分别考虑两种情况。\r\n\r\n如果这个\\(s^2\\)的脏区域序列横跨在两个不同的列中，那么其起点必定在前一列的下半部分，其终点必定在后一列的上半部分；步骤5对这两个列排完序后，前一列的起点会有所继续下降，后一列的终点会有所上升，但是起点在前一列的下半部分，其终点在后一列的上半部分这个事实仍然不变。第6行的操作则是将前一列的下半行接在后一列的上半行前面，形成一个新列，此时整个脏区域必定在同一列。步骤7则继续对每一列进行排序，这对其它干净列没有影响；对含有脏区域的一列，将会重新排序。步骤7完成后，只有这一列会产生一个\\(0,1\\)相邻的坐标。步骤8将整个序列还原，按列优先读取并不会改变所有数的位置，此时将产生一个全排序的0-1输出。\r\n如果这个\\(s^2\\)的脏区域序列仅在同一列中，那么步骤5的排序完成后就可以停止了，只有这一列会产生一个\\(0,1\\)相邻的坐标。步骤6和7的变换和排序不会产生任何改变，因为步骤6的操作完成了，每一列就已经是单调有序的，步骤7的列排序操作是无用的。步骤8则是将数组还原。最终产生一个全排序的0-1输出。\r\n\r\n因此，这个不经意比较-交换排序算法可以对任何一个只含0和1的序列正确排序，那么根据0-1排序引理，这个算法可以对任意输入值的序列进行排序。\r\ng\r\n如果\\(s\\nmid\r\nr\\)，那么按照步骤2的变换，前一列的最后一个数（如果不是全\\(0\\)，那么最后一个数必定是\\(1\\)）将会和后一列的第一个数（如果不是全\\(0\\)，那么第一个数必定是\\(0\\)）有可能在某一行中是相邻的，这种接触最多有\\(s-1\\)个（第\\(1\\)列和第\\(2\\)列的首尾相接，第\\(2\\)列和第\\(3\\)列的首尾相接……第\\(s-1\\)列和第\\(s\\)列首位相接）。再加上题目8-7-d的分析结果（每一列中，\\(0\\)和\\(1\\)相邻的坐标个数最多只有\\(1\\)个），故至多有\\(2s-1\\)个行组成的脏区域。\r\n因此步骤4完成后，中间会有一个最多\\((2s-1)s\\)个元素组成的脏区域。为了保证这些元素最多只占半列的位置，使得步骤5-8正确进行，\\(r\\)需要满足\\(r\\ge\r\n2\\cdot(2s-1)s\\)，即\\(r\\ge\r\n4s^2-2s\\)。\r\nh\r\n将\\(r\\)行的序列填充到\\(r&#39;\\)行，使得\\(s\\mid r&#39;\\)即可。填充的内容是\\((r&#39;-r)\\times s\\)的\\(+\\infty\\)。填充后的矩阵是\\(r&#39;\\times s\\)的大小，并且满足\\(r&#39;\\ge r\\ge\r\n2s^2\\)。因此将上面的算法作为子程序进行排序。步骤8完成后，将最后的\\((r&#39;-r)s\\)个\\(+\\infty\\)舍弃。\r\n证明：基于原排序算法的正确性，最后\\((r&#39;-r)s\\)个元素必为\\(+\\infty\\)，舍去这些\\(+\\infty\\)后将得到原本正确的排序结果。因此这个新算法是正确的。\r\n","categories":["算法导论"]},{"title":"算法导论8.4 Exercises 答案","url":"/introduction-to-algorithms/chapter-8/exercises-4/","content":"\r\n8.4-1\r\n放入每个桶后，得到如下结果：\r\n\\(\\begin{aligned}\r\n&amp;0 &amp;&amp; \\langle\\rangle\\\\\r\n&amp;1 &amp;&amp; \\langle.13,.16\\rangle\\\\\r\n&amp;2 &amp;&amp; \\langle.20\\rangle\\\\\r\n&amp;3 &amp;&amp; \\langle.39\\rangle\\\\\r\n&amp;4 &amp;&amp; \\langle.42\\rangle\\\\\r\n&amp;5 &amp;&amp; \\langle.53\\rangle\\\\\r\n&amp;6 &amp;&amp; \\langle.64\\rangle\\\\\r\n&amp;7 &amp;&amp; \\langle.71,.79\\rangle\\\\\r\n&amp;8 &amp;&amp; \\langle.89\\rangle\\\\\r\n&amp;9 &amp;&amp; \\langle\\rangle\\\\\r\n\\end{aligned}\\)\r\n按顺序合并全部序列后，得到\\(\\langle.13,.16,.20,.39,.42,.53,.64,.71,.79,.89\\rangle\\)。\r\n8.4-2\r\n当每个元素都恰好分配到同一个桶中时，桶排序将会达到最坏的时间复杂度\\(\\Theta(n^2)\\)，因为每个桶中内部的元素的排序方式是插入排序。\r\n为了避免这种情况，可以考虑对桶内部的所有元素改用快速排序，堆排序等时间复杂度的上限为\\(O(n\\lg n)\\)的算法。\r\n8.4-3\r\n\\(X\\)服从的是参数为\\(n=2,p=\\dfrac{1}{2}\\)的二项分布，因此有\\(E[X]=np=1,\\text{Var}[X]=np(1-p)=0.5\\)。\r\n那么有\\(E^2[X]=1^2=1,E[X^2]=E^2[X]+\\text{Var}[X]=1+0.5=1.5\\)。\r\n8.4-4\r\n假设针对这个序列使用的排序算法为BUCKET-SORT'，那么整个算法的过程如下：\r\nBUCKET-SORT`(A, n)  let B[0 : 9] be a new array  for i = 0 to 9    make B[i] an empty list  for i = 1 to n    k = ⌊A[i] * 10⌋    // 此时每个桶B[k]中的元素都是[0, 1)均匀分布的。    insert (A[i] - 0.1 * k) * n into list B[k]  for i = 0 to 9    BUCKET-SORT(B[i], B[i].size)    for j = 1 to B[i].size      B[i, j] = 0.1 * i + B[i, j] / n  concatenate the lists B[0], B[1], ... , B[9] together in order  return the concatenated lists\r\n由于每个小桶\\(B[i]\\)的数都是来自\\([0,1)\\)均匀分布的，按照BUCKET-SORT算法的分析，这时每个小桶中运行BUCKET-SORT的期望时间复杂度为\\(O(|B[i]|)\\)。最终整个算法的时间复杂度为\\(O(n)\\)。\r\n\\(\\star\\)\r\n8.4-5\r\n在单位圆内随机选择一个点，令随机变量\\(R\\)表示这个点和原点的距离，那么有：\\(\\Pr\\{R\\le r\\}=\\dfrac{\\pi r^2}{\\pi \\cdot\r\n1^2}=r^2\\)。\r\n为了使划分的区域更加均匀，那么考虑所有\\(n\\)分为点，其中第\\(i\\)个分为点\\(r_i\\)的位置满足\\(r_i^2=\\dfrac{i}{n}\\)，即\\(r_i=\\sqrt{\\dfrac{i}{n}}\\)。\r\n那么，如果一个点\\(A_j(x_j,y_j)\\)满足\\(r_{i-1}\\le\\sqrt{x_j^2+y_j^2}&lt;r_i\\)，那么\\(A_j\\)将会放进桶\\(B[i]\\)。接下来再将桶中的所有点进行插入排序即可。\r\n由于每个点被分配进的桶的概率都是一样的，因此按照之前对桶排序的分析，这个算法仍然有\\(\\Theta(n)\\)的平均时间复杂度。\r\n\\(\\star\\)\r\n8.4-6\r\n可以知道，\\(n\\)分位点的第\\(i\\)个分位点\\(a_i\\)满足\\(P(a_i)=\\dfrac{i}{n}\\)。按照题目中的条件，\\(a_i\\)可以以\\(O(1)\\)的时间复杂度计算出来。第\\(i\\)个桶装的元素在区间\\([a_{i-1},a_i)\\)中。\r\n那么对于每个具体的值\\(X_i=x_i\\)，它应该放在桶\\(B[\\lfloor n\\cdot\r\nP(x_i)\\rfloor]\\)。由此，对于每个元素\\(x_i\\)，它被分配进每个桶的概率都是一样的。因此按照之前对桶排序的分析，这个算法仍然有\\(\\Theta(n)\\)的平均时间复杂度。\r\n","categories":["算法导论"]},{"title":"算法导论7.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-7/exercises-3/","content":"\r\n7.3-1\r\n正如平均时间复杂度的意义所在，随机算法的平均时间复杂度更能反映出其期望的运行时间。分析随机算法的时间复杂度过程中，我们预测了各种可能的随机行为，并最终通过这些所有的随机行为计算出一个总的期望值。不过，由于上述过程是随机进行的，我们不能直接以恶意地干扰这些随机行为。相反，分析最坏时间复杂度时，没有任何的随机行为，我们可以根据算法本身构造出一个恶意的输入使其时间复杂度最大化。\r\n7.3-2\r\n当达到最差情况时，随机算法恰好将区间划分成一空一满的状态，此时算法RANDOM调用次数满足\\(C(n)=C(n-1)+1\\)，即\\(C(n)=\\Theta(n)\\)。\r\n当达到最好情况时，随机算法恰好将区间划分成两半的状态，此时算法RANDOM调用次数满足\\(C(n)=2C(n/2)+1\\)，即\\(C(n)=\\Theta(n)\\)。\r\n也就是说，无论什么情况，算法RANDOM将会被调用\\(\\Theta(n)\\)次。\r\n","categories":["算法导论"]},{"title":"算法导论7.4 Exercises 答案","url":"/introduction-to-algorithms/chapter-7/exercises-4/","content":"\r\n7.4-1\r\n假设\\(T(n)\\ge cn^2\\)。那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=\\max_{q=0}^{n-1} \\{T(q)+T(n-q-1)\\}+\\Theta(n)\\\\\r\n&amp;\\ge\\max_{q=0}^{n-1} \\{c(q^2+(n-q-1)^2)\\}+\\Theta(n)\\\\\r\n&amp;=c\\max_{q=0}^{n-1} \\{q^2+(n-q-1)^2\\}+\\Theta(n)\\\\\r\n\\end{aligned}\\)\r\n可以发现，当\\(q=0\\)或\\(q=n-1\\)时，\\(\\max\\)中包含的内容将达到最大，因此有\r\n\\(\\begin{aligned}\r\nT(n)&amp;\\ge c\\max_{q=0}^{n-1} \\{q^2+(n-q-1)^2\\}+\\Theta(n)\\\\\r\n&amp;=c(n-1)^2+\\Theta(n)\\\\\r\n&amp;= cn^2-2cn+c+\\Theta(n)\\\\\r\n&amp;\\ge cn^2-2cn+\\Theta(n)\\\\\r\n&amp;= cn^2-(2cn-\\Theta(n))\\\\\r\n&amp;\\ge cn^2&amp;\\qquad(A)\r\n\\end{aligned}\\)\r\n其中步骤\\((A)\\)假设了\\(2cn\\)渐进上界比\\(\\Theta(n)\\)大。\r\n令\\(c=\\min(1,T(1)),n_0=1\\)。由于\\(T(1)\\ge c\\ge\r\ncn^2\\)，那么由数学归纳法，结论\\(T(n)=\\Omega(n^2)\\)成立。\r\n7.4-2\r\n可以知道，最好运行时间\\(T&#39;(n)\\)的递推式满足\\(\\displaystyle{T&#39;(n)=\\min_{q=0}^{n-1}\r\n\\{T(q)+T(n-q-1)\\}+\\Theta(n)}\\)。假设\\(T&#39;(n)\\ge cn\\lg n\\)，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;=\\min_{q=0}^{n-1} \\{T(q)+T(n-q-1)\\}+\\Theta(n)\\\\\r\n&amp;\\ge\\min_{q=0}^{n-1} \\{cq\\lg q+c(n-q-1)\\lg(n-q-1)\\}+\\Theta(n)\\\\\r\n&amp;=c\\min_{q=0}^{n-1} \\{q\\lg q+(n-q-1)\\lg(n-q-1)\\}+\\Theta(n)\\\\\r\n\\end{aligned}\\)\r\n将最后一行\\(\\max\\)中的内容对\\(2\\)取指数，得到\\(2^{q\\lg q+(n-q-1)\\lg(n-q-1)}=q(n-q-1)\\cdot\r\n2^{n-1}\\)。可以发现，当\\(q=\\dfrac{n-1}{2}\\)时，这个式子才能取到最小值。不过为了方便证明，如果\\(T(n)\\)大于等于其中的非最小值，那么\\(T(n)\\)一定大于等于其中的最小值，因此令\\(q=\\dfrac{n}{2}\\)，有：\r\n\\(\\begin{aligned}\r\nT(n)&amp;\\ge c\\min_{q=0}^{n-1} \\{q\\lg q+(n-q-1)\\lg(n-q-1)\\}+\\Theta(n)\\\\\r\n&amp;\\ge c(n/2\\cdot \\lg(n/2)+(n/2-1)\\lg(n/2-1))+\\Theta(n)\\\\\r\n&amp;\\ge c(n/2\\cdot \\lg(n/2)+(n/2-1)(\\lg(n/2)-1))+\\Theta(n)\r\n&amp;\\qquad(A)\\\\\r\n&amp;=cn\\lg n-c\\lg n+2c-\\dfrac{3c}{2}n+\\Theta(n)\\\\\r\n&amp;=cn\\lg n-\\left(\\dfrac{3cn}{2}+c\\lg n-2c-\\Theta(n)\\right)\\\\\r\n&amp;\\ge cn\\lg n &amp; \\qquad(B)\r\n\\end{aligned}\\)\r\n其中，步骤\\((A)\\)使用了假设\\(x\\ge 2\\rightarrow \\lg(x-1)\\ge \\lg\r\nx-1\\)，即\\(n\\ge 4\\)，步骤\\((B)\\)假设了\\(\\dfrac{3cn}{2}+c\\lg\r\nn-2c\\)的渐进增长要高于\\(\\Theta(n)\\)（只要\\(c\\)大到恰到好处）。\r\n因此，只需要假设\\(n\\ge\r\n4\\)，并且\\(c\\)取值足够大。那么由数学归纳法，结论\\(T(n)=\\Omega(n\\lg n)\\)成立。\r\n7.4-3\r\n令\\(f(q)=q^2 + (n - q -\r\n1)^2\\)，那么\\(f&#39;(q)=4q-2n+2,f&#39;&#39;(q)=4\\)。当\\(f&#39;(q)=0\\)时，\\(q=\\dfrac{n-1}{2}\\)。因此\\(f(q)\\)在区间\\(\\left[0,\\dfrac{n-1}{2}\\right]\\)上递减，在\\(\\left[\\dfrac{n-1}{2},n-1\\right]\\)上递增。因此\\(f\\)在\\(0\\)或者是\\(n-1\\)上取到最大值。\r\n7.4-4\r\n类似的，假设随机变量\\(X\\)是算法RANDOMIZED-QUICKSORT所进行的比较次数，那么按照书上的结论，有：\r\n\\(\\begin{aligned}\r\nE[X]&amp;= \\sum_{i=1}^{n-1}\\sum_{j=i+1}^n \\dfrac{2}{j-i+1}\\\\\r\n&amp;= \\sum_{i=1}^{n-1}\\sum_{k=1}^{n-i} \\dfrac{2}{k+1}\\\\\r\n&amp;\\ge \\sum_{i=1}^{n-1}\\sum_{k=1}^{n-i} \\dfrac{2}{2k}&amp;\\qquad(A)\\\\\r\n&amp;=\\sum_{i=1}^{n-1} \\Omega(\\lg n)\\\\\r\n&amp;=\\Omega(n\\lg n)\r\n\\end{aligned}\\)\r\n其中，步骤\\((A)\\)是因为当\\(k\\ge 1\\)时，\\(\\dfrac{1}{k+1}\\ge \\dfrac{1}{2k}\\)成立。\r\n因此，整个算法的期望运行时间为\\(\\Omega(n\\lg\r\nn)\\)。\r\n7.4-5\r\n按照递归树的思想，如果数组长度小于等于\\(k\\)时停止递归，那么整个递归树的高度为\\(\\lg\r\n(n/k)\\)，并且每一层所调用的划分算法的运行时间之和为\\(O(n)\\)。因此，快速排序部分的运行时间为\\(\\lg(n/k)\\cdot O(n)=O(n\\lg (n/k))\\)。\r\n当\\(n\\le\r\nk\\)时，算法终止递归，由于子问题不重叠，因此划分出的叶节点大约有\\(\\dfrac{n}{k}\\)个。根据插入排序算法的时间复杂度\\(O(n^2)\\)。因此，插入排序部分的时间为\\(\\dfrac{n}{k}\\cdot O(k^2)=O(nk)\\)。\r\n因此，总共的时间复杂度之和为\\(O(nk+n\\lg(n/k))\\)。\r\n如果不考虑不同算法之间的常数步骤耗费时间，那么令\\(f(k)=nk+n\\lg(n/k)\\)。\r\n那么有\\(f&#39;(k)=n-\\dfrac{n}{k\\ln\r\n2},f&#39;&#39;(k)=\\dfrac{n}{k^2\\ln 2}\\)。当\\(f&#39;(k)=0\\)时，有\\(k=\\dfrac{1}{\\ln 2}\\)。此时\\(f(k)\\)在\\(k=\\dfrac{1}{\\ln 2}\\)处取到最小值。因此\\(k=\\dfrac{1}{\\ln 2}\\)。\r\n如果考虑不同算法之间的常数步骤耗费时间，那么\\(k\\)需要通过实验来分析取得。\r\n\\(\\star\\)\r\n7.4-6\r\n不失一般性，假设\\(\\alpha\\le\\dfrac{1}{2}\\)，因为当\\(\\beta=1-\\alpha\\)时，划分情况一致。\r\n假设这个数组的\\(n\\)个元素都不相同，随机选取\\(3\\)个数，那么有\\(\\dbinom{n}{3}\\)种选法。其中，第\\(i\\)小的数成为最终的支点的支点的选法有\\((i-1)\\cdot (n-i)\\)种，因为比\\(i\\)小的数有\\(i-1\\)种选法，比\\(i\\)大的数有\\(n-i\\)种选法。令\\(p(n,i)=\\dfrac{6(i-1)(n-i)}{n(n-1)(n-2)}\\)表示第\\(i\\)小的元素最终成为支点的概率。\r\n划分的元素是第\\(i\\)小时，只有当\\(j\\)满足\\(i\\le\r\nj\\le n+1-i\\)时，以\\(j\\)划分才不会更坏，这样的\\(j\\)的概率占比之和为：\r\n\\(\\displaystyle{g(n,i)=\\sum_{j=i}^{n+1-i}\r\np(n,j)}=\\dfrac{(2 - 2 i + n) (-2 i^2 + n(n-5) + 2 i (2 +\r\nn))}{n(n-1)(n-2)}\\)\r\n考虑去除\\(g(n,i)\\)分子分母中的所有非三次项（即低阶项），得到\\(h(n,i)\\)，并令\\(\\alpha=\\dfrac{i}{n}\\)回代到\\(h(n,i)\\)中，得到\\(p(\\alpha)=(1-2\\alpha)(1+2\\alpha-2\\alpha^2)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论9.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-9/exercises-2/","content":"\r\n9.2-1\r\n这题的证明思路是，只要调用程序RANDOMIZED-SELECT时，\\(i\\)满足\\(1\\le\r\ni\\le\r\nr-p+1\\)，那么在接下来的递归调用步骤中这个性质恒成立。由于\\(i\\ge\r\n1\\)恒成立，因此在递归调用的过程中，不可能产生\\(p&gt;r\\)的情况。\r\n接下来证明\\(i\\ge\r\n1\\)恒成立。第8行代码的递归调用没有对\\(i\\)进行改变，因此原结论成立；第9行代码的递归调用对应的是情况\\(i&gt;k\\)时的情况，因此\\(i-k&gt;0\\)，此时的递归调用仍然保持性质成立。故原结论成立。\r\n接下来证明\\(i\\le\r\nr-p+1\\)恒成立。第7行代码和第4行的代码混合消去\\(k\\)后，得到\\(i&lt; q-p+1\\)，也就是\\(i\\le q-p\\)，可以写成\\(i\\le\r\n(q-1)-p+1\\)，因此原结论仍然成立。如果\\(i&gt;k\\)，那么由\\(i\\le r-p+1\\)两边同时减去\\(k\\)和\\(q-p+1\\)后，得到\\(i-k\\le r-q\\)，可以写成\\(i-k\\le r-(q+1)+1\\)。故原结论成立。\r\n由于\\(1\\le i\\le\r\nr-p+1\\)恒成立，因此\\(r-p+1\\ge\r\n1\\)，即\\(p\\le\r\nr\\)恒成立，因此不会产生对空数组的调用。\r\n9.2-2\r\nITERATIVE-RANDOMIZED-SELECT(A, p, r, i)  while p &lt; r    q = RANDOMIZED-PARTITION(A, p, r)    k = q – p + 1    if i == k      return A[q]    elseif i &lt; k      r = q - 1    else      p = q + 1      i = i - k\r\n9.2-3\r\n最坏的划分是从大到小选取了\\(9,8,7,6,5,4,3,2,1,0\\)时的划分情况。如下是划分的过程：\r\n\\(\\begin{aligned}\r\n&amp;[2, 3, 0, 5, 7, 9, 1, 8, 6, 4]\\\\\r\n9:&amp;[2, 3, 0, 5, 7, 4, 1, 8, 6, \\underline{9}]\\\\\r\n8:&amp;[2, 3, 0, 5, 7, 4, 1, 6, \\underline{8}, 9]\\\\\r\n7:&amp;[2, 3, 0, 5, 6, 4, 1, \\underline{7}, 8, 9]\\\\\r\n6:&amp;[2, 3, 0, 5, 1, 4, \\underline{6}, 7, 8, 9]\\\\\r\n5:&amp;[2, 3, 0, 4, 1, \\underline{5}, 6, 7, 8, 9]\\\\\r\n4:&amp;[2, 3, 0, 1, \\underline{4}, 5, 6, 7, 8, 9]\\\\\r\n3:&amp;[2, 1, 0, \\underline{3}, 4, 5, 6, 7, 8, 9]\\\\\r\n2:&amp;[0, 1, \\underline{2}, 3, 4, 5, 6, 7, 8, 9]\\\\\r\n1:&amp;[0, \\underline{1}, 2, 3, 4, 5, 6, 7, 8, 9]\\\\\r\n0:&amp;[\\underline{0}, 1, 2, 3, 4, 5, 6, 7, 8, 9]\r\n\\end{aligned}\\)\r\n9.2-4\r\n本题将使用归纳法来证明。令\\(T(n,k)\\)表示输入长度为\\(n\\)的置换并且求解第\\(k\\)小值的运行时间。\r\n当\\(n=1\\)时，可以发现不需要进行比较，直接返回结果即可。\\(1\\)阶置换的个数为\\(1\\)，故期望的运行时间和序列的顺序是独立的，即\\(T(1,1)=\\Theta(1)\\)。\r\n当\\(n&gt;1\\)时，假设对于所有\\(1\\le k&#39;\\le n&#39; &lt;\r\nn\\)，原结论都成立，即输入\\(n&#39;\\)阶上的排列的期望运行时间和排列的顺序无关，其值为\\(E[T(n&#39;,k&#39;)]\\)。\r\n考虑\\(1\\le k\\le\r\nn\\)，那么对于一个特定的\\(n\\)阶置换\\(p\\)，询问第\\(k\\)小的数的运行时间为\\(T_p(k)\\)，那么可以写出\\(T_p(k)\\)的递推式：\r\n\\(\\begin{aligned}\r\nT_p(k)&amp;=\\dfrac{1}{n}\\left(\\sum_{i=1}^{k-1}T_{p[i+1:n]}(k-i)+\\Theta(1)+\\sum_{i=k+1}^{n}T_{p[1:i-1]}(k)\\right)\\\\\r\n&amp;=\\dfrac{1}{n}\\left(\\sum_{i=1}^{k-1}T(n-i,k-i)+\\Theta(1)+\\sum_{i=k+1}^{n}T(i-1,k)\\right)\r\n&amp; \\qquad(A)\r\n\\end{aligned}\\)\r\n这个递推式的三项分别对应了划分的\\(3\\)种情况：划分值过小，划分值相等，划分值过大。\r\n其中，步骤\\((A)\\)应用了上面的假设，因为序列\\(p[i+1:n],p[1,i-1]\\)的长度必定小于\\(n\\)。经过变换后，可以发现\\(T_p(k)\\)的运行时间已经和置换\\(p\\)没有关系，因此可以用\\(T(n,k)=T_p(k)\\)来表示一个任意顺序\\(n\\)阶置换的运行时间。\r\n因此，算法RANDOMIZED-SELECT的期望运行时间和排列的顺序是独立的。\r\n","categories":["算法导论"]},{"title":"算法导论9.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-9/exercises-3/","content":"\r\n9.3-1\r\n前11行代码，无非就是将所有为\\(5\\)的常量转化成\\(7\\)。这一段的代码运行时间仍然为\\(\\Theta(n)\\)。\r\n第12-13行代码对每组\\(7\\)个元素进行原地排序。由于每组内部元素数量相同，一共有\\(\\Theta(n)\\)组，这一段的运行时间仍然为\\(\\Theta(n)\\)。\r\n第16行对中间的一组再进行一次调用，产生了\\(T(n/7)\\)的开销。\r\n第17行对数组进行了一次划分，这一段的运行时间仍然为\\(\\Theta(n)\\)。\r\n总而言之，上面这部分算法内部开销的时间复杂度为\\(\\Theta(n)\\)。\r\n第20-24行递归进入所划分的区间。按照这种划分方法，可以知道，第16行中的\\(x\\)至少有\\(\\dfrac{4\\cdot n}{2\\cdot\r\n7}=\\dfrac{2}{7}n\\)个数比它大，至少有\\(\\dfrac{2}{7}n\\)个数比它小。因此每次进行下一次递归时，至多可以去除\\(\\dfrac{2}{7}n\\)个数。假设\\(T(n)\\)为对\\(n\\)个元素进行选择的运行时间，那么有\r\n\\[T(n)\\le\r\nT(n/7)+T(5n/7)+\\Theta(n)\\]\r\n使用代入法，假设对于足够大的所有\\(n,T(n)\\le\r\ncn\\)都成立。那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;\\le T(n/7)+T(5n/7)+\\Theta(n)\\\\\r\n&amp;\\le cn/7+5cn/7+\\Theta(n)\\\\\r\n&amp;=cn-cn/7+\\Theta(n)\\\\\r\n&amp;\\le cn &amp;\\qquad(A)\r\n\\end{aligned}\\)\r\n其中，步骤\\((A)\\)假设了\\(c\\)足够大，以至于\\(cn/7\\)的增长速度超过\\(\\Theta(n)\\)。\r\n因此有\\(T(n)=O(n)\\)。\r\n由于第17行对数组进行了一次\\(\\Theta(n)\\)的划分，因此说明\\(T(n)=\\Omega(n)\\)。\r\n因此最终有\\(T(n)=\\Theta(n)\\)。\r\n9.3-2\r\n在这个时候，我们考虑不处理最后\\(A[5g+1:n]\\)这一部分元素，留给下一次递归一并进行处理。\r\n第12-13行代码对每组\\(5\\)个元素进行原地排序。由于每组内部元素数量相同，一共有\\(\\Theta(n)\\)组，这一段的运行时间仍然为\\(\\Theta(n)\\)。\r\n第16行对中间的一组再进行一次调用，产生了\\(T(n/5)\\)的开销。\r\n第17行对数组进行了一次划分，这一段的运行时间仍然为\\(\\Theta(n)\\)。\r\n总而言之，上面这部分算法内部开销的时间复杂度为\\(\\Theta(n)\\)。\r\n第20-24行递归进入所划分的区间。按照这种划分方法，可以知道，第16行中的\\(x\\)至少有\\(\\dfrac{3}{10}n\\)个数比它大，至少有\\(\\dfrac{3}{10}n\\)个数比它小。因此每次进行下一次递归时，至多可以去除\\(3n/10\\)个数。假设\\(T(n)\\)为对\\(n\\)个元素进行选择的运行时间，那么考虑将不属于群中的元素交给下一次递归处理，那么有\r\n\\(T(n)\\le T(7n/10+(n\\bmod 5)) + \\Theta(n)\r\n\\le T(7n/10+4)+\\Theta(n)\\)\r\n按照第四章的内容，递推式中的常数并不影响其最终的渐进增长表达。因此假设\\(T&#39;(n) \\le\r\nT&#39;(7n/10)+\\Theta(n)\\)，那么\\(T(n)=\\Theta(T&#39;(n))\\)。\r\n参考题目9.3-1类似的推理，有\\(T&#39;(n)=O(n)\\)，因此\\(T(n)=O(n)\\)。\r\n第17行对数组进行了一次\\(\\Theta(n)\\)的划分，说明\\(T(n)=\\Omega(n)\\)。\r\n因此最终有\\(T(n)=\\Theta(n)\\)。\r\n9.3-3\r\n将快速排序中调用子程序RANDOMIZED-PARTITION的那一行改为使用SELECT查找中位数。\r\n使用算法SELECT找到中位数后，两部分将会被划分尽量均等的两部分。按照上面的结论，假设对\\(n\\)个数进行快速排序的时间复杂度为\\(T(n)\\)，那么有\r\n\\[T(n)=2T(n/2)+O(n)\\]\r\n因此通过主定理不难得知，\\(T(n)=O(n\\lg\r\nn)\\)。\r\n\\(\\star\\)\r\n9.3-4\r\n令图\\(G=(V,E)\\)表示通过这个算法比较产生的一个有向图。其中\\(V\\)是\\(n\\)个顶点，顶点\\(v_i\\in V\\)表示数组\\(A\\)中的第\\(i\\)个元素。\r\n在调用这个基于比较的算法求第\\(i\\)小的数的过程中，额外增加如下过程：如果\\(A[x]\\ge A[y]\\)，那么在\\(E\\)中增加一条边\\((v_x,v_y)\\)。\r\n为了知道第\\(i\\)小的元素是哪一个，它必定和其它所有数有着间接的关系。因此图\\(G\\)的基图是一个连通图。\r\n那么，对于任意一个\\(j\\)，如果从\\(v_j\\)到\\(v_i\\)存在一条路径，那么找到了一个超过\\(A[i]\\)的数\\(A[j]\\)；如果从\\(v_i\\)到\\(v_j\\)存在一条路径，那么找到了一个小于\\(A[i]\\)的数\\(A[j]\\)。\r\n自此，不需要比较就能找到其余\\(i-1\\)个小数和\\(n-i\\)个大数。\r\n9.3-5\r\n由算法GET-MEDIAN详细描述整个过程。\r\nGET-MEDIAN(a1, a2, a3, a4, a5)  // 1  if a1 &gt; a2    exchange a1 with a2  // 2  if a3 &gt; a4    exchange a3 with a4  // 3  if a1 &gt; a3    exchange a1 with a3    exchange a2 with a4  // 此时已经保证a1 &lt;= a3 &lt;= a4, a1 &lt;= a2  // 4  if a2 &lt;= a5    // 此时已经保证a1 &lt;= a3 &lt;= a4, a1 &lt;= a2 &lt;= a5    // 5.1    if a2 &gt; a3      exchange a2 with a3      exchange a4 with a5    // 此时已经保证a1 &lt;= a2 &lt;= a3 &lt;= a4, a2 &lt;= a5    // 6.1    if a3 &lt;= a5      // 此时有a1 &lt;= a2 &lt;= a3 &lt;= a4 &amp; a5，那么a3是中位数。      return a3    else      // 此时有a1 &lt;= a2 &lt;= a5 &lt; a3 &lt;= a4，那么a5是中位数。      return a5  else    // 此时已经保证a1 &lt;= a3 &lt;= a4, a1 &lt;= a2, a5 &lt; a2    // 5.2    if a3 &lt;= a5      // 此时已经保证a1 &lt;= a3 &lt;= a5 &lt; a2, a3 &lt;= a4      // 6.2      if a4 &lt;= a5        // 此时有a1 &lt;= a3 &lt;= a4 &lt;= a5 &lt; a2，那么a4是中位数。        return a4      else        // 此时有a1 &lt;= a3 &lt;= a5 &lt;= a2 &amp; a4，那么a5是中位数。        return a5    else      // 此时已经保证 a1 &lt;= a3 &lt;= a4, a1 &lt;= a2, a5 &lt; a2 &amp; a3      // 6.3      if a2 &lt;= a3        // 此时有a1 &amp; a5 &lt; a2 &lt;= a3 &lt;= a4，那么a2是中位数。        return a2      else        // 此时有a1 &amp; a5 &lt;= a3 &lt;= a2 &amp; a4，那么a3是中位数。        return a3        \r\n9.3-6\r\n由算法SELECT2给出整个过程，基本思想是分治。如果查找的\\(i\\)比中位数的排名小，那么就在左边部分继续查找；如果查找的\\(i\\)恰好和中位数排名相等，那么返回这个中位数；如果查找的\\(i\\)比中位数的排名大，那么就在右边部分继续查找。\r\n// 子程序MEDIAN(A, p, r)表示返回序列A[p : r]的中位数下标q，并且已经将整个数组划分得A[p : q - 1]都比A[q]小，A[q + 1 : r]都比A[q]大。SELECT2(A, p, r, i)  q = MEDIAN(A, p, r)  k = q - p + 1  if i == k    return A[q]  else if i &lt; k    return SELECT2(A, p, q - 1, i)  else    return SELECT2(A, q + 1, r, i - k)\r\n按照题目要求，算法MEDIAN的运行时间为\\(\\Theta(n)\\)，那么程序SELECT2的运行时间\\(T(n)\\)满足\\(T(n)=T(n/2)+\\Theta(n)\\)。根据主定理，\\(T(n)=\\Theta(n)\\)，因此这个算法符合题意。\r\n9.3-7\r\n这个管道的铺设纵坐标是所有油田纵坐标的中位数，直接调用SELECT(Y, 1, n, ⌈n/2⌉)即可在\\(O(n)\\)的时间下求解。\r\n证明：假设目前的某个候选解为\\(y\\)，在它上面的油田有\\(a\\)个，在它下面的油田有\\(b\\)个。如果\\(a&gt;b\\)，那么将候选解\\(y\\)增加\\(1\\)，那么管道总长度将会减少\\(a-b\\)；类似的，如果\\(a&lt; b\\)，那么将\\(y\\)减少\\(1\\)，那么管道总长度减少\\(b-a\\)。\r\n因此为了保证管道总长度最小，\\(a\\)和\\(b\\)的值应该尽量接近，此时取得的解恰好为油田纵坐标的中位数。\r\n9.3-8\r\n由算法GET-QUANTILES给出整个过程，基本思想仍然是分治。可以发现，这个递归至多只会进行\\(\\Theta(\\lg k)\\)层。\r\n并且在同一层中，划分的区间总是不相交的。因此在每一层中，第6行代码调用程序SELECT的总时间为\\(O(n)\\)。因此整个程序的时间复杂度为\\(O(n\\lg k)\\)。\r\n// 第kl~kr个分位数在数组A[al : ar]中，并且将求出来的分位数存放在B中。GET-QUANTILES(A, al, ar, kl, kr, B, k)  if al &gt; ar or kl &gt; kr    return  n = ar - al + 1  kp = ⌊(kl + kr) / 2⌋  ap = ⌊kp * n / k⌋  x = SELECT(A, al, ar, ap)  B[kp] = x  GET-QUANTILES(A, al, ap - 1, kl, kp - 1, B, k)  GET-QUANTILES(A, ap + 1, ar, kp + 1, kr, B, k)K-QUANTILES(A, n, k)   let B[1 : k - 1] be new array  GET-QUANTILES(A, 1, n, 1, k - 1, B, k)  return B\r\n9.3-9\r\n由算法K-CLOSET-MEDIAN给出整个过程。第一次SELECT的调用是为了找出中位数，后面的两次调用是为了找出这连续的\\(k\\)个数的左右边界。注意当\\(k\\)为偶数时，还需要判断第\\(\\lceil n\\rceil-k/2\\)小的数和第\\(\\lceil\r\nn\\rceil+k/2\\)小的数中，哪个更加接近中位数。\r\n由于整个过程只调用了\\(3\\)次SELECT算法，因此算法K-CLOSET-MEDIAN的时间复杂度为\\(O(n)\\)。\r\nK-CLOSET-MEDIAN(S, n, k)  m = SELECT(Y, 1, n, ⌈n/2⌉)  if k % 2 == 1    x = SELECT(Y, 1, n, ⌈n/2⌉-(k-1)/2)    y = SELECT(Y, 1, n, ⌈n/2⌉+(k-1)/2)    return S[⌈n/2⌉-(k-1)/2 : ⌈n/2⌉+(k-1)/2]  else    x = SELECT(S, 1, n, ⌈n/2⌉-k/2)    y = SELECT(S, 1, n, ⌈n/2⌉+k/2)    if |x - m| &lt;= |y - m|      return S[⌈n/2⌉-k/2 : ⌈n/2⌉+k/2-1]    else      return S[⌈n/2⌉-k/2+1 : ⌈n/2⌉+k/2]\r\n9.3-10\r\n题目本质上是找出这\\(2n\\)个数中第\\(n\\)小的数。整个过程由算法SELECT3给出。\r\n算法SELECT3的每一次调用将会淘汰一个数组中\\(\\lfloor\r\nk/2\\rfloor\\)个较小数，使得所求中位数的排名上升一半。由于一共需要淘汰\\(n\\)个数，因此整个算法的时间复杂度为\\(O(\\lg n)\\)。\r\n// 找出数组A[i : n], B[j : n]中的第k小数。SELECT3(n, A, i, B, j, k)   if i &gt; n    return B[j + k - 1]  else if j &gt; n    return A[j + k - 1]  else if k == 1    return min&#123;A[i], B[j]&#125;  if i + ⌊k/2⌋ - 1 &lt;= n    midl = A[i + ⌊k/2⌋ - 1]  else    midl = +∞  if j + ⌊k/2⌋ - 1 &lt;= n    midr = B[i + ⌊k/2⌋ - 1]  else    midr = +∞  if midl &lt; midr    return SELECT3(n, A, i + ⌊k/2⌋, B, j, k - ⌊k/2⌋)  else    return SELECT3(n, A, i, B, j + ⌊k/2⌋, k - ⌊k/2⌋) MEDIAN3(A, B, n)  return SELECT3(n, A, 1, B, 1, n) \r\n","categories":["算法导论"]},{"title":"算法导论7 Problems 答案","url":"/introduction-to-algorithms/chapter-7/problems/","content":"\r\n7-1\r\na\r\n可以知道，此时支点值\\(x\\)为\\(13\\)。\r\n\\(\\begin{array}{|c|c|c|}\r\n\\hline\r\n&amp;i&amp;j\\\\\r\n\\hline\r\n\\langle 13, 19, 9, 5, 12, 8, 7, 4, 11, 2, 6, 21\\rangle \\\\\r\n\\hline\r\n\\langle \\underline{6}, 19, 9, 5, 12, 8, 7, 4, 11, 2, \\underline{13},\r\n21\\rangle &amp;1&amp;13\\\\\r\n\\hline\r\n\\langle 6, \\underline{2}, 9, 5, 12, 8, 7, 4, 11, \\underline{19}, 13,\r\n21\\rangle &amp; 2 &amp; 10\\\\\r\n\\hline\r\n\\langle 6, 2, 9, 5, 12, 8, 7, 4, \\underline{11}, 19, 13, 21\\rangle\r\n&amp;10&amp;9\\\\\r\n\\hline\r\n\\end{array}\\)\r\nb\r\n当数组中所有元素都相等时，HOARE-PARTITION将会返回\\(\\left\\lfloor\\dfrac{p+r}{2}\\right\\rfloor\\)，也就是中间值。这个算法相比于普通的PARTITION，其将各个元素划分地更加均匀，使得快速排序算法的时间复杂度得以下降至最好。\r\nc\r\n一开始时，\\(i=p-1,j=r+1\\)成立，恰好在数组的左侧和右侧。直到开始访问数组时，数组指针\\(i,j\\)先向中间靠拢。当\\(A[j]&gt;x\\)时，\\(j\\)将一直左移；当\\(A[i]&lt; x\\)时，\\(i\\)将一直右移。由于一个数\\(u\\)不可能同时大于一个数\\(v\\)，并且小于\\(v\\)，因此当\\(i,j\\)相遇时，它们必定停下来。最终，\\(i,j\\)永远不会越界。\r\nd\r\n根据题目7-1-c的结论，\\(j\\)将会一直在区间\\([p,r]\\)内，哪怕是已经达到\\(i&gt;j\\)。由于\\(|A|\\ge 2\\)，那么将会有以下\\(2\\)种情况说明\\(j&lt; r\\)：\r\n\r\n\\(A[p]\\ge\r\nA[r]\\)，此时第一轮while循环中，两个repeat循环各迭代一次后循环立刻停下。交换完成后，由于\\(i&lt;\r\nj\\)仍然成立，因此外循环仍然不会结束。第二轮循环迭代将会使得\\(j\\)再自减\\(1\\)，由此\\(j&lt;r\\)。\r\n\\(A[p]&lt;\r\nA[r]\\)，此时第一轮while循环中，第一个repeat循环将会迭代两次以上，那么就有\\(j&lt; r\\)仍然成立。\r\n\r\n因此，返回的\\(j\\)仍然保证了在区间\\([p,r)\\)中。\r\ne\r\n在每一次迭代前，\\(\\forall k\r\n\\in[j+1,r]\\)，都有\\(A[k]\\ge\r\nx\\)成立，\\(\\forall k\r\n\\in[p,j]\\)，都有\\(A[k]\\le\r\nx\\)成立。当遇到不满足这个情况的数时，两个repeat循环都会停下，交换这两个分别不符合各自性质的数，从而维持着它们原本的性质。因此，最终循环终止后，\\(\\forall k \\in[j+1,r]\\)，都有\\(A[k]\\ge x\\)仍然成立，\\(\\forall k \\in[p,j]\\)，都有\\(A[k]\\le x\\)仍然成立。因此，\\(A[i:j]\\)中的所有数都不超过\\(A[j+1,r]\\)。\r\nf\r\nHOARE-QUICKSORT(A, p, r)  if p &lt; r    q = HOARE-PARTITION(A, p, r)    HOARE-QUICKSORT(A, p, q)    HOARE-QUICKSORT(A, q + 1, r)\r\n7-2\r\na\r\n由于数组中的所有数都一样，算法RANDOMIZED-PARTITION的前2行将会不会起到任何作用。算法RANDOMIZED-PARTITION调用算法PARTITION时，PARTITION将会把所有数都划分到左侧，并且总返回\\(r\\)。因此其运行时间为\\(T(n)=T(n-1)+\\Theta(n)=\\Theta(n^2)\\)。\r\nb\r\n// 返回的两个下标q, t代表着A[p : q - 1], A[q : t], A[t + 1 : r]这三段。PARTITION&#x27;(A, p, r)  x = A[p]  i = k = p  j = r  while i &lt;= j    if A[i] &lt; x      exchange A[i] and A[k]      i += 1      k += 1    else if A[i] == x      i += 1    else      exchange A[i] and A[j]      j -= 1  return k, i - 1\r\n可以发现，在每一轮循环中，要么\\(i\\)自增\\(1\\)，要么\\(j\\)自减\\(1\\)，直到\\(i,j\\)相遇。因此算法PARTITION'的时间复杂度为\\(\\Theta(r-p)\\)。\r\nc\r\nRANDOMIZED-PARTITION&#x27;(A, p, r)  i = RANDOM(p, r)  exchange A[r] with A[i]  return PARTITION&#x27;(A, p, r)QUICKSORT&#x27;(A, p, r)  if p &lt; r    (q, t) = RANDOMIZED-PARTITION&#x27;(A, p, r)    QUICKSORT&#x27;(A, p, q - 1)    QUICKSORT&#x27;(A, t + 1, r)\r\nd\r\n为了方便分析，考虑将算法PARTITION'中将\\(A[i]\\)和\\(x\\)的两次比较统一称为一次比较，因为将\\(A[i]\\)和\\(x\\)仅需一次比较，就可以得出是小于，等于，还是大于，而为了方便编写伪代码，这里写成了两次比较（在第5,\r\n8行分别进行了一次小于和等于的比较。）\r\n假设\\(m\\)是数组\\(A\\)中不同的数的个数，那么算法RANDOMIZED-PARTITION'的调用次数至少为\\(m\\)。\r\n假设数\\(x\\)在\\(A\\)中的出现次数为\\(c(A,x)\\)。假设数组\\(A\\)排序后的结果为\\(\\langle\r\nz_1,z_2,\\dots,z_n\\rangle\\)，满足\\(z_1\\le z_2\\le \\dots\\le z_n\\)。\r\n对于\\(A\\)中的两个数\\(z_i,z_j(i&lt; j)\\)，如果\\(z_i=z_j=x\\)，那么它们之间有可能发生比较，有可能没有发生比较（取决于支点\\(x\\)是否选择自\\(z_i\\)或者是\\(z_j\\)，如果是，那么就发生了比较。）无论如何，为\\(x\\)的这一些数将会发生\\(c(A,x)-1\\)次比较。因此，相同的比较次数为\\(O(n)\\)次。\r\n现在假设\\(z_i&lt;\r\nz_j\\)，那么如果数\\(x\\)满足\\(z_i&lt; x&lt; z_j\\)先于\\(z_i,z_j\\)被选择，那么\\(z_i,z_j\\)将会无法被比较，否则可以被比较。这些\\(x\\)的个数有上限\\(j-i-1\\)个。\r\n和第7.4.2章类似，假设\\(X\\)是比较次数，\\(X_{ij}\\)是元素\\(z_i,z_j\\)被比较的概率，那么有\\(E[X_{i,j}]\\ge\r\n\\dfrac{2}{j-i+1}\\)，而不再是等于。\r\n因此，有\r\n\\(\\begin{aligned}\r\nE[X]&amp;= \\sum_{i=1}^{n-1}\\sum_{j=i+1}^n \\dfrac{2}{j-i+1}\\\\\r\n&amp;\\ge \\sum_{i=1}^{n-1}\\sum_{k=1}^{n-i} \\dfrac{2}{k+1}\\\\\r\n&amp;\\ge \\sum_{i=1}^{n-1}\\sum_{k=1}^{n-i} \\dfrac{2}{2k}&amp;\\qquad(A)\\\\\r\n&amp;=\\sum_{i=1}^{n-1} \\Omega(\\lg n)\\\\\r\n&amp;=\\Omega(n\\lg n)\r\n\\end{aligned}\\)\r\n其中，步骤\\((A)\\)是因为当\\(k\\ge 1\\)时，\\(\\dfrac{1}{k+1}\\ge \\dfrac{1}{2k}\\)成立。\r\n这说明算法RANDOMIZED-PARTITION'的时间复杂度为\\(T(n)=\\Omega(n\\lg n)\\)。\r\n根据算法QUICKSORT'的第3, 4行递归的区间可知，其上限\\(T(n)\\)必定不超过算法RANDOMIZED-QUICKSORT的上限。\r\n因此，最终有\\(T(n)=\\Theta(n\\lg\r\nn)\\)。\r\n7-3\r\na\r\n根据算法RANDOMIZED-PARTITION的第一行可以知道，每个元素被选作支点的概率为\\(\\dfrac{1}{n}\\)。那么可以得到\\(E[X_i]=\\dfrac{1}{n}\\)。\r\nb\r\n可以发现，在每次随机选择支点中，最多只有一个支点被选中，因此最多只有一个\\(X_q=1\\)。假设此时选择的支点是第\\(q\\)小的，那么就有\\(q-1\\)个元素划分至左侧，有\\(n-q\\)个元素划分至右侧，产生了大小分别为\\(q-1,n-q\\)的子问题。对整个数组进行一次划分的时间复杂度为\\(\\Theta(n)\\)，因此有\r\n\\(\\begin{aligned}\r\nE[T(n)]&amp;=E\\left[\\sum_{q=1}^n X_q\\cdot (T(q-1)+T(n-q))\\right] +\r\n\\Theta(n)\\\\\r\n&amp;=E\\left[\\sum_{q=1}^n X_q\\cdot (T(q-1)+T(n-q)+ \\Theta(n))\\right]\r\n\\end{aligned}\\)\r\nc\r\n假设\\(E[T(0)]=0\\)，因为空数组并不会产生任何的开销。由于随机变量\\(X_i\\)和划分后的子问题是独立的，那么有\r\n\\(\\begin{aligned}\r\nE[T(n)]&amp;=E\\left[\\sum_{q=1}^n X_q\\cdot (T(q-1)+T(n-q)+\r\n\\Theta(n))\\right]\\\\\r\n&amp;=E\\left[\\sum_{q=1}^n X_q\\cdot (T(q-1)+T(n-q))\\right]+ \\Theta(n)\\\\\r\n&amp;=\\sum_{q=1}^n (E[X_q]\\cdot (E[T(q-1)+T(n-q)]))+ \\Theta(n)\\\\\r\n&amp;=\\sum_{q=1}^n \\left(\\dfrac{1}{n}\\cdot (E[T(q-1)]+E[T(n-q)])\\right)+\r\n\\Theta(n)\\\\\r\n&amp;=\\dfrac{2}{n}\\sum_{q=1}^{n-1} E[T(q)]+ \\Theta(n)\\\\\r\n\\end{aligned}\\)\r\nd\r\n可以发现，\\(f(q)=q\\lg\r\nq\\)是一个递增函数，因此有\r\n\\(\\begin{aligned}\r\n\\sum_{q=1}^{n-1} q\\lg q&amp;\\le \\int_{1}^{n} x\\lg x dx \\\\\r\n&amp;=\\left.\\dfrac{1}{2} x^2\\lg x-\\dfrac{x^2}{4\\ln 2}\\right|_{1}^n\\\\\r\n&amp;=\\dfrac{n^2}{2} \\lg n-\\dfrac{n^2}{4\\ln 2}+\\dfrac{1}{4\\ln 2}\\\\\r\n&amp;\\le \\dfrac{n^2}{2} \\lg n-\\dfrac{n^2}{8}&amp;\\qquad(n\\ge 2)\r\n\\end{aligned}\\)\r\n当\\(n=1\\)时，可以验证原式仍然成立。因此\\(\\forall n\\ge 1\\)，都有\\(\\displaystyle{\\sum_{q=1}^{n-1} q\\lg\r\nq\\le  \\dfrac{n^2}{2} \\lg n-\\dfrac{n^2}{8}}\\)。\r\ne\r\n假设\\(T(n)\\le cn\\lg\r\nn\\)，那么联立题目7-3-c, 7-3-d的结论，有\r\n\\(\\begin{aligned}\r\nE[T(n)]&amp;=\\dfrac{2}{n}\\sum_{q=1}^{n-1} E[T(q)]+ \\Theta(n)\\\\\r\n&amp;\\le c\\cdot \\dfrac{2}{n}\\left(\\dfrac{n^2}{2}\\lg\r\nn-\\dfrac{n^2}{8}\\right) + \\Theta(n)\\\\\r\n&amp;=cn\\lg n-\\dfrac{cn}{4}+\\Theta(n)\\\\\r\n&amp;=cn\\lg n-\\left(\\dfrac{cn}{4}-\\Theta(n)\\right)\\\\\r\n&amp;\\le cn\\lg n &amp; \\qquad(A)\r\n\\end{aligned}\\)\r\n其中，变换\\((A)\\)表示假设\\(\\dfrac{cn}{4}\\)渐进增长上界比\\(\\Theta(n)\\)高。\r\n因此，只需要\\(c\\)再取好\\(c\\ge\r\n\\dfrac{T(2)}{2}\\)。那么由数学归纳法，\\(T(n)=O(n\\lg n)\\)成立。\r\n7-4\r\na\r\n考虑使用归纳法的思想证明，将数组前\\(\\dfrac{n}{3}\\)，中间\\(\\dfrac{n}{3}\\)，后\\(\\dfrac{n}{3}\\)的区间分别称为数组的左侧，中间，右侧。\r\n当数组长度\\(n=r-p+1\\le2\\)时，可以发现这个算法能够正确排序。\r\n当\\(r-p+1&gt;2\\)时，第1,\r\n2行的代码保证了头尾两个元素是有序的。第5行代码排序完成后，左侧在\\(A\\)中最大的\\(\\dfrac{n}{3}\\)个元素将会转移到中间。第6行代码执行前，可以知道最大的\\(\\dfrac{n}{3}\\)元素要么在中间，要么在右侧。运行完成后，最大的\\(\\dfrac{n}{3}\\)个元素都在右侧且有序，此时最小的\\(\\dfrac{2n}{3}\\)个元素均在左侧或中间。执行完成第7行代码后，左侧和中间共同保持有序，它们和右侧元素同样保持有序。\r\n此时，算法STOOGE-SORT使得序列\\(A[p:r]\\)有序。\r\nb\r\n假设算法STOOGE-SORT的运行时间为\\(T(n)\\)，那么根据第5, 6,\r\n7行的递归，可以发现产生了\\(3\\)个大小为\\(\\dfrac{2}{3}n\\)的子问题，并且每次调用所需要花费的其它操作时间为\\(\\Theta(1)\\)。因此可以写出递推式：\\(T(n)=3T(2n/3)+\\Theta(1)\\)。\r\n考虑使用主定理，代入得到\\(a=3,b=\\dfrac{3}{2},f(n)=\\Theta(1),\\log_b a\\approx\r\n2.71\\)。\r\n那么使用第一个条件，可以得到\\(T(n)=\\Theta(n^{\\log_{3/2} 3})\\approx\r\n\\Theta(n^{2.71})\\)。\r\nc\r\n不能，因为算法STOOGE-SORT的最坏时间复杂度比以上所述所有算法的最坏时间复杂度都要糟糕。\r\n7-5\r\na\r\n考虑使用归纳法进行说明。\r\n可以发现，对于长度为\\(2\\)及以下的数组，它们可以正确的被排序。\r\n当长度\\(n=p-r+1&gt;2\\)时，考虑进行划分。每一次划分完成后，支点\\(q\\)已经到达了正确的已排序位置。并且递归排序数组\\(A[p:q]\\)中的部分。根据上面的假设，数组\\(A[p:q]\\)最终已经正确排序，并且\\(A[p:q]\\)是数组中最小的\\(q-p+1\\)个数。在下一次迭代得到新的划分\\(q&#39;\\)时，支点\\(A[q&#39;]\\)已经到达了正确的位置，最终正确地递归排序\\(A[q+1:q&#39;-1]\\)中的数……因此循环结束后，整个数组将被正确地排序。\r\nb\r\n当整个数组是已排序的时候，递归的深度可以达到\\(\\Theta(n)\\)。每次划分，数组右侧将会没有元素，而左侧却有\\(n-1\\)个。\r\nc\r\n每一次递归调用，参数\\(r,p\\)将会满足\\(r-p+1\\)的值减少到原来至多一半，因此递归调用的最大深度为\\(\\Theta(\\lg\r\nn)\\)。可以发现，这份代码总体结构并没有改变，仍然保持着\\(O(n\\lg n)\\)的运行时间。\r\nTRE-QUICKSORT(A, p, r)  while p &lt; r  // Partition and then sort the low side.    q = PARTITION(A, p, r)    if q &lt;= ⌊(p + r) / 2⌋      TRE-QUICKSORT(A, p, q – 1)      p = q + 1    else      TRE-QUICKSORT(A, q + 1, r)      r = q - 1\r\n7-6\r\na\r\n假设这个数组的\\(n\\)个元素都不相同，随机选取\\(3\\)个数，那么有\\(\\dbinom{n}{3}\\)种选法。其中，第\\(i\\)小的数成为最终的支点的支点的选法有\\((i-1)\\cdot (n-i)\\)种，因为比\\(i\\)小的数有\\(i-1\\)种选法，比\\(i\\)大的数有\\(n-i\\)种选法。因此，有\r\n\\[p_i=\\dfrac{6(i-1)(n-i)}{n(n-1)(n-2)}\\]\r\nb\r\n按照这个算法，序列\\(A\\)的中位数被选上的概率增加了\\(p_{\\lfloor(n+1)/2\\rfloor}-\\dfrac{1}{n}\\)，也就是：\r\n\\[\\dfrac{6(\\lfloor(n+1)/2\\rfloor-1)(n-\\lfloor(n+1)/2\\rfloor)}{n(n-1)(n-2)}-\\dfrac{1}{n}\\]\r\n尝试计算极限\\(\\displaystyle{\\lim_{n\\rightarrow +\\infty}\r\n\\dfrac{p_{\\lfloor(n+1)/2\\rfloor}}{1/n}}\\)，有\r\n\\(\\begin{aligned}\r\n\\lim_{n\\rightarrow +\\infty} \\dfrac{p_{\\lfloor(n+1)/2\\rfloor}}{1/n}\r\n&amp;= \\lim_{n\\rightarrow +\\infty}\r\n\\dfrac{6(\\lfloor(n+1)/2\\rfloor-1)(n-\\lfloor(n+1)/2\\rfloor)}{(n-1)(n-2)}\r\n\\\\&amp;=\\dfrac{6\\cdot 1/2\\cdot 1/2}{1\\cdot 1}\\\\\r\n&amp;=\\dfrac{3}{2}\r\n\\end{aligned}\\)\r\nc\r\n令\\(\\displaystyle{s_i=\\sum_{j=1}^i\r\np_j}\\)，那么可以得到\\(s_i=\\dfrac{i(i-1)(3n-2i-2)}{n(n-1)(n-2)}\\)\r\n那么最终结果为\\(s_{2n/3}-s_{n/3-1}=\\dfrac{13n^2+9n-90}{27(n-1)(n-2)}\\)。\r\n可以得到\\(\\displaystyle{\\lim_{n\\rightarrow\r\n+\\infty} \\sum_{i=n/3}^{2n/3} p_i=\\lim_{n\\rightarrow +\\infty}\r\ns_{2n/3}-s_{n/3-1}=\\dfrac{13}{27}}\\)。\r\nd\r\n由于最完美的快速排序算法仍然会有\\(\\Omega(n\\lg\r\nn)\\)的下界。这里介绍的划分算法不如最完美的划分算法优秀，偶尔会引入比较坏的情况，因此仍然会有\\(\\Omega(n\\lg n)\\)的下界。\r\n7-7\r\n本题的思想参考了题目7-2。假设区间\\(I\\)是一部分区间的交集，那么将包含区间\\(I\\)的所有区间放数组\\(A\\)中间（因为这一些区间全部可以赋予\\(I\\)中的同一个数），右端点在\\(I\\)左边的区间放在数组\\(A\\)左侧，左端点在\\(I\\)右侧的区间放在数组\\(A\\)右侧，由此递归地排序。\r\na\r\n// 判断区间A和B是否相交。IS-INTERSECT(A, B)  return max&#123;A.l, B.l&#125; &lt;= min&#123;A.r, B.r&#125;// 区间A和B之交。INTERSECT(A, B)  return (max&#123;A.l, B.l&#125;, min&#123;A.r, B.r&#125;)// 这个划分方案将区间划分成三部分：A[p : q - 1], A[q : t], A[t + 1 : r]。其中$A[q : t]$中的所有数全都可以赋值同一个数。PARTION-INTERVAL(A, p, r)  i = RANDOM(p, r)  exchange A[i] with A[p]  I = A[p]  i = k = p  j = r  while i &lt;= j    if IS-INTERSECT(I, A[i])      I = INTERSECT(I, A[i])      i += 1    else if A[i].b &lt; I.a      exchange A[i] and A[k]      i += 1      k += 1    else      exchange A[i] and A[j]      j -= 1  return k, i - 1QUICKSORT-INTERVAL(A, p, r)  if p &lt; r    (q, t) = PARTION-INTERVAL(A, p, r)    QUICKSORT-INTERVAL(A, p, q - 1)    QUICKSORT-INTERVAL(A, t + 1, r)\r\nb\r\n如果这些区间是尽可能的重叠，那么它们将会很容易被算法PARTION-INTERVAL求出它们的交集\\(I\\)。最终这些区间都被放在了中间，达到了递归终点。算法QUICKSORT-INTERVAL将会忽略掉这些已经安排好的区间，如果足够重叠，忽略的区间数足够多，那么就有可能全部忽略完，达到\\(\\Theta(n)\\)的时间复杂度。\r\n算法QUICKSORT-INTERVAL最终递归求解的是自问\\(A[p:q-1],A[t+1:r]\\)，这两个子问题并不重叠。在最坏情况下，这些区间互相不相交，此时这个算法相当于一般的RANDOMIZED-QUICKSORT算法，其时间复杂度为\\(\\Theta(n\\lg\r\nn)\\)。在一般情况下，这个算法的行为和RANDOMIZED-QUICKSORT相同，其时间复杂度为\\(\\Theta(n\\lg n)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论9.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-9/exercises-1/","content":"\r\n9.1-1\r\n算法GET-2-SMALLEST设计如下。基本思想是，通过类似“淘汰赛”的比较方式找到最小值。在这个阶段中，需要进行\\(n-1\\)次比较。在一轮淘汰过程中，需要进行\\(\\left\\lfloor\\dfrac{n}{2}\\right\\rfloor\\)次的比较，并且记录被自己淘汰的选手。\r\n最终经过\\(\\lceil\\lg\r\nn\\rceil\\)轮的淘汰赛后，最终得出最小的胜者。\r\n最小值必定和次小值进行过比较并且将其淘汰，否则，次小值最终会成为最小值。在最小值比较过的\\(\\lceil\\lg n\\rceil\\)个数中，需要进行\\(\\lceil\\lg n\\rceil-1\\)次比较才能找出这\\(\\lceil\\lg\r\nn\\rceil\\)个数中的最小值，这个最小值就是全局的次小值。\r\n因此，最终需要进行\\(n-1+\\lceil\\lg n\\rceil -\r\n1=n+\\lceil\\lg n\\rceil-2\\)次比较就能找到最小值和次小值。\r\nGET-2-SMALLEST(A, n)  let pre[1 : n], B be new array with 0  for i = 1 to n    INSERT(B, i)    make pre[i] an empty list  while B.size != 1    let C be new array    for i = 1 to B.size by 2      if A[B[i]] &lt;= A[B[i + 1]]        INSERT(C, B[i])        INSERT(pre[B[i]], B[i + 1])      else                INSERT(C, B[i + 1])        INSERT(pre[B[i + 1]], B[i])    if B.size % 2 == 1      INSERT(C, B[B.size])    B = C  smallest_1 = B[1]  smallest_2 = B[smallest_1, 1]  for i = 2 to pre[smallest_1].size    if A[pre[smallest_1, i]] &lt; A[smallest_2]      smallest_2 = pre[smallest_1, i]  return A[smallest_1], A[smallest_2]\r\n9.1-2\r\n总共需要\\(3\\)次比较。对数组中的前\\(3\\)个数直接进行排序，需要进行\\(3\\)次比较。这\\(3\\)个数中间的那个值一定不是最小值也不是最大值，因为它前面还有一个比它更小的数，后面还有一个比它更大的数。\r\n9.1-3\r\n总共需要\\(7\\)场比赛。\r\n首先将这\\(25\\)匹马分成\\(5\\)组分别进行小组赛，并且决出组内排名，令\\(h_{i,j}(1\\le i,j\\le 5)\\)表示第\\(i\\)组第\\(j\\)名的马。\r\n接下来，第\\(6\\)场比赛是由组内\\(5\\)个冠军进行展开，也就是\\(h_{1,1},h_{2,1},h_{3,1},h_{4,1},h_{5,1}\\)。最终假设第\\(k\\)名的马来自第\\(r_k\\)组，为\\(h_{r_k,1}\\)。\r\n那么可以知道，\\(h_{r_4,1},h_{r_5,1}\\)不可能是前\\(3\\)好的马，并且\\(h_{r_1,1}\\)是最好的马。\r\n第\\(7\\)场比赛由\\(h_{r_1,2},h_{r_1,3},h_{r_2,1},h_{r_2,2},h_{r_3,1}\\)之间进行，这场比赛前\\(2\\)好的马就是全局第\\(2,3\\)好的马。因为次好的马有可能来自\\(r_1,r_2\\)组。\r\n\\(\\star\\)\r\n9.1-4\r\n假设最大值候选集合为\\(S\\)，最小值候选集合为\\(T\\)。在一开始，\\(|S|=|T|=n\\)。那么当\\(|S\\cap T|\\ge 2\\)时，采用\\(1\\)次比较可以同时在\\(S,T\\)中分别去掉\\(1\\)个元素，这种比较最多只能使用\\(\\left\\lfloor\\dfrac{n}{2}\\right\\rfloor\\)次。在此之后，两个集合都只剩下\\(n-\\left\\lfloor\\dfrac{n}{2}\\right\\rfloor=\\left\\lceil\\dfrac{n}{2}\\right\\rceil\\)个元素。\r\n那么在每个集合内部，使用\\(1\\)次比较可以再次去掉集合内的\\(1\\)个元素，这时需要\\(n-\\left\\lfloor\\dfrac{n}{2}\\right\\rfloor-1\\)次的比较。\r\n因此，至少需要\\(\\left\\lfloor\\dfrac{n}{2}\\right\\rfloor+2\\left(n-\\left\\lfloor\\dfrac{n}{2}\\right\\rfloor-1\\right)=2n-\\left\\lfloor\\dfrac{n}{2}\\right\\rfloor-2=\\left\\lceil\\dfrac{3n}{2}\\right\\rceil-2\\)次比较。\r\n","categories":["算法导论"]},{"title":"算法导论32.2 Exercises 答案","url":"/introduction-to-algorithms/chapter-32/exercises-2/","content":"\r\n32.2-1\r\n可见，\\(p=26\\bmod 11=4\\)。\r\n按照算法RABIN-KARP-MATCHER的执行结果，可以计算出的\\(t_s\\)值如下标：\r\n\\(\\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}\\hline\r\ns&amp;0&amp;1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8&amp;9&amp;10&amp;11&amp;12&amp;13&amp;14\\\\\\hline\r\nt_s&amp;9&amp;3&amp;8&amp;4&amp;4&amp;4&amp;4&amp;10&amp;9&amp;2&amp;3&amp;1&amp;9&amp;2&amp;5\\\\\\hline\r\n\\end{array}\\)\r\n可见一共有\\(4\\)次命中，但是仅有偏移\\(6\\)是有效偏移，因此其余的偏移\\(3,4,5\\)都是伪命中。\r\n32.2-2\r\n这题的思想比较简单：首先求出\\(k\\)个模式串的\\(p\\)值\\(p_1,p_2,\\dots,p_k\\)，并且使用一个基于链接法的哈希表来存储这些\\(p\\)值和对应的字符串。只要哈希表的大小合适，那么只需要\\(O(1)\\cdot O(m(v+n/q))=\r\nO(m(v+n/q))\\)，其中\\(v\\)是有效偏移的数量。需要注意的是，只有\\(p_1,p_2,\\dots,p_k\\)都是长度为\\(m\\)的情况下才能使用该算法RABIN-KARP-MATCHER'：\r\nRABIN-KARP-MATCHER&#x27;(T, P, n, k, m, d, q)  h = d^(m - 1) mod q  let p[1 : k] be a new array by 0  let T be a new hash-table.  t0 = 0  for i = 1 to m    t0 = (d * t0 + T[i]) mod q    for j = 1 to k    p[j] = (d * p[j] + P[j, i]) mod q  for j = 1 to k    let x be a new node    x.key = p[j]    x.p = P[j]    // 节点x存的是字符串和它的哈希值。    CHAINED-HASH-INSERT(T, x)  //假设CHAINED-HASH-SEARCH&#x27;返回的是哈希表中和x.key相同的所有节点，而并非只是至多一个；hash是一个哈希函数。  for s = 0 to n - m    for v, pat in CHAINED-HASH-SEARCH&#x27;(T, hash(t_s))      if v == t_s         if pat[1 : m] == T[s + 1 : s + m]          print &quot;Pattern &quot; pat &quot; occur with shifts&quot; s    if s &lt; n - m      t_&#123;s + 1&#125; = (d * (t_s - T[s + 1] * h) + T[s + m + 1]) mod q\r\n对于模式串不等长的情况下，不能够使用上述哈希表的情况，只能分别独立地进行查询。通过数组模拟各种查询情况，最终整个过程由程序RABIN-KARP-MATCHER''给出，其时间复杂度为\\(O(km(v+n/q))\\)，其中\\(v\\)是有效偏移的数量。\r\nRABIN-KARP-MATCHER&#x27;&#x27;(T, P, n, k, d, q)  h = d^(m - 1) mod q  let p[1 : k] be a new array by 0  let T be a new hash-table.  for j = 1 to k    t0 = 0    for i = 1 to |P[j]|      p[j] = (d * p[j] + P[j, i]) mod q      t0 = (d * t0 + T[i]) mod q    for s = 0 to n - |P[j]|      if p == t_s        if P[j, 1 : |P[j]|] == T[s + 1 : s + m]          print &quot;Pattern &quot; P[j] &quot; occur with shifts&quot; s      if s &lt; n - m        t_&#123;s + 1&#125; = (d * (t_s - T[s + 1] * h) + T[s + m + 1]) mod q\r\n32.2-3\r\n这道题的本质思想是将二维的情况转化为一维。对于每相邻\\(m\\)行，我们先预处理出一个长度为\\(n\\)的数组\\(U\\)，然后再在数组\\(U\\)上处理一维的情况，注意处理一行\\(U\\)的情况时，不像RABIN-KARP-MATCHER那样以\\(d\\)作为进制，而是以\\(d&#39;=d^m\\)来作为进制。和RABIN-KARP-MATCHER同样的是，判断一个字符矩阵对应的值\\(t\\)是否和\\(p\\)相同只需要\\(O(1)\\)的时间即可完成。\r\n一共需要判断\\((n-m+1)^2\\)种情况，因此在最坏情况下，这个二维版本的算法将会达到\\(O((n-m)+1^2 \\cdot\r\nm^2)=O(n^4)\\)。具体过程由RABIN-KARP-MATCHER-2D给出。\r\nRABIN-KARP-MATCHER-2D(T, P, n, m, d, q)  ha = d ^ (m * (m-1)) mod q  hr = d ^ (m-1) mod q  d&#x27; = d ^ m mod q  p = 0  for j = 1 to m    for i = 1 to m      p = (d * p + P[i, j]) mod q  let U[1 : n] be a new array by 0  for j = 1 to n    for i = 1 to m      U[j] = (d * U[j] + T[i, j]) mod q  for rs = 0 to n - m    u0 = 0    for j = 1 to m      u0 = (d&#x27; * u0 + U[j]) mod q    for cs = 0 to n - m      if p == ts        if P[1 : m,1 : m] == T[rs + 1:rs + m,cs + 1:cs + m]          print &quot;Pattern occurs with shift&quot; (rs, cs)      if cs &lt; n - m        u_&#123;cs + 1&#125; = (d&#x27; * (u_&#123;cs&#125; - U[cs + 1] * ha) + U[cs + m + 1]) mod q    if rs &lt; n - m      for j = 1 to n        U[j] = (d * (u[j] - T[rs + 1, j] * ha) + T[rs + m + 1, j]) mod q\r\n32.2-4\r\n考虑令\\(\\displaystyle{f(A,B,x)=\\left(\\sum_{i=0}^{n-1}(a_i-b_i)x^i\\right)\\bmod\r\nq}\\)。\r\n如果两个文件相同，那么也就是说\\(\\forall\r\ni\\in[0,n),a_i=b_i\\)均成立，那么此时任取\\(x\\in[0,q)\\)，都必定有\\(A(x)=B(x)\\)。\r\n否则，非零多项式\\(f(A,B,x)\\)的次数至多为\\(n\\)。由于\\(q\\)是一个质数，依照题目31.4-4的结论，方程\\(f(A,B,x)=0\\)最多有\\(n\\)个不同的根。由于\\(x\\)是从\\([0,q)\\)中选择的，因此任取\\(x\\in [0,q),f(A,B,x)=0\\)的概率至多为\\(\\dfrac{n}{q}\\)。由于\\(q&gt;10^3\\cdot n\\)，因此\\(f(A,B,x)=0\\)的概率不会超过\\(10^{-3}\\)，原结论成立。\r\n","categories":["算法导论"]},{"title":"算法导论32.1 Exercises 答案","url":"/introduction-to-algorithms/chapter-32/exercises-1/","content":"\r\n32.1-1\r\n令\\(t(s)(s\\le n-m)\\)表示偏移为\\(s\\)时，进行的匹配次数，那么这些匹配次数由下表给出：\r\n\\(\\begin{array}{|c|l|c|c|}\\hline\r\ns&amp;\\mathtt{000010001010001} &amp;t(s)&amp;\\text{is matched}\\\\\\hline\r\n0&amp;\\mathtt{0001}&amp;4&amp;\\text{No}\\\\\\hline\r\n1&amp;\\mathtt{\\ 0001}&amp;4&amp;\\text{Yes}\\\\\\hline\r\n2&amp;\\mathtt{\\ \\ 0001}&amp;3&amp;\\text{No}\\\\\\hline\r\n3&amp;\\mathtt{\\ \\ \\ 0001}&amp;2&amp;\\text{No}\\\\\\hline\r\n4&amp;\\mathtt{\\ \\ \\ \\ 0001}&amp;1&amp;\\text{No}\\\\\\hline\r\n5&amp;\\mathtt{\\ \\ \\ \\ \\ 0001}&amp;4&amp;\\text{Yes}\\\\\\hline\r\n6&amp;\\mathtt{\\ \\ \\ \\ \\ \\ 0001}&amp;3&amp;\\text{No}\\\\\\hline\r\n7&amp;\\mathtt{\\ \\ \\ \\ \\ \\ \\ 0001}&amp;2&amp;\\text{No}\\\\\\hline\r\n8&amp;\\mathtt{\\ \\ \\ \\ \\ \\ \\ \\ 0001}&amp;1&amp;\\text{No}\\\\\\hline\r\n9&amp;\\mathtt{\\ \\ \\ \\ \\ \\ \\ \\ \\ 0001}&amp;2&amp;\\text{No}\\\\\\hline\r\n10&amp;\\mathtt{\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ 0001}&amp;1&amp;\\text{No}\\\\\\hline\r\n11&amp;\\mathtt{\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ 0001}&amp;4&amp;\\text{Yes}\\\\\\hline\r\n\\end{array}\\)\r\n32.1-2\r\n如果\\(P\\)的各个字母都不相同，那么可以考虑从左到右遍历文本串\\(T\\)，考察\\(T\\)中和\\(P[1]\\)相同的那些下标。由于\\(P\\)中的字符各不相同，因此对于一对相邻都是字符\\(P[1]\\)的下标\\(i,j(i&lt;j)\\)，只有\\(i+|P|\\le j\\)时，偏移量\\(i+1\\)才有可能是正确的，这时只需要检测一下即可。\r\n由于\\(S\\)中的每个字符和\\(P\\)中的字符至多只会进行一次匹配，因此这个算法的时间复杂度为\\(O(n)\\)。具体过程由NAIVE-STRING-MATCHER'给出。\r\nNAIVE-STRING-MATCHER(T, P, n, m)  cnt = n + 1  for i = 1 to n    if T[i] == P[1]      cnt = 1    else      cnt = cnt + 1    if cnt == m and P[1:m] == T[i - cnt + 1:i]      print &quot;Pattern occurs with shift&quot; i - cnt\r\n32.1-3\r\n对于文本串\\(T\\)的偏移量\\(s\\)，它能和模式串\\(P\\)的第\\(j\\)个字符比较当且仅当\\(T[s+1:s+j-1]=P[1:j-1]\\)，这个概率值为\\(d^{-(j-1)}\\)。\r\n令随机变量\\(X_{s}\\)表示偏移量为\\(s\\)时，\\(T[s+j-1]\\)和\\(P[j]\\)发生了比较。那么有\\(X_{s,j}=d^{-(j-1)}\\)。\r\n令随机变量\\(\\displaystyle{Y=\\sum_{s=0}^{n-m}\\sum_{j=1}^{m}X_{ij}}\\)表示比较次数，那么有：\r\n\\(\\begin{aligned}\r\nE[Y]&amp;=\\sum_{s=0}^{n-m}\\sum_{j=1}^{m}E[X_{ij}]\\\\\r\n&amp;=\\sum_{s=0}^{n-m}\\sum_{j=1}^{m}\\dfrac{1}{d^{j-1}}\\\\\r\n&amp;=\\sum_{s=0}^{n-m}\\dfrac{d-d^{1-m}}{d-1}\\\\\r\n&amp;=(n-m+1)\\cdot\\dfrac{d-d^{1-m}}{d-1}\\\\\r\n&amp;=(n-m+1)\\cdot\\dfrac{1-d^{m}}{1-d^{-1}}\\\\\r\n&amp;\\le(n-m+1)\\cdot\\dfrac{1}{1-d^{-1}}\\\\\r\n&amp;\\le(n-m+1)\\cdot\\dfrac{1}{1-2^{-1}}\\\\\r\n&amp;\\le2(n-m+1)\r\n\\end{aligned}\\)\r\n32.1-4\r\n本题可以使用动态规划进行求解。令状态\\(f(i,j)(0\\le i\\le m,0\\le j\\le\r\nm)\\)表示使用\\(P\\)的前\\(i\\)个字符是否能匹配\\(T\\)的前\\(j\\)个字符。那么可以写出如下状态转移方程：\r\n\\(f(i,j)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;1 &amp; &amp; \\text{if}\\quad  i=0\\land j=0 \\\\\r\n  &amp;0 &amp; &amp; \\text{if}\\quad  i=0\\land j&gt;0\\lor i&gt;0\\land\r\nj=0\\land P[i]\\neq\\Diamond\\land f(i-1,0)=0 \\\\\r\n  &amp;\\bigvee_{k=0}^j f(i-1,k) &amp; &amp; \\text{if}\\quad  i&gt;0\\land\r\nP[i]=\\Diamond\\\\\r\n  &amp;f(i-1,j-1)\\land \\mathbf{1}\\{P[i]=S[j]\\} &amp; &amp;\r\n\\text{if}\\quad  i&gt;0\\land j&gt;0\\land P[i]\\neq\\Diamond\\\\\r\n\\end{aligned}\\right.\\)\r\n其中\\(\\mathbf{1}\\{b\\}\\)表示一个示性函数，用于表示布尔表达式\\(b\\)是否成立。方程第三行表示这里有一个通配符\\(\\Diamond\\)，它可以匹配任意长度的字符串，因此可以从任意状态\\(f(i-1,k)\\)转移到\\(f(i,j)(k\\le\r\nj)\\)，方程的第四行用于表示一个普通字符的匹配。\r\n最终答案为\\(f(m,n)\\)。\r\n使用前缀和可以将这个转移优化到\\(O(nm)\\)，因此可以在多项式时间复杂度内完成这个问题。\r\n","categories":["算法导论"]},{"title":"算法导论9 Problems 答案","url":"/introduction-to-algorithms/chapter-9/problems/","content":"\r\n9-1\r\na\r\n先直接进行排序，需要\\(O(n\\lg\r\nn)\\)的运行时间，然后直接返回最后\\(i\\)个数。这个算法的总体时间复杂度为\\(O(n\\lg n)\\)。\r\nb\r\n使用算法BUILD-MAX-HEAP对整个数组进行建堆，需要\\(O(n)\\)的运行时间。然后使用\\(i\\)次算法EXTRACT-MAX分别弹出当前最大值，每次使用的运行时间为\\(O(\\lg n)\\)。这个算法的总体时间复杂度为\\(O(n + i\\lg n)\\)。\r\nc\r\n先用算法SELECT求出第\\(n-i+1\\)小的数（也就是第\\(i\\)大的数），需要\\(O(n)\\)的运行时间。然后直接对后面\\(i\\)个元素进行排序后直接返回，这个过程需要\\(O(i\\lg\r\ni)\\)的运行时间。这个算法的总体时间复杂度为\\(O(n + i\\lg i)\\)。\r\n9-2\r\na\r\n如果第3行代码返回的\\(q\\)恰好是下标最大值\\(r\\)，那么\\(k=r-p+1\\)，由于\\(i\\le\r\nr-p+1\\)是恒成立的，因此必定进入第6行的分支。此时的递归调用相当于是SIMPLER-RANDOMIZED-SELECT(A, p, r, i)，这没有对区间做任何的缩减。因此，在最坏情况下相当于进行无限递归，程序不会终止。\r\nb\r\n算法SIMPLER-RANDOMIZED-SELECT的第3行相当于从区间\\(A[p:r]\\)中均匀随机选择一个数作为支点，最终划分完成后（假设这是第\\(i\\)小的数），在第6-7行中选择一个分支继续进行查找。\r\n假设在最坏情况下，每次递归查找的都是大小比较大的那个区间，那么假设\\(T(n)\\)为运行时间，有\r\n\\[T(n)\\le \\dfrac{1}{n}\\cdot\\sum_{i=1}^n\r\nT(\\max\\{i,n-i\\}) + O(n)\\]\r\n整理一下，可以写成\r\n\\[T(n)\\le\r\n\\dfrac{1}{n-1}\\cdot\\sum_{i=1}^{n-1} T(\\max\\{i,n-i\\}) + O(n)\\]\r\n考虑消去\\(\\max\\)。如果\\(n-1\\)是奇数，那么项\\(T(n/2)\\)会出现\\(1\\)次，项\\(T(n/2+1),T(n/2+2),\\dots,T(n-1)\\)都会出现\\(2\\)次；如果\\(n-1\\)是偶数，那么项\\(T((n+1)/2),T((n+1)/2+1),\\dots,T(n-1)\\)都会出现\\(2\\)次。\r\n因此为了避免分别讨论，缩放时，\\(n-1\\)为奇数的情况再添加多一个项，那么可以写出\r\n\\[T(n)\\le\r\n\\dfrac{2}{n-1}\\cdot\\sum_{i=\\lceil n/2\\rceil}^{n-1} T(i) +\r\nO(n)\\]\r\n假设\\(T(n)\\le cn\\)，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;\\le \\dfrac{2}{n-1}\\cdot\\sum_{i=\\lceil n/2\\rceil}^{n-1} T(i) +\r\nO(n)\\\\\r\n&amp;\\le \\dfrac{2c}{n-1} \\cdot \\dfrac{(\\lceil n/2\\rceil+n-1)(n-\\lceil\r\nn/2\\rceil)}{2} + O(n)\\\\\r\n&amp;=c\\cdot \\dfrac{(\\lceil n/2\\rceil+n-1)(n-\\lceil n/2\\rceil)}{n-1} +\r\nO(n)\\\\\r\n&amp;\\le c\\cdot \\dfrac{(n/2+1+n-1)(n-n/2-1)}{n-1} + O(n)\\\\\r\n&amp;=\\dfrac{3cn(n-2)}{4(n-1)} + O(n) \\\\\r\n&amp;\\le\\dfrac{3cn(n-2)}{4(n-2)} + O(n) \\\\\r\n&amp;=\\dfrac{3}{4} cn+O(n)\\\\\r\n&amp;\\le cn &amp; \\qquad(A)\r\n\\end{aligned}\\)\r\n其中步骤\\((A)\\)使用了如下假设：\\(c\\)足够大，使得\\(\\dfrac{cn}{4}\\)的渐进增长快于\\(O(n)\\)。\r\n因此有\\(T(n)=O(n)\\)。\r\n9-3\r\n这里的中位数默认是第\\(\\left\\lceil\\dfrac{n}{2}\\right\\rceil\\)小的数。\r\n需要注意的是，通过哈希表，我们可以把相同的\\(x\\)合并成一个，并且其权值进行相加。只要哈希表的性能足够优秀，那么这个预处理需要\\(\\Theta(n)\\)的时间复杂度完成。因此在接下来的过程中，我们默认\\(x\\)是两两不同的。\r\na\r\n小于中位数的数有\\(\\left\\lceil\\dfrac{n}{2}\\right\\rceil-1\\)个。那么这些数的权值之和为\\(\\dfrac{1}{n}\\left(\\left\\lceil\\dfrac{n}{2}\\right\\rceil-1\\right)\\)。可以发现，当\\(n\\)为偶数时，权值和为\\(\\dfrac{1}{2}-\\dfrac{1}{n}\\)，当\\(n\\)为奇数时，权值和为\\(\\dfrac{n-1}{2n}\\)。无论那种情况都小于\\(\\dfrac{1}{2}\\)。\r\n大于中位数的数有\\(n-\\left\\lceil\\dfrac{n}{2}\\right\\rceil=\\left\\lfloor\\dfrac{n}{2}\\right\\rfloor\\)个。那么这些数的权值之和为\\(\\dfrac{1}{n}\\left\\lfloor\\dfrac{n}{2}\\right\\rfloor\\)。无论\\(n\\)取何值，权值之和总小于等于\\(\\dfrac{1}{2}\\)。\r\n因此，\\(\\{x\\}\\)的普通中位数就是这种特殊情况下的带权中位数。\r\nb\r\n算法GET-WEIGHTED-MEDIAN1给出了求取一个带权中位数的算法。其中排序算法的时间复杂度假设为\\(O(n\\lg n)\\)。\r\n// 数组A中的每一个元素都有两个属性，分别为x和w，x表示数值，w表示权重。GET-WEIGHTED-MEDIAN1(A, n)  sort A[1 : n] by key x  s = 0  for i = 1 to n    s = s + A[i].w    if s &gt;= 0.5      return A[i].x  return NIL\r\n直接排完序后，从小到大将所有数的权值逐渐相加，将第一个大于等于0.5的数直接返回。如果输入是合法的（权值之和为\\(1\\)），那么第7行的代码return NIL不会被运行到。\r\nc\r\n整个算法通过如下伪代码给出给出。子程序RANDOMIZED-PARTITION-WEIGHTED和PARTITION-WEIGHTED与原版的行为基本相同，多统计了一个权值之和。它们的时间复杂度为\\(\\Theta(n)\\)。\r\n算法MEDIAN-WEIGHT的时间复杂度\\(T(n)\\)的分析过程和9-2-b完全一致，为\\(T(n)=O(n)\\)。第5行代码第一次对整个数组进行了一次划分，因此有\\(T(n)=\\Omega(n)\\)。那么整个算法的时间复杂度为\\(T(n)=\\Theta(n)\\)。\r\n// PARTITION-WEIGHTED返回两个值，一个是划分后这个数的下标q，一个是A[p : q]中所有数的权值之和。PARTITION-WEIGHTED(A, p, r)  s = 0  x = A[r].x // the pivot  i = p – 1 // highest index into the low side  for j = p to r – 1 // process each element other than the pivot    if A[j].x &lt; x // does this element belong on the low side?      i = i + 1 // index of a new slot in the low side      exchange A[i] with A[j] // put this element there  exchange A[i + 1] with A[r] // pivot goes just to the right of the low side  return i + 1, s + A[i + 1].wRANDOMIZED-PARTITION-WEIGHTED(A, p, r)  i = RANDOM(p, r)  exchange A[r] with A[i]  return PARTITION-WEIGHTED(A, p, r)// 目标是求出最小的数x，使得小于等于x的所有权值之和大于等于0.5.MEDIAN-WEIGHT(A, n)  pw = 0.5  p = 1  r = n  while p &lt; r    q, nw = RANDOMIZED-PARTITION(A, p, r)    if nw &gt;= pw      r = q    else      pw = pw - nw      p = q + 1  return A[p].x\r\nd\r\n假设\\(x\\)是目前的最小值解，且\\(x\\)不是带权中位数，即不满足带权中位数条件\\(\\displaystyle{\\sum_{x_i&lt; x_k}\r\nw_i&lt;\\dfrac{1}{2},\\sum_{x_i&gt; x_k} w_i\\le\r\n\\dfrac{1}{2}}\\)中的一个。\r\n不失一般性，假设不满足第\\(2\\)个条件，那么有\\(\\displaystyle{\\sum_{p_i&gt; x} w_i-\\sum_{p_i&lt;\r\nx} w_i&gt;0}\\)。\r\n令\\(\\displaystyle{k=\\min_{i=1}^n\\{|x-p_i|\\}}\\)，那么取\\(l\\)使得\\(l\\in\r\n[0,k)\\)。从\\(x\\)向右迈出一小步\\(l\\)，那么此时有\r\n\\(\\begin{aligned}\r\n\\sum_{i=1}^n w_i  d(x+l,p_i) &amp;= \\sum_{p_i&lt;x} w_i(x+l-p_i) +\r\n\\sum_{p_i&gt;x} w_i(p_i-x-l)\\\\\r\n&amp;=\\sum_{p_i&lt;x} w_i(x-p_i)+\\sum_{p_i&gt;x} w_i(p_i-x) -\r\nl\\left(\\sum_{p_i&gt;x} w_i-\\sum_{p_i&lt;x} w_i\\right)\\\\\r\n&amp;=\\sum_{i=1}^n w_i  d(x,p_i)- l\\left(\\sum_{p_i&gt;x}\r\nw_i-\\sum_{p_i&lt;x} w_i\\right)\\\\\r\n&amp;\\le \\sum_{i=1}^n w_i  d(x,p_i)\r\n\\end{aligned}\\)\r\n由此可见，得到了一个更优秀的解\\(x+l\\)。\r\n当不满足第\\(1\\)个条件时，则是按反方向走，证明方法类似。\r\n因此，当\\(x\\)是带权中位数时，得到的解是最优的。\r\ne\r\n由于\\(\\displaystyle{\\sum_{i=1}^n\r\nd(p,p_i)=\\sum_{i=1}^n w_i(|x-x_i|+|y-y_i|)=\\left(\\sum_{i=1}^n\r\nw_i|x-x_i|\\right)+\\left(\\sum_{i=1}^n\r\nw_i|y-y_i|\\right)}\\)，可以分别将两个维度的坐标看成是两个独立的一维问题进行解决。分别求出\\(x\\)坐标和\\(y\\)坐标后进行组合即可。\r\n9-4\r\na\r\n这个算法由SELECT'给出。基本思想是先一对对元素进行比较并且绑定，完成\\(\\left\\lfloor\\dfrac{n}{2}\\right\\rfloor\\)次比较后，递归划分出\\(\\left\\lceil\\dfrac{n}{2}\\right\\rceil\\)个小元素中前\\(i\\)小的元素。划分好后，第\\(i\\)小数必定是这\\(i\\)对数中的第\\(i\\)小数。\r\nSELECT&#x27;(A, n, i)  if 2 * i &gt;= n    return SELECT(A, 1, n, i)  if n % 2 == 1    INSERT(A, +∞)    n += 1  m = n / 2  for i = 1 to m    if A[i] &gt; A[i + m]      exchange A[i] with A[i + m]      combine A[i] and A[i + m]  SELECT&#x27;(A[1 : m], m, i)  let B[1 : i + i] be new array  for j = 1 to i    B[j] = A[i]    B[j + i] = the number that A[i] combine  return SELECT(B, 1, i + i, i)\r\nb\r\n我们使用代入法来证明\\(U_i(n)-n=O(T(2i)\\lg(n/i))\\)。假设\\(U_i(n) -n\\le c \\cdot T(2i)\\cdot\r\n\\lg(n/i)\\)。那么有\r\n\\(\\begin{aligned}\r\nU_i(n)-n&amp;= (U_i(\\lceil n/2\\rceil)-\\lceil n/2\\rceil)+T(2i)\\\\\r\n&amp;\\le c\\cdot T(2i)\\cdot \\lg(\\lceil n/2\\rceil/i) + T(2i)\\\\\r\n&amp;\\le c\\cdot T(2i)\\cdot(\\lg( n/2/i) + 1) &amp; \\qquad(A)\\\\\r\n&amp;\\le c\\cdot T(2i)\\cdot(\\lg(n/i)) \\\\\r\n\\end{aligned}\\)\r\n其中，步骤\\((A)\\)假设了\\(c&gt;1\\)，并且足够大到消去符号\\(\\lceil\\rceil\\)。\r\n因此，\\(U_i(n)-n=O(T(2i)\\lg(n/i))\\)，即\\(U_i(n)=n+O(T(2i)\\lg(n/i))\\)。\r\nc\r\n根据题目9-4-b的结论，可以得出：\\(\\exists\r\nc,n_0&gt;0,\\forall n&gt;n_0,0\\le U_i(n)-n\\le c\\cdot S(2i)\\cdot\r\n\\lg(n/i)\\)恒成立。\r\n那么有\r\n\\(\\begin{aligned}\r\nU_i(n)-n &amp;\\le c\\cdot S(2i)\\cdot \\lg(n/i)\\\\\r\n&amp;= c\\cdot S(2i)\\cdot (\\lg n-\\lg i)\\\\\r\n&amp;\\le c\\cdot S(2i)\\cdot \\lg n\r\n\\end{aligned}\\)\r\n构造一个新常数\\(c&#39;=c\\cdot\r\nS(2i)\\)，那么这对常数\\(\\{c&#39;,n_0\\}\\)说明\\(U_i(n)-n=O(\\lg n)\\)，即\\(U_i(n)=n+O(\\lg n)\\)。\r\nd\r\n当\\(k\\ge 2\\)时，\\(i=n/k&lt;n/2\\)。因此根据题目9-4-b的结论，代入\\(i=n/k\\)，可以得到\\(U_i(n)=n+O(S(2n/k)\\lg k)\\)。\r\n9-5\r\na\r\n和分析RANDOMIZED-QUICKSORT时的思想一致，如果我们选择的支点处在\\(\\min\\{z_i,z_j\\}\\)和\\(\\max\\{z_i,z_k\\}\\)之间时，才会有讨论的意义。否则，每次划分区间时，这\\(3\\)个元素仍然处在同一个区间内部，\\(z_j\\)和\\(z_k\\)是否被比较仍然未知。并且按照上面的思想，\\(z_j\\)和\\(z_k\\)是否被比较，当且仅当\\(z_j,z_k\\)处在同一区间内，并且着两个数之一成为支点\\(q\\)。那么分别考虑三种情况：\r\n\r\n当\\(z_i&lt; z_j&lt;\r\nz_k\\)时，如果支点\\(q\\in\\{z_j,z_k\\}\\)，那么就会产生对\\(z_j,z_k\\)的比较。如果\\(q\\in\r\n[z_i,z_j)\\)，那么下一层递归将会进入区间\\([z_i,q),z_j,z_k\\)永远不会被比较。如果\\(q\\in (z_j,z_k)\\)，那么\\(z_j\\)和\\(z_k\\)将会被分隔开，永远不会被比较。此时\\(E[X_{ijk}]=\\dfrac{2}{k-i+1}\\)。\r\n当\\(z_j&lt; z_k&lt;\r\nz_i\\)时，此时和情况1类似。此时\\(E[X_{ijk}]=\\dfrac{2}{i-j+1}\\)。\r\n当\\(z_j\\le z_i\\le\r\nz_k\\)时，类似的，如果\\(q\\in\r\n(z_j,z_k)\\)，那么\\(z_j\\)和\\(z_k\\)将会被分隔开，永远不会被比较；否则必定会被比较，此时\\(E[X_{ijk}]=\\dfrac{2}{k-j+1}\\)。\r\n\r\n因此有：\r\n\\(E[X_{ijk}]=\r\n\\left \\{\\begin{aligned}\r\n  &amp;\\dfrac{2}{k-i+1} &amp; &amp; \\text{if}\\quad  z_i&lt; z_j&lt; z_k\r\n\\\\\r\n  &amp;\\dfrac{2}{i-j+1} &amp; &amp; \\text{if}\\quad  z_j&lt; z_k&lt; z_i\r\n\\\\\r\n  &amp;\\dfrac{2}{k-j+1} &amp; &amp; \\text{if}\\quad  z_j\\le z_i\\le z_k \\\\\r\n\\end{aligned}\\right.\\)\r\nb\r\n根据示性随机变量\\(X_i\\)的定义，有\\(\\displaystyle{X_i=\\sum_{j=1}^{n-1}\\sum_{k=j+1}^n\r\nX_{ijk}}\\)。那么有\r\n\\(\\begin{aligned}\r\nE[X_i]&amp;=E\\left[\\sum_{j=1}^{n-1}\\sum_{k=j+1}^n X_{ijk}\\right]\\\\\r\n&amp;=\\sum_{j=1}^{n-1}\\sum_{k=j+1}^n E[X_{ijk}]\\\\\r\n&amp;=\\sum_{j=i+1}^{n-1}\\sum_{k=j+1}^n E[X_{ijk}] +\r\n\\sum_{j=1}^{i-2}\\sum_{k=j+1}^{i-1} E[X_{ijk}] +\r\n\\sum_{j=1}^{i}\\sum_{k=i}^n E[X_{ijk}]\\\\\r\n&amp;=\\sum_{j=i+1}^{n-1}\\sum_{k=j+1}^n \\dfrac{2}{k-i+1} +\r\n\\sum_{j=1}^{i-2}\\sum_{k=j+1}^{i-1} \\dfrac{2}{i-j+1} +\r\n\\sum_{j=1}^{i}\\sum_{k=i}^n \\dfrac{2}{k-j+1}\\\\\r\n&amp;=2\\left(\\sum_{j=i+1}^{n-1}\\sum_{k=j+1}^n \\dfrac{1}{k-i+1} +\r\n\\sum_{j=1}^{i-2}\\sum_{k=j+1}^{i-1} \\dfrac{1}{i-j+1} +\r\n\\sum_{j=1}^{i}\\sum_{k=i}^n \\dfrac{1}{k-j+1}\\right)\\\\\r\n&amp;=2\\left(\\sum_{k=i+2}^{n}\\dfrac{k-i-1}{k-i+1} +\r\n\\sum_{j=1}^{i-2}\\dfrac{i-j-1}{i-j+1} + \\sum_{j=1}^{i}\\sum_{k=i}^n\r\n\\dfrac{1}{k-j+1}\\right)\\\\\r\n&amp;\\le 2\\left(\\sum_{k=i+1}^{n}\\dfrac{k-i-1}{k-i+1} +\r\n\\sum_{j=1}^{i-2}\\dfrac{i-j-1}{i-j+1} + \\sum_{j=1}^{i}\\sum_{k=i}^n\r\n\\dfrac{1}{k-j+1}\\right)\r\n\\end{aligned}\\)\r\nc\r\n由题目9-5-b的推导继续进行。\r\n\\(\\begin{aligned}\r\nE[X_i]&amp;\\le 2\\left(\\sum_{k=i+1}^{n}\\dfrac{k-i-1}{k-i+1} +\r\n\\sum_{j=1}^{i-2}\\dfrac{i-j-1}{i-j+1} + \\sum_{j=1}^{i}\\sum_{k=i}^n\r\n\\dfrac{1}{k-j+1}\\right)\\\\\r\n&amp;\\le 2\\left(\\sum_{k=i+1}^{n} 1 + \\sum_{j=1}^{i-2}1 +\r\n\\sum_{j=1}^{i}\\sum_{k=i}^n \\dfrac{1}{k-j+1}\\right)\\\\\r\n&amp;= 2\\left(n-2 + \\sum_{j=1}^{i}\\sum_{k=i}^n \\dfrac{1}{k-j+1}\\right)\\\\\r\n&amp;= 2\\left(n-2 + \\sum_{c=1}^n \\dfrac{1}{c}\\cdot\\sum_{1\\le j\\le i,i\\le\r\nj+c-1\\le n} 1\\right)\\\\\r\n&amp;\\le 2\\left(n-2 + \\sum_{c=1}^n \\dfrac{1}{c}\\cdot c\\right)\\\\\r\n&amp;\\le 2(n-2+n)\\\\\r\n&amp;\\le 4n\r\n\\end{aligned}\\)\r\nd\r\n算法RANDOMIZED-SELECT的整个过程是围绕子程序RANDOMIZED-PARTITION进行的，比较过程就在这个子程序中进行。\r\n根据题目9-5-c的结论，所有调用子程序RANDOMIZED-PARTITION的过程中，总期望比较次数不超过\\(4n\\)。因此算法RANDOMIZED-SELECT的时间复杂度为\\(O(n)\\)。\r\n9-6\r\n假设单个组的大小为\\(2k+1\\)，其中\\(k\\)是一个正整数，且是常数。\r\na\r\n此时意味着有前提条件：\\(k\\ge\r\n2\\).\r\n前11行代码，无非就是将所有为\\(5\\)的常量转化成\\(2k+1\\)。这一段的代码运行时间仍然为\\(\\Theta(n)\\)。\r\n第12-13行代码对每组\\(2k+1\\)个元素进行原地排序。由于每组内部元素数量相同，一共有\\(\\Theta(n)\\)组，这一段的运行时间仍然为\\(\\Theta(n)\\)。\r\n第16行对中间的一组再进行一次调用，产生了\\(T(n/(2k+1))\\)的开销。\r\n第17行对数组进行了一次划分，这一段的运行时间仍然为\\(\\Theta(n)\\)。\r\n总而言之，上面这部分算法内部开销的时间复杂度为\\(\\Theta(n)\\)。\r\n第20-24行递归进入所划分的区间。按照这种划分方法，可以知道，第16行中的\\(x\\)至少有\\(\\dfrac{n\\cdot\r\n(k+1)}{2\\cdot(2k+1)}=\\dfrac{k+1}{4k+2}n\\)个数比它大，至少有\\(\\dfrac{k+1}{4k+2}n\\)个数比它小。因此每次进行下一次递归时，至多可以去除\\(\\dfrac{k+1}{4k+2}n\\)个数。假设\\(T(n)\\)为对\\(n\\)个元素进行选择的运行时间，那么有\r\n\\[T(n)\\le\r\nT(n/(2k+1))+T((3k+1)n/(4k+2))+\\Theta(n)\\]\r\n使用代入法，假设\\(T(n)\\le\r\ncn\\)，那么有\r\n\\(\\begin{aligned}\r\nT(n)&amp;\\le T(n/(2k+1))+T((3k+1)n/(4k+2))+\\Theta(n)\\\\\r\n&amp;\\le \\dfrac{c}{2k+1} n+\\dfrac{c(3k+1)}{4k+2}n+\\Theta(n)\\\\\r\n&amp;=cn-\\dfrac{c(k-1)}{4k+2}n+\\Theta(n)\\\\\r\n&amp;\\le cn &amp;\\qquad(A)\r\n\\end{aligned}\\)\r\n其中，步骤\\((A)\\)假设了\\(c\\)足够大，以至于项\\(\\dfrac{c(k-1)}{4k+2}n\\)的渐进增长速度超过\\(\\Theta(n)\\)。并且，由于\\(k\\ge 2\\)，因此这个项是恒正的。\r\n因此有\\(T(n)=O(n)\\)。\r\n由于第17行对数组进行了一次\\(\\Theta(n)\\)的划分，因此说明\\(T(n)=\\Omega(n)\\)。\r\n因此最终有\\(T(n)=\\Theta(n)\\)。\r\nb\r\n此时意味着有前提条件：\\(k=1\\).\r\n那么\\(T(n)\\)可以写成\r\n\\[T(n)\\le\r\nT(n/3)+T(2n/3)+\\Theta(n)\\]\r\n由于\\(k=1\\)，项\\(\\dfrac{c(k-1)}{4k+2}n\\)的值恒为\\(0\\)，因此题目9-6-a的结论不适用。\r\n那么假设\\(T(n)\\le cn\\lg n\\)，有\r\n\\(\\begin{aligned}\r\nT(n)&amp;\\le T(n/3)+T(2n/3)+\\Theta(n)\\\\\r\n&amp;\\le \\dfrac{cn}{3} \\lg\\dfrac{cn}{3}+\\dfrac{2n}{3} \\lg\\dfrac{2n}{3}\r\n+\\Theta(n)\\\\\r\n&amp;=cn\\lg n-\\dfrac{c}{3}\\cdot \\lg \\dfrac{27}{4}\\cdot n + \\Theta(n)\\\\\r\n&amp;\\le cn\\lg n &amp;\\qquad(A)\r\n\\end{aligned}\\)\r\n其中，步骤\\((A)\\)假设了\\(c\\)足够大，以至于\\(\\dfrac{c}{3}\\cdot \\lg \\dfrac{27}{4}\\cdot\r\nn\\)的渐进增长速度超过\\(\\Theta(n)\\)。\r\n因此有\\(T(n)=O(n\\lg n)\\)。\r\nc\r\n前11行代码是为了调整整个数组的长度是\\(9\\)的倍数。\r\n第12-13行代码则是对组内的所有元素进行排序，每组有\\(3\\)个元素。排完序后的示意图如下：\r\n\r\n第16-17行代码则是对大组中的所有中位数再次进行排序，由于排序元素数量恒定为\\(3\\)个。排完序后的示意图如下：\r\n\r\n其中，蓝色区域表示比\\(x\\)小的数，黄色区域表示比\\(x\\)大的数。\r\n因此可以发现，整个序列可以划分成大小为\\(9\\)的组，也就是说一共有\\(\\dfrac{n}{9}\\)组。其中一半的大组至少有\\(4\\)个数比\\(x\\)小，一半的大组至少有\\(4\\)个数比\\(x\\)大。那么在每一次的划分过程中，我们可以排除掉至少\\(\\dfrac{n\\cdot 4}{2\\cdot\r\n9}=\\dfrac{2}{9}n\\)个数。\r\n由此继续进行划分下去，最终可以成功找到一个第\\(i\\)大的数。\r\nd\r\n第1行的while循环次数最多为\\(8\\)，内部嵌套的for循环长度为\\(\\Theta(n)\\)，因此前11行代码的运行时间为\\(\\Theta(n)\\)。\r\n第12-13行代码则是对组内的所有元素进行排序，由于排序元素数量恒定为\\(3\\)个，组数为\\(\\Theta(n)\\)。因此第12-13行代码的运行时间为\\(\\Theta(n)\\)。\r\n第16-17行代码则是对大组中的所有中位数再次进行排序，由于排序元素数量恒定为\\(3\\)个，大组的组数也是\\(\\Theta(n)\\)。因此第12-13行代码的运行时间为\\(\\Theta(n)\\)。\r\n第20行对中间的一个大组再进行一次调用，产生了\\(T(n/9)\\)的开销。\r\n第21行对数组进行了一次划分，这一段的运行时间仍然为\\(\\Theta(n)\\)。\r\n第23-28行递归进入所划分的区间。按照题目9-6-c的描述，这个开销最大为\\(T(7n/9)\\)。\r\n那么可以写出\\(T(n)\\)的递推关系式：\r\n\\[T(n)\\le\r\nT(n/9)+T(7n/9)+\\Theta(n)\\]\r\n进一步化简，有\r\n\\(\\begin{aligned}\r\nT(n)&amp;\\le T(n/9)+T(7n/9)+\\Theta(n)\\\\\r\n&amp;\\le cn/9+7cn/9+\\Theta(n)\\\\\r\n&amp;=cn-cn/9+\\Theta(n)\\\\\r\n&amp;\\le cn &amp;\\qquad(A)\r\n\\end{aligned}\\)\r\n其中，步骤\\((A)\\)假设了\\(c\\)足够大，以至于项\\(cn/9\\)的渐进增长速度超过\\(\\Theta(n)\\)。\r\n因此有\\(T(n)=O(n)\\)。\r\n","categories":["算法导论"]},{"title":"算法导论32.4 Exercises 答案","url":"/introduction-to-algorithms/chapter-32/exercises-4/","content":"\r\n32.4-1\r\n模式串\\(P=\\texttt{ababbabbabbababbabb}\\)的前缀数组为\\(\\pi=(0,0,1,2,0,1,2,0,1,2,0,1,2,3,4,5,6,7,8)\\)。\r\n32.4-2\r\n\\(\\pi^{\\ast}[q]\\)的大小可以达到\\(q-1\\)。以\\(m\\)个字符\\(\\texttt{a}\\)的模式串\\(P\\)为例，对于\\(\\forall\r\nq\\in[2,n],\\pi^{\\ast}[q]=\\{1,2,\\dots,q-1\\}\\)。因此集合\\(\\pi^{\\ast}[q]\\)的大小可以达到\\(q-1\\)。\r\n32.4-3\r\n可见，在\\(T\\)中出现\\(P\\)的有效偏移量集合为\\(\\{q-2m:\\pi[q]=m,q\\ge 2m\\}\\)。因为\\(P\\)被拼接在了前面，因此需要减去\\(P\\)已经占有的偏移量\\(m\\)。此外，还需要满足\\(q\\ge 2m\\)，以避免和字符串\\(P\\)有交叉。由于\\(\\pi\\)递增时，最多只会递增\\(1\\)，因此只需要考虑等于\\(m\\)的情况即可满足所有情况，而不需要考虑大于\\(m\\)的情况。\r\n32.4-4\r\n不失一般性，这里只考虑KMP-MATCHER的主体部分（因为COMPUTE-PREFIX-FUNCTION的分析方式和KMP-MATCHER一致）。\r\n按照定义，由于\\(r=\\pi[q]\\)是\\(P[:q]\\)中最长的真子前缀同时也是其后缀，因此\\(\\pi[q]&lt;q\\)。这意味着第4-5中的while循环执行一次\\(q\\)值就会减少。由于\\(q\\)不可能为负数，并且第3行的每轮for循环中，只有第7行才会对\\(q\\)增加（并且只增加\\(1\\)），因此第5行最多也只会执行\\(n\\)次。\r\n最终，第2-10行只需要\\(\\Theta(n)\\)的时间即可完成。第1行的COMPUTE-PREFIX-FUNCTION使用类似分析方式可以得到其运行时间为\\(\\Theta(m)\\)。由于\\(m\\le\r\nn\\)，因此KMP-MATCHER的时间复杂度为\\(\\Theta(m)+\\Theta(n)=\\Theta(n)\\)。\r\n32.4-5\r\n本题的分析框架和题目32.4-4的一样，只考虑KMP-MATCHER的主体部分。\r\n令势函数\\(\\Phi(D_i)\\)表示第\\(i\\)轮for循环结束后\\(q\\)的值。由于\\(q\\)的值在for循环开始前为\\(0\\)，因此有\\(\\Phi(D_0)=0\\)。\r\n令均摊开销\\(\\widehat{c_i}=c_i+\\Phi(D_i)-\\Phi(D_{i-1})\\)，其中\\(c_i\\)表示真实开销。那么有\\(\\displaystyle{\\sum_{i=1}^nc_i=\\sum_{i=1}^n\\widehat{c_i}-\\Phi(D_n)+\\Phi(D_0)}\\)。令每轮开销的均摊代价\\(\\widehat{c_i}=2\\)，那么有\r\n\\(\\begin{aligned}\r\n\\sum_{i=1}^nc_i&amp;=\\sum_{i=1}^n\\widehat{c_i}-\\Phi(D_n)+\\Phi(D_0)\\\\\r\n&amp;\\le \\sum_{i=1}^nc_i+\\Phi(D_0)\\\\\r\n&amp;\\le 2n\r\n\\end{aligned}\\)\r\n因此KMP-MATCHER的第2-10行只需要\\(\\Theta(n)\\)的时间即可完成。第1行的COMPUTE-PREFIX-FUNCTION使用类似分析方式可以得到其运行时间为\\(\\Theta(m)\\)。由于\\(m\\le\r\nn\\)，因此KMP-MATCHER的时间复杂度为\\(\\Theta(m)+\\Theta(n)=\\Theta(n)\\)。\r\n32.4-6\r\n按照题目给定的\\(\\pi&#39;\\)的定义，将KMP-MATCHER修改后的KMP-MATCHER'如下所示。\r\nCOMPUTE-PREFIX-FUNCTION&#x27;(P, m)  π = COMPUTE-PREFIX-FUNCTION(P, m)  Let π&#x27;[1 : m - 1] be a new array  for q = 1 to m - 1    if π[q] == 0      π&#x27;[q] = 0    else if π[q] != 0 and P[π[q] + 1] == P[q + 1]      π&#x27;[q] = π&#x27;[π[q]]    else      π&#x27;[q] = π[q]  return π, π&#x27;KMP-MATCHER&#x27;(T, P, n, m)  π, π&#x27; = COMPUTE-PREFIX-FUNCTION(P, m)  q = 0  for i = 1 to n    while q &gt; 0 and P[q + 1] != T[i]      q = π[q]    if P[q + 1] == T[i]      q = q + 1    if q == m      print &quot;Pattern occurs with shift&quot; i – m      q = π[q]\r\n接下来我们证明这个嵌套调用的\\(\\pi&#39;\\)是正确的。如果满足\\(\\pi&#39;\\)中定义的第一行和第三行的情况，那么就有\\(\\pi&#39;[q]=\\pi[q]\\)，这和KMP-MATCHER'执行第5行的过程完全一致。\r\n当满足\\(\\pi&#39;\\)的第二条情况时，即\\(P[q+1]=P[\\pi[q]+1]\\)，这种情况意味着在KMP-MATCHER'执行第5行的过程前后，都将会对\\(P[q+1]\\neq T[i]\\)和\\(P[\\pi [q]+1]\\neq\r\nT[i]\\)进行判断。由于字母相同，这两种判断是没有必要的，\\(\\pi&#39;\\)将会跳到下一个和\\(P[q+1]\\)不相同的字符\\(P[\\pi&#39; [q]+1]\\)再和\\(T[i]\\)进行比较。因此这个过程是正确的。\r\n\\(\\pi&#39;\\)数组的存在是一个对KMP-MATCHER的优化，但是它不会降低KMP-MATCHER的时间复杂度。只有当\\(T\\)的长度远大于\\(P\\)的长度时，\\(\\pi&#39;\\)数组会对KMP-MATCHER带来常数上的优化。\r\n# 32.4-7\r\n\\(T\\)是\\(T&#39;\\)的旋转串，当且仅当\\(T&#39;\\)出现在\\(TT\\)中。因此这相当于执行了一次KMP-MATCHER算法。具体过程由IS-CYCLIC-ROTATION给出。\r\nIS-CYCLIC-ROTATION(T, T&#x27;, m)  π = COMPUTE-PREFIX-FUNCTION(P, m)  q = 0  S = TT  for i = 1 to m + m    while q &gt; 0 and T[q + 1] != S[i]      q = π[q]    if T[q + 1] == S[i]      q = q + 1    if i &gt; m and q == m      print &quot;T&#x27; is T with shift&quot; i – m      q = π[q]\r\n\\(\\star\\)\r\n32.4-8\r\n基于KMP算法的\\(\\pi\\)数组计算转移函数\\(\\delta\\)的算法由COMPUTE-TRANSITION-FUNCTION-KMP所示。\r\nCOMPUTE-TRANSITION-FUNCTION-KMP(P, ∑, m)  π = COMPUTE-PREFIX-FUNCTION(P, m)  for each character a ∈ ∑    δ(0, a) = 0  δ(0, P[1]) = 1  for q = 1 to m    for each character a ∈ ∑      if q &lt; m and P[q + 1] == a        δ(q, a) = q + 1      else        δ(q, a) = δ(π[q], a)  return δ\r\n可见第2-4行对\\(\\delta(0,\\cdot)\\)处理的正确性是显而易见的，在一开始没有接受到任何字符时，只有接受到正确的字符\\(P[1]\\)时，才可以从状态\\(0\\)转移到状态\\(1\\)。第7-8行的处理同样也是显而易见的，遇到正确的字符那么就向前一个状态进位。\r\n接下来证明另一种情况，即第9-10行的情况。按照\\(\\delta\\)的定义，可见\\(\\delta(q,a)=\\sigma(P[:q]a)\\)，将\\(\\pi[q]\\)视为前面的\\(q\\)，也有\\(\\delta(\\pi[q],a)=\\sigma(P[:\\pi\r\n[q]]a)\\)。按照\\(\\pi\\)数组的定义，由于\\(P[: \\pi[q]]\\sqsupset P[:q]\\)，因此\\(P[:\\pi[q]]a\\sqsupset P[:q]a\\)，从而\\(\\sigma(P[:\\pi\r\n[q]]a)\\le\\sigma(P[:q]a)\\)。由于\\(\\pi[q]=\\sigma(P[:q])\\)，因此\\(P[:q]\\)后面添加一个字符\\(a\\)后，可以得到\\(\\pi[q]\\ge \\sigma(P[:q]a)-1\\)，因为\\(\\sigma\\)的函数值最多只会增加\\(1\\)，这意味着\\(\\sigma(P[:\\pi [q]]a)\\ge\r\n\\sigma(P[:q]a)\\)。\r\n因此，最终可以得到\\(\\sigma(P[:\\pi\r\n[q]]a)=\\sigma(P[:q]a)\\)，即\\(\\delta(\\pi[q],a)=\\delta(q,a)\\)，原结论成立。\r\n","categories":["算法导论"]},{"title":"算法导论32.5 Exercises 答案","url":"/introduction-to-algorithms/chapter-32/exercises-5/","content":"\r\n32.5-1\r\n如下两表，是分别执行完COMPUTE-SUFFIX-ARRAY的第2-7行和第8行后的结果。\r\n\\(\\begin{array}{ccccl}\r\ni&amp;left\\text{-}rank&amp;right\\text{-}rank&amp;index&amp;\\text{substring}\\\\\\hline\r\n1&amp;8&amp;9&amp;1&amp;\\texttt{hi}\\\\\r\n2&amp;9&amp;16&amp;2&amp;\\texttt{ip}\\\\\r\n3&amp;16&amp;16&amp;3&amp;\\texttt{pp}\\\\\r\n4&amp;16&amp;9&amp;4&amp;\\texttt{pi}\\\\\r\n5&amp;9&amp;20&amp;5&amp;\\texttt{it}\\\\\r\n6&amp;20&amp;25&amp;6&amp;\\texttt{ty}\\\\\r\n7&amp;25&amp;8&amp;7&amp;\\texttt{yh}\\\\\r\n8&amp;8&amp;15&amp;8&amp;\\texttt{ho}\\\\\r\n9&amp;15&amp;16&amp;9&amp;\\texttt{op}\\\\\r\n10&amp;16&amp;16&amp;10&amp;\\texttt{pp}\\\\\r\n11&amp;16&amp;9&amp;11&amp;\\texttt{pi}\\\\\r\n12&amp;9&amp;20&amp;12&amp;\\texttt{it}\\\\\r\n13&amp;20&amp;25&amp;13&amp;\\texttt{ty}\\\\\r\n14&amp;25&amp;0&amp;14&amp;\\texttt{y}\\\\\r\n\\end{array}\r\n\\qquad\r\n\\begin{array}{ccccl}\r\ni&amp;left\\text{-}rank&amp;right\\text{-}rank&amp;index&amp;\\text{substring}\\\\\\hline\r\n1&amp;8&amp;9&amp;1&amp;\\texttt{hi}\\\\\r\n2&amp;8&amp;15&amp;8&amp;\\texttt{ho}\\\\\r\n3&amp;9&amp;16&amp;2&amp;\\texttt{ip}\\\\\r\n4&amp;9&amp;20&amp;5&amp;\\texttt{it}\\\\\r\n5&amp;9&amp;20&amp;12&amp;\\texttt{it}\\\\\r\n6&amp;15&amp;16&amp;9&amp;\\texttt{op}\\\\\r\n7&amp;16&amp;9&amp;4&amp;\\texttt{pi}\\\\\r\n8&amp;16&amp;9&amp;11&amp;\\texttt{pi}\\\\\r\n9&amp;16&amp;16&amp;3&amp;\\texttt{pp}\\\\\r\n10&amp;16&amp;16&amp;10&amp;\\texttt{pp}\\\\\r\n11&amp;20&amp;25&amp;6&amp;\\texttt{ty}\\\\\r\n12&amp;20&amp;25&amp;13&amp;\\texttt{ty}\\\\\r\n13&amp;25&amp;0&amp;14&amp;\\texttt{y}\\\\\r\n14&amp;25&amp;8&amp;7&amp;\\texttt{yh}\\\\\r\n\\end{array}\\)\r\n当\\(l=2\\)时，分别执行完COMPUTE-SUFFIX-ARRAY的第11行，第12-17行和第18行的结果如下三个表所示。\r\n\\(\\begin{array}{ccl}\r\ni&amp;rank&amp;\\text{substring}\\\\\\hline\r\n1&amp;1&amp;\\texttt{hi}\\\\\r\n2&amp;3&amp;\\texttt{ip}\\\\\r\n3&amp;7&amp;\\texttt{pp}\\\\\r\n4&amp;6&amp;\\texttt{pi}\\\\\r\n5&amp;4&amp;\\texttt{it}\\\\\r\n6&amp;8&amp;\\texttt{ty}\\\\\r\n7&amp;10&amp;\\texttt{yh}\\\\\r\n8&amp;2&amp;\\texttt{ho}\\\\\r\n9&amp;5&amp;\\texttt{op}\\\\\r\n10&amp;7&amp;\\texttt{pp}\\\\\r\n11&amp;6&amp;\\texttt{pi}\\\\\r\n12&amp;4&amp;\\texttt{it}\\\\\r\n13&amp;8&amp;\\texttt{ty}\\\\\r\n14&amp;9&amp;\\texttt{y}\\\\\r\n\\end{array}\\qquad\r\n\\begin{array}{ccccl}\r\ni&amp;left\\text{-}rank&amp;right\\text{-}rank&amp;index&amp;\\text{substring}\\\\\\hline\r\n1&amp;1&amp;7&amp;1&amp;\\texttt{hipp}\\\\\r\n2&amp;3&amp;6&amp;2&amp;\\texttt{ippi}\\\\\r\n3&amp;7&amp;4&amp;3&amp;\\texttt{ppit}\\\\\r\n4&amp;6&amp;8&amp;4&amp;\\texttt{pity}\\\\\r\n5&amp;4&amp;10&amp;5&amp;\\texttt{ityh}\\\\\r\n6&amp;8&amp;2&amp;6&amp;\\texttt{tyho}\\\\\r\n7&amp;10&amp;5&amp;7&amp;\\texttt{yhop}\\\\\r\n8&amp;2&amp;7&amp;8&amp;\\texttt{hopp}\\\\\r\n9&amp;5&amp;6&amp;9&amp;\\texttt{oppi}\\\\\r\n10&amp;7&amp;4&amp;10&amp;\\texttt{ppit}\\\\\r\n11&amp;6&amp;8&amp;11&amp;\\texttt{pity}\\\\\r\n12&amp;4&amp;9&amp;12&amp;\\texttt{ity}\\\\\r\n13&amp;8&amp;0&amp;13&amp;\\texttt{ty}\\\\\r\n14&amp;9&amp;0&amp;14&amp;\\texttt{y}\\\\\r\n\\end{array}\\qquad\r\n\\begin{array}{ccccl}\r\ni&amp;left\\text{-}rank&amp;right\\text{-}rank&amp;index&amp;\\text{substring}\\\\\\hline\r\n1&amp;1&amp;7&amp;1&amp;\\texttt{hipp}\\\\\r\n2&amp;2&amp;7&amp;8&amp;\\texttt{hopp}\\\\\r\n3&amp;3&amp;6&amp;2&amp;\\texttt{ippi}\\\\\r\n4&amp;4&amp;9&amp;12&amp;\\texttt{ity}\\\\\r\n5&amp;4&amp;10&amp;5&amp;\\texttt{ityh}\\\\\r\n6&amp;5&amp;6&amp;9&amp;\\texttt{oppi}\\\\\r\n7&amp;6&amp;8&amp;4&amp;\\texttt{pity}\\\\\r\n8&amp;6&amp;8&amp;11&amp;\\texttt{pity}\\\\\r\n9&amp;7&amp;4&amp;3&amp;\\texttt{ppit}\\\\\r\n10&amp;7&amp;4&amp;10&amp;\\texttt{ppit}\\\\\r\n11&amp;8&amp;0&amp;13&amp;\\texttt{ty}\\\\\r\n12&amp;8&amp;2&amp;6&amp;\\texttt{tyho}\\\\\r\n13&amp;9&amp;0&amp;14&amp;\\texttt{y}\\\\\r\n14&amp;10&amp;5&amp;7&amp;\\texttt{yhop}\\\\\r\n\\end{array}\\)\r\n当\\(l=4\\)时，分别执行完COMPUTE-SUFFIX-ARRAY的第11行，第12-17行和第18行的结果如下三个表所示。\r\n\\(\\begin{array}{ccl}\r\ni&amp;rank&amp;\\text{substring}\\\\\\hline\r\n1&amp;1&amp;\\texttt{hipp}\\\\\r\n2&amp;3&amp;\\texttt{ippi}\\\\\r\n3&amp;8&amp;\\texttt{ppit}\\\\\r\n4&amp;7&amp;\\texttt{pity}\\\\\r\n5&amp;5&amp;\\texttt{ityh}\\\\\r\n6&amp;10&amp;\\texttt{tyho}\\\\\r\n7&amp;12&amp;\\texttt{yhop}\\\\\r\n8&amp;2&amp;\\texttt{hopp}\\\\\r\n9&amp;6&amp;\\texttt{oppi}\\\\\r\n10&amp;8&amp;\\texttt{ppit}\\\\\r\n11&amp;7&amp;\\texttt{pity}\\\\\r\n12&amp;4&amp;\\texttt{ity}\\\\\r\n13&amp;9&amp;\\texttt{ty}\\\\\r\n14&amp;11&amp;\\texttt{y}\\\\\r\n\\end{array}\\qquad\r\n\\begin{array}{ccccl}\r\ni&amp;left\\text{-}rank&amp;right\\text{-}rank&amp;index&amp;\\text{substring}\\\\\\hline\r\n1&amp;1&amp;5&amp;1&amp;\\texttt{hippityh}\\\\\r\n2&amp;3&amp;10&amp;2&amp;\\texttt{ippityho}\\\\\r\n3&amp;8&amp;12&amp;3&amp;\\texttt{ppityhop}\\\\\r\n4&amp;7&amp;2&amp;4&amp;\\texttt{pityhopp}\\\\\r\n5&amp;5&amp;6&amp;5&amp;\\texttt{ityhoppi}\\\\\r\n6&amp;10&amp;8&amp;6&amp;\\texttt{tyhoppit}\\\\\r\n7&amp;12&amp;7&amp;7&amp;\\texttt{yhoppity}\\\\\r\n8&amp;2&amp;4&amp;8&amp;\\texttt{hoppity}\\\\\r\n9&amp;6&amp;9&amp;9&amp;\\texttt{oppity}\\\\\r\n10&amp;8&amp;11&amp;10&amp;\\texttt{ppity}\\\\\r\n11&amp;7&amp;0&amp;11&amp;\\texttt{pity}\\\\\r\n12&amp;4&amp;0&amp;12&amp;\\texttt{ity}\\\\\r\n13&amp;9&amp;0&amp;13&amp;\\texttt{ty}\\\\\r\n14&amp;11&amp;0&amp;14&amp;\\texttt{y}\\\\\r\n\\end{array}\\qquad\r\n\\begin{array}{ccccl}\r\ni&amp;left\\text{-}rank&amp;right\\text{-}rank&amp;index&amp;\\text{substring}\\\\\\hline\r\n1&amp;1&amp;5&amp;1&amp;\\texttt{hippityh}\\\\\r\n2&amp;2&amp;4&amp;8&amp;\\texttt{hoppity}\\\\\r\n3&amp;3&amp;10&amp;2&amp;\\texttt{ippityho}\\\\\r\n4&amp;4&amp;0&amp;12&amp;\\texttt{ity}\\\\\r\n5&amp;5&amp;6&amp;5&amp;\\texttt{ityhoppi}\\\\\r\n6&amp;6&amp;9&amp;9&amp;\\texttt{oppity}\\\\\r\n7&amp;7&amp;0&amp;11&amp;\\texttt{pity}\\\\\r\n8&amp;7&amp;2&amp;4&amp;\\texttt{pityhopp}\\\\\r\n9&amp;8&amp;11&amp;10&amp;\\texttt{ppity}\\\\\r\n10&amp;8&amp;12&amp;3&amp;\\texttt{ppityhop}\\\\\r\n11&amp;9&amp;0&amp;13&amp;\\texttt{ty}\\\\\r\n12&amp;10&amp;8&amp;6&amp;\\texttt{tyhoppit}\\\\\r\n13&amp;11&amp;0&amp;14&amp;\\texttt{y}\\\\\r\n14&amp;12&amp;7&amp;7&amp;\\texttt{yhoppity}\\\\\r\n\\end{array}\\)\r\n当\\(l=8\\)时，分别执行完COMPUTE-SUFFIX-ARRAY的第11行，第12-17行和第18行的结果如下三个表所示。\r\n\\(\\begin{array}{ccl}\r\ni&amp;rank&amp;\\text{substring}\\\\\\hline\r\n1&amp;1&amp;\\texttt{hippityh}\\\\\r\n2&amp;3&amp;\\texttt{ippityho}\\\\\r\n3&amp;10&amp;\\texttt{ppityhop}\\\\\r\n4&amp;8&amp;\\texttt{pityhopp}\\\\\r\n5&amp;5&amp;\\texttt{ityhoppi}\\\\\r\n6&amp;12&amp;\\texttt{tyhoppit}\\\\\r\n7&amp;14&amp;\\texttt{yhoppity}\\\\\r\n8&amp;2&amp;\\texttt{hoppity}\\\\\r\n9&amp;6&amp;\\texttt{oppity}\\\\\r\n10&amp;9&amp;\\texttt{ppity}\\\\\r\n11&amp;7&amp;\\texttt{pity}\\\\\r\n12&amp;4&amp;\\texttt{ity}\\\\\r\n13&amp;11&amp;\\texttt{ty}\\\\\r\n14&amp;13&amp;\\texttt{y}\\\\\r\n\\end{array}\\qquad\\begin{array}{ccccl}\r\ni&amp;left\\text{-}rank&amp;right\\text{-}rank&amp;index&amp;\\text{substring}\\\\\\hline\r\n1&amp;1&amp;6&amp;1&amp;\\texttt{hippityhoppity}\\\\\r\n2&amp;3&amp;9&amp;2&amp;\\texttt{ippityhoppity}\\\\\r\n3&amp;10&amp;7&amp;3&amp;\\texttt{ppityhoppity}\\\\\r\n4&amp;8&amp;4&amp;4&amp;\\texttt{pityhoppity}\\\\\r\n5&amp;5&amp;11&amp;5&amp;\\texttt{ityhoppity}\\\\\r\n6&amp;12&amp;13&amp;6&amp;\\texttt{tyhoppity}\\\\\r\n7&amp;14&amp;0&amp;7&amp;\\texttt{yhoppity}\\\\\r\n8&amp;2&amp;0&amp;8&amp;\\texttt{hoppity}\\\\\r\n9&amp;6&amp;0&amp;9&amp;\\texttt{oppity}\\\\\r\n10&amp;9&amp;0&amp;10&amp;\\texttt{ppity}\\\\\r\n11&amp;7&amp;0&amp;11&amp;\\texttt{pity}\\\\\r\n12&amp;4&amp;0&amp;12&amp;\\texttt{ity}\\\\\r\n13&amp;11&amp;0&amp;13&amp;\\texttt{ty}\\\\\r\n14&amp;13&amp;0&amp;14&amp;\\texttt{y}\\\\\r\n\\end{array}\\qquad\\begin{array}{ccccl}\r\ni&amp;left\\text{-}rank&amp;right\\text{-}rank&amp;index&amp;\\text{substring}\\\\\\hline\r\n1&amp;1&amp;6&amp;1&amp;\\texttt{hippityhoppity}\\\\\r\n2&amp;2&amp;0&amp;8&amp;\\texttt{hoppity}\\\\\r\n3&amp;3&amp;9&amp;2&amp;\\texttt{ippityhoppity}\\\\\r\n4&amp;4&amp;0&amp;12&amp;\\texttt{ity}\\\\\r\n5&amp;5&amp;11&amp;5&amp;\\texttt{ityhoppity}\\\\\r\n6&amp;6&amp;0&amp;9&amp;\\texttt{oppity}\\\\\r\n7&amp;7&amp;0&amp;11&amp;\\texttt{pity}\\\\\r\n8&amp;8&amp;4&amp;4&amp;\\texttt{pityhoppity}\\\\\r\n9&amp;9&amp;0&amp;10&amp;\\texttt{ppity}\\\\\r\n10&amp;10&amp;7&amp;3&amp;\\texttt{ppityhoppity}\\\\\r\n11&amp;11&amp;0&amp;13&amp;\\texttt{ty}\\\\\r\n12&amp;12&amp;13&amp;6&amp;\\texttt{tyhoppity}\\\\\r\n13&amp;13&amp;0&amp;14&amp;\\texttt{y}\\\\\r\n14&amp;14&amp;0&amp;7&amp;\\texttt{yhoppity}\\\\\r\n\\end{array}\\)\r\n因此，得到的\\(SA\\)数组为\\([1,8,2,12,5,9,11,4,10,3,13,6,14,7]\\)。\r\n最终，按序填入\\(LCP\\)数组的顺序如下表所示：\r\n\\(\\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}\\hline\r\ni&amp;1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8&amp;9&amp;10&amp;11&amp;12&amp;13&amp;14\\\\\\hline\r\ns&amp;1&amp;3&amp;10&amp;8&amp;5&amp;12&amp;14&amp;2&amp;6&amp;9&amp;7&amp;4&amp;11&amp;13\\\\\\hline\r\nLCP[i]&amp;0&amp;0&amp;5&amp;4&amp;3&amp;2&amp;1&amp;1&amp;0&amp;1&amp;0&amp;1&amp;0&amp;0\\\\\\hline\r\n\\end{array}\\)\r\n因此，得到的\\(LCP\\)数组为\\([0,1,0,1,3,0,0,4,1,5,0,2,0,1]\\)。\r\n32.5-2\r\n基本思想是，如果不需要\\(\\lfloor\\lg\r\nn\\rfloor-1\\)次while循环就能够区分出所有后缀的排名，那么while循环可以提前终止。\r\n具体细节是，在MAKE-RANKS的过程中，如果最后一名的后缀的排名已经恰好达到了\\(n\\)，那么可以终止while循环。修改狗的算法由COMPUTE-SUFFIX-ARRAY'给出。\r\nCOMPUTE-SUFFIX-ARRAY&#x27;(T, n)  allocate arrays substr-rank[1:n], rank[1:n], and SA[1:n]  for i = 1 to n    substr-rank[i].left-rank = ord(T[i])    if i &lt; n      substr-rank[i].right-rank = ord(T[i + 1])    else substr-rank[i].right-rank = 0    substr-rank[i].index = i  sort the array substr-rank into monotonically increasing order based on the left-rank attributes, using the right-rank attributes to break ties; if still a tie, the order does not matter  l = 2  while l &lt; n    MAKE-RANKS(substr-rank, rank, n)    for i = 1 to n      substr-rank[i].left-rank = rank[i]      if i + l ≤ n        substr-rank[i].right-rank = rank[i + l]      else substr-rank[i].right-rank = 0      substr-rank[i].index = i    sort the array substr-rank into monotonically increasing order based on the left-rank attributes, using the right-rank attributes to break ties; if still a tie, the order does not matter    l = 2 * l  for i = 1 to n    SA[i] = substr-rank[i].index  return SA\r\n32.5-3\r\n使用一个不曾出现在\\(T_1,T_2\\)中的字符\\(\\texttt{@}\\)，并将其和\\(T_1,T_2\\)拼接起来，得到\\(T=T_1\\texttt{@}T_2\\)，其长度为\\(n=n_1+n_2+1\\)。对字符串\\(T\\)求出它的SA数组和LCP数组后，枚举\\(T\\)中每对排名相邻的后缀\\(SA[i],SA[i-1]\\)。如果这两个后缀来自\\(T\\)的不同部分（也就是其中一个来自\\(T_1\\)，另一个来自\\(T_2\\)）那么说明这两个后缀的最长公共前缀为\\(T_1,T_2\\)这两个字符串的子串之一，由于\\(\\texttt{@}\\)不在\\(T_1\\)中，因此可以确保\\(LCP\\)不会恰好经过\\(\\texttt{@}\\)。具体过程由程序LONGEST-COMMON-SUBSTRINGS给出。\r\nLONGEST-COMMON-SUBSTRINGS(T1, T2, n1, n2)  T = T1 @ T2  n = n1 + n2 + 1  SA = COMPUTE-SUFFIX-ARRAY(T, n)  LCP = COMPUTE-LCP(T, SA, n)  len = 0  S = ∅  for i = 2 to n    l = SA[i - 1]    r = SA[i]    if min&#123;l, r&#125; &lt;= n1 and max(l, r) &gt; n1 + 1      if LCP[i] &gt; len        len = LCP[i]        S = &#123;min&#123;l, r&#125;&#125;    else if lCP[i] == len        S = S ∪ &#123;min&#123;l, r&#125;&#125;  let string-list be a new array  for l in S    INSERT(string-list, T1[l : l + len - 1])  return string-list\r\n32.5-4\r\n这里首先需要解释一下这个约束\\(SA[i-1]=n&#39;-SA[i]-LCP[i]+2\\)是怎么来的：\r\n首先，\\(T\\)中有一个子串\\([l,r]\\)是回文串，那么在\\(T&#39;\\)这个字符串中，其在后半段对应的位置中是\\([l&#39;,r&#39;]\\)。这意味着\\(r-l+1=r&#39;-l&#39;+1=\\text{len}\\)，由于\\(T&#39;\\)的最后\\(n\\)个字符是由\\(T\\)反转而来，并且字符\\(\\texttt{@}\\)处在下标\\(\\dfrac{n&#39;+1}{2}\\)中，因此有\\(\\dfrac{n&#39;+1}{2}-r=l&#39;-\\dfrac{n&#39;+1}{2}\\)。最终联立上面两个式子可以得到\\(n&#39;+1=l&#39;+l+\\text{len}-1\\)，更进一步可以得到\\(l&#39;=n&#39;-l-\\text{len}+2\\)，和上面给定的约束很像。\r\n因此，这个求解最长回文子串的算法的错误在于，它认为后缀\\(T[l:]\\)和\\(T[l&#39;:]\\)在\\(SA\\)数组中是相邻的，然而并非如此。\r\n考虑字符串\\(T=\\texttt{abbcabb}\\)，那么有\\(T&#39;=\\texttt{abbcabb@bbacbba}\\)。等算法结束后，我们可以得到关于这个字符串的表格：\r\n\\(\\begin{array}{cclc}\r\ni&amp;SA[i]&amp;\\text{substring}&amp;LCP[i]&amp;SA[i-1]=n&#39;-SA[i]-LCP[i]+2\\\\\\hline\r\n1&amp;8&amp;\\texttt{@bbacbba}&amp;0&amp;\\text{No}\\\\\r\n2&amp;15&amp;\\texttt{a}&amp;0&amp;\\text{No}\\\\\r\n3&amp;5&amp;\\texttt{abb@bbacbba}&amp;1&amp;\\text{No}\\\\\r\n4&amp;1&amp;\\texttt{abbcabb@bbacbba}&amp;3&amp;\\text{No}\\\\\r\n5&amp;11&amp;\\texttt{acbba}&amp;1&amp;\\text{No}\\\\\r\n6&amp;7&amp;\\texttt{b@bbacbba}&amp;0&amp;\\text{No}\\\\\r\n7&amp;14&amp;\\texttt{ba}&amp;1&amp;\\text{No}\\\\\r\n8&amp;10&amp;\\texttt{bacbba}&amp;2&amp;\\text{No}\\\\\r\n9&amp;6&amp;\\texttt{bb@bbacbba}&amp;1&amp;\\text{Yes}\\\\\r\n10&amp;13&amp;\\texttt{bba}&amp;2&amp;\\text{No}\\\\\r\n11&amp;9&amp;\\texttt{bbacbba}&amp;3&amp;\\text{No}\\\\\r\n12&amp;2&amp;\\texttt{bbcabb@bbacbba}&amp;2&amp;\\text{No}\\\\\r\n13&amp;3&amp;\\texttt{bcabb@bbacbba}&amp;1&amp;\\text{No}\\\\\r\n14&amp;4&amp;\\texttt{cabb@bbacbba}&amp;0&amp;\\text{No}\\\\\r\n15&amp;12&amp;\\texttt{cbba}&amp;1&amp;\\text{Yes}\\\\\r\n\\end{array}\\)\r\n由表格可知这个算法的输出结果为\\(1\\)，但是实际上答案为\\(2\\)。\\(T\\)一共有两个子串\\(\\texttt{bb}\\)满足答案。其中一对\\(\\texttt{bb}\\)及其在后半段的反转分别是\\(T&#39;[2:3],T&#39;[13:14]\\)，但是在\\(SA\\)数组中，\\(2\\)和\\(13\\)不相邻。同样的，另一对\\(\\texttt{bb}\\)则及其反转分别是在\\(T&#39;[6:7],T&#39;[9:10]\\)，但是在\\(SA\\)数组中，\\(6\\)和\\(10\\)不相邻。\r\n最终是因为约束\\(SA[i-1]=n&#39;-SA[i]-LCP[i]+2\\)认为后缀\\(T[l:]\\)和\\(T[l&#39;:]\\)在\\(SA\\)数组中是相邻的，导致了错误。因此这个约束不正确。\r\n","categories":["算法导论"]},{"title":"算法导论32.3 Exercises 答案","url":"/introduction-to-algorithms/chapter-32/exercises-3/","content":"\r\n32.3-1\r\n本题的状态集合\\(Q=\\{0,1,2,3,4,5\\}\\)，起始状态\\(q_0=0\\)，接受状态为\\(\\{5\\}\\)。\r\n针对模式串\\(P=\\texttt{aabab}\\)在字符集\\(\\Sigma=\\{a,b\\}\\)上的状态函数\\(\\delta(s,c)\\)如下表所示。\r\n\\(\\begin{array}{|c|c|c|c|c|c|c|}\\hline\r\ns&amp;0&amp;1&amp;2&amp;3&amp;4&amp;5\\\\\\hline\r\n\\texttt{a}&amp;1&amp;2&amp;2&amp;4&amp;2&amp;1\\\\\\hline\r\n\\texttt{b}&amp;0&amp;0&amp;3&amp;0&amp;5&amp;0\\\\\\hline\r\n\\end{array}\\)\r\n由此，对于文本串\\(T=\\texttt{aaababaabaababaab}\\)，它的状态转移序列为\\(0,1,2,2,3,4,5,1,2,3,4,2,3,4,5,1,2,3\\)，由此\\(P\\)在\\(T\\)中出现了两次，分别为偏移量为\\(1\\)和\\(9\\)时出现。\r\n32.3-2\r\n本题的状态集合\\(Q=\\{0,1,2,3,\\dots,20,21\\}\\)，起始状态\\(q_0=0\\)，接受状态为\\(\\{21\\}\\)。\r\n针对模式串\\(P=\\texttt{ababbabbababbababbabb}\\)在字符集\\(\\Sigma=\\{a,b\\}\\)上的状态函数\\(\\delta(s,c)\\)如下表所示。\r\n\\(\\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}\\hline\r\ns&amp;0&amp;1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8&amp;9&amp;10&amp;11&amp;12&amp;13&amp;14&amp;15&amp;16&amp;17&amp;18&amp;19&amp;20&amp;21\\\\\\hline\r\n\\texttt{a}&amp;1&amp;1&amp;3&amp;1&amp;3&amp;6&amp;1&amp;3&amp;9&amp;1&amp;11&amp;1&amp;3&amp;14&amp;1&amp;16&amp;1&amp;3&amp;19&amp;1&amp;3&amp;9\\\\\\hline\r\n\\texttt{b}&amp;0&amp;2&amp;0&amp;4&amp;5&amp;0&amp;7&amp;8&amp;0&amp;10&amp;0&amp;12&amp;13&amp;0&amp;15&amp;8&amp;17&amp;18&amp;0&amp;20&amp;21&amp;0\\\\\\hline\r\n\\end{array}\\)\r\n32.3-3\r\n假设\\(P\\)的长度为\\(m\\)。\\(P[:k]\\sqsupset P[:q]\\)推导出\\(k=0\\lor\r\nk=q\\)意味着这个字符串只要产生了一次失配，那么就必须从头开始匹配，这意味着任何不以\\(P[1]\\)为开头的字符串是\\(P\\)的一个前缀，因此，这种模式串一般是\\(\\forall i\\in[2,n],P[1]\\neq P[i]\\)成立。\r\n对于这种模式串，它的状态转移函数\\(\\delta(s,c)(s\\in[0,m],c\\in\\Sigma)\\)如下：\r\n\\(\\delta(s,c)=\r\n\\left \\{\\begin{aligned}\r\n  &amp;0 &amp; &amp; \\text{if}\\quad  s=m\\lor s&lt;m \\land P[s+1]\\neq c\r\n\\\\\r\n  &amp;s+1 &amp; &amp; \\text{if}\\quad  s&lt;c\\land P[s+1]=c \\\\\r\n\\end{aligned}\\right.\\)\r\n32.3-4\r\n由于\\(x\\sqsupset y\\)，因此有\\(|x|\\le |y|\\)。又因为\\(x,y\\)同为\\(P\\)的前缀，因此有\\(x\\sqsubset y\\)。\r\n按照\\(\\sigma\\)的定义，有\\(\\sigma(x)= |x|\\)。但是因为\\(x\\sqsubset y,x\\sqsupset y\\)，因此\\(\\sigma(y)\\ge |x|\\)。最终有\\(\\sigma(x)\\le \\sigma(y)\\)。\r\n32.3-5\r\n最少的状态数即为合并\\(P\\)和\\(P&#39;\\)的最长公共前缀作为共同状态。更一般的说，令\\(P\\)和\\(P&#39;\\)的最长公共前缀的状态为\\(r=\\max\\{i:P[:i]=P&#39;[:i]\\}\\)，那么一共有\\(|P|+|P&#39;|-r-1\\)个状态，直到第\\(r\\)个字符之后，状态才会被分开。具体构建过程由COMPUTE-TRANSITION-FUNCTION'给出。\r\nCOMPUTE-TRANSITION-FUNCTION&#x27;(P, m, P&#x27;, m&#x27;, ∑)  r = 0  while k &lt; m amd k &lt; m&#x27; and P[r + 1] == P&#x27;[r + 1]    r += 1  for q = 0 to m    for each character a ∈ ∑      k = min &#123;m, q + 1&#125;    while P[:k] is not a suffix of P[:q]a      k = k – 1      δ(q, a) = k  for each q = r + 1 to m&#x27;    for each character a ∈ ∑      k = min &#123;m, q + 1&#125;    while P&#x27;[:k] is not a suffix of P&#x27;[:q]a      k = k – 1    if k &lt;= r      δ(q + m, a) = k    else      δ(q + m, a) = m + k  return δ\r\n32.3-6\r\n对于包含通配符\\(\\Diamond\\)的一个模式串\\(P\\)，假设我们将其划分成切割成一个个不包含通配符\\(\\Diamond\\)的模式串\\(P_1,P_2,\\dots,P_k\\)，那么将这些状态进行“首尾相接”即可，因为只要进行到当前的模式串\\(P_i\\)，那么就不能转移到以前的模式串。可见将会一共有\\(|P|+1\\)个状态。\r\n具体过程由COMPUTE-TRANSITION-FUNCTION-GAP给出。\r\nCOMPUTE-TRANSITION-FUNCTION-GAP(P, ∑, m)  split P into Q[1], Q[2], ..., Q[k] by &#x27;◊&#x27;  pre = 0  for i = 1 to k    δt = COMPUTE-TRANSITION-FUNCTION-GAP(Q[i], ∑, |Q[i]|)    for s = 0 to |Q[i]|      for each character a ∈ ∑        δ(pre + s, a) = δt(s, a)    pre = pre + |Q[i]|  return δ\r\n","categories":["算法导论"]},{"title":"算法导论32 Problems 答案","url":"/introduction-to-algorithms/chapter-32/problems/","content":"\r\n32-1\r\na\r\n首先使用 KMP 算法计算出\\(\\pi\\)数组，分两种情况进行考虑：\r\n\r\n如果\\(i\\bmod\r\n(i-\\pi[i])=0\\)，那么有\\(\\rho(P[:i])=\\dfrac{i}{i-\\pi[i]}\\)，这意味\\(P[i-\\pi[i]+1:i]=P[1:\\pi[i]]\\)，那也就是说，\\(P[\\pi[i]+1:2\\pi[i]]=P[1,\\pi[i]]\\)，类似的，有\\(P[i-2\\pi [i]+1:i]=P[i-\\pi\r\n[i]+1:i]\\)，最终多次迭代下去，可以发现这是一个周期为\\(\\dfrac{i}{i-\\pi[i]}\\)的字符串，此外，由于\\(\\forall k\\in \\pi^{\\ast}[i]\\)，都有\\(k\\le \\pi[i]\\)，因此\\(i-\\pi[i]\\)是\\(i\\)满足条件的最小因子，它将使值\\(\\dfrac{i}{i-k}\\)达到最大，因此原结论成立。\r\n如果\\(i\\bmod (i-\\pi[i])\\neq\r\n0\\)，那么\\(\\rho(P[:i])=1\\)。因为，对于一个非周期字符串\\(s\\)（如果是周期字符串，那么可以归约到最小非周期字符串），如果存在一个正整数\\(r\\)满足\\(s^r=P[i]\\)，那么有\\(r\\mid i\\)。然而按照上面的方式依次取出\\(r\\)个字母，它们不能取完整，因此这时\\(P[:i]\\)只能由自身拼接\\(1\\)次而成，原结论成立。\r\n\r\n算法COMPUTE-PREFIX-RHO给出了具体过程，可见其时间复杂度为\\(O(n)\\)。\r\nCOMPUTE-PREFIX-RHO(P, m)  π = COMPUTE-PREFIX-FUNCTION(P, m)  let ρ[1 : m] be a new array  for i = 1 to m    if i % (i - π[i]) == 0      ρ[i] = i / (i - π[i])    else      ρ[i] = 1  return ρ\r\nb\r\n待研究，相关链接：\r\n\r\n该算法相关的论文\r\n相关数列 1\r\n相关数列 2\r\n\r\nc\r\n同题目 32-1-b。\r\n32-2\r\na\r\n假设目前需要对比\\(P\\)中非空后缀\\(i\\)和\\(j\\)，令\\(P[i]\\)表示\\(P\\)的第\\(i\\)个元字符。如下考虑多种情况：\r\n\r\n如果\\(P[i]\\neq\r\nP[j]\\)，那么第\\(i\\)个非空后缀和第\\(j\\)个非空后缀的字典序由\\(P[i]\\)和\\(P[j]\\)决定，此时和\\(P[i],P[j]\\)后面的字符没有任何关系，因此原结论成立。\r\n如果\\(P[i]=P[j]\\)，考虑\\(i,j\\)都在\\(P\\)中\\(P_1\\)所占有的下标。可见，由于\\(P_1[i:]\\varnothing\\)和\\(P_1[j:]\\varnothing\\)的长度不同，并且最后一个字符\\(\\varnothing\\)都小于已经出现的字符，因此它们的字典序已经确定。此时再在独立的字符串\\(P_1[i:]\\varnothing,P_1[j:]\\varnothing\\)后面再添加字符也不会改变\\(P_1[i:]\\varnothing\\)和\\(P_1[j:]\\)的字典序。因此原结论成立。接下来考虑\\(i,j\\)都在\\(P\\)中\\(P_2\\)所占有的下标，明显原结论成立，因为这些后缀恰好是\\(P_2\\)的后缀。\r\n如果\\(P[i]=P[j]\\)，考虑\\(i,j\\)在\\(P\\)中，其中一个在\\(P_1\\)所占有的下标，另一个在\\(P_2\\)所占有的下标。不失一般性，假设\\(i\\)属于前者，\\(j\\)属于后者，那么不难得到\\(i&lt;j\\)。由于此时\\(P[i]=P[j]\\)，因此我们继续向下找下一个下标，直到满足这两个元字符不相同，即最小的正整数\\(s\\)，使得\\(P[i+s]\\neq P[j+s]\\)。可以发现\\(i+s\\)仍会在\\(P_1\\)占有的下标中。按照步骤 A 的作用，\\(P_1\\)必定会包含一个出现\\(\\varnothing\\)的元字符，因此第\\(i\\)个非空后缀不晚于这个元字符结束。由于\\(n&#39;\\not\\equiv n&#39;&#39;\\pmod\r\n3\\)，因此\\(i\\)个非空后缀和第\\(j\\)个非空后缀必定是以不同数量的\\(\\varnothing\\)元字符作为结尾，此外由于\\(\\varnothing\\)的字典序最小，再在它们的后面任意添加字符也不会改变这两个非空后缀的字典序，因此原结论成立。\r\n\r\n因此，\\(P\\)的非空后缀的排名和\\(P\\)的后缀排名是相同的。由于早在\\(\\varnothing\\)的时候就已经确定了排名，去除\\(\\varnothing\\)后面的字符并不影响后缀的排名，因此\\(P\\)中的后缀排名和\\(T\\)的采样后缀的相对排名是一致的，因此原结论成立。\r\nb\r\n由于每个元字符都恰好是一个三元组，因此我们可以使用基数排序完成，只需要进行三趟。由于字符的大小有限，因此每趟基数排序的内部使用计数排序，最终可以在\\(\\Theta(n)\\)的时间内完成这个排序过程。需要注意的是，由于前面的字符占主导地位，因此基数排序过程是对这些三元组中的每个字符从后往前进行。如下算法SA-SORT-CHARACTERS给出了这个过程，可见其时间复杂度为\\(\\Theta(n)\\)。\r\n// 假设字符出P中的每个字符用三元组(s[1], s[2], s[3])表示，分别表示元字符中的第一、第二和第三个字符。SA-SORT-CHARACTERS(P, n)  // L数组中的元素有两个属性：s属性是对应下标的元字符，index属性表示当前字符的下标。  let L[1 : n], L&#x27;[1 : n], P&#x27;[1 : n] be new arrays  for i = 1 to n    L[i].index = i    L[i].s = P[i].s  mx = 0  // 这里使用mx表示元字符中，所有内部字符的最大大小。  for i = 1 to n    mx = max&#123;mx, P[i].s[1], P[i].s[2], P[i].s[3]&#125;  let cnt[0 : mx] be a new array  for d = 3 downto 1    for j = 0 to mx      cnt[j] = 0    for i = 1 to n      cnt[L[i].s[d]] = cnt[L[i].s[d]] + 1    for j = 1 to mx      cnt[j] = cnt[j - 1] + cnt[j]    for i = n downto 1      L&#x27;[cnt[L[i].s[d]]] = L[i]      cnt[L[i].s[d]] = cnt[L[i].s[d]] - 1    L = L&#x27;  r = 1  P&#x27;[L[1].index] = 1  for i = 2 to n    if L[i].s != L[i - 1].s      r = r + 1    P&#x27;[L[i].index] = r  return P&#x27;\r\nc\r\n假设后缀\\(P[i:]\\)是非采样后缀，那么有\\(r_i=\\square,r_{i+1}\\)是一个非负整数。如果\\(r_i\\neq \\square\\)，那么说明\\(r_i\\)是进行递归后，对应采样后缀的排名，因此这些\\(r_i\\)是非负整数的情况下是唯一的，因此这使得二元组\\((T[i],r_{i+1})\\)是唯一的。\r\n由于原字符\\(T[i]\\)的范围非常小，因此我们同样可以使用题目\r\n32-2-b\r\n的思路，使用基数排序（每趟内部使用计数排序）对这些二元组进行排序。如下算法SA-SORT-CHARACTERS给出了这个过程，可见其时间复杂度为\\(\\Theta(n)\\)。\r\nSA-SORT-NONSAMPLE-SUFFIXES(T, r, n)  n&#x27; = ⌊n / 3⌋  let L[1 : n&#x27;], L&#x27;[1 : n&#x27;], nonsapmle[1 : n&#x27;] be new arrays  for i = 3 to n by 3    let L[i / 3].t[1 : 2] be a new array    L[i / 3].t[1] = T[i]    L[i / 3].t[2] = r[i + 1]    L[i / 3].index = i  mx = 0  // 这里使用mx表示元字符中，所有字符的大小。  for i = 1 to n&#x27;    mx = max&#123;mx, L[i].t[1], L[i].t[2]&#125;  let cnt[0 : mx] be a new array  for d = 2 downto 1    for j = 0 to mx      cnt[j] = 0    for i = 1 to n&#x27;      cnt[L[i].t[d]] = cnt[L[i].t[d]] + 1    for j = 1 to mx      cnt[j] = cnt[j - 1] + cnt[j]    for i = n&#x27; downto 1      L&#x27;[cnt[L[i].s[d]]] = L[i]      cnt[L[i].s[d]] = cnt[L[i].s[d]] - 1    L = L&#x27;  return L\r\nd\r\n假设字符串\\(T\\)后面已经拼接了两个\\(\\varnothing\\)，对应到\\(r\\)数组中其值为\\(0\\)，也就是说，字符串\\(T\\)现在的长度为\\(n+2\\)。\r\n其基本思想是，对于任意一对下标\\(i,j(i\\not\\equiv j\\pmod 3,1\\le i,j\\le\r\nn)\\)，只要最多比较三次就能比较出字典序。也就是说，只要比对\\((P[i],P[j]),(P[i+1],P[j+1]),(P[i+2],P[j+2])\\)即可。可以发现，必定存在最小的\\(s(0\\le s\\le 2)\\)，使得\\(r_{i+s}\\neq\\square\\land\r\nr_{j+s}\\neq\\square\\)。\r\n具体过程由SA-SORT-MERGE给出，它将原有的\\(r\\)数组以及题目 32-2-d\r\n所排好序的二元组进行归并，返回最终得到的\\(SA\\)数组。最终这个过程在\\(\\Theta(n)\\)的时间内完成。\r\n// 字符串T的长度为n+2，包括后面已经拼接了两个∅，r[n + 1] = r[n + 2] = 0。// 数组r如题意所示。// 数组nonsample是已经排好序的非采样后缀的下标，保证其大小为⌊n / 3⌋。SA-SORT-MERGE(T, r, nonsample, n)  n&#x27; = ⌊n / 3⌋  sample-choice = 1  nonsample-choice = 2  let sample[1 : n - n&#x27;] be a new array  for i = 1 to n    if i % 3 != 0      sample[r[i]] = i  let SA[1 : n] be a new array  ls = 1  ln = 1  k = 1  while ls &lt;= n - n&#x27; and ln &lt;= n&#x27;    p = sample[ls]    q = nonsample[ln]    if T[p] != T[q]      if T[p] &lt; T[q]        choice = sample-choice      else        choice = nonsample-choice    else if p % 3 == 1      // 此时r[p + 1] != □必定成立      if r[p + 1] &lt; r[q + 1]        choice = sample-choice      else        choice = nonsample-choice    else      // 此时r[p + 1] != □必定成立      if T[p + 1] &lt; T[q + 1] or T[p + 1] == T[q + 1] and r[p + 2] &lt; r[q + 2]        choice = sample-choice      else        choice = nonsample-choice    if choice == sample-choice      SA[k] = p      k = k + 1      ls = ls + 1    else      SA[k] = q      k = k + 1      ln = ln + 1  while ls &lt;= n - n&#x27;    SA[k] = sample[ls]    k = k + 1    ls = ls + 1  while ls &lt;= n&#x27;    SA[k] = nonsample[ls]    k = k + 1    ln = ln + 1  return SA\r\ne\r\n综上所述：\r\n\r\n步骤 1 进行的是第一步分治。子步骤 A 和 B 花费了\\(\\Theta(n)\\)的时间来构造字符串\\(P,P_1,P_2\\)。子步骤 C 使用了题目 32-2-b\r\n的算法，对字符串\\(P\\)中的字符进行排序，并通过子步骤 D\r\n进行产生\\(P\\)中每个字符的排名，存在数组\\(P&#39;\\)中，这个过程使用了基数排序和计数排序的方法，总共花费了\\(\\Theta(n)\\)的时间。子步骤 E 递归构造\\(P&#39;\\)的\\(SA\\)数组，由于其长度为\\(2n/3\\)，因此需要花费\\(T(2n/3)\\)的时间。子步骤 F 则使用\\(\\Theta(n)\\)的时间将\\(P&#39;\\)的\\(SA\\)数组映射回采样后缀中。\r\n步骤 2 进行的是第二步分治。子步骤 G 使用\\(\\Theta(n)\\)的时间求出\\(r\\)数组。子步骤 H 使用了题目 32-2-c\r\n的算法，对\\((T[i],r_{i+1})\\)二元组进行排序，由于同样使用了基数排序和计数排序的方法，因此总共花费了\\(\\Theta(n)\\)的时间。\r\n步骤 3 进行的是归并。它将两个分支步骤的结果进行归并。使用题目\r\n32-2-d 的算法在\\(\\Theta(n)\\)时间内求出最终的\\(SA\\)数组。\r\n\r\n因此，除了步骤 1 的子步骤 E 需要求解规模为\\(2n/3\\)的子问题，其余步骤都需要花费\\(\\Theta(n)\\)的时间进行处理，因此有\\(T(n)=T(2n/3)+\\Theta(n)\\)。按照主定理，有\\(T(n)=\\Theta(n)\\)，因此这是一个线性时间求解\\(SA\\)数组的算法。\r\n32-3\r\na\r\n需要注意的是，拼接的字符\\(\\mathtt{\\$}\\)的字典序是所有字符中最小的。可以假定，在为字符串构造\r\nSA 数组时，它后面都有一个终结符\\(\\mathtt{\\$}\\)。因此，在对所有后缀排好序后，可以发现每个后缀的排名都是唯一的，此时在这些后缀后面如何加字符，都不会影响它们原本的排名。因此，BWT\r\n只需要挪用\\(SA\\)数组的结果即可，不过需要先在\\(SA\\)数组的最前面再插入一个值\\(|T|+1\\)，那么这时的结果才是 BWT\r\n数组产生的结果。最终，字符串\\(t[i]=T[(BWT\r\n[i]-1-1)\\bmod (|T|+1) + 1]\\)才是 BWT\r\n的结果。更具体的过程由BWT-KNOWN-SA给出。\r\nBWT-KNOWN-SA(T, SA, n)  let BWT[1 : n + 1] be a new array  W = T$  t = T[n]  for i = 1 to n    t = t W[(SA[i] - 1 - 1) mod (n + 1) + 1]  return t\r\nb\r\n基于插入排序的思想就可以计算出每个下标的排名，如下给出BWT-COMPUTE-RANK将给出计算\\(rank\\)数组的算法。如果字母表中一共有\\(k\\)个字符，并且其范围是从\\(1\\)到\\(k\\)，那么BWT-COMPUTE-RANK计算\\(rank\\)数组的时间复杂度为\\(\\Theta(n+k)\\)。如果\\(k=O(n)\\)或者是一个常数，那么就有\\(\\Theta(n+k)=\\Theta(n)\\)。\r\nBWT-COMPUTE-RANK(T, n, k)  let C[0 : k], rank[1 : n] be new arrays by 0  for i = 1 to n    C[T[i]] = C[T[i]] + 1  for i = 1 to k    C[i] = C[i] + C[i-1]  for i = n downto 1    rank[i] = C[T[i]]    C[T[i]] = C[T[i]] - 1  return rank\r\nc\r\n只需要按照题目的含义进行模拟即可，先从\\(\\mathtt{\\$}\\)开始填充，因为它必定处于最后一位。整个过程由BWT-INV给出，可见其由于只有一个for循环进行常数操作，因此其时间复杂度为\\(\\Theta (n)\\)。\r\nBWT-INV-RANK(T, rank, n)  let S[1 : n] be a new array  pos = 0  for i = 1 to n    if T[i] == $      pos = i  for i = n downto 1    S[i] = T[pos]    pos = rank[pos]  interpret S[1 : n - 1] as a string s  return s\r\n","categories":["算法导论"]}]