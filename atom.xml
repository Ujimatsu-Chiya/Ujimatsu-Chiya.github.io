<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ujimatsu Chiya</title>
  
  
  <link href="https://ujimatsu-chiya.github.io/atom.xml" rel="self"/>
  
  <link href="https://ujimatsu-chiya.github.io/"/>
  <updated>2023-10-07T16:57:31.884Z</updated>
  <id>https://ujimatsu-chiya.github.io/</id>
  
  <author>
    <name>Ujimatsu Chiya</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法导论32 Problems 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-Problems/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-Problems/</id>
    <published>2023-10-07T16:57:31.000Z</published>
    <updated>2023-10-07T16:57:31.884Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">32-1</h1><h2 id="a">a</h2><p>首先使用KMP算法计算出<span class="math inline">\(\pi\)</span>数组，分两种情况进行考虑：</p><ul><li><p>如果<span class="math inline">\(i\bmod(i-\pi[i])=0\)</span>，那么有<span class="math inline">\(\rho(P[:i])=\dfrac{i}{i-\pi[i]}\)</span>，这意味<span class="math inline">\(P[i-\pi[i]+1:i]=P[1:\pi[i]]\)</span>，那也就是说，<span class="math inline">\(P[\pi[i]+1:2\pi[i]]=P[1,\pi[i]]\)</span>，类似的，有<span class="math inline">\(P[i-2\pi [i]+1:i]=P[i-\pi[i]+1:i]\)</span>，最终多次迭代下去，可以发现这是一个周期为<span class="math inline">\(\dfrac{i}{i-\pi[i]}\)</span>的字符串，此外，由于<span class="math inline">\(\forall k\in \pi^{\ast}[i]\)</span>，都有<span class="math inline">\(k\le \pi[i]\)</span>，因此<span class="math inline">\(i-\pi[i]\)</span>是<span class="math inline">\(i\)</span>满足条件的最小因子，它将使值<span class="math inline">\(\dfrac{i}{i-k}\)</span>达到最大，因此原结论成立。</p></li><li><p>如果<span class="math inline">\(i\bmod (i-\pi[i])\neq0\)</span>，那么<span class="math inline">\(\rho(P[:i])=1\)</span>。因为，对于一个非周期字符串<span class="math inline">\(s\)</span>（如果是周期字符串，那么可以归约到最小非周期字符串），如果存在一个正整数<span class="math inline">\(r\)</span>满足<span class="math inline">\(s^r=P[i]\)</span>，那么有<span class="math inline">\(r\mid i\)</span>。然而按照上面的方式依次取出<span class="math inline">\(r\)</span>个字母，它们不能取完整，因此这时<span class="math inline">\(P[:i]\)</span>只能由自身拼接<span class="math inline">\(1\)</span>次而成，原结论成立。</p></li></ul><p>算法<code>COMPUTE-PREFIX-RHO</code>给出了具体过程，可见其时间复杂度为<span class="math inline">\(O(n)\)</span>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">COMPUTE-PREFIX-RHO(P, m)</span><br><span class="line">  π = COMPUTE-PREFIX-FUNCTION(P, m)</span><br><span class="line">  let ρ[1 : m] be a new array</span><br><span class="line">  for i = 1 to m</span><br><span class="line">    if i % (i - π[i]) == 0</span><br><span class="line">      ρ[i] = i / (i - π[i])</span><br><span class="line">    else</span><br><span class="line">      ρ[i] = 1</span><br><span class="line">  return ρ</span><br></pre></td></tr></table></figure><h2 id="b">b</h2><p>待研究，相关链接：</p><ul><li><a href="https://www.sciencedirect.com/science/article/pii/0022000083900028">该算法相关的论文</a></li><li><a href="https://oeis.org/A216955">相关数列1</a></li><li><a href="https://oeis.org/A217941">相关数列2</a></li></ul><h2 id="c">c</h2><p>同题目32-1-b。</p><h1 id="section-1">32-2</h1><h2 id="a-1">a</h2><p>假设目前需要对比<span class="math inline">\(P\)</span>中非空后缀<span class="math inline">\(i\)</span>和<span class="math inline">\(j\)</span>，令<span class="math inline">\(P[i]\)</span>表示<span class="math inline">\(P\)</span>的第<span class="math inline">\(i\)</span>个元字符。如下考虑多种情况：</p><ol type="1"><li><p>如果<span class="math inline">\(P[i]\neqP[j]\)</span>，那么第<span class="math inline">\(i\)</span>个非空后缀和第<span class="math inline">\(j\)</span>个非空后缀的字典序由<span class="math inline">\(P[i]\)</span>和<span class="math inline">\(P[j]\)</span>决定，此时和<span class="math inline">\(P[i],P[j]\)</span>后面的字符没有任何关系，因此原结论成立。</p></li><li><p>如果<span class="math inline">\(P[i]=P[j]\)</span>，考虑<span class="math inline">\(i,j\)</span>都在<span class="math inline">\(P\)</span>中<span class="math inline">\(P_1\)</span>所占有的下标。可见，由于<span class="math inline">\(P_1[i:]\varnothing\)</span>和<span class="math inline">\(P_1[j:]\varnothing\)</span>的长度不同，并且最后一个字符<span class="math inline">\(\varnothing\)</span>都小于已经出现的字符，因此它们的字典序已经确定。此时再在独立的字符串<span class="math inline">\(P_1[i:]\varnothing,P_1[j:]\varnothing\)</span>后面再添加字符也不会改变<span class="math inline">\(P_1[i:]\varnothing\)</span>和<span class="math inline">\(P_1[j:]\)</span>的字典序。因此原结论成立。接下来考虑<span class="math inline">\(i,j\)</span>都在<span class="math inline">\(P\)</span>中<span class="math inline">\(P_2\)</span>所占有的下标，明显原结论成立，因为这些后缀恰好是<span class="math inline">\(P_2\)</span>的后缀。</p></li><li><p>如果<span class="math inline">\(P[i]=P[j]\)</span>，考虑<span class="math inline">\(i,j\)</span>在<span class="math inline">\(P\)</span>中，其中一个在<span class="math inline">\(P_1\)</span>所占有的下标，另一个在<span class="math inline">\(P_2\)</span>所占有的下标。不失一般性，假设<span class="math inline">\(i\)</span>属于前者，<span class="math inline">\(j\)</span>属于后者，那么不难得到<span class="math inline">\(i&lt;j\)</span>。由于此时<span class="math inline">\(P[i]=P[j]\)</span>，因此我们继续向下找下一个下标，直到满足这两个元字符不相同，即最小的正整数<span class="math inline">\(s\)</span>，使得<span class="math inline">\(P[i+s]\neq P[j+s]\)</span>。可以发现<span class="math inline">\(i+s\)</span>仍会在<span class="math inline">\(P_1\)</span>占有的下标中。按照步骤A的作用，<span class="math inline">\(P_1\)</span>必定会包含一个出现<span class="math inline">\(\varnothing\)</span>的元字符，因此第<span class="math inline">\(i\)</span>个非空后缀不晚于这个元字符结束。由于<span class="math inline">\(n&#39;\not\equiv n&#39;&#39;\pmod3\)</span>，因此<span class="math inline">\(i\)</span>个非空后缀和第<span class="math inline">\(j\)</span>个非空后缀必定是以不同数量的<span class="math inline">\(\varnothing\)</span>元字符作为结尾，此外由于<span class="math inline">\(\varnothing\)</span>的字典序最小，再在它们的后面任意添加字符也不会改变这两个非空后缀的字典序，因此原结论成立。</p></li></ol><p>因此，<span class="math inline">\(P\)</span>的非空后缀的排名和<span class="math inline">\(P\)</span>的后缀排名是相同的。由于早在<span class="math inline">\(\varnothing\)</span>的时候就已经确定了排名，去除<span class="math inline">\(\varnothing\)</span>后面的字符并不影响后缀的排名，因此<span class="math inline">\(P\)</span>中的后缀排名和<span class="math inline">\(T\)</span>的采样后缀的相对排名是一致的，因此原结论成立。</p><h2 id="b-1">b</h2><p>由于每个元字符都恰好是一个三元组，因此我们可以使用基数排序完成，只需要进行三趟。由于字符的大小有限，因此每趟基数排序的内部使用计数排序，最终可以在<span class="math inline">\(\Theta(n)\)</span>的时间内完成这个排序过程。需要注意的是，由于前面的字符占主导地位，因此基数排序过程是对这些三元组中的每个字符从后往前进行。如下算法<code>SA-SORT-CHARACTERS</code>给出了这个过程，可见其时间复杂度为<span class="math inline">\(\Theta(n)\)</span>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 假设字符出P中的每个字符用三元组(s[1], s[2], s[3])表示，分别表示元字符中的第一、第二和第三个字符。</span><br><span class="line">SA-SORT-CHARACTERS(P, n)</span><br><span class="line">  // L数组中的元素有两个属性：s属性是对应下标的元字符，index属性表示当前字符的下标。</span><br><span class="line">  let L[1 : n], L&#x27;[1 : n], P&#x27;[1 : n] be new arrays</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    L[i].index = i</span><br><span class="line">    L[i].s = P[i].s</span><br><span class="line">  mx = 0</span><br><span class="line">  // 这里使用mx表示元字符中，所有内部字符的最大大小。</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    mx = max&#123;mx, P[i].s[1], P[i].s[2], P[i].s[3]&#125;</span><br><span class="line">  let cnt[0 : mx] be a new array</span><br><span class="line">  for d = 3 downto 1</span><br><span class="line">    for j = 0 to mx</span><br><span class="line">      cnt[j] = 0 </span><br><span class="line">    for i = 1 to n</span><br><span class="line">      cnt[L[i].s[d]] = cnt[L[i].s[d]] + 1</span><br><span class="line">    for j = 1 to mx</span><br><span class="line">      cnt[j] = cnt[j - 1] + cnt[j]</span><br><span class="line">    for i = n downto 1</span><br><span class="line">      L&#x27;[cnt[L[i].s[d]]] = L[i]</span><br><span class="line">      cnt[L[i].s[d]] = cnt[L[i].s[d]] - 1</span><br><span class="line">    L = L&#x27;</span><br><span class="line">  r = 1</span><br><span class="line">  P&#x27;[L[1].index] = 1</span><br><span class="line">  for i = 2 to n</span><br><span class="line">    if L[i].s != L[i - 1].s</span><br><span class="line">      r = r + 1</span><br><span class="line">    P&#x27;[L[i].index] = r</span><br><span class="line">  return P&#x27;</span><br></pre></td></tr></table></figure><h2 id="c-1">c</h2><p>假设后缀<span class="math inline">\(P[i:]\)</span>是非采样后缀，那么有<span class="math inline">\(r_i=\square,r_{i+1}\)</span>是一个非负整数。如果<span class="math inline">\(r_i\neq \square\)</span>，那么说明<span class="math inline">\(r_i\)</span>是进行递归后，对应采样后缀的排名，因此这些<span class="math inline">\(r_i\)</span>是非负整数的情况下是唯一的，因此这使得二元组<span class="math inline">\((T[i],r_{i+1})\)</span>是唯一的。</p><p>由于原字符<span class="math inline">\(T[i]\)</span>的范围非常小，因此我们同样可以使用题目32-2-b的思路，使用基数排序（每趟内部使用计数排序）对这些二元组进行排序。如下算法<code>SA-SORT-CHARACTERS</code>给出了这个过程，可见其时间复杂度为<span class="math inline">\(\Theta(n)\)</span>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">SA-SORT-NONSAMPLE-SUFFIXES(T, r, n)</span><br><span class="line">  n&#x27; = ⌊n / 3⌋</span><br><span class="line">  let L[1 : n&#x27;], L&#x27;[1 : n&#x27;], nonsapmle[1 : n&#x27;] be new arrays</span><br><span class="line">  for i = 3 to n by 3</span><br><span class="line">    let L[i / 3].t[1 : 2] be a new array</span><br><span class="line">    L[i / 3].t[1] = T[i]</span><br><span class="line">    L[i / 3].t[2] = r[i + 1]</span><br><span class="line">    L[i / 3].index = i</span><br><span class="line">  mx = 0</span><br><span class="line">  // 这里使用mx表示元字符中，所有字符的大小。</span><br><span class="line">  for i = 1 to n&#x27;</span><br><span class="line">    mx = max&#123;mx, L[i].t[1], L[i].t[2]&#125;</span><br><span class="line">  let cnt[0 : mx] be a new array</span><br><span class="line">  for d = 2 downto 1</span><br><span class="line">    for j = 0 to mx</span><br><span class="line">      cnt[j] = 0 </span><br><span class="line">    for i = 1 to n&#x27;</span><br><span class="line">      cnt[L[i].t[d]] = cnt[L[i].t[d]] + 1</span><br><span class="line">    for j = 1 to mx</span><br><span class="line">      cnt[j] = cnt[j - 1] + cnt[j]</span><br><span class="line">    for i = n&#x27; downto 1</span><br><span class="line">      L&#x27;[cnt[L[i].s[d]]] = L[i]</span><br><span class="line">      cnt[L[i].s[d]] = cnt[L[i].s[d]] - 1</span><br><span class="line">    L = L&#x27;</span><br><span class="line">  return L</span><br></pre></td></tr></table></figure><h2 id="d">d</h2><p>假设字符串<span class="math inline">\(T\)</span>后面已经拼接了两个<span class="math inline">\(\varnothing\)</span>，对应到<span class="math inline">\(r\)</span>数组中其值为<span class="math inline">\(0\)</span>，也就是说，字符串<span class="math inline">\(T\)</span>现在的长度为<span class="math inline">\(n+2\)</span>。</p><p>其基本思想是，对于任意一对下标<span class="math inline">\(i,j(i\not\equiv j\pmod 3,1\le i,j\len)\)</span>，只要最多比较三次就能比较出字典序。也就是说，只要比对<span class="math inline">\((P[i],P[j]),(P[i+1],P[j+1]),(P[i+2],P[j+2])\)</span>即可。可以发现，必定存在最小的<span class="math inline">\(s(0\le s\le 2)\)</span>，使得<span class="math inline">\(r_{i+s}\neq\square\landr_{j+s}\neq\square\)</span>。</p><p>具体过程由<code>SA-SORT-MERGE</code>给出，它将原有的<span class="math inline">\(r\)</span>数组以及题目32-2-d所排好序的二元组进行归并，返回最终得到的<span class="math inline">\(SA\)</span>数组。最终这个过程在<span class="math inline">\(\Theta(n)\)</span>的时间内完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// 字符串T的长度为n+2，包括后面已经拼接了两个∅，r[n + 1] = r[n + 2] = 0。</span><br><span class="line">// 数组r如题意所示。</span><br><span class="line">// 数组nonsample是已经排好序的非采样后缀的下标，保证其大小为⌊n / 3⌋。</span><br><span class="line">SA-SORT-MERGE(T, r, nonsample, n)</span><br><span class="line">  n&#x27; = ⌊n / 3⌋</span><br><span class="line">  sample-choice = 1</span><br><span class="line">  nonsample-choice = 2</span><br><span class="line">  let sample[1 : n - n&#x27;] be a new array</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    if i % 3 != 0</span><br><span class="line">      sample[r[i]] = i</span><br><span class="line">  let SA[1 : n] be a new array</span><br><span class="line">  ls = 1</span><br><span class="line">  ln = 1</span><br><span class="line">  k = 1</span><br><span class="line">  while ls &lt;= n - n&#x27; and ln &lt;= n&#x27;</span><br><span class="line">    p = sample[ls]</span><br><span class="line">    q = nonsample[ln]</span><br><span class="line">    if T[p] != T[q]</span><br><span class="line">      if T[p] &lt; T[q]</span><br><span class="line">        choice = sample-choice</span><br><span class="line">      else</span><br><span class="line">        choice = nonsample-choice</span><br><span class="line">    else if p % 3 == 1</span><br><span class="line">      // 此时r[p + 1] != □必定成立</span><br><span class="line">      if r[p + 1] &lt; r[q + 1]</span><br><span class="line">        choice = sample-choice</span><br><span class="line">      else</span><br><span class="line">        choice = nonsample-choice</span><br><span class="line">    else</span><br><span class="line">      // 此时r[p + 1] != □必定成立</span><br><span class="line">      if T[p + 1] &lt; T[q + 1] or T[p + 1] == T[q + 1] and r[p + 2] &lt; r[q + 2]</span><br><span class="line">        choice = sample-choice</span><br><span class="line">      else</span><br><span class="line">        choice = nonsample-choice</span><br><span class="line">    if choice == sample-choice</span><br><span class="line">      SA[k] = p</span><br><span class="line">      k = k + 1</span><br><span class="line">      ls = ls + 1</span><br><span class="line">    else</span><br><span class="line">      SA[k] = q</span><br><span class="line">      k = k + 1</span><br><span class="line">      ln = ln + 1</span><br><span class="line">  while ls &lt;= n - n&#x27;</span><br><span class="line">    SA[k] = sample[ls]</span><br><span class="line">    k = k + 1</span><br><span class="line">    ls = ls + 1</span><br><span class="line">  while ls &lt;= n&#x27;</span><br><span class="line">    SA[k] = nonsample[ls]</span><br><span class="line">    k = k + 1</span><br><span class="line">    ln = ln + 1</span><br><span class="line">  return SA</span><br></pre></td></tr></table></figure><h2 id="e">e</h2><p>综上所述：</p><ol type="1"><li><p>步骤1进行的是第一步分治。子步骤A和B花费了<span class="math inline">\(\Theta(n)\)</span>的时间来构造字符串<span class="math inline">\(P,P_1,P_2\)</span>。子步骤C使用了题目32-2-b的算法，对字符串<span class="math inline">\(P\)</span>中的字符进行排序，并通过子步骤D进行产生<span class="math inline">\(P\)</span>中每个字符的排名，存在数组<span class="math inline">\(P&#39;\)</span>中，这个过程使用了基数排序和计数排序的方法，总共花费了<span class="math inline">\(\Theta(n)\)</span>的时间。子步骤E递归构造<span class="math inline">\(P&#39;\)</span>的<span class="math inline">\(SA\)</span>数组，由于其长度为<span class="math inline">\(2n/3\)</span>，因此需要花费<span class="math inline">\(T(2n/3)\)</span>的时间。子步骤F则使用<span class="math inline">\(\Theta(n)\)</span>的时间将<span class="math inline">\(P&#39;\)</span>的<span class="math inline">\(SA\)</span>数组映射回采样后缀中。</p></li><li><p>步骤2进行的是第二步分治。子步骤G使用<span class="math inline">\(\Theta(n)\)</span>的时间求出<span class="math inline">\(r\)</span>数组。子步骤H使用了题目32-2-c的算法，对<span class="math inline">\((T[i],r_{i+1})\)</span>二元组进行排序，由于同样使用了基数排序和计数排序的方法，因此总共花费了<span class="math inline">\(\Theta(n)\)</span>的时间。</p></li><li><p>步骤3进行的是归并。它将两个分支步骤的结果进行归并。使用题目32-2-d的算法在<span class="math inline">\(\Theta(n)\)</span>时间内求出最终的<span class="math inline">\(SA\)</span>数组。</p></li></ol><p>因此，除了步骤1的子步骤E需要求解规模为<span class="math inline">\(2n/3\)</span>的子问题，其余步骤都需要花费<span class="math inline">\(\Theta(n)\)</span>的时间进行处理，因此有<span class="math inline">\(T(n)=T(2n/3)+\Theta(n)\)</span>。按照主定理，有<span class="math inline">\(T(n)=\Theta(n)\)</span>，因此这是一个线性时间求解<span class="math inline">\(SA\)</span>数组的算法。</p><h1 id="section-2">32-3</h1><h2 id="a-2">a</h2><p>需要注意的是，拼接的字符<span class="math inline">\(\mathtt{\$}\)</span>的字典序是所有字符中最小的。可以假定，在为字符串构造SA数组时，它后面都有一个终结符<span class="math inline">\(\mathtt{\$}\)</span>。因此，在对所有后缀排好序后，可以发现每个后缀的排名都是唯一的，此时在这些后缀后面如何加字符，都不会影响它们原本的排名。因此，BWT只需要挪用<span class="math inline">\(SA\)</span>数组的结果即可，不过需要先在<span class="math inline">\(SA\)</span>数组的最前面再插入一个值<span class="math inline">\(|T|+1\)</span>，那么这时的结果才是BWT数组产生的结果。最终，字符串<span class="math inline">\(t[i]=T[(BWT [i]-1-1)\bmod (|T|+1) +1]\)</span>才是BWT的结果。更具体的过程由<code>BWT-KNOWN-SA</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BWT-KNOWN-SA(T, SA, n)</span><br><span class="line">  let BWT[1 : n + 1] be a new array</span><br><span class="line">  W = T$</span><br><span class="line">  t = T[n]</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    t = t W[(SA[i] - 1 - 1) mod (n + 1) + 1]</span><br><span class="line">  return t</span><br></pre></td></tr></table></figure><h2 id="b-2">b</h2><p>基于插入排序的思想就可以计算出每个下标的排名，如下给出<code>BWT-COMPUTE-RANK</code>将给出计算<span class="math inline">\(rank\)</span>数组的算法。如果字母表中一共有<span class="math inline">\(k\)</span>个字符，并且其范围是从<span class="math inline">\(1\)</span>到<span class="math inline">\(k\)</span>，那么<code>BWT-COMPUTE-RANK</code>计算<span class="math inline">\(rank\)</span>数组的时间复杂度为<span class="math inline">\(\Theta(n+k)\)</span>。如果<span class="math inline">\(k=O(n)\)</span>或者是一个常数，那么就有<span class="math inline">\(\Theta(n+k)=\Theta(n)\)</span>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BWT-COMPUTE-RANK(T, n, k)</span><br><span class="line">  let C[0 : k], rank[1 : n] be new arrays by 0</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    C[T[i]] = C[T[i]] + 1</span><br><span class="line">  for i = 1 to k</span><br><span class="line">    C[i] = C[i] + C[i-1]</span><br><span class="line">  for i = n downto 1</span><br><span class="line">    rank[i] = C[T[i]]</span><br><span class="line">    C[T[i]] = C[T[i]] - 1</span><br><span class="line">  return rank</span><br></pre></td></tr></table></figure><h2 id="c-2">c</h2><p>只需要按照题目的含义进行模拟即可，先从<span class="math inline">\(\mathtt{\$}\)</span>开始填充，因为它必定处于最后一位。整个过程由<code>BWT-INV</code>给出，可见其由于只有一个<code>for</code>循环进行常数操作，因此其时间复杂度为<span class="math inline">\(\Theta O(n)\)</span>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BWT-INV-RANK(T, rank, n)</span><br><span class="line">  let S[1 : n] be a new array</span><br><span class="line">  pos = 0</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    if T[i] == $</span><br><span class="line">      pos = i</span><br><span class="line">  for i = n downto 1</span><br><span class="line">    S[i] = T[pos]</span><br><span class="line">    pos = rank[pos]</span><br><span class="line">  interpret S[1 : n - 1] as a string s</span><br><span class="line">  return s</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论32.5 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-5-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-5-Exercises/</id>
    <published>2023-10-07T16:57:28.000Z</published>
    <updated>2023-10-07T16:57:28.858Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">32.5-1</h1><p>如下两表，是分别执行完<code>COMPUTE-SUFFIX-ARRAY</code>的第2-7行和第8行后的结果。</p><p><span class="math inline">\(\begin{array}{ccccl}i&amp;left\text{-}rank&amp;right\text{-}rank&amp;index&amp;\text{substring}\\\hline1&amp;8&amp;9&amp;1&amp;\texttt{hi}\\2&amp;9&amp;16&amp;2&amp;\texttt{ip}\\3&amp;16&amp;16&amp;3&amp;\texttt{pp}\\4&amp;16&amp;9&amp;4&amp;\texttt{pi}\\5&amp;9&amp;20&amp;5&amp;\texttt{it}\\6&amp;20&amp;25&amp;6&amp;\texttt{ty}\\7&amp;25&amp;8&amp;7&amp;\texttt{yh}\\8&amp;8&amp;15&amp;8&amp;\texttt{ho}\\9&amp;15&amp;16&amp;9&amp;\texttt{op}\\10&amp;16&amp;16&amp;10&amp;\texttt{pp}\\11&amp;16&amp;9&amp;11&amp;\texttt{pi}\\12&amp;9&amp;20&amp;12&amp;\texttt{it}\\13&amp;20&amp;25&amp;13&amp;\texttt{ty}\\14&amp;25&amp;0&amp;14&amp;\texttt{y}\\ \end{array} \qquad\begin{array}{ccccl}i&amp;left\text{-}rank&amp;right\text{-}rank&amp;index&amp;\text{substring}\\\hline1&amp;8&amp;9&amp;1&amp;\texttt{hi}\\2&amp;8&amp;15&amp;8&amp;\texttt{ho}\\3&amp;9&amp;16&amp;2&amp;\texttt{ip}\\4&amp;9&amp;20&amp;5&amp;\texttt{it}\\5&amp;9&amp;20&amp;12&amp;\texttt{it}\\6&amp;15&amp;16&amp;9&amp;\texttt{op}\\7&amp;16&amp;9&amp;4&amp;\texttt{pi}\\8&amp;16&amp;9&amp;11&amp;\texttt{pi}\\9&amp;16&amp;16&amp;3&amp;\texttt{pp}\\10&amp;16&amp;16&amp;10&amp;\texttt{pp}\\11&amp;20&amp;25&amp;6&amp;\texttt{ty}\\12&amp;20&amp;25&amp;13&amp;\texttt{ty}\\13&amp;25&amp;0&amp;14&amp;\texttt{y}\\14&amp;25&amp;8&amp;7&amp;\texttt{yh}\\ \end{array}\)</span></p><p>当<span class="math inline">\(l=2\)</span>时，分别执行完<code>COMPUTE-SUFFIX-ARRAY</code>的第11行，第12-17行和第18行的结果如下三个表所示。</p><p><span class="math inline">\(\begin{array}{ccl}i&amp;rank&amp;\text{substring}\\\hline 1&amp;1&amp;\texttt{hi}\\2&amp;3&amp;\texttt{ip}\\ 3&amp;7&amp;\texttt{pp}\\4&amp;6&amp;\texttt{pi}\\ 5&amp;4&amp;\texttt{it}\\6&amp;8&amp;\texttt{ty}\\ 7&amp;10&amp;\texttt{yh}\\8&amp;2&amp;\texttt{ho}\\ 9&amp;5&amp;\texttt{op}\\10&amp;7&amp;\texttt{pp}\\ 11&amp;6&amp;\texttt{pi}\\12&amp;4&amp;\texttt{it}\\ 13&amp;8&amp;\texttt{ty}\\14&amp;9&amp;\texttt{y}\\ \end{array}\qquad \begin{array}{ccccl}i&amp;left\text{-}rank&amp;right\text{-}rank&amp;index&amp;\text{substring}\\\hline1&amp;1&amp;7&amp;1&amp;\texttt{hipp}\\2&amp;3&amp;6&amp;2&amp;\texttt{ippi}\\3&amp;7&amp;4&amp;3&amp;\texttt{ppit}\\4&amp;6&amp;8&amp;4&amp;\texttt{pity}\\5&amp;4&amp;10&amp;5&amp;\texttt{ityh}\\6&amp;8&amp;2&amp;6&amp;\texttt{tyho}\\7&amp;10&amp;5&amp;7&amp;\texttt{yhop}\\8&amp;2&amp;7&amp;8&amp;\texttt{hopp}\\9&amp;5&amp;6&amp;9&amp;\texttt{oppi}\\10&amp;7&amp;4&amp;10&amp;\texttt{ppit}\\11&amp;6&amp;8&amp;11&amp;\texttt{pity}\\12&amp;4&amp;9&amp;12&amp;\texttt{ity}\\13&amp;8&amp;0&amp;13&amp;\texttt{ty}\\14&amp;9&amp;0&amp;14&amp;\texttt{y}\\ \end{array}\qquad\begin{array}{ccccl}i&amp;left\text{-}rank&amp;right\text{-}rank&amp;index&amp;\text{substring}\\\hline1&amp;1&amp;7&amp;1&amp;\texttt{hipp}\\2&amp;2&amp;7&amp;8&amp;\texttt{hopp}\\3&amp;3&amp;6&amp;2&amp;\texttt{ippi}\\4&amp;4&amp;9&amp;12&amp;\texttt{ity}\\5&amp;4&amp;10&amp;5&amp;\texttt{ityh}\\6&amp;5&amp;6&amp;9&amp;\texttt{oppi}\\7&amp;6&amp;8&amp;4&amp;\texttt{pity}\\8&amp;6&amp;8&amp;11&amp;\texttt{pity}\\9&amp;7&amp;4&amp;3&amp;\texttt{ppit}\\10&amp;7&amp;4&amp;10&amp;\texttt{ppit}\\11&amp;8&amp;0&amp;13&amp;\texttt{ty}\\12&amp;8&amp;2&amp;6&amp;\texttt{tyho}\\13&amp;9&amp;0&amp;14&amp;\texttt{y}\\14&amp;10&amp;5&amp;7&amp;\texttt{yhop}\\ \end{array}\)</span></p><p>当<span class="math inline">\(l=4\)</span>时，分别执行完<code>COMPUTE-SUFFIX-ARRAY</code>的第11行，第12-17行和第18行的结果如下三个表所示。</p><p><span class="math inline">\(\begin{array}{ccl}i&amp;rank&amp;\text{substring}\\\hline 1&amp;1&amp;\texttt{hipp}\\2&amp;3&amp;\texttt{ippi}\\ 3&amp;8&amp;\texttt{ppit}\\4&amp;7&amp;\texttt{pity}\\ 5&amp;5&amp;\texttt{ityh}\\6&amp;10&amp;\texttt{tyho}\\ 7&amp;12&amp;\texttt{yhop}\\8&amp;2&amp;\texttt{hopp}\\ 9&amp;6&amp;\texttt{oppi}\\10&amp;8&amp;\texttt{ppit}\\ 11&amp;7&amp;\texttt{pity}\\12&amp;4&amp;\texttt{ity}\\ 13&amp;9&amp;\texttt{ty}\\14&amp;11&amp;\texttt{y}\\ \end{array}\qquad \begin{array}{ccccl}i&amp;left\text{-}rank&amp;right\text{-}rank&amp;index&amp;\text{substring}\\\hline1&amp;1&amp;5&amp;1&amp;\texttt{hippityh}\\2&amp;3&amp;10&amp;2&amp;\texttt{ippityho}\\3&amp;8&amp;12&amp;3&amp;\texttt{ppityhop}\\4&amp;7&amp;2&amp;4&amp;\texttt{pityhopp}\\5&amp;5&amp;6&amp;5&amp;\texttt{ityhoppi}\\6&amp;10&amp;8&amp;6&amp;\texttt{tyhoppit}\\7&amp;12&amp;7&amp;7&amp;\texttt{yhoppity}\\8&amp;2&amp;4&amp;8&amp;\texttt{hoppity}\\9&amp;6&amp;9&amp;9&amp;\texttt{oppity}\\10&amp;8&amp;11&amp;10&amp;\texttt{ppity}\\11&amp;7&amp;0&amp;11&amp;\texttt{pity}\\12&amp;4&amp;0&amp;12&amp;\texttt{ity}\\13&amp;9&amp;0&amp;13&amp;\texttt{ty}\\14&amp;11&amp;0&amp;14&amp;\texttt{y}\\ \end{array}\qquad\begin{array}{ccccl}i&amp;left\text{-}rank&amp;right\text{-}rank&amp;index&amp;\text{substring}\\\hline1&amp;1&amp;5&amp;1&amp;\texttt{hippityh}\\2&amp;2&amp;4&amp;8&amp;\texttt{hoppity}\\3&amp;3&amp;10&amp;2&amp;\texttt{ippityho}\\4&amp;4&amp;0&amp;12&amp;\texttt{ity}\\5&amp;5&amp;6&amp;5&amp;\texttt{ityhoppi}\\6&amp;6&amp;9&amp;9&amp;\texttt{oppity}\\7&amp;7&amp;0&amp;11&amp;\texttt{pity}\\8&amp;7&amp;2&amp;4&amp;\texttt{pityhopp}\\9&amp;8&amp;11&amp;10&amp;\texttt{ppity}\\10&amp;8&amp;12&amp;3&amp;\texttt{ppityhop}\\11&amp;9&amp;0&amp;13&amp;\texttt{ty}\\12&amp;10&amp;8&amp;6&amp;\texttt{tyhoppit}\\13&amp;11&amp;0&amp;14&amp;\texttt{y}\\14&amp;12&amp;7&amp;7&amp;\texttt{yhoppity}\\ \end{array}\)</span></p><p>当<span class="math inline">\(l=8\)</span>时，分别执行完<code>COMPUTE-SUFFIX-ARRAY</code>的第11行，第12-17行和第18行的结果如下三个表所示。</p><p><span class="math inline">\(\begin{array}{ccl}i&amp;rank&amp;\text{substring}\\\hline 1&amp;1&amp;\texttt{hippityh}\\2&amp;3&amp;\texttt{ippityho}\\ 3&amp;10&amp;\texttt{ppityhop}\\4&amp;8&amp;\texttt{pityhopp}\\ 5&amp;5&amp;\texttt{ityhoppi}\\6&amp;12&amp;\texttt{tyhoppit}\\ 7&amp;14&amp;\texttt{yhoppity}\\8&amp;2&amp;\texttt{hoppity}\\ 9&amp;6&amp;\texttt{oppity}\\10&amp;9&amp;\texttt{ppity}\\ 11&amp;7&amp;\texttt{pity}\\12&amp;4&amp;\texttt{ity}\\ 13&amp;11&amp;\texttt{ty}\\14&amp;13&amp;\texttt{y}\\ \end{array}\qquad\begin{array}{ccccl}i&amp;left\text{-}rank&amp;right\text{-}rank&amp;index&amp;\text{substring}\\\hline1&amp;1&amp;6&amp;1&amp;\texttt{hippityhoppity}\\2&amp;3&amp;9&amp;2&amp;\texttt{ippityhoppity}\\3&amp;10&amp;7&amp;3&amp;\texttt{ppityhoppity}\\4&amp;8&amp;4&amp;4&amp;\texttt{pityhoppity}\\5&amp;5&amp;11&amp;5&amp;\texttt{ityhoppity}\\6&amp;12&amp;13&amp;6&amp;\texttt{tyhoppity}\\7&amp;14&amp;0&amp;7&amp;\texttt{yhoppity}\\8&amp;2&amp;0&amp;8&amp;\texttt{hoppity}\\9&amp;6&amp;0&amp;9&amp;\texttt{oppity}\\10&amp;9&amp;0&amp;10&amp;\texttt{ppity}\\11&amp;7&amp;0&amp;11&amp;\texttt{pity}\\12&amp;4&amp;0&amp;12&amp;\texttt{ity}\\13&amp;11&amp;0&amp;13&amp;\texttt{ty}\\14&amp;13&amp;0&amp;14&amp;\texttt{y}\\\end{array}\qquad\begin{array}{ccccl}i&amp;left\text{-}rank&amp;right\text{-}rank&amp;index&amp;\text{substring}\\\hline1&amp;1&amp;6&amp;1&amp;\texttt{hippityhoppity}\\2&amp;2&amp;0&amp;8&amp;\texttt{hoppity}\\3&amp;3&amp;9&amp;2&amp;\texttt{ippityhoppity}\\4&amp;4&amp;0&amp;12&amp;\texttt{ity}\\5&amp;5&amp;11&amp;5&amp;\texttt{ityhoppity}\\6&amp;6&amp;0&amp;9&amp;\texttt{oppity}\\7&amp;7&amp;0&amp;11&amp;\texttt{pity}\\8&amp;8&amp;4&amp;4&amp;\texttt{pityhoppity}\\9&amp;9&amp;0&amp;10&amp;\texttt{ppity}\\10&amp;10&amp;7&amp;3&amp;\texttt{ppityhoppity}\\11&amp;11&amp;0&amp;13&amp;\texttt{ty}\\12&amp;12&amp;13&amp;6&amp;\texttt{tyhoppity}\\13&amp;13&amp;0&amp;14&amp;\texttt{y}\\14&amp;14&amp;0&amp;7&amp;\texttt{yhoppity}\\ \end{array}\)</span></p><p>因此，得到的<span class="math inline">\(SA\)</span>数组为<span class="math inline">\([1,8,2,12,5,9,11,4,10,3,13,6,14,7]\)</span>。</p><p>最终，按序填入<span class="math inline">\(LCP\)</span>数组的顺序如下表所示：</p><p><span class="math inline">\(\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}\hlinei&amp;1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8&amp;9&amp;10&amp;11&amp;12&amp;13&amp;14\\\hlines&amp;1&amp;3&amp;10&amp;8&amp;5&amp;12&amp;14&amp;2&amp;6&amp;9&amp;7&amp;4&amp;11&amp;13\\\hlineLCP[i]&amp;0&amp;0&amp;5&amp;4&amp;3&amp;2&amp;1&amp;1&amp;0&amp;1&amp;0&amp;1&amp;0&amp;0\\\hline\end{array}\)</span></p><p>因此，得到的<span class="math inline">\(LCP\)</span>数组为<span class="math inline">\([0,1,0,1,3,0,0,4,1,5,0,2,0,1]\)</span>。</p><h1 id="section-1">32.5-2</h1><p>基本思想是，如果不需要<span class="math inline">\(\lfloor\lgn\rfloor-1\)</span>次<code>while</code>循环就能够区分出所有后缀的排名，那么<code>while</code>循环可以提前终止。</p><p>具体细节是，在<code>MAKE-RANKS</code>的过程中，如果最后一名的后缀的排名已经恰好达到了<span class="math inline">\(n\)</span>，那么可以终止<code>while</code>循环。修改狗的算法由<code>COMPUTE-SUFFIX-ARRAY'</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">COMPUTE-SUFFIX-ARRAY&#x27;(T, n)</span><br><span class="line">  allocate arrays substr-rank[1:n], rank[1:n], and SA[1:n]</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    substr-rank[i].left-rank = ord(T[i])</span><br><span class="line">    if i &lt; n</span><br><span class="line">      substr-rank[i].right-rank = ord(T[i + 1])</span><br><span class="line">    else substr-rank[i].right-rank = 0</span><br><span class="line">    substr-rank[i].index = i</span><br><span class="line">  sort the array substr-rank into monotonically increasing order based on the left-rank attributes, using the right-rank attributes to break ties; if still a tie, the order does not matter</span><br><span class="line">  l = 2</span><br><span class="line">  while l &lt; n</span><br><span class="line">    MAKE-RANKS(substr-rank, rank, n)</span><br><span class="line">    for i = 1 to n</span><br><span class="line">      substr-rank[i].left-rank = rank[i]</span><br><span class="line">      if i + l ≤ n</span><br><span class="line">        substr-rank[i].right-rank = rank[i + l]</span><br><span class="line">      else substr-rank[i].right-rank = 0</span><br><span class="line">      substr-rank[i].index = i</span><br><span class="line">    sort the array substr-rank into monotonically increasing order based on the left-rank attributes, using the right-rank attributes to break ties; if still a tie, the order does not matter</span><br><span class="line">    l = 2 * l</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    SA[i] = substr-rank[i].index</span><br><span class="line">  return SA</span><br></pre></td></tr></table></figure><h1 id="section-2">32.5-3</h1><p>使用一个不曾出现在<span class="math inline">\(T_1,T_2\)</span>中的字符<span class="math inline">\(\texttt{@}\)</span>，并将其和<span class="math inline">\(T_1,T_2\)</span>拼接起来，得到<span class="math inline">\(T=T_1\texttt{@}T_2\)</span>，其长度为<span class="math inline">\(n=n_1+n_2+1\)</span>。对字符串<span class="math inline">\(T\)</span>求出它的<code>SA</code>数组和<code>LCP</code>数组后，枚举<span class="math inline">\(T\)</span>中每对排名相邻的后缀<span class="math inline">\(SA[i],SA[i-1]\)</span>。如果这两个后缀来自<span class="math inline">\(T\)</span>的不同部分（也就是其中一个来自<span class="math inline">\(T_1\)</span>，另一个来自<span class="math inline">\(T_2\)</span>）那么说明这两个后缀的最长公共前缀为<span class="math inline">\(T_1,T_2\)</span>这两个字符串的子串之一，由于<span class="math inline">\(\texttt{@}\)</span>不在<span class="math inline">\(T_1\)</span>中，因此可以确保<span class="math inline">\(LCP\)</span>不会恰好经过<span class="math inline">\(\texttt{@}\)</span>。具体过程由程序<code>LONGEST-COMMON-SUBSTRINGS</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">LONGEST-COMMON-SUBSTRINGS(T1, T2, n1, n2)</span><br><span class="line">  T = T1 @ T2</span><br><span class="line">  n = n1 + n2 + 1</span><br><span class="line">  SA = COMPUTE-SUFFIX-ARRAY(T, n)</span><br><span class="line">  LCP = COMPUTE-LCP(T, SA, n)</span><br><span class="line">  len = 0</span><br><span class="line">  S = ∅</span><br><span class="line">  for i = 2 to n</span><br><span class="line">    l = SA[i - 1]</span><br><span class="line">    r = SA[i]</span><br><span class="line">    if min&#123;l, r&#125; &lt;= n1 and max(l, r) &gt; n1 + 1</span><br><span class="line">      if LCP[i] &gt; len</span><br><span class="line">        len = LCP[i]</span><br><span class="line">        S = &#123;min&#123;l, r&#125;&#125;</span><br><span class="line">    else if lCP[i] == len</span><br><span class="line">        S = S ∪ &#123;min&#123;l, r&#125;&#125;</span><br><span class="line">  let string-list be a new array</span><br><span class="line">  for l in S</span><br><span class="line">    INSERT(string-list, T1[l : l + len - 1])</span><br><span class="line">  return string-list</span><br></pre></td></tr></table></figure><h1 id="section-3">32.5-4</h1><p>这里首先需要解释一下这个约束<span class="math inline">\(SA[i-1]=n&#39;-SA[i]-LCP[i]+2\)</span>是怎么来的：</p><p>首先，<span class="math inline">\(T\)</span>中有一个子串<span class="math inline">\([l,r]\)</span>是回文串，那么在<span class="math inline">\(T&#39;\)</span>这个字符串中，其在后半段对应的位置中是<span class="math inline">\([l&#39;,r&#39;]\)</span>。这意味着<span class="math inline">\(r-l+1=r&#39;-l&#39;+1=\text{len}\)</span>，由于<span class="math inline">\(T&#39;\)</span>的最后<span class="math inline">\(n\)</span>个字符是由<span class="math inline">\(T\)</span>反转而来，并且字符<span class="math inline">\(\texttt{@}\)</span>处在下标<span class="math inline">\(\dfrac{n&#39;+1}{2}\)</span>中，因此有<span class="math inline">\(\dfrac{n&#39;+1}{2}-r=l&#39;-\dfrac{n&#39;+1}{2}\)</span>。最终联立上面两个式子可以得到<span class="math inline">\(n&#39;+1=l&#39;+l+\text{len}-1\)</span>，更进一步可以得到<span class="math inline">\(l&#39;=n&#39;-l-\text{len}+2\)</span>，和上面给定的约束很像。</p><p>因此，这个求解最长回文子串的算法的错误在于，它认为后缀<span class="math inline">\(T[l:]\)</span>和<span class="math inline">\(T[l&#39;:]\)</span>在<span class="math inline">\(SA\)</span>数组中是相邻的，然而并非如此。</p><p>考虑字符串<span class="math inline">\(T=\texttt{abbcabb}\)</span>，那么有<span class="math inline">\(T&#39;=\texttt{abbcabb@bbacbba}\)</span>。等算法结束后，我们可以得到关于这个字符串的表格：</p><p><span class="math inline">\(\begin{array}{cclc}i&amp;SA[i]&amp;\text{substring}&amp;LCP[i]&amp;SA[i-1]=n&#39;-SA[i]-LCP[i]+2\\\hline1&amp;8&amp;\texttt{@bbacbba}&amp;0&amp;\text{No}\\2&amp;15&amp;\texttt{a}&amp;0&amp;\text{No}\\3&amp;5&amp;\texttt{abb@bbacbba}&amp;1&amp;\text{No}\\4&amp;1&amp;\texttt{abbcabb@bbacbba}&amp;3&amp;\text{No}\\5&amp;11&amp;\texttt{acbba}&amp;1&amp;\text{No}\\6&amp;7&amp;\texttt{b@bbacbba}&amp;0&amp;\text{No}\\7&amp;14&amp;\texttt{ba}&amp;1&amp;\text{No}\\8&amp;10&amp;\texttt{bacbba}&amp;2&amp;\text{No}\\9&amp;6&amp;\texttt{bb@bbacbba}&amp;1&amp;\text{Yes}\\10&amp;13&amp;\texttt{bba}&amp;2&amp;\text{No}\\11&amp;9&amp;\texttt{bbacbba}&amp;3&amp;\text{No}\\12&amp;2&amp;\texttt{bbcabb@bbacbba}&amp;2&amp;\text{No}\\13&amp;3&amp;\texttt{bcabb@bbacbba}&amp;1&amp;\text{No}\\14&amp;4&amp;\texttt{cabb@bbacbba}&amp;0&amp;\text{No}\\15&amp;12&amp;\texttt{cbba}&amp;1&amp;\text{Yes}\\\end{array}\)</span></p><p>由表格可知这个算法的输出结果为<span class="math inline">\(1\)</span>，但是实际上答案为<span class="math inline">\(2\)</span>。<span class="math inline">\(T\)</span>一共有两个子串<span class="math inline">\(\texttt{bb}\)</span>满足答案。其中一对<span class="math inline">\(\texttt{bb}\)</span>及其在后半段的反转分别是<span class="math inline">\(T&#39;[2:3],T&#39;[13:14]\)</span>，但是在<span class="math inline">\(SA\)</span>数组中，<span class="math inline">\(2\)</span>和<span class="math inline">\(13\)</span>不相邻。同样的，另一对<span class="math inline">\(\texttt{bb}\)</span>则及其反转分别是在<span class="math inline">\(T&#39;[6:7],T&#39;[9:10]\)</span>，但是在<span class="math inline">\(SA\)</span>数组中，<span class="math inline">\(6\)</span>和<span class="math inline">\(10\)</span>不相邻。</p><p>最终是因为约束<span class="math inline">\(SA[i-1]=n&#39;-SA[i]-LCP[i]+2\)</span>认为后缀<span class="math inline">\(T[l:]\)</span>和<span class="math inline">\(T[l&#39;:]\)</span>在<span class="math inline">\(SA\)</span>数组中是相邻的，导致了错误。因此这个约束不正确。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论32.4 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-4-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-4-Exercises/</id>
    <published>2023-10-07T16:57:25.000Z</published>
    <updated>2023-10-07T16:57:25.833Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">32.4-1</h1><p>模式串<span class="math inline">\(P=\texttt{ababbabbabbababbabb}\)</span>的前缀数组为<span class="math inline">\(\pi=(0,0,1,2,0,1,2,0,1,2,0,1,2,3,4,5,6,7,8)\)</span>。</p><h1 id="section-1">32.4-2</h1><p><span class="math inline">\(\pi^{\ast}[q]\)</span>的大小可以达到<span class="math inline">\(q-1\)</span>。以<span class="math inline">\(m\)</span>个字符<span class="math inline">\(\texttt{a}\)</span>的模式串<span class="math inline">\(P\)</span>为例，对于<span class="math inline">\(\forallq\in[2,n],\pi^{\ast}[q]=\{1,2,\dots,q-1\}\)</span>。因此集合<span class="math inline">\(\pi^{\ast}[q]\)</span>的大小可以达到<span class="math inline">\(q-1\)</span>。</p><h1 id="section-2">32.4-3</h1><p>可见，在<span class="math inline">\(T\)</span>中出现<span class="math inline">\(P\)</span>的有效偏移量集合为<span class="math inline">\(\{q-2m:\pi[q]=m,q\ge 2m\}\)</span>。因为<span class="math inline">\(P\)</span>被拼接在了前面，因此需要减去<span class="math inline">\(P\)</span>已经占有的偏移量<span class="math inline">\(m\)</span>。此外，还需要满足<span class="math inline">\(q\ge 2m\)</span>，以避免和字符串<span class="math inline">\(P\)</span>有交叉。由于<span class="math inline">\(\pi\)</span>递增时，最多只会递增<span class="math inline">\(1\)</span>，因此只需要考虑等于<span class="math inline">\(m\)</span>的情况即可满足所有情况，而不需要考虑大于<span class="math inline">\(m\)</span>的情况。</p><h1 id="section-3">32.4-4</h1><p>不失一般性，这里只考虑<code>KMP-MATCHER</code>的主体部分（因为<code>COMPUTE-PREFIX-FUNCTION</code>的分析方式和<code>KMP-MATCHER</code>一致）。</p><p>按照定义，由于<span class="math inline">\(r=\pi[q]\)</span>是<span class="math inline">\(P[:q]\)</span>中最长的真子前缀同时也是其后缀，因此<span class="math inline">\(\pi[q]&lt;q\)</span>。这意味着第4-5中的<code>while</code>循环执行一次<span class="math inline">\(q\)</span>值就会减少。由于<span class="math inline">\(q\)</span>不可能为负数，并且第3行的每轮<code>for</code>循环中，只有第7行才会对<span class="math inline">\(q\)</span>增加（并且只增加<span class="math inline">\(1\)</span>），因此第5行最多也只会执行<span class="math inline">\(n\)</span>次。</p><p>最终，第2-10行只需要<span class="math inline">\(\Theta(n)\)</span>的时间即可完成。第1行的<code>COMPUTE-PREFIX-FUNCTION</code>使用类似分析方式可以得到其运行时间为<span class="math inline">\(\Theta(m)\)</span>。由于<span class="math inline">\(m\len\)</span>，因此<code>KMP-MATCHER</code>的时间复杂度为<span class="math inline">\(\Theta(m)+\Theta(n)=\Theta(n)\)</span>。</p><h1 id="section-4">32.4-5</h1><p>本题的分析框架和题目32.4-4的一样，只考虑<code>KMP-MATCHER</code>的主体部分。</p><p>令势函数<span class="math inline">\(\Phi(D_i)\)</span>表示第<span class="math inline">\(i\)</span>轮<code>for</code>循环结束后<span class="math inline">\(q\)</span>的值。由于<span class="math inline">\(q\)</span>的值在<code>for</code>循环开始前为<span class="math inline">\(0\)</span>，因此有<span class="math inline">\(\Phi(D_0)=0\)</span>。</p><p>令均摊开销<span class="math inline">\(\widehat{c_i}=c_i+\Phi(D_i)-\Phi(D_{i-1})\)</span>，其中<span class="math inline">\(c_i\)</span>表示真实开销。那么有<span class="math inline">\(\displaystyle{\sum_{i=1}^nc_i=\sum_{i=1}^n\widehat{c_i}-\Phi(D_n)+\Phi(D_0)}\)</span>。令每轮开销的均摊代价<span class="math inline">\(\widehat{c_i}=2\)</span>，那么有</p><p><span class="math inline">\(\begin{aligned}\sum_{i=1}^nc_i&amp;=\sum_{i=1}^n\widehat{c_i}-\Phi(D_n)+\Phi(D_0)\\&amp;\le \sum_{i=1}^nc_i+\Phi(D_0)\\ &amp;\le 2n\end{aligned}\)</span></p><p>因此<code>KMP-MATCHER</code>的第2-10行只需要<span class="math inline">\(\Theta(n)\)</span>的时间即可完成。第1行的<code>COMPUTE-PREFIX-FUNCTION</code>使用类似分析方式可以得到其运行时间为<span class="math inline">\(\Theta(m)\)</span>。由于<span class="math inline">\(m\len\)</span>，因此<code>KMP-MATCHER</code>的时间复杂度为<span class="math inline">\(\Theta(m)+\Theta(n)=\Theta(n)\)</span>。</p><h1 id="section-5">32.4-6</h1><p>按照题目给定的<span class="math inline">\(\pi&#39;\)</span>的定义，将<code>KMP-MATCHER</code>修改后的<code>KMP-MATCHER'</code>如下所示。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">COMPUTE-PREFIX-FUNCTION&#x27;(P, m)</span><br><span class="line">  π = COMPUTE-PREFIX-FUNCTION(P, m)</span><br><span class="line">  Let π&#x27;[1 : m - 1] be a new array</span><br><span class="line">  for q = 1 to m - 1</span><br><span class="line">    if π[q] == 0</span><br><span class="line">      π&#x27;[q] = 0</span><br><span class="line">    else if π[q] != 0 and P[π[q] + 1] == P[q + 1]</span><br><span class="line">      π&#x27;[q] = π&#x27;[π[q]]</span><br><span class="line">    else</span><br><span class="line">      π&#x27;[q] = π[q]</span><br><span class="line">  return π, π&#x27;</span><br><span class="line"></span><br><span class="line">KMP-MATCHER&#x27;(T, P, n, m)</span><br><span class="line">  π, π&#x27; = COMPUTE-PREFIX-FUNCTION(P, m)</span><br><span class="line">  q = 0</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    while q &gt; 0 and P[q + 1] != T[i]</span><br><span class="line">      q = π[q]</span><br><span class="line">    if P[q + 1] == T[i]</span><br><span class="line">      q = q + 1</span><br><span class="line">    if q == m</span><br><span class="line">      print &quot;Pattern occurs with shift&quot; i – m</span><br><span class="line">      q = π[q]</span><br></pre></td></tr></table></figure></p><p>接下来我们证明这个嵌套调用的<span class="math inline">\(\pi&#39;\)</span>是正确的。如果满足<span class="math inline">\(\pi&#39;\)</span>中定义的第一行和第三行的情况，那么就有<span class="math inline">\(\pi&#39;[q]=\pi[q]\)</span>，这和<code>KMP-MATCHER'</code>执行第5行的过程完全一致。</p><p>当满足<span class="math inline">\(\pi&#39;\)</span>的第二条情况时，即<span class="math inline">\(P[q+1]=P[\pi[q]+1]\)</span>，这种情况意味着在<code>KMP-MATCHER'</code>执行第5行的过程前后，都将会对<span class="math inline">\(P[q+1]\neq T[i]\)</span>和<span class="math inline">\(P[\pi [q]+1]\neqT[i]\)</span>进行判断。由于字母相同，这两种判断是没有必要的，<span class="math inline">\(\pi&#39;\)</span>将会跳到下一个和<span class="math inline">\(P[q+1]\)</span>不相同的字符<span class="math inline">\(P[\pi&#39; [q]+1]\)</span>再和<span class="math inline">\(T[i]\)</span>进行比较。因此这个过程是正确的。</p><p><span class="math inline">\(\pi&#39;\)</span>数组的存在是一个对<code>KMP-MATCHER</code>的优化，但是它不会降低<code>KMP-MATCHER</code>的时间复杂度。只有当<span class="math inline">\(T\)</span>的长度远大于<span class="math inline">\(P\)</span>的长度时，<span class="math inline">\(\pi&#39;\)</span>数组会对<code>KMP-MATCHER</code>带来常数上的优化。# 32.4-7</p><p><span class="math inline">\(T\)</span>是<span class="math inline">\(T&#39;\)</span>的旋转串，当且仅当<span class="math inline">\(T&#39;\)</span>出现在<span class="math inline">\(TT\)</span>中。因此这相当于执行了一次<code>KMP-MATCHER</code>算法。具体过程由<code>IS-CYCLIC-ROTATION</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">IS-CYCLIC-ROTATION(T, T&#x27;, m)</span><br><span class="line">  π = COMPUTE-PREFIX-FUNCTION(P, m)</span><br><span class="line">  q = 0</span><br><span class="line">  S = TT</span><br><span class="line">  for i = 1 to m + m</span><br><span class="line">    while q &gt; 0 and T[q + 1] != S[i]</span><br><span class="line">      q = π[q]</span><br><span class="line">    if T[q + 1] == S[i]</span><br><span class="line">      q = q + 1</span><br><span class="line">    if i &gt; m and q == m</span><br><span class="line">      print &quot;T&#x27; is T with shift&quot; i – m</span><br><span class="line">      q = π[q]</span><br></pre></td></tr></table></figure><h1 id="star-32.4-8"><span class="math inline">\(\star\)</span>32.4-8</h1><p>基于KMP算法的<span class="math inline">\(\pi\)</span>数组计算转移函数<span class="math inline">\(\delta\)</span>的算法由<code>COMPUTE-TRANSITION-FUNCTION-KMP</code>所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">COMPUTE-TRANSITION-FUNCTION-KMP(P, ∑, m)</span><br><span class="line">  π = COMPUTE-PREFIX-FUNCTION(P, m)</span><br><span class="line">  for each character a ∈ ∑</span><br><span class="line">    δ(0, a) = 0</span><br><span class="line">  δ(0, P[1]) = 1</span><br><span class="line">  for q = 1 to m</span><br><span class="line">    for each character a ∈ ∑</span><br><span class="line">      if q &lt; m and P[q + 1] == a</span><br><span class="line">        δ(q, a) = q + 1</span><br><span class="line">      else</span><br><span class="line">        δ(q, a) = δ(π[q], a)</span><br><span class="line">  return δ</span><br></pre></td></tr></table></figure><p>可见第2-4行对<span class="math inline">\(\delta(0,\cdot)\)</span>处理的正确性是显而易见的，在一开始没有接受到任何字符时，只有接受到正确的字符<span class="math inline">\(P[1]\)</span>时，才可以从状态<span class="math inline">\(0\)</span>转移到状态<span class="math inline">\(1\)</span>。第7-8行的处理同样也是显而易见的，遇到正确的字符那么就向前一个状态进位。</p><p>接下来证明另一种情况，即第9-10行的情况。按照<span class="math inline">\(\delta\)</span>的定义，可见<span class="math inline">\(\delta(q,a)=\sigma(P[:q]a)\)</span>，将<span class="math inline">\(\pi[q]\)</span>视为前面的<span class="math inline">\(q\)</span>，也有<span class="math inline">\(\delta(\pi[q],a)=\sigma(P[:\pi[q]]a)\)</span>。按照<span class="math inline">\(\pi\)</span>数组的定义，由于<span class="math inline">\(P[: \pi[q]]\sqsupset P[:q]\)</span>，因此<span class="math inline">\(P[:\pi[q]]a\sqsupset P[:q]a\)</span>，从而<span class="math inline">\(\sigma(P[:\pi[q]]a)\le\sigma(P[:q]a)\)</span>。由于<span class="math inline">\(\pi[q]=\sigma(P[:q])\)</span>，因此<span class="math inline">\(P[:q]\)</span>后面添加一个字符<span class="math inline">\(a\)</span>后，可以得到<span class="math inline">\(\pi[q]\ge \sigma(P[:q]a)-1\)</span>，因为<span class="math inline">\(\sigma\)</span>的函数值最多只会增加<span class="math inline">\(1\)</span>，这意味着<span class="math inline">\(\sigma(P[:\pi [q]]a)\ge\sigma(P[:q]a)\)</span>。</p><p>因此，最终可以得到<span class="math inline">\(\sigma(P[:\pi[q]]a)=\sigma(P[:q]a)\)</span>，即<span class="math inline">\(\delta(\pi[q],a)=\delta(q,a)\)</span>，原结论成立。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论32.3 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-3-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-3-Exercises/</id>
    <published>2023-10-07T16:57:22.000Z</published>
    <updated>2023-10-07T16:57:22.748Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">32.3-1</h1><p>本题的状态集合<span class="math inline">\(Q=\{0,1,2,3,4,5\}\)</span>，起始状态<span class="math inline">\(q_0=0\)</span>，接受状态为<span class="math inline">\(\{5\}\)</span>。</p><p>针对模式串<span class="math inline">\(P=\texttt{aabab}\)</span>在字符集<span class="math inline">\(\Sigma=\{a,b\}\)</span>上的状态函数<span class="math inline">\(\delta(s,c)\)</span>如下表所示。</p><p><span class="math inline">\(\begin{array}{|c|c|c|c|c|c|c|}\hlines&amp;0&amp;1&amp;2&amp;3&amp;4&amp;5\\\hline\texttt{a}&amp;1&amp;2&amp;2&amp;4&amp;2&amp;1\\\hline\texttt{b}&amp;0&amp;0&amp;3&amp;0&amp;5&amp;0\\\hline\end{array}\)</span></p><p>由此，对于文本串<span class="math inline">\(T=\texttt{aaababaabaababaab}\)</span>，它的状态转移序列为<span class="math inline">\(0,1,2,2,3,4,5,1,2,3,4,2,3,4,5,1,2,3\)</span>，由此<span class="math inline">\(P\)</span>在<span class="math inline">\(T\)</span>中出现了两次，分别为偏移量为<span class="math inline">\(1\)</span>和<span class="math inline">\(9\)</span>时出现。</p><h1 id="section-1">32.3-2</h1><p>本题的状态集合<span class="math inline">\(Q=\{0,1,2,3,\dots,20,21\}\)</span>，起始状态<span class="math inline">\(q_0=0\)</span>，接受状态为<span class="math inline">\(\{21\}\)</span>。</p><p>针对模式串<span class="math inline">\(P=\texttt{ababbabbababbababbabb}\)</span>在字符集<span class="math inline">\(\Sigma=\{a,b\}\)</span>上的状态函数<span class="math inline">\(\delta(s,c)\)</span>如下表所示。</p><p><span class="math inline">\(\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}\hlines&amp;0&amp;1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8&amp;9&amp;10&amp;11&amp;12&amp;13&amp;14&amp;15&amp;16&amp;17&amp;18&amp;19&amp;20&amp;21\\\hline\texttt{a}&amp;1&amp;1&amp;3&amp;1&amp;3&amp;6&amp;1&amp;3&amp;9&amp;1&amp;11&amp;1&amp;3&amp;14&amp;1&amp;16&amp;1&amp;3&amp;19&amp;1&amp;3&amp;9\\\hline\texttt{b}&amp;0&amp;2&amp;0&amp;4&amp;5&amp;0&amp;7&amp;8&amp;0&amp;10&amp;0&amp;12&amp;13&amp;0&amp;15&amp;8&amp;17&amp;18&amp;0&amp;20&amp;21&amp;0\\\hline\end{array}\)</span></p><h1 id="section-2">32.3-3</h1><p>假设<span class="math inline">\(P\)</span>的长度为<span class="math inline">\(m\)</span>。<span class="math inline">\(P[:k]\sqsupset P[:q]\)</span>推导出<span class="math inline">\(k=0\lork=q\)</span>意味着这个字符串只要产生了一次失配，那么就必须从头开始匹配，这意味着任何不以<span class="math inline">\(P[1]\)</span>为开头的字符串是<span class="math inline">\(P\)</span>的一个前缀，因此，这种模式串一般是<span class="math inline">\(\forall i\in[2,n],P[1]\neq P[i]\)</span>成立。</p><p>对于这种模式串，它的状态转移函数<span class="math inline">\(\delta(s,c)(s\in[0,m],c\in\Sigma)\)</span>如下：</p><p><span class="math inline">\(\delta(s,c)= \left\{\begin{aligned}  &amp;0 &amp; &amp; \text{if}\quad s=m\lor s&lt;m\land P[s+1]\neq c \\  &amp;s+1 &amp; &amp; \text{if}\quad s&lt;c\landP[s+1]=c \\ \end{aligned}\right.\)</span></p><h1 id="section-3">32.3-4</h1><p>由于<span class="math inline">\(x\sqsupset y\)</span>，因此有<span class="math inline">\(|x|\le |y|\)</span>。又因为<span class="math inline">\(x,y\)</span>同为<span class="math inline">\(P\)</span>的前缀，因此有<span class="math inline">\(x\sqsubset y\)</span>。</p><p>按照<span class="math inline">\(\sigma\)</span>的定义，有<span class="math inline">\(\sigma(x)= |x|\)</span>。但是因为<span class="math inline">\(x\sqsubset y,x\sqsupset y\)</span>，因此<span class="math inline">\(\sigma(y)\ge |x|\)</span>。最终有<span class="math inline">\(\sigma(x)\le \sigma(y)\)</span>。</p><h1 id="section-4">32.3-5</h1><p>最少的状态数即为合并<span class="math inline">\(P\)</span>和<span class="math inline">\(P&#39;\)</span>的最长公共前缀作为共同状态。更一般的说，令<span class="math inline">\(P\)</span>和<span class="math inline">\(P&#39;\)</span>的最长公共前缀的状态为<span class="math inline">\(r=\max\{i:P[:i]=P&#39;[:i]\}\)</span>，那么一共有<span class="math inline">\(|P|+|P&#39;|-r-1\)</span>个状态，直到第<span class="math inline">\(r\)</span>个字符之后，状态才会被分开。具体构建过程由<code>COMPUTE-TRANSITION-FUNCTION'</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">COMPUTE-TRANSITION-FUNCTION&#x27;(P, m, P&#x27;, m&#x27;, ∑)</span><br><span class="line">  r = 0</span><br><span class="line">  while k &lt; m amd k &lt; m&#x27; and P[r + 1] == P&#x27;[r + 1]</span><br><span class="line">    r += 1</span><br><span class="line">  for q = 0 to m</span><br><span class="line">    for each character a ∈ ∑</span><br><span class="line">      k = min &#123;m, q + 1&#125;</span><br><span class="line">    while P[:k] is not a suffix of P[:q]a</span><br><span class="line">      k = k – 1</span><br><span class="line">      δ(q, a) = k</span><br><span class="line">  for each q = r + 1 to m&#x27;</span><br><span class="line">    for each character a ∈ ∑</span><br><span class="line">      k = min &#123;m, q + 1&#125;</span><br><span class="line">    while P&#x27;[:k] is not a suffix of P&#x27;[:q]a</span><br><span class="line">      k = k – 1</span><br><span class="line">    if k &lt;= r</span><br><span class="line">      δ(q + m, a) = k</span><br><span class="line">    else</span><br><span class="line">      δ(q + m, a) = m + k</span><br><span class="line">  return δ</span><br></pre></td></tr></table></figure><h1 id="section-5">32.3-6</h1><p>对于包含通配符<span class="math inline">\(\Diamond\)</span>的一个模式串<span class="math inline">\(P\)</span>，假设我们将其划分成切割成一个个不包含通配符<span class="math inline">\(\Diamond\)</span>的模式串<span class="math inline">\(P_1,P_2,\dots,P_k\)</span>，那么将这些状态进行“首尾相接”即可，因为只要进行到当前的模式串<span class="math inline">\(P_i\)</span>，那么就不能转移到以前的模式串。可见将会一共有<span class="math inline">\(|P|+1\)</span>个状态。</p><p>具体过程由<code>COMPUTE-TRANSITION-FUNCTION-GAP</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">COMPUTE-TRANSITION-FUNCTION-GAP(P, ∑, m)</span><br><span class="line">  split P into Q[1], Q[2], ..., Q[k] by &#x27;◊&#x27;</span><br><span class="line">  pre = 0</span><br><span class="line">  for i = 1 to k</span><br><span class="line">    δt = COMPUTE-TRANSITION-FUNCTION-GAP(Q[i], ∑, |Q[i]|)</span><br><span class="line">    for s = 0 to |Q[i]|</span><br><span class="line">      for each character a ∈ ∑</span><br><span class="line">        δ(pre + s, a) = δt(s, a)</span><br><span class="line">    pre = pre + |Q[i]|</span><br><span class="line">  return δ</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论32.2 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-2-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-2-Exercises/</id>
    <published>2023-10-07T16:57:19.000Z</published>
    <updated>2023-10-07T16:57:19.479Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">32.2-1</h1><p>可见，<span class="math inline">\(p=26\bmod 11=4\)</span>。</p><p>按照算法<code>RABIN-KARP-MATCHER</code>的执行结果，可以计算出的<span class="math inline">\(t_s\)</span>值如下标：</p><p><span class="math inline">\(\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}\hlines&amp;0&amp;1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8&amp;9&amp;10&amp;11&amp;12&amp;13&amp;14\\\hlinet_s&amp;9&amp;3&amp;8&amp;4&amp;4&amp;4&amp;4&amp;10&amp;9&amp;2&amp;3&amp;1&amp;9&amp;2&amp;5\\\hline\end{array}\)</span></p><p>可见一共有<span class="math inline">\(4\)</span>次命中，但是仅有偏移<span class="math inline">\(6\)</span>是有效偏移，因此其余的偏移<span class="math inline">\(3,4,5\)</span>都是伪命中。</p><h1 id="section-1">32.2-2</h1><p>这题的思想比较简单：首先求出<span class="math inline">\(k\)</span>个模式串的<span class="math inline">\(p\)</span>值<span class="math inline">\(p_1,p_2,\dots,p_k\)</span>，并且使用一个基于链接法的哈希表来存储这些<span class="math inline">\(p\)</span>值和对应的字符串。只要哈希表的大小合适，那么只需要<span class="math inline">\(O(1)\cdot O(m(v+n/q))=O(m(v+n/q))\)</span>，其中<span class="math inline">\(v\)</span>是有效偏移的数量。需要注意的是，只有<span class="math inline">\(p_1,p_2,\dots,p_k\)</span>都是长度为<span class="math inline">\(m\)</span>的情况下才能使用该算法<code>RABIN-KARP-MATCHER'</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">RABIN-KARP-MATCHER&#x27;(T, P, n, k, m, d, q)</span><br><span class="line">  h = d^(m - 1) mod q</span><br><span class="line">  let p[1 : k] be a new array by 0</span><br><span class="line">  let T be a new hash-table.</span><br><span class="line">  t0 = 0</span><br><span class="line">  for i = 1 to m</span><br><span class="line">    t0 = (d * t0 + T[i]) mod q</span><br><span class="line">    for j = 1 to k</span><br><span class="line">    p[j] = (d * p[j] + P[j, i]) mod q</span><br><span class="line">  for j = 1 to k</span><br><span class="line">    let x be a new node</span><br><span class="line">    x.key = p[j]</span><br><span class="line">    x.p = P[j]</span><br><span class="line">    // 节点x存的是字符串和它的哈希值。</span><br><span class="line">    CHAINED-HASH-INSERT(T, x)</span><br><span class="line">  //假设CHAINED-HASH-SEARCH&#x27;返回的是哈希表中和x.key相同的所有节点，而并非只是至多一个；hash是一个哈希函数。</span><br><span class="line">  for s = 0 to n - m</span><br><span class="line">    for v, pat in CHAINED-HASH-SEARCH&#x27;(T, hash(t_s))</span><br><span class="line">      if v == t_s </span><br><span class="line">        if pat[1 : m] == T[s + 1 : s + m]</span><br><span class="line">          print &quot;Pattern &quot; pat &quot; occur with shifts&quot; s</span><br><span class="line">    if s &lt; n - m</span><br><span class="line">      t_&#123;s + 1&#125; = (d * (t_s - T[s + 1] * h) + T[s + m + 1]) mod q</span><br></pre></td></tr></table></figure><p>对于模式串不等长的情况下，不能够使用上述哈希表的情况，只能分别独立地进行查询。通过数组模拟各种查询情况，最终整个过程由程序<code>RABIN-KARP-MATCHER''</code>给出，其时间复杂度为<span class="math inline">\(O(km(v+n/q))\)</span>，其中<span class="math inline">\(v\)</span>是有效偏移的数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RABIN-KARP-MATCHER&#x27;&#x27;(T, P, n, k, d, q)</span><br><span class="line">  h = d^(m - 1) mod q</span><br><span class="line">  let p[1 : k] be a new array by 0</span><br><span class="line">  let T be a new hash-table.</span><br><span class="line">  for j = 1 to k</span><br><span class="line">    t0 = 0</span><br><span class="line">    for i = 1 to |P[j]|</span><br><span class="line">      p[j] = (d * p[j] + P[j, i]) mod q</span><br><span class="line">      t0 = (d * t0 + T[i]) mod q</span><br><span class="line">    for s = 0 to n - |P[j]|</span><br><span class="line">      if p == t_s</span><br><span class="line">        if P[j, 1 : |P[j]|] == T[s + 1 : s + m]</span><br><span class="line">          print &quot;Pattern &quot; P[j] &quot; occur with shifts&quot; s</span><br><span class="line">      if s &lt; n - m</span><br><span class="line">        t_&#123;s + 1&#125; = (d * (t_s - T[s + 1] * h) + T[s + m + 1]) mod q</span><br></pre></td></tr></table></figure><h1 id="section-2">32.2-3</h1><p>这道题的本质思想是将二维的情况转化为一维。对于每相邻<span class="math inline">\(m\)</span>行，我们先预处理出一个长度为<span class="math inline">\(n\)</span>的数组<span class="math inline">\(U\)</span>，然后再在数组<span class="math inline">\(U\)</span>上处理一维的情况，注意处理一行<span class="math inline">\(U\)</span>的情况时，不像<code>RABIN-KARP-MATCHER</code>那样以<span class="math inline">\(d\)</span>作为进制，而是以<span class="math inline">\(d&#39;=d^m\)</span>来作为进制。和<code>RABIN-KARP-MATCHER</code>同样的是，判断一个字符矩阵对应的值<span class="math inline">\(t\)</span>是否和<span class="math inline">\(p\)</span>相同只需要<span class="math inline">\(O(1)\)</span>的时间即可完成。</p><p>一共需要判断<span class="math inline">\((n-m+1)^2\)</span>种情况，因此在最坏情况下，这个二维版本的算法将会达到<span class="math inline">\(O((n-m)+1^2 \cdotm^2)=O(n^4)\)</span>。具体过程由<code>RABIN-KARP-MATCHER-2D</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">RABIN-KARP-MATCHER-2D(T, P, n, m, d, q)</span><br><span class="line">  ha = d ^ (m * (m-1)) mod q</span><br><span class="line">  hr = d ^ (m-1) mod q</span><br><span class="line">  d&#x27; = d ^ m mod q</span><br><span class="line">  p = 0</span><br><span class="line">  for j = 1 to m</span><br><span class="line">    for i = 1 to m</span><br><span class="line">      p = (d * p + P[i, j]) mod q</span><br><span class="line">  let U[1 : n] be a new array by 0</span><br><span class="line">  for j = 1 to n</span><br><span class="line">    for i = 1 to m</span><br><span class="line">      U[j] = (d * U[j] + T[i, j]) mod q</span><br><span class="line">  for rs = 0 to n - m</span><br><span class="line">    u0 = 0</span><br><span class="line">    for j = 1 to m</span><br><span class="line">      u0 = (d&#x27; * u0 + U[j]) mod q</span><br><span class="line">    for cs = 0 to n - m</span><br><span class="line">      if p == ts</span><br><span class="line">        if P[1 : m,1 : m] == T[rs + 1:rs + m,cs + 1:cs + m]</span><br><span class="line">          print &quot;Pattern occurs with shift&quot; (rs, cs)</span><br><span class="line">      if cs &lt; n - m</span><br><span class="line">        u_&#123;cs + 1&#125; = (d&#x27; * (u_&#123;cs&#125; - U[cs + 1] * ha) + U[cs + m + 1]) mod q</span><br><span class="line">    if rs &lt; n - m</span><br><span class="line">      for j = 1 to n</span><br><span class="line">        U[j] = (d * (u[j] - T[rs + 1, j] * ha) + T[rs + m + 1, j]) mod q</span><br></pre></td></tr></table></figure><h1 id="section-3">32.2-4</h1><p>考虑令<span class="math inline">\(\displaystyle{f(A,B,x)=\left(\sum_{i=0}^{n-1}(a_i-b_i)x^i\right)\bmodq}\)</span>。</p><p>如果两个文件相同，那么也就是说<span class="math inline">\(\foralli\in[0,n),a_i=b_i\)</span>均成立，那么此时任取<span class="math inline">\(x\in[0,q)\)</span>，都必定有<span class="math inline">\(A(x)=B(x)\)</span>。</p><p>否则，非零多项式<span class="math inline">\(f(A,B,x)\)</span>的次数至多为<span class="math inline">\(n\)</span>。由于<span class="math inline">\(q\)</span>是一个质数，依照题目31.4-4的结论，方程<span class="math inline">\(f(A,B,x)=0\)</span>最多有<span class="math inline">\(n\)</span>个不同的根。由于<span class="math inline">\(x\)</span>是从<span class="math inline">\([0,q)\)</span>中选择的，因此任取<span class="math inline">\(x\in [0,q),f(A,B,x)=0\)</span>的概率至多为<span class="math inline">\(\dfrac{n}{q}\)</span>。由于<span class="math inline">\(q&gt;10^3\cdot n\)</span>，因此<span class="math inline">\(f(A,B,x)=0\)</span>的概率不会超过<span class="math inline">\(10^{-3}\)</span>，原结论成立。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论32.1 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-1-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-1-Exercises/</id>
    <published>2023-10-07T16:57:15.000Z</published>
    <updated>2023-10-07T17:08:43.355Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">32.1-1</h1><p>令<span class="math inline">\(t(s)(s\le n-m)\)</span>表示偏移为<span class="math inline">\(s\)</span>时，进行的匹配次数，那么这些匹配次数由下表给出：</p><p><span class="math inline">\(\begin{array}{|c|l|c|c|}\hlines&amp;\mathtt{000010001010001} &amp;t(s)&amp;\text{is matched}\\\hline0&amp;\mathtt{0001}&amp;4&amp;\text{No}\\\hline 1&amp;\mathtt{\0001}&amp;4&amp;\text{Yes}\\\hline 2&amp;\mathtt{\ \0001}&amp;3&amp;\text{No}\\\hline 3&amp;\mathtt{\ \ \0001}&amp;2&amp;\text{No}\\\hline 4&amp;\mathtt{\ \ \ \0001}&amp;1&amp;\text{No}\\\hline 5&amp;\mathtt{\ \ \ \ \0001}&amp;4&amp;\text{Yes}\\\hline 6&amp;\mathtt{\ \ \ \ \ \0001}&amp;3&amp;\text{No}\\\hline 7&amp;\mathtt{\ \ \ \ \ \ \0001}&amp;2&amp;\text{No}\\\hline 8&amp;\mathtt{\ \ \ \ \ \ \ \0001}&amp;1&amp;\text{No}\\\hline 9&amp;\mathtt{\ \ \ \ \ \ \ \ \0001}&amp;2&amp;\text{No}\\\hline 10&amp;\mathtt{\ \ \ \ \ \ \ \ \ \0001}&amp;1&amp;\text{No}\\\hline 11&amp;\mathtt{\ \ \ \ \ \ \ \ \ \ \0001}&amp;4&amp;\text{Yes}\\\hline \end{array}\)</span></p><h1 id="section-1">32.1-2</h1><p>如果<span class="math inline">\(P\)</span>的各个字母都不相同，那么可以考虑从左到右遍历文本串<span class="math inline">\(T\)</span>，考察<span class="math inline">\(T\)</span>中和<span class="math inline">\(P[1]\)</span>相同的那些下标。由于<span class="math inline">\(P\)</span>中的字符各不相同，因此对于一对相邻都是字符<span class="math inline">\(P[1]\)</span>的下标<span class="math inline">\(i,j(i&lt;j)\)</span>，只有<span class="math inline">\(i+|P|\le j\)</span>时，偏移量<span class="math inline">\(i+1\)</span>才有可能是正确的，这时只需要检测一下即可。</p><p>由于<span class="math inline">\(S\)</span>中的每个字符和<span class="math inline">\(P\)</span>中的字符至多只会进行一次匹配，因此这个算法的时间复杂度为<span class="math inline">\(O(n)\)</span>。具体过程由<code>NAIVE-STRING-MATCHER'</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NAIVE-STRING-MATCHER(T, P, n, m)</span><br><span class="line">  cnt = n + 1</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    if T[i] == P[1]</span><br><span class="line">      cnt = 1</span><br><span class="line">    else</span><br><span class="line">      cnt = cnt + 1</span><br><span class="line">    if cnt == m and P[1:m] == T[i - cnt + 1:i]</span><br><span class="line">      print &quot;Pattern occurs with shift&quot; i - cnt</span><br></pre></td></tr></table></figure><h1 id="section-2">32.1-3</h1><p>对于文本串<span class="math inline">\(T\)</span>的偏移量<span class="math inline">\(s\)</span>，它能和模式串<span class="math inline">\(P\)</span>的第<span class="math inline">\(j\)</span>个字符比较当且仅当<span class="math inline">\(T[s+1:s+j-1]=P[1:j-1]\)</span>，这个概率值为<span class="math inline">\(d^{-(j-1)}\)</span>。</p><p>令随机变量<span class="math inline">\(X_{s}\)</span>表示偏移量为<span class="math inline">\(s\)</span>时，<span class="math inline">\(T[s+j-1]\)</span>和<span class="math inline">\(P[j]\)</span>发生了比较。那么有<span class="math inline">\(X_{s,j}=d^{-(j-1)}\)</span>。</p><p>令随机变量<span class="math inline">\(\displaystyle{Y=\sum_{s=0}^{n-m}\sum_{j=1}^{m}X_{ij}}\)</span>表示比较次数，那么有：</p><p><span class="math inline">\(\begin{aligned}E[Y]&amp;=\sum_{s=0}^{n-m}\sum_{j=1}^{m}E[X_{ij}]\\&amp;=\sum_{s=0}^{n-m}\sum_{j=1}^{m}\dfrac{1}{d^{j-1}}\\&amp;=\sum_{s=0}^{n-m}\dfrac{d-d^{1-m}}{d-1}\\&amp;=(n-m+1)\cdot\dfrac{d-d^{1-m}}{d-1}\\&amp;=(n-m+1)\cdot\dfrac{1-d^{m}}{1-d^{-1}}\\&amp;\le(n-m+1)\cdot\dfrac{1}{1-d^{-1}}\\&amp;\le(n-m+1)\cdot\dfrac{1}{1-2^{-1}}\\ &amp;\le2(n-m+1)\end{aligned}\)</span></p><h1 id="section-3">32.1-4</h1><p>本题可以使用动态规划进行求解。令状态<span class="math inline">\(f(i,j)(0\le i\le m,0\le j\lem)\)</span>表示使用<span class="math inline">\(P\)</span>的前<span class="math inline">\(i\)</span>个字符是否能匹配<span class="math inline">\(T\)</span>的前<span class="math inline">\(j\)</span>个字符。那么可以写出如下状态转移方程：</p><p><span class="math inline">\(f(i,j)= \left \{\begin{aligned}  &amp;1&amp; &amp; \text{if}\quad i=0\land j=0 \\  &amp;0 &amp; &amp;\text{if}\quad i=0\land j&gt;0\lor i&gt;0\land j=0\landP[i]\neq\Diamond\land f(i-1,0)=0 \\  &amp;\bigvee_{k=0}^j f(i-1,k) &amp;&amp; \text{if}\quad i&gt;0\land P[i]=\Diamond\\  &amp;f(i-1,j-1)\land\mathbf{1}\{P[i]=S[j]\} &amp; &amp; \text{if}\quad i&gt;0\landj&gt;0\land P[i]\neq\Diamond\\ \end{aligned}\right.\)</span></p><p>其中<span class="math inline">\(\mathbf{1}\{b\}\)</span>表示一个示性函数，用于表示布尔表达式<span class="math inline">\(b\)</span>是否成立。方程第三行表示这里有一个通配符<span class="math inline">\(\Diamond\)</span>，它可以匹配任意长度的字符串，因此可以从任意状态<span class="math inline">\(f(i-1,k)\)</span>转移到<span class="math inline">\(f(i,j)(k\lej)\)</span>，方程的第四行用于表示一个普通字符的匹配。</p><p>最终答案为<span class="math inline">\(f(m,n)\)</span>。</p><p>使用前缀和可以将这个转移优化到<span class="math inline">\(O(nm)\)</span>，因此可以在多项式时间复杂度内完成这个问题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论29 Problems 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/29-Problems/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/29-Problems/</id>
    <published>2023-10-04T06:40:13.000Z</published>
    <updated>2023-10-04T06:40:13.149Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">29-1</h1><h2 id="a">a</h2><p>假设现在存在一个标准型线性规划的算法<code>LP-SOLVER-A(A, b, c)</code>（其中<span class="math inline">\(\mathbf{A,b}\)</span>表示约束，<span class="math inline">\(\mathbf{c}\)</span>表示目标函数对应的向量，最大化<span class="math inline">\(\mathbf{c}^T\mathbf{x}\)</span>的值），那么按照定理29.5，这个算法无非就返回<span class="math inline">\(3\)</span>种结果：</p><ol type="1"><li>一个达到最优目标值的向量<span class="math inline">\(\mathbf{x}\)</span>。</li><li><code>"unbounded"</code>，即无界。</li><li><code>"infeasible"</code>，即这个约束不可行。</li></ol><p>那么线性不等式可行性问题检测算法<code>LINEAR-INEQUALITY-FEASIBILITY</code>用于检测标准型线性不等式可行性，只需要调用<code>LP-SOLVER-A</code>作为子程序即可。更具体的过程如下给出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LINEAR-INEQUALITY-FEASIBILITY(A, b, m, n):</span><br><span class="line">  let c[1 : n] be a new array</span><br><span class="line">  sol = LP-SOLVE-A(A, b, c)</span><br><span class="line">  if sol != &quot;infeasible&quot;</span><br><span class="line">    return sol</span><br><span class="line">  return NIL</span><br></pre></td></tr></table></figure><p>这个过程用到的变量和约束的个数分是<span class="math inline">\(n,m\)</span>，即它们本身。</p><h2 id="b">b</h2><p>如果一个标准型线性规划<span class="math inline">\(L\)</span>存在一个有限最优解（最大值），那么其对偶问题也存在一个有限最优解（最小值）。如果我们令这个最大值和最小值相等，再交由<code>LINEAR-INEQUALITY-FEASIBILITY-A</code>求出一个可行解即可。</p><p>更具体地说，线性规划<span class="math inline">\(L\)</span>可行当且仅当下面关于<span class="math inline">\(\mathbf{x,y}\)</span>的线性不等式是否可行：</p><p><span class="math inline">\(\begin{aligned}\mathbf{A}\mathbf{x}&amp;\le\mathbf{b}\\\mathbf{A}^T\mathbf{y}&amp;\ge\mathbf{c}\\\mathbf{c}^T\mathbf{x}&amp;=\mathbf{b}^T\mathbf{y}\\ \mathbf{x}&amp;\ge0\\ \mathbf{y}&amp;\ge 0\\ \end{aligned}\)</span></p><p>如果<span class="math inline">\(L\)</span>是无界的，那么上面的线性不等式同样是不可行的。因此，我们下一步只需要判断<span class="math inline">\(L\)</span>是否为可行，从而区分出无界和不可行这两种情况。只需要进行两次判断以区分这<span class="math inline">\(3\)</span>种情况即可。更具体的情况由<code>LP-SOLVE</code>给出，假定<code>LINEAR-INEQUALITY-FEASIBILITY-A</code>是用于求解标准型线性不等式可行性的算法。最终求解线性规划算法由<code>LP-SOLVE</code>给出。</p><p>将上面的线性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">LP-SOLVE(A, b, c, m, n)</span><br><span class="line">  sol1 = LINEAR-INEQUALITY-FEASIBILITY-A(A, b, m, n)</span><br><span class="line">  if sol1 == NIL</span><br><span class="line">    return &quot;infeasible&quot;</span><br><span class="line">  let A&#x27;[2 * n + 2 * m + 2, n + m] be a new table by 0</span><br><span class="line">  let b&#x27;[2 * n + 2 * m + 2] be a new array by 0</span><br><span class="line">  for i = 1 to m</span><br><span class="line">    for j = 1 to n</span><br><span class="line">      A&#x27;[i, j] = A[i, j]</span><br><span class="line">      A&#x27;[m + j][n + i] = A[i, j]</span><br><span class="line">  for i = 1 to m</span><br><span class="line">    A[m + n + 1][n + i] = -b[i]</span><br><span class="line">    A[m + n + 2][n + i] = b[i]</span><br><span class="line">  for j = 1 to n</span><br><span class="line">    A[m + n + 1][j] = c[j]</span><br><span class="line">    A[m + n + 2][j] = -c[j]</span><br><span class="line">  for k = 1 to m + n</span><br><span class="line">    A[m + n + 2 + k][k] = -1</span><br><span class="line">  for i = 1 to m</span><br><span class="line">    b&#x27;[i] = b[i]</span><br><span class="line">  for j = 1 to n</span><br><span class="line">    b&#x27;[m + i] = c[j]</span><br><span class="line">  sol2 = LINEAR-INEQUALITY-FEASIBILITY-A(A, b, 2 * n + 2 * m + 2, n + m)</span><br><span class="line">  if sol2 == NIL</span><br><span class="line">    return &quot;unbounded&quot;</span><br><span class="line">  else</span><br><span class="line">    return sol2</span><br></pre></td></tr></table></figure><p>对上面的线性不等式标准化后，将会有<span class="math inline">\(2n+2m+2\)</span>条不等式，<span class="math inline">\(n+m\)</span>个变量，它们仍然是<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>的多项式。</p><h1 id="section-1">29-2</h1><h2 id="a-1">a</h2><p>该线性规划<span class="math inline">\(L\)</span>给出的最优可行解为<span class="math inline">\(\mathbf{x}^{\ast}=(x_1,x_2,x_3)=(8,4,0)\)</span>，对于其对偶线性规划，其最优可行解为<span class="math inline">\(\mathbf{y}^{\ast}=(y_1,y_2,y_3)=(0,1/6,2/3)\)</span>。令<span class="math inline">\(\mathbf{A}\)</span>表示原约束的系数矩阵，可以知道，<span class="math inline">\(\mathbf{Ax}^{\ast}=(12,24,36)^T,\mathbf{A}^T\mathbf{y}=(3,1,13/6)^T\)</span>。将<span class="math inline">\(\mathbf{A}^T\mathbf{y^{\ast}}\)</span>和<span class="math inline">\(\mathbf{x}^{\ast}\)</span>以及<span class="math inline">\(\mathbf{Ax}\)</span>和<span class="math inline">\(\mathbf{y}^{\ast}\)</span>相对比即可完成验证。</p><h2 id="b-1">b</h2><p>必要性：假设互补松驰性成立，那么有<span class="math inline">\(\displaystyle{\sum_{j=1}^nc_j\overline{x}_j=\sum_{j=1}^n\sum_{i=1}^ma_{ij}\overline{y}_i\overline{x}_j}\)</span>。原因在于，考虑每个<span class="math inline">\(j\in[1,n]\)</span>，如果<span class="math inline">\(\overline{x}_j=0\)</span>，那么<span class="math inline">\(\displaystyle{c_j\overline{x}_j=0,\overline{x}_j\cdot\sum_{i=1}^ma_{ij}\overline{y}_i=0}\)</span>，等式<span class="math inline">\(\displaystyle{c_j\overline{x}_j=\sum_{i=1}^ma_{ij}\overline{y}_i\overline{x}_j}\)</span>成立；如果<span class="math inline">\(\overline{x}_j=0\)</span>不成立，那么按照互补松弛性，此时有<span class="math inline">\(\displaystyle{\sum_{i=1}^ma_{ij}\overline{y}_i=c_j}\)</span>，等式<span class="math inline">\(\displaystyle{c_j\overline{x}_j=\sum_{i=1}^ma_{ij}\overline{y}_i\overline{x}_j}\)</span>依旧成立。因此有<span class="math inline">\(\displaystyle{\sum_{j=1}^nc_j\overline{x}_j=\sum_{j=1}^n\sum_{i=1}^ma_{ij}\overline{y}_i\overline{x}_j}\)</span>。</p><p>可以用类似的方法证明<span class="math inline">\(\displaystyle{\sum_{i=1}^mb_i\overline{y}_i=\sum_{i=1}^m\sum_{j=1}^na_{ij}\overline{x}_j\overline{y}_i}\)</span>。考虑每个<span class="math inline">\(i\in[1,m]\)</span>，如果<span class="math inline">\(\overline{y}_i=0\)</span>，那么<span class="math inline">\(\displaystyle{b_i\overline{y}_i=0,y_i\cdot\sum_{j=1}^n}a_{ij}\overline{x}_j=0\)</span>，等式<span class="math inline">\(\displaystyle{b_i\overline{y}_i=\sum_{j=1}^na_{ij}\overline{x}_j\overline{y}_i}\)</span>成立。如果<span class="math inline">\(\overline{y}_i=0\)</span>不成立，那么按照互补松弛性，此时有<span class="math inline">\(\displaystyle{\sum_{j=1}^na_{ij}\overline{x}_j=b_i}\)</span>，等式<span class="math inline">\(\displaystyle{b_i\overline{y}_i=\sum_{j=1}^na_{ij}\overline{x}_j\overline{y}_i}\)</span>依旧成立。因此有<span class="math inline">\(\displaystyle{\sum_{i=1}^mb_i\overline{y}_i=\sum_{i=1}^m\sum_{j=1}^na_{ij}\overline{x}_j\overline{y}_i}\)</span>。</p><p>由于<span class="math inline">\(\displaystyle{\sum_{j=1}^n\sum_{i=1}^ma_{ij}\overline{y}_i\overline{x}_j=\sum_{i=1}^m\sum_{j=1}^na_{ij}\overline{x}_j\overline{y}}\)</span>，因此有<span class="math inline">\(\displaystyle{\sum_{j=1}^nc_j\overline{x}_j=\sum_{i=1}^m b_i\overline{y}_i}\)</span>，即<span class="math inline">\(\mathbf{c}^T\overline{\mathbf{x}}=\mathbf{b}^T\overline{\mathbf{y}}\)</span>。</p><p>按照定理29.4，<span class="math inline">\(\overline{\mathbf{x}},\overline{\mathbf{y}}\)</span>分别是原线性规划和对偶线性规划的最优解，原结论成立。</p><p>充分性：我们将使用反证法完成证明。假设现在<span class="math inline">\(\mathbf{x}^{\ast},\mathbf{y}^{\ast}\)</span>分别是原线性规划和对偶线性规划的最优解。假设<span class="math inline">\(\exists i\in[1,m]\)</span>满足<span class="math inline">\(y_i^{\ast}\neq 0\)</span>，并且有<span class="math inline">\(\displaystyle{\sum_{j=1}^na_{ij}x_j^{\ast}&lt;b_i}\)</span>，使用必要性种类似的计算过程，可以得到：</p><p><span class="math inline">\(\begin{aligned} \sum_{j=1}^nc_jx_j^{\ast}&amp;=\sum_{j=1}^n\sum_{i=1}^ma_{ij}y_i^{\ast}x_j^{\ast}\\&amp;=\sum_{i=1}^m\sum_{j=1}^n a_{ij}x_j^{\ast}y_i^{\ast}\\&amp;&lt;\sum_{i=1}^m\sum_{j=1}^n b_iy_i^{\ast}\\\end{aligned}\)</span></p><p>按照定理29.4，<span class="math inline">\(\overline{\mathbf{x}},\overline{\mathbf{y}}\)</span>必定不是原线性规划和对偶线性规划的最优解，因此原结论成立。</p><p>对于另外一种情况的证明过程类似，假设<span class="math inline">\(\exists j\in[1,n]\)</span>满足<span class="math inline">\(x_j^{\ast}\neq 0\)</span>，并且有<span class="math inline">\(\displaystyle{\sum_{i=1}^ma_{ij}y_i^{\ast}&gt;c_j}\)</span>，使用必要性种类似的计算过程，可以得到：</p><p><span class="math inline">\(\begin{aligned} \sum_{j=1}^nc_jx_j^{\ast}&amp;&lt;\sum_{j=1}^n\sum_{i=1}^ma_{ij}y_i^{\ast}x_j^{\ast}\\&amp;=\sum_{i=1}^m\sum_{j=1}^n a_{ij}x_j^{\ast}y_i^{\ast}\\&amp;=\sum_{i=1}^m\sum_{j=1}^n b_iy_i^{\ast}\\\end{aligned}\)</span></p><p>同样的，<span class="math inline">\(\overline{\mathbf{x}},\overline{\mathbf{y}}\)</span>必定不是原线性规划和对偶线性规划的最优解，因此原结论成立。</p><p>因此原结论成立。</p><h2 id="c">c</h2><p>本题使用29-2-b的结论即可直接证明。 充分性：由于<span class="math inline">\(\mathbf{x}^{\ast}\)</span>是原线性规划的最优解，令<span class="math inline">\(\mathbf{y}^{\ast}\)</span>是对偶线性规划的最优解，那么其必定满足条件1。按照题目29-2-b的结论，条件2和3都成立。由此充分性成立。</p><p>必要性：条件1说明了<span class="math inline">\(\overline{\mathbf{y}}\)</span>是对偶线性规划的一个可行解，根据题目29-2-b的结论，条件2和条件3说明了构造出来的可行解<span class="math inline">\(\overline{\mathbf{x,y}}\)</span>都是各自线性规划的最优解。由此必要性成立。</p><p>因此原结论成立。</p><h1 id="section-2">29-3</h1><h2 id="a-2">a</h2><p>证明过程和在线性规划时期，对引理29.1的证明过程完全相同。不失一般性，假设现在需要证明的整数规划是标准型。</p><p>令<span class="math inline">\(\mathbf{x}\)</span>是原整数规划的一个可行解，<span class="math inline">\(\mathbf{y}\)</span>是对偶整数规划的一个可行解，那么有</p><p><span class="math inline">\(\begin{aligned}\mathbf{c}^T\overline{\mathbf{x}}&amp;\le(\mathbf{A}^T\overline{\mathbf{y}})^T\overline{\mathbf{x}}\\&amp;=\overline{\mathbf{y}}^T\mathbf{A}\overline{\mathbf{x}}\\&amp;\le\overline{\mathbf{y}}^T\mathbf{b} \end{aligned}\)</span></p><p>因此原结论成立。</p><h2 id="b-2">b</h2><p>考虑如下单个变量<span class="math inline">\(x\)</span>的标准型整数规划：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;x\\ \text{subject to}&amp; \\ &amp;&amp;x&amp;\le\dfrac{1}{2}\\&amp;&amp;x&amp;\ge 0 \end{aligned}\)</span></p><p>可以发现其最优可行解只有<span class="math inline">\(x=0\)</span>，目标函数值为<span class="math inline">\(0\)</span>。</p><p>那么其对偶整数规划为：</p><p><span class="math inline">\(\begin{aligned} \text{mimimize}&amp;&amp;\dfrac{1}{2}y\\ \text{subject to}&amp; \\ &amp;&amp;y&amp;\ge 1\\&amp;&amp;y&amp;\ge 0 \end{aligned}\)</span></p><p>可以发现其最优可行解为<span class="math inline">\(y=1\)</span>，目标函数值为<span class="math inline">\(\dfrac{1}{2}\)</span>。</p><p>由于它们的最优解不相同，因此整数规划不满足对偶性。</p><h2 id="c-1">c</h2><p>不失一般性，假设现在需要证明的整数规划是标准型。</p><p>令<span class="math inline">\(L_I\)</span>是一个标准型整数规划，<span class="math inline">\(L\)</span>是<span class="math inline">\(L_I\)</span>除去整数约束后所得到的线性规划，<span class="math inline">\(L_I^D\)</span>是<span class="math inline">\(L_I\)</span>的对偶整数规划，<span class="math inline">\(L^D\)</span>是<span class="math inline">\(L\)</span>的对偶线性规划。那么<span class="math inline">\(P,D\)</span>分别是<span class="math inline">\(L,L^D\)</span>的目标函数值。按照定理29.4，有<span class="math inline">\(P=D\)</span>。</p><p>由于<span class="math inline">\(L_I\)</span>是<span class="math inline">\(L\)</span>添加上了整数约束而来，因此<span class="math inline">\(L_I\)</span>的可行域必定是<span class="math inline">\(L\)</span>的可行域的子集。这意味着在<span class="math inline">\(L\)</span>中的最优解必定不劣于<span class="math inline">\(L_I\)</span>中的最优解，因此有<span class="math inline">\(IP\le P\)</span>；类似的，在<span class="math inline">\(L^D\)</span>中的最优解必定不劣于<span class="math inline">\(L^D_I\)</span>中的最优解，因此有<span class="math inline">\(ID\ge D\)</span>。</p><p>最终有等式<span class="math inline">\(IP\le P=D\le ID\)</span>。</p><h1 id="section-3">29-4</h1><p>这里的证明参考了这篇<a href="https://people.orie.cornell.edu/dpw/orie6300/fall2008/Lectures/lec07.pdf">文章</a>。</p><p>首先列出<strong>原始</strong>Farkas引理：</p><h2 id="farkas引理">Farkas引理</h2><p>给定<span class="math inline">\(M\in\mathbb{R}^{(m+1)\timesn},g\in\mathbb{R}^{m+1}\)</span>，如下两种陈述只有一种成立：</p><ol type="1"><li><span class="math inline">\(\exists \mathbf{v}\in\mathbb{R}^{n},\mathbf{Mv=g},\mathbf{v}\ge \mathbf{0}\)</span></li><li><span class="math inline">\(\exists \mathbf{w}\in\mathbb{R}^{m+1},\mathbf{M}^T\mathbf{w}\ge\mathbf{0},\mathbf{g}^T\mathbf{w}&lt;0\)</span></li></ol><hr><p>接下来证明题目中给定的<strong>变种</strong>Farkas引理。第一步则是使用反证法证明<strong>至多</strong>只有一个陈述成立。假设这两个陈述都成立，那么我们针对<span class="math inline">\(\mathbf{v,w}\)</span>的存在性，可以列出：</p><p><span class="math inline">\(\begin{aligned} \mathbf{Mv}&amp;\le\mathbf{g}\\ \mathbf{w}^T\mathbf{M}&amp;=\mathbf{0}\\\mathbf{w}^T\mathbf{g}&amp;&lt;\mathbf{0} \end{aligned}\)</span></p><p>对第一条不等式左乘上一个恒非负的向量<span class="math inline">\(\mathbf{w^T}\)</span>，得到<span class="math inline">\(\mathbf{w}^T\mathbf{Mv}\le\mathbf{w}^T\mathbf{g}\)</span>，即得到<span class="math inline">\(\mathbf{w}^T\mathbf{g}=\mathbf{0}\)</span>，和第三条不等式矛盾，因此这两个陈述至多只有一个成立。</p><p>接下来证明第2个陈述和如下第3个陈述是等价的：</p><ol start="3" type="1"><li><span class="math inline">\(\exists \mathbf{w}\in\mathbb{R}^{m+1}\)</span>，使得<span class="math inline">\(\mathbf{w}\ge\mathbf{0},\mathbf{M}^T\mathbf{w}=0,\mathbf{w}^T\mathbf{g}=-1\)</span>。</li></ol><p>必要性显然成立，因为<span class="math inline">\(\mathbf{w}^T\mathbf{g}=-1&lt;0\)</span>，从而第2个陈述也是成立的。接下来证明充分性，令<span class="math inline">\(\mathbf{w&#39;}=-\dfrac{1}{\mathbf{w}^T\mathbf{g}}\cdotw\)</span>，那么由于<span class="math inline">\(-\dfrac{1}{\mathbf{w}^T\mathbf{g}}&lt;0\)</span>，因此<span class="math inline">\(\mathbf{w&#39;}\ge 0\)</span>仍然成立；<span class="math inline">\(\mathbf{w&#39;}^T\mathbf{g}=\dfrac{1}{\mathbf{w}^T\mathbf{g}}\cdot(\mathbf{w}^T\mathbf{g})=-1\)</span>；此外，<span class="math inline">\(\mathbf{w&#39;}^T\mathbf{M}=-\dfrac{1}{\mathbf{w}^T\mathbf{g}}\cdot(\mathbf{w}^T\mathbf{M})=0\)</span>，最终<span class="math inline">\(\mathbf{w&#39;}\)</span>的存在说明充分性成立。由此，第2个陈述和第3个陈述等价。</p><p>假设现在第2个陈述不成立，那么第3个陈述也不成立。那么可以将<span class="math inline">\(\mathbf{M}^T\mathbf{w}=\mathbf{0},\mathbf{g}^T\mathbf{w}=-1\)</span>重写成<span class="math inline">\(\mathbf{A}=(\mathbf{M},\mathbf{g})^T,\mathbf{b}=(0,0,\dots,0,-1)^T\)</span>。</p><p>由于第3个陈述不成立，这意味着<span class="math inline">\(\nexists\mathbf{x}\in\mathbb{R}^{m+1},\mathbf{x}\ge 0\)</span>使得<span class="math inline">\(\mathbf{Ax=b}\)</span>。也就是说，这时不满足<strong>原始</strong>Farkas引理的第1个陈述，那么这意味着<strong>原始</strong>Farkas引理第2个陈述必须成立，因此通过这条陈述，给出了<span class="math inline">\(\exists\mathbf{y}\in\mathbb{R}^{n+1},\mathbf{A}^T\mathbf{y}\ge0,\mathbf{b}^T\mathbf{y}&lt;0\)</span>。</p><p>令<span class="math inline">\(\mathbf{y}=\begin{pmatrix}\mathbf{z}\\\lambda\end{pmatrix}\)</span>，其中<span class="math inline">\(\mathbf{z}\in \mathbb{R}^n,\lambda\in\mathbb{R}\)</span>。由于<span class="math inline">\(\mathbf{b}^T\)</span>前<span class="math inline">\(n\)</span>个分量都是<span class="math inline">\(0\)</span>，因此<span class="math inline">\(\mathbf{b}^T\mathbf{y}=-\lambda&lt;0\)</span>，因此得到<span class="math inline">\(\lambda&gt;0\)</span>。<span class="math inline">\(\mathbf{A}^T\mathbf{y}\ge 0\)</span>意味着<span class="math inline">\(\begin{pmatrix}\mathbf{M}&amp;\mathbf{g}\end{pmatrix}\begin{pmatrix}\mathbf{z}\\\lambda\end{pmatrix}\ge0\)</span>，这给出了<span class="math inline">\(\mathbf{Mz}+\lambda\mathbf{g}\ge 0\)</span>，即<span class="math inline">\(\mathbf{M}(-\mathbf{z}/\lambda)\leg\)</span>。向量<span class="math inline">\((-\mathbf{z}/\lambda)\)</span>的存在证明了<strong>变种</strong>Farkas引理的第1条陈述是正确的，因此原结论成立。</p><h1 id="section-4">29-5</h1><h2 id="a-3">a</h2><p>由于删除了一些约束，因此这个问题的线性规划可以从最小费用流问题转化而来：</p><p><span class="math inline">\(\begin{aligned} \text{minimize}&amp;&amp;\sum_{(u,v)\in E}a(u,v)\cdot f_{uv}\\ \text{subject to}&amp; \\&amp;&amp;f_{uv}&amp;\le c(u,v) &amp;&amp;\forall (u,v)\in E \\&amp;&amp;f_{uv}&amp;\ge 0 &amp;&amp;\forall (u,v)\in E \\&amp;&amp;\sum_{(u,v)\in E} f_{uv}&amp;=\sum_{(v,u)\in E} f_{vu}&amp;&amp;\forall u\in V \end{aligned}\)</span></p><h2 id="b-3">b</h2><p>由于花费函数<span class="math inline">\(a(u,v)&gt;0\)</span>，并且线性规划的目标函数是最小化费用。因此线性规划的最优方案将是：不使用任何边进行流动，那么这样将不会产生任何花费。因此，这个流是的大小为<span class="math inline">\(0\)</span>。</p><h2 id="c-2">c</h2><p>不失一般性，我们可以删除<span class="math inline">\(E\)</span>中<span class="math inline">\((t,s)\)</span>的边，这不会减少最大流的值。</p><p>我们构造图<span class="math inline">\(G&#39;=(V&#39;,E&#39;)\)</span>，其中<span class="math inline">\(V&#39;=V,E&#39;=E\cup\{(t,s)\}\)</span>。令<span class="math inline">\(a(t,s)=-1,c(t,s)=+\infty\)</span>，对于<span class="math inline">\(\forall(u,v)\in E\)</span>，都有<span class="math inline">\(a(u,v)=0,c(u,v)\)</span>为原最大流问题中，有向边<span class="math inline">\((u,v)\)</span>的容量。考虑新构造后的图<span class="math inline">\(G&#39;\)</span>，以及对应的容量函数<span class="math inline">\(c\)</span>和费用函数<span class="math inline">\(a\)</span>，那么最大流问题就相当于解决如此一个最小费用流通问题。</p><p>在<span class="math inline">\(G&#39;\)</span>中，如果一个“流”从<span class="math inline">\(t\)</span>流动到<span class="math inline">\(s\)</span>，那么将会有一个真正的流从<span class="math inline">\(s\)</span>流动到<span class="math inline">\(t\)</span>。并且由于<span class="math inline">\(a(t,s)=-1\)</span>，因此线性规划算法将会“激励”尽量多的流产生，并且产生一个真正的流并不会添加任何代价。由于<span class="math inline">\(c(t,s)=+\infty\)</span>，因此这将不会限制从<span class="math inline">\(s\)</span>到<span class="math inline">\(t\)</span>的流产生。</p><p>最终，舍去变量<span class="math inline">\(f_{ts}\)</span>的值（或者是让其值为<span class="math inline">\(0\)</span>），那么计算出的一组解<span class="math inline">\(f\)</span>为原图<span class="math inline">\(G\)</span>上的最大流。</p><h2 id="d">d</h2><p>令<span class="math inline">\(\displaystyle{A=1+\sum_{(u,v)\inE}a(u,v)}\)</span>，其中<span class="math inline">\(a(u,v)\)</span>是从<span class="math inline">\(u\)</span>到<span class="math inline">\(v\)</span>的距离。也就是说，<span class="math inline">\(M\)</span>是一个足够大的数，但并非是无穷大。</p><p>同样的，不失一般性，我们可以删除<span class="math inline">\(E\)</span>中<span class="math inline">\(s\)</span>的所有入边，这不会增加从<span class="math inline">\(s\)</span>到任意节点的最短路径。</p><p>可以构造图<span class="math inline">\(G&#39;=(V&#39;,E&#39;)\)</span>，其中<span class="math inline">\(V&#39;=V,E&#39;=E\cup\{(v,s):v\inV-\{s\}\}\)</span>。<span class="math inline">\(\forall (v,s)\inE&#39;\)</span>，令<span class="math inline">\(c(v,s)=1,a(v,s)=-A\)</span>。<span class="math inline">\(\forall (u,v)\inE,c(u,v)=+\infty,a(u,v)\)</span>为原最短路问题中，从<span class="math inline">\(u\)</span>到<span class="math inline">\(v\)</span>的距离边权。考虑新构造后的图<span class="math inline">\(G&#39;\)</span>，以及对应的容量函数<span class="math inline">\(c\)</span>和费用函数<span class="math inline">\(a\)</span>，那么最短路问题就相当于解决如此一个最小费用流通问题。</p><p>在<span class="math inline">\(G&#39;\)</span>中，任意一条<strong>简单路径</strong>的长度都小于<span class="math inline">\(A\)</span>。因此在一个最小费用流通问题中，使用边<span class="math inline">\((v,s)\inE&#39;\)</span>一定是更优的。对于任意<span class="math inline">\(v\inV-\{s\}\)</span>，这意味着必定有一个流从<span class="math inline">\(s\)</span>到达<span class="math inline">\(v\)</span>，并且这个流的费用是最小的，这时从<span class="math inline">\(s\)</span>到<span class="math inline">\(v\)</span>的这个流恰好就对应了原问题的最短路径。</p><p>最终，舍去所有变量<span class="math inline">\(f_{vs}(s\inV-\{s\})\)</span>（或者是让其值为<span class="math inline">\(0\)</span>）。对于任意节点<span class="math inline">\(v\in V-\{s\}\)</span>，求出从<span class="math inline">\(s\)</span>到<span class="math inline">\(v\)</span>的最短路径，需要从<span class="math inline">\(v\)</span>开始，逐渐向前移动，找到这个流的起点即可。最终处理出来的流就是对应最短路径。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论29.3 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/29-3-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/29-3-Exercises/</id>
    <published>2023-10-04T06:40:10.000Z</published>
    <updated>2023-10-04T06:40:10.016Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">29.3-1</h1><p>该线性规划的对偶线性规划为：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;50y_1+100y_2+25y_3\\ \text{subject to}&amp; \\&amp;&amp;-2y_1+5y_2+3y_3&amp;\le 1\\ &amp;&amp;8y_1+2y_2-5y_3&amp;\le1\\ &amp;&amp;0y_1+0y_2+10y_3&amp;\le 1\\&amp;&amp;10y_1+0y_2-2y_3&amp;\le 1\\ &amp;&amp;y_1,y_2,y_3&amp;\ge 0\end{aligned}\)</span></p><h1 id="section-1">29.3-2</h1><p>整个过程分成两个步骤进行：</p><ol type="1"><li><p>是将所有约束的比较符号的方向统一化。不失一般性，如果现在需要将除去非负约束以外的<span class="math inline">\(\ge\)</span>的约束转化成<span class="math inline">\(\le\)</span>的约束，那么只需要对原约束两侧乘上<span class="math inline">\(-1\)</span>，并将比较符号反向即可。</p></li><li><p>假设经第1个步骤处理后，原线性规划的目标函数为<span class="math inline">\(\mathbf{c}^T\mathbf{x}\)</span>，并且朝某一个方向优化（最大/最小），约束是<span class="math inline">\(\mathbf{A}^T\mathbf{x}\circ\mathbf{b}\)</span>，其中<span class="math inline">\(\circ\in\{\le,\ge\}\)</span>。那么原线性规划的对偶线性规划的目标函数是<span class="math inline">\(\mathbf{b}^T\mathbf{y}\)</span>，并且朝<strong>另一个</strong>方向优化（最小/最大），约束是<span class="math inline">\(\mathbf{A}^T\mathbf{y}\overline{\circ}\mathbf{c}\)</span>，即将统一前的比较符号均取反即可。</p></li></ol><h1 id="section-2">29.3-3</h1><p>我们可以给出最大流问题线性规划的标准型为：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;\sum_{(s,v)\in E} f_{sv}-\sum_{(v,s)\in E} f_{vs}\\ \text{subjectto}&amp; \\ &amp;&amp;f_{uv}&amp;\le c(u,v) &amp;&amp;\forall (u,v)\in E\\ &amp;&amp;f_{uv}&amp;\ge 0 &amp;&amp;\forall (u,v)\in E \\&amp;&amp;\sum_{(u,v)\in E} f_{uv}-\sum_{(v,u)\in E} f_{vu}&amp;\le 0&amp;&amp;\forall u\in V-\{s,t\}\\ &amp;&amp;\sum_{(v,u)\in E}f_{vu}-\sum_{(u,v)\in E} f_{uv}&amp;\le 0 &amp;&amp;\forall u\inV-\{s,t\} \end{aligned}\)</span></p><p>可见，令左边的系数矩阵为<span class="math inline">\(\mathbf{A}\)</span>，其大小为<span class="math inline">\((2|V|+2|E|-4)\times |E|\)</span>，右边的<span class="math inline">\(\mathbf{b}\)</span>是一个<span class="math inline">\(2|V|+2|E|-4\)</span>维的向量，其目标函数<span class="math inline">\(\mathbf{c}^T\mathbf{x}\)</span>中的向量<span class="math inline">\(\mathbf{c}^T\)</span>长度为<span class="math inline">\(|E|\)</span>。因此最大流问题的对偶线性规划为</p><p><span class="math inline">\(\begin{aligned} \text{minimize}&amp;&amp;\mathbf{b}^T\mathbf{y}\\ \text{subject to}&amp; \\&amp;&amp;\mathbf{A}^T\mathbf{y}&amp;\ge\mathbf{c}\end{aligned}\)</span></p><h1 id="section-3">29.3-4</h1><p>我们可以给出最小费用流问题线性规划的统一符号方向后的结果为：</p><p><span class="math inline">\(\begin{aligned} \text{minimize}&amp;&amp;\sum_{(u,v)\in E} a(u,v)\cdot f_{uv}\\ \text{subject to}&amp; \\&amp;&amp;f_{uv}&amp;\le c(u,v) &amp;&amp;\forall (u,v)\in E \\&amp;&amp;f_{uv}&amp;\ge 0 &amp;&amp;\forall (u,v)\in E \\&amp;&amp;\sum_{(u,v)\in E} f_{uv}-\sum_{(v,u)\in E} f_{vu}&amp;\le 0&amp;&amp;\forall u\in V-\{s,t\}\\ &amp;&amp;\sum_{(v,u)\in E}f_{vu}-\sum_{(u,v)\in E} f_{uv}&amp;\le 0 &amp;&amp;\forall u\inV-\{s,t\}\\ &amp;&amp;\sum_{(s,v)\in E} f_{sv}-\sum_{(v,s)\in E}f_{vs}&amp;\le d\\ &amp;&amp;\sum_{(v,s)\in E} f_{vs}-\sum_{(s,v)\in E}f_{sv}&amp;\le -d \end{aligned}\)</span></p><p>可见，令左边的系数矩阵为<span class="math inline">\(\mathbf{A}\)</span>，其大小为<span class="math inline">\((2|V|+2|E|-2)\times |E|\)</span>，右边的<span class="math inline">\(\mathbf{b}\)</span>是一个<span class="math inline">\(2|V|+2|E|-2\)</span>维的向量，其目标函数<span class="math inline">\(\mathbf{c}^T\mathbf{x}\)</span>中的向量<span class="math inline">\(\mathbf{c}^T\)</span>长度为<span class="math inline">\(|E|\)</span>。因此最小费用流问题的对偶线性规划为</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;\mathbf{b}^T\mathbf{y}\\ \text{subject to}&amp; \\&amp;&amp;\mathbf{A}^T\mathbf{y}&amp;\ge\mathbf{c}\end{aligned}\)</span></p><h1 id="section-4">29.3-5</h1><p>不失一般性，这里仅考虑标准型的线性规划：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;\mathbf{c}^T\mathbf{x}\\ \text{subject to}&amp; \\&amp;&amp;\mathbf{A}\mathbf{x}&amp;\le\mathbf{b}\\&amp;&amp;\mathbf{x}&amp;\ge\mathbf{0} \end{aligned}\)</span></p><p>按照定义，其对偶线性规划为：</p><p><span class="math inline">\(\begin{aligned} \text{minimize}&amp;&amp;\mathbf{b}^T\mathbf{y}\\ \text{subject to}&amp; \\&amp;&amp;\mathbf{A}^T\mathbf{y}&amp;\ge\mathbf{c}\\&amp;&amp;\mathbf{y}&amp;\ge\mathbf{0} \end{aligned}\)</span></p><p>该对偶线性规划的对偶线性规划为：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;\mathbf{c}^T\mathbf{x&#39;}\\ \text{subject to}&amp; \\&amp;&amp;\mathbf{A}\mathbf{x&#39;}&amp;\le\mathbf{b}\\&amp;&amp;\mathbf{x&#39;}&amp;\ge\mathbf{0} \end{aligned}\)</span></p><p>可见，第一个线性规划和第三个线性规划的形式是完全一致的，因此一个线性规划对偶的对偶是它本身。</p><h1 id="section-5">29.3-6</h1><p>最大流问题中，推论24.5最大流的值的上界被最小割值限制着，这可以被解释成最大流问题的弱对偶。</p><h1 id="section-6">29.3-7</h1><p>本题以分类讨论为主。</p><p>对于原线性规划：</p><ul><li>当<span class="math inline">\(r&gt;0,s&lt;0\)</span>时，原线性规划的可行域是<span class="math inline">\(\varnothing\)</span>，因此它不可行。</li><li>当<span class="math inline">\(r&gt;0,s\ge0\)</span>时，原线性规划的可行域是<span class="math inline">\(0\le x\les/r\)</span>。此时目标值必定是有限的。</li><li>当<span class="math inline">\(r=0,s&lt;0\)</span>时，原线性规划的可行域是<span class="math inline">\(\varnothing\)</span>，因此它不可行。</li><li>当<span class="math inline">\(r=0,s\ge0\)</span>时，原线性规划的可行域是<span class="math inline">\(x\ge0\)</span>。如果<span class="math inline">\(t\le0\)</span>，那么其目标值有限，否则是无界的。</li><li>当<span class="math inline">\(r&lt;0,s&lt;0\)</span>时，原线性规划的可行域是<span class="math inline">\(x\ge s/r\)</span>。如果<span class="math inline">\(t\le0\)</span>，那么其目标值有限，否则是无界的。</li><li>当<span class="math inline">\(r&lt;0,s\ge0\)</span>时，原线性规划的可行域是<span class="math inline">\(x\ge0\)</span>。如果<span class="math inline">\(t\le0\)</span>，那么其目标值有限，否则是无界的。</li></ul><p>可见这个线性规划的对偶线性规划是：</p><p><span class="math inline">\(\begin{aligned} \text{minimize}&amp;&amp;sy\\ \text{subject to}&amp; \\ &amp;&amp;ry&amp;\ge t\\&amp;&amp;y&amp;\ge0 \end{aligned}\)</span></p><ul><li>当<span class="math inline">\(r&gt;0,t\le0\)</span>时，对偶线性规划的可行域是<span class="math inline">\(y\ge0\)</span>。如果<span class="math inline">\(s\ge0\)</span>，那么其目标值有限，否则是无界的。</li><li>当<span class="math inline">\(r&gt;0,t&gt;0\)</span>时，对偶线性规划的可行域是<span class="math inline">\(y\ge t/r\)</span>。如果<span class="math inline">\(s\ge0\)</span>，那么其目标值有限，否则是无界的。</li><li>当<span class="math inline">\(r=0,t\le0\)</span>时，对偶线性规划的可行域是<span class="math inline">\(y\ge0\)</span>。如果<span class="math inline">\(s\ge0\)</span>，那么其目标值有限，否则是无界的。</li><li>当<span class="math inline">\(r=0,t&gt;0\)</span>时，对偶线性规划的可行域是<span class="math inline">\(\varnothing\)</span>，因此它不可行。</li><li>当<span class="math inline">\(r&lt;0,t\le0\)</span>时，对偶线性规划的可行域是<span class="math inline">\(0\lex\le t/r\)</span>。此时目标值必定是有限的。</li><li>当<span class="math inline">\(r&lt;0,t&gt;0\)</span>时，对偶线性规划的可行域是<span class="math inline">\(\varnothing\)</span>，因此它不可行。</li></ul><p>综上所述：</p><ol type="1"><li>当<span class="math inline">\((r=0\land s\ge 0\land t\le0)\lor(r&gt;0\land r&gt;0\land s\ge 0)\lor(r&lt;0\land t\le0)\)</span>为真时，满足第一个断言。</li><li>当<span class="math inline">\((r=0\land s\ge 0\land t&gt;0)\lor(r&lt;0\land t&gt; 0)\)</span>为真时，满足第二个断言。</li><li>当<span class="math inline">\((r=0\land s&lt; 0\land t\le0)\lor(r&gt;0\land s&lt; 0)\)</span>为真时，满足第三个断言。</li><li>当<span class="math inline">\(r=0\land s&lt; 0\land t&gt;0\)</span>为真时，满足第四个断言。</li></ol><h1 id="section-7">29.3-8</h1><p>如果一个线性规划无解，即不存在一个向量<span class="math inline">\(\mathbf{x}\)</span>满足各个约束，那么说明这个标准线性规划是不可行的。</p><p>否则，必定存在一系列可行解，使得多个向量<span class="math inline">\(\mathbf{x}\)</span>满足这些约束。如果这个线性规划没有有限的最优目标值，那么说明这个可行域必定是无界的。否则按照最优性（即要么最大，要么最小），有一个有限目标值的最优解。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论29.2 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/29-2-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/29-2-Exercises/</id>
    <published>2023-10-04T06:40:06.000Z</published>
    <updated>2023-10-04T06:40:06.717Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">29.2-1</h1><p>这个最短路问题的对应线性规划问题如下：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;d_x\\ \text{subject to}&amp; \\ &amp;&amp;d_t&amp;\le d_s+3\\&amp;&amp;d_y&amp;\le d_s+5\\ &amp;&amp;d_x&amp;\le d_t+6\\&amp;&amp;d_y&amp;\le d_t+2\\ &amp;&amp;d_z&amp;\le d_x+2\\&amp;&amp;d_t&amp;\le d_y+1\\ &amp;&amp;d_x&amp;\le d_y+4\\&amp;&amp;d_z&amp;\le d_y+6\\ &amp;&amp;d_s&amp;\le d_z+3\\&amp;&amp;d_x&amp;\le d_z+7\\ &amp;&amp;d_s&amp;=0\end{aligned}\)</span></p><h1 id="section-1">29.2-2</h1><p>这和第29.2章介绍的线性规划系统类似，如下给出：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;\sum_{v\in V} d_v\\ \text{subject to}&amp; \\ &amp;&amp;d_v&amp;\led_u+w(u,v) &amp;&amp;\forall (u,v)\in E \\ &amp;&amp;d_s&amp;=0\end{aligned}\)</span></p><p>两条约束和29.2所给出的约束相同，区别在于目标函数。由于目前是希望最大化所有变量<span class="math inline">\(d_v\)</span>，但是最短路径的松弛性质仍然保持，因此这时的最优解对应了<span class="math inline">\(s\)</span>到所有节点的最短路径长度。</p><h1 id="section-2">29.2-3</h1><p>这个最大流问题的对应线性规划问题如下：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;f_{sv_1}+f_{sv_2}\\ \text{subject to}&amp; \\ &amp;&amp;f_{uv}&amp;\ge 0&amp;&amp;\forall (u,v)\in E \\ &amp;&amp;f_{sv_1}&amp;\le 16\\&amp;&amp;f_{sv_2}&amp;\le 14\\ &amp;&amp;f_{v_1v_3}&amp;\le 12\\&amp;&amp;f_{v_2v_1}&amp;\le 4\\ &amp;&amp;f_{v_2v_4}&amp;\le 14\\&amp;&amp;f_{v_3v_2}&amp;\le 9\\ &amp;&amp;f_{v_3v_t}&amp;\le 20\\&amp;&amp;f_{v_4v_3}&amp;\le 7\\ &amp;&amp;f_{v_4t}&amp;\le 4\\&amp;&amp;f_{sv_1}+f_{v_2v_1}&amp;= f_{v_1v_3}\\&amp;&amp;f_{sv_2}+f_{v_3v_2}&amp;= f_{v_2v_1}+f_{v_2v_4}\\&amp;&amp;f_{v_1v_3}+f_{v_4v_3}&amp;= f_{v_3v_2}+f_{v_3t}\\&amp;&amp;f_{v_2v_4}&amp;= f_{v_4v_3}+f_{v_4t}\\\end{aligned}\)</span></p><h1 id="section-3">29.2-4</h1><p>这里使用题目24.1-4的结果：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;\sum_{(s,v)\in E} f_{sv}-\sum_{(v,s)\in E} f_{vs}\\ \text{subjectto}&amp; \\ &amp;&amp;f_{uv}&amp;\ge 0 &amp;&amp;\forall (u,v)\in E \\&amp;&amp;f_{uv}&amp;\le c(u,v) &amp;&amp;\forall (u,v)\in E \\&amp;&amp;\sum_{(u,v)\in E} f_{uv}&amp;=\sum_{(v,u)\in E} f_{vu}&amp;&amp;\forall u\in V-\{s,t\} \end{aligned}\)</span></p><p>可见，这里一共有<span class="math inline">\(2|E|+|V|-2=O(V+E)\)</span>条约束。</p><h1 id="section-4">29.2-5</h1><p>令二分图<span class="math inline">\(G=(V,E),V=L\cupR\)</span>。使用第24.3章的结论，我们可以将这个问题转化成最大流问题进行解答：令<span class="math inline">\(V&#39;=V\cup\{s,t\},E&#39;=\{(s,l):l\inL\}\cup\{(r,t):r\in R\}\cup E\)</span>，对于<span class="math inline">\(\forall (u,v)\in E&#39;\)</span>，都有<span class="math inline">\(c(u,v)=1\)</span>。那么图<span class="math inline">\(G\)</span>的二分图最大匹配数量相当于是图<span class="math inline">\(G&#39;=(V&#39;,E&#39;)\)</span>中从<span class="math inline">\(s\)</span>到<span class="math inline">\(t\)</span>的最大流。这个线性规划将使用题目29.2-4的结论，如下：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;\sum_{l\in L}f_{sl} \\ \text{subject to}&amp; \\&amp;&amp;f_{uv}&amp;\ge 0 &amp;&amp;\forall (u,v)\in E&#39; \\&amp;&amp;f_{uv}&amp;\le c(u,v) &amp;&amp;\forall (u,v)\in E&#39; \\&amp;&amp;\sum_{(u,v)\in E&#39;} f_{uv}&amp;=\sum_{(v,u)\in E&#39;}f_{vu} &amp;&amp;\forall u\in V \end{aligned}\)</span></p><h1 id="section-5">29.2-6</h1><p>这意味着对于任意一条路径<span class="math inline">\(p_i\)</span>，如果其经过边<span class="math inline">\((u,v)\)</span>，那么这条路径就需要受到这条边容量的限制。因此，对于路径<span class="math inline">\(P\)</span>，我们可以写出如下线性规划：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;\sum_{i=1}^px_i \\ \text{subject to}&amp; \\ &amp;&amp;x_{i}&amp;\ge 0&amp;&amp;\forall i\in[1,p] \\ &amp;&amp;\sum_{1\le i\le p,(u,v)\inP_i}x_i&amp;\le c(u,v) &amp;&amp;\forall (u,v)\in E \\\end{aligned}\)</span></p><p>如果<span class="math inline">\(G\)</span>是一个有<span class="math inline">\(\dfrac{|V|(|V|-1)}{2}\)</span>条边的有向无环图，那么<span class="math inline">\(p\)</span>的值可以达到<span class="math inline">\(2^{|V|-2}\)</span>。因此使用这个线性规划求解最大流问题是不明智的，因为约束的大小和数量都太多（呈指数级数量）。</p><h1 id="section-6">29.2-7</h1><p>只需要对多商品流问题的目标函数进行修改即可。修改后的线性规划问题如下：</p><p><span class="math inline">\(\begin{aligned} \text{minimize}&amp;&amp;\sum_{(u,v)\in E}a(u,v)\cdot\left(\sum_{i=1}^k f_{i,u,v}\right) \\\text{subject to}&amp; \\ &amp;&amp;\sum_{i=1}^kf_{i,u,v}&amp;\le c(u,v)&amp;&amp;\forall (u,v)\in E\\ &amp;&amp;\sum_{(u,v)\inE}f_{i,u,v}-\sum_{(v,u)\in E}f_{i,v,u}&amp;= 0 &amp;&amp;\foralli\in[1,k],\forall u\in V-\{s_i,t_i\} \\ &amp;&amp;\sum_{(s_i,v)\inE}f_{i,s_i,v}-\sum_{(v,s_i)\in E}f_{i,v,s_i}&amp;= d_i &amp;&amp;\foralli\in[1,k]\\ &amp;&amp;f_{i,u,v}&amp;\ge 0 &amp;&amp;\foralli\in[1,k],\forall (u,v)\in E\\ \end{aligned}\)</span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论29.1 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/29-1-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/29-1-Exercises/</id>
    <published>2023-10-04T06:40:02.000Z</published>
    <updated>2023-10-04T06:47:57.910Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">29.1-1</h1><p><span class="math inline">\((0,7),(1,6),(2,5)\)</span>分别是这个线性规划的<span class="math inline">\(3\)</span>个可行解，其目标函数值分别为<span class="math inline">\(21,16,11\)</span>。</p><h1 id="section-1">29.1-2</h1><p><span class="math inline">\((7,3,0),(7,4,0),(7,5,0)\)</span>分别是这个线性规划的<span class="math inline">\(3\)</span>个可行解，其目标函数值分别为<span class="math inline">\(35,42,49\)</span>。</p><h1 id="section-2">29.1-3</h1><p>对第二条约束变形后，得到<span class="math inline">\(x_1+x_2\ge5\)</span>，这和第一条约束<span class="math inline">\(x_1+x_2\le2\)</span>是明显冲突的。因此，这个线性规划是不可行的。</p><h1 id="section-3">29.1-4</h1><p>考虑令<span class="math inline">\(x_1=2t,x_2=t\)</span>，那么目标函数为<span class="math inline">\(t\)</span>。当<span class="math inline">\(t\ge0\)</span>时，第一条约束化成<span class="math inline">\(-3t\le-1\)</span>，第二条约束化成<span class="math inline">\(-4t\le-2\)</span>，其余约束化成<span class="math inline">\(t\ge0\)</span>。哪怕<span class="math inline">\(t\)</span>趋向于正无穷，这些约束仍然是成立的。由于需要最大化目标值，那么目标值可以到达正无穷，因此这个线性规划是无界的。</p><h1 id="section-4">29.1-5</h1><p>构造出的线性规划问题如下：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;x_1+x_2\\ \text{subject to}&amp; \\ &amp;&amp;x_1+2x_2&amp;\le 4\\&amp;&amp;2x_1+x_2&amp;\le 5 \end{aligned}\)</span></p><p>虽然可行解是无界的，但是最优解只有一个：<span class="math inline">\((2,1)\)</span>，其目标值为<span class="math inline">\(3\)</span>。</p><h1 id="section-5">29.1-6</h1><h2 id="a">a</h2><p>只需要将等式约束<span class="math inline">\(\displaystyle{\sum_{j=1}^na_{ij}x_j=b_j}\)</span>替换成如下两个约束即可：</p><p><span class="math inline">\(\begin{aligned} \sum_{j=1}^n a_{ij}x_j&amp;\le b_i\\ \sum_{j=1}^n a_{ij}x_j &amp;\ge b_i\end{aligned}\)</span></p><h2 id="b">b</h2><p>将不等式约束<span class="math inline">\(\displaystyle{\sum_{j=1}^na_{ij}x_j\le b_j}\)</span>替换成如下两个约束即可：</p><p><span class="math inline">\(\begin{aligned} \sum_{j=1}^n a_{ij}x_j&amp;= b_i-s\\ s&amp;\ge 0 \end{aligned}\)</span></p><h1 id="section-6">29.1-7</h1><p>如果当前是对某个目标函数<span class="math inline">\(f(x)\)</span>最小化，那么其等价的最大化线性约束就是对目标函数<span class="math inline">\(g(x)=-f(x)\)</span>最大化。</p><p>令<span class="math inline">\(S\)</span>是第一个线性规划的可行域，<span class="math inline">\(x_0\in S\)</span>是其一个最优解。这意味着<span class="math inline">\(\forall x\in S\)</span>，都有<span class="math inline">\(f(x)\ge f(x_0)\)</span>。代入<span class="math inline">\(g(x)=-f(x)\)</span>，那么有<span class="math inline">\(f\forall x \in S\)</span>，均有<span class="math inline">\(g(x)\leg(x_0)\)</span>。因此，原线性规划和新线性规划是等价的。</p><h1 id="section-7">29.1-8</h1><p>还需要添加如下约束，以确保真实投票人数不会超过人口数：</p><p><span class="math inline">\(\begin{aligned}-2x_1+8x_2+0x_3+10x_4&amp;\le 100\\ 5x_1+2x_2+0x_3+0x_4&amp;\le 200\\3x_1-5x_2+10x_3-2x_4&amp;\le 50\\ \end{aligned}\)</span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论26 Problems 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/26-Problems/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/26-Problems/</id>
    <published>2023-10-01T11:28:03.000Z</published>
    <updated>2023-10-01T11:51:14.574Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">26-1</h1><h2 id="a">a</h2><p>使用得到<code>P-MAT-VEC-RECURSIVE</code>类似的方法对<code>SUM-ARRAYS</code>进行修改，同样可以得到其基于递归的并行版本<code>SUM-ARRAYS-RECURSIVE</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SUM-ARRAYS-RECURSIVE(A, B, C, i, i&#x27;)</span><br><span class="line">  if i == i&#x27;</span><br><span class="line">    C[i] = A[i] + B[i]</span><br><span class="line">  else</span><br><span class="line">    mid = ⌊(i + i&#x27;) / 2⌋</span><br><span class="line">    spawn SUM-ARRAYS-RECURSIVE(A, B, C, i, mid)</span><br><span class="line">    spawn SUM-ARRAYS-RECURSIVE(A, B, C, mid + 1, i&#x27;)</span><br><span class="line">    sync</span><br></pre></td></tr></table></figure><p>可见这个算法的工作量为<span class="math inline">\(T_1(n)=\Theta(n)\)</span>。由于其递归深度达到<span class="math inline">\(\Theta(\lg n)\)</span>，并且只需要花费<span class="math inline">\(\Theta(1)\)</span>的时间即可完成，因此其持续时间为<span class="math inline">\(T_{\infty}(n)=\Theta(\lgn)\cdot\Theta(1)=\Theta(\lg n)\)</span>。因此的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n/\lgn)\)</span>。</p><h2 id="b">b</h2><p>如果<span class="math inline">\(grain\text{-}size=1\)</span>，那么<span class="math inline">\(r=n\)</span>，<code>SUM-ARRAYS'</code>中的<code>for</code>循环将会串行地执行<span class="math inline">\(n\)</span>次，每次调用<code>ADD-SUBARRAY</code>都只花费<span class="math inline">\(\Theta(1)\)</span>的时间。因此持续时间<span class="math inline">\(T_{\infty}(n)=n\cdot\Theta(1)=\Theta(n)\)</span>。可以知道其工作量为<span class="math inline">\(T_1(n)=\Theta(n)\)</span>，因此其并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(1)\)</span>。</p><h2 id="c">c</h2><p>令<span class="math inline">\(g=grain\text{-}size\)</span>。执行单次<code>ADD-SUBARRAY</code>所需要的时间为<span class="math inline">\(O(g)\)</span>。在<code>SUM-ARRAYS'</code>中，一共需要执行<span class="math inline">\(n/g\)</span>次<code>ADD-SUBARRAY</code>，但是<code>for</code>循环并没有带有<code>parrllel</code>关键字，也就是说，这些调用<code>ADD-SUBARRAY</code>的线程是按顺序启动的，它们并非同时启动的，因此这里仍然需要花费<span class="math inline">\(O(n/g)\)</span>的时间完成这个<code>for</code>循环。</p><p>因此，<code>SUM-ARRAYS'</code>需要花费<span class="math inline">\(O(g+n/g)\)</span>的时间完成。令<span class="math inline">\(f(g)=g+n/g\)</span>，那么有<span class="math inline">\(f&#39;(g)=1-n/g^2\)</span>。令<span class="math inline">\(f&#39;(g)=00\)</span>，即<span class="math inline">\(g=\sqrt{n}\)</span>时，<code>SUM-ARRAYS'</code>只需要花费<span class="math inline">\(O(\sqrt{n})\)</span>的时间就可以完成。</p><h1 id="section-1">26-2</h1><h2 id="a-1">a</h2><p>修改后的代码由<code>P-MATRIX-MULTIPLY-RECURSIVE'</code>所示，它消去了临时矩阵<span class="math inline">\(D\)</span>的存在。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A, B, C, n)</span><br><span class="line">  if n == 1</span><br><span class="line">    c11 = c11 + a11 · b11</span><br><span class="line">    return</span><br><span class="line">  partition A, B, C, and D into n/2 × n/2 submatrices A11, A12, A21, A22; B11, B12, B21, B22; and C11, C12, C21, C22; respectively</span><br><span class="line">  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A11, B11, C11, n / 2)</span><br><span class="line">  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A11, B12, C12, n / 2)</span><br><span class="line">  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A21, B11, C21, n / 2)</span><br><span class="line">  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A21, B12, C22, n / 2)</span><br><span class="line">  sync</span><br><span class="line">  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A12, B21, C11, n / 2)</span><br><span class="line">  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A12, B22, C12, n / 2)</span><br><span class="line">  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A22, B21, C21, n / 2)</span><br><span class="line">  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A22, B22, C22, n / 2)</span><br><span class="line">  sync</span><br></pre></td></tr></table></figure><p>可见，它的串行投影是<code>MATRIX-MULTIPLY-RECURSIVE</code>，因此其工作量为<span class="math inline">\(\Theta(n^3)\)</span>。</p><h2 id="b-1">b</h2><p>对于其工作量<span class="math inline">\(T_1(n)\)</span>，可以给出其递推式<span class="math inline">\(T_1(n)=8T_1(n/2)+\Theta(n^2)\)</span>，因此得到<span class="math inline">\(T_1(n)=\Theta(n^3)\)</span>。</p><p>对于其持续时间，除了递归调用，<code>P-MATRIX-MULTIPLY-RECURSIVE'</code>没有再做其它工作。因此可以给出其递推式<span class="math inline">\(T_{\infty}(n)=2T_{\infty}(n/2)+\Theta(1)\)</span>，最终通过主定理可以得知<span class="math inline">\(T_{\infty}(n)=\Theta(n)\)</span>。</p><p>也就是说，算法<code>P-MATRIX-MULTIPLY-RECURSIVE'</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^2)\)</span>。</p><h2 id="c-1">c</h2><p>忽略掉<span class="math inline">\(\Theta\)</span>符号后，对于<span class="math inline">\(1000\times1000\)</span>的矩阵而言，调用<code>P-MATRIX-MULTIPLY-RECURSIVE'</code>的并行度为<span class="math inline">\(10^6\)</span>。相比于调用<code>P-MATRIX-MULTIPLY-RECURSIVE</code>得到<span class="math inline">\(10^7\)</span>的并行度，计算机依旧不会有这么多的处理器，但是在算法的运行时间的常数却明显减少了，因此这种权衡是值得的。</p><h1 id="section-2">26-3</h1><h2 id="a-2">a</h2><p>对<code>LU-DECOMPOSITION</code>修改后得到的并行化版本为<code>P-LU-DECOMPOSITION</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">P-LU-DECOMPOSITION(A, n)</span><br><span class="line">  let L and U be new n × n matrices </span><br><span class="line">  initialize U with 0s below the diagonal</span><br><span class="line">  initialize L with 1s on the diagonal and 0s above the diagonal</span><br><span class="line">  for k = 1 to n</span><br><span class="line">    u_&#123;kk&#125; = a_&#123;kk&#125;</span><br><span class="line">    parallel for i = k + 1 to n</span><br><span class="line">      l_&#123;ik&#125; = a_&#123;ik&#125; / a_&#123;kk&#125;</span><br><span class="line">      u_&#123;ki&#125; = a_&#123;ki&#125;</span><br><span class="line">    parallel for i = k + 1 to n</span><br><span class="line">      parallel for j = k + 1 to n</span><br><span class="line">        a_&#123;ij&#125; = a_&#123;ij&#125; − l_&#123;ik&#125; * u_&#123;kj&#125;</span><br><span class="line">  return L and U</span><br></pre></td></tr></table></figure><p>也就是说，所有内循环都可以进行并行，但是最外层的那一层循环不允许并行。第一个内循环能够并行的原因是：它只读取<span class="math inline">\(a\)</span>矩阵的元素，并修改<span class="math inline">\(L,U\)</span>对应行和对应列的元素，并不会进行多次存取。第二个双重内循环能够并行的原因是第<span class="math inline">\(i\)</span>轮二层循环，第<span class="math inline">\(j\)</span>轮三次循环中，他只会读取<span class="math inline">\(L,U\)</span>矩阵的值并且修改<span class="math inline">\(a_{ij}\)</span>的值，不会造成冲突。外层循环不能是并行的原因是按照LU分解的定义，后一次的运行依赖于前一次的结果。</p><p><code>P-LU-DECOMPOSITION</code>的串行投影是<code>LU-DECOMPOSITION</code>，因此其工作量为<span class="math inline">\(T_1(n)=\Theta(n^3)\)</span>。</p><p>对于<code>P-LU-DECOMPOSITION</code>的持续时间，第一层的第一次内循环花费的时间是<span class="math inline">\(\Theta(\lg(n-k))=\Theta(\lgn)\)</span>，因为转化成<code>spawn ... sync</code>结构后就变成了分支法，然后进行递归。第二次的两个双重嵌套寻呼按的原因相同，其花费的时间为<span class="math inline">\(\Theta(\lg(n-k))+\Theta(\lg(n-k))=\Theta(\lgn)\)</span>。因此，外层<code>for</code>循环需要<span class="math inline">\(\Theta(\lgn)\)</span>的时间完成一次。最终，<code>P-LU-DECOMPOSITION</code>的持续时间为<span class="math inline">\(T_{\infty}(n)=n\cdot \Theta(\lg n)=\Theta(n\lgn)\)</span>。</p><p>最终我们可以计算出<code>P-LU-DECOMPOSITION</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^2/\lgn)\)</span>。</p><h2 id="b-2">b</h2><p>对<code>LUP-DECOMPOSITION</code>修改后得到的并行化版本为<code>P-LUP-DECOMPOSITION</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">P-LUP-DECOMPOSITION(A, n)</span><br><span class="line">  let π[1 : n] be a new array</span><br><span class="line">  parallel for i = 1 to n</span><br><span class="line">    π[i] = i</span><br><span class="line">  for k = 1 to n</span><br><span class="line">    p = 0</span><br><span class="line">    parallel for i = k to n</span><br><span class="line">      if |a_&#123;ik&#125;| &gt; p</span><br><span class="line">        p = |a_&#123;ik&#125;|</span><br><span class="line">        k&#x27; = i</span><br><span class="line">    if p == 0</span><br><span class="line">      error &quot;singular matrix&quot;</span><br><span class="line">    exchange π[k] with π[k&#x27;]</span><br><span class="line">    parallel for i = 1 to n</span><br><span class="line">      exchange a_&#123;ki&#125; with a_&#123;k&#x27;i&#125; </span><br><span class="line">    parallel for i = k + 1 to n</span><br><span class="line">      a_&#123;ik&#125; = a_&#123;ik&#125; / a_&#123;kk&#125;</span><br><span class="line">      parallel for j = k + 1 to n</span><br><span class="line">        a_&#123;ij&#125; = a_&#123;ij&#125; − a_&#123;ik&#125; * a_&#123;kj&#125;</span><br></pre></td></tr></table></figure><p>第2行的<code>for</code>循环可以并行，这是显而易见的。第6-9行的<code>for</code>循环是可以并行的，因为这是寻找一个最大值，在这个过程中，<span class="math inline">\(n\)</span>个元素构成一棵<span class="math inline">\(n\)</span>个叶节点的二叉树，对于内部节点，它是两个子节点中的最大值，由于这棵树的深度为<span class="math inline">\(\Theta(\lgn)\)</span>，因此这段循环的持续时间为<span class="math inline">\(\Theta(\lgn)\)</span>。第13行的<code>for</code>循环用于交换两行元素，显而易见是可以并行的。对于第15行和17行的<code>for</code>循环，第16行仅仅是对<span class="math inline">\(a_{ik}\)</span>进行更新，此后都是对<span class="math inline">\(a_{ij}(j&gt;k)\)</span>中的所有元素进行更新。至于先对哪一行操作都是没有关系的，因此第15行和17行的<code>for</code>循环它们都可以并行。外面针对<span class="math inline">\(k\)</span>的<code>for</code>循环不能并行，因为会导致数据读取冲突。</p><p><code>P-LUP-DECOMPOSITION</code>的串行投影是<code>LUP-DECOMPOSITION</code>，因此其工作量为<span class="math inline">\(T_1(n)=\Theta(n^3)\)</span>。</p><p>对于<code>P-LUP-DECOMPOSITION</code>的持续时间，分析和<code>P-LU-DECOMPOSITION</code>非常相似。第6，13，15，17行的<code>for</code>循环都可以进行，因此这部分只使用<span class="math inline">\(\Theta(\lgn)\)</span>的时间即可完成。最终，<code>P-LUP-DECOMPOSITION</code>的持续时间为<span class="math inline">\(T_{\infty}(n)=n\cdot \Theta(\lg n)=\Theta(n\lgn)\)</span>。</p><p>最终我们可以计算出<code>P-LUP-DECOMPOSITION</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^2/\lgn)\)</span>。</p><h2 id="c-2">c</h2><p>对<code>LUP-SOLVE</code>修改后得到的并行化版本为<code>P-LUP-SOLVE</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">P-LUP-SOLVE(L, U, π, b, n)</span><br><span class="line">  let x and y be new vectors of length n</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    val = 0</span><br><span class="line">    parallel for j = 1 to i - 1</span><br><span class="line">      val = val + l_&#123;ij&#125; * y_j</span><br><span class="line">    y_i = b_&#123;π[i]&#125; - val</span><br><span class="line">  for i = n downto 1</span><br><span class="line">    val = 0</span><br><span class="line">    parallel for j = i + 1 to n</span><br><span class="line">      val = val + u_&#123;ij&#125; * x_j</span><br><span class="line">    x_i = (y_u - val) / u_&#123;ii&#125;</span><br><span class="line">  return x</span><br></pre></td></tr></table></figure><p>第4和9行的<code>for</code>循环可以并行，只需要将长度为<span class="math inline">\(n\)</span>的序列构造出一棵<span class="math inline">\(n\)</span>个叶子节点的完全二叉树即可，对于内部节点，它是两个子节点中的值之和。因此，这两个内部<code>for</code>循环都能够在<span class="math inline">\(\Theta(\lgn)\)</span>的时间内完成。对于第2和7行的<code>for</code>循环，因为后面计算<span class="math inline">\(x,y\)</span>值需要依赖前面已经计算出的<span class="math inline">\(x,y\)</span>值。</p><p>最终，<code>P-LUP-SOLVE</code>的串行投影即为<code>LUP-SOLVE</code>，因此其工作量为<span class="math inline">\(T_1(n)=\Theta(n^2)\)</span>。按照上面的结论，可以得到持续时间<span class="math inline">\(T_{\infty}(n)=n\cdot \Theta(\lg n)=\Theta(n\lgn)\)</span>。最终我们可以计算出<code>P-LUP-SOLVE</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n/\lgn)\)</span>。</p><h2 id="d">d</h2><p>一个对正定矩阵求逆的并行算法由<code>P-MATRIX-INVERSION-POSITIVE-DEFINITE</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">P-MATRIX-INVERSION-POSITIVE-DEFINITE(A, n)</span><br><span class="line">  partition A into n/2 × n/2 submatrices B, CT, C, D; respectively</span><br><span class="line">  let W[1 : n, 1 : n], X[1 : n, 1 : n], Y[1 : n, 1 : n], Z[1 : n, 1 : n], S[1 : n, 1 : n] be new matrices</span><br><span class="line">  B&#x27; = P-MATRIX-INVERSION-POSITIVE-DEFINITE(B, n / 2)</span><br><span class="line">  W = P-MATRIX-MULTIPLY(C, B&#x27;, W, n / 2)</span><br><span class="line">  WT = W</span><br><span class="line">  P-TRANSPOSE(WT, n / 2)</span><br><span class="line">  P-MATRIX-MULTIPLY(W, CT, X, n / 2)</span><br><span class="line">  S = D - X</span><br><span class="line">  S&#x27; = P-MATRIX-INVERSION-POSITIVE-DEFINITE(S, n / 2)</span><br><span class="line">  P-MATRIX-MULTIPLY(S&#x27;, W, Y, n / 2)</span><br><span class="line">  YT = Y</span><br><span class="line">  P-TRANSPOSE(YT, n / 2)</span><br><span class="line">  P-MATRIX-MULTIPLY(WT, y, Z)</span><br><span class="line">  R = B&#x27; + Z</span><br><span class="line">  A&#x27; = [[R, -YT], [-Y, S&#x27;]]</span><br><span class="line">  return A&#x27;</span><br></pre></td></tr></table></figure><p>按照第28.2章的结论以及不等式28.15，可以知道其工作量<span class="math inline">\(I_1(n)\le2I_1(n/2)+4M_1(n/2)+O(n^2)\)</span>，最终得到<span class="math inline">\(I_1(n)=O(M(n))\)</span>。</p><p>在并行版本中，由题目26.1-8，26.2-3和题26-1-a可知，矩阵的转置、加法和乘法都可以在<span class="math inline">\(\Theta(\lgn)\)</span>时间内完成。在<code>P-MATRIX-INVERSION-POSITIVE-DEFINITE</code>中，一共进行了<span class="math inline">\(2\)</span>次矩阵转置，<span class="math inline">\(4\)</span>次矩阵加减法，<span class="math inline">\(4\)</span>次矩阵乘法。同样的，它们还进行了<span class="math inline">\(2\)</span>次大小为<span class="math inline">\(n/2\timesn/2\)</span>矩阵的求逆。可见，这些步骤都是依赖于前一步的结果，因此步骤之间不能直接并行。我们可以写出它的持续时间<span class="math inline">\(I_{\infty}(n)\)</span>满足<span class="math inline">\(I_{\infty}(n)=2I_{\infty}(n/2)+10\cdot\Theta(\lgn)\)</span>，因此最终得到<span class="math inline">\(I_{\infty}(n)=\Theta(n)\)</span>。</p><p>最终我们可以得到它的并行度为<span class="math inline">\(I_1(n)/I_{\infty}(n)=O(M(n)/n)\)</span>。</p><h1 id="section-3">26-4</h1><h2 id="a-3">a</h2><p>设计的<code>P-REDUCE</code>如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">P-REDUCE(x, i, j)</span><br><span class="line">  if i == j</span><br><span class="line">    return x[i]</span><br><span class="line">  else</span><br><span class="line">    mid = ⌊(i + j) / 2⌋</span><br><span class="line">    l = spawn P-REDUCE(x, i, mid)</span><br><span class="line">    r = spawn P-REDUCE(x, mid + 1, j)</span><br><span class="line">    sync</span><br><span class="line">    return l ⊗ r</span><br></pre></td></tr></table></figure><p>不难发现它的串行投影即为<code>REDUCE</code>，因此它的工作量为<span class="math inline">\(T_1(n)=\Theta(n)\)</span>。由于这棵进行搜索的二叉树的深度为<span class="math inline">\(\Theta(\lgn)\)</span>，因此这个算法的持续时间为<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)\)</span>。</p><h2 id="b-3">b</h2><p>这个算法相当于是以<span class="math inline">\(k=1,2,\dots,n\)</span>对<code>P-REDUCE</code>都进行了一次调用。因此<code>P-SCAN-1</code>的工作量为<span class="math inline">\(\displaystyle{T_1(n)=\sum_{k=1}^n\Theta(k)=\Theta(n^2)}\)</span>。</p><p>接下来求解<code>P-SCAN-1</code>的持续时间。由于对<code>P-SCAN-1</code>对<code>P-REDUCE</code>的间接调用呈树形，假设伪代码中，第<span class="math inline">\(i\)</span>次对<code>P-REDUCE</code>的调用的持续时间为<span class="math inline">\(iter(i)\)</span>，那么有<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)+\max\{iter(i):1\lei\le n\}\)</span>，按照题目26-4-a的结论，有<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)\)</span>。</p><p>因此<code>P-SCAN-1</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^2/\lgn)\)</span>。</p><h2 id="c-3">c</h2><p>我们可以使用归纳法进行证明其正确性。即证明，调用<code>P-SCAN-2-AUX(i, j)</code>，对于<span class="math inline">\(\forall k\in[i,j]\)</span>，它都正确计算出了<span class="math inline">\(y[k]=x[i]\otimes x[i+1]\otimes\dots\otimesx[k]\)</span>。</p><p>对于基本情况：<span class="math inline">\(i=j\)</span>，<code>P-SCAN-2-AUX</code>都正确计算出了<span class="math inline">\(y\)</span>数组，这由<code>P-SCAN-2-AUX</code>的前两行明显可知。</p><p>当<span class="math inline">\(i&lt;j\)</span>时，假设对于区间<span class="math inline">\([i,j]\)</span>内的所有真子区间<span class="math inline">\([i&#39;,j&#39;]\)</span>，即<span class="math inline">\(i\le i&#39;\le j&#39;\le j\)</span>，且<span class="math inline">\(i=i&#39;,j=j&#39;\)</span>不同时成立，<code>P-SCAN-2-AUX</code>都计算出了正确的结果。那么第三行得到了一个<span class="math inline">\(k=\lfloor(i+j)/2\rfloor\)</span>。对于第4和5行的代码，它们分别对<span class="math inline">\(y\)</span>数组的区间<span class="math inline">\([i,k]\)</span>和<span class="math inline">\([k+1,j]\)</span>进行写入，并且读取的内容也不相交，因此这两行代码不会构成竞争。在第6行结束后，<span class="math inline">\(y\)</span>数组满足：如果<span class="math inline">\(p\le k\)</span>，那么<span class="math inline">\(y[p]=x[i]\otimes x[i+1]\otimes\dots\otimesx[p]\)</span>，否则<span class="math inline">\(y[p]=x[k+1]\otimesx[k+2]\otimes\dots\otimes x[k]\)</span>。对于<span class="math inline">\(p&gt;k\)</span>的情况，第8行将<span class="math inline">\(y[p]\)</span>重新赋值成<span class="math inline">\(y[k]\otimes y[p]\)</span>。这个步骤完成后，<span class="math inline">\(\forall p\in[i,j]\)</span>，都有<span class="math inline">\(y[p]=x[i]\otimes x[i+1]\otimes\dots\otimesx[p]\)</span>。因此<code>P-SCAN-2-AUX</code>是正确的。</p><p>接下来考虑<code>P-SCAN-2-AUX</code>的工作量<span class="math inline">\(T_1(n)\)</span>，消去最后的<code>for</code>循环中的<code>parallel</code>关键字后，那么除去递归部分，它的运行时间是<span class="math inline">\(\Theta(n)\)</span>。因此可以写出<span class="math inline">\(T_1(n)=2T_1(n/2)+\Theta(n)\)</span>，从而得到<span class="math inline">\(T_1(n)=\Theta(n\lg n)\)</span>。</p><p>接下来考虑其持续时间<span class="math inline">\(T_{\infty}(n)\)</span>。可见出了递归部分，其余部分仍然需要<span class="math inline">\(\Theta(\lg n)\)</span>进行。因此有<span class="math inline">\(T_{\infty}(n)=T_{\infty}(n/2)+\Theta(\lgn)\)</span>，最终得到<span class="math inline">\(T_{\infty}(n)=\Theta(\lg^2n)\)</span>。</p><p>因此<code>P-SCAN-2</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n/\lgn)\)</span>。</p><h2 id="d-1">d</h2><p><code>P-SCAN-UP</code>第8行填入的是$<code>right ⊗ t[k]</code>；<code>P-SCAN-DOWN</code>的第5行填入<code>v</code>，第6行填入<code>v ⊗ t[k]</code>。</p><p>需要注意的是，<span class="math inline">\(t[k]\)</span>存储的是当一个区间<span class="math inline">\([i,j]\)</span>被尽量均匀地划分成两个区间<span class="math inline">\([i,k],[k+1,j]\)</span>后，<span class="math inline">\(t[k]\)</span>就是记录区间<span class="math inline">\([i,j]\)</span>前面一半元素（即<span class="math inline">\([i,k]\)</span>）的元素之和<span class="math inline">\(t[k]=x[i]\otimes x[i+1]\otimes\dots\otimesx[k]\)</span>。</p><p>首先证明，调用时每个<span class="math inline">\(t[k]\)</span>最多只会被赋值一次（因此，在执行<code>P-SCAN-DOWN</code>时不会造成任何冲突）。只有调用<code>P-SCAN-UP</code>，当<span class="math inline">\(i&lt;j\)</span>时，才会对<span class="math inline">\(t[k]\)</span>进行赋值，在此之后更深的递归讲不会再对<span class="math inline">\(t[k]\)</span>进行赋值，原因如下。如果递归的区间是左半子区间<span class="math inline">\([i,k]\)</span>，那么对于所有<span class="math inline">\([i,k]\)</span>的长度大于等于<span class="math inline">\(2\)</span>的（等于<span class="math inline">\(1\)</span>则不会进入到这个分支）真子区间<span class="math inline">\([i&#39;,k&#39;]\)</span>，都有<span class="math inline">\(\lfloor(i&#39;+k&#39;)/2\rfloor&lt;k\)</span>，因此<span class="math inline">\(t[k]\)</span>不会被重复赋值；如果递归的是右子区间<span class="math inline">\([k+1,j]\)</span>，那么它的访问和读写只会在这个区间内进行，更不会对<span class="math inline">\(t[k]\)</span>进行访问。因此，<span class="math inline">\(t[k]\)</span>确实能够正确记录区间<span class="math inline">\([i,j]\)</span>的信息。根据<code>P-SCAN-DOWB</code>的第5行代码，就可以知道<span class="math inline">\(t[k]\)</span>记录的是区间i,j的左半区间的元素之和。并且，<code>P-SCAN-UP</code>的返回值是<span class="math inline">\([i,j]\)</span>这个区间的所有元素之和，因此结论成立。</p><p>接下来证明每次调用<code>P-SCAN-DOWN(v, x, t, y, i, j)</code>时，总满足<span class="math inline">\(v=x[1]\otimes x[2]\otimes\dots\otimesx[i-1]\)</span>。同样使用归纳法来证明。在<code>P-SCAN-3</code>调用<code>P-SCAN-DOWN</code>时，有<span class="math inline">\(v=x[1],i=2\)</span>，因此基本情况下是成立的。<code>P-SCAN-DOWN</code>首先调用<code>P-SCAN-DOWN(v, x, t, y, i, k)</code>，由于参数<span class="math inline">\(i\)</span>没有变化，因此<span class="math inline">\(v\)</span>仍然使用原来的<span class="math inline">\(v\)</span>，原结论成立；然后调用<code>P-SCAN-DOWN(v ⊗ t[k], x, t, y, k + 1, j)</code>，由于此时<span class="math inline">\(t[k]=x[i]\otimes x[i+1]\otimes\dots\otimesx[k]\)</span>，因此有<span class="math inline">\(v\otimest[k]=x[1]\otimes x[2]\otimes\dots\otimesx[k]\)</span>。因此第二次调用时同样满足题目的条件。因此当<code>P-SCAN-DOWN</code>进入第2行后，<code>y[i] = v ⊗ x[i]</code>则是<span class="math inline">\(y[i]=x[1]\otimes x[2]\otimes\dots\otimesx[i]\)</span>，<span class="math inline">\(y[i]\)</span>被正确地计算出来。</p><p>因此，算法<code>P-SCAN-3</code>是正确的。</p><h2 id="e">e</h2><p>可以发现，这棵树的节点数仍然是<span class="math inline">\(\Theta(n)\)</span>，因此<code>P-SCAN-3</code>的工作量<span class="math inline">\(T_1(n)=\Theta(n)\)</span>。</p><p>接下来首先考虑<code>P-SCAN-UP</code>。由于其每次划分出了两个长度尽量均等的区间，并且其余处理部分都只要<span class="math inline">\(\Theta(1)\)</span>的时间，因此<code>P-SCAN-UP</code>这段代码的持续时间满足<span class="math inline">\(T_{\infty}(n)=T_{\infty}(n/2)+\Theta(1)\)</span>，从而得到<span class="math inline">\(T_{\infty}(n)=\Theta(\lgn)\)</span>。<code>P-SCAN-DOWN</code>和<code>P-SCAN-UP</code>的结构基本相同，因此对其分析也一样。</p><p>最终，<code>P-SCAN-3</code>的持续时间为<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)\)</span>。</p><p>因此，<code>P-SCAN-3</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n/\lgn)\)</span>。</p><h2 id="f">f</h2><p>修改后的<code>P-SCAN-3</code>由<code>P-SCAN-3'</code>给出。代价是并发度将会降低。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">P-SCAN-3&#x27;(x, n)</span><br><span class="line">  let y[1 : n] be a new array</span><br><span class="line">  y[1] = x[1]</span><br><span class="line">  if n &gt; 1</span><br><span class="line">    P-SCAN-3-AUX(x[1], x, y, 2, n)</span><br><span class="line">  return y</span><br><span class="line"></span><br><span class="line">P-SCAN-SUM-ARRAYS(x, i, j)</span><br><span class="line">  if i == j</span><br><span class="line">    return x[i]</span><br><span class="line">  else</span><br><span class="line">    k = ⌊(i + j) / 2⌋</span><br><span class="line">    l = spawn P-SCAN-SUM-ARRAYS(x, t, i, k)</span><br><span class="line">    r = P-SCAN-SUM-ARRAYS(x, t, k + 1, j)</span><br><span class="line">    return l ⊗ r</span><br><span class="line"></span><br><span class="line">P-SCAN-3-AUX(v, x, y, i, j)</span><br><span class="line">  if i == j</span><br><span class="line">    y[i] = v ⊗ x[i]</span><br><span class="line">  else</span><br><span class="line">    k = ⌊(i + j) / 2⌋</span><br><span class="line">    spawn P-SCAN-3-AUX(v, x, y, i, k)</span><br><span class="line">    t = P-SCAN-SUM-ARRAYS(x, i, k)</span><br><span class="line">    P-SCAN-3-AUX(v ⊗ t, x, y, k + 1, j)</span><br><span class="line">    sync</span><br></pre></td></tr></table></figure><h2 id="star-g"><span class="math inline">\(\star\)</span> g</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">P-SCAN-4(x, n)</span><br><span class="line">  l = 1</span><br><span class="line">  while l &lt;= n</span><br><span class="line">    parallel for i = 1 to n by l * 2</span><br><span class="line">      parallel j = 0 to l - 1</span><br><span class="line">        if i + l + j &lt;= n</span><br><span class="line">          x[i + l + j] = x[i + l + j] + x[i + l - 1]</span><br><span class="line">    l = l * 2</span><br></pre></td></tr></table></figure><p>这个算法的基本思想是，将<span class="math inline">\(x\)</span>分成<span class="math inline">\(\lceiln/(2l)\rceil\)</span>块，每一块的长度为<span class="math inline">\(2l\)</span>（最后一块不足<span class="math inline">\(2l\)</span>也以一块记），并且<span class="math inline">\(l\)</span>是<span class="math inline">\(2\)</span>的幂。一开始<span class="math inline">\(l=1\)</span>，将前半块的最后一个元素<span class="math inline">\(x[i+l-1]\)</span>添加到后半块<span class="math inline">\(x[i+l+j](0\lej&lt;l)\)</span>中的每一个元素。从而最终完成后，每一块内部都是对应值的前缀和。可见两个<code>parallel for</code>循环不会导致冲突，因此这个算法的持续时间为<span class="math inline">\(T_{\infty}(n)=\Theta(\lg^2n)\)</span>。</p><h2 id="h">h</h2><p>将字符串中的<code>(</code>视为<span class="math inline">\(+1\)</span>，<code>')'</code>视为<span class="math inline">\(-1\)</span>，得到一个数组<span class="math inline">\(x\)</span>，求出其前缀和<span class="math inline">\(y\)</span>。那么一个括号字符串是合法的，当且仅当<span class="math inline">\(\forall i\in[1,n],y_i\ge 0\)</span>，并且有<span class="math inline">\(y_n=0\)</span>。通过对<code>P-SCAN-3</code>进行改造，我们可以得到一个在<span class="math inline">\(\Theta(\lgn)\)</span>时间内判断一个括号字符串是否合法的程序<code>PARENTHESES-IS-WELL-FORMED</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">PARENTHESES-IS-WELL-FORMED(s, n)</span><br><span class="line">  let y[0 : n] and t[1 : n] be new arrays</span><br><span class="line">  y[0] = 0</span><br><span class="line">  P-SCAN-UP&#x27;(s, t, 1, n)</span><br><span class="line">  mn = P-SCAN-DOWN&#x27;(0, s, t, y, 1, n)</span><br><span class="line">  return mn &gt;= 0 and y[n] == 0</span><br><span class="line"></span><br><span class="line">P-SCAN-UP&#x27;(s, t, i, j)</span><br><span class="line">  if i == j</span><br><span class="line">    if s[i] == &#x27;(&#x27;</span><br><span class="line">      return 1</span><br><span class="line">    else</span><br><span class="line">      return -1</span><br><span class="line">  else</span><br><span class="line">    k = ⌊(i + j) / 2⌋</span><br><span class="line">    t[k] = spawn P-SCAN-UP&#x27;(s, t, i, k)</span><br><span class="line">    right = P-SCAN-UP&#x27;(s, t, k + 1, j)</span><br><span class="line">    sync</span><br><span class="line">    return t[k] + right</span><br><span class="line"></span><br><span class="line">P-SCAN-DOWN&#x27;(v, s, t, y, i, j)</span><br><span class="line">  if i == j</span><br><span class="line">    y[i] = v + x[i]</span><br><span class="line">    return y[i]</span><br><span class="line">  else</span><br><span class="line">    k = ⌊(i + j) / 2⌋</span><br><span class="line">    l = spawn P-SCAN-DOWN (v, x, t, y, i, k)</span><br><span class="line">    r = P-SCAN-DOWN(v + t[k], x, t, y, k + 1, j)</span><br><span class="line">    sync</span><br><span class="line">    return min&#123;l, r&#125;</span><br></pre></td></tr></table></figure><p>改造后的程序还返回了前缀和数组中的最小值。</p><h1 id="section-4">26-5</h1><h2 id="a-4">a</h2><p>不失一般性，这里假设矩阵<span class="math inline">\(A\)</span>的大小<span class="math inline">\(n\)</span>是<span class="math inline">\(2\)</span>的幂次。基于等式26.9，那么对矩阵<span class="math inline">\(A\)</span>的填充并行分治算法由<code>SIMPLE-STENCIL</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SIMPLE-STENCIL(A, n)</span><br><span class="line">  if n == 1</span><br><span class="line">    generate the value of a11</span><br><span class="line">    return</span><br><span class="line">  partition A into n/2 × n/2 submatrices A11, A12, A21, A22; respectively</span><br><span class="line">  SIMPLE-STENCIL(A11, n / 2)</span><br><span class="line">  spawn SIMPLE-STENCIL(A12, n / 2)</span><br><span class="line">  spawn SIMPLE-STENCIL(A21, n / 2)</span><br><span class="line">  sync</span><br><span class="line">  SIMPLE-STENCIL(A22, n / 2)</span><br></pre></td></tr></table></figure><p>可见这个算法只是为了填充原来矩阵的所有元素，由其串行投影可以知道其工作量满足<span class="math inline">\(T_1(n)=4T_1(n/2)+\Theta(1)\)</span>，可以得到<span class="math inline">\(T_1(n)=\Theta(n^2)\)</span>。</p><p>这个算法的持续时间满足<span class="math inline">\(T_{\infty}(n)=3T_\infty(n/2)+\Theta(1)\)</span>，可以得到<span class="math inline">\(T_{\infty}(n)=\Theta(n^{\lg 3})\)</span>。</p><p>最终可以得到并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^{2-\lg3})\)</span>。</p><h2 id="b-4">b</h2><p>不失一般性，这里假设矩阵<span class="math inline">\(A\)</span>的大小<span class="math inline">\(n\)</span>是<span class="math inline">\(3\)</span>的幂次，那么按照题目26-5-a的结果，我们可以对<code>SIMPLE-STENCIL</code>修改成<code>SIMPLE-STENCIL3</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SIMPLE-STENCIL3(A, n)</span><br><span class="line">  if n == 1</span><br><span class="line">    generate the value of a11</span><br><span class="line">    return</span><br><span class="line">  partition A into n/3 × n/3 submatrices A11, A12, A13, A21, A22, A23, A31, A32, A33; respectively</span><br><span class="line">  SIMPLE-STENCIL3(A11, n / 3)</span><br><span class="line">  spawn SIMPLE-STENCIL3(A12, n / 3)</span><br><span class="line">  spawn SIMPLE-STENCIL3(A21, n / 3)</span><br><span class="line">  sync</span><br><span class="line">  spawn SIMPLE-STENCIL3(A13, n / 3)</span><br><span class="line">  spawn SIMPLE-STENCIL3(A22, n / 3)</span><br><span class="line">  spawn SIMPLE-STENCIL3(A31, n / 3)</span><br><span class="line">  sync</span><br><span class="line">  spawn SIMPLE-STENCIL3(A23, n / 3)</span><br><span class="line">  spawn SIMPLE-STENCIL3(A32, n / 3)</span><br><span class="line">  sync</span><br><span class="line">  SIMPLE-STENCIL3(A33, n / 3)</span><br></pre></td></tr></table></figure><p>和题目26-3-a分析的过程类似，可以知道其工作量满足<span class="math inline">\(T_1(n)=9T_1(n/3)+\Theta(1)\)</span>，可以得到<span class="math inline">\(T_1(n)=\Theta(n^2)\)</span>。</p><p>这个算法的持续时间满足<span class="math inline">\(T_{\infty}(n)=5T_\infty(n/3)+\Theta(1)\)</span>，可以得到<span class="math inline">\(T_{\infty}(n)=\Theta(n^{\log_3 5})\)</span>。</p><p>最终可以得到并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^{2-\log_35})\)</span>。</p><h2 id="c-4">c</h2><p>利用类似的方式修改题目26-5-a和26-5-b的代码，可以给出<code>SIMPLE-STENCIL-B</code>代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SIMPLE-STENCIL-B(A, n)</span><br><span class="line">  if n == 1</span><br><span class="line">    generate the value of a11</span><br><span class="line">    return</span><br><span class="line">  partition A into n/b × n/b submatrices A11, A12, ..., A1b, A21, A22, ..., A2b, ...,  Ab1, Ab2, ..., Abb; respectively</span><br><span class="line">  for k = 2 to b * b</span><br><span class="line">    //注意这里的parallel for 循环将是以硬编码的形式构造出来，因此后面的分析不会对Θ(lg n)这个因子进行考虑。</span><br><span class="line">    parallel for i = 1 to b</span><br><span class="line">      j = k - i</span><br><span class="line">      if 1 &lt;= j and j &lt;= b</span><br><span class="line">      SIMPLE-STENCIL3(Aij, n / b)</span><br></pre></td></tr></table></figure><p>和题目26-3-a和26-3-b分析的过程类似，可以知道其工作量满足<span class="math inline">\(T_1(n)=b^2T_1(n/b)+\Theta(1)\)</span>，可以得到<span class="math inline">\(T_1(n)=\Theta(n^2)\)</span>。</p><p>这个算法的持续时间满足<span class="math inline">\(T_{\infty}(n)=(2b-1)T_\infty(n/b)+\Theta(1)\)</span>，可以得到<span class="math inline">\(T_{\infty}(n)=\Theta(n^{\log_b(2b-1)})\)</span>。</p><p>最终可以得到并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^{2-\log_b(2b-1)})\)</span>。</p><p>为了证明<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^{2-\log_b(2b-1)})=o(n)\)</span>，那么需要证明<span class="math inline">\(f\forallb\ge 2\)</span>，都有<span class="math inline">\(2-\log_b(2b-1)&lt;1\)</span>，即证明<span class="math inline">\(\log_b(2b-1)&gt;1\)</span>。由于<span class="math inline">\(\forall b\ge 2\)</span>，都有<span class="math inline">\(2b-1&gt;b\)</span>，因此<span class="math inline">\(\log_b(2b-1)&gt;1\)</span>成立是很显然的。因此有<span class="math inline">\(T_1(n)/T_{\infty}(n)=o(n)\)</span>。</p><h2 id="d-2">d</h2><p>这个算法由<code>STENCIL</code>给出，并且它还能对更一般形式的矩阵进行填充。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">STENCIL(A, n)</span><br><span class="line">  for k = 2 to n + n - 1</span><br><span class="line">    up = max&#123;1, k - n&#125;</span><br><span class="line">    down = min&#123;n, k - 1&#125;</span><br><span class="line">    parallel for i = up to down</span><br><span class="line">      j = k - i</span><br><span class="line">      generate the value of aij</span><br></pre></td></tr></table></figure><p>可以知道<code>STENCIL</code>的工作量是<span class="math inline">\(T_1(n)=\Theta(n^2)\)</span>，因为它仅仅是从小到大枚举矩阵的每条副对角线，并按顺序填入一个个元素。</p><p>可以知道<code>STENCIL</code>的持续时间满足<span class="math inline">\(T_\infty(n)=n\cdot\Theta(\lg n)=\Theta(n\lgn)\)</span>。因为第<span class="math inline">\(k\)</span>轮迭代最多也只会进行<span class="math inline">\(n\)</span>次操作。如果去掉关键字<code>parallel</code>关键字并转化为<code>spawn ... sync</code>结构，那么这一部分需要花费<span class="math inline">\(\Theta(\lg n)\)</span>的时间。</p><p>因此，<code>STENCIL</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n/\lgn)\)</span>。</p><p>如果需要达到<span class="math inline">\(\Theta(n)\)</span>的并行度，那么可以将<code>parallel for</code>循环转化成硬编码形式，从而去掉这个<code>parallel for</code>循环，并且一次性在<span class="math inline">\(\Theta(1)\)</span>的时间内生产<span class="math inline">\(\Theta(n)\)</span>个元素，从而使并行度提升到<span class="math inline">\(\Theta(n)\)</span>。但是这里使用了<code>parallel for</code>循环，它是基于分治法实现的，因此达不到这个最大并行度。</p><h1 id="section-5">26-6</h1><h2 id="a-5">a</h2><p>工作量定律将改写成<span class="math inline">\(E[T_P]\geE[T_1]/P\)</span>；持续时间定律将改写成<span class="math inline">\(E[T_P]\geE[T_{\infty}]\)</span>；贪心调度界限改写成<span class="math inline">\(E[T_P]\le E[T_1]/P+E[T_{\infty}]\)</span>。</p><h2 id="b-5">b</h2><p>按照题目给出的数据，令<span class="math inline">\(P=10000\)</span>，那么可以写出以下三条式子：</p><p><span class="math inline">\(\begin{aligned} E[T_1]&amp;=10^4\cdot0.01+10^9\cdot 0.99\\ E[T_P]&amp;=1\cdot 0.01+10^9\cdot0.99\\E[T_1/T_P]&amp;=\dfrac{10^4}{1}\cdot0.01+\dfrac{10^9}{10^9}\cdot0.99\\\end{aligned}\)</span></p><p>从而得到<span class="math inline">\(E[T_1/T_P]\approx100,\dfrac{E[T_1]}{E[T_P]}\approx1\)</span>。</p><p>选用<span class="math inline">\(\dfrac{E[T_1]}{E[T_P]}\)</span>的原因有如下两个：</p><ol type="1"><li><p>由于在绝大多数时间中，无论是<span class="math inline">\(P=1\)</span>还是<span class="math inline">\(P=10000\)</span>，其运行时间大多数都在<span class="math inline">\(10^9\)</span>，因此说明这个添加到<span class="math inline">\(P=10000\)</span>的操作应该对加速作用不大，因此选用<span class="math inline">\(\dfrac{E[T_1]}{E[T_P]}\)</span>是一个比较恰当的值。</p></li><li><p><span class="math inline">\(T_1/T_P\)</span>这个随机变量并不成立。题目中没有提到<span class="math inline">\(T_1=10^4\)</span>和<span class="math inline">\(T_1=10^9\)</span>的时机是否和<span class="math inline">\(T_P=1\)</span>和<span class="math inline">\(T_P=10^9\)</span>的时机相同。也就是说，它们不一定是相关的。因此采用独立计算更加合适，即选用<span class="math inline">\(\dfrac{E[T_1]}{E[T_P]}\)</span>。</p></li></ol><h2 id="c-5">c</h2><p>当<span class="math inline">\(P\)</span>趋于无穷时，期望的加速比应该和并行度相等。这和题目26-6-b使用的定义是一致的。</p><h2 id="d-3">d</h2><p>我们可以对第7.3章提到的<code>RANDOMIZED-QUICKSORT</code>算法提出其并行化版本<code>P-RANDOMIZED-QUICKSORT</code>（按照题目要求，不对<code>RANDOMIZED-PARTITION</code>并行化）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">P-RANDOMIZED-QUICKSORT(A, p, r)</span><br><span class="line">  if p &lt; r:</span><br><span class="line">    q = RANDOMIZED-PARTITION(A, p, r)</span><br><span class="line">    spawn P-RANDOMIZED-QUICKSORT(A, p, q - 1)</span><br><span class="line">    spawn P-RANDOMIZED-QUICKSORT(A, q + 1, r)</span><br><span class="line">    sync</span><br></pre></td></tr></table></figure><h2 id="e-1">e</h2><p>可见，<code>P-RANDOMIZED-QUICKSORT</code>的串行投影为<code>RANDOMIZED-QUICKSORT</code>，因此其期望工作量<span class="math inline">\(E[T_1(n)]=O(n\lg n)\)</span>。</p><p>对于<code>P-RANDOMIZED-QUICKSORT</code>持续时间，考虑将<code>P-RANDOMIZED-QUICKSORT</code>和<code>RANDOMIZED-SELECT</code>的行为进行对比。<code>P-RANDOMIZED-QUICKSORT</code>的<code>RANDOMIZED-PARTITION</code>和<code>RANDOMIZED-SELECT</code>中的一样，这部分都是占据了主导的时间<span class="math inline">\(\Theta(n)\)</span>。因此，对其划分的推导也和第9.2章给的完全一样。接下来考虑其递归部分。可以发现，<code>P-RANDOMIZED-QUICKSORT</code>的阶段划分和<code>RANDOMIZED-SELECT</code>也相同，并且证明过程同样也考虑了那个执行时间比较长的执行分支。因此对<code>P-RANDOMIZED-QUICKSORT</code>持续时间<span class="math inline">\(T_{\infty}(n)\)</span>的分析过程和<code>RANDOMIZED-SELECT</code>的分析过程完全一致。按照定理9.2的结论，我们得到<span class="math inline">\(T_{\infty}(n)=\Theta(n)\)</span>。</p><p>因此，<code>P-RANDOMIZED-QUICKSORT</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=O(\lg n)\)</span>。</p><h2 id="f-1">f</h2><p><code>RANDOMIZED-SELECT</code>的并行化版本由<code>P-RANDOMIZED-SELECT</code>给出。其中，给定的<code>P-RANDOMIZED-PARTITION</code>由题目26.3-3的<code>P-PARTITION</code>实现而来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">P-RANDOMIZED-PARTITION(A, p, r)</span><br><span class="line">  i = RANDOM(p, r)</span><br><span class="line">  exchange A[r] with A[i]</span><br><span class="line">  return P-PARTITION(A, p, r)</span><br><span class="line"></span><br><span class="line">P-RANDOMIZED-SELECT(A, p, r, i)</span><br><span class="line">  if p == r</span><br><span class="line">    return A[p]</span><br><span class="line">  q = P-RANDOMIZED-PARTITION(A, p, r)</span><br><span class="line">  k = q – p + 1</span><br><span class="line">  if i == k</span><br><span class="line">    return A[q]</span><br><span class="line">  else if i &lt; k</span><br><span class="line">    return P-RANDOMIZED-SELECT(A, p, q – 1, i)</span><br><span class="line">  else </span><br><span class="line">    return P-RANDOMIZED-SELECT(A, q + 1, r, i – k)</span><br></pre></td></tr></table></figure><p>可见这个算法的串行投影为<code>RANDOMIZED-SELECT</code>，因此它的工作量为<span class="math inline">\(T_1(n)=\Theta(n)\)</span>。</p><p>令示性遍历<span class="math inline">\(X_k\)</span>表示<code>P-RANDOMIZED-PARTITION</code>划分出来后的元素在于位置<span class="math inline">\(k\)</span>。那么由于程序的其余部分都需要<span class="math inline">\(\Theta(\lgn)\)</span>完成（根据题目26.3-3的结论，这里的主要开销就在于<code>P-RANDOMIZED-PARTITION</code>需要花费<span class="math inline">\(\Theta(\lgn)\)</span>的时间），因此可以对随机变量<span class="math inline">\(T_{\infty}(n)\)</span>可以写出如下递推式：</p><p><span class="math display">\[T_{\infty}(n)=\sum_{i=1}^n X_k\cdotT_{\infty}(\max\{k-1,n-k\})+\Theta(\lg n)\]</span></p><p>可见<span class="math inline">\(E[X_k]=\dfrac{1}{n}\)</span>，因为每个位置都有可能被选到。那么对式子左右两侧取期望值，那么有</p><p><span class="math inline">\(\begin{aligned}E[T_{\infty}(n)]&amp;=\sum_{k=1}^n E[X_k]\cdotE[T_{\infty}(\max\{k-1,n-k\})]+\Theta(\lg n)\\&amp;\le\dfrac{2}{n}\sum_{k=\lfloor n/2\rfloor}^{n-1}E[T_{\infty}(k)]+\Theta(\lg n)\\ \end{aligned}\)</span></p><p>接下来使用代入法证明<span class="math inline">\(E[T_{\infty}(n)]=O(n^d)\)</span>，即<span class="math inline">\(\exists c,n_0&gt;0,d\in(0,1)\)</span>，使得<span class="math inline">\(\forall n\ge n_0\)</span>，都有<span class="math inline">\(E[T_{\infty}(n)]\le c\cdotn^{d}\)</span>。那么就可以得到</p><p><span class="math inline">\(\begin{aligned}E[T_{\infty}(n)]&amp;\le\dfrac{2}{n}\sum_{k=\lfloor n/2\rfloor}^{n-1}E[T_{\infty}(k)]+\Theta(\lg n)\\ &amp;\le\dfrac{2}{n}\sum_{k=\lfloorn/2\rfloor}^{n-1} c\cdot k^d+\Theta(\lg n)\\&amp;=\dfrac{2c}{n}\sum_{k=\lfloor n/2\rfloor}^{n-1} k^d+\Theta(\lg n)\\&amp;\le \dfrac{2c}{n}\int_{\lfloor n/2\rfloor}^n x^d dx+\Theta(\lg n)\\&amp;=\dfrac{2c}{n}\cdot\left.\dfrac{x^{d+1}}{d+1}\right|_{x=\lfloorn/2\rfloor}^n+\Theta(\lg n)\\ &amp;=c\cdot\dfrac{2-2^{-d}}{d+1}\cdot n^d+ \Theta(\lg n) \end{aligned}\)</span></p><p>考虑关于<span class="math inline">\(d\)</span>的一元一次不等式<span class="math inline">\(\dfrac{2-2^{-d}}{d+1}&lt;1\)</span>，可以得到<span class="math inline">\(d&gt;0\)</span>。</p><p>也就是说，无论<span class="math inline">\(d\)</span>取<span class="math inline">\((0,1)\)</span>中的什么值，只要第一个项中的<span class="math inline">\(c\)</span>足够大，它就可以覆盖到<span class="math inline">\(\Theta(\lg n)\)</span>中的常数，从而最终得到<span class="math inline">\(T_{\infty}(n)\)</span></p><p>因此，<span class="math inline">\(T_{\infty}(n)=o(n^d)\)</span>，其中<span class="math inline">\(d\)</span>是任意正数。</p><p>最终可以得到并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^{1-d})\)</span>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论26.3 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/26-3-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/26-3-Exercises/</id>
    <published>2023-10-01T11:28:01.000Z</published>
    <updated>2023-10-01T11:28:01.400Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">26.3-1</h1><p>基本思想是，只需要当前排序的数组长度小于等于某个很小的阈值<span class="math inline">\(K\)</span>，那么就选择使用原本串行的归并方式。否则使用当前优化过的归并方式，这个过程由<code>P-MERGE'</code>给出。其中<code>MEGRE'</code>和<code>MERGE</code>相比，表示将排序结果存储到<span class="math inline">\(B\)</span>中（而不是原本的<span class="math inline">\(A\)</span>中）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">P-MERGE&#x27;(A, p, q, r)</span><br><span class="line">  let B[p : r] be a new array             // allocate scratch array</span><br><span class="line">  if r - p &gt; M</span><br><span class="line">    P-MERGE-AUX(A, p, q, q + 1, r, B, p)  // merge from A into B</span><br><span class="line">  else</span><br><span class="line">    MERGE&#x27;(A, p, q, r, B)</span><br><span class="line">  parallel for i = p to r                 // copy B back to A in parallel</span><br><span class="line">    A[i] = B[i]</span><br></pre></td></tr></table></figure><h1 id="section-1">26.3-2</h1><p>通过对题目9.3-10给出的<code>MEDIAN3</code>进行改造，我们给出了一个程序<code>MEDIAN4</code>，它用于求解两个有序数组<span class="math inline">\(A[1:n],B[1:m]\)</span>中的中位数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 找出数组A[i : n], B[j : m]中的第k小数。</span><br><span class="line">SELECT4(A, i, n, B, j, m, k)</span><br><span class="line">  if i &gt; n</span><br><span class="line">    return B[j + k - 1]</span><br><span class="line">  else if j &gt; m</span><br><span class="line">    return A[j + k - 1]</span><br><span class="line">  else if k == 1</span><br><span class="line">    return min&#123;A[i], B[j]&#125;</span><br><span class="line">  if i + ⌊k/2⌋ - 1 &lt;= n</span><br><span class="line">    midl = A[i + ⌊k/2⌋ - 1]</span><br><span class="line">  else</span><br><span class="line">    midl = +∞</span><br><span class="line">  if j + ⌊k/2⌋ - 1 &lt;= m</span><br><span class="line">    midr = B[i + ⌊k/2⌋ - 1]</span><br><span class="line">  else</span><br><span class="line">    midr = +∞</span><br><span class="line">  if midl &lt; midr</span><br><span class="line">    return SELECT4(A, i + ⌊k/2⌋, n, B, j, m, k - ⌊k/2⌋, n)</span><br><span class="line">  else</span><br><span class="line">    return SELECT4(A, i, n, B, j + ⌊k/2⌋, m, k - ⌊k/2⌋, n)</span><br><span class="line"></span><br><span class="line">MEDIAN4(A, B, n, m)</span><br><span class="line">  return SELECT4(A, 1, n, B, 1, m, ⌊(n + m) / 2⌋)</span><br></pre></td></tr></table></figure><p>由此可以将<code>P-MERGE-AUX</code>修改成<code>P-MERGE-AUX'</code>，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">P-MERGE-AUX(A, p1, r1, p2, r2, B, p3)</span><br><span class="line">  if p1 &gt; r1 and p2 &gt; r2</span><br><span class="line">    return</span><br><span class="line">  if r1 − p1 &lt; r2 − p2</span><br><span class="line">    exchange p1 with p2</span><br><span class="line">    exchange r1 with r2</span><br><span class="line">  x = MEDIAN4(A[p1 : r1], B[p2 : r2], r1 - p1 + 1, r2 - p2 + 2)</span><br><span class="line">  q2 = FIND-SPLIT-POINT(A, p2, r2, x)</span><br><span class="line">  q3 = p3 + (q1 − p1) + (q2 − p2) </span><br><span class="line">  B[q3] = x</span><br><span class="line">  spawn P-MERGE-AUX(A, p1, q1 − 1, p2, q2 − 1, B, p3)</span><br><span class="line">  spawn P-MERGE-AUX(A, q1 + 1, r1, q2, r2, B, q3 + 1)</span><br><span class="line">  sync</span><br></pre></td></tr></table></figure><p>先求解<code>P-MERGE-AUX'</code>的工作量<span class="math inline">\(T_1(n)\)</span>。可见，由于每次都淘汰了数组中一半的元素，并且每一轮除了递归部分，只需要<span class="math inline">\(\Theta(\lg n)\)</span>的时间运行。因此有<span class="math inline">\(T_1(n)=2T_1(n/2)+\Theta(\lgn)\)</span>。根据主定理可以得到<span class="math inline">\(T_1(n)=\Theta(n)\)</span>。</p><p>接下来求解<code>P-MERGE-AUX'</code>的持续时间<span class="math inline">\(T_{\infty}(n)\)</span>。同样的，我们得到<span class="math inline">\(T_\infty(n)=T_\infty(n/2)+\Theta(\lgn)\)</span>。从而得到<span class="math inline">\(T_{\infty}(n)=\Theta(\lg^2n)\)</span>。</p><p>由于<code>P-MERGE-AUX'</code>的工作量和持续时间都不变，因此得到的<code>P-MERGE'</code>得到的工作量和持续时间和第26.3章分析的一样，分别为<span class="math inline">\(\Theta(n)\)</span>和<span class="math inline">\(\Theta(\lg^2n)\)</span>。因此其并行量仍然为<span class="math inline">\(\Theta(n/\lg^2 n)\)</span>。</p><h1 id="section-2">26.3-3</h1><p><code>PARTITION</code>的并行化版本<code>P-PARTITION</code>如下展示。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// 令T[p, r]表示一棵二叉树T存储了区间[p, r]内所有数的相关信息，包括：</span><br><span class="line">// small：A[p, r]中小于等于x的数的个数。</span><br><span class="line">// large：[p, r]中大于x的数的个数。</span><br><span class="line">P-PARTITION-CAL(A, p, r, x)</span><br><span class="line">  if p == r</span><br><span class="line">    if A[p] &lt;= x</span><br><span class="line">      T[p, r].small = 1</span><br><span class="line">      T[p, r].large = 0</span><br><span class="line">      return (1, 0)</span><br><span class="line">    else</span><br><span class="line">      T[p, r].small = 0</span><br><span class="line">      T[p, r].large = 1</span><br><span class="line">      return (0, 1)</span><br><span class="line">  else</span><br><span class="line">    mid = ⌊(p + r) / 2⌋</span><br><span class="line">    cl-small, cl-large = spawn P-PARTITION-CAL(A, p, mid, x)</span><br><span class="line">    cr-small, cr-large = spawn P-PARTITION-CAL(A, mid + 1, q, x)</span><br><span class="line">    sync</span><br><span class="line">    T[p, r].small = cl-small + cr-small</span><br><span class="line">    T[p, r].large = cl-large + cr-large</span><br><span class="line">    return (T[p, r].small, T[p, r].large)</span><br><span class="line"></span><br><span class="line">P-PARTITION-FILL(A, p, r, x, B, ls, rs, ll, rl)</span><br><span class="line">  if p == r:</span><br><span class="line">    if A[p] &lt;= x</span><br><span class="line">      B[ls] = A[p]</span><br><span class="line">    else</span><br><span class="line">      B[ll] = A[p]</span><br><span class="line">  else</span><br><span class="line">    mid = ⌊(p + r) / 2⌋</span><br><span class="line">    spawn P-PARTITION-FILL(A, p, mid, x, B, ls, ls + T[p, mid].small - 1, ll, ll + T[p, mid].large + 1)</span><br><span class="line">    spawn P-PARTITION-FILL(A, p, mid, x, B, rs - T[mid + 1, r].small + 1, rs, rl - T[mid + 1, r].large + 1, rl)</span><br><span class="line">    sync</span><br><span class="line"></span><br><span class="line">P-PARTITION(A, p, r)</span><br><span class="line">  if p == r</span><br><span class="line">    return p</span><br><span class="line">  x = A[r]</span><br><span class="line">  c-small, c-large = P-PARTITION-CAL(A, p, r - 1, x)</span><br><span class="line">  let B[p : r] be a new array</span><br><span class="line">  q = p + c-small</span><br><span class="line">  B[q] = x</span><br><span class="line">  P-PARTION-FILL(A, p, r, x, B, p, p + c-small - 1, r - c-large + 1, r)</span><br><span class="line">  parallel for i = p to r</span><br><span class="line">    A[i] = B[i]</span><br><span class="line">  return q</span><br></pre></td></tr></table></figure></p><p>我们可以首先并行化地构筑出一棵二叉树<span class="math inline">\(T\)</span>，其中<span class="math inline">\(T[l,r]\)</span>存储区间<span class="math inline">\([l,r]\)</span>内的信息：小于等于<span class="math inline">\(x\)</span>的元素个数和大于<span class="math inline">\(x\)</span>的元素个数。我们可以知道这棵树的节点数为<span class="math inline">\(\displaystyle{\sum_{i=0}^{\infty}\left\lceil\dfrac{n}{2^i}\right\rceil}=\Theta(n)\)</span>。</p><p>因此，第一趟遍历首先是将这棵树的所有节点信息先处理出来（如<code>P-PARTITION-CAL</code>所示），由于这棵树一共有<span class="math inline">\(\Theta(n)\)</span>个节点，其深度为<span class="math inline">\(\Theta(\lgn)\)</span>，因此这一部分的工作量为<span class="math inline">\(\Theta(n)\)</span>，持续时间为<span class="math inline">\(\Theta(\lg n)\)</span>。</p><p>第二趟遍历则是按照树给定的信息，自底向上地将所有元素填入新数组<span class="math inline">\(B\)</span>中（如<code>P-PARTITION-FILL</code>所示）。这一部分的分析和第一趟类似，这一部分的工作量为<span class="math inline">\(\Theta(n)\)</span>，持续时间为<span class="math inline">\(\Theta(\lg n)\)</span>。</p><p>第三趟遍历则是将<span class="math inline">\(B\)</span>数组并行地填入<span class="math inline">\(A\)</span>中对应位置，因此这一部分的工作量为<span class="math inline">\(\Theta(n)\)</span>，持续时间为<span class="math inline">\(\Theta(\lg n)\)</span>。</p><p>也就是说，<code>P-PARTITION</code>的工作量<span class="math inline">\(T_1(n)\)</span>满足<span class="math inline">\(T_1(n)=2T_1(n/2)+\Theta(1)\)</span>，即得到<span class="math inline">\(T_1(n)=\Theta(n)\)</span>。其工作时间<span class="math inline">\(T_{\infty}(n)\)</span>满足<span class="math inline">\(T_\infty(n)=T_{\infty}(n/2)+\Theta(1)=\Theta(\lgn)\)</span>。因此其并行度为<span class="math inline">\(\Theta(n/\lgn)\)</span>。</p><h1 id="section-3">26.3-4</h1><p>给出的<code>FFT</code>的并行版本<code>P-FFT</code>如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FFT(a, n)</span><br><span class="line">  if n == 1</span><br><span class="line">    return a</span><br><span class="line">  let a-even_&#123;0 : n / 2 - 1&#125;, a-odd_&#123;0 : n / 2 - 1&#125; be new arrays</span><br><span class="line">  parallel for k = 0 to n / 2 - 1</span><br><span class="line">    a-even_&#123;k&#125; = a_&#123;k * 2&#125;</span><br><span class="line">    a_odd_&#123;k&#125; = a_&#123;k * 2 + 1&#125;</span><br><span class="line">  y-even = spawn FFT(a-even, n / 2)</span><br><span class="line">  y-odd = spawn FFT(a-odd, n / 2)</span><br><span class="line">  sync</span><br><span class="line">  parallel for k = 0 to n / 2 - 1</span><br><span class="line">    ω = exp(2 * π * i * k / n)</span><br><span class="line">    y_k = y-even_&#123;k&#125; + ω * y-odd_&#123;k&#125;</span><br><span class="line">    y_&#123;k + n / 2&#125; = y-even_&#123;k&#125; - ω * y-odd_&#123;k&#125;</span><br><span class="line">  return y</span><br></pre></td></tr></table></figure><p><code>P-FFT</code>和其串行投影<code>FFT</code>的区别在于：将<span class="math inline">\(a\)</span>向量进行奇偶划分的过程可以并行完成。其次，<span class="math inline">\(y^{even},y^{odd}\)</span>的计算也是同时派生出两个子线程再进行合并。此外，<span class="math inline">\(\omega_n^k\)</span>的值不能够递推计算，它只能以<span class="math inline">\((\omega_n)^k\)</span>的方式进行计算。</p><p>可见其串行投影为普通的<code>FFT</code>，因此其工作量为<span class="math inline">\(T_1(n)=\Theta(n\lg n)\)</span>。</p><p>每次递归，它都会将两个大小恰好为一半的两个子问题进行递归计算，其余部分只需要<span class="math inline">\(\Theta(\lgn)\)</span>的时间就能够完成好（如两次次<code>parallel for</code>循环以及<span class="math inline">\(\omega_n^k\)</span>的计算），因此其持续时间满足<span class="math inline">\(T_{\infty}(n)=T_{\infty}(n/2)+\Theta(\lgn)\)</span>，最终得到<span class="math inline">\(T_{\infty}(n)=\Theta(\lg^2n)\)</span>。</p><p>因此，<code>P-FFT</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n/\lgn)\)</span>。</p><h1 id="star-26.3-5"><span class="math inline">\(\star\)</span>26.3-5</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">P-SELECT(A, p, r, i)</span><br><span class="line">  g = ⌊(r – p + 1) / 5⌋</span><br><span class="line">  f = (r - p + 1) % 5</span><br><span class="line">  parallel for j = p to p + g – 1</span><br><span class="line">    sort〈A[j], A[j + g], A[j + 2 * g], A[j + 3 * g], A[j + 4 * g]〉in place</span><br><span class="line">  for j = 0 to t - 1</span><br><span class="line">    exchange A[p + 3 * g + j] with A[p + 5 * g + j] </span><br><span class="line">  x = P-SELECT(A, p + 2 * g, p + 3 * g + f – 1, ⌈(g + f) /2⌉)</span><br><span class="line">  q = P-PARTITION-AROUND(A, p, r, x)</span><br><span class="line">  k = q – p + 1</span><br><span class="line">  if i == k</span><br><span class="line">    return A[q]</span><br><span class="line">  else if i &lt; k</span><br><span class="line">    return P-SELECT(A, p, q – 1, i)</span><br><span class="line">  else </span><br><span class="line">    return P-SELECT(A, q + 1, r, i – k)</span><br></pre></td></tr></table></figure><p>修改后得到的<code>P-SELECT</code>算法如上。相比于<code>SELECT</code>，<code>P-SELECT</code>将未满一个组的五个元素进行了延后处理。此外，套用题目26.3-3的结论，<code>P-PARTITION-AROUND</code>可以由<code>PARTITION-AROUND</code>转化而来。其余部分只需要<span class="math inline">\(\Theta(\lg n)\)</span>的时间即可完成。</p><p>因此，<code>P-SELECT</code>的工作量<span class="math inline">\(T_1(n)\)</span>和<code>SELECT</code>的运行时间一样，为<span class="math inline">\(\Theta(n)\)</span>。</p><p><code>P-SELECT</code>的持续时间<span class="math inline">\(T_{\infty}(n)\)</span>可以由<span class="math inline">\(T_{\infty}(n)\leT_{\infty}(n/5)+T_{\infty}(7n/10)+\Theta(\lgn)\)</span>给出。这里可以考虑使用第4.7章介绍的Akra-Bazzi方法进行求解。</p><p>令<span class="math inline">\(c_1=\dfrac{1}{5},c_2=\dfrac{7}{10}\)</span>，构造关于未知数<span class="math inline">\(p\)</span>的方程<span class="math inline">\(c_1^p+c_2^p=1\)</span>，可以得到<span class="math inline">\(p\approx0.84\)</span>。因此，使用等式4.23，可以得到</p><p><span class="math inline">\(\begin{aligned}T_{\infty}(n)&amp;=\Theta\left(n^p\left(1+\int_{1}^n\dfrac{f(x)}{x^{p+1}}dx\right)\right) \\&amp;=\Theta\left(n^p\left(1+\int_{1}^n \dfrac{\lgx}{x^{p+1}}dx\right)\right) \\&amp;=\Theta\left(n^p\left(1+\left(\dfrac{1-n^{-p}(1+p\ln n)}{p^2\ln2}\right)\right)\right) \\ &amp;=\Theta(n^p) \end{aligned}\)</span></p><p>因此，<code>P-SELECT</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^{1-p})\approx\Theta(n^{0.16})\)</span>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论26.2 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/26-2-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/26-2-Exercises/</id>
    <published>2023-10-01T11:27:58.000Z</published>
    <updated>2023-10-01T11:27:58.941Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">26.2-1</h1><p>使用<code>P-MATRIX-MULTIPLY</code>计算<span class="math inline">\(2\times 2\)</span>矩阵的轨迹如下图所示：</p><p><img data-src="26.2-1.png"></p><p>可见，图中有<span class="math inline">\(13\)</span>个节点，因此其工作量为<span class="math inline">\(13\)</span>。此外，粗线表示这个有向无环图的最长链，其一共有<span class="math inline">\(6\)</span>个节点，因此其持续时间为<span class="math inline">\(6\)</span>，最终我们得到并行度为<span class="math inline">\(\dfrac{13}{6}\)</span>。</p><h1 id="section-1">26.2-2</h1><p>使用<code>P-MATRIX-MULTIPLY-RECURSIVE</code>计算<span class="math inline">\(2\times 2\)</span>矩阵的轨迹如下图所示：</p><p><img data-src="26.2-2.png"></p><p>可见，图中有<span class="math inline">\(42\)</span>个节点，因此其工作量为<span class="math inline">\(42\)</span>。此外，粗线表示这个有向无环图的最长链，其一共有<span class="math inline">\(23\)</span>个节点，因此其持续时间为<span class="math inline">\(23\)</span>，最终我们得到并行度为<span class="math inline">\(\dfrac{42}{23}\)</span>。</p><h1 id="section-2">26.2-3</h1><p>对<code>P-MATRIX-MULTIPLY</code>修改后，由<code>P-MATRIX-MULTIPLY'</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, k, k&#x27;)</span><br><span class="line">  if k == k&#x27;</span><br><span class="line">    return a_&#123;ik&#125; * b_&#123;kj&#125;</span><br><span class="line">  else</span><br><span class="line">    mid = ⌊(k + k&#x27;) / 2⌋</span><br><span class="line">    l = spawn P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, k, mid)</span><br><span class="line">    r = P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, mid, k&#x27;)</span><br><span class="line">    sync</span><br><span class="line">    return l + r</span><br><span class="line"></span><br><span class="line">P-MATRIX-MULTIPLY&#x27;(A, B, C, n)</span><br><span class="line">  parallel for i = 1 to n</span><br><span class="line">    parallel for j = 1 to n</span><br><span class="line">      C_&#123;ij&#125; = P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, 1, n)</span><br></pre></td></tr></table></figure><p>可以知道其工作量为<span class="math inline">\(T_1(n)=\Theta(n^3)\)</span>。</p><p>对程序<code>P-MATRIX-MULTIPLY-AUX'</code>的分析和对题目26.1-7中对<code>P-MAT-VEC-RECURSIVE-AUX'</code>的分析完全一致。因此，假设<span class="math inline">\(iter_n(i,j)\)</span>表示外层循环为<span class="math inline">\(i\)</span>，内层循环为<span class="math inline">\(j\)</span>时的运行时间，那么有<span class="math inline">\(iter_n(i,j)=O(\lg n)\)</span>。</p><p>由于<code>P-MATRIX-MULTIPLY'</code>首先沿着<code>parallel for</code>循环<span class="math inline">\(i\)</span>的递归树的路径向下，然后沿着内层循环<code>parallel for</code>循环<span class="math inline">\(j\)</span>的递归树的路径向下，因此这个算法的持续时间为<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)+\Theta(\lgn)+\max\{iter_n(i,j):1\le i,j\le n\}=\Theta(\lg n)\)</span>。</p><p>因此并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^3/\lgn)\)</span>。</p><h1 id="section-3">26.2-4</h1><p>考虑对题目26.2-3的代码<code>P-MATRIX-MULTIPLY'</code>进行修改，最终由<code>P-MATRIX-MULTIPLY''</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">P-MATRIX-MULTIPLY-AUX&#x27;&#x27;(A, B, i, j, k, k&#x27;)</span><br><span class="line">  if k == k&#x27;</span><br><span class="line">    return a_&#123;ik&#125; * b_&#123;kj&#125;</span><br><span class="line">  else</span><br><span class="line">    mid = ⌊(k + k&#x27;) / 2⌋</span><br><span class="line">    l = spawn P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, k, mid)</span><br><span class="line">    r = P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, mid, k&#x27;)</span><br><span class="line">    sync</span><br><span class="line">    return l + r</span><br><span class="line"></span><br><span class="line">P-MATRIX-MULTIPLY&#x27;&#x27;(A, B, C, p, q, r)</span><br><span class="line">  parallel for i = 1 to p</span><br><span class="line">    parallel for j = 1 to r</span><br><span class="line">      C_&#123;ij&#125; = P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, 1, q)</span><br></pre></td></tr></table></figure><p>使用和题目26.2-3一样的分析方式，我们可以知道这个算法的工作量为<span class="math inline">\(T_1(n)=\Theta(pqr)\)</span>。</p><p>如果假设<span class="math inline">\(iter_n(i,j)\)</span>表示外层循环为<span class="math inline">\(i\)</span>，内层循环为<span class="math inline">\(j\)</span>时的运行时间，那么有<span class="math inline">\(iter_n(i,j)=O(\lgq)\)</span>。那么这个算法的持续时间为<span class="math inline">\(T_{\infty}(n)=\Theta(\lg p)+\Theta(\lgr)+\max\{iter_n(i,j):1\le i\le p,1\le j\le r\}=\Theta(\lg(pqr))\)</span>。</p><p>因此并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(pqr/\lg(pqr))\)</span>。</p><h1 id="section-4">26.2-5</h1><p>修改后的可并行化的Floyd-Warshall算法由<code>P-FLOYD-WARSHALL'</code>给出（使用题目23.2-4的Floyd-Warshall算法伪代码<code>FLOYD-WARSHALL'</code>进行修改）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">P-FLOYD-WARSHALL&#x27;(W, n)</span><br><span class="line">  D = W</span><br><span class="line">  for k = 1 to n</span><br><span class="line">    parallel for i = 1 to n</span><br><span class="line">      parallel for j = 1 to n</span><br><span class="line">        d_&#123;ij&#125; = min &#123;d_&#123;ij&#125;, d_&#123;ik&#125; + d_&#123;kj&#125; &#125;</span><br><span class="line">6 return D</span><br></pre></td></tr></table></figure><p>首先说明一下这样修改的正确性。可见，在第<span class="math inline">\(k\)</span>轮循环中，<code>P-FLOYD-WARSHALL'</code>的第5行只会使用<span class="math inline">\(D\)</span>的第<span class="math inline">\(k\)</span>行和第<span class="math inline">\(k\)</span>列中的元素进行读取，并对其它元素进行修改。由于原来的图是一个非负边权的图，因此哪怕对<span class="math inline">\(d_{ik},d_{kj}\)</span>这样的元素进行更新，也不会对原本的值进行改变。因此。这个算法通过如此并行化完成是正确的。</p><p>这个程序的串行投影需要花费<span class="math inline">\(\Theta(n^3)\)</span>的时间完成，因此其工作量为<span class="math inline">\(T_1(n)=\Theta(n^3)\)</span>。</p><p>接下来求解持续时间<span class="math inline">\(T_{\infty}(n)\)</span>。假设<span class="math inline">\(iter_n(i,j)\)</span>表示外层<code>parallel for</code>循环为<span class="math inline">\(i\)</span>，内层<code>parallel for</code>循环为<span class="math inline">\(j\)</span>时的运行时间，那么有<span class="math inline">\(iter_n(i,j)=O(1)\)</span>，因为接下来只有一个较小值更新操作和加法操作。将两层循环中的<code>parallel</code>关键字转化为<code>spawn ... sync</code>结构后，那么可以得知<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)+\Theta(\lgn)+\max\{iter_n(i,j):1\le i,j\le n\}=\Theta(\lgn)\)</span>。由于这个两层<code>parallel for</code>循环需要串行地执行<span class="math inline">\(k\)</span>次，因此我们可以求出<span class="math inline">\(T_{\infty}(n)=n\cdot \Theta(\lg n)=\Theta(n\lgn)\)</span>。</p><p>最终并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^3/(n\lgn))=\Theta(n^2/\lg n)\)</span>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论26.1 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/26-1-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/26-1-Exercises/</id>
    <published>2023-10-01T11:27:56.000Z</published>
    <updated>2023-10-01T11:27:56.423Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">26.1-1</h1><p>一个串行算法的运行轨迹是看起来是一个单链表。相比于图26.2和图26.4所展示的运行轨迹，每个节点最多只有一条入边和一条出边。</p><h1 id="section-1">26.1-2</h1><p>相比于原来，现在<code>P-FIB</code>变成了<code>P-FIB'</code>，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">P-FIB&#x27;(n)</span><br><span class="line">  if n &lt;= 1</span><br><span class="line">    return n</span><br><span class="line">  else </span><br><span class="line">    x = spawn P-FIB&#x27;(n − 1)</span><br><span class="line">    y = spawn P-FIB&#x27;(n − 2)</span><br><span class="line">    sync</span><br><span class="line">    return x + y</span><br></pre></td></tr></table></figure><p>与原来的区别在于，父线程一进入<code>else</code>就被挂起，并且产生了两个子线程来求解<code>P-FIB'(n − 1)</code>和<code>P-FIB'(n − 2)</code>，父线程会一直等待，直到这两个线程完成执行，最终才返回计算结果。</p><p>因此，除了增加了一些线程本身的空间占用，这种做法并不会产生任何的改进，因此其渐进工作量<span class="math inline">\(T_1&#39;\)</span>仍然为<span class="math inline">\(\Theta(\phi^n)\)</span>，其持续时间仍然是<span class="math inline">\(T_{\infty}&#39;=\Theta(n)\)</span>，并行度为<span class="math inline">\(T_1&#39;/T_{\infty}&#39;=\Theta(\phi^n/n)\)</span>。</p><h1 id="section-2">26.1-3</h1><p>如下图所示，为<code>P-FIB(5)</code>的计算有向无环图。可见，图中有<span class="math inline">\(29\)</span>个节点，因此其工作量为<span class="math inline">\(29\)</span>。此外，粗线表示这个有向无环图的最长链，其一共有<span class="math inline">\(10\)</span>个节点，因此其持续时间为<span class="math inline">\(10\)</span>，最终我们得到并行度为<span class="math inline">\(2.9\)</span>。</p><p><img data-src="26.1-3.png"></p><h1 id="section-3">26.1-4</h1><p>假设这些时间步中，一共有<span class="math inline">\(x\)</span>个非完全步，一共有<span class="math inline">\(y\)</span>个完全步。那么必定有<span class="math inline">\(y\le\lfloor(T_1 -x)/P\rfloor\)</span>。我们通过反证法来证明这个不等式是成立的。</p><p>由于每个非完全步至少有<span class="math inline">\(1\)</span>的工作量，因此至多只有<span class="math inline">\(T_1-x\)</span>的工作量在完全步完成，也就是说，有<span class="math inline">\(Py\le T_1-x\)</span>。假设<span class="math inline">\(y&gt;\lfloor(T_1 -x)/P\rfloor\)</span>，那么有</p><p><span class="math inline">\(\begin{aligned} Py&amp;\geP\cdot(\lfloor(T_1 - x)/P\rfloor+1)\\ &amp;=P\cdot\lfloor(T_1 -x)/P\rfloor+P\\ &amp;=P\cdot\left(\dfrac{T_1-x}{P}-((T_1-x)\bmodP)\right) + P\\ &amp;=T_1-x+P-((T_1-x)\bmod P)\\ &amp;&gt;T_1-x\end{aligned}\)</span></p><p>这和<span class="math inline">\(Py\le T_1-x\)</span>矛盾，因此有<span class="math inline">\(y\le\lfloor(T_1 - x)/P\rfloor\)</span>。</p><p>那么有<span class="math inline">\(T_p=x+y\le x+\lfloor(T_1 -x)/P\rfloor\)</span>。由于<span class="math inline">\(x\leT_\infty\)</span>，即<span class="math inline">\(x\)</span>是所有时间步的一个子集，因此有</p><p><span class="math inline">\(\begin{aligned} T_p&amp;\le x+\lfloor(T_1- x)/P\rfloor\\ &amp;\le x+(T_1 - x)/P\\ &amp;\le T_\infty+(T_1 -T_\infty)/P\\ \end{aligned}\)</span></p><p>原结论成立。</p><h1 id="section-4">26.1-5</h1><p><img data-src="26.1-5.png"></p><p>假设现在有<span class="math inline">\(k\)</span>个处理器，<span class="math inline">\(k+1\)</span>个任务，其中每个串行任务内部一共有<span class="math inline">\(m\)</span>个节点。那么左图是贪心调度器的一种调度，接下来的<span class="math inline">\(m\)</span>个时间步它先完成<span class="math inline">\(k\)</span>个任务的串行节点，然后再花费<span class="math inline">\(m\)</span>个时间步进行剩下的那一个任务，在这种调度下，花费了<span class="math inline">\(2m+2\)</span>个时间步完成整个程序的运行（注意，这里加上了开始和结束的时间步）。如左图所示。</p><p>另一种调度则是，每次优先选择剩余时间最长的<span class="math inline">\(k\)</span>个任务运行一个时间步，直到完成所有任务为止。因此，这个过程总共需要<span class="math inline">\(\left\lceil\dfrac{(k+1)m}{k}\right\rceil+2=\left\lceilm+\dfrac{m}{k}\right\rceil+2\)</span>个时间步进行。如右图所示。</p><p>因此，有<span class="math inline">\(\displaystyle{\lim_{k\rightarrow+\infty}(2m+2)/\left(\left\lceilm+\dfrac{m}{k}\right\rceil+2\right)=2}\)</span>，这时第一种调度所花费的时间步是第二种调度的接近<span class="math inline">\(2\)</span>倍。</p><h1 id="section-5">26.1-6</h1><p>根据工作量定律，有<span class="math inline">\(T_1\le \min\{4\cdotT_4,10\cdot T_{10},64\cdot T_{64}\}\)</span>，从而得到<span class="math inline">\(T_1\le 320\)</span>。</p><p>根据持续时间定理，有<span class="math inline">\(T_\infty\le\min\{T_4,T_{10},T_{64}\}\)</span>，从而得到<span class="math inline">\(T_\infty\le 10\)</span>。</p><p>对<span class="math inline">\(T_{10}\)</span>对应的情况应用不等式26.5，那么有</p><p><span class="math inline">\(\begin{aligned} T_{10}&amp;\le\dfrac{T_1-T_\infty}{10}+T_\infty\\ &amp;\le \dfrac{T_1+9T_\infty}{10}\\&amp;\le 32+\dfrac{9T_\infty}{10} \end{aligned}\)</span></p><p>从而得到<span class="math inline">\(T_\infty&gt;\dfrac{100}{9}\)</span>，这和给出的<span class="math inline">\(T_{\infty}\le10\)</span>是矛盾的，因此这个教授是在撒谎。</p><h1 id="section-6">26.1-7</h1><p>可以将提供的<code>P-MAT-VEC-RECURSIVE</code>进行改造后，得到如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">P-MAT-VEC-RECURSIVE-AUX&#x27;(A, x, n, i, j, j&#x27;)</span><br><span class="line">  if j == j&#x27;</span><br><span class="line">    return a_&#123;i, j&#125; * x_j</span><br><span class="line">  else</span><br><span class="line">    mid = ⌊(j + j&#x27;) / 2⌋</span><br><span class="line">    l = spawn P-MAT-VEC-RECURSIVE-AUX&#x27;(A, x, n, i, j, mid)</span><br><span class="line">    r = P-MAT-VEC-RECURSIVE-AUX&#x27;(A, x, n, i, mid + 1, j&#x27;)</span><br><span class="line">    sync</span><br><span class="line">    return l + r</span><br><span class="line"></span><br><span class="line">P-MAT-VEC-RECURSIVE&#x27;(A, x, y, n)</span><br><span class="line">  parallel for i = 1 to n</span><br><span class="line">    y_i = P-MAT-VEC-RECURSIVE-AUX&#x27;(A, x, n, i, 1, n)</span><br></pre></td></tr></table></figure><p>其基本思想在于，对于<span class="math inline">\(A\)</span>的每一行都和<span class="math inline">\(x\)</span>独立相乘，得到一个值。然后，先计算这一行左半部分和<span class="math inline">\(x\)</span>的左半部分点积；右半部分和<span class="math inline">\(x\)</span>的左半部分点并行进行计算，最终将结果合并。</p><p>因此，<code>P-MAT-VEC-RECURSIVE'</code>的工作量为<span class="math inline">\(T_1(n)=\Theta(n^2)\)</span>，因为它仍然运行了<span class="math inline">\(n^2\)</span>次乘法运算。</p><p><code>P-MAT-VEC-RECURSIVE'</code>的持续时间<span class="math inline">\(T_{\infty}(n)\)</span>如下计算。由于<code>P-MAT-VEC-RECURSIVE'</code>中的每次循环都是独立的，因此令<span class="math inline">\(iter_{\infty}(n,i)\)</span>表示第<span class="math inline">\(i\)</span>次的循环结果，我们可以得到：</p><p><span class="math display">\[T_{\infty}(n)=\Theta(\lgn)+\max\{iter_{\infty}(n,i):1\le i\le n\}\]</span></p><p>对于每一次<code>P-MAT-VEC-RECURSIVE-AUX'</code>的调用，我们可以发现，每一次调用都将求和的范围减小，因此有<span class="math inline">\(iter_{\infty}(n,i)=iter_{\infty}(n/2,i)+\Theta(1)\)</span>。根据主定理，可以得到：</p><p><span class="math display">\[iter_{\infty}(n,i)=\Theta(\lgn)+\Theta(\lg n)\]</span></p><p>因此，我们最终得到<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)+\Theta(\lgn)=\Theta(\lg n)\)</span>。</p><p>最终我们得到这个算法的并行度为<span class="math inline">\(T_1(n)/T_\infty(n)=\Theta(n^2/\lgn)\)</span>。</p><h1 id="section-7">26.1-8</h1><p>可见，这个程序的串行投影需要花费<span class="math inline">\(\Theta(n^2)\)</span>的时间完成，因此其工作量为<span class="math inline">\(T_1(n)=\Theta(n^2)\)</span>。</p><p>接下来求解持续时间<span class="math inline">\(T_{\infty}(n)\)</span>。令<span class="math inline">\(iter_1(j)(2\le j\len)\)</span>表示其外层循环所需要的时间，<span class="math inline">\(iter_2(i)(1\le j&lt;n)\)</span>表示其内层循环所需要的时间。</p><p>如果将内层<code>for</code>循环的<code>parallel</code>关键字转化为<code>spawn ... sync</code>结构后，那么可以得知<span class="math inline">\(iter_1(i)=\Theta(\lg i)+\max\{iter_2(j):1\lej&lt;i\}\)</span>。可以知道，由于<span class="math inline">\(iter_2(j)=\Theta(1)\)</span>，因此有<span class="math inline">\(iter_1(i)=\Theta(\lg i)+\Theta(1)=\Theta(\lgi)\)</span>。</p><p>再将外层<code>for</code>循环的<code>parallel</code>关键字转化为<code>spawn ... sync</code>结构后，那么可以得知<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)+\max\{iter_1(i):2\lej\le n\}=\Theta(\lg n)+\Theta(\lg n)\)</span>。从而得到<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)\)</span>。</p><p>因此并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^2/\lgn)\)</span>。</p><h1 id="section-8">26.1-9</h1><p>也就是说，现在的程序转化为<code>P-TRANSPOSE'</code>，即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P-TRANSPOSE(A, n)</span><br><span class="line">  parallel for j = 2 to n</span><br><span class="line">    for i = 1 to j − 1</span><br><span class="line">      exchange a_&#123;ij&#125; with a_&#123;ji&#125;</span><br></pre></td></tr></table></figure><p>工作量和题目28.1-8的情况一样，为<span class="math inline">\(T_1(n)=\Theta(n^2)\)</span>。</p><p>接下来求解持续时间<span class="math inline">\(T_{\infty}(n)\)</span>。令<span class="math inline">\(iter(j)(2\le j\len)\)</span>表示其外层循环所需要的时间，由内层循环可以知道，<span class="math inline">\(iter(j)=\Theta(j)\)</span>。将外层<code>for</code>循环的<code>parallel</code>关键字转化为<code>spawn ... sync</code>结构后，那么可以得知<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)+\max\{iter(i):2\lej\le n\}=\Theta(\lg n)+\Theta(n)\)</span>。因此，我们最终得到<span class="math inline">\(T_{\infty}(n)=\Theta(\lgn)+\Theta(n)=\Theta(n)\)</span>。</p><p>因此并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^2/n)=\Theta(n)\)</span>。</p><h1 id="section-9">26.1-10</h1><p>相当于解如下关于未知数<span class="math inline">\(P,T_P,T_P&#39;\)</span>的方程组：</p><p><span class="math display">\[\left \{\begin{aligned}  &amp;T_P=\dfrac{T_1}{P}+T_\infty\\  &amp;T_P&#39;=\dfrac{T_1&#39;}{P}+T_\infty&#39;\\  &amp;T_P=T_P&#39;\\\end{aligned}\right.\]</span></p><p>其中<span class="math inline">\(T_1=2048,T_{\infty}=1,T_1&#39;=1024,T_{\infty}&#39;=8\)</span>，最终得到解：</p><p><span class="math display">\[\left \{\begin{aligned}  &amp;P=\dfrac{1024}{7}\\  &amp;T_P=15\\  &amp;T_P&#39;=15\\\end{aligned}\right.\]</span></p><p>也就是说，只需要约<span class="math inline">\(146\)</span>或者<span class="math inline">\(147\)</span>个处理器就能使这两个版本的算法运行时间相同。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>滴滴 秋招 2023.09.28 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Didi-20230928/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Didi-20230928/</id>
    <published>2023-09-29T09:06:03.000Z</published>
    <updated>2023-09-29T09:06:03.565Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="圆木加工">1、圆木加工</h1><p>一家木材厂需要加工三根圆木。这三根圆木长度分别为<span class="math inline">\(a,b,c\)</span>，一共需要进行不超过<span class="math inline">\(n\)</span>次加工程序。第<span class="math inline">\(i\)</span>道加工程序需要选择其中一根长度严格大于<span class="math inline">\(i\)</span>的圆木，将其切割，使其长度减少<span class="math inline">\(i\)</span>。被切下的部分不再进入后续的加工流程。如果这三根圆木的长度能够组成一个面积大于<span class="math inline">\(0\)</span>的三角形，那么就称此时的圆木长度三元组<span class="math inline">\((a&#39;,b&#39;,c&#39;)\)</span>是好的。</p><p>现在的问题是：一共可能形成多少种好的三元组？</p><h2 id="输入">输入</h2><p>输入仅一行四个正整数<span class="math inline">\(n,a,b,c\)</span>。</p><p>对于<span class="math inline">\(100\%\)</span>的数据，<span class="math inline">\(1\le n,a,b,c \le 100\)</span>。</p><h2 id="输出">输出</h2><p>输出一行，一个整数，表示好的三元组的个数。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5 3 4 5</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">有如下10种三元组</span><br><span class="line">(1,4,4),(2,2,2),(2,4,3),(2,4,5),(3,2,4),(3,3,3),(3,3,5),(3,4,2),(3,4,4),(3,4,5)</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>对于三种原木<span class="math inline">\((a,b,c)\)</span>是否能拼接成一个三角形，只需要判断<span class="math inline">\(a+b&gt;c,a+c&gt;b,b+c&gt;a\)</span>是否都成立即可。</p><p>由于第<span class="math inline">\(i\)</span>次加工程序切除原木的长度只依赖于<span class="math inline">\(i\)</span>本身，因此，如果从原木<span class="math inline">\((a,b,c)\)</span>经过若干道加工程序变成<span class="math inline">\((a&#39;,b&#39;,c&#39;)\)</span>后，其使用的加工轮数必定是确定的。也就是说，只要从<span class="math inline">\((a,b,c)\)</span>变成<span class="math inline">\((a&#39;,b&#39;,c&#39;)\)</span>，那么必定进行了<span class="math inline">\(k\)</span>轮，并且<span class="math inline">\(k\)</span>是一个常数，不依赖于现有的决策。</p><p>因此，我们使用带有记忆化的深度优先搜索即可完成本题。如果发现当前状态<span class="math inline">\((a,b,c)\)</span>被遍历过，那么就直接返回，否则进一步向下进行枚举即可。这保证了每个不同的三元组<span class="math inline">\((a,b,c)\)</span>都只被遍历一次。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">104</span>;</span><br><span class="line"><span class="type">int</span> n,a,b,c;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> vis[N][N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[a][b][c]) <span class="keyword">return</span>;</span><br><span class="line">    vis[a][b][c]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a+b&gt;c&amp;&amp;a+c&gt;b&amp;&amp;b+c&gt;a) ++ans;</span><br><span class="line">    <span class="keyword">if</span>(k==n+<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;k) <span class="built_in">dfs</span>(k+<span class="number">1</span>,a-k,b,c);</span><br><span class="line">    <span class="keyword">if</span>(b&gt;k) <span class="built_in">dfs</span>(k+<span class="number">1</span>,a,b-k,c);</span><br><span class="line">    <span class="keyword">if</span>(c&gt;k) <span class="built_in">dfs</span>(k+<span class="number">1</span>,a,b,c-k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>,&amp;n,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,a,b,c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="平衡树">2、平衡树</h1><p>小明正在玩一棵树，它正在研究树的平衡性，它为了辅助研究，为树定义了一个函数<span class="math inline">\(S(x)\)</span>，表示对树中节点<span class="math inline">\(x\)</span>，其到树中其他所有节点的距离之和，注意树上相邻节点之间距离为<span class="math inline">\(1\)</span>，而且树根为<span class="math inline">\(1\)</span>号节点。现在他想让你帮他进行计算！</p><h2 id="输入-1">输入</h2><p>第一行两个正整数<span class="math inline">\(n,m\)</span>分别表示树上的节点数和询问数。</p><p>接下来一行<span class="math inline">\(n-1个数\)</span>p_2,p_3,p_n<span class="math inline">\(。表示节点\)</span>i<span class="math inline">\(的父亲为\)</span>p_i$。</p><p>接下来一行<span class="math inline">\(m\)</span>个数，<span class="math inline">\(x_1,x_2,\dotsx_m\)</span>，分别表示每次询问所使用的<span class="math inline">\(x\)</span>值。</p><p>对于所有数据，<span class="math inline">\(1\le n,m\le 20000,1\lep_i&lt; n, 1 \le x_i \le n\)</span>。</p><h2 id="输出-1">输出</h2><p>输出一行<span class="math inline">\(m\)</span>个数，单空格隔开，分别表示每次询问的答案。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3 3</span><br><span class="line">1 1</span><br><span class="line">1 2 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2 3 3</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>这道题是原题Leetcode834。其使用的基本思想是换根动态规划，进行两次深度优先搜索即可完成，其中第二次搜索使用了动态规划的思想。</p><p>其基本思想是，首先我们先以<span class="math inline">\(O(n)\)</span>的时间复杂度求出一个节点的答案值，然后再将其转移到每个节点的答案。</p><p>令<span class="math inline">\(d_i\)</span>表示节点<span class="math inline">\(i\)</span>的深度，<span class="math inline">\(s_i\)</span>表示以节点<span class="math inline">\(i\)</span>为根的子树中的节点数个数，<span class="math inline">\(f_i\)</span>表示<span class="math inline">\(i\)</span>到其它节点的所有距离之和。</p><p>通过第一次深度优先搜索，我们可以求出数组<span class="math inline">\(d,s\)</span>。并且，我们能够利用好数组<span class="math inline">\(d\)</span>给出第一个转移：</p><ul><li><span class="math inline">\(\displaystyle{\sum_{i=1}^nd_i\rightarrow f_1}\)</span></li></ul><p>以上根据定义是显而易见的。令<span class="math inline">\(\text{son}(u)\)</span>表示<span class="math inline">\(u\)</span>的所有子节点，那么考虑<span class="math inline">\(v\in\text{son}(u)\)</span>，我们可以列出如下转移：</p><ul><li><span class="math inline">\(f_u+(n-s_v)-s_v\rightarrowf_v\)</span></li></ul><p>当我们已经求出了节点<span class="math inline">\(u\)</span>的<span class="math inline">\(f_u\)</span>值后，那么对于<span class="math inline">\(u\)</span>其中的一个子节点，<span class="math inline">\(f_u\)</span>值会发生什么变化呢？对于一个节点<span class="math inline">\(w\)</span>，如果它在<span class="math inline">\(v\)</span>的子树，那么从<span class="math inline">\(u\)</span>走到<span class="math inline">\(w\)</span>的距离减少了<span class="math inline">\(1\)</span>，因此需要减去<span class="math inline">\(s_v\)</span>；如果它不在<span class="math inline">\(v\)</span>的子树，那么从<span class="math inline">\(u\)</span>走到<span class="math inline">\(w\)</span>的距离增加了<span class="math inline">\(1\)</span>，因此可以得出如上转移。这在<span class="math inline">\(O(n)\)</span>的时间内可以完成。</p><p>对于给定的每个询问<span class="math inline">\(x\)</span>，直接输出<span class="math inline">\(f_x\)</span>的值即可。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">20004</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans[N],d[N],sz[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;g[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> dis)</span></span>&#123;</span><br><span class="line">    d[u]=dis;</span><br><span class="line">    sz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:g[u])&#123;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,dis+<span class="number">1</span>);</span><br><span class="line">        sz[u]+=sz[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:g[u])&#123;</span><br><span class="line">        ans[v]=ans[u]-sz[v]+(n-sz[v]);</span><br><span class="line">        <span class="built_in">dfs2</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        g[x].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans[<span class="number">1</span>]+=d[i];</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>,ans[x],<span class="string">&quot; \n&quot;</span>[i==m]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>华为 秋招 2023.09.27 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Huawei-20230927/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Huawei-20230927/</id>
    <published>2023-09-27T16:14:45.000Z</published>
    <updated>2023-09-27T16:14:45.218Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="价格优惠">1、价格优惠</h1><p>某商城进行“双十一”促销活动，活动采用等价格减免的方式，某位客人一次购买了<span class="math inline">\(N\)</span>件商品，需要帮忙计算本次购买能获得的总优惠。给定商品价格数组<span class="math inline">\(p\)</span>，其中<span class="math inline">\(p[i]\)</span>表示第i件商品的价格，第<span class="math inline">\(i\)</span>件商品能获得的优惠为第<span class="math inline">\(i\)</span>件商品之前的第<span class="math inline">\(j\)</span>件商品的价格，其中<span class="math inline">\(p[j]\le p[i]\)</span>，并目<span class="math inline">\(j\le i\)</span>，且<span class="math inline">\(p[j]\)</span>是离<span class="math inline">\(p[i]\)</span>最近的一个小于等于<span class="math inline">\(p[i]\)</span>的商品。求本次购买能获得的总优惠。</p><p>例如：给定价格数组<span class="math inline">\(p=[9,4,3,5],p[3]=5\)</span>能获得的优惠为<span class="math inline">\(p[2]=3,p[2]\)</span>是满足条件离<span class="math inline">\(p[3]\)</span>最近的一个商品，其中<span class="math inline">\(p[1]=4\)</span>也小于<span class="math inline">\(p[3]\)</span>，但不是离<span class="math inline">\(p[3]\)</span>最近的商品。</p><h2 id="输入">输入</h2><p>第一行是商品的个数<span class="math inline">\(N,1\le N\le100000\)</span>。</p><p>第二行是用空格分隔的<span class="math inline">\(N\)</span>个整数，数组元素的值表示商品的价格<span class="math inline">\(0&lt; p[i]\le 100000\)</span>。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">9 4 5 2 4 </span><br></pre></td></tr></table></figure><h2 id="输出">输出</h2><p>输出为一个整数，表示本次购买获得的总优惠。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">9 4 5 2 4</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">商品0的价格为p[0]=9，第一件商品之前无其他商品，该商品获得的优惠为0。</span><br><span class="line">商品1的价格为p[1]=4，p[1]之前不存在满足条件的商品，该商品获得的优惠为0。</span><br><span class="line">商品2的价格为p[2]=5，p[2]之前满足条件的最近的一个商品为p[1]=4，该商品获得的优惠为4。</span><br><span class="line">商品3的价格为p[3]=2，p[3]之前没有满足条件的商品，该商品获得的优惠为0。</span><br><span class="line">商品4的价格为p[4]=4。p[4]之前满足条件的最近的一个商品为p[3]=2，该商品获得的优惠为2。</span><br><span class="line">由此可以计算出本次购买可以获得的总优惠为： 4+2=6。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">4</span><br><span class="line">1 2 3 5</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">商品0的价格为p[0]=1，第一件商品之前无其他商品，该商品获得的优惠为0。</span><br><span class="line">商品1的价格为p[1]=2，p[1]之前满足条件的最近的一个商品为p[0]=1，该商品获得的优惠为1。</span><br><span class="line">商品2的价格为p[2]=3，p[2]之前满足条件的最近的一个商品为p[1]=2，该商品获得的优惠为2。</span><br><span class="line">商品3的价格为p[3]=5，p[3]之前满足条件的最近的一个商品为p[2]=3，该商品获得的优惠为3。</span><br><span class="line">由此可以计算出本次购买可以获得的总优惠为：1+2+3=6。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">4</span><br><span class="line">4 3 2 1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">商品0的价格为p[0]=9，第一件商品之前无其他商品，该商品获得的优惠为0。</span><br><span class="line">商品1的价格为p[1]=4，p[1]之前不存在满足条件的商品，该商品获得的优惠为0。</span><br><span class="line">商品2的价格为p[2]=5，p[2]之前满足条件的最近的一个商品为p[1]=4，该商品获得的优惠为4。</span><br><span class="line">商品3的价格为p[3]=2，p[3]之前没有满足条件的商品，该商品获得的优惠为0。</span><br><span class="line">商品4的价格为p[4]=4。p[4]之前满足条件的最近的一个商品为p[3]=2，该商品获得的优惠为2。</span><br><span class="line">本次购买每件商品都没有满足条件的优惠，本次购买可获得的优惠为0。</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>本题是Leetcode 496的变种。相当于是为每一个数<span class="math inline">\(p[i]\)</span>找到左边第一个不超过它的数，并加上它。</p><p>因此，使用单调栈可以完美解决这个问题，我们通过维护一个非单调递减的栈来记录元素的值，当把栈中所有比当前元素大的元素弹出后，栈顶即为我们所需要求的值，再把当前的数推进栈中。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"><span class="type">int</span> p[N],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;st;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()&amp;&amp;p[i]&lt;st.<span class="built_in">top</span>()) st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(!st.<span class="built_in">empty</span>())</span><br><span class="line">            ans+=st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">push</span>(p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多项式计算">2、多项式计算</h1><p>给定两个一元多项式以及多项式运算符，计算输出两个多项式运算的结果，计算规则见样例。</p><h2 id="输入-1">输入</h2><p>分三行输入，第一行输入多项式<span class="math inline">\(A\)</span>的系数数组（按照阶数高到低顺序），第二行输入多项式<span class="math inline">\(B\)</span>的系数数组，第三行输入多项式运算符。运算符包括加<code>(+)</code>减<code>(-)</code>乘<code>(*)</code>三种，系数数组大小小于<span class="math inline">\(128\)</span>，系数取值范围<span class="math inline">\([-512,512]\)</span>。</p><h2 id="输出-1">输出</h2><p>输出多项式运算结果的系数数组，如果计算后多项式为<span class="math inline">\(0\)</span>，则输出0。从第<span class="math inline">\(1\)</span>个非零的系数开始输出。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[1 2 3 4 5 6]</span><br><span class="line">[2 3 -4]</span><br><span class="line">+</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[1 2 3 6 8 2]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">多项式系数数组[1 2 3 4 5 6]表示多项式A(x)=x^5 + 2x^4+ 3x^3 + 4x^2 + 5x + 6</span><br><span class="line">多项式系数数组[2 3 -4]表示多项式B(x)=2x^2 + 3x - 4</span><br><span class="line">A(x) + B(x) = x^5 + 2x^4 + 3x^3 + 6x^2 + 8x + 2，对应的多项式系数数组为[1 2 3 6 8 2]。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[1 2 3]</span><br><span class="line">[1 2 1]</span><br><span class="line">-</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[2]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">(x^2 + 2x + 3) - (x^2 + 2x + 1) = 2</span><br><span class="line">高阶的0系数不输出。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[1 1]</span><br><span class="line">[1 1]</span><br><span class="line">*</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[1 2 1]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">(x + 1) * (x + 1) = x^2 + 2x + 1</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>本题是一道输入输出处理题和模拟题。建议使用<code>python</code>结合<code>eval</code>函数来完成。接下来为了方便处理按照多项式的形式进行处理，需要将输入的数组<span class="math inline">\(A,B\)</span>进行逆序。</p><p>逆序完成后，我们可以将下标作为指数，按照多项式的定义进行计算。</p><p>需要注意的是，计算完多项式的结果后，按照题目要求需要注意如下事项：</p><ol type="1"><li>去掉高次中的<span class="math inline">\(0\)</span>系数项。</li><li>如果多项式的结果为<span class="math inline">\(0\)</span>，那么还需要避免输出的多项式为空，需要往对应数组添加回一个<span class="math inline">\(0\)</span>。</li><li>对输出的多项式进行逆序。</li></ol><h2 id="代码-1">代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="built_in">list</span>(<span class="built_in">reversed</span>(<span class="built_in">eval</span>(<span class="built_in">input</span>().replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;,&#x27;</span>))))</span><br><span class="line">B = <span class="built_in">list</span>(<span class="built_in">reversed</span>(<span class="built_in">eval</span>(<span class="built_in">input</span>().replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;,&#x27;</span>))))</span><br><span class="line">op = <span class="built_in">input</span>()</span><br><span class="line">n = <span class="built_in">max</span>(<span class="built_in">len</span>(A), <span class="built_in">len</span>(B))</span><br><span class="line">A += [<span class="number">0</span>] * (n - <span class="built_in">len</span>(A))</span><br><span class="line">B += [<span class="number">0</span>] * (n - <span class="built_in">len</span>(B))</span><br><span class="line"><span class="keyword">if</span> op == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">    C = [A[i] + B[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="keyword">elif</span> op == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">    C = [A[i] - B[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    C = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            C[i + j] += A[i] * A[j]</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(C) &gt; <span class="number">0</span> <span class="keyword">and</span> C[-<span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">    C.pop()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(C) == <span class="number">0</span>:</span><br><span class="line">    C = [<span class="number">0</span>]</span><br><span class="line">C.reverse()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(C).replace(<span class="string">&#x27;, &#x27;</span>, <span class="string">&#x27; &#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="货物运输">3、货物运输</h1><p>有<span class="math inline">\(m\)</span>件货物和<span class="math inline">\(n\)</span>辆卡车，每辆卡车只能运送<strong>一件</strong>货物，卡车的载重量需要<strong>大于等于</strong>货物重量才能运输；</p><p>另有<span class="math inline">\(x\)</span>个载重为<span class="math inline">\(y\)</span>的拖斗，每辆卡车<strong>最多</strong>可以拖挂一个拖斗以提升载重量，共同运输一件更重的货物；</p><p>请你返回<strong>最多</strong>可以运输多少件货物。</p><h2 id="输入-2">输入</h2><p>三行数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m n x y</span><br><span class="line">weight0 weight1 weight2...</span><br><span class="line">load0 load1 load2...</span><br></pre></td></tr></table></figure><p>第<span class="math inline">\(1\)</span>行包含四个数字，分别为：</p><ul><li><span class="math inline">\(m\)</span>：货物数量</li><li><span class="math inline">\(n\)</span>：卡车数量</li><li><span class="math inline">\(x\)</span>：拖斗数量</li><li><span class="math inline">\(y\)</span>：拖斗载重</li></ul><p>第<span class="math inline">\(2\)</span>行为货物的重量列表，以空格分隔；</p><p>第<span class="math inline">\(3\)</span>行为卡车的载重列表，以空格分隔；</p><p>范围：</p><ul><li><span class="math inline">\(1\le\)</span> 货物/卡车<span class="math inline">\(\le 50000\)</span></li><li><span class="math inline">\(0\le\)</span> 拖斗数量<span class="math inline">\(\le 50000\)</span></li><li><span class="math inline">\(0\le\)</span>货物重量/卡车载重量/拖斗载重量<span class="math inline">\(\le1000000000\)</span></li></ul><h2 id="输出-2">输出</h2><p>一个整数，最多可以运输货物的数量。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5 5 1 5</span><br><span class="line">5 5 8 9 9</span><br><span class="line">1 2 4 6 6</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">2号卡车运输1号货物，6&gt;=5</span><br><span class="line">4号卡车运输5号货物，6&gt;=5</span><br><span class="line">5号卡车挂拖斗，运输3号货物，4+5&gt;=8</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">4 4 2 3</span><br><span class="line">9 6 7 8</span><br><span class="line">5 2 3 4</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1号卡车挂拖斗，运输4号货物，5+3&gt;=8</span><br><span class="line">4号卡车挂拖斗，运输3号货物，4+3&gt;=7</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>这道题是Leetcode 2071的原题。按照贪心的思想，如果我们可以完成<span class="math inline">\(k\)</span>个货物的运输，那么用载重最重的<span class="math inline">\(k\)</span>辆卡车运送<span class="math inline">\(k\)</span>个最轻的货物必定是一个解（包括使用拖斗），并且这个解是最极端的情况。</p><p>如果能够运送<span class="math inline">\(k\)</span>件货物，那么就存在一个运送<span class="math inline">\(k-1\)</span>个货物的方案，因此这道题我们可以使用二分进行求解。</p><p>现在需要判断<span class="math inline">\(k\)</span>件货物是否能够被运送。我们将使用载重最大的<span class="math inline">\(k\)</span>辆卡车运送最轻的<span class="math inline">\(k\)</span>个货物。我们从小到大遍历每个货物，每个货物用一个载重比它大，且最载重最小的卡车运行，这才符合我们贪心地思想。如果当前卡车并不能运送当前货物，那么在此之后它也不能够运送其它货物，他这时需要一个拖斗才能够运送，我们需要为这辆卡车添加一个拖斗，并且延后它的使用时期。如果这辆卡车装了拖斗依旧不能运送这个货物，那么说明这个<span class="math inline">\(k\)</span>不可行。最终，我们只需要判断拖斗的使用数量是否不超过<span class="math inline">\(x\)</span>即可。</p><p>此外还需要注意的是，如果一个卡车已经装载了拖斗后，和另一个没装拖斗的卡车载重相等，那么优先使用前一个卡车，因为后一个仍然有提升载重的潜力。</p><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> pi pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[N],l[N],n,m,x,y;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ok</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;pi,vector&lt;pi&gt;,greater&lt;pi&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">pi</span>(l[n-k+i],<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;)&#123;</span><br><span class="line">        <span class="keyword">auto</span> [ld,tp]=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(ld&gt;=w[i])&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tp==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">pi</span>(ld+y,<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt&lt;=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>,&amp;m,&amp;n,&amp;x,&amp;y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;l[i]);</span><br><span class="line">    <span class="built_in">sort</span>(w+<span class="number">1</span>,w+m+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(l+<span class="number">1</span>,l+n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">ok</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="built_in">min</span>(m,n);</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">ok</span>(mid)) l=mid;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>阿里控股 秋招 2023.09.23 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Alikonggu-20230923/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Alikonggu-20230923/</id>
    <published>2023-09-27T16:14:41.000Z</published>
    <updated>2023-09-28T07:26:16.300Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="小红的三元组">1、小红的三元组</h1><p>小红有一个长度为<span class="math inline">\(n\)</span>的数组<span class="math inline">\(a\)</span>，她每次操作可以删掉一个三元组<span class="math inline">\((x,y,z)\)</span>，要求<span class="math inline">\(x&lt;y&lt;z\)</span>，<span class="math inline">\(y\)</span>是<span class="math inline">\(x\)</span>的倍数，<span class="math inline">\(z\)</span>是<span class="math inline">\(y\)</span>的倍数。小红想知道最多可以执行多少次操作。</p><h2 id="输入">输入</h2><p>第一行一个整数<span class="math inline">\(n\)</span>，表示数组的长度。</p><p>第二行<span class="math inline">\(n\)</span>个整数<span class="math inline">\(a_1,a_2,\dots,a_n\)</span>，表示数组的元素。</p><ul><li><span class="math inline">\(1\le n\le 10^5\)</span></li><li><span class="math inline">\(1\le a_i\le 6\)</span></li></ul><h2 id="输出">输出</h2><p>输出一个整数，表示最多可以执行的操作次数。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">7</span><br><span class="line">1 1 2 3 4 5 6</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">先删除(1,2,4)，再删除(1,3,6)。</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>可见，满足题意的三元组只有可能是如下三种情况：<span class="math inline">\((1,2,4),(1,2,6),(1,3,6)\)</span>。</p><p>由于<span class="math inline">\(3,4\)</span>都在这些组合都出现了一次，因此我们优先取走<span class="math inline">\((1,2,4),(1,3,6)\)</span>这些组合，再取走<span class="math inline">\((1,2,6)\)</span>这种组合。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">14</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;v&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        ++a[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> u:v)&#123;</span><br><span class="line">        <span class="type">int</span> t=<span class="built_in">min</span>(a[u[<span class="number">0</span>]],<span class="built_in">min</span>(a[u[<span class="number">1</span>]],a[u[<span class="number">2</span>]]));</span><br><span class="line">        ans+=t;</span><br><span class="line">        a[u[<span class="number">0</span>]]-=t;</span><br><span class="line">        a[u[<span class="number">1</span>]]-=t;</span><br><span class="line">        a[u[<span class="number">2</span>]]-=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小红的连续字符串">2、小红的连续字符串</h1><p>小红有一个字符串<span class="math inline">\(s\)</span>，只包含小写字母。如果一个字符串中，不包含连续的三个相同的字母，并且不存在两个相同的字母紧挨着两个相同的字母，那么这个字符串就是合法的。例如，字符串<code>"aaa"</code>是不合法的，字符串<code>"aabb"</code>也是不合法的。字符串<code>"aab"</code>是合法的。</p><p>小红想知道，最少需要删除多少个字符，才能使得字符串变成合法的。</p><h2 id="输入-1">输入</h2><p>第一行一个字符串<span class="math inline">\(s\)</span>，长度不超过<span class="math inline">\(10^5\)</span>，只包含小写字母。</p><h2 id="输出-1">输出</h2><p>输出一个整数，表示最少需要删除的字符个数。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">aabbaa</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">删除一个字符b，得到aabaa，是一个合法的字符串。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">aaabbb</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">删除三个字符，得到aab，是一个合法的字符串。</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>由于不允许连续三个字母挨在一起，因此我们首先将连续多于两个字母的都删剩两个，然后再考虑下一步。</p><p>接下来每一块相同的字母不超过<span class="math inline">\(2\)</span>个。我们接下来从前往后遍历每个连续块。如果当前连续块的字母个数为<span class="math inline">\(2\)</span>，并且前一个连续块字母个数也为<span class="math inline">\(2\)</span>，那么删除当前块的一个字母（因为删除前面的并不会使结果变得更优）。</p><p>因此，只需要统计两个过程删去的字符数即可。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"><span class="type">int</span> a[N],m=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>,pre=s[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==pre) ++cnt;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            a[++m]=cnt;</span><br><span class="line">            cnt=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        a[i]=<span class="built_in">min</span>(a[i],<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">2</span>&amp;&amp;a[i]==<span class="number">2</span>&amp;&amp;a[i<span class="number">-1</span>]==<span class="number">2</span>)&#123;</span><br><span class="line">            --a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        s+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n-s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="有根树无重复数的路径">3、有根树无重复数的路径</h1><p>小红拿到了一个有根树，根节点为<span class="math inline">\(1\)</span>号节点，每个节点到其每个孩子有一条有向边。小红想取一条路径，满足路径上所有节点的权值都不相等。小红想知道，自己有多少种选择方案？</p><h2 id="输入-2">输入</h2><p>第一行输入一个正整数<span class="math inline">\(n\)</span>，代表节点的数量。</p><p>第二行输入<span class="math inline">\(n-1\)</span>个正整数<span class="math inline">\(a_i\)</span>，代表<span class="math inline">\(2\)</span>号节点到<span class="math inline">\(n\)</span>号节点每个节点的父亲编号。</p><p>第三行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(v_i\)</span>，代表<span class="math inline">\(1\)</span>号节点到<span class="math inline">\(n\)</span>号节点每个节点的权值。</p><ul><li><span class="math inline">\(2\le n\le 2\times 10^5\)</span></li><li><span class="math inline">\(1\le a_i&lt; i\le2\times10^5\)</span></li><li><span class="math inline">\(1\le v_i\le 10^9\)</span></li></ul><h2 id="输出-2">输出</h2><p>小山选择路径的方案数。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">1 1 1 2</span><br><span class="line">1 1 2 2 2</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">路径上有一个节点，有5种取法。</span><br><span class="line">路径上有两个节点的取法有： 1-3、1-4、2-5</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">1 1</span><br><span class="line">1 2 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">路径上有一个节点，有3种取法。</span><br><span class="line">路径上有两个节点的取法有： 1-2、1-3</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>假设我们现在处在节点<span class="math inline">\(u\)</span>，现在一直向父亲节点移动。在移动的过程中，一旦发现一个节点<span class="math inline">\(u&#39;\)</span>的权值出现过，那么说明再往上的路径都是不符合要求的。也就是说，如果<span class="math inline">\(w\)</span>是<span class="math inline">\(u&#39;\)</span>的子节点，又是<span class="math inline">\(u\)</span>的祖先，那么从<span class="math inline">\(w\)</span>到<span class="math inline">\(u\)</span>的路径中，以<span class="math inline">\(u\)</span>为终点的路径都是符合要求的，我们直接统计即可。</p><p>在实现过程中，我们并不能够直接寻找<span class="math inline">\(w\)</span>，因为这将导致<span class="math inline">\(O(n^2)\)</span>的时间复杂度。我们使用的做法是，假设现在遍历到了一个<span class="math inline">\(u\)</span>节点，并且已经知道了其父亲节点所对应的<span class="math inline">\(w\)</span>节点的深度为<span class="math inline">\(d\)</span>，那么如果<span class="math inline">\(u\)</span>的权值<span class="math inline">\(v_u\)</span>已经在从根到<span class="math inline">\(u\)</span>的路径上出现过，那么令其最深的深度为<span class="math inline">\(w_u\)</span>（否则，令<span class="math inline">\(w_u=0\)</span>，这里假设根节点的深度为<span class="math inline">\(1\)</span>），那么令<span class="math inline">\(d&#39;=\max\{d,w_u\}\)</span>，假设<span class="math inline">\(u\)</span>节点的深度为<span class="math inline">\(d_u\)</span>，那么就可以直接把<span class="math inline">\(d_u-d&#39;\)</span>统计到答案中。</p><p>由此我们维护好<span class="math inline">\(w_u\)</span>值，最终可以以<span class="math inline">\(O(n)\)</span>的时间完成本题。</p><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200004</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;g[N];</span><br><span class="line"><span class="type">int</span> a[N],n;</span><br><span class="line">map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt;v;</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> np,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!v[a[u]].<span class="built_in">empty</span>())&#123;</span><br><span class="line">        np=<span class="built_in">max</span>(np,v[a[u]].<span class="built_in">back</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    ans+=d-np;</span><br><span class="line">    v[a[u]].<span class="built_in">push_back</span>(d);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:g[u])&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(v,np,d+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v[a[u]].<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        g[x].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>米哈游 秋招 2023.09.24 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Mihayou-20230924/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Mihayou-20230924/</id>
    <published>2023-09-26T06:33:01.000Z</published>
    <updated>2023-09-27T06:55:48.762Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="相加异或">1、相加异或</h1><p>对于一个数组<span class="math inline">\(c\)</span>，定义<span class="math inline">\(f(c)\)</span>为<span class="math inline">\(c\)</span>数组所有元素的总和。</p><p>现在给定两个长度为<span class="math inline">\(n\)</span>的数组<span class="math inline">\(a,b\)</span>，请你恰好删除一个数组<span class="math inline">\(a\)</span>的元素或者一个数组<span class="math inline">\(b\)</span>的元素，使得<span class="math inline">\(f(a)\)</span>异或<span class="math inline">\(f(b)\)</span>最大。</p><h2 id="输入">输入</h2><p>第一行输入一个整数<span class="math inline">\(n\)</span>。</p><p>第二行输入<span class="math inline">\(n\)</span>个整数<span class="math inline">\(a_i\)</span>。</p><p>第三行输入<span class="math inline">\(n\)</span>个整数<span class="math inline">\(b_i\)</span>。</p><p><span class="math inline">\(1\le n,a_i,b_i \le 10^5\)</span></p><h2 id="输出">输出</h2><p>输出最大的异或和。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">3 2 1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">删除a数组的3。</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>令<span class="math inline">\(s_a\)</span>表示原来的数组<span class="math inline">\(a\)</span>中的元素和，<span class="math inline">\(s_b\)</span>表示原来的<span class="math inline">\(b\)</span>数组的元素和。那么对于删除<span class="math inline">\(a\)</span>中的某个元素<span class="math inline">\(a_i\)</span>后，最终<span class="math inline">\(f(a)\oplus f(b)=(s_a-a_i)\opluss_b\)</span>。对于<span class="math inline">\(b\)</span>数组也同理。因此最终答案为</p><p><span class="math display">\[\max_{i=1}^n\{\max\{(s_a-a_i)\opluss_b,(s_b-b_i)\oplus s_a\}\}\]</span></p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> sa=<span class="number">0</span>,sb=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        sa+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">        sb+=b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,(sa-a[i])^sb);</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,(sb-b[i])^sa);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="米小游与魔法少女-奇运">2、米小游与魔法少女-奇运</h1><p>米小游都快保底了还没抽到希儿，好生气哦！只能打会活动再拿点水晶。</p><p>米小游和世界第一可爱的魔法少女TeRiRi正在打BOSS，BOSS的血量为<span class="math inline">\(h\)</span>，当BOSS血量小于等于<span class="math inline">\(0\)</span>时，BOSS死亡。TeRiRi有一套牌，在一轮中，她会按顺序一张一张的将卡牌打出，套牌中有两种卡牌：</p><ol type="1"><li><strong>时来运转</strong>：获得<span class="math inline">\(x\)</span>个<strong>幸运币</strong>。</li><li><strong>幸运一掷</strong>：造成<span class="math inline">\(x\)</span>点伤害，并投掷所有<strong>幸运币</strong>，造成等于所有<strong>幸运币</strong>掷出的点数之和的伤害。</li></ol><p><strong>幸运币</strong>可以等概率的投掷出<span class="math inline">\(1\sim 6\)</span>之间的点数。（所以为什么不叫骰子呢？）</p><p>米小游想知道，TeRiRi的套牌在一轮内击杀BOSS的概率。</p><h2 id="输入-1">输入</h2><p>第一行输入两个整数<span class="math inline">\(n(1\le n\le 100),h(1\leh\le 10^9)\)</span>，分别表示卡牌张数和BOSS血量。</p><p>接下来<span class="math inline">\(n\)</span>行，每行首先输入两个整数<span class="math inline">\(t(1\le t\le2),x(1\le x\le 10)\)</span>，<span class="math inline">\(t\)</span>为<span class="math inline">\(1\)</span>表示卡牌为时来运转，<span class="math inline">\(t\)</span>为<span class="math inline">\(2\)</span>表示卡牌为幸运一掷。</p><h2 id="输出-1">输出</h2><p>输出一个实数表示答案，你的答案与标准答案的误差不超过<span class="math inline">\(10^{-4}\)</span>都被认为是正确答案。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">2 5</span><br><span class="line">1 1</span><br><span class="line">2 1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">0.5</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">幸运币掷出4及以上的概率为0.5，再加上1点固定伤害，即可击杀BOSS。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">3 1145</span><br><span class="line">1 4</span><br><span class="line">1 9</span><br><span class="line">1 9</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">无论如何都无法击杀BOSS。</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>需要注意的是，只有<strong>幸运一掷</strong>被使用出时，前面获得的<strong>幸运币</strong>才会有用处。如果到最后都没有使出过幸运一掷，那么最后得到的<strong>幸运币</strong>也是没有用处的。通过统计，我们最终可以知道有效被投掷的<strong>幸运币</strong>有<span class="math inline">\(a\)</span>个，并且<strong>幸运一掷</strong>造成的固定伤害总共为<span class="math inline">\(b\)</span>。</p><p>由于每个幸运币之间都是独立的，因此我们可以考虑将它们合并进行处理。我们将使用动态规划来解决本问题。令<span class="math inline">\(f(i,j)(0\le i\le a,0\le j\le 6i)\)</span>表示<span class="math inline">\(i\)</span>枚幸运币投掷出总点数<span class="math inline">\(j\)</span>的概率值，那么我们可以写出它的状态转移方程：</p><p><span class="math inline">\(f(i,j)= \left \{\begin{aligned}  &amp;1&amp; &amp; \text{if}\quad i=0\land j=0 \\  &amp;0 &amp; &amp;\text{if}\quad i=0\land j&gt;0\\  &amp;\dfrac{1}{6}\cdot\sum_{k=1}^{\min\{j,6\}} f(i-1,j-k) &amp;&amp; \text{if}\quad i&gt;0 \\ \end{aligned}\right.\)</span></p><p>由于每个骰子都能均等地以<span class="math inline">\(\dfrac{1}{6}\)</span>的概率投掷出从<span class="math inline">\(1\sim 6\)</span>中的一个值，因此从状态<span class="math inline">\(f(i,j)\)</span>能够以均等地概率转移到<span class="math inline">\(f(i+1,j+1),f(i+1,j+2),\dots,f(i+1,j+6)\)</span>。</p><p>由于还收到了<span class="math inline">\(b\)</span>点固定伤害，因此只需要造成至少<span class="math inline">\(h&#39;=\max\{0,h-b\}\)</span>点伤害，就能够击败BOSS，因此最终答案为<span class="math inline">\(\displaystyle{\sum_{j=h&#39;}^{6a}f(a,j)}\)</span>。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1002</span>;</span><br><span class="line"><span class="type">double</span> f[N][N*<span class="number">6</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,h,t,x;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>,tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;t,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">1</span>)&#123;</span><br><span class="line">            tmp+=x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            b+=x;a+=tmp;tmp=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=a;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=<span class="number">6</span>*a;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">6</span>&amp;&amp;k&lt;=j;k++)&#123;</span><br><span class="line">                f[i][j]+=f[i<span class="number">-1</span>][j-k]/<span class="number">6</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    h=<span class="built_in">max</span>(<span class="number">0</span>,h-b);</span><br><span class="line">    <span class="type">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=h;j&lt;=a*<span class="number">6</span>;j++)</span><br><span class="line">        ans+=f[a][j];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10f\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="米小游的极差之和">3、米小游的极差之和</h1><p>米小游拿到了一个数组<span class="math inline">\(a\)</span>，她用这个数组构造一个新数组<span class="math inline">\(b\)</span>，其中<span class="math inline">\(a_i\)</span>代表<span class="math inline">\(b\)</span>数组中有<span class="math inline">\(a_i\)</span>个<span class="math inline">\(i\)</span>。</p><p>例如，若<span class="math inline">\(a=[2,3,1]\)</span>，那么<span class="math inline">\(b=[1,1,2,2,2,3]\)</span>，因为<span class="math inline">\(a_1 = 2\)</span>，代表<span class="math inline">\(b\)</span>数组中有<span class="math inline">\(2\)</span>个<span class="math inline">\(1\)</span>；<span class="math inline">\(a_2=3\)</span>，代表<span class="math inline">\(b\)</span>数组中有<span class="math inline">\(3\)</span>个<span class="math inline">\(2\)</span>；<span class="math inline">\(a_3=1\)</span>，代表<span class="math inline">\(b\)</span>数组中有<span class="math inline">\(1\)</span>个<span class="math inline">\(3\)</span>。</p><p>现在给定<span class="math inline">\(a\)</span>数组，你需要帮米小游求出<span class="math inline">\(b\)</span>数组中所有连续子数组的极差之和。由于答案可能过大，请对<span class="math inline">\(10^9+7\)</span>取模。</p><p>数组的极差指最大值减去最小值。</p><h2 id="输入-2">输入</h2><p>第一行输入一个正整数<span class="math inline">\(n\)</span>，代表<span class="math inline">\(a\)</span>数组的元素数量。</p><p>第二行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(a_i\)</span>，代表<span class="math inline">\(a\)</span>数组的元素。</p><ul><li><span class="math inline">\(1\le n\le 10^5\)</span></li><li><span class="math inline">\(1 \le a_i \le 10^9\)</span></li></ul><h2 id="输出-2">输出</h2><p>一个整数，代表数组中所有区间的极差之和，对<span class="math inline">\(10^9+7\)</span>取模的值。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">2</span><br><span class="line">2 1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">a=[2,1]时，b数组为[1,1,2]。</span><br><span class="line">此时b数组共有6个连续子数组：</span><br><span class="line">[1]的极差为0。</span><br><span class="line">[1]的极差为0。</span><br><span class="line">[2]的极差为0。</span><br><span class="line">[1,1]的极差为0。</span><br><span class="line">[1,2]的极差为1。</span><br><span class="line">[1,1,2]的极差为1。</span><br><span class="line">因此答案是0+0+0+0+1+1=2。</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>由于<span class="math inline">\(b\)</span>是一个单调非递减数组，因此它的任意子数组极差就相当于是最后一个元素减去第一个元素的值。因此，只有最后一个元素的值和第一个不同时，才会对极差做出贡献。</p><p>可以知道，对于任意一对<span class="math inline">\(i,j(1\le i&lt;j\len)\)</span>，<span class="math inline">\(b\)</span>中都有<span class="math inline">\(a_i\cdot a_j\)</span>个子数组以<span class="math inline">\(i\)</span>开头，以<span class="math inline">\(j\)</span>结尾，它们都做出了<span class="math inline">\(j-i\)</span>的贡献。因此，这道题的答案为<span class="math inline">\(\displaystyle{\sum_{i=1}^n\sum_{j=i+1}^n(j-i)\cdot a_i\cdot a_j}\)</span>，令<span class="math inline">\(\displaystyle{s_i=\sum_{i=1}^na_i,s_0=0,t_i=\sum_{i=1}^n i\cdota_i,t_0=0}\)</span>。那么我们可以将这个结果进一步化简一下，有：</p><p><span class="math inline">\(\begin{aligned}&amp;\sum_{i=1}^n\sum_{j=i+1}^n (j-i)\cdot a_i\cdot a_j\\=&amp;\sum_{i=1}^n a_i\cdot\left(\sum_{j=i+1}^n (j-i)\cdot a_j\right)\\=&amp;\sum_{i=1}^n a_i\cdot\left(\sum_{j=i+1}^n j\cdota_j-i\cdot\sum_{j=i+1}^n a_j\right)\\ =&amp;\sum_{i=1}^na_i\cdot((t_n-t_i)-i\cdot(s_n-s_i))\\ \end{aligned}\)</span></p><p>由此，我们可以在<span class="math inline">\(O(n)\)</span>的时间内，通过计算<span class="math inline">\(s,t\)</span>，从而计算出最终结果。</p><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line">ll a[N],s1[N],s2[N];</span><br><span class="line">ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">        s1[i]=(s1[i<span class="number">-1</span>]+a[i])%mod;</span><br><span class="line">        s2[i]=(s2[i<span class="number">-1</span>]+a[i]*i)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans+=((s2[n]-s2[i])-(s1[n]-s1[i])*i%mod)*a[i]%mod;</span><br><span class="line">        ans=(ans%mod+mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>字节跳动 秋招 2023.09.24 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Zijietiaodong-20230924/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Zijietiaodong-20230924/</id>
    <published>2023-09-25T05:19:40.000Z</published>
    <updated>2023-09-25T05:19:40.673Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="小红的01串">1、小红的<code>01</code>串</h1><p>小红拿到了一个<code>01</code>串，她准备将若干个字符<code>'1'</code>染成红色，将若干个字符<code>'0'</code>染成蓝色，但有个限制：如果一个<code>'0'</code>和一个<code>'1'</code>相邻，那么它们不能同时染色。</p><p>小红想知道，最多可以染多少个字符？</p><h2 id="输入">输入</h2><p>输入仅有一行，为小红拿到的<code>01</code>串。</p><p>字符串长度不超过<span class="math inline">\(200000\)</span>。</p><h2 id="输出">输出</h2><p>一个正整数，代表能染色的最多字符。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">110011</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">染红第一个、第三个、第五个、第六个字符即可。</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>对于一个<code>01</code>相间，长度为<span class="math inline">\(n\)</span>的比特串，对它染色的最多个数为<span class="math inline">\(\lceiln/2\rceil\)</span>，因为相邻两个不能同时染色。</p><p>因此，我们对原来的字符串分拆成多个<strong>极大</strong><code>01</code>相间子串（即前一个子串的最后一个字符要和后一个子串的第一个字符相同），分别统计它们的最多染色数并相加即可。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200004</span>;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j;i&lt;=n;i=j)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;=n&amp;&amp;s[j]!=s[j<span class="number">-1</span>];++j);</span><br><span class="line">        ans+=(j-i+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小红刷抖音">2、小红刷抖音</h1><p>小红很喜欢刷抖音，抖音后台有一个推荐系统，小红向上滑动屏幕时，该推荐系统会计算应显示给小红的短视频。</p><p>用数值量化而言，每个短视频有一个内存占用<span class="math inline">\(a_i\)</span>（画质越好的视频内存占用越大），以及该视频可以带给小红愉悦度为<span class="math inline">\(b_i\)</span>。</p><p>值得注意的是，当小红每次重复刷到同一个视频时，观看该视频获得的愉悦度会除以<span class="math inline">\(2\)</span>（向下取整）。</p><p>例如，若一个视频初始给小红获得的愉悦度为<span class="math inline">\(5\)</span>，那么第二次小红获得的愉悦度会变成2，第三次为<span class="math inline">\(1\)</span>，第四次以后再刷到这个视频获得的愉悦度就为0了。</p><p>小红一共进行了<span class="math inline">\(q\)</span>次刷视频操作。</p><p>为了使得手机不卡顿，推荐系统每次会选择一个内存占用不高于<span class="math inline">\(x_i\)</span>的视频。</p><p>如果有多个这样的视频，推荐系统会推荐满足条件的播放画质最好的那个视频（即内存占用最高的视频）。</p><p>如果有多个视频的画质都是最好，那么推荐系统会推荐当前愉悦度最高的视频。</p><p>当小红观看完这个视频后，即可获得该视频的愉悦度，请你计算小红刷完所有视频时获得的总愉悦度。</p><h2 id="输入-1">输入</h2><p>第一行输入两个正整数<span class="math inline">\(n,q\)</span>，代表视频的总数量、小红刷视频的次数。</p><p>第二行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(a_i\)</span>，代表每个视频的内存占用。</p><p>第三行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(b_i\)</span>，代表每个视频第一次观看时给小红带来的愉悦值。</p><p>第四行输入<span class="math inline">\(q\)</span>个正整数<span class="math inline">\(x_i\)</span>，代表每次小红刷视频时，系统推荐的视频占用内存的上限。</p><ul><li><span class="math inline">\(1\le n,q \le 10^5\)</span></li><li><span class="math inline">\(1 \le a_i,b_i,z_i\le 10^9\)</span></li><li>保证<span class="math inline">\(x_i\)</span>一定不小于<span class="math inline">\(a_i\)</span>的最小值。</li></ul><h2 id="输出-1">输出</h2><p>一个整数，代表小红获得的愉悦度总和。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3 4</span><br><span class="line">3 5 1</span><br><span class="line">3 4 2</span><br><span class="line">3 3 6 1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">第一次刷视频，推荐系统推荐给小红第一个视频。小红获得愉悦度3。</span><br><span class="line">第二次刷视频，推荐系统推荐给小红第一个视频。由于是第二次观看，小红获得愉悦度1。</span><br><span class="line">第三次刷视频，推荐系统推荐给小红第二个视频。小红获得愉悦度4。</span><br><span class="line">第四次刷视频，推荐系统推荐给小红第三个视频。小红获得愉悦度2。</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>这题由于是优先查找内存不超过<span class="math inline">\(x_i\)</span>且取最大，再查找愉悦值最大，因此我们可以使用一个有序的数据结构进行解决。</p><p>具体做法是将每个不同的内存占用作为键，其对应的愉悦值可以用一个最大堆进行存储。由此，C++的<code>map</code>是最满足当前需要的容器。对于一次查询<span class="math inline">\(x_i\)</span>，只需要通过二分在<code>map</code>中找到最大的那个内存值，然后再将对应的最大堆元素取出，计入答案，并将其整除<span class="math inline">\(2\)</span>的值重新插入最大堆即可。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line">map&lt;<span class="type">int</span>,priority_queue&lt;<span class="type">int</span>&gt;&gt;mp;</span><br><span class="line"><span class="type">int</span> a[N],b[N],n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) mp[a[i]].<span class="built_in">push</span>(b[i]);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="keyword">auto</span> it=mp.<span class="built_in">upper_bound</span>(x);</span><br><span class="line">        --it;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>&gt;&amp;q=it-&gt;second;</span><br><span class="line">        <span class="type">int</span> k=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        ans+=k;</span><br><span class="line">        q.<span class="built_in">push</span>(k&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小红玩大富翁游戏">3、小红玩大富翁游戏</h1><p>小红在玩一个大富翁游戏，游戏的地图为一排房子，从左到右编号依次从<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>。</p><p>每个房子有一个购买价格<span class="math inline">\(a_i\)</span>和一个经过它的房租价格<span class="math inline">\(b_i\)</span>，当小红经过一个自己没有购买的房子时，她就需要交房租（已购买的房子则不需要交房租）。</p><p>在游戏开始前，小红可以购买任意数量的房子，然后开始游戏。</p><p>游戏中，小红会按照一个给定的排列<span class="math inline">\(p\)</span>的顺序依次经过所有的房子（排列<span class="math inline">\(p\)</span>为房子的编号顺序，<span class="math inline">\(p\)</span>的大小为<span class="math inline">\(n\)</span>，即每个房子都会作为一次目标）。</p><p>小红每经过一套房子都需要交租金，除非已购买。初始小红在第一个房子的左边，当她按照顺序经过了所有房子后，<strong>她会再次移动到第<span class="math inline">\(n\)</span>个房子的右边</strong>。</p><p>请你计算小红最少的总花费。</p><h2 id="输入-2">输入</h2><p>第一行输入一个整数<span class="math inline">\(n(1\le n\le10^5)\)</span>，代表房子的总数。</p><p>第二行输入一个排列<span class="math inline">\(p_i(1\le p_i\len)\)</span>，代表小红经过的房子编号顺序。</p><p>第三行输入<span class="math inline">\(n\)</span>个整数<span class="math inline">\(a_i(1\le a_i\le 10^9)\)</span>，代表编号<span class="math inline">\(i\)</span>的房子的购买价格。</p><p>第四行输入<span class="math inline">\(n\)</span>个整数<span class="math inline">\(b_i(1\le b_i \le 10^9)\)</span>，代表编号<span class="math inline">\(i\)</span>房子的经过房租价格。</p><p>保证<span class="math inline">\([1,n]\)</span>中每个数在<span class="math inline">\(p\)</span>数组中都出现且仅出现一次。</p><h2 id="输出-2">输出</h2><p>一行一个整数，表示最少的花费。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">4</span><br><span class="line">1 3 2 4</span><br><span class="line">5 4 2 4</span><br><span class="line">1 3 1 1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">游戏开始前买下第二个房子，花费4。</span><br><span class="line">开始游戏时，小红先向右走一步到达1号房子，房租价格为1。</span><br><span class="line">然后向右走2步到达3号房子，当小红经过2号房子时，由于2号房子已经购买，则不用交房租。然后到达3号房子时交房租价格为1。</span><br><span class="line">然后向左走1步到达2号房子，不需要交房租。</span><br><span class="line">然后向右走2步到达4号房子，经过的3号房子和4号房子分别交价格为1的房租。</span><br><span class="line">最后向右离开这个大富翁地图。</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>我们需要统计每个房子被经过的次数<span class="math inline">\(c_i\)</span>，那么最终答案为<span class="math inline">\(\displaystyle{\sum_{i=1}^n\min\{a_i,b_i\cdotc_i\}}\)</span>，也就是说，如果<span class="math inline">\(a_i\leb_i\cdot c_i\)</span>，那么就租下第<span class="math inline">\(i\)</span>栋房子，否则不租。</p><p>为了求出数组<span class="math inline">\(c_i\)</span>，我们可以考虑使用差分数组进行解决。假设<span class="math inline">\(t\)</span>是差分数组，并且目前处在位置<span class="math inline">\(x\)</span>，并且走向<span class="math inline">\(y\)</span>（为了避免端点重复计算，这一个过程只会计算终点<span class="math inline">\(y\)</span>的价值）。如果<span class="math inline">\(x&lt;y\)</span>，那么就对<span class="math inline">\(t_{x+1}\)</span>加上<span class="math inline">\(1\)</span>，对<span class="math inline">\(t_{y+1}\)</span>减去<span class="math inline">\(1\)</span>。如果<span class="math inline">\(x&gt;y\)</span>，那么就对<span class="math inline">\(t_x\)</span>减去<span class="math inline">\(1\)</span>，<span class="math inline">\(t_y\)</span>加上<span class="math inline">\(1\)</span>。</p><p>对于题目输入的排列。我们只需要令<span class="math inline">\(p_0=0,p_{n+1}=n+1\)</span>，那么整个过程就恰好不重不漏地完成计算，最终有<span class="math inline">\(c_i=c_{i-1}+t_i,c_0=0\)</span>。此后直接计算答案即可。</p><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200004</span>;</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="type">int</span> p[N],a[N],b[N],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">    ++s[<span class="number">1</span>];</span><br><span class="line">    --s[p[<span class="number">1</span>]+<span class="number">1</span>];</span><br><span class="line">    ++s[p[n]+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x=p[i],y=p[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(x&lt;y)&#123;</span><br><span class="line">            ++s[x+<span class="number">1</span>];--s[y+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ++s[y];--s[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        s[i]+=s[i<span class="number">-1</span>];</span><br><span class="line">        ans+=<span class="built_in">min</span>(<span class="number">1ll</span>*a[i],<span class="number">1ll</span>*b[i]*s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小红的机器人">4、小红的机器人</h1><p>小红有一个机器人，她可以对机器人进行以下<span class="math inline">\(4\)</span>种指令：</p><ul><li><code>L</code>：向左一步。</li><li><code>R</code>：向右一步。</li><li><code>U</code>: 向上一步。</li><li><code>D</code>: 向下一步。小红现在给定了一个指令集（有上下左右最多四种操作）。</li></ul><p>小红希望选出一个非空子序列（在指令集中可以不连续），使得机器人执行这段子序列指令后回到原地。小红想知道最终有多少选择方式？由于答案可能过大，请对<span class="math inline">\(10^9+7\)</span>取模。</p><p>我们定义，两个子序列中存在某位置字母的选择情况不同（例如在第一个子序列中选择了第<span class="math inline">\(x\)</span>个字符，而在第二个子序列中没选），则称为两个不同的子序列。</p><h2 id="输入-3">输入</h2><p>一行仅包含<code>'L', 'R', 'U', 'D'</code>四种字符的字符串，长度不超过<span class="math inline">\(500000\)</span>。</p><h2 id="输出-3">输出</h2><p>一个整数，代表子序列的选择方案。</p><h2 id="样例-3">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">LLRUU</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">第一种方案：选择第一个字符和第三个字符组成子序列&quot;LR&quot;，向左走一步，向右走一步，回到原点。</span><br><span class="line">第二种方案：选择第二个字符和第三个字符组成子序列&quot;LR&quot;，向左走一步，向右走一步，回到原点。</span><br></pre></td></tr></table></figure><h2 id="解答-3">解答</h2><p>可以发现，这些指令是没有顺序性的。即前面的指令执行结果并不会影响后面的执行执行结果。因此，最终机器人的位置只和不同指令的个数有关，而和顺序没有关系。</p><p>如果一条非空指令能够使机器人回到原点，那么<code>L, R</code>的数量必须相等，<code>U, D</code>的数量必须相等。并且可以发现，两个维度的坐标都是独立互不干扰的，可以使用乘法原理计算完成。</p><p>因此，假设<span class="math inline">\(c_L,c_R,c_U,c_D\)</span>分别是输入的字符串的<code>L, R, U, D</code>的指令数，那么我们可以得到最终答案为：</p><p><span class="math display">\[\left(\sum_{i=0}^{\min\{c_L,c_R\}}\dbinom{c_L}{i}\cdot\dbinom{c_R}{i}\right)\cdot\left(\sum_{i=0}^{\min\{c_U,c_D\}}\dbinom{c_U}{i}\cdot\dbinom{c_D}{i}\right)-1\]</span></p><p>其中最后的<span class="math inline">\(-1\)</span>是指指令为空的情况。</p><p>本题的实现基于线性逆元，当然也可以不写，直接求出阶乘再计算逆元也是可以的。</p><h2 id="代码-3">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">500004</span>;</span><br><span class="line">ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll fac[N],finv[N],inv[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=fac[<span class="number">1</span>]=inv[<span class="number">1</span>]=finv[<span class="number">0</span>]=finv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">        inv[i]=(mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">        finv[i]=finv[i<span class="number">-1</span>]*inv[i]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fac[n]*finv[n-m]%mod*finv[m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> cnt[<span class="number">128</span>];</span><br><span class="line"><span class="function">ll <span class="title">cal</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> w=<span class="built_in">min</span>(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=w;i++)</span><br><span class="line">        ans=(ans+<span class="built_in">C</span>(x,i)*<span class="built_in">C</span>(y,i))%mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">init</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ++cnt[s[i]];</span><br><span class="line">    ll m1=<span class="built_in">cal</span>(cnt[<span class="string">&#x27;L&#x27;</span>],cnt[<span class="string">&#x27;R&#x27;</span>]);</span><br><span class="line">    ll m2=<span class="built_in">cal</span>(cnt[<span class="string">&#x27;U&#x27;</span>],cnt[<span class="string">&#x27;D&#x27;</span>]);</span><br><span class="line">    ll ans=m1*m2%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>网易 秋招 2023.09.23 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Wangyi-20230923B/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Wangyi-20230923B/</id>
    <published>2023-09-25T05:19:38.000Z</published>
    <updated>2023-09-25T05:19:38.427Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="小红的字符串查询">1、小红的字符串查询</h1><p>小红拿到了一个字符串。她有多次查询，每次查询一个区间，你需要回答该区间包含了多少个长度为<span class="math inline">\(3\)</span>的、所有字母都相等的连续子串。</p><h2 id="输入">输入</h2><p>第一行输入两个正整数<span class="math inline">\(n,k\)</span>，代表字符率长度和查询次数。</p><p>第二行输入一个长度为<span class="math inline">\(n\)</span>的、仅包含小写字母的字符串。</p><p>接下来的<span class="math inline">\(k\)</span>行，每行输入两个正整数<span class="math inline">\(l,r\)</span>，代表一次查询。</p><ul><li><span class="math inline">\(l \le n,k \le 10^5\)</span></li><li><span class="math inline">\(1\le l\le r\le n\)</span></li></ul><h2 id="输出">输出</h2><p>输出<span class="math inline">\(k\)</span>行，每行输出一个整数表示答案。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">8 4</span><br><span class="line">aaaaabbb</span><br><span class="line">1 8</span><br><span class="line">2 7</span><br><span class="line">3 6</span><br><span class="line">4 5</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>这题使用前缀和将会变得非常简单。令<span class="math inline">\(f_i(i\ge 3)\)</span>表示字符串的三个字母<span class="math inline">\(s_{i-2},s_{i-1},s_{i}\)</span>是否相等，如果相等，那么为<span class="math inline">\(1\)</span>，否则为<span class="math inline">\(0\)</span>，其中<span class="math inline">\(f_1=f_2=0\)</span>。</p><p>那么，令<span class="math inline">\(t_i=\displaystyle{\sum_{j=1}^if_j},t_0=0\)</span>表示<span class="math inline">\(f\)</span>的前缀和，因此对于每次询问<span class="math inline">\(l,r\)</span>，只需要回答值<span class="math inline">\(\max\{0,t_r-t_{l+1}\}\)</span>即可。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"><span class="type">char</span> t[N];</span><br><span class="line"><span class="type">int</span> s[N],n,q,l,r;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %s&quot;</span>,&amp;n,&amp;q,t+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[i]==t[i<span class="number">-1</span>]&amp;&amp;t[i]==t[i<span class="number">-2</span>])&#123;</span><br><span class="line">            s[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s[i]+=s[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        l+=<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,l&gt;r?<span class="number">0</span>:s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小红的数组构造">2、小红的数组构造</h1><p>小红有一个数组，数组相邻元素的差值最多为<span class="math inline">\(1\)</span>，即<span class="math inline">\(|a_i-a_{i+1}|\le1\)</span>，并且数组元素都是正整致，即<span class="math inline">\(a_i\ge1\)</span>，现在小红知道数组的长度为<span class="math inline">\(n\)</span>，数组的和为<span class="math inline">\(m\)</span>，小红想知道所有符合条件的数组中，<span class="math inline">\(a_p\)</span>的最大值是多少。</p><h2 id="输入-1">输入</h2><p>第一行三个整数<span class="math inline">\(n,m,p\)</span>，表示数组的长度，数组的和，以及要求的位置。</p><ul><li><span class="math inline">\(1\le p\le n\le m\le 10^9\)</span></li></ul><h2 id="输出-1">输出</h2><p>输出一个整数，表示位置<span class="math inline">\(a_p\)</span>的最大值。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">4 5 2</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">数组[1,2,1,1] 满足条件，且位置2的最大值为2。</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>这道题可以使用二分法进行求解。接下来元素<span class="math inline">\(a_p\)</span>是否可以取到<span class="math inline">\(x\)</span>。</p><p>为了元素<span class="math inline">\(a_p\)</span>是否可以取到<span class="math inline">\(x\)</span>，那么其它元素得值尽可能低。于此同时为了维持相邻元素的绝对差不超过<span class="math inline">\(1\)</span>这个性质，对于元素<span class="math inline">\(a_q\)</span>，如果<span class="math inline">\(q&gt;p\)</span>，那么<span class="math inline">\(a_q\)</span>就要比<span class="math inline">\(a_{q-1}\)</span>少<span class="math inline">\(1\)</span>；如果<span class="math inline">\(q&lt;p\)</span>，那么<span class="math inline">\(a_q\)</span>就要比<span class="math inline">\(a_{q+1}\)</span>少<span class="math inline">\(1\)</span>，直到恰好为<span class="math inline">\(0\)</span>。</p><p>这种情况是最节省和值的使用的，我们可以通过逐渐为其它元素加上<span class="math inline">\(1\)</span>，直到总和达到<span class="math inline">\(m\)</span>，如果总和达不到<span class="math inline">\(m\)</span>，那么<span class="math inline">\(a_p\)</span>必定不止<span class="math inline">\(x\)</span>。因此，我们不需要考虑<span class="math inline">\(a_p\)</span>的上界。</p><p>更一般的来说，如果第<span class="math inline">\(a_p=x\)</span>，那么最节省和值方法的形状如下：</p><p><span class="math display">\[0,0,0,\dots,0,1,2\dots,x-1,x,x-1,x-2,\dots2,1,0,\dots,0\]</span></p><p>注意，两端可能没有取到<span class="math inline">\(0\)</span>就结束了。</p><p>由于两边的处理方式是一样的，因此只需要考虑其中一侧。令<span class="math inline">\(f(n,x)\)</span>表示现在有<span class="math inline">\(n\)</span>个数组元素，其中最后一个元素为<span class="math inline">\(x\)</span>时，最少需要消耗的和值。按照等差数列求和公式，那么可以写出</p><p><span class="math inline">\(f(n,x)= \left\{\begin{aligned}  &amp;\dfrac{(2x-n+1)n}{2} &amp; &amp; \text{if}\quadx\ge n \\  &amp;\dfrac{(x+1)x}{2} &amp; &amp; \text{if}\quad x&lt;n \\\end{aligned}\right.\)</span></p><p>因此，判断第<span class="math inline">\(x\)</span>栋楼高度是否为至少<span class="math inline">\(h\)</span>，只需要判断<span class="math inline">\(f(p,x)+f(n-p+1,x)-x\lem\)</span>是否满足即可。</p><h2 id="代码-1">代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">n, m, p = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cal2</span>(<span class="params">n, x</span>):</span><br><span class="line">    <span class="keyword">if</span> x &gt;= n:</span><br><span class="line">        <span class="keyword">return</span> (x + x - n + <span class="number">1</span>) * n // <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> (x + <span class="number">1</span>) * x // <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cal</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> cal2(p, x) + cal2(n - p + <span class="number">1</span>, x) - x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">l, r = <span class="number">1</span>, m</span><br><span class="line"><span class="keyword">while</span> l &lt; r:</span><br><span class="line">    mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> cal(mid) &lt;= m:</span><br><span class="line">        l = mid</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r = mid - <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(l)</span><br></pre></td></tr></table></figure><h1 id="小红的树上路径与">3、小红的树上路径与</h1><p>小红拿到了一棵树，她定义一条路径的权值为路径上所有节点权值按位与计算出的值。小红想知道，所有路径的权值之和等于多少？答案请对<span class="math inline">\(10^9+7\)</span>取模。</p><h2 id="输入-2">输入</h2><p>第一行输入一个正整数<span class="math inline">\(n\)</span>，代表树的节点数量。</p><p>第二行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(a_i\)</span>，代表每个节点的权值。</p><p>接下来的<span class="math inline">\(n-1\)</span>行，每行输入<span class="math inline">\(2\)</span>个正整数<span class="math inline">\(u,v\)</span>，代表节点<span class="math inline">\(u\)</span>和节点<span class="math inline">\(v\)</span>有一条无向边连接。</p><ul><li><span class="math inline">\(1\le n\le 10^5\)</span></li><li><span class="math inline">\(1\le a_i\le 10^9\)</span></li></ul><h2 id="输出-2">输出</h2><p>一个整数，代表所有路径的权值之和。由于答案过大，请对<span class="math inline">\(10^9+7\)</span>取模。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">3 6 4</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">路径1-2的权值为3&amp;6，管案是2。</span><br><span class="line">路径2-3的权值为6&amp;4，答案是4。</span><br><span class="line">路径1-2-3的权值为3&amp;6&amp;4，管案是0。</span><br><span class="line">因此所有路程的权值之和是2+4=6。</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>由于不同数位之间的比特都是相互独立的，因此我们对同一数位进行处理即可。</p><p>不失一般性，我们只讨论最低位的情况。对于<span class="math inline">\(u,v\)</span>间的路径的与值为<span class="math inline">\(1\)</span>，当且仅当<span class="math inline">\(u,v\)</span>之间所有的节点值都为<span class="math inline">\(1\)</span>。由于原图是一棵树，因此我们去除所有<span class="math inline">\(0\)</span>节点后，可以发现这个图变成了一个森林，其中每个连通块都是一棵树。同一连通块下的任意一对节点的与值都为<span class="math inline">\(1\)</span>，因此我们统计每个连通块的节点数<span class="math inline">\(c\)</span>后，可以知道这里面一共有<span class="math inline">\(\dfrac{c(c+1)}{2}\)</span>条路径可以添加到答案中。</p><p>这里使用了并查集来求取每个连通块中的节点数。</p><p>因此回到原题，假设所有数第<span class="math inline">\(i\)</span>位做出的贡献为<span class="math inline">\(v_i\)</span>，那么最终答案为<span class="math inline">\(\displaystyle{\sum_{i=0}^{\infty}2^i\cdotv_i}\)</span>。</p><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> pi pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line">ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> fa[N],sz[N],n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">vector&lt;pi&gt;e;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="built_in">find</span>(x),v=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(u!=v)&#123;</span><br><span class="line">        fa[v]=u;</span><br><span class="line">        sz[u]+=sz[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        fa[i]=i;sz[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[x,y]:e)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[x]&amp;&amp;b[y])</span><br><span class="line">            <span class="built_in">merge</span>(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i]&amp;&amp;i==<span class="built_in">find</span>(i))</span><br><span class="line">            ans+=<span class="number">1ll</span>*sz[i]*(sz[i]<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        e.<span class="built_in">push_back</span>(<span class="built_in">pi</span>(x<span class="number">-1</span>,y<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">b</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            b[j]=a[j]&gt;&gt;i&amp;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=(ans+(<span class="built_in">solve</span>(b)&lt;&lt;i))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小红的数列">4、小红的数列</h1><p>小红拿到了一个数列，该数列满足以下性质：</p><ol type="1"><li><span class="math inline">\(f(1)=a,f(2)=b\)</span></li><li><span class="math inline">\(f(i)=f(i-1)\cdot f(i-2)\cdotc^d\)</span></li></ol><p>请你计算出该数列的第<span class="math inline">\(n\)</span>项的因子数量。由于答案过大，请对<span class="math inline">\(10^9+7\)</span>取模。</p><h2 id="输入-3">输入</h2><p>五个正整数<span class="math inline">\(a,b,c,d,n\)</span>。</p><ul><li><span class="math inline">\(l\le a,b,c,d,n\le 10^{12}\)</span></li></ul><h2 id="输出-3">输出</h2><p>第<span class="math inline">\(n\)</span>项的因子数量对<span class="math inline">\(10^9+7\)</span>取模的值。</p><h2 id="样例-3">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">1 2 3 4 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">第三项是162，共有10个因子。</span><br></pre></td></tr></table></figure><h2 id="解答-3">解答</h2><p>如果一个数<span class="math inline">\(n\)</span>可以被分解成<span class="math inline">\(\displaystyle{n=\prod_{i=1}^mp_i^{e_i}}\)</span>，那么它的因子个数为<span class="math inline">\(\displaystyle{\sigma_0(n)=\prod_{i=1}^m(e_i+1)}\)</span>。</p><p>因此，我们可以考虑找出<span class="math inline">\(f(n)\)</span>的因式分解，并使用上面的公式进行求解出最终答案。</p><p>假设质因子<span class="math inline">\(p\)</span>在<span class="math inline">\(n\)</span>的质因数分解出现的次数记为<span class="math inline">\(g(n,p)\)</span>，令<span class="math inline">\(f_p(n)=g(f(n),p)\)</span>，那么按照上面<span class="math inline">\(f\)</span>的式子，我们可以得到：</p><p><span class="math display">\[f_p(n)=f_p(n-1)+f_p(n-2)+g(c,p)\cdotd\]</span></p><p>这和斐波那契数列非常像，更一般的，我们将它写成矩阵相乘的形式：</p><p><span class="math display">\[\begin{aligned}[f_p(n),f_p(n+1),g(c,p)\cdot d]&amp;=[f_p(n-1),f_p(n),g(c,p)\cdotd]\cdot\begin{bmatrix}0&amp;1&amp;0\\1&amp;1&amp;0\\0&amp;1&amp;1\\\end{bmatrix}\\&amp;=[f_p(1),f_p(2),g(c,p)\cdot d]\cdot\begin{bmatrix}0&amp;1&amp;0\\1&amp;1&amp;0\\0&amp;1&amp;1\\\end{bmatrix}^{n-1}\\&amp;=[g(a,p),g(b,p),g(c,p)\cdot d]\cdot\begin{bmatrix}0&amp;1&amp;0\\1&amp;1&amp;0\\0&amp;1&amp;1\\\end{bmatrix}^{n-1}\end{aligned}\]</span></p><p>其中，最后一行通过矩阵快速幂即可完成。</p><p>因此，最终答案为<span class="math inline">\(\displaystyle{\prod_p(f_p(n)+1)}\)</span>。其余的任务就是对<span class="math inline">\(a,b,c\)</span>进行因式分解，这没有任何难度。</p><h2 id="代码-3">代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> factorint</span><br><span class="line"></span><br><span class="line">mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">a: <span class="built_in">list</span>, b: <span class="built_in">list</span></span>):</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">sum</span>(a[i][k] * b[k][j] <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(b))) % mod <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(b[<span class="number">0</span>]))] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a))]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a, b, c, d, n = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">fa, fb, fc = <span class="built_in">dict</span>(factorint(a).items()), <span class="built_in">dict</span>(factorint(b).items()), <span class="built_in">dict</span>(factorint(c).items())</span><br><span class="line">mp = &#123;x: [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>(fa.keys()) + <span class="built_in">list</span>(fb.keys()) + <span class="built_in">list</span>(fc.keys())&#125;</span><br><span class="line"><span class="keyword">for</span> p, e <span class="keyword">in</span> fa.items():</span><br><span class="line">    mp[p][<span class="number">0</span>] += e</span><br><span class="line"><span class="keyword">for</span> p, e <span class="keyword">in</span> fb.items():</span><br><span class="line">    mp[p][<span class="number">1</span>] += e</span><br><span class="line"><span class="keyword">for</span> p, e <span class="keyword">in</span> fc.items():</span><br><span class="line">    mp[p][<span class="number">2</span>] += e</span><br><span class="line"></span><br><span class="line">ans = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> mp.values():</span><br><span class="line">    a = [[v[<span class="number">0</span>], v[<span class="number">1</span>], v[<span class="number">2</span>] * d]]</span><br><span class="line">    b = [[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]]</span><br><span class="line">    k = n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k:</span><br><span class="line">        <span class="keyword">if</span> k &amp; <span class="number">1</span>:</span><br><span class="line">            a = mul(a, b)</span><br><span class="line">        b = mul(b, b)</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span></span><br><span class="line">    ans = ans * (a[<span class="number">0</span>][<span class="number">0</span>] + <span class="number">1</span>) % mod</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
</feed>
