<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ujimatsu Chiya</title>
  
  
  <link href="https://ujimatsu-chiya.github.io/atom.xml" rel="self"/>
  
  <link href="https://ujimatsu-chiya.github.io/"/>
  <updated>2023-11-23T09:21:46.062Z</updated>
  <id>https://ujimatsu-chiya.github.io/</id>
  
  <author>
    <name>Ujimatsu Chiya</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>华为（留学） 秋招 2023.11.22 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Huawei-20231122B/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Huawei-20231122B/</id>
    <published>2023-11-23T09:21:46.000Z</published>
    <updated>2023-11-23T09:21:46.062Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="获取窗口最大优先级列表">1、获取窗口最大优先级列表</h1><p>在指令调度过程中，经常需要在某个指令序列中挑选出调度窗口大小内拥有最大优先级的元素，请设计一种方法能快速的挑选并记录下从左到右每个调度窗口中拥有最大优先级的元素(如果窗口中同时出现多个相等的最大优先级元素，记录拥有最小序列号元素)。</p><h2 id="输入">输入</h2><p>第一行一个正整数<span class="math inline">\(n\)</span>，表示指令数量。</p><p>第二行<span class="math inline">\(n\)</span>个用空格隔开的整数<span class="math inline">\(p_0,p_1,\dots,p_{n-1}\)</span>，分别表示第<span class="math inline">\(0\sim n-1\)</span>条指令的优先级大小。</p><p>第三行一个正整数<span class="math inline">\(k\)</span>，表示调度窗口大小。</p><ul><li><p><span class="math inline">\(0&lt;n\le 1000\)</span></p></li><li><p><span class="math inline">\(-100\le p_i\le 100,0\lei&lt;n\)</span></p></li><li><p><span class="math inline">\(0&lt;k\le n\)</span></p></li></ul><h2 id="输出">输出</h2><p>一行，<span class="math inline">\(n-k+1\)</span>个用空格隔开的整数，表示从左到右每个调度窗口中拥有最大优先级元素的序列号。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">8</span><br><span class="line">1 3 -1 -3 5 3 6 7</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1 1 4 4 6 7</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">下表中，&quot;()&quot;为调度窗口，调度窗口宽度为3:</span><br><span class="line">|调度窗口            |最大元素标号|</span><br><span class="line">|(1 3 -1)-3 5 3 6 7 | 1         |</span><br><span class="line">| 1(3 -1 -3)5 3 6 7 | 1         |</span><br><span class="line">| 1 3(-1 -3 5)3 6 7 | 4         |</span><br><span class="line">| 1 3 -1(-3 5 3)6 7 | 4         |</span><br><span class="line">| 1 3 -1 -3(5 3 6)7 | 6         |</span><br><span class="line">| 1 3 -1 -3 5(3 6 7)| 7         |</span><br><span class="line">从左往右，第一个调度窗口中的三个元素大小分别为&quot;1&quot;、&quot;3&quot;、&quot;1&quot;，所以第一个调度窗口中拥有最大优先级的元素下标为&quot;1&quot;，则输出&quot;1&quot;。依次类推，第二个至最后一个调度窗口中拥有最大优先级的元素下标分别为&quot;1&quot;、&quot;4&quot;、&quot;4&quot;、&quot;6&quot;、&quot;7&quot;。所以最终输出为&quot;1 1 4 4 6 7&quot;。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">8</span><br><span class="line">4 3 -1 -3 -6 -7 -8 5</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">0 1 2 3 4 5 7</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">|调度窗口               |最大元素标号|</span><br><span class="line">|(4 3)-1 -3 -6 -7 -8 5 | 0         |</span><br><span class="line">| 4(3 -1)-3 -6 -7 -8 5 | 1         |</span><br><span class="line">| 4 3(-1 -3)-6 -7 -8 5 | 2         |</span><br><span class="line">| 4 3 -1(-3 -6)-7 -8 5 | 3         |</span><br><span class="line">| 4 3 -1 -3(-6 -7)-8 5 | 4         |</span><br><span class="line">| 4 3 -1 -3 -6(-7 -8)5 | 5         |</span><br><span class="line">| 4 3 -1 -3 -6 -7(-8 5)| 7         |</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">4</span><br><span class="line">-3 4 2 3</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">|调度窗口   |最大元素标号|</span><br><span class="line">|(-3 4 2 3)| 1         |</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>其中一种最简单的方法是，枚举每个长度为<span class="math inline">\(k\)</span>的区间，并对这个区间内的所有数都排好序（以优先级大小为第一关键字降序，以索引为第二关键字升序）。然后输出排序结果的第一个指令对应的索引即可。这种做法的时间复杂度为<span class="math inline">\(O(n^2\log n)\)</span>。勉强通过本题。</p><p>接下来介绍一种使用<span class="math inline">\(O(n)\)</span>的时间的做法，其使用了单调队列。基本思想是从一个区间<span class="math inline">\([i-k+1,i]\)</span>的解得出<span class="math inline">\([i-k+2,i+1]\)</span>的解。对于这个队列的队头，如果取到了一个新的<span class="math inline">\(i\)</span>，那么就需要去掉队头所有满足<span class="math inline">\(\lei-k\)</span>的元素，因为区间已经不再覆盖这些元素。由于<span class="math inline">\(a_i\)</span>将要从队尾进行加入，那么就去掉队尾中所有满足<span class="math inline">\(&lt;p_i\)</span>的元素，这是因为随着<span class="math inline">\(p_i\)</span>的加入，被去掉的元素不可能再是一个最优解。最终，只需要输出队头的元素即可。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1004</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N],n,k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()&amp;&amp;i-q.<span class="built_in">front</span>()&gt;=k) q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()&amp;&amp;a[i]&gt;a[q.<span class="built_in">back</span>()]) q.<span class="built_in">pop_back</span>();</span><br><span class="line">        q.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=k<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>,q.<span class="built_in">front</span>(), <span class="string">&quot; \n&quot;</span>[i==n<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="独立拓扑问题">2、独立拓扑问题</h1><p>网络由<span class="math inline">\(n\)</span>台设备 (Device，编号<span class="math inline">\(0\)</span>到<span class="math inline">\(n-1\)</span>)组成，设备之间通过链路(Link)连接。每台设备固定属于某个设备层级(层级由整数表示，范围<span class="math inline">\(0\sim1000\)</span>，不同设备可能属于不同设备层级)。独立拓扑代表同一层级的设备互相通过直连的链路互联形成的局部网络拓扑(如果某设备没有与任何同层级设备有直连链路连接，该设备本身也是一个独立拓扑)。</p><p>输入所有设备、链路信息，找出这个网络里面最大的独立拓扑，返回独立拓扑中的设备数。</p><p>如下图所示，每个圆圈代表一台设备，圆圈的颜色用以区分设备所属的设备层级，黑色的线代表设备之间的链路连接，每个粉色框是一个独立拓扑，最大的独立拓扑是右下角的，包括了<span class="math inline">\(10\)</span>台设备。</p><p><img data-src="1.png"></p><h2 id="输入-1">输入</h2><p>第一行<span class="math inline">\(n\)</span>，代表<span class="math inline">\(n\)</span>台设备，编号<span class="math inline">\(0\)</span>到<span class="math inline">\(n-1\)</span>。</p><p>第二行<span class="math inline">\(n\)</span>个整数，代表每台设备对应的设备层级，层级范围<span class="math inline">\(0\sim1000\)</span>。</p><p>第三行<span class="math inline">\(m\)</span>，代表共有<span class="math inline">\(m\)</span>条链路。</p><p>第四行到第<span class="math inline">\(m+3\)</span>行，每行两个数字，代表某两台设备间存在的直连链路(链路代表两台设备互联，不区分左右顺序)</p><ul><li><span class="math inline">\(1\le n\le 1000\)</span></li><li><span class="math inline">\(0\le m\le 100000\)</span></li></ul><h2 id="输出-1">输出</h2><p>计算出的最大的独立拓扑的设备数量。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">27</span><br><span class="line">1 1 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3</span><br><span class="line">31</span><br><span class="line">0 1</span><br><span class="line">0 2</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">0 4</span><br><span class="line">4 5</span><br><span class="line">5 6</span><br><span class="line">6 7</span><br><span class="line">1 7</span><br><span class="line">2 8</span><br><span class="line">8 9</span><br><span class="line">9 10</span><br><span class="line">10 13</span><br><span class="line">3 11</span><br><span class="line">11 12</span><br><span class="line">12 13</span><br><span class="line">3 14</span><br><span class="line">14 15</span><br><span class="line">15 16</span><br><span class="line">4 17</span><br><span class="line">17 18</span><br><span class="line">18 19</span><br><span class="line">19 22</span><br><span class="line">22 21</span><br><span class="line">21 20</span><br><span class="line">20 5</span><br><span class="line">7 23</span><br><span class="line">23 24</span><br><span class="line">24 25</span><br><span class="line">25 26</span><br><span class="line">22 26</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">第一行表示27台设备</span><br><span class="line">第二行表示这27台设备每一台所属的设备层级</span><br><span class="line">第三行表示这个网络共有31条链路</span><br><span class="line">后面每一行代表链路两端设备编号</span><br><span class="line">最终输出为: 10。解释: 编号&quot;17、18、19、20、21、22、23、24、25、26&quot;这10台10设备之间不通过其他层设备即实现互联，并且与同层其他节点没有额外直接互联的。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">1 2 2</span><br><span class="line">2</span><br><span class="line">0 1</span><br><span class="line">0 2</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">第一行表示3台设备</span><br><span class="line">第二行表示这3台设备每一台所属的设备层级</span><br><span class="line">第三行表示这个网络共有2条链路</span><br><span class="line">后面每一行代表链路两端设备编号</span><br><span class="line"></span><br><span class="line">输出为：1。解释：设备0与另外两台设备的层级不一样。设备1与设备2虽然属于同一层级，但是没有直接互联，故这三台设备分别各自为一个独立拓扑。</span><br></pre></td></tr></table></figure><p>以下是第二个样例的图：</p><p><img data-src="2.png"></p><h2 id="解答-1">解答</h2><p>对于原图<span class="math inline">\(G\)</span>中的两个节点<span class="math inline">\(x,y\)</span>，如果它们处于同一层级，那么在新图<span class="math inline">\(G&#39;\)</span>中也为这两个节点连上边。这样子救恩那个确保只有同层级的节点才属于一个连通块。</p><p>因此问题转化成在新图<span class="math inline">\(G&#39;\)</span>上求最大的连通块大小，可以使用并查集进行求解。最终输出最大的集合大小即可。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1004</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N],n,m,k;</span><br><span class="line"><span class="type">int</span> fa[N],sz[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="built_in">find</span>(x),v=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(u!=v)&#123;</span><br><span class="line">        fa[v]=u;</span><br><span class="line">        sz[u]+=sz[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        fa[i]=i;sz[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(a[x]==a[y])&#123;</span><br><span class="line">            <span class="built_in">merge</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=*<span class="built_in">max_element</span>(sz,sz+n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="健康餐">3、健康餐</h1><p>某减肥食堂，每一份菜都标记了卡路里。一位顾客，根据营养师的建议，每次饮食都要将卡路里控制在一定区间内(含上下限的值) ，请问他有多少种选择。</p><p>为了简单起见，每份菜的卡路里用整数表示，且每份菜的卡路里数各不相同；同一个菜品可以打任意多份。</p><h2 id="输入-2">输入</h2><p>营养师建议的卡路里下限<code>kcal_low</code>和上限<code>kcal_high</code>。<code>1 &lt;= kcal_low &lt;= 1000; 1 &lt;= kcal_high &lt;= 1000</code>。</p><p>一个标记着每个菜品的卡路里的列表<code>menu</code>。<code>1 &lt;= menu.length &lt;= 100; 100 &lt;= menu[i] &lt;= 1000;  menu</code>中的所有值互不相同。</p><h2 id="输出-2">输出</h2><p>可行的打菜方案总数。</p><p>注：根据输入的不同，打菜方案总数，可能会大于<span class="math inline">\(2^{32}\)</span>，但可保证小于<span class="math inline">\(2^{64}\)</span>。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">350</span><br><span class="line">500</span><br><span class="line">100 200 500</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">其中，输入的含义：350是kcal_low，表示卡路里的下限；</span><br><span class="line">500是kcal_high，表示卡路里的上限；</span><br><span class="line">menu = [100,200,500]，表示各个菜品的卡路里。</span><br><span class="line">输出的含义：有7种选择，可以使这顿饭的卡路里摄取量在区间范围内。</span><br><span class="line">500=500</span><br><span class="line">500=200×2+100</span><br><span class="line">500=200+100×3</span><br><span class="line">500-100×5</span><br><span class="line">400=200×2</span><br><span class="line">400=200+100×2</span><br><span class="line">400=100×4</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">100</span><br><span class="line">400</span><br><span class="line">500 550 600 650 700 750 800 850 900 950 1000</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">100是kcal_low，表示卡路里的下限；</span><br><span class="line">400是kcal_high，表示卡路里的上限；</span><br><span class="line">menu = [500,550,600,650,700,750,800,850,900,950,1000]，表示各个菜品的卡路里。</span><br><span class="line">无法找到满足条件的健康餐组合，输出0。</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>这题是一道简单的完全背包问题。令<span class="math inline">\(m,M\)</span>分别表示题目中的卡路里下限和上限，<span class="math inline">\(n\)</span>表示菜单大小，<span class="math inline">\(a_i\)</span>表示每份菜的卡路里值。</p><p>那么，令<span class="math inline">\(f(i,j)(0\le i\le n,j\ge0)\)</span>表示选择了菜单中前<span class="math inline">\(i\)</span>份菜以及份数后，总卡路里数为<span class="math inline">\(j\)</span>的方案数，我们可以写出如下状态转移方程：</p><p><span class="math display">\[f(i,j)=\left \{\begin{aligned}  &amp;1  &amp; &amp; \text{if}\quad i=0\land j=0 \\  &amp;0  &amp; &amp; \text{if}\quad i=0\land j&gt;0 \\  &amp;f(i-1,j)  &amp; &amp; \text{if}\quad i&gt;0\land j&lt;a_i \\  &amp;f(i-1,j)+f(i,j-a_i)  &amp; &amp; \text{if}\quad i&gt;0\land j\gea_i \\\end{aligned}\right.\]</span></p><p>其中，方程的第四行第一个项表示第<span class="math inline">\(i\)</span>份菜未曾被选择过，第二个项表示第<span class="math inline">\(i\)</span>份菜被选择了，并且在<span class="math inline">\(f(i,j-a_i)\)</span>的基础上，又选择了一份菜。</p><p>因此最终答案为<span class="math inline">\(\displaystyle{\sum_{j=m}^Mf(n,j)}\)</span>。</p><h2 id="代码-2">代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mn = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">mx = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">f = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(mx + <span class="number">1</span>)]</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">a = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> a:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x, mx + <span class="number">1</span>):</span><br><span class="line">        f[i] += f[i - x]</span><br><span class="line">ans = <span class="built_in">sum</span>(f[mn:])</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>得物 秋招 2023.11.15 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Dewu-20231115/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Dewu-20231115/</id>
    <published>2023-11-23T09:21:43.000Z</published>
    <updated>2023-11-23T09:21:43.359Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="最少数字">1、最少数字</h1><p>小明用计算机随机生成了<span class="math inline">\(N\)</span>个正整数，他希望从这<span class="math inline">\(N\)</span>个数中选取若干个数，使得它们的和等于<span class="math inline">\(M\)</span>。这些随机生成的数字可能会相同，但是每个数字最多只允许使用一次。</p><p>当然这样的选取方案可能不存在，也可能有多个。</p><p>现在希望你编写一个程序，能够找出数字个数最少的选取方案，输出对应的最少数字的个数，如果无解输出<code>"No solution"</code>。</p><h2 id="输入">输入</h2><p>单组输入，每组输入<span class="math inline">\(2\)</span>行。</p><p>第<span class="math inline">\(1\)</span>行包合两个正整数<span class="math inline">\(N\)</span>和<span class="math inline">\(M\)</span>，分别表示初始输入的正整数个数和目标数字和。</p><ul><li><span class="math inline">\((N\le 10^3,M\le 10^5)\)</span></li></ul><p>第<span class="math inline">\(2\)</span>行为<span class="math inline">\(N\)</span>个正整数，两两之甸用空格隔开(每一个正整数均小于等于<span class="math inline">\(10^5\)</span>)。</p><h2 id="输出">输出</h2><p>输出数字个数最少的选取方案中所包含的最少数字个数，如果无解输出<code>"No solution"</code>。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5 5</span><br><span class="line">1 3 2 1 1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>这是一道经典的01背包问题。将数的和视为物品的重量，其价值视为<span class="math inline">\(1\)</span>，那么我们此时是希望最小化价值之和。令<span class="math inline">\(a_i\)</span>表示第<span class="math inline">\(i\)</span>个输入的数，<span class="math inline">\(f(i,j)(0\le i\le n,0\le j\lem)\)</span>表示在前<span class="math inline">\(i\)</span>个数中，和为<span class="math inline">\(j\)</span>的最小子集的大小。那么不难写出如下状态转移方程：</p><p><span class="math display">\[f(i,j)=\left \{\begin{aligned}  &amp;0  &amp; &amp; \text{if}\quad i=0\land j=0 \\  &amp;+\infty  &amp; &amp; \text{if}\quad i=0\land j&gt;0 \\  &amp;f(i-1,j) &amp; &amp; \text{if}\quad i&gt;0\land j&lt;a_i \\  &amp;\min\{f(i-1,j),f(i-1,j-a_i)+1\} &amp; &amp; \text{if}\quadi&gt;0\land j\ge a_i \\\end{aligned}\right.\]</span></p><p>其中，方程的第<span class="math inline">\(4\)</span>行表示了两种不同的选择：如果不选择<span class="math inline">\(a_i\)</span>，那么元素之和不变，因此从<span class="math inline">\(f(i-1,j)\)</span>转移过来；如果选择了元素<span class="math inline">\(a_i\)</span>，那么元素之和将增加<span class="math inline">\(a_i\)</span>，因此从<span class="math inline">\(f(i-1,j-a_i)\)</span>转移过来，并多计算一个元素个数。</p><p>因此最终答案为<span class="math inline">\(f(n,m)\)</span>。如果<span class="math inline">\(f(n,m)=+\infty\)</span>，那么说明无解。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">a = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">inf = <span class="number">10</span> ** <span class="number">9</span></span><br><span class="line">f = [inf <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> a:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m, x - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        f[i] = <span class="built_in">min</span>(f[i], f[i - x] + <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(f[m] <span class="keyword">if</span> f[m] != inf <span class="keyword">else</span> <span class="string">&quot;No solution&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="搭建电路">2、搭建电路</h1><p>小明迷上了一个搭建电路的游戏。</p><p><strong>在游戏中，两个电子元件之间只能存在唯一通路，每次在两个电子元件之间增加一条有效电路(两个元件之间先前没有电路相连)都将获得相应的积分奖励。 (初始状态时电子元件之间均未连接)。</strong></p><p>已知电子元件数量<span class="math inline">\(n\)</span>和部分电子元件之间的奖励积分值，如何构建一个有效电路将所有元件全部连接起来，并且可以得到最多的积分奖励。</p><h2 id="输入-1">输入</h2><p>第<span class="math inline">\(1\)</span>行输入两个正整数<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>，其中<span class="math inline">\(n\)</span>表示电子元件数量<span class="math inline">\((n&lt;=100)\)</span>，<span class="math inline">\(m\)</span>表示提供了<span class="math inline">\(m\)</span>对电子元件之间的奖励积分值<span class="math inline">\((m&lt;=1000)\)</span>。两个正整数之间用空格隔开。</p><p>第<span class="math inline">\(2\)</span>行到第<span class="math inline">\(m+1\)</span>行对应<span class="math inline">\(m\)</span>对电子元件及其对应的奖励积分值，每一行包含三个正整数，第<span class="math inline">\(1\)</span>个和第<span class="math inline">\(2\)</span>个整数表示电子元件编号($从$1开始)，第<span class="math inline">\(3\)</span>个整数表示两个元件之间搭建电路的奖励积分<span class="math inline">\(num(0&lt;num&lt;10^9)\)</span>。整数之同用空格隔开。</p><h2 id="输出-1">输出</h2><p>输出占<span class="math inline">\(1\)</span>行，输出一个正整数，即最多可以得到的积分奖励值。如果没有办法把所有元件全部连接起来，则输出<code>"No solution."</code><strong>(注意，<code>tion</code>后有英文句号)。</strong></p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3 3</span><br><span class="line">1 2 10</span><br><span class="line">1 3 20</span><br><span class="line">2 3 30</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">50</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>本题是最大生成树的模板题。相比于最小生成树，只需要从大到小遍历所有边，并尝试添加即可，这个过程使用Kruskal算法可以解决。</p><h2 id="代码-1">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">e = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    e.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">e.sort(key=<span class="keyword">lambda</span> x: -x[<span class="number">2</span>])</span><br><span class="line">fa = <span class="built_in">list</span>(<span class="built_in">range</span>(n + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> fa[x] == x:</span><br><span class="line">        <span class="keyword">return</span> fa[x]</span><br><span class="line">    fa[x] = find(fa[x])</span><br><span class="line">    <span class="keyword">return</span> fa[x]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">x, y</span>):</span><br><span class="line">    fa[find(x)] = find(y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cnt = ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> u, v, w <span class="keyword">in</span> e:</span><br><span class="line">    <span class="keyword">if</span> find(u) != find(v):</span><br><span class="line">        merge(u, v)</span><br><span class="line">        ans += w</span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(ans <span class="keyword">if</span> cnt == n - <span class="number">1</span> <span class="keyword">else</span> <span class="string">&quot;No solution.&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>民生科技 秋招 2023.10.29 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Minshengkeji-20231029/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Minshengkeji-20231029/</id>
    <published>2023-10-30T06:49:03.000Z</published>
    <updated>2023-10-30T06:49:03.658Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="小红的相似密码">1、小红的相似密码</h1><p>小红有两个银行卡密码，对于“相似”的密码，小红给出以下判断的规则：</p><p>小红可以对任意一个密码进行最多<span class="math inline">\(k\)</span>次操作，每次操作选择该密码所有字符，并将每个字符都加一(例如，<code>"abc"</code>加得到<code>"bcd"</code>，<code>"zzz"</code>加一得到<code>"aaa"</code>)。如果能通过这些操作后，使得两个密码变得相等，那么小红就认为这两个密码是相似的。</p><p>小红想知道自己的两个密码是否是相似的。你能帮帮她吗？</p><h2 id="输入">输入</h2><p>对于每组测试教据，第一行输入两个正整数<span class="math inline">\(n,k\)</span>，分别表示密码的长度和模作次数。</p><p>第二行输入一个长度为<span class="math inline">\(n\)</span>的字符串<span class="math inline">\(s\)</span>，表示小红第一个银行卡密码，仅包会小写字母。</p><p>第三行输入一个长度为<span class="math inline">\(n\)</span>的字符串<span class="math inline">\(t\)</span>，表示小红第二个银行卡密码，仅包会小写字母。</p><ul><li><span class="math inline">\(1 \le n \le 10^5\)</span></li><li><span class="math inline">\(1\le k\le 100\)</span></li></ul><h2 id="输出">输出</h2><p>一行输出一个字符串，表示答案。如果两个密码是相似的，则输出<code>"YES"</code>。否则输出<code>"NO"</code>。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">4 3</span><br><span class="line">abcd</span><br><span class="line">cdef</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">YES</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">4 1</span><br><span class="line">abcd</span><br><span class="line">cdef</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>假设不考虑炒作次数<span class="math inline">\(k\)</span>，那么一个字符串<span class="math inline">\(s\)</span>能够变成字符串<span class="math inline">\(t\)</span>，当且仅当这两个字符串的相邻两个字符的编号差值都相同，因为无论进行多少次操作，相邻字符编号之差总是不变的。</p><p>那么接下来考虑操作次数。我们要么对<span class="math inline">\(s\)</span>进行操作，要么对<span class="math inline">\(t\)</span>进行操作。令<span class="math inline">\(d&#39;=(s_0-t_0)\bmod 26\)</span>，并且令<span class="math inline">\(d=\min\{d&#39;,26-d&#39;\}\)</span>，这两种选择是要么选择<span class="math inline">\(s\)</span>，要么选择<span class="math inline">\(t\)</span>进行操作（选择一个最优的），只要步数<span class="math inline">\(d\le k\)</span>是正确的即可。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">s, t, k</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">diff</span>(<span class="params">s</span>):</span><br><span class="line">        <span class="keyword">return</span> [(<span class="built_in">ord</span>(s[i + <span class="number">1</span>]) - <span class="built_in">ord</span>(s[i])) % <span class="number">26</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s) - <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> diff(s) != diff(t):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    d = <span class="built_in">abs</span>(<span class="built_in">ord</span>(s[<span class="number">0</span>]) - <span class="built_in">ord</span>(t[<span class="number">0</span>]))</span><br><span class="line">    d = <span class="built_in">min</span>(d, <span class="number">26</span> - d)</span><br><span class="line">    <span class="keyword">return</span> d &lt;= k</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">s, t = <span class="built_in">input</span>(), <span class="built_in">input</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;YES&quot;</span> <span class="keyword">if</span> solve(s, t, k) <span class="keyword">else</span> <span class="string">&quot;NO&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="小红走排列">2、小红走排列</h1><p>数轴上有<span class="math inline">\(n\)</span>个点<span class="math inline">\(a_i\)</span>，小红初始在原点，希望按照一定的顺序访问这些点，小红想知道在所有的不同的访问顺序，走过的路径的总和是多少。例如有三个点<span class="math inline">\([1,3,5]\)</span>，按照<span class="math inline">\(a_1,a_2,a_3\)</span>的顺序访问，那么走过的路径为<span class="math inline">\(|1-0|+|3-1|+|5-3|=5\)</span>。按照<span class="math inline">\(a_1,a_3,a_2\)</span>的顺序访问，走过的路径为<span class="math inline">\(|1-0|+|5-1|+|3-5|=7\)</span>。一共有<span class="math inline">\(n!\)</span>种访问顺序。</p><h2 id="输入-1">输入</h2><p>警一行一个整数<span class="math inline">\(n\)</span>。表示点的个数。</p><p>第二行<span class="math inline">\(n\)</span>个整数，表示点的位置，按照升序给出。</p><ul><li><span class="math inline">\(1\le n\le 10^5\)</span></li><li><span class="math inline">\(1 \le a_1 \le \dots\le a_n \le10^9\)</span></li></ul><h2 id="输出-1">输出</h2><p>输出一行一个整数表示答案，答案可能很大，输出答案对<span class="math inline">\(10^9+7\)</span>取模的结果。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">1 3 5</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">50</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">顺序为a1,a2,a3时，路径为|1-0|+|3-1|+|5-3|=5。</span><br><span class="line">顺序为a1,a3,a2时，路径为|1-0|+|5-1|+|3-5|=7。</span><br><span class="line">顺序为a2,a1,a3时，路径为|3-0|+|1-3|+|5-1|=9。</span><br><span class="line">顺序为a2,a3,a1时，路径为|3-0|+|5-3|+|1-5|=9。</span><br><span class="line">顺序为a3,a1,a2时，路径为|5-0|+|1-5|+|3-1|=11。</span><br><span class="line">顺序为a3,a2,a1时，路径为|5-0|+|3-5|+|1-3|=9。</span><br><span class="line">所以答案为5+7+9+9+11+9=50。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>可见，由于所有路径都出现了恰好一次，因此对于任意一对<span class="math inline">\(i,j(i\neq j)\)</span>，小红先在<span class="math inline">\(a_i\)</span>，然后立刻走到<span class="math inline">\(a_j\)</span>的出现次数都是相同的。</p><p>假设不考虑处在<span class="math inline">\(0\)</span>的起点，由于每个路径的步数都是<span class="math inline">\(n-1\)</span>，因此所有路径的步数之和为<span class="math inline">\(n!\cdot(n-1)\)</span>。不同的满足<span class="math inline">\(i\neq j\)</span>的二元组<span class="math inline">\((i,j)\)</span>一共有<span class="math inline">\(n(n-1)\)</span>个，因此从<span class="math inline">\(a_i\)</span>到<span class="math inline">\(a_j\)</span>的走向的出现次数为<span class="math inline">\(n!\cdot(n-1)/(n(n-1))=(n-1)!\)</span>。</p><p>算上<span class="math inline">\(0\)</span>作为起点的情况。令<span class="math inline">\(a\)</span>的前缀和为<span class="math inline">\(\displaystyle{s_i=\sum_{j=1}^ia_i,s_0=0}\)</span>。这<span class="math inline">\(n!\)</span>条路径中，每个节点作为起点都恰好出现了<span class="math inline">\((n-1)!\)</span>次，因此这部分的答案为<span class="math inline">\(\displaystyle{(n-1)!\cdot s_n}\)</span>。</p><p>因此，这道题的答案为：</p><p><span class="math inline">\(\begin{aligned} (n-1)!\cdots_n+(n-1)!\cdot\sum_{i=1}^n\sum_{j=1}^n|a_i-a_j|&amp;=(n-1)!\cdot\left(s_n+\sum_{i=1}^n\sum_{j=1}^i(a_i-a_j)\right)\\ &amp;=(n-1)!\cdot\left(s_n+\sum_{i=1}^n(i\cdota_i-s_i)\right) \end{aligned}\)</span></p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line">ll a[N],s[N],mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">        s[i]=(s[i<span class="number">-1</span>]+a[i])%mod;</span><br><span class="line">        sum=(sum+a[i]*i%mod-s[i]+mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ll fac=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        fac=fac*i%mod;</span><br><span class="line">    ll ans=(fac*s[n]%mod+fac*<span class="number">2</span>*sum)%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>阿里云智能 秋招 2023.10.29 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Aliyunzhineng-20231029/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Aliyunzhineng-20231029/</id>
    <published>2023-10-30T06:49:01.000Z</published>
    <updated>2023-11-02T14:32:17.351Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="小红的单词">1、小红的单词</h1><p>小红有一个长度不超过<span class="math inline">\(10\)</span>的单词，写在了一个<span class="math inline">\(10\times10\)</span>的方块里，单词有可能是横着或者竖着的。</p><p>请你找到这个单词。</p><h2 id="输入">输入</h2><p>输入一个<span class="math inline">\(10\times10\)</span>的方块，字母表示单词的组或部分，<code>'.'</code>表示空白。</p><h2 id="输出">输出</h2><p>输出一个字符串表示答案。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">..........</span><br><span class="line">..........</span><br><span class="line">..........</span><br><span class="line">..smallred</span><br><span class="line">..........</span><br><span class="line">..........</span><br><span class="line">..........</span><br><span class="line">..........</span><br><span class="line">..........</span><br><span class="line">..........</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">smallred</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>由于单词是向下写或者是向右写的，因此只需要从上到下，从左到右枚举所有字母字符，按顺序添加到答案即可。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">10</span></span><br><span class="line">s = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    t = <span class="built_in">input</span>()</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> t[j] != <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">            s += t[j]</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小红的数组变换">2、小红的数组变换</h1><p>小红拿到了一个数组，她每次操作可以选择两个元素<span class="math inline">\(a_i,a_j\)</span>，并选择<span class="math inline">\(a_i\)</span>的一个因子<span class="math inline">\(x\)</span>，然后将<span class="math inline">\(a_i\)</span>变成<span class="math inline">\(a_i/x\)</span>，将<span class="math inline">\(a_j\)</span>变成<span class="math inline">\(a_j\times x\)</span>。</p><p>小红想知道，是否可以通过有限次操作，使得数组中每个元素最多只包含一种素因子？</p><p>素因子的定义： 若<span class="math inline">\(x\)</span>能被<span class="math inline">\(p\)</span>整除，且<span class="math inline">\(p\)</span>是素数，则<span class="math inline">\(p\)</span>为<span class="math inline">\(x\)</span>的一个素因子。例如，<span class="math inline">\(12\)</span>的素因子有<span class="math inline">\(2\)</span>和<span class="math inline">\(3\)</span>。</p><h2 id="输入-1">输入</h2><p>第一行输入一个正整数<span class="math inline">\(t\)</span>，代表询问次数。</p><p>接下来的<span class="math inline">\(2 \times t\)</span>行，每<span class="math inline">\(2\)</span>行为一次询问：</p><p>第一行输入一个正整数<span class="math inline">\(n\)</span>，代表数组的大小。</p><p>第二行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(a_i\)</span>，代表数组的元素。</p><ul><li><span class="math inline">\(1\le t\le 10\)</span></li><li><span class="math inline">\(1\le n\le 200000\)</span></li><li><span class="math inline">\(1 \le ai \le 10^6\)</span></li><li>保证所有的<span class="math inline">\(n\)</span>之和不超过<span class="math inline">\(200000\)</span></li></ul><h2 id="输出-1">输出</h2><p>输出<span class="math inline">\(t\)</span>行，若可以通过有限次操作，使得数组中每个元素最多只包含一种素因子，则输出<code>"Yes"</code>。否则输出<code>"No"</code>。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">1 2 3 4</span><br><span class="line">2</span><br><span class="line">10 12</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">第一组询问，不需要任何操作，因为每个元素本身只含一种素因子。</span><br><span class="line">第二组询问，显然是无解的。</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>题目中提到的操作意味着可以将每一个数的质因子转移到另一个数中。因此，一种贪心的思想是：同一个下标的数汇聚所有同一个质因子。</p><p>因此，我们只需要分别对<span class="math inline">\(a\)</span>中的每个数进行质因数分解，然后判断这些不同的质因子数量是否超过<span class="math inline">\(n\)</span>即可，因为同一个质因子可以汇聚到不同的下标。</p><h2 id="代码-1">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">a</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(a)</span><br><span class="line">    st = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> a:</span><br><span class="line">        st |= <span class="built_in">set</span>(sympy.factorint(x).keys())</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(st) &gt; n:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">    <span class="built_in">input</span>()</span><br><span class="line">    a = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Yes&quot;</span> <span class="keyword">if</span> solve(a) <span class="keyword">else</span> <span class="string">&quot;No&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小红的好字符串">3、小红的好字符串</h1><p>小红定义一个字符串是“好字符串”，当且仅当其不包含任意长度不小于<span class="math inline">\(2\)</span>的回文子串。例如，<code>"abcda"</code>是好字符串而<code>"arcaea"</code>则不是好字符串(因为包含了回文子串<code>"aea"</code>)。</p><p>现在小红拿到了一个字符串，她想知道有多少个非空子序列(可以不连续)是好字符串，你能帮帮她吗？</p><h2 id="输入-2">输入</h2><p>一个字符串，仅包含小写字母。字符串长度不超过<span class="math inline">\(10^5\)</span>。</p><h2 id="输出-2">输出</h2><p>好子序列的数量。由于答案可能过大，请对<span class="math inline">\(10^9+7\)</span>取模。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">aba</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">除了&quot;aa&quot;和”aba&quot;以外，其余五个子序列均是合法的。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">aaa</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">ghij</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">15</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>如果一个字符串是好字符串，当且仅当这个字符串的任意相邻<strong>三个</strong>字符都不相同。因为，不存在长度为<span class="math inline">\(2\)</span>的回文串意味着相邻两个字符不同，不存在长度为<span class="math inline">\(3\)</span>的回文串意味着被一个字符隔开的两个字符不能相同。</p><p>因此，这道题我们可以使用动态规划进行解决。令<span class="math inline">\(f(i,j,k)(0\le i\le n,0\le j\le m,0\le k&lt;m,i\neq j)\)</span>表示<span class="math inline">\(s\)</span>的长度为<span class="math inline">\(i\)</span>的前缀中，有多少个好子序列满足：倒数第一个字符是第<span class="math inline">\(k\)</span>个字符，倒数第二字符是第<span class="math inline">\(j\)</span>个字符（如果子序列长度小于<span class="math inline">\(2\)</span>，那么<span class="math inline">\(j=m\)</span>）。其中<span class="math inline">\(m=26\)</span>。令<span class="math inline">\(s_i\)</span>表示字符串<span class="math inline">\(s\)</span>中位置为<span class="math inline">\(i\)</span>的字母的序数（从<span class="math inline">\(0\)</span>到<span class="math inline">\(25\)</span>），那么有以下初值：</p><p><span class="math inline">\(f(0,\cdot,\cdot)=0\)</span>，这是因为空字符串不会包含任何字符，没有任何符合条件的子序列。</p><p>它也有如下转移：</p><ul><li><span class="math inline">\(f(i-1,\cdot,\cdot)\rightarrowf(i,\cdot,\cdot)\)</span>。这是因为第<span class="math inline">\(i\)</span>个字符没有被使用。</li><li><span class="math inline">\(f(i-1,j,k)\rightarrowf(i,k,s_i)\)</span>，其中<span class="math inline">\(j\neq s_i,k\neqs_i\)</span>，这是使用了第<span class="math inline">\(i\)</span>个字符，并且要确保前面两个字符不是<span class="math inline">\(s_i\)</span>。</li><li><span class="math inline">\(f(i-1,m,k)+[s_i=k]\rightarrowf(i,m,k)\)</span>，表示<span class="math inline">\(s_i\)</span>自成一个子序列，其中<span class="math inline">\([]\)</span>是一个示性函数，如果内部的布尔表达式的值为真，那么其值为<span class="math inline">\(1\)</span>，否则为<span class="math inline">\(0\)</span>。</li></ul><p>因此，最终答案为<span class="math inline">\(\displaystyle{\sum_{j=0}^m\sum_{k=0}^{m-1}f(n,j,k)}\)</span>。</p><h2 id="代码-2">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">m = <span class="number">26</span></span><br><span class="line">f = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">    x = <span class="built_in">ord</span>(ch) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i != x:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                <span class="keyword">if</span> j != x:</span><br><span class="line">                    f[j][x] += f[i][j]</span><br><span class="line">                    <span class="keyword">if</span> f[j][x] &gt;= mod:</span><br><span class="line">                        f[j][x] -= mod</span><br><span class="line">    f[m][x] += <span class="number">1</span></span><br><span class="line">ans = (<span class="built_in">sum</span>(f[i][j] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>))) % mod</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>阿里菜鸟 秋招 2023.10.25 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Alicainiao-20231025/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Alicainiao-20231025/</id>
    <published>2023-10-30T04:33:42.000Z</published>
    <updated>2023-10-30T04:33:42.707Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="小红的偶数">1、小红的偶数</h1><p>小红喜欢偶数，即一个数从因数分解的角度来看，其中的偶数因子越多，她就越喜欢这个数。也就是，<span class="math inline">\(x=p_1 \times p_2 \times\dots\timesp_k\)</span>，其中<span class="math inline">\(p_i\)</span>都是偶数，那么<span class="math inline">\(k\)</span>的最大值就是小红对这个数的喜欢程度。小红想知道区间<span class="math inline">\([l,r]\)</span>的数中，小红对哪个数的喜欢程度最高，输出小红的喜欢程度。</p><h2 id="输入">输入</h2><p>一行两个整数<span class="math inline">\(l,r\)</span>，表示区间<span class="math inline">\([l,r]\)</span>。</p><ul><li><span class="math inline">\(1\le l\le r \le 10^9\)</span></li></ul><h2 id="输出">输出</h2><p>输出一个整数，表示小红对这个数的喜欢程度。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3 10</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">小红最喜欢的数是8，喜欢程度是3，因为8=2×2×2。</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>对于一个正整数<span class="math inline">\(n\)</span>，假设<span class="math inline">\(n\)</span>有<span class="math inline">\(k\)</span>个质因子<span class="math inline">\(2\)</span>，那么存在一个题目中要求的分解，其中<span class="math inline">\(p_1=p_2=\dots=p_{k-1}=2,p_k=\dfrac{n}{2^{k-1}}\)</span>，并且这时的<span class="math inline">\(k\)</span>已经达到最大。</p><p>因此，为了判断区间<span class="math inline">\([l,r]\)</span>中是否存在一个整数，其喜欢程度为<span class="math inline">\(k\)</span>，只需要判断<span class="math inline">\(2^k\)</span>是否能整除<span class="math inline">\([l,r]\)</span>中的一个数即可。</p><p>基于前缀和的思想，我们可以知道，在<span class="math inline">\(1\simn\)</span>这<span class="math inline">\(n\)</span>个数中，有<span class="math inline">\(\lfloor n/d\rfloor\)</span>个数是<span class="math inline">\(d\)</span>的倍数。</p><p>因此，如果<span class="math inline">\(2^k\)</span>整除区间<span class="math inline">\([l,r]\)</span>中的某一个数，那么就会有<span class="math inline">\(\lfloor r/2^k\rfloor\neq\lfloor(l-1)/2^k\rfloor\)</span>。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">l, r = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">34</span>):</span><br><span class="line">    <span class="keyword">if</span> (r &gt;&gt; i) != ((l - <span class="number">1</span>) &gt;&gt; i):</span><br><span class="line">        ans = i</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure><h1 id="小红的数组">2、小红的数组</h1><p>小红有一个数组<span class="math inline">\(a\)</span>，每次可以进行以下两种操作：</p><ol type="1"><li>选择一个下标<span class="math inline">\(i\)</span>，将<span class="math inline">\(a_i\)</span>加<span class="math inline">\(2\)</span>，即<span class="math inline">\(a_i =a_i+2\)</span>。</li><li>选择一个下标<span class="math inline">\(i\)</span>，如果<span class="math inline">\(a_i= a_{i+1}\)</span>，将<span class="math inline">\(a_i\)</span>和<span class="math inline">\(a_{i+1}\)</span>加<span class="math inline">\(1\)</span>，即<span class="math inline">\(a_i =a_{i}+1,a_{i+1} = a_{i+1}+1\)</span>；否则不能进行操作。</li></ol><p>小红可以进行若干次操作，小红想知道能否通过若干次操作使得数组<span class="math inline">\(a\)</span>中所有元素相等。</p><h2 id="输入-1">输入</h2><p>第一行一个整数<span class="math inline">\(t\)</span>，表示数据组数。</p><p>接下来<span class="math inline">\(t\)</span>组数据，每组数据第一行一个整数<span class="math inline">\(n\)</span>，表示数组长度。</p><p>接下来一行<span class="math inline">\(n\)</span>个整数<span class="math inline">\(a_1,a_2,\dots,a_n\)</span>，表示数组<span class="math inline">\(a\)</span>的初始值。</p><ul><li><span class="math inline">\(1\le t\le 10\)</span></li><li><span class="math inline">\(1 \le n \le 10^5\)</span></li><li><span class="math inline">\(1 \le a_i \le 10^9\)</span></li></ul><h2 id="输出-1">输出</h2><p>输出<span class="math inline">\(t\)</span>行，每行一个字符串，如果能使得数组<span class="math inline">\(a\)</span>中所有元素相等，输出<code>"YES"</code>，否则输出<code>"NO"</code>。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">3</span><br><span class="line">1 1 3</span><br><span class="line">3</span><br><span class="line">2 2 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">第一组，无法通过操作使得数组a中所有元素相等。</span><br><span class="line">第二组，对i=1,2各执行一次操作一，即可使得数组a中所有元素相等。</span><br><span class="line">第三组，对i=1各执行一次操作二，即可使得数组a中所有元素相等。</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>使用操作一，我们可以将<span class="math inline">\(a\)</span>中的所有数全都提高到足够大的地步，得到如下数组<span class="math inline">\(a&#39;\)</span>：</p><ul><li><span class="math inline">\(\foralli\in[1,n],a&#39;_i\)</span>的奇偶性和<span class="math inline">\(a_i\)</span>相同。</li><li>奇偶性相同的两个下标<span class="math inline">\(i,j\)</span>满足<span class="math inline">\(a&#39;_i=a&#39;_j\)</span>。</li></ul><p>此时数组中元素的差不会超过<span class="math inline">\(1\)</span>。通过更进一步可以发现，本质上操作一的存在可以随意调整数组<span class="math inline">\(a\)</span>中的大小，只有通过操作二才能改变元素的奇偶性。因此，令<span class="math inline">\(b_i=a_i\bmod2\)</span>，那么操作二可以视为是对相同的<span class="math inline">\(b_i,b_{i+1}(i&lt;n)\)</span>都进行翻转。</p><p>接下来将<span class="math inline">\(b\)</span>中的数按照相同的数分成一段段，计算每一个段的长度，得到一个长度为<span class="math inline">\(m\)</span>的数组<span class="math inline">\(c\)</span>。对于一次操作二，观察数组<span class="math inline">\(c\)</span>的变化，可以发现，<span class="math inline">\(c\)</span>中奇数下标的元素和和偶数下标的元素和的奇偶性总是不变的。</p><p>如果<span class="math inline">\(c\)</span>中奇数下标的元素和和偶数下标的元素和都是奇数，那么无论通过多少次操作二，<span class="math inline">\(b\)</span>总会存在两个相邻的段，其长度都是奇数，因此这时的数组是不满足条件的。否则，只需要一系列的操作二，<span class="math inline">\(b\)</span>中只会剩下一个长度为奇数的段，这时只需要将其它段都执行操作二即可满足题目条件。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"><span class="type">int</span> a[N],c[N],n;</span><br><span class="line"><span class="type">int</span> d[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        a[i]&amp;=<span class="number">1</span>;c[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pre=a[<span class="number">1</span>],m=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre==a[i]) ++cnt;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            c[++m]=cnt;</span><br><span class="line">            cnt=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    c[++m]=cnt;</span><br><span class="line">    d[<span class="number">0</span>]=d[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c[i]&amp;<span class="number">1</span>) d[i&amp;<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (d[<span class="number">0</span>]&amp;d[<span class="number">1</span>])==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="built_in">solve</span>()?<span class="string">&quot;YES&quot;</span>:<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小红的子数组权值">3、小红的子数组权值</h1><p>小红有一个长度为<span class="math inline">\(n\)</span>的数组<span class="math inline">\(a\)</span>，记子区间<span class="math inline">\([l,r]\)</span>的权值为<span class="math inline">\(a_l|a_{l+1}|\dots|a_r\)</span>，即区间内所有数的按位或运算的结果。一共有<span class="math inline">\(n\times(n+1)/2\)</span>个子区间，小红想知道对应的<span class="math inline">\(n\times(n+1)/2\)</span>个权值中，有多少个不同的取值。</p><h2 id="输入-2">输入</h2><p>第一行一个整数<span class="math inline">\(n\)</span>，表示数组长度。</p><p>第二行<span class="math inline">\(n\)</span>个整数<span class="math inline">\(a_1,a_2,\dots,a_n\)</span>，表示数组<span class="math inline">\(a\)</span>的元素。</p><ul><li><span class="math inline">\(1 \le n \le 10^5\)</span></li><li><span class="math inline">\(1 \le a_i \le 10^9\)</span></li></ul><h2 id="输出-2">输出</h2><p>输出一个整数，表示不同的取值个数。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">1 2 4</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">[1,1]的权值为1</span><br><span class="line">[1,2]的权值为3</span><br><span class="line">[1,3]的权值为7</span><br><span class="line">[2,2]的权值为2</span><br><span class="line">[2,3]的权值为6</span><br><span class="line">[3,3]的权值为4</span><br><span class="line">权值两两不同，共有6种取值。</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>本题是Leetcode 898的原题。对于任意一个下标<span class="math inline">\(r\)</span>，可以发现，以<span class="math inline">\(r\)</span>为最后一个元素的子数组最多只有<span class="math inline">\(\log M\)</span>个不同的权值，其中<span class="math inline">\(M\)</span>是数组<span class="math inline">\(a\)</span>的最大值。这是因为根据或运算的性质，对原来的或之和多或上一个数只会将原来的或之和的某些<span class="math inline">\(0\)</span>比特置换成<span class="math inline">\(1\)</span>比特（反之不可行）。</p><p>因此从左到右枚举下标<span class="math inline">\(r\)</span>，我们可以维护一个集合<span class="math inline">\(R_r\)</span>用来表示以<span class="math inline">\(r\)</span>为终点的子数组的不同权值，这个集合可以由<span class="math inline">\(R_{r-1}\)</span>得出，并且为<span class="math inline">\(R_r=\{x\mid a_r:x\inR_{r-1}\}\cup\{x\}\)</span>。可以发现<span class="math inline">\(R_r\)</span>的大小永远不会超过<span class="math inline">\(\log M\)</span>。最终将所有<span class="math inline">\(R_r\)</span>的集合求并集然后输出大小即可。</p><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"><span class="type">int</span> a[N],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt;st,suf,t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        t.<span class="built_in">clear</span>();</span><br><span class="line">        t.<span class="built_in">insert</span>(a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x:suf) t.<span class="built_in">insert</span>(x|a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y:t) st.<span class="built_in">insert</span>(y);</span><br><span class="line">        suf=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,st.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>字节跳动 秋招 2023.10.22 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Zijietiaodong-20231022/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Zijietiaodong-20231022/</id>
    <published>2023-10-22T15:59:21.000Z</published>
    <updated>2023-10-22T15:59:21.460Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="小红的赛车队">1、小红的赛车队</h1><p>假设有<span class="math inline">\(n\)</span>个赛车队参加一场比赛，每个赛车队的车辆数为<span class="math inline">\(a_i\)</span>辆，要将这<span class="math inline">\(n\)</span>个赛车队分成小组，每个小组里的车辆总数不超过<span class="math inline">\(4\)</span>辆，并且不能把赛车队拆开。问最少需要多少个小组。</p><h2 id="输入">输入</h2><p>一行一个整数<span class="math inline">\(t\)</span>，表示数据组数。</p><p>每组数据第一行一个整数<span class="math inline">\(n\)</span>，表示赛车队数。</p><p>接下来一行<span class="math inline">\(n\)</span>个整数<span class="math inline">\(a_i\)</span>，表示每个赛车队的车辆数。</p><ul><li><span class="math inline">\(1 \le t \le 100\)</span></li><li><span class="math inline">\(1\le n \le 10^3\)</span></li><li><span class="math inline">\(1 \le a_i\le 4\)</span></li></ul><h2 id="输出">输出</h2><p>输出<span class="math inline">\(t\)</span>行，每行一个整数，表示最少需要的小组数。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">1 2 3 4</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">前两个车队一组，第三个车队一组，第四个车队一组即可。</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>本题可以使用贪心的思想进行解决。</p><p>可见，<span class="math inline">\(4\)</span>辆一队的队伍无法和其它队伍成组，必须自己成组。<span class="math inline">\(3\)</span>辆一队的队伍参加组合，要么自己成组，要么带上一个<span class="math inline">\(1\)</span>辆一队的车队。</p><p>如此，处理完<span class="math inline">\(4\)</span>辆一队和<span class="math inline">\(3\)</span>辆一队的车队，剩下<span class="math inline">\(2\)</span>辆一队和<span class="math inline">\(1\)</span>辆一队的车队。为了尽量减少成组数量，让<span class="math inline">\(2\)</span>辆一队的车队两个两个组合。如果<span class="math inline">\(2\)</span>辆一队的车队还剩下一个，那么可以<strong>至多</strong>带上<span class="math inline">\(2\)</span>个<span class="math inline">\(1\)</span>辆一队的车队。剩下的<span class="math inline">\(1\)</span>辆一队的车队直接尽可能地进行组合，如果这时仍然有<span class="math inline">\(c\)</span>个<span class="math inline">\(1\)</span>辆一队的车队，那么至少还需要组成<span class="math inline">\(\lceil c/4\rceil\)</span>个组。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c[<span class="number">7</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in">sizeof</span>(c));</span><br><span class="line">    <span class="type">int</span> n,x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);++c[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=c[<span class="number">4</span>]+c[<span class="number">3</span>];</span><br><span class="line">    c[<span class="number">1</span>]=<span class="built_in">max</span>(<span class="number">0</span>,c[<span class="number">1</span>]-c[<span class="number">3</span>]);</span><br><span class="line">    ans+=c[<span class="number">2</span>]&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(c[<span class="number">2</span>]&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        ++ans;</span><br><span class="line">        c[<span class="number">1</span>]=<span class="built_in">max</span>(<span class="number">0</span>,c[<span class="number">1</span>]<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ans+=(c[<span class="number">1</span>]+<span class="number">3</span>)/<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">solve</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小红走迷宫">2、小红走迷宫</h1><p>小红和朋友被困在了迷宫里，迷宫有<span class="math inline">\(n\)</span>个传送阵，每个传送阵都有一个编号<span class="math inline">\(i\)</span>(编号从<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>)，编号为<span class="math inline">\(i\)</span>的传送阵会将小红传送到编号为<span class="math inline">\(a_i\)</span>的传送阵。小红最初在编号为<span class="math inline">\(s\)</span>的传送阵，朋友最初在编号为<span class="math inline">\(t\)</span>的传送阵，小红和朋友都可以通过传送阵传送，每次传送都会花费一分钟（两人可以同时传送）。现在小红想知道，小红和朋友最少需要多少分钟才能在同一个传送阵里见面，如果不能见面，输出<span class="math inline">\(-1\)</span>。</p><h2 id="输入-1">输入</h2><p>第一行输入三个整数<span class="math inline">\(n,s,t\)</span>，表示传送阵的数量，小红最初所在的传送阵编号，朋友最初所在的传送阵编号。</p><p>第二行输入<span class="math inline">\(n\)</span>个整数<span class="math inline">\(a_i\)</span>，表示编号为<span class="math inline">\(i\)</span>的传送阵会将小红传送到编号为<span class="math inline">\(a_i\)</span>的传送阵。</p><ul><li><span class="math inline">\(1\le n\le 10^5\)</span></li><li><span class="math inline">\(1\le s,t\le n\)</span></li><li><span class="math inline">\(1\le a_i\le n\)</span></li></ul><p>保证<span class="math inline">\(a_i\)</span>数组中的元素互不相同。</p><h2 id="输出-1">输出</h2><p>输出一个整数，表示小红和朋友最少需要多少分钟才能在同一个传送阵里见面，如果不能见面，输出<span class="math inline">\(-1\)</span>。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5 1 2</span><br><span class="line">5 1 2 3 4</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">朋友可以通过一次传送到达小红所在位置。</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>首先对小红自己的坐标进行多次迭代，求出首次到达时间，令<span class="math inline">\(c_i\)</span>表示小红首次到达<span class="math inline">\(i\)</span>的时间，<span class="math inline">\(c_i=-1\)</span>意味着小红无法从<span class="math inline">\(s\)</span>到达<span class="math inline">\(i\)</span>。可见，小红必定会在有限次内多次到达同一个节点，这时停止迭代。</p><p>接下来让朋友的坐标进行多次迭代。同样的，只要到达已经传送过的节点就停止。假设朋友在时间<span class="math inline">\(i\)</span>到达节点<span class="math inline">\(u\)</span>，并且<span class="math inline">\(c_u\neq -1\)</span>，那么说明小红可以以<span class="math inline">\(c_u\)</span>的时间到达节点<span class="math inline">\(u\)</span>，这时<span class="math inline">\(\min\{i,c_u\}\)</span>是一个候选答案。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"><span class="type">int</span> c[N],vis[N],a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,s,t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;n,&amp;s,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">-1</span>,<span class="built_in">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c[s]!=<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        c[s]=i;</span><br><span class="line">        s=a[s];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[t])&#123;</span><br><span class="line">            vis[t]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(c[t]!=<span class="number">-1</span>)</span><br><span class="line">                ans=<span class="built_in">min</span>(ans,<span class="built_in">max</span>(i,c[t]));</span><br><span class="line">            t=a[t];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans&gt;n) ans=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小红的前缀和之和">3、小红的前缀和之和</h1><p>给定两个正整数<span class="math inline">\(n,x\)</span>，小红希望你构造一个长度为<span class="math inline">\(n\)</span>的数组，满足<span class="math inline">\(\displaystyle{\sum_{i=1}^n\text{sum}(i)=x}\)</span>。</p><p><span class="math inline">\(\text{sum}(i)\)</span>即数组的前<span class="math inline">\(i\)</span>项之和。换言之，小红希望你构造一个长度为<span class="math inline">\(n\)</span>的数组满足，<span class="math inline">\(n\)</span>个前缀和之和等于<span class="math inline">\(x\)</span>。</p><p>要求数组的元素仅由<span class="math inline">\(1\)</span>和<span class="math inline">\(2\)</span>组成。</p><h2 id="输入-2">输入</h2><p>两个正整数<span class="math inline">\(n,x\)</span></p><ul><li><span class="math inline">\(1\le n \le 10^5\)</span></li><li><span class="math inline">\(1 \le x \le 10^{18}\)</span></li></ul><h2 id="输出-2">输出</h2><p>如果无解，请输出<span class="math inline">\(-1\)</span>。</p><p>否则输出<span class="math inline">\(n\)</span>个正整数，每个正整数为<span class="math inline">\(1\)</span>或者<span class="math inline">\(2\)</span>。有多解时输出任意即可。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3 8</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1 2 1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">三个前缀和分别是1,3,4,1+3+4=8，符合条件。</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>令需要打印的数组为<span class="math inline">\(a\)</span>。那么根据<span class="math inline">\(\text{sum}(i)\)</span>中每个元素的贡献，可以发现其前缀和的和为<span class="math inline">\(\displaystyle{s=\sum_{i=1}^n(n-i+1)a_i}\)</span>。可以发现这是一个关于<span class="math inline">\(a\)</span>的<strong>线性</strong>表达式，并且其系数都是正数。</p><p>由于<span class="math inline">\(a_i\in\{1,2\}\)</span>，因此<span class="math inline">\(s\)</span>的值至少为<span class="math inline">\(\dfrac{n(n+1)}{2}\)</span>，至多为<span class="math inline">\(n(n+1)\)</span>。这意味着如果存在答案，那么<span class="math inline">\(x\)</span>的值应该在这两个界限之间。</p><p>之后开始考虑填入<span class="math inline">\(a\)</span>的每个数。为了正确处理上下界的过程，我们假设这时填入某个新数组<span class="math inline">\(a&#39;\)</span>的元素<span class="math inline">\(a&#39;_i\)</span>的是<span class="math inline">\(0\)</span>和<span class="math inline">\(1\)</span>，并且数组之和为<span class="math inline">\(x&#39;=x-\dfrac{n(n+1)}{2}\)</span>，这意味着我们对每个元素都加上<span class="math inline">\(1\)</span>就可以得到原问题的答案。一开始假设<span class="math inline">\(a&#39;\)</span>中所有元素为<span class="math inline">\(0\)</span>。令<span class="math inline">\(s\)</span>的系数<span class="math inline">\(c_i=n-i+1\)</span>。我们按照<span class="math inline">\(i\)</span>小到大的顺序（也就是<span class="math inline">\(c_i\)</span>从大到小的顺序）枚举<span class="math inline">\(i\)</span>，判断将<span class="math inline">\(a_i&#39;\)</span>改成<span class="math inline">\(1\)</span>是否会导致前缀和之和<span class="math inline">\(\displaystyle{s&#39;=\sum_{i=1}^nc_ia&#39;_i}\)</span>是否会超过<span class="math inline">\(x&#39;\)</span>，如果不超过，那么将<span class="math inline">\(a_i&#39;\)</span>变成<span class="math inline">\(1\)</span>。可见只要<span class="math inline">\(x&#39;\)</span>不超过<span class="math inline">\(\dfrac{n(n+1)}{2}\)</span>，这样子枚举一定是有解的。</p><h2 id="代码-2">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>():</span><br><span class="line">    n, x = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    x -= n * (n + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> [-<span class="number">1</span>]</span><br><span class="line">    a = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> n - i &lt;= x:</span><br><span class="line">            a.append(<span class="number">2</span>)</span><br><span class="line">            x -= n - i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a.append(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> [-<span class="number">1</span>] <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(*solve())</span><br></pre></td></tr></table></figure><h1 id="不相交区间">4、不相交区间</h1><p>现有一个长度为<span class="math inline">\(n\)</span>的数组<span class="math inline">\(a\)</span>和<span class="math inline">\(m\)</span>个区间。</p><p>你可以选择任意个区间，选择的区间不能相交。如果选择一个区间<span class="math inline">\([l,r]\)</span>。那么可以获得<span class="math inline">\(\displaystyle{\sum_{i=l}^ra_i}\)</span>的分数。</p><p>请你计算出你可以获得的最大分数。</p><p>请注意，如果区间右端点在数组的范围之外，则该区间不可选取。</p><p>假设两个区间分别是<span class="math inline">\([l_1,r_1]\)</span>和<span class="math inline">\([l_2,r_2]\)</span>，如果它们满足<span class="math inline">\(l_1 \le l_2\le r_1\)</span>或<span class="math inline">\(l_2\le r_1\ler_2\)</span>，则认为这两个区间相交。</p><h2 id="输入-3">输入</h2><p>第一行两个整数<span class="math inline">\(n,m\)</span>，表示数组的长度和区间的个数。</p><p>第二行<span class="math inline">\(n\)</span>个整数<span class="math inline">\(a_i\)</span>，表示数组的元素。</p><p>接下来<span class="math inline">\(m\)</span>行每行两个整数<span class="math inline">\(l_i,r_i\)</span>，表示每一个区间。</p><ul><li><span class="math inline">\(1\le n,m,a_i\le 10^5\)</span></li><li><span class="math inline">\(1\le l\le r\le 10^5\)</span></li></ul><h2 id="输出-3">输出</h2><p>输出一个整数，表示可以获得的最大分数。</p><h2 id="样例-3">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5 3</span><br><span class="line">1 2 3 4 9</span><br><span class="line">1 4</span><br><span class="line">2 3</span><br><span class="line">4 5</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">18</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">5 3</span><br><span class="line">9 2 3 4 1</span><br><span class="line">1 4</span><br><span class="line">2 3</span><br><span class="line">4 5</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">18</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解答-3">解答</h2><p>这是一道比较明显的动态规划问题。</p><p>令数组<span class="math inline">\(a\)</span>的前缀和为<span class="math inline">\(\displaystyle{s_i=\sum_{j=1}^ia_j},s_0=0\)</span>。令<span class="math inline">\(f(r)(0\le r\le n)\)</span>表示前<span class="math inline">\(r\)</span>个元素中，一个最优秀的选法所得到的最大分数和（如果有一些区间的右端点超过了<span class="math inline">\(r\)</span>，那么很明显这些区间是无法被选择的）。那么可以写出其状态转移方程如下：</p><p><span class="math inline">\(f(r)= \left \{\begin{aligned}  &amp;0&amp; &amp; \text{if}\quad r=0 \\  &amp;\max\left\{f(r-1),\max_{1\lej\le m,r_j=r} \{f(l_i-1)+s_r-s_{l_i-1}\}\right\}&amp; &amp;\text{if}\quad r&gt;0 \\ \end{aligned}\right.\)</span></p><p>其中，如果不选择以<span class="math inline">\(r\)</span>为端点的区间，那么就从<span class="math inline">\(f(r-1)\)</span>转移过来，并不产生任何分数。否则，如果选择某个区间<span class="math inline">\([l_i,r]\)</span>，那么为了保证区间不产生相交，其它的区间端点必须小于<span class="math inline">\(l_i\)</span>，即从<span class="math inline">\(f(l_i-1)\)</span>转移而来，并且选上了<span class="math inline">\([l_i,r]\)</span>这个区间，得到了<span class="math inline">\(s_r-s_{l_i-1}\)</span>的分数。</p><p>因此最终答案为<span class="math inline">\(f(n)\)</span>。</p><h2 id="代码-3">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100005</span>;</span><br><span class="line">ll f[N],s[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;g[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,l,r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;s[i]);</span><br><span class="line">        s[i]+=s[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="keyword">if</span>(r&lt;=n) g[r].<span class="built_in">push_back</span>(l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">1</span>;r&lt;=n;r++)&#123;</span><br><span class="line">        f[r]=f[r<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l:g[r])&#123;</span><br><span class="line">            f[r]=<span class="built_in">max</span>(f[r],f[l<span class="number">-1</span>]+s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>阿里大文娱 秋招 2023.10.15 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Alidawenyu-20231015/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Alidawenyu-20231015/</id>
    <published>2023-10-20T02:56:20.000Z</published>
    <updated>2023-10-20T02:56:20.725Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="小红一家人">1、小红一家人</h1><p>小红拿到了一棵二叉树。小红定义，如果一个节点既有左孩子又有右孩子，那么这三个节点被称为“一家人”。</p><p>小红想知道，在这个二叉树中，一共能找到多少“一家人”？(每个节点最多被计算一次)</p><p>设节点个数为<span class="math inline">\(n,n\le 2\cdot10^5\)</span>。$1<span class="math inline">\(节点权值\)</span>n$，且任意两点权值互不相同。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">&#123;1,2,3,4,5,6,7&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">若选择了[1,2,3]这一家人，那么2,3节点就无法选取为父亲，最终就只有一组“一家人”。</span><br></pre></td></tr></table></figure><p>上面样例对应的树为：</p><pre class="mermaid">graph TD  1((1));    subgraph A2    3((3));6((6));7((7));  end  subgraph A1    2((2));4((4));5((5));  end  1---2;1---3;2---4;2---5;  3---6;3---7;</pre><h2 id="解答">解答</h2><p>本题是一道树形动态规划。令状态<span class="math inline">\(f_{u,0}\)</span>表示以<span class="math inline">\(u\)</span>为根的子树中，最大的一家人个数是多少个，其中节点<span class="math inline">\(u\)</span><strong>不被作为一家人的父亲节点使用</strong>，令状态<span class="math inline">\(f_{u,1}\)</span>表示以<span class="math inline">\(u\)</span>为根的子树中，最大的一家人个数是多少个，其中节点<span class="math inline">\(u\)</span><strong>被作为一家人的父亲节点使用</strong>。</p><p>那么对于树上的一个节点<span class="math inline">\(u\)</span>，它分别有如下三种情况：</p><ul><li><span class="math inline">\(u\)</span>是一个叶子节点，这时<span class="math inline">\(f_{u,0}=f_{u,1}=0\)</span>是显而易见的。</li><li><span class="math inline">\(u\)</span>只有一个儿子，假设这个儿子为<span class="math inline">\(v\)</span>。可见，<span class="math inline">\(u\)</span>不可能作为一个父亲节点被使用，因此<span class="math inline">\(f_{u,1}=0\)</span>。如果不使用<span class="math inline">\(u\)</span>，那么方案数并不会增加，无论子节点有没有被选上都没所谓，因此有<span class="math inline">\(f_{u,0}=\max\{f_{v,0},f_{v,1}\}\)</span>。</li><li><span class="math inline">\(u\)</span>有两个儿子，假设两个儿子分别为<span class="math inline">\(l,r\)</span>。如果<span class="math inline">\(u\)</span>被作为父亲节点被使用，那么<span class="math inline">\(l,r\)</span>都不能作为父亲节点被使用，因此有<span class="math inline">\(f_{u,1}=f_{l,0}+f_{r,0}+1\)</span>。如果<span class="math inline">\(u\)</span>不被作为父亲节点被使用，那么<span class="math inline">\(l,r\)</span>是否作为父亲节点并没有所谓，因此有<span class="math inline">\(f_{u,1}=\max\{f_{l,0},f_{l,1}\}+\max\{f_{r,0},f_{r,1}\}\)</span>。</li></ul><p>对于这棵树的根节点<span class="math inline">\(r\)</span>，最终答案为<span class="math inline">\(\max\{f_{r,0},f_{r,1}\}\)</span>。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dfs</span><span class="params">(TreeNode *r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r-&gt;left==<span class="literal">nullptr</span>&amp;&amp;r-&gt;right==<span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(r-&gt;left==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt;v=<span class="built_in">dfs</span>(r-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="built_in">max</span>(v[<span class="number">0</span>],v[<span class="number">1</span>]),<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(r-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt;v=<span class="built_in">dfs</span>(r-&gt;left);</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="built_in">max</span>(v[<span class="number">0</span>],v[<span class="number">1</span>]),<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vl=<span class="built_in">dfs</span>(r-&gt;left),vr=<span class="built_in">dfs</span>(r-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="built_in">max</span>(vl[<span class="number">0</span>],vl[<span class="number">1</span>])+<span class="built_in">max</span>(vr[<span class="number">0</span>],vr[<span class="number">1</span>]),vl[<span class="number">0</span>]+vr[<span class="number">0</span>]+<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;v=<span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="小红点菜">2、小红点菜</h1><p>小红来到了一家餐馆，准备点一些菜。</p><p>已知该餐馆有<span class="math inline">\(n\)</span>道菜，第<span class="math inline">\(i\)</span>道菜的售价为<span class="math inline">\(a_i\)</span>。</p><p>小红准备点一些价格相同的菜，但小红不会点单价超过<span class="math inline">\(m\)</span>的菜。</p><p>小红想知道，自己最多可以点多少道菜？</p><h2 id="输入">输入</h2><p>第一行输入两个正整数。</p><p><span class="math inline">\(n, m(1 \le n \le 10^6,1 \le m \le100)\)</span>，分别表示菜单上的菜品数量以及小红准备点的最大单价。</p><p>第二行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(w_1,w_2,\dots,w_n(1\lew_i\le100)\)</span>，分别表示每道菜的售价。</p><h2 id="输出">输出</h2><p>输出仅一行一个整数，表示小红最多可以点的菜的数量。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">9 6</span><br><span class="line">2 3 3 6 6 6 9 9 23</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">小红点单价6元的菜，共可以点3份菜。</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>只需要统计所有单价的出现次数，然后在不超过<span class="math inline">\(m\)</span>的单价中，取一个最大的出现次数即可。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">104</span>;</span><br><span class="line"><span class="type">int</span> c[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k,x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        ++c[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*<span class="built_in">max_element</span>(c+<span class="number">1</span>,c+k+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="牛牛的连通器">3、牛牛的连通器</h1><p>牛牛最近学习了连通器原理：<strong>在连通器中装有同种液体，当连通器中液体不流动时，各容器中液面总保持相平。</strong></p><p>牛牛有<span class="math inline">\(n\)</span>支<strong>规格相同</strong>的试管，这些试管中有一些底部是相互连通的。为了避免混淆试管之间的连通性，牛牛给每支试管做了标记，第<span class="math inline">\(i\)</span>支试管的标记为<span class="math inline">\(tab_i\)</span>。如果两支试管标记相同，那么它们就是联通的。</p><p>初始时，每支试管中都没有水，并且<strong>视试管的容积为无穷大</strong>，现在牛牛有三种操作：</p><ul><li><span class="math inline">\(1\ a\ b\)</span>: <span class="math inline">\(1\)</span>表示这是个注水操作，表示牛牛向第<span class="math inline">\(a\)</span>支试管中注入<span class="math inline">\(b\)</span>毫升水。</li><li><span class="math inline">\(2\ a\ b\)</span>：<span class="math inline">\(2\)</span>表示这是个抽水操作，表示牛牛从第<span class="math inline">\(a\)</span>支试管中抽出<span class="math inline">\(b\)</span>毫升水，该操作保证第<span class="math inline">\(a\)</span>支试管所在的连通器中至少有<span class="math inline">\(b\)</span>毫升水。</li><li><span class="math inline">\(3\ a\)</span>：<span class="math inline">\(3\)</span>表示这是个询问操作，牛牛想知道第<span class="math inline">\(a\)</span>支试管中有多水毫升水。</li></ul><p>他会进行<span class="math inline">\(m\)</span>个操作，你能帮牛牛完成这些操作吗？由于试管的规格相同，因此<strong>忽略掉底部连通部分的体积</strong>，我们可以进一步简化连通器原理：在连通器中装有同种液体，当连通器中液体不流动时，各容器中的液体体积相同。</p><h2 id="输入-1">输入</h2><p>第一行给出两个整数<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>，分别表示试管数量和操作数量。</p><p>第二行给出<span class="math inline">\(n\)</span>个整数，第<span class="math inline">\(i\)</span>个整数表示第<span class="math inline">\(i\)</span>试管的标签<span class="math inline">\(tab_i\)</span>。</p><p>接下来<span class="math inline">\(m\)</span>行，每行都是一个操作，其格式如题目所述。</p><ul><li><span class="math inline">\(1 \le n, m \le 10^5\)</span></li><li><span class="math inline">\(1 \le tab_i \le n\)</span></li><li><span class="math inline">\(1\le a\le n\)</span></li><li><span class="math inline">\(1\le b\le 10000\)</span></li></ul><h2 id="输出-1">输出</h2><p>对于每个<span class="math inline">\(3\)</span>操作，输出一个浮点数，表示询问的试管中水的体积。</p><p>假设正确答案为<span class="math inline">\(a\)</span>，你输出的答案为<span class="math inline">\(b\)</span>，当<span class="math inline">\(\dfrac{|a-b|}{\max(a,1)}&lt;10^{-5}\)</span>时视为答案正确。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5 6</span><br><span class="line">1 2 1 2 3</span><br><span class="line">1 1 5</span><br><span class="line">3 1</span><br><span class="line">1 2 7</span><br><span class="line">3 4</span><br><span class="line">2 4 4</span><br><span class="line">3 2</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2.500000</span><br><span class="line">3.500000</span><br><span class="line">1.500000</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">由tab值我们知道：第1支试管和第3支试管连通，第2支试管和第4支试管连通。第一个操作我们向第1支试管中注入5毫升水，根据连通器原理，最终第1支试管和第3支试管中的水是一样的，即5/2 = 2.5毫升。</span><br><span class="line">同理，第三个操作最终会使得第2支试管和第4支试管中的水都是7/2=3.5毫升。抽水操作也是相同的道理。</span><br><span class="line">需要注意的是，虽然直观地看第4支试管中此时只有3.5毫升水，但是第4支试管所在的整个连通器中有7毫升水，因此牛牛是可以抽取4毫升水的。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">6 8</span><br><span class="line">1 2 2 2 3 1</span><br><span class="line">1 3 10</span><br><span class="line">3 2</span><br><span class="line">2 3 2</span><br><span class="line">3 3</span><br><span class="line">1 1 9</span><br><span class="line">1 5 10</span><br><span class="line">3 5</span><br><span class="line">3 6</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">3.333333</span><br><span class="line">2.666667</span><br><span class="line">10.000000</span><br><span class="line">4.500000</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>本题直接模拟即可解决。我们只需要将所有试管的编号映射成连通器的编号后，再同一进行处理即可。对于每一次输出，相当于是输出水量和试管个数的比值。</p><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"><span class="type">int</span> sz[N],tg[N];</span><br><span class="line">ll s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,o,a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;tg[i]);</span><br><span class="line">        ++sz[tg[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;o,&amp;a);</span><br><span class="line">        <span class="keyword">if</span>(o&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b);</span><br><span class="line">            s[tg[a]]+=(o==<span class="number">1</span>?b:-b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            a=tg[a];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.10f\n&quot;</span>,<span class="number">1.0</span>*s[a]/sz[a]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>百度 秋招 2023.10.17 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Baidu-20231017/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Baidu-20231017/</id>
    <published>2023-10-18T06:42:00.000Z</published>
    <updated>2023-10-18T06:42:00.399Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="小红的数字">1、小红的数字</h1><p>小红想知道在区间<span class="math inline">\([l,r]\)</span>内，有多少个数是<span class="math inline">\(a\)</span>的倍数，或者是<span class="math inline">\(b\)</span>的倍数，或者是<span class="math inline">\(c\)</span>的倍数。</p><h2 id="输入">输入</h2><p>第一行输入一个整数<span class="math inline">\(T\)</span>，表示数据组数。</p><p>接下来<span class="math inline">\(T\)</span>行，每行输入五个整数<span class="math inline">\(a, b, c\)</span>和<span class="math inline">\(l,r\)</span>，表示<span class="math inline">\(a, b, c\)</span>和<span class="math inline">\(l, r\)</span> 的值。</p><ul><li><span class="math inline">\(1 \leq T \leq 10^5\)</span></li><li><span class="math inline">\(1 \leq a, b, c \leq 10^9\)</span></li><li><span class="math inline">\(1 \leq l \leq r \leq 10^9\)</span></li></ul><h2 id="输出">输出</h2><p>输出<span class="math inline">\(T\)</span>行，每行输出一个整数，表示答案。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">1</span><br><span class="line">2 3 4 1 10</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">[1, 10] 内有 2, 3, 4, 6, 8, 9, 10 这七个数是 2 的倍数，或者是 3 的倍数，或者是 4 的倍数。</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>为了方便，我们先求出<span class="math inline">\(r\)</span>以内满足条件的数有多少个，再求出<span class="math inline">\(l-1\)</span>以内满足条件的数有多少个，再用前者减去后者就可以得到原问题的答案。</p><p>因此，接下来问题转化成了求<span class="math inline">\(n\)</span>以内满足条件的数有多少个。这个问题Leetcode1201的子问题。</p><p>我们可以使用容斥原理进行求解。不考虑其它，<span class="math inline">\(n\)</span>以内一共有<span class="math inline">\(\lfloor n/a\rfloor\)</span>个数是<span class="math inline">\(a\)</span>的倍数，那么不考虑重复计算的话，这个问题的答案为<span class="math inline">\(\lfloor n/a\rfloor+\lfloor n/b\rfloor+\lfloorn/c\rfloor\)</span>。一些数如果既是<span class="math inline">\(a\)</span>的倍数，又是<span class="math inline">\(b\)</span>的倍数，那么它是<span class="math inline">\(\text{lcm}(a,b)\)</span>的倍数，其中<span class="math inline">\(\text{lcm}\)</span>是最小公倍数，我们需要将这些算重复的减回去。但是如果一个数同时是<span class="math inline">\(a,b,c\)</span>的倍数，那么这些数也被重复减去了，需要加回来。因此，这道题使用容斥原理后，其答案为：</p><p><span class="math display">\[\lfloor n/a\rfloor+\lfloorn/b\rfloor+\lfloor n/c\rfloor-\lfloor n/\text{lcm}(a,b)\rfloor-\lfloorn/\text{lcm}(b,c)\rfloor-\lfloor n/\text{lcm}(c,a)\rfloor+\lfloorn/\text{lcm}(a,b,c)\rfloor\]</span></p><p>求解<span class="math inline">\(\text{lcm}\)</span>只需要使用欧几里得算法即可，另外由于最小公倍数满足结合性，因此可以通过递推的方式求解最小公倍数。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> lcm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">a, b, c, n</span>):</span><br><span class="line">    z = [a, b, c]</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">8</span>):</span><br><span class="line">        l = lcm(*[z[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>) <span class="keyword">if</span> s &gt;&gt; i &amp; <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">bin</span>(s).count(<span class="string">&#x27;1&#x27;</span>) &amp; <span class="number">1</span>:</span><br><span class="line">            ans += n // l</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ans -= n // l</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">    a, b, c, l, r = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    <span class="built_in">print</span>(solve(a, b, c, r) - solve(a, b, c, l - <span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小红的连续自然数乘积">2、小红的连续自然数乘积</h1><p>小红想在<span class="math inline">\([1,n]\)</span>取一些连续的正整数，使得它们的乘积最多有<span class="math inline">\(k\)</span>个不同的素因子。小红想知道，自己最多可以取多少个正整数？</p><p>所谓连续，指取的这些正整数不能重复，且相邻两个的差为<span class="math inline">\(1\)</span>。例如<span class="math inline">\([2,3,4,5],[5,6,7]\)</span>都是连续的取数。</p><p>所谓素因子：对于一个数<span class="math inline">\(n\)</span>来说，将它的因子拆到若干个素数相乘，这些素数被称为<span class="math inline">\(n\)</span>的素因子。</p><h2 id="输入-1">输入</h2><p>两个正整数<span class="math inline">\(n\)</span>和<span class="math inline">\(k\)</span>，用空格隔开。</p><ul><li><span class="math inline">\(1\le k\le n\le 10^5\)</span></li></ul><h2 id="输出-1">输出</h2><p>一个整数，代表小红可以取的连续正整数最大值。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">10 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">选择1到6，乘积是720，有3个不同的素因子（2，3，5）。</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>我们首先可以使用筛法，将每个数的所有质因子求出来。</p><p>先以某个数<span class="math inline">\(l\)</span>为起点，逐渐乘上<span class="math inline">\(l+1,l+2,\dots,\)</span>可以发现它的质因子个数不断增长，最终质因子个数超过<span class="math inline">\(k\)</span>后，这时这个数不再是我们所求的值。假设乘上某个数<span class="math inline">\(r\)</span>后，这个数立刻不符合要求，那么这时<span class="math inline">\(r\)</span>是这个极限，这时我们一共取到了<span class="math inline">\(r-l\)</span>个数。随着起点右移，这个极限点也是非递减的。</p><p>因此，我们可以使用双指针法完成这个过程，用一个数组来维护所有质因数出现的情况，以及用一个变量维护质因子的数量即可。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;d[N];</span><br><span class="line"><span class="type">int</span> cnt[N],tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> o)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(o==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(++cnt[x]==<span class="number">1</span>) ++tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(--cnt[x]==<span class="number">0</span>) --tot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(d[i].<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j+=i)&#123;</span><br><span class="line">                d[j].<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">1</span>;l&lt;=n;l++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(;r&lt;=n&amp;&amp;tot&lt;=k;r++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> x:d[r]) <span class="built_in">add</span>(x,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tot&gt;k)&#123;</span><br><span class="line">            --r;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> x:d[r]) <span class="built_in">add</span>(x,<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,r-l);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x:d[l]) <span class="built_in">add</span>(x,<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小红的字符串构造easy">3、小红的字符串构造（easy）</h1><p>小红拿到了两个长度为<span class="math inline">\(n\)</span>的字符串<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>，她希望你构造一个新的字符串<span class="math inline">\(c\)</span>，要求<span class="math inline">\(c\)</span>的每个字符<span class="math inline">\(c_i\)</span>是<span class="math inline">\(a_i\)</span>和<span class="math inline">\(b_i\)</span>二选一生成。</p><p>小红希望最终字符串<span class="math inline">\(c\)</span>的每一种字符都恰好出现了<span class="math inline">\(1\)</span>次。你能帮帮她吗？</p><h2 id="输入-2">输入</h2><p>第一行输入一个正整数<span class="math inline">\(n\)</span>，代表两个字符串的长度。</p><p>第二行输入字符串<span class="math inline">\(a\)</span>。</p><p>第三行输入字符串<span class="math inline">\(b\)</span>。</p><ul><li><span class="math inline">\(1\leq n \leq 10^5\)</span></li><li>字符串保证仅包含大写和小写字母。</li></ul><h2 id="输出-2">输出</h2><p>如果无解，请输出<span class="math inline">\(-1\)</span>。</p><p>否则输出一个合法的字符串。有多解时输出任意即可。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">6</span><br><span class="line">abcdef</span><br><span class="line">fedcba</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">abdcef</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">输出fbdcea等字符串也是合法的。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">abB</span><br><span class="line">bBA</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">aBA</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>可以发现，字符串的长度<span class="math inline">\(n\)</span>最多不会超过<span class="math inline">\(52\)</span>，因为字符串<span class="math inline">\(c\)</span>只有可能包含小写字母和大写字母。因此，当<span class="math inline">\(n&gt;52\)</span>时是无解的。</p><p>进行判断完后，可以发现这是一道明显的2-SAT问题，因为每个位置<span class="math inline">\(i\)</span>都有两种选择：要么选择<span class="math inline">\(a_i\)</span>，要么选择<span class="math inline">\(b_i\)</span>。不失一般性，假设存在一对<span class="math inline">\((i,j)\)</span>使得<span class="math inline">\(a_i=b_j\)</span>，那么如果位置<span class="math inline">\(i\)</span>选择了<span class="math inline">\(a_i\)</span>，那么位置<span class="math inline">\(j\)</span>就必须选择<span class="math inline">\(a_j\)</span>，这对于其它情况类似。</p><p>也就是说，其中一个位置的选择会影响到另外一个位置的选择。我们为每个位置和每个选择作为一个节点，并且将上面的抉择关系建立成一个图<span class="math inline">\(G=(V,E)\)</span>。对于一对<span class="math inline">\(i,j(i\neq j)\)</span>，如果<span class="math inline">\(a_i=b_j\)</span>，并且位置<span class="math inline">\(i\)</span>已经选择来自<span class="math inline">\(a\)</span>，那么位置<span class="math inline">\(j\)</span>也必须来自<span class="math inline">\(a\)</span>，从而得到一条边<span class="math inline">\((i_a,j_a)\in E\)</span>。</p><p>最终，对于同一个位置的两个选择，如果发现它们是相互依赖的，即如果位置<span class="math inline">\(i\)</span>选择了<span class="math inline">\(a\)</span>，那么位置<span class="math inline">\(i\)</span>就要选择<span class="math inline">\(b\)</span>，并且反之亦然（也就是说<span class="math inline">\(i_a,j_a\)</span>相互可达），那么这很明显是矛盾的，无解。至于具体实现，我们可以使用tarjan算法求出每个图的强连通分量，并判断是否存在一个位置的两个选择在同一强连通分类即可。</p><p>接下来考虑构造一个有效方案。我们使用tarjan算法求出了原图中每个图的强连通分量，并为它们进行编号。下面实现的tarjan算法中，它是自底向上进行编号的。假设选择<span class="math inline">\(i_a,i_b\)</span>所在强连通分量的编号为<span class="math inline">\(t_{i,a},t_{i,b}\)</span>。不失一般性，假设<span class="math inline">\(t_{i,a}&lt;t_{i,b}\)</span>，也就是说<span class="math inline">\(i_a\)</span>所在的强连通分量先生成，<span class="math inline">\(i_b\)</span>的强连通分量后生成，那么只会有两种情况：</p><ol type="1"><li><span class="math inline">\(i_a,i_b\)</span>相互不可达，此时选择哪一个决策都没有问题。</li><li><span class="math inline">\(i_b\)</span>可达<span class="math inline">\(i_a\)</span>，这时只需要选择<span class="math inline">\(i_a\)</span>就不会产生任何问题。</li></ol><p>总而言之，基于这个tarjan算法实现的性质，我们只需要选择强连通分量编号比较小的选项即可。</p><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">104</span>;</span><br><span class="line">string s[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> t[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;g[N];</span><br><span class="line"><span class="type">int</span> dfn[N],low[N],idx=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> col[N],c=<span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> ins[N];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt;st;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++idx;</span><br><span class="line">    st.<span class="built_in">push</span>(u);ins[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dfn[v]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v);</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ins[v])&#123;</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])&#123;</span><br><span class="line">        ++c;<span class="type">int</span> x;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            x=st.<span class="built_in">top</span>();st.<span class="built_in">pop</span>();</span><br><span class="line">            ins[x]=<span class="number">0</span>;col[x]=c;</span><br><span class="line">        &#125;<span class="keyword">while</span>(x!=u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">52</span>) <span class="keyword">return</span> <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[<span class="number">0</span>][i]==s[<span class="number">0</span>][j]) g[i].<span class="built_in">push_back</span>(j+n);</span><br><span class="line">            <span class="keyword">if</span>(s[<span class="number">0</span>][i]==s[<span class="number">1</span>][j]) g[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">            <span class="keyword">if</span>(s[<span class="number">1</span>][i]==s[<span class="number">0</span>][j]) g[i+n].<span class="built_in">push_back</span>(j+n);</span><br><span class="line">            <span class="keyword">if</span>(s[<span class="number">1</span>][i]==s[<span class="number">1</span>][j]) g[i+n].<span class="built_in">push_back</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n+n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>][i]!=s[<span class="number">1</span>][i]&amp;&amp;col[i]==col[n+i]) <span class="keyword">return</span> <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>][i]==s[<span class="number">1</span>][i]) t[i]=s[<span class="number">0</span>][i];</span><br><span class="line">        <span class="keyword">else</span> t[i]=s[col[i]&gt;col[n+i]][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(t,t+n);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s[<span class="number">0</span>]&gt;&gt;s[<span class="number">1</span>];</span><br><span class="line">    cout&lt;&lt;<span class="built_in">solve</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>网易 秋招 2023.10.15 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Wangyi-20231015/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Wangyi-20231015/</id>
    <published>2023-10-15T05:44:35.000Z</published>
    <updated>2023-10-15T05:44:35.411Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="小红的字符串变换easy">1、小红的字符串变换（easy）</h1><p>小红有一个字符串<span class="math inline">\(s\)</span>，她想把<span class="math inline">\(s\)</span>变成<span class="math inline">\(t\)</span>。</p><p>小红可以进行操作：选择两种不同的字母，然后将在<span class="math inline">\(s\)</span>中的这两种字母按任意顺序排列。</p><p>小红想知道她是否可以恰好操作一次将<span class="math inline">\(s\)</span>变成<span class="math inline">\(t\)</span>。</p><h2 id="输入">输入</h2><p>第一行输入一个字符串<span class="math inline">\(s\)</span>。</p><p>第二行输入一个字符串<span class="math inline">\(t\)</span>。</p><p><span class="math inline">\(s\)</span>和<span class="math inline">\(t\)</span>长度相等，且都不超过<span class="math inline">\(10^6\)</span>。</p><h2 id="输出">输出</h2><p>若小红可以恰好操作一次将<span class="math inline">\(s\)</span>变成<span class="math inline">\(t\)</span>，则输出<code>"YES"</code>，再输出选择的两种字母，否则输出<code>"NO"</code>。</p><p>如果有多种方案，请输出字典序最小的方案（第一种字母 ASCII码值尽可能小，若第一种字母 ASCII 码值相同，则第二种字母 ASCII码值尽可能小）。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">abab</span><br><span class="line">abba</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">YES</span><br><span class="line">a b</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">选择字母 &#x27;a&#x27; 、 &#x27;b&#x27; ，即可使 &quot;abab&quot; 变成 &quot;abba&quot;</span><br><span class="line">选择字母 &#x27;b&#x27; 、 &#x27;a&#x27; 也是答案，但此方案的字典序较大。</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>对于任意一个下标<span class="math inline">\(i\)</span>，如果<span class="math inline">\(s_i\neqt_i\)</span>，那么我们只能选择这一对字符<span class="math inline">\((s_i,t_i)\)</span>进行操作，如果只使用这一对字符进行操作仍然无法完成<span class="math inline">\(s=t\)</span>的目的，那么说明肯定还存在另一对和<span class="math inline">\((s_i,t_i)\)</span>不相同的字符串需要操作，这时肯定是无解的。如果能够达到<span class="math inline">\(s=t\)</span>的目的，那么<span class="math inline">\((s_i,t_i)\)</span>就是唯一解。</p><p>如果有多个解，那么唯有<span class="math inline">\(s=t\)</span>才可以做到。此时最小字典序的解为<span class="math inline">\((\texttt{a,b})\)</span>。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">s, t</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    v = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> s[i] != t[i]:</span><br><span class="line">            v = <span class="built_in">sorted</span>([s[i], t[i]])</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> v:</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">    s0 = <span class="built_in">set</span>(i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n) <span class="keyword">if</span> s[i] == v[<span class="number">0</span>])</span><br><span class="line">    s1 = <span class="built_in">set</span>(i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n) <span class="keyword">if</span> s[i] == v[<span class="number">1</span>])</span><br><span class="line">    t0 = <span class="built_in">set</span>(i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n) <span class="keyword">if</span> t[i] == v[<span class="number">0</span>])</span><br><span class="line">    t1 = <span class="built_in">set</span>(i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n) <span class="keyword">if</span> t[i] == v[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s0) == <span class="built_in">len</span>(t0) <span class="keyword">and</span> <span class="built_in">len</span>(s1) == <span class="built_in">len</span>(t1) <span class="keyword">and</span> (s0 | s1) == (t0 | t1):</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ans = solve(<span class="built_in">input</span>(), <span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">if</span> ans:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;YES\n&#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(ans[<span class="number">0</span>], ans[<span class="number">1</span>]))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;NO&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小红的树上染色">2、小红的树上染色</h1><p>小红有一棵<span class="math inline">\(n\)</span>个点的树，<span class="math inline">\(1\)</span>号点是根结点。树上的一些边需要被染色，小红每次可以选择一个点，将这个点到根结点的所有边染成红色。小红想知道，最少需要多少次操作，才能使得树上所有的边都被染成红色。</p><p>必须把所有需要染红的边染红，可以把一条边染色多次，也可以把不需要染色的边染成红色。</p><h2 id="输入-1">输入</h2><p>第一行一个整数<span class="math inline">\(n\)</span>，表示树上点的个数。</p><p>接下来<span class="math inline">\(n-1\)</span>行，每行三个整数<span class="math inline">\(u,v,c\)</span>，表示<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>之间有一条边，如果<span class="math inline">\(c=1\)</span>，表示这条边需要被染色，否则表示这条边可以不被染色。</p><ul><li><span class="math inline">\(2 \leq n \leq 10^5\)</span></li><li><span class="math inline">\(1 \leq u, v \leq n\)</span></li></ul><h2 id="输出-1">输出</h2><p>输出一个整数，表示最少需要的操作次数。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">1 2 1</span><br><span class="line">1 3 0</span><br><span class="line">2 4 1</span><br><span class="line">2 5 0</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">选择 4 号结点，把 (1, 2)，(2, 4) 染红。</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>基于贪心的思想，我们应该尽量选择深度足够深的节点进行染色。为了使得染色节点尽可能少，怎么做出这个选择呢？</p><p>如果一个节点<span class="math inline">\(u\)</span>连向它的父节点这条边必须被染色，但是<span class="math inline">\(u\)</span>的子树中，没有需要被染色的边，那么我们可以选择<span class="math inline">\(u\)</span>，这样子将使得<span class="math inline">\(u\)</span>到根中的所有边都会被进行染色。此外，选择<span class="math inline">\(u\)</span>的后代是没有必要的，因为选择它们的效果和选择<span class="math inline">\(u\)</span>相同。</p><p>由此我们只需要统计选择必须被选择的节点<span class="math inline">\(u\)</span>即可。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> pi pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;pi&gt;g[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [v,w]:g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> c=<span class="built_in">dfs</span>(v,u);</span><br><span class="line">        <span class="keyword">if</span>(w&amp;&amp;c==<span class="number">0</span>) ++ans;</span><br><span class="line">        cnt+=w+c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v,w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(<span class="built_in">pi</span>(v,w));</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(<span class="built_in">pi</span>(u,w));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小红的mex查询">3、小红的mex查询</h1><p>小红拿到了一个空集。她准备进行以下操作：将<span class="math inline">\([l,r]\)</span>区间的每个整数添加进集合。</p><p>请你在每次操作后，输出当前集合的<span class="math inline">\(\text{mex}\)</span>。我们定义，集合的<span class="math inline">\(\text{mex}\)</span>为：集合中最小的未出现的非负整数。</p><h2 id="输入-2">输入</h2><p>第一行输入一个正整数<span class="math inline">\(q\)</span>，代表操作次数。 接下来的<span class="math inline">\(q\)</span>行，每行输入两个正整数<span class="math inline">\(l,r\)</span>，代表一次操作。</p><ul><li><span class="math inline">\(1\leq q \leq 10^5\)</span></li><li><span class="math inline">\(1\leq l \leq r \leq 10^9\)</span></li></ul><h2 id="输出-2">输出</h2><p>输出<span class="math inline">\(q\)</span>行，每行输入一个整数，代表当前的集合<span class="math inline">\(\text{mex}\)</span>。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">4</span><br><span class="line">1 3</span><br><span class="line">7 8</span><br><span class="line">0 5</span><br><span class="line">3 6</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">6</span><br><span class="line">9</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">第一次操作后，集合为[1,2,3]，mex 为 0。</span><br><span class="line">第二次操作后，集合为[1,2,3,7,8]，mex 仍然是 0。</span><br><span class="line">第三次操作后，集合为[0,1,2,3,4,5,7,8]，mex 为 6。</span><br><span class="line">第四次操作后，集合为[0,1,2,3,4,5,6,7,8]，mex 为 9。</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>令第<span class="math inline">\(i\)</span>次操作表示为区间<span class="math inline">\([l_i,r_i]\)</span>。按照<span class="math inline">\(\text{mex}\)</span>的覆盖性质可以发现，一个候选的<span class="math inline">\(\text{mex}\)</span>值必定为集合<span class="math inline">\(U=\{r_i+1\midi\in[1,n]\}\cup\{0\}\)</span>，因为对于一个数<span class="math inline">\(k\)</span>，如果不存在<span class="math inline">\(i\)</span>使得<span class="math inline">\(r_i+1=k\)</span>，那么有两种情况：</p><ul><li><span class="math inline">\(k\)</span>不被任何一个区间所覆盖，但是<span class="math inline">\(k-1\)</span>也将不会被任何一个区间所覆盖。因此<span class="math inline">\(k\)</span>必定不是一个<span class="math inline">\(\text{mex}\)</span>值。</li><li><span class="math inline">\(k\)</span>被任何一个区间所覆盖，因此<span class="math inline">\(k\)</span>必定不是一个<span class="math inline">\(\text{mex}\)</span>值。</li></ul><p>因此，每对一个区间<span class="math inline">\([l_i,r_i]\)</span>进行操作后，将原本集合<span class="math inline">\(U\)</span>中区间<span class="math inline">\([l_i,r_i]\)</span>内的所有元素删除即可。最终输出<span class="math inline">\(S\)</span>中的最小值即可。</p><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l[N],r[N],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt;st&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;l[i],&amp;r[i]);++r[i];</span><br><span class="line">        st.<span class="built_in">insert</span>(r[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">auto</span> it=st.<span class="built_in">lower_bound</span>(l[i]);</span><br><span class="line">            <span class="keyword">if</span>(it==st.<span class="built_in">end</span>()||*it&gt;=r[i]) <span class="keyword">break</span>;</span><br><span class="line">            st.<span class="built_in">erase</span>(it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*st.<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小红的字符串回文值">4、小红的字符串回文值</h1><p>小红有一个字符串<span class="math inline">\(s\)</span>，她想知道这个字符串中字典序最大的后缀、字典序最小的后缀的回文值分别是多少。</p><p>字符串的回文值定义为：字符串的最长回文子串长度。</p><h2 id="输入-3">输入</h2><p>第一行输入一个字符串，字符串长度不超过<span class="math inline">\(2\times 10^5\)</span>。</p><h2 id="输出-3">输出</h2><p>输出两个整数表示答案。</p><h2 id="样例-3">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">abc</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1 1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">字典序最大的后缀为&quot;c&quot;，回文值为1</span><br><span class="line">字典序最小的后缀为&quot;abc&quot;，回文值为1</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">ababa</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">3 1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">字典序最大的后缀为&quot;baba&quot;，回文值为3（最大回文子串为 &quot;bab&quot; 或 &quot;aba&quot; ）</span><br><span class="line">字典序最小的后缀为&quot;a&quot;，回文值为1</span><br></pre></td></tr></table></figure><h2 id="解答-3">解答</h2><p>本题将分为两个部分进行求解。</p><p>第一部分是找到两个字典序最大和最小的后缀。这题可以直接使用后缀数组进行解决，不过这不在考察范围内。对于一对后缀<span class="math inline">\((i,j)\)</span>，我们可以使用字符串哈希，通过二分找到最小的正整数<span class="math inline">\(l\)</span>使得<span class="math inline">\(s_{i+l-1}\neq s_{j+l-1}\)</span>，并比较<span class="math inline">\(s_{i+l-1}\)</span>和<span class="math inline">\(s_{j+l-1}\)</span>的顺序，从而比较出这两个后缀的字典序大小。如果不存在<span class="math inline">\(l\)</span>，那么说明<span class="math inline">\(i,j\)</span>中其中一个是另一个的前缀，因此长度较小的那个后缀字典序比较小。</p><p>最终通过哈希算法求解字典序最大和最小的后缀。</p><p>第二部分是找到一个字符串的最长回文字符串长度，这个问题可以使用Manachar算法直接解决。也可以使用二分法和哈希法完成，具体做法是预处理出这个字符串的前缀哈希值和后缀哈希值，使用中心扩展法进行二分即可。</p><h2 id="代码-3">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200004</span>;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">ull pw[N],hs[N],B=<span class="number">131</span>;</span><br><span class="line"><span class="function">ull <span class="title">geths</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hs[r]-hs[l<span class="number">-1</span>]*pw[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lt</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m=n-y+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">geths</span>(x,x+mid<span class="number">-1</span>)!=<span class="built_in">geths</span>(y,y+mid<span class="number">-1</span>)) r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l==m+<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> s[x+l<span class="number">-1</span>]&lt;s[y+l<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(string t)</span></span>&#123;</span><br><span class="line">    string s=<span class="string">&quot;#&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> ch:t)&#123;</span><br><span class="line">        s+=ch;s+=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">d</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,l=<span class="number">0</span>,r=<span class="number">-1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> k=(i&gt;r?<span class="number">1</span>:<span class="built_in">min</span>(d[l+r-i],r-i+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(;<span class="number">0</span>&lt;=i-k&amp;&amp;i+k&lt;n&amp;&amp;s[i-k]==s[i+k];k++);</span><br><span class="line">        d[i]=k--;</span><br><span class="line">        <span class="keyword">if</span>(i+k&gt;r)&#123;</span><br><span class="line">            l=i-k;</span><br><span class="line">            r=i+k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k=*<span class="built_in">max_element</span>(d.<span class="built_in">begin</span>(),d.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> k<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    pw[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        pw[i]=pw[i<span class="number">-1</span>]*B;</span><br><span class="line">        hs[i]=hs[i<span class="number">-1</span>]*B+s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mx=<span class="number">1</span>,mn=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">lt</span>(mn,i)) mn=i;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">lt</span>(mx,i)) mx=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,<span class="built_in">solve</span>(<span class="built_in">string</span>(s+mx,s+n+<span class="number">1</span>)),<span class="built_in">solve</span>(<span class="built_in">string</span>(s+mn,s+n+<span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>华为 秋招 2023.10.11 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Huawei-20231011/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Huawei-20231011/</id>
    <published>2023-10-12T16:41:00.000Z</published>
    <updated>2023-11-11T07:03:05.945Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="计算最少流控请求数">1、计算最少流控请求数</h1><p>服务器性能有限，对于突发请求，有时需要通过流控保护系统不受冲击。假设某服务器的系统要求任意<span class="math inline">\(M\)</span>分钟内只能处理<span class="math inline">\(N\)</span>条请求，超出的请求必须流控掉。已知连续<span class="math inline">\(X\)</span>分钟，每分钟的实际请求数，请给出至少流控掉多少请求，才能保证上述系统不受冲击。</p><h2 id="输入">输入</h2><p>第一行：<span class="math inline">\(M\)</span>和<span class="math inline">\(N\)</span>，<span class="math inline">\(M\)</span>范围<span class="math inline">\([1,10]\)</span>；<span class="math inline">\(N\)</span>的范围<span class="math inline">\([0,10000]\)</span></p><p>第二行：连续分钟数<span class="math inline">\(X\)</span>，<span class="math inline">\(X\)</span>范围为<span class="math inline">\([1,100000]\)</span></p><p>第三行：每分钟的请求数范围<span class="math inline">\([0,1000]\)</span></p><h2 id="输出">输出</h2><p>最少可以流控的请求数。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">4 6</span><br><span class="line">6</span><br><span class="line">2 1 2 2 3 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">第一行系统要求：每4分钟只能接受6个请求。</span><br><span class="line">第二行：连续6分钟。</span><br><span class="line">第三行：每分钟的实际请求数。</span><br><span class="line">至少流控3个请求(可以是： 第4分钟流控1个请求，第5分钟流控1个请求，第6分钟流控1个请求)，才可以满足系统4分钟内只能处理6条请求的要求。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">2 10</span><br><span class="line">6</span><br><span class="line">1 9 1 9 8 2</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">第一行系统要求：每2分钟只能接受10个请求</span><br><span class="line">第二行：连续6分钟。</span><br><span class="line">第三行：每分钟的实际请求数。</span><br><span class="line">至少流控7个请求(可以是第5分钟流控7个请求)，才可以满足系统2分钟内只能外理10条请求的要求。</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>这题可以使用贪心轻易解决。从小到大枚举每个长度为<span class="math inline">\(m\)</span>的区间，如果当前确实必须要流控一些请求，那么按照贪心的思想，应该优先流控掉这些请求，这确保了后面的请求能过尽量少流控一些。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"><span class="type">int</span> a[N],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n,x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;m,&amp;n,&amp;x);</span><br><span class="line">    m=<span class="built_in">min</span>(m,x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x;i++)</span><br><span class="line">        sum+=a[i];</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">        s+=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m;i&lt;=x;i++)&#123;</span><br><span class="line">        s+=a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&gt;=i-m+<span class="number">1</span>&amp;&amp;s&gt;n;j--)&#123;</span><br><span class="line">            <span class="type">int</span> v=<span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">min</span>(s-n,a[j]));</span><br><span class="line">            a[j]-=v;s-=v;</span><br><span class="line">        &#125;</span><br><span class="line">        s-=a[i-m+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sum2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x;i++)sum2+=a[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum-sum2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="快乐时间">2、快乐时间</h1><p>小明在工作之余喜欢在电子书城阅读不同的书籍并且获得最大的满足感，因此根据书城针对每本书籍的评分收集了<span class="math inline">\(n\)</span>个书籍的打分清单<code>books</code>，例如第一本书的打分<code>books[0]=5</code>代表该书的满意程度为<span class="math inline">\(5\)</span>，第二本书<code>books[1]=-2</code>代表该书的满意程度为<span class="math inline">\(-2\)</span>。</p><p>阅读每本书花费的都是<span class="math inline">\(1\)</span>单位时间，<code>time</code>定义为阅读本书及之前所有书的时间之和。因此第一本阅读的书籍<code>time[0]=1</code>，第二本阅读的书籍<code>time[1]=2</code>，第三本阅读的书籍<code>time[2]=3</code>并以此类推。</p><p>每本书籍的【快乐时间】系数为阅读该书籍和之前每本书籍所花费的时间乘以对这本书籍的满意程度，即<code>time[i] * books[i]</code>，其中<span class="math inline">\(i\)</span>从<span class="math inline">\(0\)</span>开始。</p><p>小明想了解自己如何安排阅读计划才能获得最大的快乐时间，请帮忙计算一下阅读给定书籍【快乐时间】总和最大的值是多少，可以按照任意顺序调整阅读书籍顺序（即每本书对应的<code>time[i]</code>是可以对调的），也可以放弃阅读某些书籍。</p><h2 id="输入-1">输入</h2><p>输入为字符串，字符串内容为代表每本书籍的喜爱指数，例如<code>books = [4,3,2]</code>，其中<span class="math inline">\(1\le n\le -500\)</span>，满意程度 <span class="math inline">\(-1000 \le \texttt{books[i]}\le-1000\)</span>。</p><h2 id="输出-1">输出</h2><p>输出为数字，代表最大的快乐时间，例如<span class="math inline">\(20\)</span>，按照原来顺序相反的时间阅读书籍<span class="math inline">\((2\times 1 + 3\times2 + 4\times3 =20)\)</span>，评分越高的书籍越后面阅读可以获得最大的快乐时间。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">4,3,2</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">20</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">按照原来顺序相反的时间阅读书籍(2 * 1 + 3 * 2 + 4 * 3 = 20)，评分越高的书籍越后面阅读可以获得最大的快乐时间。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">-1,-4,-5</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">大家对于这些书籍评分都很低，所以不阅读任何书籍可以获得最大的快乐时间。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">-1,-8,0,5,-9</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">14</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">去掉第二个和最后一本书籍，最大的快乐时间系数和为(-1 * 1 + 0 * 2 + 5 * 3 = 14)。每本书籍都需要花费1单位时间来阅读。</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>这题是一道经典的贪心题。由于快乐值前面的系数<code>time[i]</code>都是非负整数，因此如果需要不选择一些书，那么优先去掉满意度最小的那些书。那么问题转化为最大值<span class="math inline">\(s=\displaystyle{\sum_{i=1}^m i\cdota_i}\)</span>，其中<span class="math inline">\(a_i\)</span>是被选定书籍的评分。可以发现，当我们<span class="math inline">\(a_i\)</span>是不下降的时候，<span class="math inline">\(s\)</span>值能过取得最大，因为如果存在一对<span class="math inline">\(a_j,a_i(j&lt;i)\)</span>使得<span class="math inline">\(a_j&gt;a_i\)</span>，交换它们会使得答案更优。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"><span class="type">int</span> a[N],n=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> &amp;ch:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isdigit</span>(ch)&amp;&amp;ch!=<span class="string">&#x27;-&#x27;</span>) ch=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    ss&lt;&lt;s;</span><br><span class="line">    <span class="keyword">while</span>(ss&gt;&gt;s)&#123;</span><br><span class="line">        a[++n]=<span class="built_in">atoi</span>(s.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="type">int</span> s1=<span class="number">0</span>,s2=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        s1+=a[i];</span><br><span class="line">        s2+=s1;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,s2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="稀疏存储">3、稀疏存储</h1><p>在虚拟化技术、芯片仿真器等领域，存在一种场景，即实际读写的数据量比较小，但要求可访问的地址空间却很大(要求4GB、甚至128GB地址空间)。</p><p>实现一个地址范围为32G的，可在该地址范围内任意位置读写数据的虚拟化内存机制(数据默认清零)。</p><p>对应功能：</p><ol type="1"><li>读取任意地址数据；</li><li>往任意地址写入任意数据；</li><li>清空数据，并释放内存。</li></ol><p>输入格式： <code>Command Address Length Data</code></p><p>提示：</p><ol type="1"><li><code>Command</code>为<code>Read</code>、<code>Write</code>、<code>Clear</code>之一；</li><li><code>Address</code>采用64位无符号十六进制数，全大写；</li><li><code>Length</code>采用64位无符号十进制数，单位为“字节”；</li><li><code>Data</code>采用字节流(2个16进制数表示一个<code>Byte</code>)，全大写；</li><li>如果指定的<code>Length</code>大于实际给定的<code>Data</code>，需要程序自行未尾补0，小于则未尾截断。</li></ol><h2 id="输入-2">输入</h2><p>每条指令一行，一个用例输入可以是多条指令混合，只有<code>Read</code>指令有输出。</p><p>每个用例保证指令、参数格式正确，但不保证参数范围，需要程序按照题目规格要求自行校验，参数不合法，则对应的指令无效。</p><p>每个用例保证需要存储的总数据量最大不超过<code>16MB</code>。一个用例最多不超过<span class="math inline">\(500\)</span>条指令。</p><p>例如（3表示有3条指令）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">Write 0x100 7 001122AA</span><br><span class="line">Read 0x100 4</span><br><span class="line">Clear</span><br></pre></td></tr></table></figure><h2 id="输出-2">输出</h2><p>采用字节流 (2个16进制数表示一个<code>Byte</code>)，全大写。</p><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">001122AA</span><br></pre></td></tr></table></figure><p>每条<code>Read</code>指令对应一行输出数据，如果指令给的参数不合法，对应的输出为空（不换行）。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">1</span><br><span class="line">Read 0x100 4</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">00000000</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0x100地址空间未被写入数据，默认返回全0，一共4个字节。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">Write 0x100 8 00001122AABBCCDD</span><br><span class="line">Read 0x100 12</span><br><span class="line">Clear</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">00001122AABBCCDD00000000</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0x100地址，前8个字节被写入了有效数据00001122AABBCCDD，读取0x100地址12个字节数据，后4个字节补齐默认数据0，因此结果为00001122AABBCCDDO0000000。</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>这题的地址值上限为32G，即地址范围是<span class="math inline">\(0\sim2^{35}-1\)</span>，令<span class="math inline">\(M=2^{35}\)</span>。</p><p>为了方便操作，这里直接使用一个字典来存储对应位置的字节值（由于存储的数据量不超过16MB，因此字典最多只有<span class="math inline">\(2^{24}\)</span>个项，在接受范围之内），每次进行<code>Clear</code>操作就清空字典，执行<code>Write</code>操作时，将每个字节对应的位置直接写入即可；在进行<code>Read</code>操作时，直接从字典中取值，如果取不到，那么用<code>00</code>字节替代。</p><p>以下是本代码校验时需要注意的地方：</p><ul><li><code>Write</code>操作时，需要注意给定字节串的长度是否为偶数。</li><li><code>Write</code>操作和<code>Read</code>操作时，需要判断地址是否产生溢出，以及输入的长度<code>Length</code>是否是一个非负整数。</li><li><code>Read</code>操作时，如果<code>Length</code>的值为<span class="math inline">\(0\)</span>，那么不进行任何操作。</li></ul><h2 id="代码-2">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">mp = <span class="built_in">dict</span>()</span><br><span class="line">MAX = <span class="number">32</span> &lt;&lt; <span class="number">30</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    ls = <span class="built_in">input</span>().split()</span><br><span class="line">    <span class="keyword">if</span> ls[<span class="number">0</span>] == <span class="string">&#x27;Clear&#x27;</span>:</span><br><span class="line">        mp.clear()</span><br><span class="line">    <span class="keyword">elif</span> ls[<span class="number">0</span>] == <span class="string">&#x27;Write&#x27;</span>:</span><br><span class="line">        add, sz, s = <span class="built_in">int</span>(ls[<span class="number">1</span>][<span class="number">2</span>:], <span class="number">16</span>), <span class="built_in">int</span>(ls[<span class="number">2</span>]), ls[<span class="number">3</span>]</span><br><span class="line">        <span class="keyword">if</span> sz &lt; <span class="number">0</span> <span class="keyword">or</span> add + sz - <span class="number">1</span> &gt;= MAX <span class="keyword">or</span> <span class="built_in">len</span>(s) &amp; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        sz = <span class="built_in">min</span>(sz, <span class="built_in">len</span>(s) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        s = s[:sz &lt;&lt; <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(sz):</span><br><span class="line">            mp[add + i] = s[i &lt;&lt; <span class="number">1</span>:i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">elif</span> ls[<span class="number">0</span>] == <span class="string">&quot;Read&quot;</span>:</span><br><span class="line">        add, sz = <span class="built_in">int</span>(ls[<span class="number">1</span>][<span class="number">2</span>:], <span class="number">16</span>), <span class="built_in">int</span>(ls[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">if</span> sz &lt;= <span class="number">0</span> <span class="keyword">or</span> add + sz - <span class="number">1</span> &gt;= MAX:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(sz):</span><br><span class="line">            <span class="built_in">print</span>(mp.get(add + i, <span class="string">&quot;00&quot;</span>), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>携程 秋招 2023.10.10 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Xiecheng-20231010/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Xiecheng-20231010/</id>
    <published>2023-10-11T10:56:04.000Z</published>
    <updated>2023-10-11T10:56:04.619Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="游游修改01串">1、游游修改<code>01</code>串</h1><p>游游拿到了一个<code>01</code>串，她最多可以修改字符串中的一个位置(即<code>'0'</code>变<code>'1'</code>，或<code>'1'</code>变<code>'0'</code>)。游游希望修改后字符串包含尽可能多的长度为<span class="math inline">\(3\)</span>的回文子串。你能帮帮她吗？</p><h2 id="输入">输入</h2><p>一个仅包含<code>'0'</code>和<code>'1'</code>的字符串，长度不超过<span class="math inline">\(10^5\)</span>。</p><h2 id="输出">输出</h2><p>一个整数，代表修改后的回文子串数量。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">01101</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>一个长度为<span class="math inline">\(3\)</span>的字符串<span class="math inline">\(t=t_1t_2t_3\)</span>是回文串当且仅当<span class="math inline">\(t_1=t_3\)</span>。</p><p>因此，首先统计当前输入的字符串<span class="math inline">\(s\)</span>有多少个长度为<span class="math inline">\(3\)</span>的回文串，并记录其值为<span class="math inline">\(v\)</span>。如果要修改字符<span class="math inline">\(s[i]\)</span>，那么只会影响子串<span class="math inline">\(s[i-2:i]\)</span>和<span class="math inline">\(s[i:i+2]\)</span>是否为回文串这个状态发生变化。因此改变<span class="math inline">\(s[i]\)</span>后，重新统计受影响的位置中的变化即可，最终取最大值。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">n = <span class="built_in">len</span>(s)</span><br><span class="line">v = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> s[i - <span class="number">1</span>] == s[i + <span class="number">1</span>]:</span><br><span class="line">        v += <span class="number">1</span></span><br><span class="line">mx = v</span><br><span class="line">s = <span class="built_in">list</span>(<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> s)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    k = i - <span class="number">1</span></span><br><span class="line">    w = v</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> [i - <span class="number">1</span>, i + <span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="number">1</span> &lt;= k &lt; n - <span class="number">1</span> <span class="keyword">and</span> s[k - <span class="number">1</span>] == s[k + <span class="number">1</span>]:</span><br><span class="line">            w -= <span class="number">1</span></span><br><span class="line">    s[i] ^= <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> [i - <span class="number">1</span>, i + <span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="number">1</span> &lt;= k &lt; n - <span class="number">1</span> <span class="keyword">and</span> s[k - <span class="number">1</span>] == s[k + <span class="number">1</span>]:</span><br><span class="line">            w += <span class="number">1</span></span><br><span class="line">    mx = <span class="built_in">max</span>(mx, w)</span><br><span class="line">    s[i] ^= <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(mx)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="游游的分治">2、游游的分治</h1><p>二维平面上有<span class="math inline">\(n\)</span>个点。游游准备用以下的分治手段查找出某个点。</p><ol type="1"><li><p>按横坐标从小到大排序，横坐标相等的按纵坐标从小到大排序。将排好序的点数组分成数量尽可能接近的两部分（如果此时共有奇数个点，那么第一部分的数量比第二部分少<span class="math inline">\(1\)</span>）。查找指定点在第一部分还是第二部分。</p></li><li><p>按纵坐标从小到大排序，纵坐标相等的按横坐标从小到大排序。将排好序的点数组分成数量尽可能接近的两部分（如果此时共有奇数个点，那么第一部分的数量比第二部分少<span class="math inline">\(1\)</span>）。查找指定点在第一部分还是第二部分。</p></li><li><p>回到第一步重复下去。直到最终只剩一个点时跳出。</p></li></ol><p>请你模拟游游的分治过程。</p><h2 id="输入-1">输入</h2><p>第一行输入两个正整数<span class="math inline">\(n,x\)</span>，代表点的数量、以及需要查找第几个点。</p><p>接下来的<span class="math inline">\(n\)</span>行，每行输入两个整数<span class="math inline">\(x_i,y_i\)</span>，代表点的坐标。</p><ul><li><span class="math inline">\(1 \le n \le 1000\)</span></li><li><span class="math inline">\(-10^9\le x_i,y_i\le 10^9\)</span></li></ul><h2 id="输出-1">输出</h2><p>输出一个字符串，代表每次查找的结果。</p><ol type="1"><li>如果该次查到的在第一部分，输出<code>'L'</code>。</li><li>如果该次查到的在第二部分，输出<code>'R'</code>。</li><li>如果该次查找仅包含一个点，输出<code>'O'</code>。</li></ol><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">4 2</span><br><span class="line">-1 3</span><br><span class="line">3 5</span><br><span class="line">2 6</span><br><span class="line">4 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">RRO</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>按照题目的要求进行即可。第<span class="math inline">\(i\)</span>次的搜索使用的排序规则为第<span class="math inline">\(i\bmod2\)</span>条，并舍弃另一半未被搜索的点。</p><h2 id="代码-1">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">n, x = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">a = []</span><br><span class="line">f = [<span class="keyword">lambda</span> t: t, <span class="keyword">lambda</span> t: (t[<span class="number">1</span>], t[<span class="number">0</span>])]</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    a.append(<span class="built_in">tuple</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">t = a[x - <span class="number">1</span>]</span><br><span class="line">s = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    a.sort(key=f[k &amp; <span class="number">1</span>])</span><br><span class="line">    m = <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="keyword">if</span> m == <span class="number">1</span>:</span><br><span class="line">        s += <span class="string">&quot;O&quot;</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    l, r = a[:m &gt;&gt; <span class="number">1</span>], a[m &gt;&gt; <span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">if</span> t <span class="keyword">in</span> l:</span><br><span class="line">        s += <span class="string">&quot;L&quot;</span></span><br><span class="line">        a = l</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        s += <span class="string">&quot;R&quot;</span></span><br><span class="line">        a = r</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><h1 id="游游的字符串">3、游游的字符串</h1><p>游游拿到了一个字符申，她每次接作可以梅一个字裤修改为其字母表上相邻的字母，例如<code>'a'</code>修改为<code>'b'</code>，<code>'e'</code>修改为<code>'d'</code>等。</p><p>游游希望最终字符串每个相邻字符都不相等，她想知道最终最少操作多少次？请你给出任意一个修改后的方案。</p><h2 id="输入-2">输入</h2><p>输入仅包含一行由英文小写字母组成的字符串，长度不超过<span class="math inline">\(10^5\)</span>。</p><h2 id="输出-2">输出</h2><p>第一行输出一个整数，代表最少的修改次数。</p><p>第二行输出一个字符串，代表修改后的字符串。有多解时输出任意即 可。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">aabcc</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2</span><br><span class="line">babcb</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>一个字符可以改成它字母表上相邻的字符，我们可以将第<span class="math inline">\(i\)</span>个字符最终变成另一个字符视为是一种决策，这些决策集合用<span class="math inline">\(O_i\)</span>来表示，<span class="math inline">\(o_{i,j}\)</span>表示选择的是第<span class="math inline">\(j\)</span>种决策表示的字符。</p><p>由于当前字母的决策只取决于前一个字母，因此这题我们使用动态规划不难解决。令<span class="math inline">\(s\)</span>表示输入的字符串，状态<span class="math inline">\(f(i,j)(1\le i\le n,1\le j\le|O_i|)\)</span>表示保证前<span class="math inline">\(i\)</span>个字符已经不相同的情况下，第<span class="math inline">\(i\)</span>个字符为<span class="math inline">\(o_{i,j}\)</span>所需要的最小操作次数。那么可以写出如下状态转移方程：</p><p><span class="math inline">\(f(i,j)= \left\{\begin{aligned}  &amp;[o_{i,j}\neq s_i] &amp; &amp; \text{if}\quad i=1\\  &amp;\min_{\substack{1\le k\le |O_{i-1}|\\o_{i-1,k}\neqo_{i,j}}}\{f(i-1,k)+[o_{i,j}\neq s_i]\} &amp; &amp; \text{if}\quadi&gt;1 \\ \end{aligned}\right.\)</span></p><p>其中，示性函数<span class="math inline">\([b]\)</span>表示布尔表达式<span class="math inline">\(b\)</span>如果成立，那么其值为<span class="math inline">\(1\)</span>，否则为<span class="math inline">\(0\)</span>。为了记录最优决策，我们还要记录当前状态是由<span class="math inline">\(f(i-1,\cdot)\)</span>的哪个状态转移而来，在最后构造方案时，根据记录情况，从后往前进行构造即可。</p><p>因此，最终答案为<span class="math inline">\(\displaystyle{\min_{j=1}^{|O_n|}\{f(n,j)\}}\)</span>。</p><h2 id="代码-2">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">n = <span class="built_in">len</span>(s)</span><br><span class="line"></span><br><span class="line">op = [<span class="string">&quot;&quot;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">if</span> s[i] == <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">        op[i] = <span class="string">&#x27;ab&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> s[i] == <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">        op[i] = <span class="string">&#x27;yz&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        k = <span class="built_in">ord</span>(s[i])</span><br><span class="line">        op[i] = <span class="built_in">chr</span>(k - <span class="number">1</span>) + <span class="built_in">chr</span>(k) + <span class="built_in">chr</span>(k + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">f = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(op[i]))] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">pre = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(op[i]))] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(op[<span class="number">0</span>])):</span><br><span class="line">    f[<span class="number">0</span>][j] = <span class="built_in">int</span>(op[<span class="number">0</span>][j] != s[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(op[i])):</span><br><span class="line">        f[i][j] = <span class="number">10</span> ** <span class="number">10</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(op[i - <span class="number">1</span>])):</span><br><span class="line">            <span class="keyword">if</span> op[i - <span class="number">1</span>][k] != op[i][j]:</span><br><span class="line">                v = f[i - <span class="number">1</span>][k] + <span class="built_in">int</span>(op[i][j] != s[i])</span><br><span class="line">                <span class="keyword">if</span> v &lt; f[i][j]:</span><br><span class="line">                    f[i][j] = v</span><br><span class="line">                    pre[i][j] = k</span><br><span class="line"></span><br><span class="line">k = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(op[-<span class="number">1</span>])):</span><br><span class="line">    <span class="keyword">if</span> f[-<span class="number">1</span>][j] &lt; f[-<span class="number">1</span>][k]:</span><br><span class="line">        k = j</span><br><span class="line"><span class="built_in">print</span>(f[-<span class="number">1</span>][k])</span><br><span class="line">ans = [<span class="string">&quot;&quot;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    ans[i] = op[i][k]</span><br><span class="line">    k = pre[i][k]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(ans))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="游游的树">4、游游的树</h1><p>游游拿到了一棵树，其中每个节点被染成了红色(<code>r</code>)、绿色(<code>g</code>)或蓝色(<code>b</code>)。</p><p>游游想选择一条长度为<span class="math inline">\(3\)</span>的简单路径，满足该路径上的四个点恰好共有<span class="math inline">\(3\)</span>种颜色。</p><p>游游想知道，可以选择多少不同的路径？我们认为，点<span class="math inline">\(p\)</span>到点<span class="math inline">\(q\)</span>，点<span class="math inline">\(q\)</span>到点<span class="math inline">\(p\)</span>这两条路径为同一条。</p><p>注：树指不含重边和自环的无向连通图。</p><h2 id="输入-3">输入</h2><p>第一行输入一个正整数<span class="math inline">\(n\)</span>，代表树的节点数量。</p><p>第二行输入一个长度为<span class="math inline">\(n\)</span>的、仅包含<code>'r'</code>、<code>'g'</code>、<code>'b'</code>三种字符的字符串，第<span class="math inline">\(i\)</span>个字符表示节点<span class="math inline">\(i\)</span>的颜色。</p><p>接下来的<span class="math inline">\(n-1\)</span>行，每行输入两个正整数<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>，代表点<span class="math inline">\(u\)</span>和点<span class="math inline">\(v\)</span>有一条无向边连接。</p><ul><li><span class="math inline">\(3\le n\le 10^5\)</span></li><li><span class="math inline">\(1\le u,v\le n\)</span></li></ul><h2 id="输出-3">输出</h2><p>一个整数，代表不同路径的数量。</p><h2 id="样例-3">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">4</span><br><span class="line">rgbg</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">只有一种选择：选择1-2-3-4路径</span><br></pre></td></tr></table></figure><h2 id="解答-3">解答</h2><p>由于长度的路径只有<span class="math inline">\(3\)</span>，因此我们可以用贡献法进行解决，枚举每一边作为路径的中间那条边，计算路径数，并添加到答案中。</p><p>为了表达上和编码上的方便，我们分别将三种颜色映射成三个数字<span class="math inline">\(0,1,2\)</span>。令<span class="math inline">\(a_u\)</span>表示节点<span class="math inline">\(u\)</span>的颜色，令<span class="math inline">\(c_{u,k}\)</span>表示节点<span class="math inline">\(u\)</span>有多少个相邻节点的颜色是<span class="math inline">\(k\)</span>，令<span class="math inline">\(d_u\)</span>表示节点<span class="math inline">\(u\)</span>的度数。接下来对每条边<span class="math inline">\(u,v\)</span>分两种情况进行讨论：</p><ul><li><p>如果<span class="math inline">\(a_u=a_v\)</span>，那么说明<span class="math inline">\(u\)</span>的另一个邻居<span class="math inline">\(x\)</span>和<span class="math inline">\(v\)</span>的另一个邻居<span class="math inline">\(y\)</span>必须是剩下的两种颜色。设这两种颜色分别为<span class="math inline">\(c_1\)</span>和<span class="math inline">\(c_2\)</span>，那么要么<span class="math inline">\(x\)</span>的颜色为<span class="math inline">\(c_1\)</span>，<span class="math inline">\(y\)</span>的颜色为<span class="math inline">\(c_2\)</span>；要么<span class="math inline">\(x\)</span>的颜色为<span class="math inline">\(c_2\)</span>，<span class="math inline">\(y\)</span>的颜色为<span class="math inline">\(c_1\)</span>，因此这条边总共做出的贡献为<span class="math inline">\(c_{u,c_1}\times c_{v,c_2}+c_{u,c_2}\timesc_{v,c_1}\)</span>。</p></li><li><p>如果<span class="math inline">\(a_u\neq a_v\)</span>，令<span class="math inline">\(c_0\)</span>是除去<span class="math inline">\(a_u\)</span>和<span class="math inline">\(a_v\)</span>的剩下的第三种颜色，那么<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>中必定有一个颜色是<span class="math inline">\(c_0\)</span>，另一个节点颜色随意，那么可以看出这部分做出的贡献为<span class="math inline">\(c_{u,c_0}\times(d_v-1)+c_{v,c_0}\times(d_u-1)-c_{u,c_0}\times c_{v,c_0}\)</span>，其中，前两项里面的<span class="math inline">\(-1\)</span>在于避免这条路径又回到这条边的另一个节点，从而避免把有重复节点的路径统计进去。第三项在于前面的一项将两端都是颜色c_0的情况重复计算了，需要减回去。</p></li></ul><p>因此直接累计答案即可。</p><h2 id="代码-3">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">cnt = [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">g = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">mp = &#123;<span class="string">&#x27;r&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;g&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">col = [mp[c] <span class="keyword">for</span> c <span class="keyword">in</span> s]</span><br><span class="line"></span><br><span class="line">edge = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">    x, y = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x) - <span class="number">1</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    g[x].append(y)</span><br><span class="line">    g[y].append(x)</span><br><span class="line">    edge.append((x, y))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> g[i]:</span><br><span class="line">        cnt[i][col[j]] += <span class="number">1</span></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> u, v <span class="keyword">in</span> edge:</span><br><span class="line">    <span class="keyword">if</span> col[u] == col[v]:</span><br><span class="line">        c1 = <span class="number">1</span> <span class="keyword">if</span> col[u] == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        c2 = <span class="number">3</span> - c1 - col[u]</span><br><span class="line">        ans += cnt[u][c1] * cnt[v][c2] + cnt[u][c2] * cnt[v][c1]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        c = <span class="number">3</span> - col[u] - col[v]</span><br><span class="line">        ans += cnt[u][c] * (<span class="built_in">len</span>(g[v]) - <span class="number">1</span>) + cnt[v][c] * (<span class="built_in">len</span>(g[u]) - <span class="number">1</span>) - cnt[u][c] * cnt[v][c]</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>度小满 秋招 2023.10.09 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Duxiaoman-20231009/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Duxiaoman-20231009/</id>
    <published>2023-10-11T10:56:01.000Z</published>
    <updated>2023-10-11T10:56:01.276Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="accept">1、accept</h1><p>给一个<span class="math inline">\(n\timesm\)</span>的字符矩阵，请你判断将矩阵中的某一行按从左向右顺序或者某一列按从上到下顺序取出作为一个字符串后，该字符串中是否存在子串<code>"accept"</code>。</p><h2 id="输入">输入</h2><p>第一行包含一个正整数<span class="math inline">\(T\)</span>，表示数据组数。</p><p>接下来包含<span class="math inline">\(T\)</span>组数据，对于每组数据：</p><p>第一行包含两个正整数<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>，表示矩阵的行数和列数。</p><p>接下来<span class="math inline">\(n\)</span>行，每行一个长度为<span class="math inline">\(m\)</span>的字符串，表示矩阵每一行中的内容。</p><p>保证所有字符均为小写英文字符。</p><p><span class="math inline">\(100\%\)</span>的数据保证：<span class="math inline">\(1\le T\le 10,1\le n,m\le 100\)</span></p><h2 id="输出">输出</h2><p>对于每组数据，如果存在则输出<code>"YES"</code>否则输出<code>"NO"</code>。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">2</span><br><span class="line">10</span><br><span class="line">dc</span><br><span class="line">ac</span><br><span class="line">ca</span><br><span class="line">ec</span><br><span class="line">cc</span><br><span class="line">qe</span><br><span class="line">gp</span><br><span class="line">ht</span><br><span class="line">ee</span><br><span class="line">pd</span><br><span class="line">2 10</span><br><span class="line">dscacceptd</span><br><span class="line">pqoxaccepw</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">第一组数据中，第二列中包舍了&quot;accept&quot;子串。</span><br><span class="line">第二组数据中，第一行中包含了“accept&quot;子串。</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>首先枚举<code>"accept"</code>或者是其逆序<code>"tpecca"</code>是否在字符矩阵的每一行存在即可，可以使用内置的库完成。</p><p>至于纵向的处理，只需要将这个字符矩阵进行转置，再进行和刚刚相同的操作即可。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">p1 = <span class="string">&quot;accept&quot;</span></span><br><span class="line">p2 = p1[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">ls</span>):</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> ls:</span><br><span class="line">        <span class="keyword">if</span> p1 <span class="keyword">in</span> s <span class="keyword">or</span> p2 <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    n, m = <span class="built_in">len</span>(ls), <span class="built_in">len</span>(ls[<span class="number">0</span>])</span><br><span class="line">    lt = [<span class="string">&quot;&quot;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            lt[j] += ls[i][j]</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> lt:</span><br><span class="line">        <span class="keyword">if</span> p1 <span class="keyword">in</span> s <span class="keyword">or</span> p2 <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    ls = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        ls.append(<span class="built_in">input</span>())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;YES&quot;</span> <span class="keyword">if</span> solve(ls) <span class="keyword">else</span> <span class="string">&quot;NO&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="数组排序">2、数组排序</h1><p>给定一个长度为<span class="math inline">\(n\)</span>的数组<span class="math inline">\(A\)</span>，数组下标为<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>，第<span class="math inline">\(i\)</span>个数记为<span class="math inline">\(a_i\)</span>，保证<span class="math inline">\(A\)</span>数组是<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>的一个排列。现在，小明将对<span class="math inline">\(A\)</span>数组按顺序进行<span class="math inline">\(m\)</span>次操作来对<span class="math inline">\(A\)</span>数组排序。第<span class="math inline">\(i\)</span>次操作会给定参数<span class="math inline">\(x_i\)</span>和<span class="math inline">\(y_i(x_i&lt;y_i)\)</span>，表示若<span class="math inline">\(a_{x_i}&gt;a_{y_i}\)</span>，则交换<span class="math inline">\(a_{x_i}\)</span>和<span class="math inline">\(a_{y_i}\)</span>。若数组恢复有序，小明会立刻停止操作。</p><p>现在，你需要告诉小明<span class="math inline">\(A\)</span>数组最早在什么时恢复有序（本题有序指数组单调递增，即从小到大有序），即找到一个最小的非负整数<span class="math inline">\(p\)</span>，满足第<span class="math inline">\(p\)</span>次操作后，数组<span class="math inline">\(A\)</span>有序。特别地，若<span class="math inline">\(A\)</span>数组在第<span class="math inline">\(1\)</span>次操作前就有序，则<span class="math inline">\(p=0\)</span>，若数组在<span class="math inline">\(m\)</span>次操作后仍然没有处于有序状态，则<span class="math inline">\(p=m+1\)</span>。</p><h2 id="输入-1">输入</h2><p>本题输入包含多组测试数据，输入第一行包含一个正整数<span class="math inline">\(T(1\le T\le100)\)</span>，表示数据组数。</p><p>接下来，每三行描述了一组测试数据。</p><p>每组测试数据中，第一行包含两个正整数<span class="math inline">\(n(2\le n\le 20)\)</span>和<span class="math inline">\(m(1\le m\le 200)\)</span>，分别表示<span class="math inline">\(A\)</span>数组长度和操作个数。</p><p>接下来一行包含<span class="math inline">\(n\)</span>个整数，描述了数组<span class="math inline">\(A\)</span>，保证数组<span class="math inline">\(A\)</span>为<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>的一个排列。</p><p>接下来一行包含<span class="math inline">\(2m\)</span>个整数，按操作顺序描述了小明将要进行的操作，第<span class="math inline">\(2i-1\)</span>个整数和第<span class="math inline">\(2i\)</span>个整数描述了第<span class="math inline">\(i\)</span>次操作<span class="math inline">\((1\lei\le m)\)</span>，分别代表了操作的两个参数<span class="math inline">\(x_i\)</span>和<span class="math inline">\(y_i(x_i&lt;y_i)\)</span>。</p><p>对于<span class="math inline">\(100\%\)</span>的数据，满足<span class="math inline">\(2\le n\le 20,1\le m\le 200,1\le T\le100\)</span>。</p><p>保证数组<span class="math inline">\(A\)</span>是<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>的一个排列。</p><h2 id="输出-1">输出</h2><p>对于每组测试数据，输出包含一行一个整数，即满足题意的最小非负整数。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">2</span><br><span class="line">5 2</span><br><span class="line">1 2 4 3 5</span><br><span class="line">1 2 3 4</span><br><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">1 2</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">对于样例的第一组测试数据：</span><br><span class="line">初始A数组为:1 2 4 3 5</span><br><span class="line">执行第1次操作后，数组A变为：1 2 4 3 5</span><br><span class="line">执行第2次操作后，数组A变为：1 2 3 4 5</span><br><span class="line">此时有序，故答案为2。</span><br><span class="line">对于样例的第二组测试数据，数组初始即有序，故答案为0。</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>只需要直接处理这个过程即可。如果数组<span class="math inline">\(A\)</span>已经有序，那么直接返回<span class="math inline">\(0\)</span>即可，接下来枚举每个交换操作，交换完后如果发现是有序的，那么可以直接返回。否则返回值<span class="math inline">\(m+1\)</span>。这种做法完全可以做出这个数据范围下<span class="math inline">\(O(nm)\)</span>的这题。</p><p>以下介绍一种<span class="math inline">\(O(n+m)\)</span>的做法。在整个过程中，维护一个变量<span class="math inline">\(c\)</span>，表示有多少个数已经排在了正确的位置上，当<span class="math inline">\(c=n\)</span>时，说明数组已经有序。可以在<span class="math inline">\(O(1)\)</span>的时间内维护好<span class="math inline">\(c\)</span>变量，交换前处理排好序的下标的情况，交换后也处理排好序的下标的情况，从而完成变量<span class="math inline">\(c\)</span>的维护。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N],x[N],y[N],n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x[i],&amp;y[i]);</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==i) ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt==n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[x[i]]&gt;a[y[i]])&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[x[i]]==x[i]) --cnt;</span><br><span class="line">            <span class="keyword">if</span>(a[y[i]]==y[i]) --cnt;</span><br><span class="line">            <span class="built_in">swap</span>(a[x[i]],a[y[i]]);</span><br><span class="line">            <span class="keyword">if</span>(a[x[i]]==x[i]) ++cnt;</span><br><span class="line">            <span class="keyword">if</span>(a[y[i]]==y[i]) ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt==n) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">solve</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小的区间">3、最小的区间</h1><p>给定一个长度为<span class="math inline">\(n\)</span>的数组<span class="math inline">\(A\)</span>，下标为<span class="math inline">\(1\)</span>到n。给定一个长度为<span class="math inline">\(m\)</span>的数组<span class="math inline">\(B\)</span>，下标为<span class="math inline">\(1\)</span>到<span class="math inline">\(m\)</span>，数组<span class="math inline">\(B\)</span>中第<span class="math inline">\(i\)</span>个数记为<span class="math inline">\(b_i\)</span>。请找出长度最小的连续区间<span class="math inline">\([l,r]\)</span>（<span class="math inline">\(1\le l\le r\le n\)</span>且<span class="math inline">\(l,r\)</span>为整数），使得该区间对于所有满足<span class="math inline">\(1\le x\le m\)</span>的正整数<span class="math inline">\(x\)</span>均有：正整数<span class="math inline">\(x\)</span>在<span class="math inline">\(A\)</span>数组的下标落在区间<span class="math inline">\([l,r]\)</span>的所有数中至少现了<span class="math inline">\(b_x\)</span>次。</p><p>注意，对于任意一个连续区间<span class="math inline">\([l,r]，区间的长度定义为\)</span>r-l+1$。</p><h2 id="输入-2">输入</h2><p>输入第一行包含两个数<span class="math inline">\(n(1\le n\le10^5)\)</span>和<span class="math inline">\(m(1\le m\le10^5)\)</span>，分别表示数组<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>的长度。</p><p>输入第二行包含<span class="math inline">\(n\)</span>个整数，描述了数组<span class="math inline">\(A\)</span>。</p><p>输出第三行包含<span class="math inline">\(m\)</span>个整数，描述了数组<span class="math inline">\(B\)</span>。</p><p>对于<span class="math inline">\(100\%\)</span>的数据，满足<span class="math inline">\(1\le n,m\le 10^5\)</span>。</p><p>保证数组<span class="math inline">\(A\)</span>和数组<span class="math inline">\(B\)</span>中所有数均为不超过<span class="math inline">\(10^5\)</span>的非负整数，保证数组<span class="math inline">\(B\)</span>不全为<span class="math inline">\(0\)</span>。</p><h2 id="输出-2">输出</h2><p>输出包含一行一个整数，表示最小的符合要求的区间的长度。</p><p>如果不存在符合要求的区间，请输出<span class="math inline">\(-1\)</span>。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">8 5</span><br><span class="line">2 3 3 1 2 4 2 5</span><br><span class="line">1 2 0 0 0</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">样例中，区间[4,7]是长度最小的满足条件的区间，其区间长度为7-4+1=4。</span><br><span class="line">样例中需要满足的条件是“1至少出现1次”，“2至少出现2次”，“3、4、5至少出现0次”。</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>我们可以使用双指针法完成这题。我们可以使用枚举左指针<span class="math inline">\(l\)</span>，并且找到最大的<span class="math inline">\(r(r\le n+1)\)</span>指针使得区间<span class="math inline">\([l,r)\)</span>中的所有出现次数都满足数组<span class="math inline">\(b\)</span>，从而把答案<span class="math inline">\(r-l\)</span>进行统计（如果<span class="math inline">\(r\)</span>存在）。</p><p>这个过程怎么维护呢？使用一个<span class="math inline">\(c\)</span>数组用于统计<span class="math inline">\(a[l,r)\)</span>中的元素个数，以及集合<span class="math inline">\(S\)</span>用于记录满足<span class="math inline">\(1\le x\le m,c_x&lt;b_x\)</span>的那些<span class="math inline">\(x\)</span>值。随着右指针右移，<span class="math inline">\(S\)</span>集合元素逐渐减少，直到为空，这时<span class="math inline">\(r-l\)</span>为所求的答案。接下来去除<span class="math inline">\(a_l\)</span>元素，集合<span class="math inline">\(S\)</span>有可能新添加一个元素<span class="math inline">\(a_l\)</span>。由此使用双指针法即可完成本题。</p><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N],b[N],n,m;</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt;st;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> op)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;m) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(++cnt[x]&gt;=b[x])</span><br><span class="line">            st.<span class="built_in">erase</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(--cnt[x]&lt;b[x])</span><br><span class="line">            st.<span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">        <span class="keyword">if</span>(b[i]) st.<span class="built_in">insert</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">1</span>;l&lt;=n;l++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(;r&lt;=n&amp;&amp;!st.<span class="built_in">empty</span>();r++)&#123;</span><br><span class="line">            <span class="built_in">add</span>(a[r],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,r-l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">add</span>(a[l],<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans&gt;n) ans=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>百度 秋招 2023.10.10 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Baidu-20231010/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Baidu-20231010/</id>
    <published>2023-10-11T10:55:57.000Z</published>
    <updated>2023-10-11T10:55:57.193Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="小红的精灵">1、小红的精灵</h1><p>小红有<span class="math inline">\(n\)</span>个精灵，精灵分布在<span class="math inline">\(m\)</span>个房间中，第<span class="math inline">\(i\)</span>个精灵可以施展<span class="math inline">\(a_i\)</span>次魔法，现在有<span class="math inline">\(k\)</span>个敌人要攻击，每次攻击需要一个房间的精灵都消耗一次魔法，该次攻击可以击杀一个敌人。问小红最多可以消灭多少敌人。</p><h2 id="输入">输入</h2><p>一行三个整数<span class="math inline">\(n,m,k\)</span>，分别表示精灵数量，房间数量，敌人数量。</p><p>接下来<span class="math inline">\(n\)</span>行，每行两个整数，第<span class="math inline">\(i\)</span>行表示第<span class="math inline">\(i\)</span>个精灵的所在房间编号<span class="math inline">\(b_i\)</span>和可以施展的魔法次数<span class="math inline">\(a_i\)</span>。</p><ul><li><span class="math inline">\(1\le n,m\le 10^5\)</span></li><li><span class="math inline">\(1\le b_i\le m\)</span></li><li><span class="math inline">\(1\le a_i,k \le 10^6\)</span></li></ul><h2 id="输出">输出</h2><p>输出一个整数，表示最多可以消灭的敌人数量。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">4 5 12</span><br><span class="line">2 4</span><br><span class="line">5 2</span><br><span class="line">3 6</span><br><span class="line">2 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">11</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">有12个敌人，第二个房间可以消灭3个敌人，第三个房间可以消灭6个敌人，第五个房间可以消灭2个敌人。总共可以消灭11个敌人。</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>如果第<span class="math inline">\(i\)</span>个房间没有精灵，那么第<span class="math inline">\(i\)</span>个房间并没有用处。如果第<span class="math inline">\(i\)</span>个房间有精灵，那么这个房间可以击败的敌人数为<span class="math inline">\(c_i=\displaystyle{\min_{1\le j\len,b_j=i}\{a_j\}}\)</span>。</p><p>最终把<span class="math inline">\(c_i\)</span>的值进行求和即可，并和<span class="math inline">\(k\)</span>取较小值。如果第<span class="math inline">\(i\)</span>个房间没有精灵，那么令<span class="math inline">\(c_i=0\)</span>。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n, m, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">mp = &#123;&#125;</span><br><span class="line">INF = <span class="number">10</span> ** <span class="number">9</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    b, a = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    mp[b] = <span class="built_in">min</span>(mp.get(b, INF), a)</span><br><span class="line">ans = <span class="built_in">min</span>(<span class="built_in">sum</span>(mp.values()), k)</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure><h1 id="小红分糖果">2、小红分糖果</h1><p>小红有<span class="math inline">\(n\)</span>个糖果，要分给小朋友，每个小朋友必须分到<span class="math inline">\([l,r]\)</span>个，如果可以分完，输出最少可以分给多少小朋友，最多可以分给多少小朋友，如果不能分完，输出<span class="math inline">\(-1\)</span>。</p><h2 id="输入-1">输入</h2><p>一行三个整数<span class="math inline">\(n,l,r\)</span>，表示糖果数量和每个小朋友的要求。</p><ul><li><span class="math inline">\(1\le n \le 10^9\)</span></li><li><span class="math inline">\(1\le l\le r\le 10^9\)</span></li></ul><h2 id="输出-1">输出</h2><p>如果可以分完，输出最少可以分给多少小朋友，最多可以分给多少小朋友，如果不能分完，输出<span class="math inline">\(-1\)</span>。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">10 2 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">4 5</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">最少可以分给4个小朋友，[2,2,3,3]; 最多可以分给5个小朋友，每个小朋友分到2个糖果。</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>假设现在需要求最大值，基本思想是每个小朋友都分的最少。也就是说，分得<span class="math inline">\(d=\lfloor n/l\rfloor\)</span>个小朋友，还剩下<span class="math inline">\(q=n-ld\)</span>个糖果。容易知道<span class="math inline">\(d\)</span>是答案的一个上界，<span class="math inline">\(d\)</span>不能够再大了。可见<span class="math inline">\(q&lt;l\)</span>，那么这些多出来的<span class="math inline">\(q\)</span>个糖果需要分配回去，但是为了确保满足题意，哪怕分回去每个小朋友也不能分超过<span class="math inline">\(r\)</span>个糖果，他们现在最多只能再得到<span class="math inline">\(r-l\)</span>个糖果。因此，剩下的糖果数<span class="math inline">\(q\)</span>必须满足<span class="math inline">\(q\led(r-l)\)</span>。如果不满足<span class="math inline">\(q\led(r-l)\)</span>，</p><p>那么如果分给<span class="math inline">\(d\)</span>个小朋友不可行，有没有可能通过减少小朋友从而获得一个分配方案呢？答案是不可能的，因为减少了小朋友后，就要承担原本分给他的<span class="math inline">\(l\)</span>个糖果，之前的小朋友反而还需要多承受一些糖果（总共剩余不止<span class="math inline">\(q\)</span>糖果了）。因此减少小朋友并不能获得一个合法的分配方案，上面给出的答案就是最佳答案。</p><p>假设现在需要求最小值，思想和上面的类似，每个小朋友都分的最多。也就是说，分得<span class="math inline">\(d=\lfloor n/r\rfloor\)</span>个小朋友，还剩下<span class="math inline">\(q=n-rd\)</span>个糖果。容易知道<span class="math inline">\(d\)</span>是答案的一个下界，<span class="math inline">\(d\)</span>不能够再小了。类似的，可见<span class="math inline">\(q&lt;r\)</span>。如果<span class="math inline">\(q=0\)</span>，那么这些糖果恰好分完，不需要再判断其它情况。如果<span class="math inline">\(q&gt;0\)</span>，那么还需要多一个小朋友来承受这些糖果。如果<span class="math inline">\(q\gel\)</span>，那么说明这时新的小朋友已经满足了条件，此时答案为<span class="math inline">\(d+1\)</span>，如果<span class="math inline">\(q&lt;l\)</span>，那么前面的小朋友只能都拿出<span class="math inline">\(r-l\)</span>个糖果给他。因此，如果<span class="math inline">\(q+d(r-l)\gel\)</span>仍然成立，那么这个小朋友也是符合条件的，否则他无法取到<span class="math inline">\(l\)</span>个糖果，并不可行。</p><p>同样的问题，如果分给<span class="math inline">\(d\)</span>个小朋友不可行，有没有可能通过增加小朋友从而获得一个分配方案呢？答案同样也是不可行的，因为增加了小朋友后，其余的小朋友就要拿出更多的糖果分出来，原来已经不够分配给持有<span class="math inline">\(q\)</span>个糖果的小朋友的数量，现在更加不可行。因此增加小朋友并不能获得一个合法的分配方案，上面给出的答案就是最佳答案。</p><h2 id="代码-1">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">n, l, r = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">rp, rr = <span class="built_in">divmod</span>(n, l)</span><br><span class="line"><span class="keyword">if</span> rp * (r - l) &lt; rr:</span><br><span class="line">    rp = -<span class="number">1</span></span><br><span class="line">lp, lr = <span class="built_in">divmod</span>(n, r)</span><br><span class="line"><span class="keyword">if</span> lr &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">if</span> lp * (r - l) + lr &lt; l:</span><br><span class="line">        lp = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        lp += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> rp == -<span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(lp, rp)</span><br></pre></td></tr></table></figure><h1 id="小红的树上游走">3、小红的树上游走</h1><p>小红有一棵<span class="math inline">\(n\)</span>个节点的树，节点编号为<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>。每条边有一个权值，权值是<span class="math inline">\(1\)</span>或者<span class="math inline">\(0\)</span>。</p><p>对于一个长度为<span class="math inline">\(k\)</span>的节点序列<span class="math inline">\([a_1,a_2,\dots,a_k]\)</span>，按照顺序依次访问这些节点，从<span class="math inline">\(a_i\)</span>走到<span class="math inline">\(a_{i+1}\)</span>，会按照最短路径走。</p><p>小红想知道，对于所有长度为<span class="math inline">\(k\)</span>的节点序列中（一共有<span class="math inline">\(n^k\)</span>个长度为<span class="math inline">\(k\)</span>的序列），有多少个序列满足：小红走完这个序列后，经过的所有边的权值之和不为0。</p><p>由于答案可能很大，你只需要输出答案对<span class="math inline">\(10^9+7\)</span>取模的结果。</p><p>注意，小红可以从一个节点走到它自己，也可以重复经过一条边。</p><h2 id="输入-2">输入</h2><p>一行两个整数<span class="math inline">\(n\)</span>和<span class="math inline">\(k\)</span>，表示树的节点数和序列长度。</p><p>接下来<span class="math inline">\(n-1\)</span>行，每行三个整数<span class="math inline">\(u,v,w\)</span>，表示节点<span class="math inline">\(u\)</span>和节点<span class="math inline">\(v\)</span>之间有一条边，权值为<span class="math inline">\(w\)</span>。</p><ul><li><span class="math inline">\(1\le k\le n\le 10^5\)</span></li><li><span class="math inline">\(1\le u,v \le n,0\le w\le 1\)</span></li></ul><h2 id="输出-2">输出</h2><p>输出一个整数，表示满足条件的序列个数对<span class="math inline">\(10^9+7\)</span>取模的结果。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3 2</span><br><span class="line">1 2 1</span><br><span class="line">2 3 0</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">四个序列分别为[1,2],[2,1],[1,3],[3,1]</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>这道题的对立问题是：有多少序列，经过的所有边的权值之和等于<span class="math inline">\(0\)</span>。最终用总方案数<span class="math inline">\(n^k\)</span>减去对立问题的答案数，就能过得到原问题的答案。</p><p>可以发现，求解对立问题的解比求解原问题要简单的多，只要序列<span class="math inline">\(a\)</span>相邻的两个节点之间的路径都为<span class="math inline">\(0\)</span>即可。原问题与此的区别在于，<span class="math inline">\(a\)</span>中<strong>至少</strong>存在一对相邻节点，其路径权值和不等于<span class="math inline">\(0\)</span>，由于还要考虑其它相邻对节点是否满足这个情况，因此直接求解原问题比较困难。</p><p>接下来求解这个对立问题。可见，只需要每一对相邻对节点的路径和为<span class="math inline">\(0\)</span>即可，这时不需要考虑其它相邻节点对的问题，比较简单，我们使用并查集进行解决。将所有权值为<span class="math inline">\(0\)</span>的所有边的相邻节点合并在一起，那么节点<span class="math inline">\(u\)</span>和节点<span class="math inline">\(v\)</span>的路径之和为<span class="math inline">\(0\)</span>当且仅当它们在同一个集合中。因此，一个满足对立问题的序列，要求它的所有结点都在同一个集合中。假设所有合并操作完成后，一共有<span class="math inline">\(m\)</span>个集合，第<span class="math inline">\(i\)</span>个集合一共有<span class="math inline">\(c_i\)</span>个节点，那么这个集合中，满足的节点序列答案为<span class="math inline">\(c_i^k\)</span>。因此本题的最终答案为<span class="math inline">\(\displaystyle{n^k-\sum_{i=1}^mci^k}\)</span>。</p><h2 id="代码-2">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">n, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">fa = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">sz = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> fa[x] == x:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    fa[x] = find(fa[x])</span><br><span class="line">    <span class="keyword">return</span> fa[x]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">x, y</span>):</span><br><span class="line">    u, v = find(x), find(y)</span><br><span class="line">    <span class="keyword">if</span> u != v:</span><br><span class="line">        fa[v] = u</span><br><span class="line">        sz[u] += sz[v]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">    x, y, w = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    x, y = x - <span class="number">1</span>, y - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> w == <span class="number">0</span>:</span><br><span class="line">        merge(x, y)</span><br><span class="line"></span><br><span class="line">ans = (<span class="built_in">pow</span>(n, k, mod) - <span class="built_in">sum</span>(<span class="built_in">pow</span>(sz[i], k, mod) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n) <span class="keyword">if</span> i == find(i))) % mod</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>字节跳动 秋招 2023.10.08 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Zijietiaodong-20231008/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Zijietiaodong-20231008/</id>
    <published>2023-10-08T16:57:32.000Z</published>
    <updated>2023-10-08T16:57:32.039Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="小红操作数组">1、小红操作数组</h1><p>小红拿到了一个数组，她准备进行任意次以下操作：</p><p>选择一个正整数<span class="math inline">\(x\)</span>，使得数组的每个<span class="math inline">\(a_i\)</span>都变成<span class="math inline">\(x\%a_i\)</span>。</p><p>小红希望最终数组的每个元素都相等目大于<span class="math inline">\(0\)</span>。她想要你告诉她能否达成目的。</p><h2 id="输入">输入</h2><p>有多组测试用例，第一行输入一个整数<span class="math inline">\(t\)</span>，表示用例组数。</p><p>接下来每<span class="math inline">\(2\timest\)</span>行，表示一组用例。对于每组用例：</p><p>第一行输入一个正整数<span class="math inline">\(n\)</span>，代表数组的大小。</p><p>第二行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(a_i\)</span>，代表小红拿到的数组。</p><ul><li><span class="math inline">\(1\le t, n, a_i \le 10^5\)</span></li></ul><p>保证<span class="math inline">\(n\)</span>的总和不超过<span class="math inline">\(10^5\)</span>。</p><h2 id="输出">输出</h2><p>如果可以使得所有数相等且大于<span class="math inline">\(0\)</span>，输出<code>"Yes"</code>。否则输出<code>"No"</code>。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">3 6</span><br><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">2</span><br><span class="line">3 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>如果<span class="math inline">\(a\)</span>中的这些数都相同，那么不需要任何操作就是符合题意的。</p><p>否则，就需要进行至少<span class="math inline">\(1\)</span>次操作。如果存在某个<span class="math inline">\(a_i=1\)</span>，那么无论选什么<span class="math inline">\(x\)</span>，<span class="math inline">\(a_i\)</span>都变成<span class="math inline">\(0\)</span>，这是不符合题意的；否则我们选<span class="math inline">\(x=1\)</span>进行一次操作，那么下一步<span class="math inline">\(a\)</span>中所有数都变成<span class="math inline">\(1\)</span>，这是符合题意的。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>():</span><br><span class="line">    <span class="built_in">input</span>()</span><br><span class="line">    st = <span class="built_in">set</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> st <span class="keyword">or</span> <span class="built_in">len</span>(st) == <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Yes&quot;</span> <span class="keyword">if</span> solve() <span class="keyword">else</span> <span class="string">&quot;No&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="小红的有根树">2、小红的有根树</h1><p>小红拿到了一棵有根树，其中根是<span class="math inline">\(1\)</span>号节点。小红准备给每个节点染成红色或者绿色或者蓝色。但是有以下两个要求：</p><ol type="1"><li>每个节点和它的父亲颜色不同。 （如果它存在父亲）</li><li>每个节点和它的父亲的父亲颜色不同。 （如果它存在父亲的父亲）</li></ol><p>请你输出任意一种染色方案。</p><h2 id="输入-1">输入</h2><p>第一行输入一个正整数<span class="math inline">\(n\)</span>，代表节点的数量。</p><p>接下来的<span class="math inline">\(n-1\)</span>行，每行输入两个正整数<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>，代表节点<span class="math inline">\(u\)</span>和节点<span class="math inline">\(v\)</span>有一条边连接。</p><ul><li><span class="math inline">\(1 \le n \le 10^5\)</span></li><li><span class="math inline">\(1\le u,v\le n\)</span></li></ul><h2 id="输出-1">输出</h2><p>一个长度为<span class="math inline">\(n\)</span>的、仅由<code>'R','G','B'</code>三种字母组成的字符串。第<span class="math inline">\(i\)</span>个字符为<code>'R'</code>代表<span class="math inline">\(i\)</span>号节点被染成红色，为<code>'G'</code>代表染成绿色，<code>'B'</code>代麦染成蓝色。</p><p>如果有多解，输出任意即可。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">4</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br><span class="line">1 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">BGRG</span><br></pre></td></tr></table></figure><p>样例1的染色如下图：</p><pre class="mermaid">graph TD  1((1));2((2));3((3));4((4))  classDef red-node fill:red, color:white;  classDef blue-node fill:blue, color:white;  classDef green-node fill:green, color:white;  class 1 blue-node;  class 2 green-node;  class 3 red-node;  class 4 green-node;  1---2;3---4;1---3</pre><h2 id="解答-1">解答</h2><p>从另一个角度考虑这个问题：对于一个节点<span class="math inline">\(u\)</span>，其所有直系后代和直系后代的直系后代都不能和<span class="math inline">\(u\)</span>有相同的颜色。因此，我们只需要让<span class="math inline">\(u\)</span>的所有直系后代染上同一种颜色，以及让直系后代的直系后代也染上同一种颜色即可。</p><p>也就是说，每一层染上的颜色都是相同的，只需要相邻三层的节点染上的颜色都不相同即可，这个过程通过DFS即可完成。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;g[N];</span><br><span class="line"><span class="type">char</span> s[N],t[]=<span class="string">&quot;RGB&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    s[u]=t[d%<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u,d+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,x,y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        g[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        g[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(s+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小红做糖葫芦">3、小红做糖葫芦</h1><p>小红想用山楂制作糖葫芦，一串糖葫芦用一串字符串表示，糖葫芦的甜度为串上所有字符的甜度之和。字符的甜度为这个字符与字符<code>'a'</code>的差值。</p><p>即<code>'a'</code>的甜度为<span class="math inline">\(0\)</span>，<code>'b'</code>的甜度为<span class="math inline">\(1\)</span>……，<code>'z'</code>的甜度为<span class="math inline">\(25\)</span>。小红有<span class="math inline">\(n\)</span>个山植按顺序从<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>依次摆放，山植被表示为一个字符，山植的甜度即为字符的甜度。</p><p>小红制作糖葫芦时，需要取出一段连续的山楂制作成糖葫芦。</p><p>小红想知道，在所有可能被制成的糖葫芦中，甜度第<span class="math inline">\(k\)</span>大的糖葫芦甜度为多少？</p><p>若有一根糖葫串本身或翻转后与另一串糖葫芦相同，则这两串糖葫芦被视为是相同的糖葫芦。</p><p>例如，糖葫芦<code>"abc"</code>与<code>"cba"</code>被认为是相同的。</p><p>糖动芦。</p><h2 id="输入-2">输入</h2><p>第一行输入两个整数<span class="math inline">\(n,k(1\le n\le 200,1\lek\le n \times(n+1)/2)\)</span></p><p>第二行输入一个长度为<span class="math inline">\(n\)</span>的字符串，表示山楂的摆放顺序。</p><h2 id="输出-2">输出</h2><p>一行一个整数，表示甜度第<span class="math inline">\(k\)</span>大的是多少。若可能产生的糖葫芦数小于<span class="math inline">\(k\)</span>，则输出<span class="math inline">\(-1\)</span>。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3 4</span><br><span class="line">abc</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">可能制作的糖葫芦串为a,b,c,ab,bc,abc。甜度分别为0,1,2,1,3,3，其中第4甜的糖葫芦串甜度为1。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">3 4</span><br><span class="line">aba</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">可以制作的糖葫芦只有4种：&quot;a&quot;、&quot;b&quot;、&quot;ab&quot;、&quot;aba&quot;甜度分别是0,1,1,2，第4甜的糖葫芦甜度为0。请注意，&quot;ba&quot;和&quot;ab&quot;被视为同一种糖葫芦。</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>这题可以使用暴力完成，因为它的长度只有<span class="math inline">\(n\le 200\)</span>。</p><p>使用一个集合<span class="math inline">\(S\)</span>存储一些字符串。枚举输入的字符串<span class="math inline">\(s\)</span>中的每个子串，判断它是否已经存在了<span class="math inline">\(S\)</span>中，如果不存在，那么就暴力求它的甜度值出来存放在另一个数组<span class="math inline">\(A\)</span>中，并将<span class="math inline">\(s\)</span>和<span class="math inline">\(s\)</span>的逆序存入<span class="math inline">\(S\)</span>中。</p><p>最终将<span class="math inline">\(A\)</span>排序后，输出第<span class="math inline">\(k\)</span>大的值即可，当然如果<span class="math inline">\(A\)</span>的长度不足<span class="math inline">\(k\)</span>，那么输出<span class="math inline">\(-1\)</span>。</p><h2 id="代码-2">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">n, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">st = <span class="built_in">set</span>()</span><br><span class="line">a = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">        t = s[i:j + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> t <span class="keyword">in</span> st:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        st.add(t)</span><br><span class="line">        st.add(t[::-<span class="number">1</span>])</span><br><span class="line">        a.append(<span class="built_in">sum</span>(<span class="built_in">ord</span>(ch) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) <span class="keyword">for</span> ch <span class="keyword">in</span> t))</span><br><span class="line"></span><br><span class="line">a.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(-<span class="number">1</span> <span class="keyword">if</span> k &gt; <span class="built_in">len</span>(a) <span class="keyword">else</span> a[k - <span class="number">1</span>])</span><br></pre></td></tr></table></figure><h1 id="小红合并数组">4、小红合并数组</h1><p>小红拿到了一个数组，她可以进行以下操作：选择两个相同的元素<span class="math inline">\(x\)</span>，将它们删除，并将<span class="math inline">\(2x\)</span>添加进数组。这种操作称为一次“合并”。</p><p>小红在进行合并之前可以先往数组里添加任意一个元素。之后小红希望最大化“合并”的次数。请你帮帮小红。</p><h2 id="输入-3">输入</h2><p>第一行输入一个正整数<span class="math inline">\(n\)</span>，代表数组的大小。</p><p>第二行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(a_i\)</span>，代表小红拿到的数组。</p><ul><li><span class="math inline">\(1\le n \le 10^5\)</span></li><li><span class="math inline">\(1 \le a_i \le 10^9\)</span></li></ul><h2 id="输出-3">输出</h2><p>输出两个整数，第一个数为添加的元素，第二个数为合并的最大次数。</p><p>如果有多种添加的方案，输出任意一个即可。</p><h2 id="样例-3">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">1 1 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">3 2</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">添加3后，数组变成[1,1,3,3]，可以合并两次。</span><br><span class="line">添加2也是可以的，依然可以合并2次。</span><br></pre></td></tr></table></figure><h2 id="解答-3">解答</h2><p>可见，无论一开始对<span class="math inline">\(a\)</span>怎么操作，到最后无法合并时，<span class="math inline">\(a\)</span>中的所有数都只出现了一次。并且，按照二进制中“进位”的性质，无论执行操作的次序如何，到最后无法合并时，最终得到的数组总是同一个数组（与其说是数组，不如说是集合<span class="math inline">\(S\)</span>，因为这些数都是无序的）。</p><p>对于一个新加入的<span class="math inline">\(x\)</span>，如果<span class="math inline">\(x,2x,4x,8x,\dots,2^{k-1}x\)</span>都在数组中，但是<span class="math inline">\(2^kx\)</span>不在数组中，那么我们可以进行<span class="math inline">\(k\)</span>次合并操作，并且最终得到新的数<span class="math inline">\(2^kx\)</span>。</p><p>因此，考虑已经对<span class="math inline">\(a\)</span>进行完了所有操作，得到数组<span class="math inline">\(a&#39;\)</span>，这时数组<span class="math inline">\(a&#39;\)</span>没有办法再进行下一步操作，我们将<span class="math inline">\(a&#39;\)</span>看成是一个集合<span class="math inline">\(S\)</span>。枚举<span class="math inline">\(S\)</span>中的每个数<span class="math inline">\(x\)</span>，作为一开始要添加到数组<span class="math inline">\(a\)</span>中的数，然后找到最大的<span class="math inline">\(k\)</span>使得<span class="math inline">\(x,2x,4x,8x,\dots,2^{k-1}x\)</span>都在数组中，但是<span class="math inline">\(2^kx\)</span>不在数组中。这时我们就可以多进行<span class="math inline">\(k\)</span>次操作。由于整个操作的过程中，数组的元素和保持不变，因此这个<span class="math inline">\(k\)</span>值也会很小，直接枚举即可。</p><p>最终，找到最大的<span class="math inline">\(k\)</span>值和对应的<span class="math inline">\(x\)</span>，那么总操作次数为<span class="math inline">\(n-|S|+k\)</span>。</p><h2 id="代码-3">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"></span><br><span class="line">ll a[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    unordered_set&lt;ll&gt;st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ll x=a[i];</span><br><span class="line">        <span class="keyword">while</span>(st.<span class="built_in">count</span>(x))&#123;</span><br><span class="line">            st.<span class="built_in">erase</span>(x);</span><br><span class="line">            x&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        st.<span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    ll k=<span class="number">0</span>;<span class="type">int</span> v=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll x:st)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;st.<span class="built_in">count</span>(x/<span class="number">2</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;st.<span class="built_in">count</span>(x&lt;&lt;j);++j);</span><br><span class="line">        <span class="keyword">if</span>(j&gt;v)&#123;</span><br><span class="line">            k=x;v=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %d\n&quot;</span>,k,n-st.<span class="built_in">size</span>()+v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小红统计子数组">5、小红统计子数组</h1><p>小红拿到了一个大小为<span class="math inline">\(n\)</span>的数组，她想知道，有多少个连续子数组满足，该子数组所有元素的乘积是<span class="math inline">\(k\)</span>的倍数？</p><h2 id="输入-4">输入</h2><p>第一行输入两个正整数<span class="math inline">\(n\)</span>和<span class="math inline">\(k\)</span>。</p><p>第二行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(a_i\)</span>。</p><ul><li><span class="math inline">\(1\le n \le 10^5\)</span></li><li><span class="math inline">\(1\le a_i \le 10^6\)</span></li><li><span class="math inline">\(1\le k \le 10^{12}\)</span></li></ul><h2 id="输出-4">输出</h2><p>满足条件的子数组数量。</p><h2 id="样例-4">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3 6</span><br><span class="line">2 3 4</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="解答-4">解答</h2><p>这题我们可以很轻易地想到使用双指针来解决。令<span class="math inline">\(\displaystyle{s_i=\prod_{j=1}^ia_j,s_0=1}\)</span>为数组<span class="math inline">\(a\)</span>的前缀积，那么区间<span class="math inline">\(a[l:r]\)</span>的子数组元素之积可以表示成<span class="math inline">\(\dfrac{s_r}{s_{l-1}}\)</span>。枚举每个右指针<span class="math inline">\(r\)</span>，找到一个最小的<span class="math inline">\(l(0\le l\le r)\)</span>满足<span class="math inline">\(\dfrac{s_r}{s_l}\)</span>不是<span class="math inline">\(k\)</span>的倍数。那么<span class="math inline">\(\forall i=[0,l)\)</span>，子数组<span class="math inline">\(a[i+1,r]\)</span>都是<span class="math inline">\(k\)</span>的倍数，将这<span class="math inline">\(l\)</span>个数都统计进答案即可。时间复杂度为<span class="math inline">\(O(n)\)</span>。</p><p>但是问题在于，前缀积<span class="math inline">\(s_i\)</span>的值可能很大。如何进行优化？</p><p>考虑<span class="math inline">\(k\)</span>这个数，如果一个数是<span class="math inline">\(k\)</span>的倍数，那么对于它所有在<span class="math inline">\(k\)</span>中的质因子的出现次数都至少是<span class="math inline">\(k\)</span>对应的质因子的出现次数。更正式的说，令<span class="math inline">\(k\)</span>的质因数分解为<span class="math inline">\(\displaystyle{k=\prod_{i=1}^mp_i^{e_i}}\)</span>，那么如果一个数<span class="math inline">\(n\)</span>满足它是<span class="math inline">\(k\)</span>的倍数，那么<span class="math inline">\(\forall i\in[1,m],n\)</span>至少有<span class="math inline">\(e_i\)</span>个质因子<span class="math inline">\(p_i\)</span>。</p><p>这启发我们可以换另外一种思路，将一个前缀积转化为多个前缀和的做法。首先构造<span class="math inline">\(m\)</span>个数组<span class="math inline">\(b_i\)</span>，其中<span class="math inline">\(b_{i,j}\)</span>表示<span class="math inline">\(a_j\)</span>包含的质因子<span class="math inline">\(p_i\)</span>的个数，令<span class="math inline">\(\displaystyle{t_{i,j}=\sum_{k=1}^jb_{i,k},b_{i,0}=0}\)</span>，也就是说，<span class="math inline">\(t_{i,j}\)</span>其实是<span class="math inline">\(s_{i,j}\)</span>中因子<span class="math inline">\(p_i\)</span>的次数，这时我们上面类似的思路，同样采用如下双指针法，即可完成本题：枚举每个右指针<span class="math inline">\(r\)</span>，找到一个最小的<span class="math inline">\(l(0\le l\le r)\)</span>。使得存在<span class="math inline">\(i\in[1,m],t_{i,r}-t_{i,l}&lt;e_i\)</span>成立，类似的，将<span class="math inline">\(l\)</span>统计进答案即可。时间复杂度为<span class="math inline">\(O(n\log k+\sqrt{k})\)</span>，足以通过本题。</p><h2 id="代码-4">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"></span><br><span class="line">n, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">a = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">fact = <span class="built_in">list</span>(sympy.factorint(k).items())</span><br><span class="line">ls = [[<span class="number">0</span>] * <span class="built_in">len</span>(fact)]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> a:</span><br><span class="line">    b = ls[-<span class="number">1</span>].copy()</span><br><span class="line">    <span class="keyword">for</span> i, (p, r) <span class="keyword">in</span> <span class="built_in">enumerate</span>(fact):</span><br><span class="line">        <span class="keyword">while</span> x % p == <span class="number">0</span>:</span><br><span class="line">            x //= p</span><br><span class="line">            b[i] += <span class="number">1</span></span><br><span class="line">    ls.append(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">l, r</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(fact)):</span><br><span class="line">        <span class="keyword">if</span> ls[r][i] - ls[l][i] &lt; fact[i][<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">l = <span class="number">0</span></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> check(l, r) <span class="keyword">and</span> l &lt; r:</span><br><span class="line">        l = l + <span class="number">1</span></span><br><span class="line">    ans += l</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论32 Problems 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-Problems/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-Problems/</id>
    <published>2023-10-07T16:57:31.000Z</published>
    <updated>2023-10-07T16:57:31.884Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">32-1</h1><h2 id="a">a</h2><p>首先使用KMP算法计算出<span class="math inline">\(\pi\)</span>数组，分两种情况进行考虑：</p><ul><li><p>如果<span class="math inline">\(i\bmod(i-\pi[i])=0\)</span>，那么有<span class="math inline">\(\rho(P[:i])=\dfrac{i}{i-\pi[i]}\)</span>，这意味<span class="math inline">\(P[i-\pi[i]+1:i]=P[1:\pi[i]]\)</span>，那也就是说，<span class="math inline">\(P[\pi[i]+1:2\pi[i]]=P[1,\pi[i]]\)</span>，类似的，有<span class="math inline">\(P[i-2\pi [i]+1:i]=P[i-\pi[i]+1:i]\)</span>，最终多次迭代下去，可以发现这是一个周期为<span class="math inline">\(\dfrac{i}{i-\pi[i]}\)</span>的字符串，此外，由于<span class="math inline">\(\forall k\in \pi^{\ast}[i]\)</span>，都有<span class="math inline">\(k\le \pi[i]\)</span>，因此<span class="math inline">\(i-\pi[i]\)</span>是<span class="math inline">\(i\)</span>满足条件的最小因子，它将使值<span class="math inline">\(\dfrac{i}{i-k}\)</span>达到最大，因此原结论成立。</p></li><li><p>如果<span class="math inline">\(i\bmod (i-\pi[i])\neq0\)</span>，那么<span class="math inline">\(\rho(P[:i])=1\)</span>。因为，对于一个非周期字符串<span class="math inline">\(s\)</span>（如果是周期字符串，那么可以归约到最小非周期字符串），如果存在一个正整数<span class="math inline">\(r\)</span>满足<span class="math inline">\(s^r=P[i]\)</span>，那么有<span class="math inline">\(r\mid i\)</span>。然而按照上面的方式依次取出<span class="math inline">\(r\)</span>个字母，它们不能取完整，因此这时<span class="math inline">\(P[:i]\)</span>只能由自身拼接<span class="math inline">\(1\)</span>次而成，原结论成立。</p></li></ul><p>算法<code>COMPUTE-PREFIX-RHO</code>给出了具体过程，可见其时间复杂度为<span class="math inline">\(O(n)\)</span>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">COMPUTE-PREFIX-RHO(P, m)</span><br><span class="line">  π = COMPUTE-PREFIX-FUNCTION(P, m)</span><br><span class="line">  let ρ[1 : m] be a new array</span><br><span class="line">  for i = 1 to m</span><br><span class="line">    if i % (i - π[i]) == 0</span><br><span class="line">      ρ[i] = i / (i - π[i])</span><br><span class="line">    else</span><br><span class="line">      ρ[i] = 1</span><br><span class="line">  return ρ</span><br></pre></td></tr></table></figure><h2 id="b">b</h2><p>待研究，相关链接：</p><ul><li><a href="https://www.sciencedirect.com/science/article/pii/0022000083900028">该算法相关的论文</a></li><li><a href="https://oeis.org/A216955">相关数列1</a></li><li><a href="https://oeis.org/A217941">相关数列2</a></li></ul><h2 id="c">c</h2><p>同题目32-1-b。</p><h1 id="section-1">32-2</h1><h2 id="a-1">a</h2><p>假设目前需要对比<span class="math inline">\(P\)</span>中非空后缀<span class="math inline">\(i\)</span>和<span class="math inline">\(j\)</span>，令<span class="math inline">\(P[i]\)</span>表示<span class="math inline">\(P\)</span>的第<span class="math inline">\(i\)</span>个元字符。如下考虑多种情况：</p><ol type="1"><li><p>如果<span class="math inline">\(P[i]\neqP[j]\)</span>，那么第<span class="math inline">\(i\)</span>个非空后缀和第<span class="math inline">\(j\)</span>个非空后缀的字典序由<span class="math inline">\(P[i]\)</span>和<span class="math inline">\(P[j]\)</span>决定，此时和<span class="math inline">\(P[i],P[j]\)</span>后面的字符没有任何关系，因此原结论成立。</p></li><li><p>如果<span class="math inline">\(P[i]=P[j]\)</span>，考虑<span class="math inline">\(i,j\)</span>都在<span class="math inline">\(P\)</span>中<span class="math inline">\(P_1\)</span>所占有的下标。可见，由于<span class="math inline">\(P_1[i:]\varnothing\)</span>和<span class="math inline">\(P_1[j:]\varnothing\)</span>的长度不同，并且最后一个字符<span class="math inline">\(\varnothing\)</span>都小于已经出现的字符，因此它们的字典序已经确定。此时再在独立的字符串<span class="math inline">\(P_1[i:]\varnothing,P_1[j:]\varnothing\)</span>后面再添加字符也不会改变<span class="math inline">\(P_1[i:]\varnothing\)</span>和<span class="math inline">\(P_1[j:]\)</span>的字典序。因此原结论成立。接下来考虑<span class="math inline">\(i,j\)</span>都在<span class="math inline">\(P\)</span>中<span class="math inline">\(P_2\)</span>所占有的下标，明显原结论成立，因为这些后缀恰好是<span class="math inline">\(P_2\)</span>的后缀。</p></li><li><p>如果<span class="math inline">\(P[i]=P[j]\)</span>，考虑<span class="math inline">\(i,j\)</span>在<span class="math inline">\(P\)</span>中，其中一个在<span class="math inline">\(P_1\)</span>所占有的下标，另一个在<span class="math inline">\(P_2\)</span>所占有的下标。不失一般性，假设<span class="math inline">\(i\)</span>属于前者，<span class="math inline">\(j\)</span>属于后者，那么不难得到<span class="math inline">\(i&lt;j\)</span>。由于此时<span class="math inline">\(P[i]=P[j]\)</span>，因此我们继续向下找下一个下标，直到满足这两个元字符不相同，即最小的正整数<span class="math inline">\(s\)</span>，使得<span class="math inline">\(P[i+s]\neq P[j+s]\)</span>。可以发现<span class="math inline">\(i+s\)</span>仍会在<span class="math inline">\(P_1\)</span>占有的下标中。按照步骤A的作用，<span class="math inline">\(P_1\)</span>必定会包含一个出现<span class="math inline">\(\varnothing\)</span>的元字符，因此第<span class="math inline">\(i\)</span>个非空后缀不晚于这个元字符结束。由于<span class="math inline">\(n&#39;\not\equiv n&#39;&#39;\pmod3\)</span>，因此<span class="math inline">\(i\)</span>个非空后缀和第<span class="math inline">\(j\)</span>个非空后缀必定是以不同数量的<span class="math inline">\(\varnothing\)</span>元字符作为结尾，此外由于<span class="math inline">\(\varnothing\)</span>的字典序最小，再在它们的后面任意添加字符也不会改变这两个非空后缀的字典序，因此原结论成立。</p></li></ol><p>因此，<span class="math inline">\(P\)</span>的非空后缀的排名和<span class="math inline">\(P\)</span>的后缀排名是相同的。由于早在<span class="math inline">\(\varnothing\)</span>的时候就已经确定了排名，去除<span class="math inline">\(\varnothing\)</span>后面的字符并不影响后缀的排名，因此<span class="math inline">\(P\)</span>中的后缀排名和<span class="math inline">\(T\)</span>的采样后缀的相对排名是一致的，因此原结论成立。</p><h2 id="b-1">b</h2><p>由于每个元字符都恰好是一个三元组，因此我们可以使用基数排序完成，只需要进行三趟。由于字符的大小有限，因此每趟基数排序的内部使用计数排序，最终可以在<span class="math inline">\(\Theta(n)\)</span>的时间内完成这个排序过程。需要注意的是，由于前面的字符占主导地位，因此基数排序过程是对这些三元组中的每个字符从后往前进行。如下算法<code>SA-SORT-CHARACTERS</code>给出了这个过程，可见其时间复杂度为<span class="math inline">\(\Theta(n)\)</span>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 假设字符出P中的每个字符用三元组(s[1], s[2], s[3])表示，分别表示元字符中的第一、第二和第三个字符。</span><br><span class="line">SA-SORT-CHARACTERS(P, n)</span><br><span class="line">  // L数组中的元素有两个属性：s属性是对应下标的元字符，index属性表示当前字符的下标。</span><br><span class="line">  let L[1 : n], L&#x27;[1 : n], P&#x27;[1 : n] be new arrays</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    L[i].index = i</span><br><span class="line">    L[i].s = P[i].s</span><br><span class="line">  mx = 0</span><br><span class="line">  // 这里使用mx表示元字符中，所有内部字符的最大大小。</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    mx = max&#123;mx, P[i].s[1], P[i].s[2], P[i].s[3]&#125;</span><br><span class="line">  let cnt[0 : mx] be a new array</span><br><span class="line">  for d = 3 downto 1</span><br><span class="line">    for j = 0 to mx</span><br><span class="line">      cnt[j] = 0 </span><br><span class="line">    for i = 1 to n</span><br><span class="line">      cnt[L[i].s[d]] = cnt[L[i].s[d]] + 1</span><br><span class="line">    for j = 1 to mx</span><br><span class="line">      cnt[j] = cnt[j - 1] + cnt[j]</span><br><span class="line">    for i = n downto 1</span><br><span class="line">      L&#x27;[cnt[L[i].s[d]]] = L[i]</span><br><span class="line">      cnt[L[i].s[d]] = cnt[L[i].s[d]] - 1</span><br><span class="line">    L = L&#x27;</span><br><span class="line">  r = 1</span><br><span class="line">  P&#x27;[L[1].index] = 1</span><br><span class="line">  for i = 2 to n</span><br><span class="line">    if L[i].s != L[i - 1].s</span><br><span class="line">      r = r + 1</span><br><span class="line">    P&#x27;[L[i].index] = r</span><br><span class="line">  return P&#x27;</span><br></pre></td></tr></table></figure><h2 id="c-1">c</h2><p>假设后缀<span class="math inline">\(P[i:]\)</span>是非采样后缀，那么有<span class="math inline">\(r_i=\square,r_{i+1}\)</span>是一个非负整数。如果<span class="math inline">\(r_i\neq \square\)</span>，那么说明<span class="math inline">\(r_i\)</span>是进行递归后，对应采样后缀的排名，因此这些<span class="math inline">\(r_i\)</span>是非负整数的情况下是唯一的，因此这使得二元组<span class="math inline">\((T[i],r_{i+1})\)</span>是唯一的。</p><p>由于原字符<span class="math inline">\(T[i]\)</span>的范围非常小，因此我们同样可以使用题目32-2-b的思路，使用基数排序（每趟内部使用计数排序）对这些二元组进行排序。如下算法<code>SA-SORT-CHARACTERS</code>给出了这个过程，可见其时间复杂度为<span class="math inline">\(\Theta(n)\)</span>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">SA-SORT-NONSAMPLE-SUFFIXES(T, r, n)</span><br><span class="line">  n&#x27; = ⌊n / 3⌋</span><br><span class="line">  let L[1 : n&#x27;], L&#x27;[1 : n&#x27;], nonsapmle[1 : n&#x27;] be new arrays</span><br><span class="line">  for i = 3 to n by 3</span><br><span class="line">    let L[i / 3].t[1 : 2] be a new array</span><br><span class="line">    L[i / 3].t[1] = T[i]</span><br><span class="line">    L[i / 3].t[2] = r[i + 1]</span><br><span class="line">    L[i / 3].index = i</span><br><span class="line">  mx = 0</span><br><span class="line">  // 这里使用mx表示元字符中，所有字符的大小。</span><br><span class="line">  for i = 1 to n&#x27;</span><br><span class="line">    mx = max&#123;mx, L[i].t[1], L[i].t[2]&#125;</span><br><span class="line">  let cnt[0 : mx] be a new array</span><br><span class="line">  for d = 2 downto 1</span><br><span class="line">    for j = 0 to mx</span><br><span class="line">      cnt[j] = 0 </span><br><span class="line">    for i = 1 to n&#x27;</span><br><span class="line">      cnt[L[i].t[d]] = cnt[L[i].t[d]] + 1</span><br><span class="line">    for j = 1 to mx</span><br><span class="line">      cnt[j] = cnt[j - 1] + cnt[j]</span><br><span class="line">    for i = n&#x27; downto 1</span><br><span class="line">      L&#x27;[cnt[L[i].s[d]]] = L[i]</span><br><span class="line">      cnt[L[i].s[d]] = cnt[L[i].s[d]] - 1</span><br><span class="line">    L = L&#x27;</span><br><span class="line">  return L</span><br></pre></td></tr></table></figure><h2 id="d">d</h2><p>假设字符串<span class="math inline">\(T\)</span>后面已经拼接了两个<span class="math inline">\(\varnothing\)</span>，对应到<span class="math inline">\(r\)</span>数组中其值为<span class="math inline">\(0\)</span>，也就是说，字符串<span class="math inline">\(T\)</span>现在的长度为<span class="math inline">\(n+2\)</span>。</p><p>其基本思想是，对于任意一对下标<span class="math inline">\(i,j(i\not\equiv j\pmod 3,1\le i,j\len)\)</span>，只要最多比较三次就能比较出字典序。也就是说，只要比对<span class="math inline">\((P[i],P[j]),(P[i+1],P[j+1]),(P[i+2],P[j+2])\)</span>即可。可以发现，必定存在最小的<span class="math inline">\(s(0\le s\le 2)\)</span>，使得<span class="math inline">\(r_{i+s}\neq\square\landr_{j+s}\neq\square\)</span>。</p><p>具体过程由<code>SA-SORT-MERGE</code>给出，它将原有的<span class="math inline">\(r\)</span>数组以及题目32-2-d所排好序的二元组进行归并，返回最终得到的<span class="math inline">\(SA\)</span>数组。最终这个过程在<span class="math inline">\(\Theta(n)\)</span>的时间内完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// 字符串T的长度为n+2，包括后面已经拼接了两个∅，r[n + 1] = r[n + 2] = 0。</span><br><span class="line">// 数组r如题意所示。</span><br><span class="line">// 数组nonsample是已经排好序的非采样后缀的下标，保证其大小为⌊n / 3⌋。</span><br><span class="line">SA-SORT-MERGE(T, r, nonsample, n)</span><br><span class="line">  n&#x27; = ⌊n / 3⌋</span><br><span class="line">  sample-choice = 1</span><br><span class="line">  nonsample-choice = 2</span><br><span class="line">  let sample[1 : n - n&#x27;] be a new array</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    if i % 3 != 0</span><br><span class="line">      sample[r[i]] = i</span><br><span class="line">  let SA[1 : n] be a new array</span><br><span class="line">  ls = 1</span><br><span class="line">  ln = 1</span><br><span class="line">  k = 1</span><br><span class="line">  while ls &lt;= n - n&#x27; and ln &lt;= n&#x27;</span><br><span class="line">    p = sample[ls]</span><br><span class="line">    q = nonsample[ln]</span><br><span class="line">    if T[p] != T[q]</span><br><span class="line">      if T[p] &lt; T[q]</span><br><span class="line">        choice = sample-choice</span><br><span class="line">      else</span><br><span class="line">        choice = nonsample-choice</span><br><span class="line">    else if p % 3 == 1</span><br><span class="line">      // 此时r[p + 1] != □必定成立</span><br><span class="line">      if r[p + 1] &lt; r[q + 1]</span><br><span class="line">        choice = sample-choice</span><br><span class="line">      else</span><br><span class="line">        choice = nonsample-choice</span><br><span class="line">    else</span><br><span class="line">      // 此时r[p + 1] != □必定成立</span><br><span class="line">      if T[p + 1] &lt; T[q + 1] or T[p + 1] == T[q + 1] and r[p + 2] &lt; r[q + 2]</span><br><span class="line">        choice = sample-choice</span><br><span class="line">      else</span><br><span class="line">        choice = nonsample-choice</span><br><span class="line">    if choice == sample-choice</span><br><span class="line">      SA[k] = p</span><br><span class="line">      k = k + 1</span><br><span class="line">      ls = ls + 1</span><br><span class="line">    else</span><br><span class="line">      SA[k] = q</span><br><span class="line">      k = k + 1</span><br><span class="line">      ln = ln + 1</span><br><span class="line">  while ls &lt;= n - n&#x27;</span><br><span class="line">    SA[k] = sample[ls]</span><br><span class="line">    k = k + 1</span><br><span class="line">    ls = ls + 1</span><br><span class="line">  while ls &lt;= n&#x27;</span><br><span class="line">    SA[k] = nonsample[ls]</span><br><span class="line">    k = k + 1</span><br><span class="line">    ln = ln + 1</span><br><span class="line">  return SA</span><br></pre></td></tr></table></figure><h2 id="e">e</h2><p>综上所述：</p><ol type="1"><li><p>步骤1进行的是第一步分治。子步骤A和B花费了<span class="math inline">\(\Theta(n)\)</span>的时间来构造字符串<span class="math inline">\(P,P_1,P_2\)</span>。子步骤C使用了题目32-2-b的算法，对字符串<span class="math inline">\(P\)</span>中的字符进行排序，并通过子步骤D进行产生<span class="math inline">\(P\)</span>中每个字符的排名，存在数组<span class="math inline">\(P&#39;\)</span>中，这个过程使用了基数排序和计数排序的方法，总共花费了<span class="math inline">\(\Theta(n)\)</span>的时间。子步骤E递归构造<span class="math inline">\(P&#39;\)</span>的<span class="math inline">\(SA\)</span>数组，由于其长度为<span class="math inline">\(2n/3\)</span>，因此需要花费<span class="math inline">\(T(2n/3)\)</span>的时间。子步骤F则使用<span class="math inline">\(\Theta(n)\)</span>的时间将<span class="math inline">\(P&#39;\)</span>的<span class="math inline">\(SA\)</span>数组映射回采样后缀中。</p></li><li><p>步骤2进行的是第二步分治。子步骤G使用<span class="math inline">\(\Theta(n)\)</span>的时间求出<span class="math inline">\(r\)</span>数组。子步骤H使用了题目32-2-c的算法，对<span class="math inline">\((T[i],r_{i+1})\)</span>二元组进行排序，由于同样使用了基数排序和计数排序的方法，因此总共花费了<span class="math inline">\(\Theta(n)\)</span>的时间。</p></li><li><p>步骤3进行的是归并。它将两个分支步骤的结果进行归并。使用题目32-2-d的算法在<span class="math inline">\(\Theta(n)\)</span>时间内求出最终的<span class="math inline">\(SA\)</span>数组。</p></li></ol><p>因此，除了步骤1的子步骤E需要求解规模为<span class="math inline">\(2n/3\)</span>的子问题，其余步骤都需要花费<span class="math inline">\(\Theta(n)\)</span>的时间进行处理，因此有<span class="math inline">\(T(n)=T(2n/3)+\Theta(n)\)</span>。按照主定理，有<span class="math inline">\(T(n)=\Theta(n)\)</span>，因此这是一个线性时间求解<span class="math inline">\(SA\)</span>数组的算法。</p><h1 id="section-2">32-3</h1><h2 id="a-2">a</h2><p>需要注意的是，拼接的字符<span class="math inline">\(\mathtt{\$}\)</span>的字典序是所有字符中最小的。可以假定，在为字符串构造SA数组时，它后面都有一个终结符<span class="math inline">\(\mathtt{\$}\)</span>。因此，在对所有后缀排好序后，可以发现每个后缀的排名都是唯一的，此时在这些后缀后面如何加字符，都不会影响它们原本的排名。因此，BWT只需要挪用<span class="math inline">\(SA\)</span>数组的结果即可，不过需要先在<span class="math inline">\(SA\)</span>数组的最前面再插入一个值<span class="math inline">\(|T|+1\)</span>，那么这时的结果才是BWT数组产生的结果。最终，字符串<span class="math inline">\(t[i]=T[(BWT [i]-1-1)\bmod (|T|+1) +1]\)</span>才是BWT的结果。更具体的过程由<code>BWT-KNOWN-SA</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BWT-KNOWN-SA(T, SA, n)</span><br><span class="line">  let BWT[1 : n + 1] be a new array</span><br><span class="line">  W = T$</span><br><span class="line">  t = T[n]</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    t = t W[(SA[i] - 1 - 1) mod (n + 1) + 1]</span><br><span class="line">  return t</span><br></pre></td></tr></table></figure><h2 id="b-2">b</h2><p>基于插入排序的思想就可以计算出每个下标的排名，如下给出<code>BWT-COMPUTE-RANK</code>将给出计算<span class="math inline">\(rank\)</span>数组的算法。如果字母表中一共有<span class="math inline">\(k\)</span>个字符，并且其范围是从<span class="math inline">\(1\)</span>到<span class="math inline">\(k\)</span>，那么<code>BWT-COMPUTE-RANK</code>计算<span class="math inline">\(rank\)</span>数组的时间复杂度为<span class="math inline">\(\Theta(n+k)\)</span>。如果<span class="math inline">\(k=O(n)\)</span>或者是一个常数，那么就有<span class="math inline">\(\Theta(n+k)=\Theta(n)\)</span>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BWT-COMPUTE-RANK(T, n, k)</span><br><span class="line">  let C[0 : k], rank[1 : n] be new arrays by 0</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    C[T[i]] = C[T[i]] + 1</span><br><span class="line">  for i = 1 to k</span><br><span class="line">    C[i] = C[i] + C[i-1]</span><br><span class="line">  for i = n downto 1</span><br><span class="line">    rank[i] = C[T[i]]</span><br><span class="line">    C[T[i]] = C[T[i]] - 1</span><br><span class="line">  return rank</span><br></pre></td></tr></table></figure><h2 id="c-2">c</h2><p>只需要按照题目的含义进行模拟即可，先从<span class="math inline">\(\mathtt{\$}\)</span>开始填充，因为它必定处于最后一位。整个过程由<code>BWT-INV</code>给出，可见其由于只有一个<code>for</code>循环进行常数操作，因此其时间复杂度为<span class="math inline">\(\Theta O(n)\)</span>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BWT-INV-RANK(T, rank, n)</span><br><span class="line">  let S[1 : n] be a new array</span><br><span class="line">  pos = 0</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    if T[i] == $</span><br><span class="line">      pos = i</span><br><span class="line">  for i = n downto 1</span><br><span class="line">    S[i] = T[pos]</span><br><span class="line">    pos = rank[pos]</span><br><span class="line">  interpret S[1 : n - 1] as a string s</span><br><span class="line">  return s</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论32.5 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-5-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-5-Exercises/</id>
    <published>2023-10-07T16:57:28.000Z</published>
    <updated>2023-10-07T16:57:28.858Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">32.5-1</h1><p>如下两表，是分别执行完<code>COMPUTE-SUFFIX-ARRAY</code>的第2-7行和第8行后的结果。</p><p><span class="math inline">\(\begin{array}{ccccl}i&amp;left\text{-}rank&amp;right\text{-}rank&amp;index&amp;\text{substring}\\\hline1&amp;8&amp;9&amp;1&amp;\texttt{hi}\\2&amp;9&amp;16&amp;2&amp;\texttt{ip}\\3&amp;16&amp;16&amp;3&amp;\texttt{pp}\\4&amp;16&amp;9&amp;4&amp;\texttt{pi}\\5&amp;9&amp;20&amp;5&amp;\texttt{it}\\6&amp;20&amp;25&amp;6&amp;\texttt{ty}\\7&amp;25&amp;8&amp;7&amp;\texttt{yh}\\8&amp;8&amp;15&amp;8&amp;\texttt{ho}\\9&amp;15&amp;16&amp;9&amp;\texttt{op}\\10&amp;16&amp;16&amp;10&amp;\texttt{pp}\\11&amp;16&amp;9&amp;11&amp;\texttt{pi}\\12&amp;9&amp;20&amp;12&amp;\texttt{it}\\13&amp;20&amp;25&amp;13&amp;\texttt{ty}\\14&amp;25&amp;0&amp;14&amp;\texttt{y}\\ \end{array} \qquad\begin{array}{ccccl}i&amp;left\text{-}rank&amp;right\text{-}rank&amp;index&amp;\text{substring}\\\hline1&amp;8&amp;9&amp;1&amp;\texttt{hi}\\2&amp;8&amp;15&amp;8&amp;\texttt{ho}\\3&amp;9&amp;16&amp;2&amp;\texttt{ip}\\4&amp;9&amp;20&amp;5&amp;\texttt{it}\\5&amp;9&amp;20&amp;12&amp;\texttt{it}\\6&amp;15&amp;16&amp;9&amp;\texttt{op}\\7&amp;16&amp;9&amp;4&amp;\texttt{pi}\\8&amp;16&amp;9&amp;11&amp;\texttt{pi}\\9&amp;16&amp;16&amp;3&amp;\texttt{pp}\\10&amp;16&amp;16&amp;10&amp;\texttt{pp}\\11&amp;20&amp;25&amp;6&amp;\texttt{ty}\\12&amp;20&amp;25&amp;13&amp;\texttt{ty}\\13&amp;25&amp;0&amp;14&amp;\texttt{y}\\14&amp;25&amp;8&amp;7&amp;\texttt{yh}\\ \end{array}\)</span></p><p>当<span class="math inline">\(l=2\)</span>时，分别执行完<code>COMPUTE-SUFFIX-ARRAY</code>的第11行，第12-17行和第18行的结果如下三个表所示。</p><p><span class="math inline">\(\begin{array}{ccl}i&amp;rank&amp;\text{substring}\\\hline 1&amp;1&amp;\texttt{hi}\\2&amp;3&amp;\texttt{ip}\\ 3&amp;7&amp;\texttt{pp}\\4&amp;6&amp;\texttt{pi}\\ 5&amp;4&amp;\texttt{it}\\6&amp;8&amp;\texttt{ty}\\ 7&amp;10&amp;\texttt{yh}\\8&amp;2&amp;\texttt{ho}\\ 9&amp;5&amp;\texttt{op}\\10&amp;7&amp;\texttt{pp}\\ 11&amp;6&amp;\texttt{pi}\\12&amp;4&amp;\texttt{it}\\ 13&amp;8&amp;\texttt{ty}\\14&amp;9&amp;\texttt{y}\\ \end{array}\qquad \begin{array}{ccccl}i&amp;left\text{-}rank&amp;right\text{-}rank&amp;index&amp;\text{substring}\\\hline1&amp;1&amp;7&amp;1&amp;\texttt{hipp}\\2&amp;3&amp;6&amp;2&amp;\texttt{ippi}\\3&amp;7&amp;4&amp;3&amp;\texttt{ppit}\\4&amp;6&amp;8&amp;4&amp;\texttt{pity}\\5&amp;4&amp;10&amp;5&amp;\texttt{ityh}\\6&amp;8&amp;2&amp;6&amp;\texttt{tyho}\\7&amp;10&amp;5&amp;7&amp;\texttt{yhop}\\8&amp;2&amp;7&amp;8&amp;\texttt{hopp}\\9&amp;5&amp;6&amp;9&amp;\texttt{oppi}\\10&amp;7&amp;4&amp;10&amp;\texttt{ppit}\\11&amp;6&amp;8&amp;11&amp;\texttt{pity}\\12&amp;4&amp;9&amp;12&amp;\texttt{ity}\\13&amp;8&amp;0&amp;13&amp;\texttt{ty}\\14&amp;9&amp;0&amp;14&amp;\texttt{y}\\ \end{array}\qquad\begin{array}{ccccl}i&amp;left\text{-}rank&amp;right\text{-}rank&amp;index&amp;\text{substring}\\\hline1&amp;1&amp;7&amp;1&amp;\texttt{hipp}\\2&amp;2&amp;7&amp;8&amp;\texttt{hopp}\\3&amp;3&amp;6&amp;2&amp;\texttt{ippi}\\4&amp;4&amp;9&amp;12&amp;\texttt{ity}\\5&amp;4&amp;10&amp;5&amp;\texttt{ityh}\\6&amp;5&amp;6&amp;9&amp;\texttt{oppi}\\7&amp;6&amp;8&amp;4&amp;\texttt{pity}\\8&amp;6&amp;8&amp;11&amp;\texttt{pity}\\9&amp;7&amp;4&amp;3&amp;\texttt{ppit}\\10&amp;7&amp;4&amp;10&amp;\texttt{ppit}\\11&amp;8&amp;0&amp;13&amp;\texttt{ty}\\12&amp;8&amp;2&amp;6&amp;\texttt{tyho}\\13&amp;9&amp;0&amp;14&amp;\texttt{y}\\14&amp;10&amp;5&amp;7&amp;\texttt{yhop}\\ \end{array}\)</span></p><p>当<span class="math inline">\(l=4\)</span>时，分别执行完<code>COMPUTE-SUFFIX-ARRAY</code>的第11行，第12-17行和第18行的结果如下三个表所示。</p><p><span class="math inline">\(\begin{array}{ccl}i&amp;rank&amp;\text{substring}\\\hline 1&amp;1&amp;\texttt{hipp}\\2&amp;3&amp;\texttt{ippi}\\ 3&amp;8&amp;\texttt{ppit}\\4&amp;7&amp;\texttt{pity}\\ 5&amp;5&amp;\texttt{ityh}\\6&amp;10&amp;\texttt{tyho}\\ 7&amp;12&amp;\texttt{yhop}\\8&amp;2&amp;\texttt{hopp}\\ 9&amp;6&amp;\texttt{oppi}\\10&amp;8&amp;\texttt{ppit}\\ 11&amp;7&amp;\texttt{pity}\\12&amp;4&amp;\texttt{ity}\\ 13&amp;9&amp;\texttt{ty}\\14&amp;11&amp;\texttt{y}\\ \end{array}\qquad \begin{array}{ccccl}i&amp;left\text{-}rank&amp;right\text{-}rank&amp;index&amp;\text{substring}\\\hline1&amp;1&amp;5&amp;1&amp;\texttt{hippityh}\\2&amp;3&amp;10&amp;2&amp;\texttt{ippityho}\\3&amp;8&amp;12&amp;3&amp;\texttt{ppityhop}\\4&amp;7&amp;2&amp;4&amp;\texttt{pityhopp}\\5&amp;5&amp;6&amp;5&amp;\texttt{ityhoppi}\\6&amp;10&amp;8&amp;6&amp;\texttt{tyhoppit}\\7&amp;12&amp;7&amp;7&amp;\texttt{yhoppity}\\8&amp;2&amp;4&amp;8&amp;\texttt{hoppity}\\9&amp;6&amp;9&amp;9&amp;\texttt{oppity}\\10&amp;8&amp;11&amp;10&amp;\texttt{ppity}\\11&amp;7&amp;0&amp;11&amp;\texttt{pity}\\12&amp;4&amp;0&amp;12&amp;\texttt{ity}\\13&amp;9&amp;0&amp;13&amp;\texttt{ty}\\14&amp;11&amp;0&amp;14&amp;\texttt{y}\\ \end{array}\qquad\begin{array}{ccccl}i&amp;left\text{-}rank&amp;right\text{-}rank&amp;index&amp;\text{substring}\\\hline1&amp;1&amp;5&amp;1&amp;\texttt{hippityh}\\2&amp;2&amp;4&amp;8&amp;\texttt{hoppity}\\3&amp;3&amp;10&amp;2&amp;\texttt{ippityho}\\4&amp;4&amp;0&amp;12&amp;\texttt{ity}\\5&amp;5&amp;6&amp;5&amp;\texttt{ityhoppi}\\6&amp;6&amp;9&amp;9&amp;\texttt{oppity}\\7&amp;7&amp;0&amp;11&amp;\texttt{pity}\\8&amp;7&amp;2&amp;4&amp;\texttt{pityhopp}\\9&amp;8&amp;11&amp;10&amp;\texttt{ppity}\\10&amp;8&amp;12&amp;3&amp;\texttt{ppityhop}\\11&amp;9&amp;0&amp;13&amp;\texttt{ty}\\12&amp;10&amp;8&amp;6&amp;\texttt{tyhoppit}\\13&amp;11&amp;0&amp;14&amp;\texttt{y}\\14&amp;12&amp;7&amp;7&amp;\texttt{yhoppity}\\ \end{array}\)</span></p><p>当<span class="math inline">\(l=8\)</span>时，分别执行完<code>COMPUTE-SUFFIX-ARRAY</code>的第11行，第12-17行和第18行的结果如下三个表所示。</p><p><span class="math inline">\(\begin{array}{ccl}i&amp;rank&amp;\text{substring}\\\hline 1&amp;1&amp;\texttt{hippityh}\\2&amp;3&amp;\texttt{ippityho}\\ 3&amp;10&amp;\texttt{ppityhop}\\4&amp;8&amp;\texttt{pityhopp}\\ 5&amp;5&amp;\texttt{ityhoppi}\\6&amp;12&amp;\texttt{tyhoppit}\\ 7&amp;14&amp;\texttt{yhoppity}\\8&amp;2&amp;\texttt{hoppity}\\ 9&amp;6&amp;\texttt{oppity}\\10&amp;9&amp;\texttt{ppity}\\ 11&amp;7&amp;\texttt{pity}\\12&amp;4&amp;\texttt{ity}\\ 13&amp;11&amp;\texttt{ty}\\14&amp;13&amp;\texttt{y}\\ \end{array}\qquad\begin{array}{ccccl}i&amp;left\text{-}rank&amp;right\text{-}rank&amp;index&amp;\text{substring}\\\hline1&amp;1&amp;6&amp;1&amp;\texttt{hippityhoppity}\\2&amp;3&amp;9&amp;2&amp;\texttt{ippityhoppity}\\3&amp;10&amp;7&amp;3&amp;\texttt{ppityhoppity}\\4&amp;8&amp;4&amp;4&amp;\texttt{pityhoppity}\\5&amp;5&amp;11&amp;5&amp;\texttt{ityhoppity}\\6&amp;12&amp;13&amp;6&amp;\texttt{tyhoppity}\\7&amp;14&amp;0&amp;7&amp;\texttt{yhoppity}\\8&amp;2&amp;0&amp;8&amp;\texttt{hoppity}\\9&amp;6&amp;0&amp;9&amp;\texttt{oppity}\\10&amp;9&amp;0&amp;10&amp;\texttt{ppity}\\11&amp;7&amp;0&amp;11&amp;\texttt{pity}\\12&amp;4&amp;0&amp;12&amp;\texttt{ity}\\13&amp;11&amp;0&amp;13&amp;\texttt{ty}\\14&amp;13&amp;0&amp;14&amp;\texttt{y}\\\end{array}\qquad\begin{array}{ccccl}i&amp;left\text{-}rank&amp;right\text{-}rank&amp;index&amp;\text{substring}\\\hline1&amp;1&amp;6&amp;1&amp;\texttt{hippityhoppity}\\2&amp;2&amp;0&amp;8&amp;\texttt{hoppity}\\3&amp;3&amp;9&amp;2&amp;\texttt{ippityhoppity}\\4&amp;4&amp;0&amp;12&amp;\texttt{ity}\\5&amp;5&amp;11&amp;5&amp;\texttt{ityhoppity}\\6&amp;6&amp;0&amp;9&amp;\texttt{oppity}\\7&amp;7&amp;0&amp;11&amp;\texttt{pity}\\8&amp;8&amp;4&amp;4&amp;\texttt{pityhoppity}\\9&amp;9&amp;0&amp;10&amp;\texttt{ppity}\\10&amp;10&amp;7&amp;3&amp;\texttt{ppityhoppity}\\11&amp;11&amp;0&amp;13&amp;\texttt{ty}\\12&amp;12&amp;13&amp;6&amp;\texttt{tyhoppity}\\13&amp;13&amp;0&amp;14&amp;\texttt{y}\\14&amp;14&amp;0&amp;7&amp;\texttt{yhoppity}\\ \end{array}\)</span></p><p>因此，得到的<span class="math inline">\(SA\)</span>数组为<span class="math inline">\([1,8,2,12,5,9,11,4,10,3,13,6,14,7]\)</span>。</p><p>最终，按序填入<span class="math inline">\(LCP\)</span>数组的顺序如下表所示：</p><p><span class="math inline">\(\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}\hlinei&amp;1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8&amp;9&amp;10&amp;11&amp;12&amp;13&amp;14\\\hlines&amp;1&amp;3&amp;10&amp;8&amp;5&amp;12&amp;14&amp;2&amp;6&amp;9&amp;7&amp;4&amp;11&amp;13\\\hlineLCP[i]&amp;0&amp;0&amp;5&amp;4&amp;3&amp;2&amp;1&amp;1&amp;0&amp;1&amp;0&amp;1&amp;0&amp;0\\\hline\end{array}\)</span></p><p>因此，得到的<span class="math inline">\(LCP\)</span>数组为<span class="math inline">\([0,1,0,1,3,0,0,4,1,5,0,2,0,1]\)</span>。</p><h1 id="section-1">32.5-2</h1><p>基本思想是，如果不需要<span class="math inline">\(\lfloor\lgn\rfloor-1\)</span>次<code>while</code>循环就能够区分出所有后缀的排名，那么<code>while</code>循环可以提前终止。</p><p>具体细节是，在<code>MAKE-RANKS</code>的过程中，如果最后一名的后缀的排名已经恰好达到了<span class="math inline">\(n\)</span>，那么可以终止<code>while</code>循环。修改狗的算法由<code>COMPUTE-SUFFIX-ARRAY'</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">COMPUTE-SUFFIX-ARRAY&#x27;(T, n)</span><br><span class="line">  allocate arrays substr-rank[1:n], rank[1:n], and SA[1:n]</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    substr-rank[i].left-rank = ord(T[i])</span><br><span class="line">    if i &lt; n</span><br><span class="line">      substr-rank[i].right-rank = ord(T[i + 1])</span><br><span class="line">    else substr-rank[i].right-rank = 0</span><br><span class="line">    substr-rank[i].index = i</span><br><span class="line">  sort the array substr-rank into monotonically increasing order based on the left-rank attributes, using the right-rank attributes to break ties; if still a tie, the order does not matter</span><br><span class="line">  l = 2</span><br><span class="line">  while l &lt; n</span><br><span class="line">    MAKE-RANKS(substr-rank, rank, n)</span><br><span class="line">    for i = 1 to n</span><br><span class="line">      substr-rank[i].left-rank = rank[i]</span><br><span class="line">      if i + l ≤ n</span><br><span class="line">        substr-rank[i].right-rank = rank[i + l]</span><br><span class="line">      else substr-rank[i].right-rank = 0</span><br><span class="line">      substr-rank[i].index = i</span><br><span class="line">    sort the array substr-rank into monotonically increasing order based on the left-rank attributes, using the right-rank attributes to break ties; if still a tie, the order does not matter</span><br><span class="line">    l = 2 * l</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    SA[i] = substr-rank[i].index</span><br><span class="line">  return SA</span><br></pre></td></tr></table></figure><h1 id="section-2">32.5-3</h1><p>使用一个不曾出现在<span class="math inline">\(T_1,T_2\)</span>中的字符<span class="math inline">\(\texttt{@}\)</span>，并将其和<span class="math inline">\(T_1,T_2\)</span>拼接起来，得到<span class="math inline">\(T=T_1\texttt{@}T_2\)</span>，其长度为<span class="math inline">\(n=n_1+n_2+1\)</span>。对字符串<span class="math inline">\(T\)</span>求出它的<code>SA</code>数组和<code>LCP</code>数组后，枚举<span class="math inline">\(T\)</span>中每对排名相邻的后缀<span class="math inline">\(SA[i],SA[i-1]\)</span>。如果这两个后缀来自<span class="math inline">\(T\)</span>的不同部分（也就是其中一个来自<span class="math inline">\(T_1\)</span>，另一个来自<span class="math inline">\(T_2\)</span>）那么说明这两个后缀的最长公共前缀为<span class="math inline">\(T_1,T_2\)</span>这两个字符串的子串之一，由于<span class="math inline">\(\texttt{@}\)</span>不在<span class="math inline">\(T_1\)</span>中，因此可以确保<span class="math inline">\(LCP\)</span>不会恰好经过<span class="math inline">\(\texttt{@}\)</span>。具体过程由程序<code>LONGEST-COMMON-SUBSTRINGS</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">LONGEST-COMMON-SUBSTRINGS(T1, T2, n1, n2)</span><br><span class="line">  T = T1 @ T2</span><br><span class="line">  n = n1 + n2 + 1</span><br><span class="line">  SA = COMPUTE-SUFFIX-ARRAY(T, n)</span><br><span class="line">  LCP = COMPUTE-LCP(T, SA, n)</span><br><span class="line">  len = 0</span><br><span class="line">  S = ∅</span><br><span class="line">  for i = 2 to n</span><br><span class="line">    l = SA[i - 1]</span><br><span class="line">    r = SA[i]</span><br><span class="line">    if min&#123;l, r&#125; &lt;= n1 and max(l, r) &gt; n1 + 1</span><br><span class="line">      if LCP[i] &gt; len</span><br><span class="line">        len = LCP[i]</span><br><span class="line">        S = &#123;min&#123;l, r&#125;&#125;</span><br><span class="line">    else if lCP[i] == len</span><br><span class="line">        S = S ∪ &#123;min&#123;l, r&#125;&#125;</span><br><span class="line">  let string-list be a new array</span><br><span class="line">  for l in S</span><br><span class="line">    INSERT(string-list, T1[l : l + len - 1])</span><br><span class="line">  return string-list</span><br></pre></td></tr></table></figure><h1 id="section-3">32.5-4</h1><p>这里首先需要解释一下这个约束<span class="math inline">\(SA[i-1]=n&#39;-SA[i]-LCP[i]+2\)</span>是怎么来的：</p><p>首先，<span class="math inline">\(T\)</span>中有一个子串<span class="math inline">\([l,r]\)</span>是回文串，那么在<span class="math inline">\(T&#39;\)</span>这个字符串中，其在后半段对应的位置中是<span class="math inline">\([l&#39;,r&#39;]\)</span>。这意味着<span class="math inline">\(r-l+1=r&#39;-l&#39;+1=\text{len}\)</span>，由于<span class="math inline">\(T&#39;\)</span>的最后<span class="math inline">\(n\)</span>个字符是由<span class="math inline">\(T\)</span>反转而来，并且字符<span class="math inline">\(\texttt{@}\)</span>处在下标<span class="math inline">\(\dfrac{n&#39;+1}{2}\)</span>中，因此有<span class="math inline">\(\dfrac{n&#39;+1}{2}-r=l&#39;-\dfrac{n&#39;+1}{2}\)</span>。最终联立上面两个式子可以得到<span class="math inline">\(n&#39;+1=l&#39;+l+\text{len}-1\)</span>，更进一步可以得到<span class="math inline">\(l&#39;=n&#39;-l-\text{len}+2\)</span>，和上面给定的约束很像。</p><p>因此，这个求解最长回文子串的算法的错误在于，它认为后缀<span class="math inline">\(T[l:]\)</span>和<span class="math inline">\(T[l&#39;:]\)</span>在<span class="math inline">\(SA\)</span>数组中是相邻的，然而并非如此。</p><p>考虑字符串<span class="math inline">\(T=\texttt{abbcabb}\)</span>，那么有<span class="math inline">\(T&#39;=\texttt{abbcabb@bbacbba}\)</span>。等算法结束后，我们可以得到关于这个字符串的表格：</p><p><span class="math inline">\(\begin{array}{cclc}i&amp;SA[i]&amp;\text{substring}&amp;LCP[i]&amp;SA[i-1]=n&#39;-SA[i]-LCP[i]+2\\\hline1&amp;8&amp;\texttt{@bbacbba}&amp;0&amp;\text{No}\\2&amp;15&amp;\texttt{a}&amp;0&amp;\text{No}\\3&amp;5&amp;\texttt{abb@bbacbba}&amp;1&amp;\text{No}\\4&amp;1&amp;\texttt{abbcabb@bbacbba}&amp;3&amp;\text{No}\\5&amp;11&amp;\texttt{acbba}&amp;1&amp;\text{No}\\6&amp;7&amp;\texttt{b@bbacbba}&amp;0&amp;\text{No}\\7&amp;14&amp;\texttt{ba}&amp;1&amp;\text{No}\\8&amp;10&amp;\texttt{bacbba}&amp;2&amp;\text{No}\\9&amp;6&amp;\texttt{bb@bbacbba}&amp;1&amp;\text{Yes}\\10&amp;13&amp;\texttt{bba}&amp;2&amp;\text{No}\\11&amp;9&amp;\texttt{bbacbba}&amp;3&amp;\text{No}\\12&amp;2&amp;\texttt{bbcabb@bbacbba}&amp;2&amp;\text{No}\\13&amp;3&amp;\texttt{bcabb@bbacbba}&amp;1&amp;\text{No}\\14&amp;4&amp;\texttt{cabb@bbacbba}&amp;0&amp;\text{No}\\15&amp;12&amp;\texttt{cbba}&amp;1&amp;\text{Yes}\\\end{array}\)</span></p><p>由表格可知这个算法的输出结果为<span class="math inline">\(1\)</span>，但是实际上答案为<span class="math inline">\(2\)</span>。<span class="math inline">\(T\)</span>一共有两个子串<span class="math inline">\(\texttt{bb}\)</span>满足答案。其中一对<span class="math inline">\(\texttt{bb}\)</span>及其在后半段的反转分别是<span class="math inline">\(T&#39;[2:3],T&#39;[13:14]\)</span>，但是在<span class="math inline">\(SA\)</span>数组中，<span class="math inline">\(2\)</span>和<span class="math inline">\(13\)</span>不相邻。同样的，另一对<span class="math inline">\(\texttt{bb}\)</span>则及其反转分别是在<span class="math inline">\(T&#39;[6:7],T&#39;[9:10]\)</span>，但是在<span class="math inline">\(SA\)</span>数组中，<span class="math inline">\(6\)</span>和<span class="math inline">\(10\)</span>不相邻。</p><p>最终是因为约束<span class="math inline">\(SA[i-1]=n&#39;-SA[i]-LCP[i]+2\)</span>认为后缀<span class="math inline">\(T[l:]\)</span>和<span class="math inline">\(T[l&#39;:]\)</span>在<span class="math inline">\(SA\)</span>数组中是相邻的，导致了错误。因此这个约束不正确。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论32.4 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-4-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-4-Exercises/</id>
    <published>2023-10-07T16:57:25.000Z</published>
    <updated>2023-10-07T16:57:25.833Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">32.4-1</h1><p>模式串<span class="math inline">\(P=\texttt{ababbabbabbababbabb}\)</span>的前缀数组为<span class="math inline">\(\pi=(0,0,1,2,0,1,2,0,1,2,0,1,2,3,4,5,6,7,8)\)</span>。</p><h1 id="section-1">32.4-2</h1><p><span class="math inline">\(\pi^{\ast}[q]\)</span>的大小可以达到<span class="math inline">\(q-1\)</span>。以<span class="math inline">\(m\)</span>个字符<span class="math inline">\(\texttt{a}\)</span>的模式串<span class="math inline">\(P\)</span>为例，对于<span class="math inline">\(\forallq\in[2,n],\pi^{\ast}[q]=\{1,2,\dots,q-1\}\)</span>。因此集合<span class="math inline">\(\pi^{\ast}[q]\)</span>的大小可以达到<span class="math inline">\(q-1\)</span>。</p><h1 id="section-2">32.4-3</h1><p>可见，在<span class="math inline">\(T\)</span>中出现<span class="math inline">\(P\)</span>的有效偏移量集合为<span class="math inline">\(\{q-2m:\pi[q]=m,q\ge 2m\}\)</span>。因为<span class="math inline">\(P\)</span>被拼接在了前面，因此需要减去<span class="math inline">\(P\)</span>已经占有的偏移量<span class="math inline">\(m\)</span>。此外，还需要满足<span class="math inline">\(q\ge 2m\)</span>，以避免和字符串<span class="math inline">\(P\)</span>有交叉。由于<span class="math inline">\(\pi\)</span>递增时，最多只会递增<span class="math inline">\(1\)</span>，因此只需要考虑等于<span class="math inline">\(m\)</span>的情况即可满足所有情况，而不需要考虑大于<span class="math inline">\(m\)</span>的情况。</p><h1 id="section-3">32.4-4</h1><p>不失一般性，这里只考虑<code>KMP-MATCHER</code>的主体部分（因为<code>COMPUTE-PREFIX-FUNCTION</code>的分析方式和<code>KMP-MATCHER</code>一致）。</p><p>按照定义，由于<span class="math inline">\(r=\pi[q]\)</span>是<span class="math inline">\(P[:q]\)</span>中最长的真子前缀同时也是其后缀，因此<span class="math inline">\(\pi[q]&lt;q\)</span>。这意味着第4-5中的<code>while</code>循环执行一次<span class="math inline">\(q\)</span>值就会减少。由于<span class="math inline">\(q\)</span>不可能为负数，并且第3行的每轮<code>for</code>循环中，只有第7行才会对<span class="math inline">\(q\)</span>增加（并且只增加<span class="math inline">\(1\)</span>），因此第5行最多也只会执行<span class="math inline">\(n\)</span>次。</p><p>最终，第2-10行只需要<span class="math inline">\(\Theta(n)\)</span>的时间即可完成。第1行的<code>COMPUTE-PREFIX-FUNCTION</code>使用类似分析方式可以得到其运行时间为<span class="math inline">\(\Theta(m)\)</span>。由于<span class="math inline">\(m\len\)</span>，因此<code>KMP-MATCHER</code>的时间复杂度为<span class="math inline">\(\Theta(m)+\Theta(n)=\Theta(n)\)</span>。</p><h1 id="section-4">32.4-5</h1><p>本题的分析框架和题目32.4-4的一样，只考虑<code>KMP-MATCHER</code>的主体部分。</p><p>令势函数<span class="math inline">\(\Phi(D_i)\)</span>表示第<span class="math inline">\(i\)</span>轮<code>for</code>循环结束后<span class="math inline">\(q\)</span>的值。由于<span class="math inline">\(q\)</span>的值在<code>for</code>循环开始前为<span class="math inline">\(0\)</span>，因此有<span class="math inline">\(\Phi(D_0)=0\)</span>。</p><p>令均摊开销<span class="math inline">\(\widehat{c_i}=c_i+\Phi(D_i)-\Phi(D_{i-1})\)</span>，其中<span class="math inline">\(c_i\)</span>表示真实开销。那么有<span class="math inline">\(\displaystyle{\sum_{i=1}^nc_i=\sum_{i=1}^n\widehat{c_i}-\Phi(D_n)+\Phi(D_0)}\)</span>。令每轮开销的均摊代价<span class="math inline">\(\widehat{c_i}=2\)</span>，那么有</p><p><span class="math inline">\(\begin{aligned}\sum_{i=1}^nc_i&amp;=\sum_{i=1}^n\widehat{c_i}-\Phi(D_n)+\Phi(D_0)\\&amp;\le \sum_{i=1}^nc_i+\Phi(D_0)\\ &amp;\le 2n\end{aligned}\)</span></p><p>因此<code>KMP-MATCHER</code>的第2-10行只需要<span class="math inline">\(\Theta(n)\)</span>的时间即可完成。第1行的<code>COMPUTE-PREFIX-FUNCTION</code>使用类似分析方式可以得到其运行时间为<span class="math inline">\(\Theta(m)\)</span>。由于<span class="math inline">\(m\len\)</span>，因此<code>KMP-MATCHER</code>的时间复杂度为<span class="math inline">\(\Theta(m)+\Theta(n)=\Theta(n)\)</span>。</p><h1 id="section-5">32.4-6</h1><p>按照题目给定的<span class="math inline">\(\pi&#39;\)</span>的定义，将<code>KMP-MATCHER</code>修改后的<code>KMP-MATCHER'</code>如下所示。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">COMPUTE-PREFIX-FUNCTION&#x27;(P, m)</span><br><span class="line">  π = COMPUTE-PREFIX-FUNCTION(P, m)</span><br><span class="line">  Let π&#x27;[1 : m - 1] be a new array</span><br><span class="line">  for q = 1 to m - 1</span><br><span class="line">    if π[q] == 0</span><br><span class="line">      π&#x27;[q] = 0</span><br><span class="line">    else if π[q] != 0 and P[π[q] + 1] == P[q + 1]</span><br><span class="line">      π&#x27;[q] = π&#x27;[π[q]]</span><br><span class="line">    else</span><br><span class="line">      π&#x27;[q] = π[q]</span><br><span class="line">  return π, π&#x27;</span><br><span class="line"></span><br><span class="line">KMP-MATCHER&#x27;(T, P, n, m)</span><br><span class="line">  π, π&#x27; = COMPUTE-PREFIX-FUNCTION(P, m)</span><br><span class="line">  q = 0</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    while q &gt; 0 and P[q + 1] != T[i]</span><br><span class="line">      q = π[q]</span><br><span class="line">    if P[q + 1] == T[i]</span><br><span class="line">      q = q + 1</span><br><span class="line">    if q == m</span><br><span class="line">      print &quot;Pattern occurs with shift&quot; i – m</span><br><span class="line">      q = π[q]</span><br></pre></td></tr></table></figure></p><p>接下来我们证明这个嵌套调用的<span class="math inline">\(\pi&#39;\)</span>是正确的。如果满足<span class="math inline">\(\pi&#39;\)</span>中定义的第一行和第三行的情况，那么就有<span class="math inline">\(\pi&#39;[q]=\pi[q]\)</span>，这和<code>KMP-MATCHER'</code>执行第5行的过程完全一致。</p><p>当满足<span class="math inline">\(\pi&#39;\)</span>的第二条情况时，即<span class="math inline">\(P[q+1]=P[\pi[q]+1]\)</span>，这种情况意味着在<code>KMP-MATCHER'</code>执行第5行的过程前后，都将会对<span class="math inline">\(P[q+1]\neq T[i]\)</span>和<span class="math inline">\(P[\pi [q]+1]\neqT[i]\)</span>进行判断。由于字母相同，这两种判断是没有必要的，<span class="math inline">\(\pi&#39;\)</span>将会跳到下一个和<span class="math inline">\(P[q+1]\)</span>不相同的字符<span class="math inline">\(P[\pi&#39; [q]+1]\)</span>再和<span class="math inline">\(T[i]\)</span>进行比较。因此这个过程是正确的。</p><p><span class="math inline">\(\pi&#39;\)</span>数组的存在是一个对<code>KMP-MATCHER</code>的优化，但是它不会降低<code>KMP-MATCHER</code>的时间复杂度。只有当<span class="math inline">\(T\)</span>的长度远大于<span class="math inline">\(P\)</span>的长度时，<span class="math inline">\(\pi&#39;\)</span>数组会对<code>KMP-MATCHER</code>带来常数上的优化。# 32.4-7</p><p><span class="math inline">\(T\)</span>是<span class="math inline">\(T&#39;\)</span>的旋转串，当且仅当<span class="math inline">\(T&#39;\)</span>出现在<span class="math inline">\(TT\)</span>中。因此这相当于执行了一次<code>KMP-MATCHER</code>算法。具体过程由<code>IS-CYCLIC-ROTATION</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">IS-CYCLIC-ROTATION(T, T&#x27;, m)</span><br><span class="line">  π = COMPUTE-PREFIX-FUNCTION(P, m)</span><br><span class="line">  q = 0</span><br><span class="line">  S = TT</span><br><span class="line">  for i = 1 to m + m</span><br><span class="line">    while q &gt; 0 and T[q + 1] != S[i]</span><br><span class="line">      q = π[q]</span><br><span class="line">    if T[q + 1] == S[i]</span><br><span class="line">      q = q + 1</span><br><span class="line">    if i &gt; m and q == m</span><br><span class="line">      print &quot;T&#x27; is T with shift&quot; i – m</span><br><span class="line">      q = π[q]</span><br></pre></td></tr></table></figure><h1 id="star-32.4-8"><span class="math inline">\(\star\)</span>32.4-8</h1><p>基于KMP算法的<span class="math inline">\(\pi\)</span>数组计算转移函数<span class="math inline">\(\delta\)</span>的算法由<code>COMPUTE-TRANSITION-FUNCTION-KMP</code>所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">COMPUTE-TRANSITION-FUNCTION-KMP(P, ∑, m)</span><br><span class="line">  π = COMPUTE-PREFIX-FUNCTION(P, m)</span><br><span class="line">  for each character a ∈ ∑</span><br><span class="line">    δ(0, a) = 0</span><br><span class="line">  δ(0, P[1]) = 1</span><br><span class="line">  for q = 1 to m</span><br><span class="line">    for each character a ∈ ∑</span><br><span class="line">      if q &lt; m and P[q + 1] == a</span><br><span class="line">        δ(q, a) = q + 1</span><br><span class="line">      else</span><br><span class="line">        δ(q, a) = δ(π[q], a)</span><br><span class="line">  return δ</span><br></pre></td></tr></table></figure><p>可见第2-4行对<span class="math inline">\(\delta(0,\cdot)\)</span>处理的正确性是显而易见的，在一开始没有接受到任何字符时，只有接受到正确的字符<span class="math inline">\(P[1]\)</span>时，才可以从状态<span class="math inline">\(0\)</span>转移到状态<span class="math inline">\(1\)</span>。第7-8行的处理同样也是显而易见的，遇到正确的字符那么就向前一个状态进位。</p><p>接下来证明另一种情况，即第9-10行的情况。按照<span class="math inline">\(\delta\)</span>的定义，可见<span class="math inline">\(\delta(q,a)=\sigma(P[:q]a)\)</span>，将<span class="math inline">\(\pi[q]\)</span>视为前面的<span class="math inline">\(q\)</span>，也有<span class="math inline">\(\delta(\pi[q],a)=\sigma(P[:\pi[q]]a)\)</span>。按照<span class="math inline">\(\pi\)</span>数组的定义，由于<span class="math inline">\(P[: \pi[q]]\sqsupset P[:q]\)</span>，因此<span class="math inline">\(P[:\pi[q]]a\sqsupset P[:q]a\)</span>，从而<span class="math inline">\(\sigma(P[:\pi[q]]a)\le\sigma(P[:q]a)\)</span>。由于<span class="math inline">\(\pi[q]=\sigma(P[:q])\)</span>，因此<span class="math inline">\(P[:q]\)</span>后面添加一个字符<span class="math inline">\(a\)</span>后，可以得到<span class="math inline">\(\pi[q]\ge \sigma(P[:q]a)-1\)</span>，因为<span class="math inline">\(\sigma\)</span>的函数值最多只会增加<span class="math inline">\(1\)</span>，这意味着<span class="math inline">\(\sigma(P[:\pi [q]]a)\ge\sigma(P[:q]a)\)</span>。</p><p>因此，最终可以得到<span class="math inline">\(\sigma(P[:\pi[q]]a)=\sigma(P[:q]a)\)</span>，即<span class="math inline">\(\delta(\pi[q],a)=\delta(q,a)\)</span>，原结论成立。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论32.3 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-3-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-3-Exercises/</id>
    <published>2023-10-07T16:57:22.000Z</published>
    <updated>2023-10-07T16:57:22.748Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">32.3-1</h1><p>本题的状态集合<span class="math inline">\(Q=\{0,1,2,3,4,5\}\)</span>，起始状态<span class="math inline">\(q_0=0\)</span>，接受状态为<span class="math inline">\(\{5\}\)</span>。</p><p>针对模式串<span class="math inline">\(P=\texttt{aabab}\)</span>在字符集<span class="math inline">\(\Sigma=\{a,b\}\)</span>上的状态函数<span class="math inline">\(\delta(s,c)\)</span>如下表所示。</p><p><span class="math inline">\(\begin{array}{|c|c|c|c|c|c|c|}\hlines&amp;0&amp;1&amp;2&amp;3&amp;4&amp;5\\\hline\texttt{a}&amp;1&amp;2&amp;2&amp;4&amp;2&amp;1\\\hline\texttt{b}&amp;0&amp;0&amp;3&amp;0&amp;5&amp;0\\\hline\end{array}\)</span></p><p>由此，对于文本串<span class="math inline">\(T=\texttt{aaababaabaababaab}\)</span>，它的状态转移序列为<span class="math inline">\(0,1,2,2,3,4,5,1,2,3,4,2,3,4,5,1,2,3\)</span>，由此<span class="math inline">\(P\)</span>在<span class="math inline">\(T\)</span>中出现了两次，分别为偏移量为<span class="math inline">\(1\)</span>和<span class="math inline">\(9\)</span>时出现。</p><h1 id="section-1">32.3-2</h1><p>本题的状态集合<span class="math inline">\(Q=\{0,1,2,3,\dots,20,21\}\)</span>，起始状态<span class="math inline">\(q_0=0\)</span>，接受状态为<span class="math inline">\(\{21\}\)</span>。</p><p>针对模式串<span class="math inline">\(P=\texttt{ababbabbababbababbabb}\)</span>在字符集<span class="math inline">\(\Sigma=\{a,b\}\)</span>上的状态函数<span class="math inline">\(\delta(s,c)\)</span>如下表所示。</p><p><span class="math inline">\(\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}\hlines&amp;0&amp;1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8&amp;9&amp;10&amp;11&amp;12&amp;13&amp;14&amp;15&amp;16&amp;17&amp;18&amp;19&amp;20&amp;21\\\hline\texttt{a}&amp;1&amp;1&amp;3&amp;1&amp;3&amp;6&amp;1&amp;3&amp;9&amp;1&amp;11&amp;1&amp;3&amp;14&amp;1&amp;16&amp;1&amp;3&amp;19&amp;1&amp;3&amp;9\\\hline\texttt{b}&amp;0&amp;2&amp;0&amp;4&amp;5&amp;0&amp;7&amp;8&amp;0&amp;10&amp;0&amp;12&amp;13&amp;0&amp;15&amp;8&amp;17&amp;18&amp;0&amp;20&amp;21&amp;0\\\hline\end{array}\)</span></p><h1 id="section-2">32.3-3</h1><p>假设<span class="math inline">\(P\)</span>的长度为<span class="math inline">\(m\)</span>。<span class="math inline">\(P[:k]\sqsupset P[:q]\)</span>推导出<span class="math inline">\(k=0\lork=q\)</span>意味着这个字符串只要产生了一次失配，那么就必须从头开始匹配，这意味着任何不以<span class="math inline">\(P[1]\)</span>为开头的字符串是<span class="math inline">\(P\)</span>的一个前缀，因此，这种模式串一般是<span class="math inline">\(\forall i\in[2,n],P[1]\neq P[i]\)</span>成立。</p><p>对于这种模式串，它的状态转移函数<span class="math inline">\(\delta(s,c)(s\in[0,m],c\in\Sigma)\)</span>如下：</p><p><span class="math inline">\(\delta(s,c)= \left\{\begin{aligned}  &amp;0 &amp; &amp; \text{if}\quad s=m\lor s&lt;m\land P[s+1]\neq c \\  &amp;s+1 &amp; &amp; \text{if}\quad s&lt;c\landP[s+1]=c \\ \end{aligned}\right.\)</span></p><h1 id="section-3">32.3-4</h1><p>由于<span class="math inline">\(x\sqsupset y\)</span>，因此有<span class="math inline">\(|x|\le |y|\)</span>。又因为<span class="math inline">\(x,y\)</span>同为<span class="math inline">\(P\)</span>的前缀，因此有<span class="math inline">\(x\sqsubset y\)</span>。</p><p>按照<span class="math inline">\(\sigma\)</span>的定义，有<span class="math inline">\(\sigma(x)= |x|\)</span>。但是因为<span class="math inline">\(x\sqsubset y,x\sqsupset y\)</span>，因此<span class="math inline">\(\sigma(y)\ge |x|\)</span>。最终有<span class="math inline">\(\sigma(x)\le \sigma(y)\)</span>。</p><h1 id="section-4">32.3-5</h1><p>最少的状态数即为合并<span class="math inline">\(P\)</span>和<span class="math inline">\(P&#39;\)</span>的最长公共前缀作为共同状态。更一般的说，令<span class="math inline">\(P\)</span>和<span class="math inline">\(P&#39;\)</span>的最长公共前缀的状态为<span class="math inline">\(r=\max\{i:P[:i]=P&#39;[:i]\}\)</span>，那么一共有<span class="math inline">\(|P|+|P&#39;|-r-1\)</span>个状态，直到第<span class="math inline">\(r\)</span>个字符之后，状态才会被分开。具体构建过程由<code>COMPUTE-TRANSITION-FUNCTION'</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">COMPUTE-TRANSITION-FUNCTION&#x27;(P, m, P&#x27;, m&#x27;, ∑)</span><br><span class="line">  r = 0</span><br><span class="line">  while k &lt; m amd k &lt; m&#x27; and P[r + 1] == P&#x27;[r + 1]</span><br><span class="line">    r += 1</span><br><span class="line">  for q = 0 to m</span><br><span class="line">    for each character a ∈ ∑</span><br><span class="line">      k = min &#123;m, q + 1&#125;</span><br><span class="line">    while P[:k] is not a suffix of P[:q]a</span><br><span class="line">      k = k – 1</span><br><span class="line">      δ(q, a) = k</span><br><span class="line">  for each q = r + 1 to m&#x27;</span><br><span class="line">    for each character a ∈ ∑</span><br><span class="line">      k = min &#123;m, q + 1&#125;</span><br><span class="line">    while P&#x27;[:k] is not a suffix of P&#x27;[:q]a</span><br><span class="line">      k = k – 1</span><br><span class="line">    if k &lt;= r</span><br><span class="line">      δ(q + m, a) = k</span><br><span class="line">    else</span><br><span class="line">      δ(q + m, a) = m + k</span><br><span class="line">  return δ</span><br></pre></td></tr></table></figure><h1 id="section-5">32.3-6</h1><p>对于包含通配符<span class="math inline">\(\Diamond\)</span>的一个模式串<span class="math inline">\(P\)</span>，假设我们将其划分成切割成一个个不包含通配符<span class="math inline">\(\Diamond\)</span>的模式串<span class="math inline">\(P_1,P_2,\dots,P_k\)</span>，那么将这些状态进行“首尾相接”即可，因为只要进行到当前的模式串<span class="math inline">\(P_i\)</span>，那么就不能转移到以前的模式串。可见将会一共有<span class="math inline">\(|P|+1\)</span>个状态。</p><p>具体过程由<code>COMPUTE-TRANSITION-FUNCTION-GAP</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">COMPUTE-TRANSITION-FUNCTION-GAP(P, ∑, m)</span><br><span class="line">  split P into Q[1], Q[2], ..., Q[k] by &#x27;◊&#x27;</span><br><span class="line">  pre = 0</span><br><span class="line">  for i = 1 to k</span><br><span class="line">    δt = COMPUTE-TRANSITION-FUNCTION-GAP(Q[i], ∑, |Q[i]|)</span><br><span class="line">    for s = 0 to |Q[i]|</span><br><span class="line">      for each character a ∈ ∑</span><br><span class="line">        δ(pre + s, a) = δt(s, a)</span><br><span class="line">    pre = pre + |Q[i]|</span><br><span class="line">  return δ</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论32.2 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-2-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-2-Exercises/</id>
    <published>2023-10-07T16:57:19.000Z</published>
    <updated>2023-10-07T16:57:19.479Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">32.2-1</h1><p>可见，<span class="math inline">\(p=26\bmod 11=4\)</span>。</p><p>按照算法<code>RABIN-KARP-MATCHER</code>的执行结果，可以计算出的<span class="math inline">\(t_s\)</span>值如下标：</p><p><span class="math inline">\(\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}\hlines&amp;0&amp;1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8&amp;9&amp;10&amp;11&amp;12&amp;13&amp;14\\\hlinet_s&amp;9&amp;3&amp;8&amp;4&amp;4&amp;4&amp;4&amp;10&amp;9&amp;2&amp;3&amp;1&amp;9&amp;2&amp;5\\\hline\end{array}\)</span></p><p>可见一共有<span class="math inline">\(4\)</span>次命中，但是仅有偏移<span class="math inline">\(6\)</span>是有效偏移，因此其余的偏移<span class="math inline">\(3,4,5\)</span>都是伪命中。</p><h1 id="section-1">32.2-2</h1><p>这题的思想比较简单：首先求出<span class="math inline">\(k\)</span>个模式串的<span class="math inline">\(p\)</span>值<span class="math inline">\(p_1,p_2,\dots,p_k\)</span>，并且使用一个基于链接法的哈希表来存储这些<span class="math inline">\(p\)</span>值和对应的字符串。只要哈希表的大小合适，那么只需要<span class="math inline">\(O(1)\cdot O(m(v+n/q))=O(m(v+n/q))\)</span>，其中<span class="math inline">\(v\)</span>是有效偏移的数量。需要注意的是，只有<span class="math inline">\(p_1,p_2,\dots,p_k\)</span>都是长度为<span class="math inline">\(m\)</span>的情况下才能使用该算法<code>RABIN-KARP-MATCHER'</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">RABIN-KARP-MATCHER&#x27;(T, P, n, k, m, d, q)</span><br><span class="line">  h = d^(m - 1) mod q</span><br><span class="line">  let p[1 : k] be a new array by 0</span><br><span class="line">  let T be a new hash-table.</span><br><span class="line">  t0 = 0</span><br><span class="line">  for i = 1 to m</span><br><span class="line">    t0 = (d * t0 + T[i]) mod q</span><br><span class="line">    for j = 1 to k</span><br><span class="line">    p[j] = (d * p[j] + P[j, i]) mod q</span><br><span class="line">  for j = 1 to k</span><br><span class="line">    let x be a new node</span><br><span class="line">    x.key = p[j]</span><br><span class="line">    x.p = P[j]</span><br><span class="line">    // 节点x存的是字符串和它的哈希值。</span><br><span class="line">    CHAINED-HASH-INSERT(T, x)</span><br><span class="line">  //假设CHAINED-HASH-SEARCH&#x27;返回的是哈希表中和x.key相同的所有节点，而并非只是至多一个；hash是一个哈希函数。</span><br><span class="line">  for s = 0 to n - m</span><br><span class="line">    for v, pat in CHAINED-HASH-SEARCH&#x27;(T, hash(t_s))</span><br><span class="line">      if v == t_s </span><br><span class="line">        if pat[1 : m] == T[s + 1 : s + m]</span><br><span class="line">          print &quot;Pattern &quot; pat &quot; occur with shifts&quot; s</span><br><span class="line">    if s &lt; n - m</span><br><span class="line">      t_&#123;s + 1&#125; = (d * (t_s - T[s + 1] * h) + T[s + m + 1]) mod q</span><br></pre></td></tr></table></figure><p>对于模式串不等长的情况下，不能够使用上述哈希表的情况，只能分别独立地进行查询。通过数组模拟各种查询情况，最终整个过程由程序<code>RABIN-KARP-MATCHER''</code>给出，其时间复杂度为<span class="math inline">\(O(km(v+n/q))\)</span>，其中<span class="math inline">\(v\)</span>是有效偏移的数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RABIN-KARP-MATCHER&#x27;&#x27;(T, P, n, k, d, q)</span><br><span class="line">  h = d^(m - 1) mod q</span><br><span class="line">  let p[1 : k] be a new array by 0</span><br><span class="line">  let T be a new hash-table.</span><br><span class="line">  for j = 1 to k</span><br><span class="line">    t0 = 0</span><br><span class="line">    for i = 1 to |P[j]|</span><br><span class="line">      p[j] = (d * p[j] + P[j, i]) mod q</span><br><span class="line">      t0 = (d * t0 + T[i]) mod q</span><br><span class="line">    for s = 0 to n - |P[j]|</span><br><span class="line">      if p == t_s</span><br><span class="line">        if P[j, 1 : |P[j]|] == T[s + 1 : s + m]</span><br><span class="line">          print &quot;Pattern &quot; P[j] &quot; occur with shifts&quot; s</span><br><span class="line">      if s &lt; n - m</span><br><span class="line">        t_&#123;s + 1&#125; = (d * (t_s - T[s + 1] * h) + T[s + m + 1]) mod q</span><br></pre></td></tr></table></figure><h1 id="section-2">32.2-3</h1><p>这道题的本质思想是将二维的情况转化为一维。对于每相邻<span class="math inline">\(m\)</span>行，我们先预处理出一个长度为<span class="math inline">\(n\)</span>的数组<span class="math inline">\(U\)</span>，然后再在数组<span class="math inline">\(U\)</span>上处理一维的情况，注意处理一行<span class="math inline">\(U\)</span>的情况时，不像<code>RABIN-KARP-MATCHER</code>那样以<span class="math inline">\(d\)</span>作为进制，而是以<span class="math inline">\(d&#39;=d^m\)</span>来作为进制。和<code>RABIN-KARP-MATCHER</code>同样的是，判断一个字符矩阵对应的值<span class="math inline">\(t\)</span>是否和<span class="math inline">\(p\)</span>相同只需要<span class="math inline">\(O(1)\)</span>的时间即可完成。</p><p>一共需要判断<span class="math inline">\((n-m+1)^2\)</span>种情况，因此在最坏情况下，这个二维版本的算法将会达到<span class="math inline">\(O((n-m)+1^2 \cdotm^2)=O(n^4)\)</span>。具体过程由<code>RABIN-KARP-MATCHER-2D</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">RABIN-KARP-MATCHER-2D(T, P, n, m, d, q)</span><br><span class="line">  ha = d ^ (m * (m-1)) mod q</span><br><span class="line">  hr = d ^ (m-1) mod q</span><br><span class="line">  d&#x27; = d ^ m mod q</span><br><span class="line">  p = 0</span><br><span class="line">  for j = 1 to m</span><br><span class="line">    for i = 1 to m</span><br><span class="line">      p = (d * p + P[i, j]) mod q</span><br><span class="line">  let U[1 : n] be a new array by 0</span><br><span class="line">  for j = 1 to n</span><br><span class="line">    for i = 1 to m</span><br><span class="line">      U[j] = (d * U[j] + T[i, j]) mod q</span><br><span class="line">  for rs = 0 to n - m</span><br><span class="line">    u0 = 0</span><br><span class="line">    for j = 1 to m</span><br><span class="line">      u0 = (d&#x27; * u0 + U[j]) mod q</span><br><span class="line">    for cs = 0 to n - m</span><br><span class="line">      if p == ts</span><br><span class="line">        if P[1 : m,1 : m] == T[rs + 1:rs + m,cs + 1:cs + m]</span><br><span class="line">          print &quot;Pattern occurs with shift&quot; (rs, cs)</span><br><span class="line">      if cs &lt; n - m</span><br><span class="line">        u_&#123;cs + 1&#125; = (d&#x27; * (u_&#123;cs&#125; - U[cs + 1] * ha) + U[cs + m + 1]) mod q</span><br><span class="line">    if rs &lt; n - m</span><br><span class="line">      for j = 1 to n</span><br><span class="line">        U[j] = (d * (u[j] - T[rs + 1, j] * ha) + T[rs + m + 1, j]) mod q</span><br></pre></td></tr></table></figure><h1 id="section-3">32.2-4</h1><p>考虑令<span class="math inline">\(\displaystyle{f(A,B,x)=\left(\sum_{i=0}^{n-1}(a_i-b_i)x^i\right)\bmodq}\)</span>。</p><p>如果两个文件相同，那么也就是说<span class="math inline">\(\foralli\in[0,n),a_i=b_i\)</span>均成立，那么此时任取<span class="math inline">\(x\in[0,q)\)</span>，都必定有<span class="math inline">\(A(x)=B(x)\)</span>。</p><p>否则，非零多项式<span class="math inline">\(f(A,B,x)\)</span>的次数至多为<span class="math inline">\(n\)</span>。由于<span class="math inline">\(q\)</span>是一个质数，依照题目31.4-4的结论，方程<span class="math inline">\(f(A,B,x)=0\)</span>最多有<span class="math inline">\(n\)</span>个不同的根。由于<span class="math inline">\(x\)</span>是从<span class="math inline">\([0,q)\)</span>中选择的，因此任取<span class="math inline">\(x\in [0,q),f(A,B,x)=0\)</span>的概率至多为<span class="math inline">\(\dfrac{n}{q}\)</span>。由于<span class="math inline">\(q&gt;10^3\cdot n\)</span>，因此<span class="math inline">\(f(A,B,x)=0\)</span>的概率不会超过<span class="math inline">\(10^{-3}\)</span>，原结论成立。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论32.1 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-1-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-1-Exercises/</id>
    <published>2023-10-07T16:57:15.000Z</published>
    <updated>2023-10-07T17:08:43.355Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">32.1-1</h1><p>令<span class="math inline">\(t(s)(s\le n-m)\)</span>表示偏移为<span class="math inline">\(s\)</span>时，进行的匹配次数，那么这些匹配次数由下表给出：</p><p><span class="math inline">\(\begin{array}{|c|l|c|c|}\hlines&amp;\mathtt{000010001010001} &amp;t(s)&amp;\text{is matched}\\\hline0&amp;\mathtt{0001}&amp;4&amp;\text{No}\\\hline 1&amp;\mathtt{\0001}&amp;4&amp;\text{Yes}\\\hline 2&amp;\mathtt{\ \0001}&amp;3&amp;\text{No}\\\hline 3&amp;\mathtt{\ \ \0001}&amp;2&amp;\text{No}\\\hline 4&amp;\mathtt{\ \ \ \0001}&amp;1&amp;\text{No}\\\hline 5&amp;\mathtt{\ \ \ \ \0001}&amp;4&amp;\text{Yes}\\\hline 6&amp;\mathtt{\ \ \ \ \ \0001}&amp;3&amp;\text{No}\\\hline 7&amp;\mathtt{\ \ \ \ \ \ \0001}&amp;2&amp;\text{No}\\\hline 8&amp;\mathtt{\ \ \ \ \ \ \ \0001}&amp;1&amp;\text{No}\\\hline 9&amp;\mathtt{\ \ \ \ \ \ \ \ \0001}&amp;2&amp;\text{No}\\\hline 10&amp;\mathtt{\ \ \ \ \ \ \ \ \ \0001}&amp;1&amp;\text{No}\\\hline 11&amp;\mathtt{\ \ \ \ \ \ \ \ \ \ \0001}&amp;4&amp;\text{Yes}\\\hline \end{array}\)</span></p><h1 id="section-1">32.1-2</h1><p>如果<span class="math inline">\(P\)</span>的各个字母都不相同，那么可以考虑从左到右遍历文本串<span class="math inline">\(T\)</span>，考察<span class="math inline">\(T\)</span>中和<span class="math inline">\(P[1]\)</span>相同的那些下标。由于<span class="math inline">\(P\)</span>中的字符各不相同，因此对于一对相邻都是字符<span class="math inline">\(P[1]\)</span>的下标<span class="math inline">\(i,j(i&lt;j)\)</span>，只有<span class="math inline">\(i+|P|\le j\)</span>时，偏移量<span class="math inline">\(i+1\)</span>才有可能是正确的，这时只需要检测一下即可。</p><p>由于<span class="math inline">\(S\)</span>中的每个字符和<span class="math inline">\(P\)</span>中的字符至多只会进行一次匹配，因此这个算法的时间复杂度为<span class="math inline">\(O(n)\)</span>。具体过程由<code>NAIVE-STRING-MATCHER'</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NAIVE-STRING-MATCHER(T, P, n, m)</span><br><span class="line">  cnt = n + 1</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    if T[i] == P[1]</span><br><span class="line">      cnt = 1</span><br><span class="line">    else</span><br><span class="line">      cnt = cnt + 1</span><br><span class="line">    if cnt == m and P[1:m] == T[i - cnt + 1:i]</span><br><span class="line">      print &quot;Pattern occurs with shift&quot; i - cnt</span><br></pre></td></tr></table></figure><h1 id="section-2">32.1-3</h1><p>对于文本串<span class="math inline">\(T\)</span>的偏移量<span class="math inline">\(s\)</span>，它能和模式串<span class="math inline">\(P\)</span>的第<span class="math inline">\(j\)</span>个字符比较当且仅当<span class="math inline">\(T[s+1:s+j-1]=P[1:j-1]\)</span>，这个概率值为<span class="math inline">\(d^{-(j-1)}\)</span>。</p><p>令随机变量<span class="math inline">\(X_{s}\)</span>表示偏移量为<span class="math inline">\(s\)</span>时，<span class="math inline">\(T[s+j-1]\)</span>和<span class="math inline">\(P[j]\)</span>发生了比较。那么有<span class="math inline">\(X_{s,j}=d^{-(j-1)}\)</span>。</p><p>令随机变量<span class="math inline">\(\displaystyle{Y=\sum_{s=0}^{n-m}\sum_{j=1}^{m}X_{ij}}\)</span>表示比较次数，那么有：</p><p><span class="math inline">\(\begin{aligned}E[Y]&amp;=\sum_{s=0}^{n-m}\sum_{j=1}^{m}E[X_{ij}]\\&amp;=\sum_{s=0}^{n-m}\sum_{j=1}^{m}\dfrac{1}{d^{j-1}}\\&amp;=\sum_{s=0}^{n-m}\dfrac{d-d^{1-m}}{d-1}\\&amp;=(n-m+1)\cdot\dfrac{d-d^{1-m}}{d-1}\\&amp;=(n-m+1)\cdot\dfrac{1-d^{m}}{1-d^{-1}}\\&amp;\le(n-m+1)\cdot\dfrac{1}{1-d^{-1}}\\&amp;\le(n-m+1)\cdot\dfrac{1}{1-2^{-1}}\\ &amp;\le2(n-m+1)\end{aligned}\)</span></p><h1 id="section-3">32.1-4</h1><p>本题可以使用动态规划进行求解。令状态<span class="math inline">\(f(i,j)(0\le i\le m,0\le j\lem)\)</span>表示使用<span class="math inline">\(P\)</span>的前<span class="math inline">\(i\)</span>个字符是否能匹配<span class="math inline">\(T\)</span>的前<span class="math inline">\(j\)</span>个字符。那么可以写出如下状态转移方程：</p><p><span class="math inline">\(f(i,j)= \left \{\begin{aligned}  &amp;1&amp; &amp; \text{if}\quad i=0\land j=0 \\  &amp;0 &amp; &amp;\text{if}\quad i=0\land j&gt;0\lor i&gt;0\land j=0\landP[i]\neq\Diamond\land f(i-1,0)=0 \\  &amp;\bigvee_{k=0}^j f(i-1,k) &amp;&amp; \text{if}\quad i&gt;0\land P[i]=\Diamond\\  &amp;f(i-1,j-1)\land\mathbf{1}\{P[i]=S[j]\} &amp; &amp; \text{if}\quad i&gt;0\landj&gt;0\land P[i]\neq\Diamond\\ \end{aligned}\right.\)</span></p><p>其中<span class="math inline">\(\mathbf{1}\{b\}\)</span>表示一个示性函数，用于表示布尔表达式<span class="math inline">\(b\)</span>是否成立。方程第三行表示这里有一个通配符<span class="math inline">\(\Diamond\)</span>，它可以匹配任意长度的字符串，因此可以从任意状态<span class="math inline">\(f(i-1,k)\)</span>转移到<span class="math inline">\(f(i,j)(k\lej)\)</span>，方程的第四行用于表示一个普通字符的匹配。</p><p>最终答案为<span class="math inline">\(f(m,n)\)</span>。</p><p>使用前缀和可以将这个转移优化到<span class="math inline">\(O(nm)\)</span>，因此可以在多项式时间复杂度内完成这个问题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
</feed>
