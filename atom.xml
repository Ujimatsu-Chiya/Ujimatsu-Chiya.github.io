<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ujimatsu Chiya</title>
  
  
  <link href="https://ujimatsu-chiya.github.io/atom.xml" rel="self"/>
  
  <link href="https://ujimatsu-chiya.github.io/"/>
  <updated>2023-10-01T11:51:14.574Z</updated>
  <id>https://ujimatsu-chiya.github.io/</id>
  
  <author>
    <name>Ujimatsu Chiya</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法导论26 Problems 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/26-Problems/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/26-Problems/</id>
    <published>2023-10-01T11:28:03.000Z</published>
    <updated>2023-10-01T11:51:14.574Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">26-1</h1><h2 id="a">a</h2><p>使用得到<code>P-MAT-VEC-RECURSIVE</code>类似的方法对<code>SUM-ARRAYS</code>进行修改，同样可以得到其基于递归的并行版本<code>SUM-ARRAYS-RECURSIVE</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SUM-ARRAYS-RECURSIVE(A, B, C, i, i&#x27;)</span><br><span class="line">  if i == i&#x27;</span><br><span class="line">    C[i] = A[i] + B[i]</span><br><span class="line">  else</span><br><span class="line">    mid = ⌊(i + i&#x27;) / 2⌋</span><br><span class="line">    spawn SUM-ARRAYS-RECURSIVE(A, B, C, i, mid)</span><br><span class="line">    spawn SUM-ARRAYS-RECURSIVE(A, B, C, mid + 1, i&#x27;)</span><br><span class="line">    sync</span><br></pre></td></tr></table></figure><p>可见这个算法的工作量为<span class="math inline">\(T_1(n)=\Theta(n)\)</span>。由于其递归深度达到<span class="math inline">\(\Theta(\lg n)\)</span>，并且只需要花费<span class="math inline">\(\Theta(1)\)</span>的时间即可完成，因此其持续时间为<span class="math inline">\(T_{\infty}(n)=\Theta(\lgn)\cdot\Theta(1)=\Theta(\lg n)\)</span>。因此的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n/\lgn)\)</span>。</p><h2 id="b">b</h2><p>如果<span class="math inline">\(grain\text{-}size=1\)</span>，那么<span class="math inline">\(r=n\)</span>，<code>SUM-ARRAYS'</code>中的<code>for</code>循环将会串行地执行<span class="math inline">\(n\)</span>次，每次调用<code>ADD-SUBARRAY</code>都只花费<span class="math inline">\(\Theta(1)\)</span>的时间。因此持续时间<span class="math inline">\(T_{\infty}(n)=n\cdot\Theta(1)=\Theta(n)\)</span>。可以知道其工作量为<span class="math inline">\(T_1(n)=\Theta(n)\)</span>，因此其并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(1)\)</span>。</p><h2 id="c">c</h2><p>令<span class="math inline">\(g=grain\text{-}size\)</span>。执行单次<code>ADD-SUBARRAY</code>所需要的时间为<span class="math inline">\(O(g)\)</span>。在<code>SUM-ARRAYS'</code>中，一共需要执行<span class="math inline">\(n/g\)</span>次<code>ADD-SUBARRAY</code>，但是<code>for</code>循环并没有带有<code>parrllel</code>关键字，也就是说，这些调用<code>ADD-SUBARRAY</code>的线程是按顺序启动的，它们并非同时启动的，因此这里仍然需要花费<span class="math inline">\(O(n/g)\)</span>的时间完成这个<code>for</code>循环。</p><p>因此，<code>SUM-ARRAYS'</code>需要花费<span class="math inline">\(O(g+n/g)\)</span>的时间完成。令<span class="math inline">\(f(g)=g+n/g\)</span>，那么有<span class="math inline">\(f&#39;(g)=1-n/g^2\)</span>。令<span class="math inline">\(f&#39;(g)=00\)</span>，即<span class="math inline">\(g=\sqrt{n}\)</span>时，<code>SUM-ARRAYS'</code>只需要花费<span class="math inline">\(O(\sqrt{n})\)</span>的时间就可以完成。</p><h1 id="section-1">26-2</h1><h2 id="a-1">a</h2><p>修改后的代码由<code>P-MATRIX-MULTIPLY-RECURSIVE'</code>所示，它消去了临时矩阵<span class="math inline">\(D\)</span>的存在。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A, B, C, n)</span><br><span class="line">  if n == 1</span><br><span class="line">    c11 = c11 + a11 · b11</span><br><span class="line">    return</span><br><span class="line">  partition A, B, C, and D into n/2 × n/2 submatrices A11, A12, A21, A22; B11, B12, B21, B22; and C11, C12, C21, C22; respectively</span><br><span class="line">  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A11, B11, C11, n / 2)</span><br><span class="line">  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A11, B12, C12, n / 2)</span><br><span class="line">  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A21, B11, C21, n / 2)</span><br><span class="line">  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A21, B12, C22, n / 2)</span><br><span class="line">  sync</span><br><span class="line">  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A12, B21, C11, n / 2)</span><br><span class="line">  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A12, B22, C12, n / 2)</span><br><span class="line">  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A22, B21, C21, n / 2)</span><br><span class="line">  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A22, B22, C22, n / 2)</span><br><span class="line">  sync</span><br></pre></td></tr></table></figure><p>可见，它的串行投影是<code>MATRIX-MULTIPLY-RECURSIVE</code>，因此其工作量为<span class="math inline">\(\Theta(n^3)\)</span>。</p><h2 id="b-1">b</h2><p>对于其工作量<span class="math inline">\(T_1(n)\)</span>，可以给出其递推式<span class="math inline">\(T_1(n)=8T_1(n/2)+\Theta(n^2)\)</span>，因此得到<span class="math inline">\(T_1(n)=\Theta(n^3)\)</span>。</p><p>对于其持续时间，除了递归调用，<code>P-MATRIX-MULTIPLY-RECURSIVE'</code>没有再做其它工作。因此可以给出其递推式<span class="math inline">\(T_{\infty}(n)=2T_{\infty}(n/2)+\Theta(1)\)</span>，最终通过主定理可以得知<span class="math inline">\(T_{\infty}(n)=\Theta(n)\)</span>。</p><p>也就是说，算法<code>P-MATRIX-MULTIPLY-RECURSIVE'</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^2)\)</span>。</p><h2 id="c-1">c</h2><p>忽略掉<span class="math inline">\(\Theta\)</span>符号后，对于<span class="math inline">\(1000\times1000\)</span>的矩阵而言，调用<code>P-MATRIX-MULTIPLY-RECURSIVE'</code>的并行度为<span class="math inline">\(10^6\)</span>。相比于调用<code>P-MATRIX-MULTIPLY-RECURSIVE</code>得到<span class="math inline">\(10^7\)</span>的并行度，计算机依旧不会有这么多的处理器，但是在算法的运行时间的常数却明显减少了，因此这种权衡是值得的。</p><h1 id="section-2">26-3</h1><h2 id="a-2">a</h2><p>对<code>LU-DECOMPOSITION</code>修改后得到的并行化版本为<code>P-LU-DECOMPOSITION</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">P-LU-DECOMPOSITION(A, n)</span><br><span class="line">  let L and U be new n × n matrices </span><br><span class="line">  initialize U with 0s below the diagonal</span><br><span class="line">  initialize L with 1s on the diagonal and 0s above the diagonal</span><br><span class="line">  for k = 1 to n</span><br><span class="line">    u_&#123;kk&#125; = a_&#123;kk&#125;</span><br><span class="line">    parallel for i = k + 1 to n</span><br><span class="line">      l_&#123;ik&#125; = a_&#123;ik&#125; / a_&#123;kk&#125;</span><br><span class="line">      u_&#123;ki&#125; = a_&#123;ki&#125;</span><br><span class="line">    parallel for i = k + 1 to n</span><br><span class="line">      parallel for j = k + 1 to n</span><br><span class="line">        a_&#123;ij&#125; = a_&#123;ij&#125; − l_&#123;ik&#125; * u_&#123;kj&#125;</span><br><span class="line">  return L and U</span><br></pre></td></tr></table></figure><p>也就是说，所有内循环都可以进行并行，但是最外层的那一层循环不允许并行。第一个内循环能够并行的原因是：它只读取<span class="math inline">\(a\)</span>矩阵的元素，并修改<span class="math inline">\(L,U\)</span>对应行和对应列的元素，并不会进行多次存取。第二个双重内循环能够并行的原因是第<span class="math inline">\(i\)</span>轮二层循环，第<span class="math inline">\(j\)</span>轮三次循环中，他只会读取<span class="math inline">\(L,U\)</span>矩阵的值并且修改<span class="math inline">\(a_{ij}\)</span>的值，不会造成冲突。外层循环不能是并行的原因是按照LU分解的定义，后一次的运行依赖于前一次的结果。</p><p><code>P-LU-DECOMPOSITION</code>的串行投影是<code>LU-DECOMPOSITION</code>，因此其工作量为<span class="math inline">\(T_1(n)=\Theta(n^3)\)</span>。</p><p>对于<code>P-LU-DECOMPOSITION</code>的持续时间，第一层的第一次内循环花费的时间是<span class="math inline">\(\Theta(\lg(n-k))=\Theta(\lgn)\)</span>，因为转化成<code>spawn ... sync</code>结构后就变成了分支法，然后进行递归。第二次的两个双重嵌套寻呼按的原因相同，其花费的时间为<span class="math inline">\(\Theta(\lg(n-k))+\Theta(\lg(n-k))=\Theta(\lgn)\)</span>。因此，外层<code>for</code>循环需要<span class="math inline">\(\Theta(\lgn)\)</span>的时间完成一次。最终，<code>P-LU-DECOMPOSITION</code>的持续时间为<span class="math inline">\(T_{\infty}(n)=n\cdot \Theta(\lg n)=\Theta(n\lgn)\)</span>。</p><p>最终我们可以计算出<code>P-LU-DECOMPOSITION</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^2/\lgn)\)</span>。</p><h2 id="b-2">b</h2><p>对<code>LUP-DECOMPOSITION</code>修改后得到的并行化版本为<code>P-LUP-DECOMPOSITION</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">P-LUP-DECOMPOSITION(A, n)</span><br><span class="line">  let π[1 : n] be a new array</span><br><span class="line">  parallel for i = 1 to n</span><br><span class="line">    π[i] = i</span><br><span class="line">  for k = 1 to n</span><br><span class="line">    p = 0</span><br><span class="line">    parallel for i = k to n</span><br><span class="line">      if |a_&#123;ik&#125;| &gt; p</span><br><span class="line">        p = |a_&#123;ik&#125;|</span><br><span class="line">        k&#x27; = i</span><br><span class="line">    if p == 0</span><br><span class="line">      error &quot;singular matrix&quot;</span><br><span class="line">    exchange π[k] with π[k&#x27;]</span><br><span class="line">    parallel for i = 1 to n</span><br><span class="line">      exchange a_&#123;ki&#125; with a_&#123;k&#x27;i&#125; </span><br><span class="line">    parallel for i = k + 1 to n</span><br><span class="line">      a_&#123;ik&#125; = a_&#123;ik&#125; / a_&#123;kk&#125;</span><br><span class="line">      parallel for j = k + 1 to n</span><br><span class="line">        a_&#123;ij&#125; = a_&#123;ij&#125; − a_&#123;ik&#125; * a_&#123;kj&#125;</span><br></pre></td></tr></table></figure><p>第2行的<code>for</code>循环可以并行，这是显而易见的。第6-9行的<code>for</code>循环是可以并行的，因为这是寻找一个最大值，在这个过程中，<span class="math inline">\(n\)</span>个元素构成一棵<span class="math inline">\(n\)</span>个叶节点的二叉树，对于内部节点，它是两个子节点中的最大值，由于这棵树的深度为<span class="math inline">\(\Theta(\lgn)\)</span>，因此这段循环的持续时间为<span class="math inline">\(\Theta(\lgn)\)</span>。第13行的<code>for</code>循环用于交换两行元素，显而易见是可以并行的。对于第15行和17行的<code>for</code>循环，第16行仅仅是对<span class="math inline">\(a_{ik}\)</span>进行更新，此后都是对<span class="math inline">\(a_{ij}(j&gt;k)\)</span>中的所有元素进行更新。至于先对哪一行操作都是没有关系的，因此第15行和17行的<code>for</code>循环它们都可以并行。外面针对<span class="math inline">\(k\)</span>的<code>for</code>循环不能并行，因为会导致数据读取冲突。</p><p><code>P-LUP-DECOMPOSITION</code>的串行投影是<code>LUP-DECOMPOSITION</code>，因此其工作量为<span class="math inline">\(T_1(n)=\Theta(n^3)\)</span>。</p><p>对于<code>P-LUP-DECOMPOSITION</code>的持续时间，分析和<code>P-LU-DECOMPOSITION</code>非常相似。第6，13，15，17行的<code>for</code>循环都可以进行，因此这部分只使用<span class="math inline">\(\Theta(\lgn)\)</span>的时间即可完成。最终，<code>P-LUP-DECOMPOSITION</code>的持续时间为<span class="math inline">\(T_{\infty}(n)=n\cdot \Theta(\lg n)=\Theta(n\lgn)\)</span>。</p><p>最终我们可以计算出<code>P-LUP-DECOMPOSITION</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^2/\lgn)\)</span>。</p><h2 id="c-2">c</h2><p>对<code>LUP-SOLVE</code>修改后得到的并行化版本为<code>P-LUP-SOLVE</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">P-LUP-SOLVE(L, U, π, b, n)</span><br><span class="line">  let x and y be new vectors of length n</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    val = 0</span><br><span class="line">    parallel for j = 1 to i - 1</span><br><span class="line">      val = val + l_&#123;ij&#125; * y_j</span><br><span class="line">    y_i = b_&#123;π[i]&#125; - val</span><br><span class="line">  for i = n downto 1</span><br><span class="line">    val = 0</span><br><span class="line">    parallel for j = i + 1 to n</span><br><span class="line">      val = val + u_&#123;ij&#125; * x_j</span><br><span class="line">    x_i = (y_u - val) / u_&#123;ii&#125;</span><br><span class="line">  return x</span><br></pre></td></tr></table></figure><p>第4和9行的<code>for</code>循环可以并行，只需要将长度为<span class="math inline">\(n\)</span>的序列构造出一棵<span class="math inline">\(n\)</span>个叶子节点的完全二叉树即可，对于内部节点，它是两个子节点中的值之和。因此，这两个内部<code>for</code>循环都能够在<span class="math inline">\(\Theta(\lgn)\)</span>的时间内完成。对于第2和7行的<code>for</code>循环，因为后面计算<span class="math inline">\(x,y\)</span>值需要依赖前面已经计算出的<span class="math inline">\(x,y\)</span>值。</p><p>最终，<code>P-LUP-SOLVE</code>的串行投影即为<code>LUP-SOLVE</code>，因此其工作量为<span class="math inline">\(T_1(n)=\Theta(n^2)\)</span>。按照上面的结论，可以得到持续时间<span class="math inline">\(T_{\infty}(n)=n\cdot \Theta(\lg n)=\Theta(n\lgn)\)</span>。最终我们可以计算出<code>P-LUP-SOLVE</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n/\lgn)\)</span>。</p><h2 id="d">d</h2><p>一个对正定矩阵求逆的并行算法由<code>P-MATRIX-INVERSION-POSITIVE-DEFINITE</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">P-MATRIX-INVERSION-POSITIVE-DEFINITE(A, n)</span><br><span class="line">  partition A into n/2 × n/2 submatrices B, CT, C, D; respectively</span><br><span class="line">  let W[1 : n, 1 : n], X[1 : n, 1 : n], Y[1 : n, 1 : n], Z[1 : n, 1 : n], S[1 : n, 1 : n] be new matrices</span><br><span class="line">  B&#x27; = P-MATRIX-INVERSION-POSITIVE-DEFINITE(B, n / 2)</span><br><span class="line">  W = P-MATRIX-MULTIPLY(C, B&#x27;, W, n / 2)</span><br><span class="line">  WT = W</span><br><span class="line">  P-TRANSPOSE(WT, n / 2)</span><br><span class="line">  P-MATRIX-MULTIPLY(W, CT, X, n / 2)</span><br><span class="line">  S = D - X</span><br><span class="line">  S&#x27; = P-MATRIX-INVERSION-POSITIVE-DEFINITE(S, n / 2)</span><br><span class="line">  P-MATRIX-MULTIPLY(S&#x27;, W, Y, n / 2)</span><br><span class="line">  YT = Y</span><br><span class="line">  P-TRANSPOSE(YT, n / 2)</span><br><span class="line">  P-MATRIX-MULTIPLY(WT, y, Z)</span><br><span class="line">  R = B&#x27; + Z</span><br><span class="line">  A&#x27; = [[R, -YT], [-Y, S&#x27;]]</span><br><span class="line">  return A&#x27;</span><br></pre></td></tr></table></figure><p>按照第28.2章的结论以及不等式28.15，可以知道其工作量<span class="math inline">\(I_1(n)\le2I_1(n/2)+4M_1(n/2)+O(n^2)\)</span>，最终得到<span class="math inline">\(I_1(n)=O(M(n))\)</span>。</p><p>在并行版本中，由题目26.1-8，26.2-3和题26-1-a可知，矩阵的转置、加法和乘法都可以在<span class="math inline">\(\Theta(\lgn)\)</span>时间内完成。在<code>P-MATRIX-INVERSION-POSITIVE-DEFINITE</code>中，一共进行了<span class="math inline">\(2\)</span>次矩阵转置，<span class="math inline">\(4\)</span>次矩阵加减法，<span class="math inline">\(4\)</span>次矩阵乘法。同样的，它们还进行了<span class="math inline">\(2\)</span>次大小为<span class="math inline">\(n/2\timesn/2\)</span>矩阵的求逆。可见，这些步骤都是依赖于前一步的结果，因此步骤之间不能直接并行。我们可以写出它的持续时间<span class="math inline">\(I_{\infty}(n)\)</span>满足<span class="math inline">\(I_{\infty}(n)=2I_{\infty}(n/2)+10\cdot\Theta(\lgn)\)</span>，因此最终得到<span class="math inline">\(I_{\infty}(n)=\Theta(n)\)</span>。</p><p>最终我们可以得到它的并行度为<span class="math inline">\(I_1(n)/I_{\infty}(n)=O(M(n)/n)\)</span>。</p><h1 id="section-3">26-4</h1><h2 id="a-3">a</h2><p>设计的<code>P-REDUCE</code>如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">P-REDUCE(x, i, j)</span><br><span class="line">  if i == j</span><br><span class="line">    return x[i]</span><br><span class="line">  else</span><br><span class="line">    mid = ⌊(i + j) / 2⌋</span><br><span class="line">    l = spawn P-REDUCE(x, i, mid)</span><br><span class="line">    r = spawn P-REDUCE(x, mid + 1, j)</span><br><span class="line">    sync</span><br><span class="line">    return l ⊗ r</span><br></pre></td></tr></table></figure><p>不难发现它的串行投影即为<code>REDUCE</code>，因此它的工作量为<span class="math inline">\(T_1(n)=\Theta(n)\)</span>。由于这棵进行搜索的二叉树的深度为<span class="math inline">\(\Theta(\lgn)\)</span>，因此这个算法的持续时间为<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)\)</span>。</p><h2 id="b-3">b</h2><p>这个算法相当于是以<span class="math inline">\(k=1,2,\dots,n\)</span>对<code>P-REDUCE</code>都进行了一次调用。因此<code>P-SCAN-1</code>的工作量为<span class="math inline">\(\displaystyle{T_1(n)=\sum_{k=1}^n\Theta(k)=\Theta(n^2)}\)</span>。</p><p>接下来求解<code>P-SCAN-1</code>的持续时间。由于对<code>P-SCAN-1</code>对<code>P-REDUCE</code>的间接调用呈树形，假设伪代码中，第<span class="math inline">\(i\)</span>次对<code>P-REDUCE</code>的调用的持续时间为<span class="math inline">\(iter(i)\)</span>，那么有<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)+\max\{iter(i):1\lei\le n\}\)</span>，按照题目26-4-a的结论，有<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)\)</span>。</p><p>因此<code>P-SCAN-1</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^2/\lgn)\)</span>。</p><h2 id="c-3">c</h2><p>我们可以使用归纳法进行证明其正确性。即证明，调用<code>P-SCAN-2-AUX(i, j)</code>，对于<span class="math inline">\(\forall k\in[i,j]\)</span>，它都正确计算出了<span class="math inline">\(y[k]=x[i]\otimes x[i+1]\otimes\dots\otimesx[k]\)</span>。</p><p>对于基本情况：<span class="math inline">\(i=j\)</span>，<code>P-SCAN-2-AUX</code>都正确计算出了<span class="math inline">\(y\)</span>数组，这由<code>P-SCAN-2-AUX</code>的前两行明显可知。</p><p>当<span class="math inline">\(i&lt;j\)</span>时，假设对于区间<span class="math inline">\([i,j]\)</span>内的所有真子区间<span class="math inline">\([i&#39;,j&#39;]\)</span>，即<span class="math inline">\(i\le i&#39;\le j&#39;\le j\)</span>，且<span class="math inline">\(i=i&#39;,j=j&#39;\)</span>不同时成立，<code>P-SCAN-2-AUX</code>都计算出了正确的结果。那么第三行得到了一个<span class="math inline">\(k=\lfloor(i+j)/2\rfloor\)</span>。对于第4和5行的代码，它们分别对<span class="math inline">\(y\)</span>数组的区间<span class="math inline">\([i,k]\)</span>和<span class="math inline">\([k+1,j]\)</span>进行写入，并且读取的内容也不相交，因此这两行代码不会构成竞争。在第6行结束后，<span class="math inline">\(y\)</span>数组满足：如果<span class="math inline">\(p\le k\)</span>，那么<span class="math inline">\(y[p]=x[i]\otimes x[i+1]\otimes\dots\otimesx[p]\)</span>，否则<span class="math inline">\(y[p]=x[k+1]\otimesx[k+2]\otimes\dots\otimes x[k]\)</span>。对于<span class="math inline">\(p&gt;k\)</span>的情况，第8行将<span class="math inline">\(y[p]\)</span>重新赋值成<span class="math inline">\(y[k]\otimes y[p]\)</span>。这个步骤完成后，<span class="math inline">\(\forall p\in[i,j]\)</span>，都有<span class="math inline">\(y[p]=x[i]\otimes x[i+1]\otimes\dots\otimesx[p]\)</span>。因此<code>P-SCAN-2-AUX</code>是正确的。</p><p>接下来考虑<code>P-SCAN-2-AUX</code>的工作量<span class="math inline">\(T_1(n)\)</span>，消去最后的<code>for</code>循环中的<code>parallel</code>关键字后，那么除去递归部分，它的运行时间是<span class="math inline">\(\Theta(n)\)</span>。因此可以写出<span class="math inline">\(T_1(n)=2T_1(n/2)+\Theta(n)\)</span>，从而得到<span class="math inline">\(T_1(n)=\Theta(n\lg n)\)</span>。</p><p>接下来考虑其持续时间<span class="math inline">\(T_{\infty}(n)\)</span>。可见出了递归部分，其余部分仍然需要<span class="math inline">\(\Theta(\lg n)\)</span>进行。因此有<span class="math inline">\(T_{\infty}(n)=T_{\infty}(n/2)+\Theta(\lgn)\)</span>，最终得到<span class="math inline">\(T_{\infty}(n)=\Theta(\lg^2n)\)</span>。</p><p>因此<code>P-SCAN-2</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n/\lgn)\)</span>。</p><h2 id="d-1">d</h2><p><code>P-SCAN-UP</code>第8行填入的是$<code>right ⊗ t[k]</code>；<code>P-SCAN-DOWN</code>的第5行填入<code>v</code>，第6行填入<code>v ⊗ t[k]</code>。</p><p>需要注意的是，<span class="math inline">\(t[k]\)</span>存储的是当一个区间<span class="math inline">\([i,j]\)</span>被尽量均匀地划分成两个区间<span class="math inline">\([i,k],[k+1,j]\)</span>后，<span class="math inline">\(t[k]\)</span>就是记录区间<span class="math inline">\([i,j]\)</span>前面一半元素（即<span class="math inline">\([i,k]\)</span>）的元素之和<span class="math inline">\(t[k]=x[i]\otimes x[i+1]\otimes\dots\otimesx[k]\)</span>。</p><p>首先证明，调用时每个<span class="math inline">\(t[k]\)</span>最多只会被赋值一次（因此，在执行<code>P-SCAN-DOWN</code>时不会造成任何冲突）。只有调用<code>P-SCAN-UP</code>，当<span class="math inline">\(i&lt;j\)</span>时，才会对<span class="math inline">\(t[k]\)</span>进行赋值，在此之后更深的递归讲不会再对<span class="math inline">\(t[k]\)</span>进行赋值，原因如下。如果递归的区间是左半子区间<span class="math inline">\([i,k]\)</span>，那么对于所有<span class="math inline">\([i,k]\)</span>的长度大于等于<span class="math inline">\(2\)</span>的（等于<span class="math inline">\(1\)</span>则不会进入到这个分支）真子区间<span class="math inline">\([i&#39;,k&#39;]\)</span>，都有<span class="math inline">\(\lfloor(i&#39;+k&#39;)/2\rfloor&lt;k\)</span>，因此<span class="math inline">\(t[k]\)</span>不会被重复赋值；如果递归的是右子区间<span class="math inline">\([k+1,j]\)</span>，那么它的访问和读写只会在这个区间内进行，更不会对<span class="math inline">\(t[k]\)</span>进行访问。因此，<span class="math inline">\(t[k]\)</span>确实能够正确记录区间<span class="math inline">\([i,j]\)</span>的信息。根据<code>P-SCAN-DOWB</code>的第5行代码，就可以知道<span class="math inline">\(t[k]\)</span>记录的是区间i,j的左半区间的元素之和。并且，<code>P-SCAN-UP</code>的返回值是<span class="math inline">\([i,j]\)</span>这个区间的所有元素之和，因此结论成立。</p><p>接下来证明每次调用<code>P-SCAN-DOWN(v, x, t, y, i, j)</code>时，总满足<span class="math inline">\(v=x[1]\otimes x[2]\otimes\dots\otimesx[i-1]\)</span>。同样使用归纳法来证明。在<code>P-SCAN-3</code>调用<code>P-SCAN-DOWN</code>时，有<span class="math inline">\(v=x[1],i=2\)</span>，因此基本情况下是成立的。<code>P-SCAN-DOWN</code>首先调用<code>P-SCAN-DOWN(v, x, t, y, i, k)</code>，由于参数<span class="math inline">\(i\)</span>没有变化，因此<span class="math inline">\(v\)</span>仍然使用原来的<span class="math inline">\(v\)</span>，原结论成立；然后调用<code>P-SCAN-DOWN(v ⊗ t[k], x, t, y, k + 1, j)</code>，由于此时<span class="math inline">\(t[k]=x[i]\otimes x[i+1]\otimes\dots\otimesx[k]\)</span>，因此有<span class="math inline">\(v\otimest[k]=x[1]\otimes x[2]\otimes\dots\otimesx[k]\)</span>。因此第二次调用时同样满足题目的条件。因此当<code>P-SCAN-DOWN</code>进入第2行后，<code>y[i] = v ⊗ x[i]</code>则是<span class="math inline">\(y[i]=x[1]\otimes x[2]\otimes\dots\otimesx[i]\)</span>，<span class="math inline">\(y[i]\)</span>被正确地计算出来。</p><p>因此，算法<code>P-SCAN-3</code>是正确的。</p><h2 id="e">e</h2><p>可以发现，这棵树的节点数仍然是<span class="math inline">\(\Theta(n)\)</span>，因此<code>P-SCAN-3</code>的工作量<span class="math inline">\(T_1(n)=\Theta(n)\)</span>。</p><p>接下来首先考虑<code>P-SCAN-UP</code>。由于其每次划分出了两个长度尽量均等的区间，并且其余处理部分都只要<span class="math inline">\(\Theta(1)\)</span>的时间，因此<code>P-SCAN-UP</code>这段代码的持续时间满足<span class="math inline">\(T_{\infty}(n)=T_{\infty}(n/2)+\Theta(1)\)</span>，从而得到<span class="math inline">\(T_{\infty}(n)=\Theta(\lgn)\)</span>。<code>P-SCAN-DOWN</code>和<code>P-SCAN-UP</code>的结构基本相同，因此对其分析也一样。</p><p>最终，<code>P-SCAN-3</code>的持续时间为<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)\)</span>。</p><p>因此，<code>P-SCAN-3</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n/\lgn)\)</span>。</p><h2 id="f">f</h2><p>修改后的<code>P-SCAN-3</code>由<code>P-SCAN-3'</code>给出。代价是并发度将会降低。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">P-SCAN-3&#x27;(x, n)</span><br><span class="line">  let y[1 : n] be a new array</span><br><span class="line">  y[1] = x[1]</span><br><span class="line">  if n &gt; 1</span><br><span class="line">    P-SCAN-3-AUX(x[1], x, y, 2, n)</span><br><span class="line">  return y</span><br><span class="line"></span><br><span class="line">P-SCAN-SUM-ARRAYS(x, i, j)</span><br><span class="line">  if i == j</span><br><span class="line">    return x[i]</span><br><span class="line">  else</span><br><span class="line">    k = ⌊(i + j) / 2⌋</span><br><span class="line">    l = spawn P-SCAN-SUM-ARRAYS(x, t, i, k)</span><br><span class="line">    r = P-SCAN-SUM-ARRAYS(x, t, k + 1, j)</span><br><span class="line">    return l ⊗ r</span><br><span class="line"></span><br><span class="line">P-SCAN-3-AUX(v, x, y, i, j)</span><br><span class="line">  if i == j</span><br><span class="line">    y[i] = v ⊗ x[i]</span><br><span class="line">  else</span><br><span class="line">    k = ⌊(i + j) / 2⌋</span><br><span class="line">    spawn P-SCAN-3-AUX(v, x, y, i, k)</span><br><span class="line">    t = P-SCAN-SUM-ARRAYS(x, i, k)</span><br><span class="line">    P-SCAN-3-AUX(v ⊗ t, x, y, k + 1, j)</span><br><span class="line">    sync</span><br></pre></td></tr></table></figure><h2 id="star-g"><span class="math inline">\(\star\)</span> g</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">P-SCAN-4(x, n)</span><br><span class="line">  l = 1</span><br><span class="line">  while l &lt;= n</span><br><span class="line">    parallel for i = 1 to n by l * 2</span><br><span class="line">      parallel j = 0 to l - 1</span><br><span class="line">        if i + l + j &lt;= n</span><br><span class="line">          x[i + l + j] = x[i + l + j] + x[i + l - 1]</span><br><span class="line">    l = l * 2</span><br></pre></td></tr></table></figure><p>这个算法的基本思想是，将<span class="math inline">\(x\)</span>分成<span class="math inline">\(\lceiln/(2l)\rceil\)</span>块，每一块的长度为<span class="math inline">\(2l\)</span>（最后一块不足<span class="math inline">\(2l\)</span>也以一块记），并且<span class="math inline">\(l\)</span>是<span class="math inline">\(2\)</span>的幂。一开始<span class="math inline">\(l=1\)</span>，将前半块的最后一个元素<span class="math inline">\(x[i+l-1]\)</span>添加到后半块<span class="math inline">\(x[i+l+j](0\lej&lt;l)\)</span>中的每一个元素。从而最终完成后，每一块内部都是对应值的前缀和。可见两个<code>parallel for</code>循环不会导致冲突，因此这个算法的持续时间为<span class="math inline">\(T_{\infty}(n)=\Theta(\lg^2n)\)</span>。</p><h2 id="h">h</h2><p>将字符串中的<code>(</code>视为<span class="math inline">\(+1\)</span>，<code>')'</code>视为<span class="math inline">\(-1\)</span>，得到一个数组<span class="math inline">\(x\)</span>，求出其前缀和<span class="math inline">\(y\)</span>。那么一个括号字符串是合法的，当且仅当<span class="math inline">\(\forall i\in[1,n],y_i\ge 0\)</span>，并且有<span class="math inline">\(y_n=0\)</span>。通过对<code>P-SCAN-3</code>进行改造，我们可以得到一个在<span class="math inline">\(\Theta(\lgn)\)</span>时间内判断一个括号字符串是否合法的程序<code>PARENTHESES-IS-WELL-FORMED</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">PARENTHESES-IS-WELL-FORMED(s, n)</span><br><span class="line">  let y[0 : n] and t[1 : n] be new arrays</span><br><span class="line">  y[0] = 0</span><br><span class="line">  P-SCAN-UP&#x27;(s, t, 1, n)</span><br><span class="line">  mn = P-SCAN-DOWN&#x27;(0, s, t, y, 1, n)</span><br><span class="line">  return mn &gt;= 0 and y[n] == 0</span><br><span class="line"></span><br><span class="line">P-SCAN-UP&#x27;(s, t, i, j)</span><br><span class="line">  if i == j</span><br><span class="line">    if s[i] == &#x27;(&#x27;</span><br><span class="line">      return 1</span><br><span class="line">    else</span><br><span class="line">      return -1</span><br><span class="line">  else</span><br><span class="line">    k = ⌊(i + j) / 2⌋</span><br><span class="line">    t[k] = spawn P-SCAN-UP&#x27;(s, t, i, k)</span><br><span class="line">    right = P-SCAN-UP&#x27;(s, t, k + 1, j)</span><br><span class="line">    sync</span><br><span class="line">    return t[k] + right</span><br><span class="line"></span><br><span class="line">P-SCAN-DOWN&#x27;(v, s, t, y, i, j)</span><br><span class="line">  if i == j</span><br><span class="line">    y[i] = v + x[i]</span><br><span class="line">    return y[i]</span><br><span class="line">  else</span><br><span class="line">    k = ⌊(i + j) / 2⌋</span><br><span class="line">    l = spawn P-SCAN-DOWN (v, x, t, y, i, k)</span><br><span class="line">    r = P-SCAN-DOWN(v + t[k], x, t, y, k + 1, j)</span><br><span class="line">    sync</span><br><span class="line">    return min&#123;l, r&#125;</span><br></pre></td></tr></table></figure><p>改造后的程序还返回了前缀和数组中的最小值。</p><h1 id="section-4">26-5</h1><h2 id="a-4">a</h2><p>不失一般性，这里假设矩阵<span class="math inline">\(A\)</span>的大小<span class="math inline">\(n\)</span>是<span class="math inline">\(2\)</span>的幂次。基于等式26.9，那么对矩阵<span class="math inline">\(A\)</span>的填充并行分治算法由<code>SIMPLE-STENCIL</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SIMPLE-STENCIL(A, n)</span><br><span class="line">  if n == 1</span><br><span class="line">    generate the value of a11</span><br><span class="line">    return</span><br><span class="line">  partition A into n/2 × n/2 submatrices A11, A12, A21, A22; respectively</span><br><span class="line">  SIMPLE-STENCIL(A11, n / 2)</span><br><span class="line">  spawn SIMPLE-STENCIL(A12, n / 2)</span><br><span class="line">  spawn SIMPLE-STENCIL(A21, n / 2)</span><br><span class="line">  sync</span><br><span class="line">  SIMPLE-STENCIL(A22, n / 2)</span><br></pre></td></tr></table></figure><p>可见这个算法只是为了填充原来矩阵的所有元素，由其串行投影可以知道其工作量满足<span class="math inline">\(T_1(n)=4T_1(n/2)+\Theta(1)\)</span>，可以得到<span class="math inline">\(T_1(n)=\Theta(n^2)\)</span>。</p><p>这个算法的持续时间满足<span class="math inline">\(T_{\infty}(n)=3T_\infty(n/2)+\Theta(1)\)</span>，可以得到<span class="math inline">\(T_{\infty}(n)=\Theta(n^{\lg 3})\)</span>。</p><p>最终可以得到并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^{2-\lg3})\)</span>。</p><h2 id="b-4">b</h2><p>不失一般性，这里假设矩阵<span class="math inline">\(A\)</span>的大小<span class="math inline">\(n\)</span>是<span class="math inline">\(3\)</span>的幂次，那么按照题目26-5-a的结果，我们可以对<code>SIMPLE-STENCIL</code>修改成<code>SIMPLE-STENCIL3</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SIMPLE-STENCIL3(A, n)</span><br><span class="line">  if n == 1</span><br><span class="line">    generate the value of a11</span><br><span class="line">    return</span><br><span class="line">  partition A into n/3 × n/3 submatrices A11, A12, A13, A21, A22, A23, A31, A32, A33; respectively</span><br><span class="line">  SIMPLE-STENCIL3(A11, n / 3)</span><br><span class="line">  spawn SIMPLE-STENCIL3(A12, n / 3)</span><br><span class="line">  spawn SIMPLE-STENCIL3(A21, n / 3)</span><br><span class="line">  sync</span><br><span class="line">  spawn SIMPLE-STENCIL3(A13, n / 3)</span><br><span class="line">  spawn SIMPLE-STENCIL3(A22, n / 3)</span><br><span class="line">  spawn SIMPLE-STENCIL3(A31, n / 3)</span><br><span class="line">  sync</span><br><span class="line">  spawn SIMPLE-STENCIL3(A23, n / 3)</span><br><span class="line">  spawn SIMPLE-STENCIL3(A32, n / 3)</span><br><span class="line">  sync</span><br><span class="line">  SIMPLE-STENCIL3(A33, n / 3)</span><br></pre></td></tr></table></figure><p>和题目26-3-a分析的过程类似，可以知道其工作量满足<span class="math inline">\(T_1(n)=9T_1(n/3)+\Theta(1)\)</span>，可以得到<span class="math inline">\(T_1(n)=\Theta(n^2)\)</span>。</p><p>这个算法的持续时间满足<span class="math inline">\(T_{\infty}(n)=5T_\infty(n/3)+\Theta(1)\)</span>，可以得到<span class="math inline">\(T_{\infty}(n)=\Theta(n^{\log_3 5})\)</span>。</p><p>最终可以得到并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^{2-\log_35})\)</span>。</p><h2 id="c-4">c</h2><p>利用类似的方式修改题目26-5-a和26-5-b的代码，可以给出<code>SIMPLE-STENCIL-B</code>代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SIMPLE-STENCIL-B(A, n)</span><br><span class="line">  if n == 1</span><br><span class="line">    generate the value of a11</span><br><span class="line">    return</span><br><span class="line">  partition A into n/b × n/b submatrices A11, A12, ..., A1b, A21, A22, ..., A2b, ...,  Ab1, Ab2, ..., Abb; respectively</span><br><span class="line">  for k = 2 to b * b</span><br><span class="line">    //注意这里的parallel for 循环将是以硬编码的形式构造出来，因此后面的分析不会对Θ(lg n)这个因子进行考虑。</span><br><span class="line">    parallel for i = 1 to b</span><br><span class="line">      j = k - i</span><br><span class="line">      if 1 &lt;= j and j &lt;= b</span><br><span class="line">      SIMPLE-STENCIL3(Aij, n / b)</span><br></pre></td></tr></table></figure><p>和题目26-3-a和26-3-b分析的过程类似，可以知道其工作量满足<span class="math inline">\(T_1(n)=b^2T_1(n/b)+\Theta(1)\)</span>，可以得到<span class="math inline">\(T_1(n)=\Theta(n^2)\)</span>。</p><p>这个算法的持续时间满足<span class="math inline">\(T_{\infty}(n)=(2b-1)T_\infty(n/b)+\Theta(1)\)</span>，可以得到<span class="math inline">\(T_{\infty}(n)=\Theta(n^{\log_b(2b-1)})\)</span>。</p><p>最终可以得到并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^{2-\log_b(2b-1)})\)</span>。</p><p>为了证明<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^{2-\log_b(2b-1)})=o(n)\)</span>，那么需要证明<span class="math inline">\(f\forallb\ge 2\)</span>，都有<span class="math inline">\(2-\log_b(2b-1)&lt;1\)</span>，即证明<span class="math inline">\(\log_b(2b-1)&gt;1\)</span>。由于<span class="math inline">\(\forall b\ge 2\)</span>，都有<span class="math inline">\(2b-1&gt;b\)</span>，因此<span class="math inline">\(\log_b(2b-1)&gt;1\)</span>成立是很显然的。因此有<span class="math inline">\(T_1(n)/T_{\infty}(n)=o(n)\)</span>。</p><h2 id="d-2">d</h2><p>这个算法由<code>STENCIL</code>给出，并且它还能对更一般形式的矩阵进行填充。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">STENCIL(A, n)</span><br><span class="line">  for k = 2 to n + n - 1</span><br><span class="line">    up = max&#123;1, k - n&#125;</span><br><span class="line">    down = min&#123;n, k - 1&#125;</span><br><span class="line">    parallel for i = up to down</span><br><span class="line">      j = k - i</span><br><span class="line">      generate the value of aij</span><br></pre></td></tr></table></figure><p>可以知道<code>STENCIL</code>的工作量是<span class="math inline">\(T_1(n)=\Theta(n^2)\)</span>，因为它仅仅是从小到大枚举矩阵的每条副对角线，并按顺序填入一个个元素。</p><p>可以知道<code>STENCIL</code>的持续时间满足<span class="math inline">\(T_\infty(n)=n\cdot\Theta(\lg n)=\Theta(n\lgn)\)</span>。因为第<span class="math inline">\(k\)</span>轮迭代最多也只会进行<span class="math inline">\(n\)</span>次操作。如果去掉关键字<code>parallel</code>关键字并转化为<code>spawn ... sync</code>结构，那么这一部分需要花费<span class="math inline">\(\Theta(\lg n)\)</span>的时间。</p><p>因此，<code>STENCIL</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n/\lgn)\)</span>。</p><p>如果需要达到<span class="math inline">\(\Theta(n)\)</span>的并行度，那么可以将<code>parallel for</code>循环转化成硬编码形式，从而去掉这个<code>parallel for</code>循环，并且一次性在<span class="math inline">\(\Theta(1)\)</span>的时间内生产<span class="math inline">\(\Theta(n)\)</span>个元素，从而使并行度提升到<span class="math inline">\(\Theta(n)\)</span>。但是这里使用了<code>parallel for</code>循环，它是基于分治法实现的，因此达不到这个最大并行度。</p><h1 id="section-5">26-6</h1><h2 id="a-5">a</h2><p>工作量定律将改写成<span class="math inline">\(E[T_P]\geE[T_1]/P\)</span>；持续时间定律将改写成<span class="math inline">\(E[T_P]\geE[T_{\infty}]\)</span>；贪心调度界限改写成<span class="math inline">\(E[T_P]\le E[T_1]/P+E[T_{\infty}]\)</span>。</p><h2 id="b-5">b</h2><p>按照题目给出的数据，令<span class="math inline">\(P=10000\)</span>，那么可以写出以下三条式子：</p><p><span class="math inline">\(\begin{aligned} E[T_1]&amp;=10^4\cdot0.01+10^9\cdot 0.99\\ E[T_P]&amp;=1\cdot 0.01+10^9\cdot0.99\\E[T_1/T_P]&amp;=\dfrac{10^4}{1}\cdot0.01+\dfrac{10^9}{10^9}\cdot0.99\\\end{aligned}\)</span></p><p>从而得到<span class="math inline">\(E[T_1/T_P]\approx100,\dfrac{E[T_1]}{E[T_P]}\approx1\)</span>。</p><p>选用<span class="math inline">\(\dfrac{E[T_1]}{E[T_P]}\)</span>的原因有如下两个：</p><ol type="1"><li><p>由于在绝大多数时间中，无论是<span class="math inline">\(P=1\)</span>还是<span class="math inline">\(P=10000\)</span>，其运行时间大多数都在<span class="math inline">\(10^9\)</span>，因此说明这个添加到<span class="math inline">\(P=10000\)</span>的操作应该对加速作用不大，因此选用<span class="math inline">\(\dfrac{E[T_1]}{E[T_P]}\)</span>是一个比较恰当的值。</p></li><li><p><span class="math inline">\(T_1/T_P\)</span>这个随机变量并不成立。题目中没有提到<span class="math inline">\(T_1=10^4\)</span>和<span class="math inline">\(T_1=10^9\)</span>的时机是否和<span class="math inline">\(T_P=1\)</span>和<span class="math inline">\(T_P=10^9\)</span>的时机相同。也就是说，它们不一定是相关的。因此采用独立计算更加合适，即选用<span class="math inline">\(\dfrac{E[T_1]}{E[T_P]}\)</span>。</p></li></ol><h2 id="c-5">c</h2><p>当<span class="math inline">\(P\)</span>趋于无穷时，期望的加速比应该和并行度相等。这和题目26-6-b使用的定义是一致的。</p><h2 id="d-3">d</h2><p>我们可以对第7.3章提到的<code>RANDOMIZED-QUICKSORT</code>算法提出其并行化版本<code>P-RANDOMIZED-QUICKSORT</code>（按照题目要求，不对<code>RANDOMIZED-PARTITION</code>并行化）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">P-RANDOMIZED-QUICKSORT(A, p, r)</span><br><span class="line">  if p &lt; r:</span><br><span class="line">    q = RANDOMIZED-PARTITION(A, p, r)</span><br><span class="line">    spawn P-RANDOMIZED-QUICKSORT(A, p, q - 1)</span><br><span class="line">    spawn P-RANDOMIZED-QUICKSORT(A, q + 1, r)</span><br><span class="line">    sync</span><br></pre></td></tr></table></figure><h2 id="e-1">e</h2><p>可见，<code>P-RANDOMIZED-QUICKSORT</code>的串行投影为<code>RANDOMIZED-QUICKSORT</code>，因此其期望工作量<span class="math inline">\(E[T_1(n)]=O(n\lg n)\)</span>。</p><p>对于<code>P-RANDOMIZED-QUICKSORT</code>持续时间，考虑将<code>P-RANDOMIZED-QUICKSORT</code>和<code>RANDOMIZED-SELECT</code>的行为进行对比。<code>P-RANDOMIZED-QUICKSORT</code>的<code>RANDOMIZED-PARTITION</code>和<code>RANDOMIZED-SELECT</code>中的一样，这部分都是占据了主导的时间<span class="math inline">\(\Theta(n)\)</span>。因此，对其划分的推导也和第9.2章给的完全一样。接下来考虑其递归部分。可以发现，<code>P-RANDOMIZED-QUICKSORT</code>的阶段划分和<code>RANDOMIZED-SELECT</code>也相同，并且证明过程同样也考虑了那个执行时间比较长的执行分支。因此对<code>P-RANDOMIZED-QUICKSORT</code>持续时间<span class="math inline">\(T_{\infty}(n)\)</span>的分析过程和<code>RANDOMIZED-SELECT</code>的分析过程完全一致。按照定理9.2的结论，我们得到<span class="math inline">\(T_{\infty}(n)=\Theta(n)\)</span>。</p><p>因此，<code>P-RANDOMIZED-QUICKSORT</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=O(\lg n)\)</span>。</p><h2 id="f-1">f</h2><p><code>RANDOMIZED-SELECT</code>的并行化版本由<code>P-RANDOMIZED-SELECT</code>给出。其中，给定的<code>P-RANDOMIZED-PARTITION</code>由题目26.3-3的<code>P-PARTITION</code>实现而来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">P-RANDOMIZED-PARTITION(A, p, r)</span><br><span class="line">  i = RANDOM(p, r)</span><br><span class="line">  exchange A[r] with A[i]</span><br><span class="line">  return P-PARTITION(A, p, r)</span><br><span class="line"></span><br><span class="line">P-RANDOMIZED-SELECT(A, p, r, i)</span><br><span class="line">  if p == r</span><br><span class="line">    return A[p]</span><br><span class="line">  q = P-RANDOMIZED-PARTITION(A, p, r)</span><br><span class="line">  k = q – p + 1</span><br><span class="line">  if i == k</span><br><span class="line">    return A[q]</span><br><span class="line">  else if i &lt; k</span><br><span class="line">    return P-RANDOMIZED-SELECT(A, p, q – 1, i)</span><br><span class="line">  else </span><br><span class="line">    return P-RANDOMIZED-SELECT(A, q + 1, r, i – k)</span><br></pre></td></tr></table></figure><p>可见这个算法的串行投影为<code>RANDOMIZED-SELECT</code>，因此它的工作量为<span class="math inline">\(T_1(n)=\Theta(n)\)</span>。</p><p>令示性遍历<span class="math inline">\(X_k\)</span>表示<code>P-RANDOMIZED-PARTITION</code>划分出来后的元素在于位置<span class="math inline">\(k\)</span>。那么由于程序的其余部分都需要<span class="math inline">\(\Theta(\lgn)\)</span>完成（根据题目26.3-3的结论，这里的主要开销就在于<code>P-RANDOMIZED-PARTITION</code>需要花费<span class="math inline">\(\Theta(\lgn)\)</span>的时间），因此可以对随机变量<span class="math inline">\(T_{\infty}(n)\)</span>可以写出如下递推式：</p><p><span class="math display">\[T_{\infty}(n)=\sum_{i=1}^n X_k\cdotT_{\infty}(\max\{k-1,n-k\})+\Theta(\lg n)\]</span></p><p>可见<span class="math inline">\(E[X_k]=\dfrac{1}{n}\)</span>，因为每个位置都有可能被选到。那么对式子左右两侧取期望值，那么有</p><p><span class="math inline">\(\begin{aligned}E[T_{\infty}(n)]&amp;=\sum_{k=1}^n E[X_k]\cdotE[T_{\infty}(\max\{k-1,n-k\})]+\Theta(\lg n)\\&amp;\le\dfrac{2}{n}\sum_{k=\lfloor n/2\rfloor}^{n-1}E[T_{\infty}(k)]+\Theta(\lg n)\\ \end{aligned}\)</span></p><p>接下来使用代入法证明<span class="math inline">\(E[T_{\infty}(n)]=O(n^d)\)</span>，即<span class="math inline">\(\exists c,n_0&gt;0,d\in(0,1)\)</span>，使得<span class="math inline">\(\forall n\ge n_0\)</span>，都有<span class="math inline">\(E[T_{\infty}(n)]\le c\cdotn^{d}\)</span>。那么就可以得到</p><p><span class="math inline">\(\begin{aligned}E[T_{\infty}(n)]&amp;\le\dfrac{2}{n}\sum_{k=\lfloor n/2\rfloor}^{n-1}E[T_{\infty}(k)]+\Theta(\lg n)\\ &amp;\le\dfrac{2}{n}\sum_{k=\lfloorn/2\rfloor}^{n-1} c\cdot k^d+\Theta(\lg n)\\&amp;=\dfrac{2c}{n}\sum_{k=\lfloor n/2\rfloor}^{n-1} k^d+\Theta(\lg n)\\&amp;\le \dfrac{2c}{n}\int_{\lfloor n/2\rfloor}^n x^d dx+\Theta(\lg n)\\&amp;=\dfrac{2c}{n}\cdot\left.\dfrac{x^{d+1}}{d+1}\right|_{x=\lfloorn/2\rfloor}^n+\Theta(\lg n)\\ &amp;=c\cdot\dfrac{2-2^{-d}}{d+1}\cdot n^d+ \Theta(\lg n) \end{aligned}\)</span></p><p>考虑关于<span class="math inline">\(d\)</span>的一元一次不等式<span class="math inline">\(\dfrac{2-2^{-d}}{d+1}&lt;1\)</span>，可以得到<span class="math inline">\(d&gt;0\)</span>。</p><p>也就是说，无论<span class="math inline">\(d\)</span>取<span class="math inline">\((0,1)\)</span>中的什么值，只要第一个项中的<span class="math inline">\(c\)</span>足够大，它就可以覆盖到<span class="math inline">\(\Theta(\lg n)\)</span>中的常数，从而最终得到<span class="math inline">\(T_{\infty}(n)\)</span></p><p>因此，<span class="math inline">\(T_{\infty}(n)=o(n^d)\)</span>，其中<span class="math inline">\(d\)</span>是任意正数。</p><p>最终可以得到并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^{1-d})\)</span>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论26.3 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/26-3-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/26-3-Exercises/</id>
    <published>2023-10-01T11:28:01.000Z</published>
    <updated>2023-10-01T11:28:01.400Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">26.3-1</h1><p>基本思想是，只需要当前排序的数组长度小于等于某个很小的阈值<span class="math inline">\(K\)</span>，那么就选择使用原本串行的归并方式。否则使用当前优化过的归并方式，这个过程由<code>P-MERGE'</code>给出。其中<code>MEGRE'</code>和<code>MERGE</code>相比，表示将排序结果存储到<span class="math inline">\(B\)</span>中（而不是原本的<span class="math inline">\(A\)</span>中）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">P-MERGE&#x27;(A, p, q, r)</span><br><span class="line">  let B[p : r] be a new array             // allocate scratch array</span><br><span class="line">  if r - p &gt; M</span><br><span class="line">    P-MERGE-AUX(A, p, q, q + 1, r, B, p)  // merge from A into B</span><br><span class="line">  else</span><br><span class="line">    MERGE&#x27;(A, p, q, r, B)</span><br><span class="line">  parallel for i = p to r                 // copy B back to A in parallel</span><br><span class="line">    A[i] = B[i]</span><br></pre></td></tr></table></figure><h1 id="section-1">26.3-2</h1><p>通过对题目9.3-10给出的<code>MEDIAN3</code>进行改造，我们给出了一个程序<code>MEDIAN4</code>，它用于求解两个有序数组<span class="math inline">\(A[1:n],B[1:m]\)</span>中的中位数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 找出数组A[i : n], B[j : m]中的第k小数。</span><br><span class="line">SELECT4(A, i, n, B, j, m, k)</span><br><span class="line">  if i &gt; n</span><br><span class="line">    return B[j + k - 1]</span><br><span class="line">  else if j &gt; m</span><br><span class="line">    return A[j + k - 1]</span><br><span class="line">  else if k == 1</span><br><span class="line">    return min&#123;A[i], B[j]&#125;</span><br><span class="line">  if i + ⌊k/2⌋ - 1 &lt;= n</span><br><span class="line">    midl = A[i + ⌊k/2⌋ - 1]</span><br><span class="line">  else</span><br><span class="line">    midl = +∞</span><br><span class="line">  if j + ⌊k/2⌋ - 1 &lt;= m</span><br><span class="line">    midr = B[i + ⌊k/2⌋ - 1]</span><br><span class="line">  else</span><br><span class="line">    midr = +∞</span><br><span class="line">  if midl &lt; midr</span><br><span class="line">    return SELECT4(A, i + ⌊k/2⌋, n, B, j, m, k - ⌊k/2⌋, n)</span><br><span class="line">  else</span><br><span class="line">    return SELECT4(A, i, n, B, j + ⌊k/2⌋, m, k - ⌊k/2⌋, n)</span><br><span class="line"></span><br><span class="line">MEDIAN4(A, B, n, m)</span><br><span class="line">  return SELECT4(A, 1, n, B, 1, m, ⌊(n + m) / 2⌋)</span><br></pre></td></tr></table></figure><p>由此可以将<code>P-MERGE-AUX</code>修改成<code>P-MERGE-AUX'</code>，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">P-MERGE-AUX(A, p1, r1, p2, r2, B, p3)</span><br><span class="line">  if p1 &gt; r1 and p2 &gt; r2</span><br><span class="line">    return</span><br><span class="line">  if r1 − p1 &lt; r2 − p2</span><br><span class="line">    exchange p1 with p2</span><br><span class="line">    exchange r1 with r2</span><br><span class="line">  x = MEDIAN4(A[p1 : r1], B[p2 : r2], r1 - p1 + 1, r2 - p2 + 2)</span><br><span class="line">  q2 = FIND-SPLIT-POINT(A, p2, r2, x)</span><br><span class="line">  q3 = p3 + (q1 − p1) + (q2 − p2) </span><br><span class="line">  B[q3] = x</span><br><span class="line">  spawn P-MERGE-AUX(A, p1, q1 − 1, p2, q2 − 1, B, p3)</span><br><span class="line">  spawn P-MERGE-AUX(A, q1 + 1, r1, q2, r2, B, q3 + 1)</span><br><span class="line">  sync</span><br></pre></td></tr></table></figure><p>先求解<code>P-MERGE-AUX'</code>的工作量<span class="math inline">\(T_1(n)\)</span>。可见，由于每次都淘汰了数组中一半的元素，并且每一轮除了递归部分，只需要<span class="math inline">\(\Theta(\lg n)\)</span>的时间运行。因此有<span class="math inline">\(T_1(n)=2T_1(n/2)+\Theta(\lgn)\)</span>。根据主定理可以得到<span class="math inline">\(T_1(n)=\Theta(n)\)</span>。</p><p>接下来求解<code>P-MERGE-AUX'</code>的持续时间<span class="math inline">\(T_{\infty}(n)\)</span>。同样的，我们得到<span class="math inline">\(T_\infty(n)=T_\infty(n/2)+\Theta(\lgn)\)</span>。从而得到<span class="math inline">\(T_{\infty}(n)=\Theta(\lg^2n)\)</span>。</p><p>由于<code>P-MERGE-AUX'</code>的工作量和持续时间都不变，因此得到的<code>P-MERGE'</code>得到的工作量和持续时间和第26.3章分析的一样，分别为<span class="math inline">\(\Theta(n)\)</span>和<span class="math inline">\(\Theta(\lg^2n)\)</span>。因此其并行量仍然为<span class="math inline">\(\Theta(n/\lg^2 n)\)</span>。</p><h1 id="section-2">26.3-3</h1><p><code>PARTITION</code>的并行化版本<code>P-PARTITION</code>如下展示。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// 令T[p, r]表示一棵二叉树T存储了区间[p, r]内所有数的相关信息，包括：</span><br><span class="line">// small：A[p, r]中小于等于x的数的个数。</span><br><span class="line">// large：[p, r]中大于x的数的个数。</span><br><span class="line">P-PARTITION-CAL(A, p, r, x)</span><br><span class="line">  if p == r</span><br><span class="line">    if A[p] &lt;= x</span><br><span class="line">      T[p, r].small = 1</span><br><span class="line">      T[p, r].large = 0</span><br><span class="line">      return (1, 0)</span><br><span class="line">    else</span><br><span class="line">      T[p, r].small = 0</span><br><span class="line">      T[p, r].large = 1</span><br><span class="line">      return (0, 1)</span><br><span class="line">  else</span><br><span class="line">    mid = ⌊(p + r) / 2⌋</span><br><span class="line">    cl-small, cl-large = spawn P-PARTITION-CAL(A, p, mid, x)</span><br><span class="line">    cr-small, cr-large = spawn P-PARTITION-CAL(A, mid + 1, q, x)</span><br><span class="line">    sync</span><br><span class="line">    T[p, r].small = cl-small + cr-small</span><br><span class="line">    T[p, r].large = cl-large + cr-large</span><br><span class="line">    return (T[p, r].small, T[p, r].large)</span><br><span class="line"></span><br><span class="line">P-PARTITION-FILL(A, p, r, x, B, ls, rs, ll, rl)</span><br><span class="line">  if p == r:</span><br><span class="line">    if A[p] &lt;= x</span><br><span class="line">      B[ls] = A[p]</span><br><span class="line">    else</span><br><span class="line">      B[ll] = A[p]</span><br><span class="line">  else</span><br><span class="line">    mid = ⌊(p + r) / 2⌋</span><br><span class="line">    spawn P-PARTITION-FILL(A, p, mid, x, B, ls, ls + T[p, mid].small - 1, ll, ll + T[p, mid].large + 1)</span><br><span class="line">    spawn P-PARTITION-FILL(A, p, mid, x, B, rs - T[mid + 1, r].small + 1, rs, rl - T[mid + 1, r].large + 1, rl)</span><br><span class="line">    sync</span><br><span class="line"></span><br><span class="line">P-PARTITION(A, p, r)</span><br><span class="line">  if p == r</span><br><span class="line">    return p</span><br><span class="line">  x = A[r]</span><br><span class="line">  c-small, c-large = P-PARTITION-CAL(A, p, r - 1, x)</span><br><span class="line">  let B[p : r] be a new array</span><br><span class="line">  q = p + c-small</span><br><span class="line">  B[q] = x</span><br><span class="line">  P-PARTION-FILL(A, p, r, x, B, p, p + c-small - 1, r - c-large + 1, r)</span><br><span class="line">  parallel for i = p to r</span><br><span class="line">    A[i] = B[i]</span><br><span class="line">  return q</span><br></pre></td></tr></table></figure></p><p>我们可以首先并行化地构筑出一棵二叉树<span class="math inline">\(T\)</span>，其中<span class="math inline">\(T[l,r]\)</span>存储区间<span class="math inline">\([l,r]\)</span>内的信息：小于等于<span class="math inline">\(x\)</span>的元素个数和大于<span class="math inline">\(x\)</span>的元素个数。我们可以知道这棵树的节点数为<span class="math inline">\(\displaystyle{\sum_{i=0}^{\infty}\left\lceil\dfrac{n}{2^i}\right\rceil}=\Theta(n)\)</span>。</p><p>因此，第一趟遍历首先是将这棵树的所有节点信息先处理出来（如<code>P-PARTITION-CAL</code>所示），由于这棵树一共有<span class="math inline">\(\Theta(n)\)</span>个节点，其深度为<span class="math inline">\(\Theta(\lgn)\)</span>，因此这一部分的工作量为<span class="math inline">\(\Theta(n)\)</span>，持续时间为<span class="math inline">\(\Theta(\lg n)\)</span>。</p><p>第二趟遍历则是按照树给定的信息，自底向上地将所有元素填入新数组<span class="math inline">\(B\)</span>中（如<code>P-PARTITION-FILL</code>所示）。这一部分的分析和第一趟类似，这一部分的工作量为<span class="math inline">\(\Theta(n)\)</span>，持续时间为<span class="math inline">\(\Theta(\lg n)\)</span>。</p><p>第三趟遍历则是将<span class="math inline">\(B\)</span>数组并行地填入<span class="math inline">\(A\)</span>中对应位置，因此这一部分的工作量为<span class="math inline">\(\Theta(n)\)</span>，持续时间为<span class="math inline">\(\Theta(\lg n)\)</span>。</p><p>也就是说，<code>P-PARTITION</code>的工作量<span class="math inline">\(T_1(n)\)</span>满足<span class="math inline">\(T_1(n)=2T_1(n/2)+\Theta(1)\)</span>，即得到<span class="math inline">\(T_1(n)=\Theta(n)\)</span>。其工作时间<span class="math inline">\(T_{\infty}(n)\)</span>满足<span class="math inline">\(T_\infty(n)=T_{\infty}(n/2)+\Theta(1)=\Theta(\lgn)\)</span>。因此其并行度为<span class="math inline">\(\Theta(n/\lgn)\)</span>。</p><h1 id="section-3">26.3-4</h1><p>给出的<code>FFT</code>的并行版本<code>P-FFT</code>如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FFT(a, n)</span><br><span class="line">  if n == 1</span><br><span class="line">    return a</span><br><span class="line">  let a-even_&#123;0 : n / 2 - 1&#125;, a-odd_&#123;0 : n / 2 - 1&#125; be new arrays</span><br><span class="line">  parallel for k = 0 to n / 2 - 1</span><br><span class="line">    a-even_&#123;k&#125; = a_&#123;k * 2&#125;</span><br><span class="line">    a_odd_&#123;k&#125; = a_&#123;k * 2 + 1&#125;</span><br><span class="line">  y-even = spawn FFT(a-even, n / 2)</span><br><span class="line">  y-odd = spawn FFT(a-odd, n / 2)</span><br><span class="line">  sync</span><br><span class="line">  parallel for k = 0 to n / 2 - 1</span><br><span class="line">    ω = exp(2 * π * i * k / n)</span><br><span class="line">    y_k = y-even_&#123;k&#125; + ω * y-odd_&#123;k&#125;</span><br><span class="line">    y_&#123;k + n / 2&#125; = y-even_&#123;k&#125; - ω * y-odd_&#123;k&#125;</span><br><span class="line">  return y</span><br></pre></td></tr></table></figure><p><code>P-FFT</code>和其串行投影<code>FFT</code>的区别在于：将<span class="math inline">\(a\)</span>向量进行奇偶划分的过程可以并行完成。其次，<span class="math inline">\(y^{even},y^{odd}\)</span>的计算也是同时派生出两个子线程再进行合并。此外，<span class="math inline">\(\omega_n^k\)</span>的值不能够递推计算，它只能以<span class="math inline">\((\omega_n)^k\)</span>的方式进行计算。</p><p>可见其串行投影为普通的<code>FFT</code>，因此其工作量为<span class="math inline">\(T_1(n)=\Theta(n\lg n)\)</span>。</p><p>每次递归，它都会将两个大小恰好为一半的两个子问题进行递归计算，其余部分只需要<span class="math inline">\(\Theta(\lgn)\)</span>的时间就能够完成好（如两次次<code>parallel for</code>循环以及<span class="math inline">\(\omega_n^k\)</span>的计算），因此其持续时间满足<span class="math inline">\(T_{\infty}(n)=T_{\infty}(n/2)+\Theta(\lgn)\)</span>，最终得到<span class="math inline">\(T_{\infty}(n)=\Theta(\lg^2n)\)</span>。</p><p>因此，<code>P-FFT</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n/\lgn)\)</span>。</p><h1 id="star-26.3-5"><span class="math inline">\(\star\)</span>26.3-5</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">P-SELECT(A, p, r, i)</span><br><span class="line">  g = ⌊(r – p + 1) / 5⌋</span><br><span class="line">  f = (r - p + 1) % 5</span><br><span class="line">  parallel for j = p to p + g – 1</span><br><span class="line">    sort〈A[j], A[j + g], A[j + 2 * g], A[j + 3 * g], A[j + 4 * g]〉in place</span><br><span class="line">  for j = 0 to t - 1</span><br><span class="line">    exchange A[p + 3 * g + j] with A[p + 5 * g + j] </span><br><span class="line">  x = P-SELECT(A, p + 2 * g, p + 3 * g + f – 1, ⌈(g + f) /2⌉)</span><br><span class="line">  q = P-PARTITION-AROUND(A, p, r, x)</span><br><span class="line">  k = q – p + 1</span><br><span class="line">  if i == k</span><br><span class="line">    return A[q]</span><br><span class="line">  else if i &lt; k</span><br><span class="line">    return P-SELECT(A, p, q – 1, i)</span><br><span class="line">  else </span><br><span class="line">    return P-SELECT(A, q + 1, r, i – k)</span><br></pre></td></tr></table></figure><p>修改后得到的<code>P-SELECT</code>算法如上。相比于<code>SELECT</code>，<code>P-SELECT</code>将未满一个组的五个元素进行了延后处理。此外，套用题目26.3-3的结论，<code>P-PARTITION-AROUND</code>可以由<code>PARTITION-AROUND</code>转化而来。其余部分只需要<span class="math inline">\(\Theta(\lg n)\)</span>的时间即可完成。</p><p>因此，<code>P-SELECT</code>的工作量<span class="math inline">\(T_1(n)\)</span>和<code>SELECT</code>的运行时间一样，为<span class="math inline">\(\Theta(n)\)</span>。</p><p><code>P-SELECT</code>的持续时间<span class="math inline">\(T_{\infty}(n)\)</span>可以由<span class="math inline">\(T_{\infty}(n)\leT_{\infty}(n/5)+T_{\infty}(7n/10)+\Theta(\lgn)\)</span>给出。这里可以考虑使用第4.7章介绍的Akra-Bazzi方法进行求解。</p><p>令<span class="math inline">\(c_1=\dfrac{1}{5},c_2=\dfrac{7}{10}\)</span>，构造关于未知数<span class="math inline">\(p\)</span>的方程<span class="math inline">\(c_1^p+c_2^p=1\)</span>，可以得到<span class="math inline">\(p\approx0.84\)</span>。因此，使用等式4.23，可以得到</p><p><span class="math inline">\(\begin{aligned}T_{\infty}(n)&amp;=\Theta\left(n^p\left(1+\int_{1}^n\dfrac{f(x)}{x^{p+1}}dx\right)\right) \\&amp;=\Theta\left(n^p\left(1+\int_{1}^n \dfrac{\lgx}{x^{p+1}}dx\right)\right) \\&amp;=\Theta\left(n^p\left(1+\left(\dfrac{1-n^{-p}(1+p\ln n)}{p^2\ln2}\right)\right)\right) \\ &amp;=\Theta(n^p) \end{aligned}\)</span></p><p>因此，<code>P-SELECT</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^{1-p})\approx\Theta(n^{0.16})\)</span>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论26.2 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/26-2-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/26-2-Exercises/</id>
    <published>2023-10-01T11:27:58.000Z</published>
    <updated>2023-10-01T11:27:58.941Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">26.2-1</h1><p>使用<code>P-MATRIX-MULTIPLY</code>计算<span class="math inline">\(2\times 2\)</span>矩阵的轨迹如下图所示：</p><p><img data-src="26.2-1.png"></p><p>可见，图中有<span class="math inline">\(13\)</span>个节点，因此其工作量为<span class="math inline">\(13\)</span>。此外，粗线表示这个有向无环图的最长链，其一共有<span class="math inline">\(6\)</span>个节点，因此其持续时间为<span class="math inline">\(6\)</span>，最终我们得到并行度为<span class="math inline">\(\dfrac{13}{6}\)</span>。</p><h1 id="section-1">26.2-2</h1><p>使用<code>P-MATRIX-MULTIPLY-RECURSIVE</code>计算<span class="math inline">\(2\times 2\)</span>矩阵的轨迹如下图所示：</p><p><img data-src="26.2-2.png"></p><p>可见，图中有<span class="math inline">\(42\)</span>个节点，因此其工作量为<span class="math inline">\(42\)</span>。此外，粗线表示这个有向无环图的最长链，其一共有<span class="math inline">\(23\)</span>个节点，因此其持续时间为<span class="math inline">\(23\)</span>，最终我们得到并行度为<span class="math inline">\(\dfrac{42}{23}\)</span>。</p><h1 id="section-2">26.2-3</h1><p>对<code>P-MATRIX-MULTIPLY</code>修改后，由<code>P-MATRIX-MULTIPLY'</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, k, k&#x27;)</span><br><span class="line">  if k == k&#x27;</span><br><span class="line">    return a_&#123;ik&#125; * b_&#123;kj&#125;</span><br><span class="line">  else</span><br><span class="line">    mid = ⌊(k + k&#x27;) / 2⌋</span><br><span class="line">    l = spawn P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, k, mid)</span><br><span class="line">    r = P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, mid, k&#x27;)</span><br><span class="line">    sync</span><br><span class="line">    return l + r</span><br><span class="line"></span><br><span class="line">P-MATRIX-MULTIPLY&#x27;(A, B, C, n)</span><br><span class="line">  parallel for i = 1 to n</span><br><span class="line">    parallel for j = 1 to n</span><br><span class="line">      C_&#123;ij&#125; = P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, 1, n)</span><br></pre></td></tr></table></figure><p>可以知道其工作量为<span class="math inline">\(T_1(n)=\Theta(n^3)\)</span>。</p><p>对程序<code>P-MATRIX-MULTIPLY-AUX'</code>的分析和对题目26.1-7中对<code>P-MAT-VEC-RECURSIVE-AUX'</code>的分析完全一致。因此，假设<span class="math inline">\(iter_n(i,j)\)</span>表示外层循环为<span class="math inline">\(i\)</span>，内层循环为<span class="math inline">\(j\)</span>时的运行时间，那么有<span class="math inline">\(iter_n(i,j)=O(\lg n)\)</span>。</p><p>由于<code>P-MATRIX-MULTIPLY'</code>首先沿着<code>parallel for</code>循环<span class="math inline">\(i\)</span>的递归树的路径向下，然后沿着内层循环<code>parallel for</code>循环<span class="math inline">\(j\)</span>的递归树的路径向下，因此这个算法的持续时间为<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)+\Theta(\lgn)+\max\{iter_n(i,j):1\le i,j\le n\}=\Theta(\lg n)\)</span>。</p><p>因此并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^3/\lgn)\)</span>。</p><h1 id="section-3">26.2-4</h1><p>考虑对题目26.2-3的代码<code>P-MATRIX-MULTIPLY'</code>进行修改，最终由<code>P-MATRIX-MULTIPLY''</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">P-MATRIX-MULTIPLY-AUX&#x27;&#x27;(A, B, i, j, k, k&#x27;)</span><br><span class="line">  if k == k&#x27;</span><br><span class="line">    return a_&#123;ik&#125; * b_&#123;kj&#125;</span><br><span class="line">  else</span><br><span class="line">    mid = ⌊(k + k&#x27;) / 2⌋</span><br><span class="line">    l = spawn P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, k, mid)</span><br><span class="line">    r = P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, mid, k&#x27;)</span><br><span class="line">    sync</span><br><span class="line">    return l + r</span><br><span class="line"></span><br><span class="line">P-MATRIX-MULTIPLY&#x27;&#x27;(A, B, C, p, q, r)</span><br><span class="line">  parallel for i = 1 to p</span><br><span class="line">    parallel for j = 1 to r</span><br><span class="line">      C_&#123;ij&#125; = P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, 1, q)</span><br></pre></td></tr></table></figure><p>使用和题目26.2-3一样的分析方式，我们可以知道这个算法的工作量为<span class="math inline">\(T_1(n)=\Theta(pqr)\)</span>。</p><p>如果假设<span class="math inline">\(iter_n(i,j)\)</span>表示外层循环为<span class="math inline">\(i\)</span>，内层循环为<span class="math inline">\(j\)</span>时的运行时间，那么有<span class="math inline">\(iter_n(i,j)=O(\lgq)\)</span>。那么这个算法的持续时间为<span class="math inline">\(T_{\infty}(n)=\Theta(\lg p)+\Theta(\lgr)+\max\{iter_n(i,j):1\le i\le p,1\le j\le r\}=\Theta(\lg(pqr))\)</span>。</p><p>因此并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(pqr/\lg(pqr))\)</span>。</p><h1 id="section-4">26.2-5</h1><p>修改后的可并行化的Floyd-Warshall算法由<code>P-FLOYD-WARSHALL'</code>给出（使用题目23.2-4的Floyd-Warshall算法伪代码<code>FLOYD-WARSHALL'</code>进行修改）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">P-FLOYD-WARSHALL&#x27;(W, n)</span><br><span class="line">  D = W</span><br><span class="line">  for k = 1 to n</span><br><span class="line">    parallel for i = 1 to n</span><br><span class="line">      parallel for j = 1 to n</span><br><span class="line">        d_&#123;ij&#125; = min &#123;d_&#123;ij&#125;, d_&#123;ik&#125; + d_&#123;kj&#125; &#125;</span><br><span class="line">6 return D</span><br></pre></td></tr></table></figure><p>首先说明一下这样修改的正确性。可见，在第<span class="math inline">\(k\)</span>轮循环中，<code>P-FLOYD-WARSHALL'</code>的第5行只会使用<span class="math inline">\(D\)</span>的第<span class="math inline">\(k\)</span>行和第<span class="math inline">\(k\)</span>列中的元素进行读取，并对其它元素进行修改。由于原来的图是一个非负边权的图，因此哪怕对<span class="math inline">\(d_{ik},d_{kj}\)</span>这样的元素进行更新，也不会对原本的值进行改变。因此。这个算法通过如此并行化完成是正确的。</p><p>这个程序的串行投影需要花费<span class="math inline">\(\Theta(n^3)\)</span>的时间完成，因此其工作量为<span class="math inline">\(T_1(n)=\Theta(n^3)\)</span>。</p><p>接下来求解持续时间<span class="math inline">\(T_{\infty}(n)\)</span>。假设<span class="math inline">\(iter_n(i,j)\)</span>表示外层<code>parallel for</code>循环为<span class="math inline">\(i\)</span>，内层<code>parallel for</code>循环为<span class="math inline">\(j\)</span>时的运行时间，那么有<span class="math inline">\(iter_n(i,j)=O(1)\)</span>，因为接下来只有一个较小值更新操作和加法操作。将两层循环中的<code>parallel</code>关键字转化为<code>spawn ... sync</code>结构后，那么可以得知<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)+\Theta(\lgn)+\max\{iter_n(i,j):1\le i,j\le n\}=\Theta(\lgn)\)</span>。由于这个两层<code>parallel for</code>循环需要串行地执行<span class="math inline">\(k\)</span>次，因此我们可以求出<span class="math inline">\(T_{\infty}(n)=n\cdot \Theta(\lg n)=\Theta(n\lgn)\)</span>。</p><p>最终并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^3/(n\lgn))=\Theta(n^2/\lg n)\)</span>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论26.1 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/26-1-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/26-1-Exercises/</id>
    <published>2023-10-01T11:27:56.000Z</published>
    <updated>2023-10-01T11:27:56.423Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">26.1-1</h1><p>一个串行算法的运行轨迹是看起来是一个单链表。相比于图26.2和图26.4所展示的运行轨迹，每个节点最多只有一条入边和一条出边。</p><h1 id="section-1">26.1-2</h1><p>相比于原来，现在<code>P-FIB</code>变成了<code>P-FIB'</code>，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">P-FIB&#x27;(n)</span><br><span class="line">  if n &lt;= 1</span><br><span class="line">    return n</span><br><span class="line">  else </span><br><span class="line">    x = spawn P-FIB&#x27;(n − 1)</span><br><span class="line">    y = spawn P-FIB&#x27;(n − 2)</span><br><span class="line">    sync</span><br><span class="line">    return x + y</span><br></pre></td></tr></table></figure><p>与原来的区别在于，父线程一进入<code>else</code>就被挂起，并且产生了两个子线程来求解<code>P-FIB'(n − 1)</code>和<code>P-FIB'(n − 2)</code>，父线程会一直等待，直到这两个线程完成执行，最终才返回计算结果。</p><p>因此，除了增加了一些线程本身的空间占用，这种做法并不会产生任何的改进，因此其渐进工作量<span class="math inline">\(T_1&#39;\)</span>仍然为<span class="math inline">\(\Theta(\phi^n)\)</span>，其持续时间仍然是<span class="math inline">\(T_{\infty}&#39;=\Theta(n)\)</span>，并行度为<span class="math inline">\(T_1&#39;/T_{\infty}&#39;=\Theta(\phi^n/n)\)</span>。</p><h1 id="section-2">26.1-3</h1><p>如下图所示，为<code>P-FIB(5)</code>的计算有向无环图。可见，图中有<span class="math inline">\(29\)</span>个节点，因此其工作量为<span class="math inline">\(29\)</span>。此外，粗线表示这个有向无环图的最长链，其一共有<span class="math inline">\(10\)</span>个节点，因此其持续时间为<span class="math inline">\(10\)</span>，最终我们得到并行度为<span class="math inline">\(2.9\)</span>。</p><p><img data-src="26.1-3.png"></p><h1 id="section-3">26.1-4</h1><p>假设这些时间步中，一共有<span class="math inline">\(x\)</span>个非完全步，一共有<span class="math inline">\(y\)</span>个完全步。那么必定有<span class="math inline">\(y\le\lfloor(T_1 -x)/P\rfloor\)</span>。我们通过反证法来证明这个不等式是成立的。</p><p>由于每个非完全步至少有<span class="math inline">\(1\)</span>的工作量，因此至多只有<span class="math inline">\(T_1-x\)</span>的工作量在完全步完成，也就是说，有<span class="math inline">\(Py\le T_1-x\)</span>。假设<span class="math inline">\(y&gt;\lfloor(T_1 -x)/P\rfloor\)</span>，那么有</p><p><span class="math inline">\(\begin{aligned} Py&amp;\geP\cdot(\lfloor(T_1 - x)/P\rfloor+1)\\ &amp;=P\cdot\lfloor(T_1 -x)/P\rfloor+P\\ &amp;=P\cdot\left(\dfrac{T_1-x}{P}-((T_1-x)\bmodP)\right) + P\\ &amp;=T_1-x+P-((T_1-x)\bmod P)\\ &amp;&gt;T_1-x\end{aligned}\)</span></p><p>这和<span class="math inline">\(Py\le T_1-x\)</span>矛盾，因此有<span class="math inline">\(y\le\lfloor(T_1 - x)/P\rfloor\)</span>。</p><p>那么有<span class="math inline">\(T_p=x+y\le x+\lfloor(T_1 -x)/P\rfloor\)</span>。由于<span class="math inline">\(x\leT_\infty\)</span>，即<span class="math inline">\(x\)</span>是所有时间步的一个子集，因此有</p><p><span class="math inline">\(\begin{aligned} T_p&amp;\le x+\lfloor(T_1- x)/P\rfloor\\ &amp;\le x+(T_1 - x)/P\\ &amp;\le T_\infty+(T_1 -T_\infty)/P\\ \end{aligned}\)</span></p><p>原结论成立。</p><h1 id="section-4">26.1-5</h1><p><img data-src="26.1-5.png"></p><p>假设现在有<span class="math inline">\(k\)</span>个处理器，<span class="math inline">\(k+1\)</span>个任务，其中每个串行任务内部一共有<span class="math inline">\(m\)</span>个节点。那么左图是贪心调度器的一种调度，接下来的<span class="math inline">\(m\)</span>个时间步它先完成<span class="math inline">\(k\)</span>个任务的串行节点，然后再花费<span class="math inline">\(m\)</span>个时间步进行剩下的那一个任务，在这种调度下，花费了<span class="math inline">\(2m+2\)</span>个时间步完成整个程序的运行（注意，这里加上了开始和结束的时间步）。如左图所示。</p><p>另一种调度则是，每次优先选择剩余时间最长的<span class="math inline">\(k\)</span>个任务运行一个时间步，直到完成所有任务为止。因此，这个过程总共需要<span class="math inline">\(\left\lceil\dfrac{(k+1)m}{k}\right\rceil+2=\left\lceilm+\dfrac{m}{k}\right\rceil+2\)</span>个时间步进行。如右图所示。</p><p>因此，有<span class="math inline">\(\displaystyle{\lim_{k\rightarrow+\infty}(2m+2)/\left(\left\lceilm+\dfrac{m}{k}\right\rceil+2\right)=2}\)</span>，这时第一种调度所花费的时间步是第二种调度的接近<span class="math inline">\(2\)</span>倍。</p><h1 id="section-5">26.1-6</h1><p>根据工作量定律，有<span class="math inline">\(T_1\le \min\{4\cdotT_4,10\cdot T_{10},64\cdot T_{64}\}\)</span>，从而得到<span class="math inline">\(T_1\le 320\)</span>。</p><p>根据持续时间定理，有<span class="math inline">\(T_\infty\le\min\{T_4,T_{10},T_{64}\}\)</span>，从而得到<span class="math inline">\(T_\infty\le 10\)</span>。</p><p>对<span class="math inline">\(T_{10}\)</span>对应的情况应用不等式26.5，那么有</p><p><span class="math inline">\(\begin{aligned} T_{10}&amp;\le\dfrac{T_1-T_\infty}{10}+T_\infty\\ &amp;\le \dfrac{T_1+9T_\infty}{10}\\&amp;\le 32+\dfrac{9T_\infty}{10} \end{aligned}\)</span></p><p>从而得到<span class="math inline">\(T_\infty&gt;\dfrac{100}{9}\)</span>，这和给出的<span class="math inline">\(T_{\infty}\le10\)</span>是矛盾的，因此这个教授是在撒谎。</p><h1 id="section-6">26.1-7</h1><p>可以将提供的<code>P-MAT-VEC-RECURSIVE</code>进行改造后，得到如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">P-MAT-VEC-RECURSIVE-AUX&#x27;(A, x, n, i, j, j&#x27;)</span><br><span class="line">  if j == j&#x27;</span><br><span class="line">    return a_&#123;i, j&#125; * x_j</span><br><span class="line">  else</span><br><span class="line">    mid = ⌊(j + j&#x27;) / 2⌋</span><br><span class="line">    l = spawn P-MAT-VEC-RECURSIVE-AUX&#x27;(A, x, n, i, j, mid)</span><br><span class="line">    r = P-MAT-VEC-RECURSIVE-AUX&#x27;(A, x, n, i, mid + 1, j&#x27;)</span><br><span class="line">    sync</span><br><span class="line">    return l + r</span><br><span class="line"></span><br><span class="line">P-MAT-VEC-RECURSIVE&#x27;(A, x, y, n)</span><br><span class="line">  parallel for i = 1 to n</span><br><span class="line">    y_i = P-MAT-VEC-RECURSIVE-AUX&#x27;(A, x, n, i, 1, n)</span><br></pre></td></tr></table></figure><p>其基本思想在于，对于<span class="math inline">\(A\)</span>的每一行都和<span class="math inline">\(x\)</span>独立相乘，得到一个值。然后，先计算这一行左半部分和<span class="math inline">\(x\)</span>的左半部分点积；右半部分和<span class="math inline">\(x\)</span>的左半部分点并行进行计算，最终将结果合并。</p><p>因此，<code>P-MAT-VEC-RECURSIVE'</code>的工作量为<span class="math inline">\(T_1(n)=\Theta(n^2)\)</span>，因为它仍然运行了<span class="math inline">\(n^2\)</span>次乘法运算。</p><p><code>P-MAT-VEC-RECURSIVE'</code>的持续时间<span class="math inline">\(T_{\infty}(n)\)</span>如下计算。由于<code>P-MAT-VEC-RECURSIVE'</code>中的每次循环都是独立的，因此令<span class="math inline">\(iter_{\infty}(n,i)\)</span>表示第<span class="math inline">\(i\)</span>次的循环结果，我们可以得到：</p><p><span class="math display">\[T_{\infty}(n)=\Theta(\lgn)+\max\{iter_{\infty}(n,i):1\le i\le n\}\]</span></p><p>对于每一次<code>P-MAT-VEC-RECURSIVE-AUX'</code>的调用，我们可以发现，每一次调用都将求和的范围减小，因此有<span class="math inline">\(iter_{\infty}(n,i)=iter_{\infty}(n/2,i)+\Theta(1)\)</span>。根据主定理，可以得到：</p><p><span class="math display">\[iter_{\infty}(n,i)=\Theta(\lgn)+\Theta(\lg n)\]</span></p><p>因此，我们最终得到<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)+\Theta(\lgn)=\Theta(\lg n)\)</span>。</p><p>最终我们得到这个算法的并行度为<span class="math inline">\(T_1(n)/T_\infty(n)=\Theta(n^2/\lgn)\)</span>。</p><h1 id="section-7">26.1-8</h1><p>可见，这个程序的串行投影需要花费<span class="math inline">\(\Theta(n^2)\)</span>的时间完成，因此其工作量为<span class="math inline">\(T_1(n)=\Theta(n^2)\)</span>。</p><p>接下来求解持续时间<span class="math inline">\(T_{\infty}(n)\)</span>。令<span class="math inline">\(iter_1(j)(2\le j\len)\)</span>表示其外层循环所需要的时间，<span class="math inline">\(iter_2(i)(1\le j&lt;n)\)</span>表示其内层循环所需要的时间。</p><p>如果将内层<code>for</code>循环的<code>parallel</code>关键字转化为<code>spawn ... sync</code>结构后，那么可以得知<span class="math inline">\(iter_1(i)=\Theta(\lg i)+\max\{iter_2(j):1\lej&lt;i\}\)</span>。可以知道，由于<span class="math inline">\(iter_2(j)=\Theta(1)\)</span>，因此有<span class="math inline">\(iter_1(i)=\Theta(\lg i)+\Theta(1)=\Theta(\lgi)\)</span>。</p><p>再将外层<code>for</code>循环的<code>parallel</code>关键字转化为<code>spawn ... sync</code>结构后，那么可以得知<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)+\max\{iter_1(i):2\lej\le n\}=\Theta(\lg n)+\Theta(\lg n)\)</span>。从而得到<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)\)</span>。</p><p>因此并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^2/\lgn)\)</span>。</p><h1 id="section-8">26.1-9</h1><p>也就是说，现在的程序转化为<code>P-TRANSPOSE'</code>，即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P-TRANSPOSE(A, n)</span><br><span class="line">  parallel for j = 2 to n</span><br><span class="line">    for i = 1 to j − 1</span><br><span class="line">      exchange a_&#123;ij&#125; with a_&#123;ji&#125;</span><br></pre></td></tr></table></figure><p>工作量和题目28.1-8的情况一样，为<span class="math inline">\(T_1(n)=\Theta(n^2)\)</span>。</p><p>接下来求解持续时间<span class="math inline">\(T_{\infty}(n)\)</span>。令<span class="math inline">\(iter(j)(2\le j\len)\)</span>表示其外层循环所需要的时间，由内层循环可以知道，<span class="math inline">\(iter(j)=\Theta(j)\)</span>。将外层<code>for</code>循环的<code>parallel</code>关键字转化为<code>spawn ... sync</code>结构后，那么可以得知<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)+\max\{iter(i):2\lej\le n\}=\Theta(\lg n)+\Theta(n)\)</span>。因此，我们最终得到<span class="math inline">\(T_{\infty}(n)=\Theta(\lgn)+\Theta(n)=\Theta(n)\)</span>。</p><p>因此并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^2/n)=\Theta(n)\)</span>。</p><h1 id="section-9">26.1-10</h1><p>相当于解如下关于未知数<span class="math inline">\(P,T_P,T_P&#39;\)</span>的方程组：</p><p><span class="math display">\[\left \{\begin{aligned}  &amp;T_P=\dfrac{T_1}{P}+T_\infty\\  &amp;T_P&#39;=\dfrac{T_1&#39;}{P}+T_\infty&#39;\\  &amp;T_P=T_P&#39;\\\end{aligned}\right.\]</span></p><p>其中<span class="math inline">\(T_1=2048,T_{\infty}=1,T_1&#39;=1024,T_{\infty}&#39;=8\)</span>，最终得到解：</p><p><span class="math display">\[\left \{\begin{aligned}  &amp;P=\dfrac{1024}{7}\\  &amp;T_P=15\\  &amp;T_P&#39;=15\\\end{aligned}\right.\]</span></p><p>也就是说，只需要约<span class="math inline">\(146\)</span>或者<span class="math inline">\(147\)</span>个处理器就能使这两个版本的算法运行时间相同。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>滴滴 秋招 2023.09.28 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Didi-20230928/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Didi-20230928/</id>
    <published>2023-09-29T09:06:03.000Z</published>
    <updated>2023-09-29T09:06:03.565Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="圆木加工">1、圆木加工</h1><p>一家木材厂需要加工三根圆木。这三根圆木长度分别为<span class="math inline">\(a,b,c\)</span>，一共需要进行不超过<span class="math inline">\(n\)</span>次加工程序。第<span class="math inline">\(i\)</span>道加工程序需要选择其中一根长度严格大于<span class="math inline">\(i\)</span>的圆木，将其切割，使其长度减少<span class="math inline">\(i\)</span>。被切下的部分不再进入后续的加工流程。如果这三根圆木的长度能够组成一个面积大于<span class="math inline">\(0\)</span>的三角形，那么就称此时的圆木长度三元组<span class="math inline">\((a&#39;,b&#39;,c&#39;)\)</span>是好的。</p><p>现在的问题是：一共可能形成多少种好的三元组？</p><h2 id="输入">输入</h2><p>输入仅一行四个正整数<span class="math inline">\(n,a,b,c\)</span>。</p><p>对于<span class="math inline">\(100\%\)</span>的数据，<span class="math inline">\(1\le n,a,b,c \le 100\)</span>。</p><h2 id="输出">输出</h2><p>输出一行，一个整数，表示好的三元组的个数。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5 3 4 5</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">有如下10种三元组</span><br><span class="line">(1,4,4),(2,2,2),(2,4,3),(2,4,5),(3,2,4),(3,3,3),(3,3,5),(3,4,2),(3,4,4),(3,4,5)</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>对于三种原木<span class="math inline">\((a,b,c)\)</span>是否能拼接成一个三角形，只需要判断<span class="math inline">\(a+b&gt;c,a+c&gt;b,b+c&gt;a\)</span>是否都成立即可。</p><p>由于第<span class="math inline">\(i\)</span>次加工程序切除原木的长度只依赖于<span class="math inline">\(i\)</span>本身，因此，如果从原木<span class="math inline">\((a,b,c)\)</span>经过若干道加工程序变成<span class="math inline">\((a&#39;,b&#39;,c&#39;)\)</span>后，其使用的加工轮数必定是确定的。也就是说，只要从<span class="math inline">\((a,b,c)\)</span>变成<span class="math inline">\((a&#39;,b&#39;,c&#39;)\)</span>，那么必定进行了<span class="math inline">\(k\)</span>轮，并且<span class="math inline">\(k\)</span>是一个常数，不依赖于现有的决策。</p><p>因此，我们使用带有记忆化的深度优先搜索即可完成本题。如果发现当前状态<span class="math inline">\((a,b,c)\)</span>被遍历过，那么就直接返回，否则进一步向下进行枚举即可。这保证了每个不同的三元组<span class="math inline">\((a,b,c)\)</span>都只被遍历一次。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">104</span>;</span><br><span class="line"><span class="type">int</span> n,a,b,c;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> vis[N][N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[a][b][c]) <span class="keyword">return</span>;</span><br><span class="line">    vis[a][b][c]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a+b&gt;c&amp;&amp;a+c&gt;b&amp;&amp;b+c&gt;a) ++ans;</span><br><span class="line">    <span class="keyword">if</span>(k==n+<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;k) <span class="built_in">dfs</span>(k+<span class="number">1</span>,a-k,b,c);</span><br><span class="line">    <span class="keyword">if</span>(b&gt;k) <span class="built_in">dfs</span>(k+<span class="number">1</span>,a,b-k,c);</span><br><span class="line">    <span class="keyword">if</span>(c&gt;k) <span class="built_in">dfs</span>(k+<span class="number">1</span>,a,b,c-k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>,&amp;n,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,a,b,c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="平衡树">2、平衡树</h1><p>小明正在玩一棵树，它正在研究树的平衡性，它为了辅助研究，为树定义了一个函数<span class="math inline">\(S(x)\)</span>，表示对树中节点<span class="math inline">\(x\)</span>，其到树中其他所有节点的距离之和，注意树上相邻节点之间距离为<span class="math inline">\(1\)</span>，而且树根为<span class="math inline">\(1\)</span>号节点。现在他想让你帮他进行计算！</p><h2 id="输入-1">输入</h2><p>第一行两个正整数<span class="math inline">\(n,m\)</span>分别表示树上的节点数和询问数。</p><p>接下来一行<span class="math inline">\(n-1个数\)</span>p_2,p_3,p_n<span class="math inline">\(。表示节点\)</span>i<span class="math inline">\(的父亲为\)</span>p_i$。</p><p>接下来一行<span class="math inline">\(m\)</span>个数，<span class="math inline">\(x_1,x_2,\dotsx_m\)</span>，分别表示每次询问所使用的<span class="math inline">\(x\)</span>值。</p><p>对于所有数据，<span class="math inline">\(1\le n,m\le 20000,1\lep_i&lt; n, 1 \le x_i \le n\)</span>。</p><h2 id="输出-1">输出</h2><p>输出一行<span class="math inline">\(m\)</span>个数，单空格隔开，分别表示每次询问的答案。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3 3</span><br><span class="line">1 1</span><br><span class="line">1 2 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2 3 3</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>这道题是原题Leetcode834。其使用的基本思想是换根动态规划，进行两次深度优先搜索即可完成，其中第二次搜索使用了动态规划的思想。</p><p>其基本思想是，首先我们先以<span class="math inline">\(O(n)\)</span>的时间复杂度求出一个节点的答案值，然后再将其转移到每个节点的答案。</p><p>令<span class="math inline">\(d_i\)</span>表示节点<span class="math inline">\(i\)</span>的深度，<span class="math inline">\(s_i\)</span>表示以节点<span class="math inline">\(i\)</span>为根的子树中的节点数个数，<span class="math inline">\(f_i\)</span>表示<span class="math inline">\(i\)</span>到其它节点的所有距离之和。</p><p>通过第一次深度优先搜索，我们可以求出数组<span class="math inline">\(d,s\)</span>。并且，我们能够利用好数组<span class="math inline">\(d\)</span>给出第一个转移：</p><ul><li><span class="math inline">\(\displaystyle{\sum_{i=1}^nd_i\rightarrow f_1}\)</span></li></ul><p>以上根据定义是显而易见的。令<span class="math inline">\(\text{son}(u)\)</span>表示<span class="math inline">\(u\)</span>的所有子节点，那么考虑<span class="math inline">\(v\in\text{son}(u)\)</span>，我们可以列出如下转移：</p><ul><li><span class="math inline">\(f_u+(n-s_v)-s_v\rightarrowf_v\)</span></li></ul><p>当我们已经求出了节点<span class="math inline">\(u\)</span>的<span class="math inline">\(f_u\)</span>值后，那么对于<span class="math inline">\(u\)</span>其中的一个子节点，<span class="math inline">\(f_u\)</span>值会发生什么变化呢？对于一个节点<span class="math inline">\(w\)</span>，如果它在<span class="math inline">\(v\)</span>的子树，那么从<span class="math inline">\(u\)</span>走到<span class="math inline">\(w\)</span>的距离减少了<span class="math inline">\(1\)</span>，因此需要减去<span class="math inline">\(s_v\)</span>；如果它不在<span class="math inline">\(v\)</span>的子树，那么从<span class="math inline">\(u\)</span>走到<span class="math inline">\(w\)</span>的距离增加了<span class="math inline">\(1\)</span>，因此可以得出如上转移。这在<span class="math inline">\(O(n)\)</span>的时间内可以完成。</p><p>对于给定的每个询问<span class="math inline">\(x\)</span>，直接输出<span class="math inline">\(f_x\)</span>的值即可。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">20004</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans[N],d[N],sz[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;g[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> dis)</span></span>&#123;</span><br><span class="line">    d[u]=dis;</span><br><span class="line">    sz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:g[u])&#123;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,dis+<span class="number">1</span>);</span><br><span class="line">        sz[u]+=sz[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:g[u])&#123;</span><br><span class="line">        ans[v]=ans[u]-sz[v]+(n-sz[v]);</span><br><span class="line">        <span class="built_in">dfs2</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        g[x].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans[<span class="number">1</span>]+=d[i];</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>,ans[x],<span class="string">&quot; \n&quot;</span>[i==m]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>华为 秋招 2023.09.27 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Huawei-20230927/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Huawei-20230927/</id>
    <published>2023-09-27T16:14:45.000Z</published>
    <updated>2023-09-27T16:14:45.218Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="价格优惠">1、价格优惠</h1><p>某商城进行“双十一”促销活动，活动采用等价格减免的方式，某位客人一次购买了<span class="math inline">\(N\)</span>件商品，需要帮忙计算本次购买能获得的总优惠。给定商品价格数组<span class="math inline">\(p\)</span>，其中<span class="math inline">\(p[i]\)</span>表示第i件商品的价格，第<span class="math inline">\(i\)</span>件商品能获得的优惠为第<span class="math inline">\(i\)</span>件商品之前的第<span class="math inline">\(j\)</span>件商品的价格，其中<span class="math inline">\(p[j]\le p[i]\)</span>，并目<span class="math inline">\(j\le i\)</span>，且<span class="math inline">\(p[j]\)</span>是离<span class="math inline">\(p[i]\)</span>最近的一个小于等于<span class="math inline">\(p[i]\)</span>的商品。求本次购买能获得的总优惠。</p><p>例如：给定价格数组<span class="math inline">\(p=[9,4,3,5],p[3]=5\)</span>能获得的优惠为<span class="math inline">\(p[2]=3,p[2]\)</span>是满足条件离<span class="math inline">\(p[3]\)</span>最近的一个商品，其中<span class="math inline">\(p[1]=4\)</span>也小于<span class="math inline">\(p[3]\)</span>，但不是离<span class="math inline">\(p[3]\)</span>最近的商品。</p><h2 id="输入">输入</h2><p>第一行是商品的个数<span class="math inline">\(N,1\le N\le100000\)</span>。</p><p>第二行是用空格分隔的<span class="math inline">\(N\)</span>个整数，数组元素的值表示商品的价格<span class="math inline">\(0&lt; p[i]\le 100000\)</span>。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">9 4 5 2 4 </span><br></pre></td></tr></table></figure><h2 id="输出">输出</h2><p>输出为一个整数，表示本次购买获得的总优惠。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">9 4 5 2 4</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">商品0的价格为p[0]=9，第一件商品之前无其他商品，该商品获得的优惠为0。</span><br><span class="line">商品1的价格为p[1]=4，p[1]之前不存在满足条件的商品，该商品获得的优惠为0。</span><br><span class="line">商品2的价格为p[2]=5，p[2]之前满足条件的最近的一个商品为p[1]=4，该商品获得的优惠为4。</span><br><span class="line">商品3的价格为p[3]=2，p[3]之前没有满足条件的商品，该商品获得的优惠为0。</span><br><span class="line">商品4的价格为p[4]=4。p[4]之前满足条件的最近的一个商品为p[3]=2，该商品获得的优惠为2。</span><br><span class="line">由此可以计算出本次购买可以获得的总优惠为： 4+2=6。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">4</span><br><span class="line">1 2 3 5</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">商品0的价格为p[0]=1，第一件商品之前无其他商品，该商品获得的优惠为0。</span><br><span class="line">商品1的价格为p[1]=2，p[1]之前满足条件的最近的一个商品为p[0]=1，该商品获得的优惠为1。</span><br><span class="line">商品2的价格为p[2]=3，p[2]之前满足条件的最近的一个商品为p[1]=2，该商品获得的优惠为2。</span><br><span class="line">商品3的价格为p[3]=5，p[3]之前满足条件的最近的一个商品为p[2]=3，该商品获得的优惠为3。</span><br><span class="line">由此可以计算出本次购买可以获得的总优惠为：1+2+3=6。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">4</span><br><span class="line">4 3 2 1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">商品0的价格为p[0]=9，第一件商品之前无其他商品，该商品获得的优惠为0。</span><br><span class="line">商品1的价格为p[1]=4，p[1]之前不存在满足条件的商品，该商品获得的优惠为0。</span><br><span class="line">商品2的价格为p[2]=5，p[2]之前满足条件的最近的一个商品为p[1]=4，该商品获得的优惠为4。</span><br><span class="line">商品3的价格为p[3]=2，p[3]之前没有满足条件的商品，该商品获得的优惠为0。</span><br><span class="line">商品4的价格为p[4]=4。p[4]之前满足条件的最近的一个商品为p[3]=2，该商品获得的优惠为2。</span><br><span class="line">本次购买每件商品都没有满足条件的优惠，本次购买可获得的优惠为0。</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>本题是Leetcode 496的变种。相当于是为每一个数<span class="math inline">\(p[i]\)</span>找到左边第一个不超过它的数，并加上它。</p><p>因此，使用单调栈可以完美解决这个问题，我们通过维护一个非单调递减的栈来记录元素的值，当把栈中所有比当前元素大的元素弹出后，栈顶即为我们所需要求的值，再把当前的数推进栈中。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"><span class="type">int</span> p[N],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;st;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()&amp;&amp;p[i]&lt;st.<span class="built_in">top</span>()) st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(!st.<span class="built_in">empty</span>())</span><br><span class="line">            ans+=st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">push</span>(p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多项式计算">2、多项式计算</h1><p>给定两个一元多项式以及多项式运算符，计算输出两个多项式运算的结果，计算规则见样例。</p><h2 id="输入-1">输入</h2><p>分三行输入，第一行输入多项式<span class="math inline">\(A\)</span>的系数数组（按照阶数高到低顺序），第二行输入多项式<span class="math inline">\(B\)</span>的系数数组，第三行输入多项式运算符。运算符包括加<code>(+)</code>减<code>(-)</code>乘<code>(*)</code>三种，系数数组大小小于<span class="math inline">\(128\)</span>，系数取值范围<span class="math inline">\([-512,512]\)</span>。</p><h2 id="输出-1">输出</h2><p>输出多项式运算结果的系数数组，如果计算后多项式为<span class="math inline">\(0\)</span>，则输出0。从第<span class="math inline">\(1\)</span>个非零的系数开始输出。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[1 2 3 4 5 6]</span><br><span class="line">[2 3 -4]</span><br><span class="line">+</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[1 2 3 6 8 2]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">多项式系数数组[1 2 3 4 5 6]表示多项式A(x)=x^5 + 2x^4+ 3x^3 + 4x^2 + 5x + 6</span><br><span class="line">多项式系数数组[2 3 -4]表示多项式B(x)=2x^2 + 3x - 4</span><br><span class="line">A(x) + B(x) = x^5 + 2x^4 + 3x^3 + 6x^2 + 8x + 2，对应的多项式系数数组为[1 2 3 6 8 2]。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[1 2 3]</span><br><span class="line">[1 2 1]</span><br><span class="line">-</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[2]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">(x^2 + 2x + 3) - (x^2 + 2x + 1) = 2</span><br><span class="line">高阶的0系数不输出。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[1 1]</span><br><span class="line">[1 1]</span><br><span class="line">*</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[1 2 1]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">(x + 1) * (x + 1) = x^2 + 2x + 1</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>本题是一道输入输出处理题和模拟题。建议使用<code>python</code>结合<code>eval</code>函数来完成。接下来为了方便处理按照多项式的形式进行处理，需要将输入的数组<span class="math inline">\(A,B\)</span>进行逆序。</p><p>逆序完成后，我们可以将下标作为指数，按照多项式的定义进行计算。</p><p>需要注意的是，计算完多项式的结果后，按照题目要求需要注意如下事项：</p><ol type="1"><li>去掉高次中的<span class="math inline">\(0\)</span>系数项。</li><li>如果多项式的结果为<span class="math inline">\(0\)</span>，那么还需要避免输出的多项式为空，需要往对应数组添加回一个<span class="math inline">\(0\)</span>。</li><li>对输出的多项式进行逆序。</li></ol><h2 id="代码-1">代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="built_in">list</span>(<span class="built_in">reversed</span>(<span class="built_in">eval</span>(<span class="built_in">input</span>().replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;,&#x27;</span>))))</span><br><span class="line">B = <span class="built_in">list</span>(<span class="built_in">reversed</span>(<span class="built_in">eval</span>(<span class="built_in">input</span>().replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;,&#x27;</span>))))</span><br><span class="line">op = <span class="built_in">input</span>()</span><br><span class="line">n = <span class="built_in">max</span>(<span class="built_in">len</span>(A), <span class="built_in">len</span>(B))</span><br><span class="line">A += [<span class="number">0</span>] * (n - <span class="built_in">len</span>(A))</span><br><span class="line">B += [<span class="number">0</span>] * (n - <span class="built_in">len</span>(B))</span><br><span class="line"><span class="keyword">if</span> op == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">    C = [A[i] + B[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="keyword">elif</span> op == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">    C = [A[i] - B[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    C = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            C[i + j] += A[i] * A[j]</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(C) &gt; <span class="number">0</span> <span class="keyword">and</span> C[-<span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">    C.pop()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(C) == <span class="number">0</span>:</span><br><span class="line">    C = [<span class="number">0</span>]</span><br><span class="line">C.reverse()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(C).replace(<span class="string">&#x27;, &#x27;</span>, <span class="string">&#x27; &#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="货物运输">3、货物运输</h1><p>有<span class="math inline">\(m\)</span>件货物和<span class="math inline">\(n\)</span>辆卡车，每辆卡车只能运送<strong>一件</strong>货物，卡车的载重量需要<strong>大于等于</strong>货物重量才能运输；</p><p>另有<span class="math inline">\(x\)</span>个载重为<span class="math inline">\(y\)</span>的拖斗，每辆卡车<strong>最多</strong>可以拖挂一个拖斗以提升载重量，共同运输一件更重的货物；</p><p>请你返回<strong>最多</strong>可以运输多少件货物。</p><h2 id="输入-2">输入</h2><p>三行数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m n x y</span><br><span class="line">weight0 weight1 weight2...</span><br><span class="line">load0 load1 load2...</span><br></pre></td></tr></table></figure><p>第<span class="math inline">\(1\)</span>行包含四个数字，分别为：</p><ul><li><span class="math inline">\(m\)</span>：货物数量</li><li><span class="math inline">\(n\)</span>：卡车数量</li><li><span class="math inline">\(x\)</span>：拖斗数量</li><li><span class="math inline">\(y\)</span>：拖斗载重</li></ul><p>第<span class="math inline">\(2\)</span>行为货物的重量列表，以空格分隔；</p><p>第<span class="math inline">\(3\)</span>行为卡车的载重列表，以空格分隔；</p><p>范围：</p><ul><li><span class="math inline">\(1\le\)</span> 货物/卡车<span class="math inline">\(\le 50000\)</span></li><li><span class="math inline">\(0\le\)</span> 拖斗数量<span class="math inline">\(\le 50000\)</span></li><li><span class="math inline">\(0\le\)</span>货物重量/卡车载重量/拖斗载重量<span class="math inline">\(\le1000000000\)</span></li></ul><h2 id="输出-2">输出</h2><p>一个整数，最多可以运输货物的数量。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5 5 1 5</span><br><span class="line">5 5 8 9 9</span><br><span class="line">1 2 4 6 6</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">2号卡车运输1号货物，6&gt;=5</span><br><span class="line">4号卡车运输5号货物，6&gt;=5</span><br><span class="line">5号卡车挂拖斗，运输3号货物，4+5&gt;=8</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">4 4 2 3</span><br><span class="line">9 6 7 8</span><br><span class="line">5 2 3 4</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1号卡车挂拖斗，运输4号货物，5+3&gt;=8</span><br><span class="line">4号卡车挂拖斗，运输3号货物，4+3&gt;=7</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>这道题是Leetcode 2071的原题。按照贪心的思想，如果我们可以完成<span class="math inline">\(k\)</span>个货物的运输，那么用载重最重的<span class="math inline">\(k\)</span>辆卡车运送<span class="math inline">\(k\)</span>个最轻的货物必定是一个解（包括使用拖斗），并且这个解是最极端的情况。</p><p>如果能够运送<span class="math inline">\(k\)</span>件货物，那么就存在一个运送<span class="math inline">\(k-1\)</span>个货物的方案，因此这道题我们可以使用二分进行求解。</p><p>现在需要判断<span class="math inline">\(k\)</span>件货物是否能够被运送。我们将使用载重最大的<span class="math inline">\(k\)</span>辆卡车运送最轻的<span class="math inline">\(k\)</span>个货物。我们从小到大遍历每个货物，每个货物用一个载重比它大，且最载重最小的卡车运行，这才符合我们贪心地思想。如果当前卡车并不能运送当前货物，那么在此之后它也不能够运送其它货物，他这时需要一个拖斗才能够运送，我们需要为这辆卡车添加一个拖斗，并且延后它的使用时期。如果这辆卡车装了拖斗依旧不能运送这个货物，那么说明这个<span class="math inline">\(k\)</span>不可行。最终，我们只需要判断拖斗的使用数量是否不超过<span class="math inline">\(x\)</span>即可。</p><p>此外还需要注意的是，如果一个卡车已经装载了拖斗后，和另一个没装拖斗的卡车载重相等，那么优先使用前一个卡车，因为后一个仍然有提升载重的潜力。</p><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> pi pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[N],l[N],n,m,x,y;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ok</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;pi,vector&lt;pi&gt;,greater&lt;pi&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">pi</span>(l[n-k+i],<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;)&#123;</span><br><span class="line">        <span class="keyword">auto</span> [ld,tp]=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(ld&gt;=w[i])&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tp==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">pi</span>(ld+y,<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt&lt;=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>,&amp;m,&amp;n,&amp;x,&amp;y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;l[i]);</span><br><span class="line">    <span class="built_in">sort</span>(w+<span class="number">1</span>,w+m+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(l+<span class="number">1</span>,l+n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">ok</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="built_in">min</span>(m,n);</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">ok</span>(mid)) l=mid;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>阿里控股 秋招 2023.09.23 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Alikonggu-20230923/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Alikonggu-20230923/</id>
    <published>2023-09-27T16:14:41.000Z</published>
    <updated>2023-09-28T07:26:16.300Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="小红的三元组">1、小红的三元组</h1><p>小红有一个长度为<span class="math inline">\(n\)</span>的数组<span class="math inline">\(a\)</span>，她每次操作可以删掉一个三元组<span class="math inline">\((x,y,z)\)</span>，要求<span class="math inline">\(x&lt;y&lt;z\)</span>，<span class="math inline">\(y\)</span>是<span class="math inline">\(x\)</span>的倍数，<span class="math inline">\(z\)</span>是<span class="math inline">\(y\)</span>的倍数。小红想知道最多可以执行多少次操作。</p><h2 id="输入">输入</h2><p>第一行一个整数<span class="math inline">\(n\)</span>，表示数组的长度。</p><p>第二行<span class="math inline">\(n\)</span>个整数<span class="math inline">\(a_1,a_2,\dots,a_n\)</span>，表示数组的元素。</p><ul><li><span class="math inline">\(1\le n\le 10^5\)</span></li><li><span class="math inline">\(1\le a_i\le 6\)</span></li></ul><h2 id="输出">输出</h2><p>输出一个整数，表示最多可以执行的操作次数。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">7</span><br><span class="line">1 1 2 3 4 5 6</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">先删除(1,2,4)，再删除(1,3,6)。</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>可见，满足题意的三元组只有可能是如下三种情况：<span class="math inline">\((1,2,4),(1,2,6),(1,3,6)\)</span>。</p><p>由于<span class="math inline">\(3,4\)</span>都在这些组合都出现了一次，因此我们优先取走<span class="math inline">\((1,2,4),(1,3,6)\)</span>这些组合，再取走<span class="math inline">\((1,2,6)\)</span>这种组合。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">14</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;v&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        ++a[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> u:v)&#123;</span><br><span class="line">        <span class="type">int</span> t=<span class="built_in">min</span>(a[u[<span class="number">0</span>]],<span class="built_in">min</span>(a[u[<span class="number">1</span>]],a[u[<span class="number">2</span>]]));</span><br><span class="line">        ans+=t;</span><br><span class="line">        a[u[<span class="number">0</span>]]-=t;</span><br><span class="line">        a[u[<span class="number">1</span>]]-=t;</span><br><span class="line">        a[u[<span class="number">2</span>]]-=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小红的连续字符串">2、小红的连续字符串</h1><p>小红有一个字符串<span class="math inline">\(s\)</span>，只包含小写字母。如果一个字符串中，不包含连续的三个相同的字母，并且不存在两个相同的字母紧挨着两个相同的字母，那么这个字符串就是合法的。例如，字符串<code>"aaa"</code>是不合法的，字符串<code>"aabb"</code>也是不合法的。字符串<code>"aab"</code>是合法的。</p><p>小红想知道，最少需要删除多少个字符，才能使得字符串变成合法的。</p><h2 id="输入-1">输入</h2><p>第一行一个字符串<span class="math inline">\(s\)</span>，长度不超过<span class="math inline">\(10^5\)</span>，只包含小写字母。</p><h2 id="输出-1">输出</h2><p>输出一个整数，表示最少需要删除的字符个数。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">aabbaa</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">删除一个字符b，得到aabaa，是一个合法的字符串。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">aaabbb</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">删除三个字符，得到aab，是一个合法的字符串。</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>由于不允许连续三个字母挨在一起，因此我们首先将连续多于两个字母的都删剩两个，然后再考虑下一步。</p><p>接下来每一块相同的字母不超过<span class="math inline">\(2\)</span>个。我们接下来从前往后遍历每个连续块。如果当前连续块的字母个数为<span class="math inline">\(2\)</span>，并且前一个连续块字母个数也为<span class="math inline">\(2\)</span>，那么删除当前块的一个字母（因为删除前面的并不会使结果变得更优）。</p><p>因此，只需要统计两个过程删去的字符数即可。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"><span class="type">int</span> a[N],m=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>,pre=s[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==pre) ++cnt;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            a[++m]=cnt;</span><br><span class="line">            cnt=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        a[i]=<span class="built_in">min</span>(a[i],<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">2</span>&amp;&amp;a[i]==<span class="number">2</span>&amp;&amp;a[i<span class="number">-1</span>]==<span class="number">2</span>)&#123;</span><br><span class="line">            --a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        s+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n-s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="有根树无重复数的路径">3、有根树无重复数的路径</h1><p>小红拿到了一个有根树，根节点为<span class="math inline">\(1\)</span>号节点，每个节点到其每个孩子有一条有向边。小红想取一条路径，满足路径上所有节点的权值都不相等。小红想知道，自己有多少种选择方案？</p><h2 id="输入-2">输入</h2><p>第一行输入一个正整数<span class="math inline">\(n\)</span>，代表节点的数量。</p><p>第二行输入<span class="math inline">\(n-1\)</span>个正整数<span class="math inline">\(a_i\)</span>，代表<span class="math inline">\(2\)</span>号节点到<span class="math inline">\(n\)</span>号节点每个节点的父亲编号。</p><p>第三行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(v_i\)</span>，代表<span class="math inline">\(1\)</span>号节点到<span class="math inline">\(n\)</span>号节点每个节点的权值。</p><ul><li><span class="math inline">\(2\le n\le 2\times 10^5\)</span></li><li><span class="math inline">\(1\le a_i&lt; i\le2\times10^5\)</span></li><li><span class="math inline">\(1\le v_i\le 10^9\)</span></li></ul><h2 id="输出-2">输出</h2><p>小山选择路径的方案数。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">1 1 1 2</span><br><span class="line">1 1 2 2 2</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">路径上有一个节点，有5种取法。</span><br><span class="line">路径上有两个节点的取法有： 1-3、1-4、2-5</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">1 1</span><br><span class="line">1 2 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">路径上有一个节点，有3种取法。</span><br><span class="line">路径上有两个节点的取法有： 1-2、1-3</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>假设我们现在处在节点<span class="math inline">\(u\)</span>，现在一直向父亲节点移动。在移动的过程中，一旦发现一个节点<span class="math inline">\(u&#39;\)</span>的权值出现过，那么说明再往上的路径都是不符合要求的。也就是说，如果<span class="math inline">\(w\)</span>是<span class="math inline">\(u&#39;\)</span>的子节点，又是<span class="math inline">\(u\)</span>的祖先，那么从<span class="math inline">\(w\)</span>到<span class="math inline">\(u\)</span>的路径中，以<span class="math inline">\(u\)</span>为终点的路径都是符合要求的，我们直接统计即可。</p><p>在实现过程中，我们并不能够直接寻找<span class="math inline">\(w\)</span>，因为这将导致<span class="math inline">\(O(n^2)\)</span>的时间复杂度。我们使用的做法是，假设现在遍历到了一个<span class="math inline">\(u\)</span>节点，并且已经知道了其父亲节点所对应的<span class="math inline">\(w\)</span>节点的深度为<span class="math inline">\(d\)</span>，那么如果<span class="math inline">\(u\)</span>的权值<span class="math inline">\(v_u\)</span>已经在从根到<span class="math inline">\(u\)</span>的路径上出现过，那么令其最深的深度为<span class="math inline">\(w_u\)</span>（否则，令<span class="math inline">\(w_u=0\)</span>，这里假设根节点的深度为<span class="math inline">\(1\)</span>），那么令<span class="math inline">\(d&#39;=\max\{d,w_u\}\)</span>，假设<span class="math inline">\(u\)</span>节点的深度为<span class="math inline">\(d_u\)</span>，那么就可以直接把<span class="math inline">\(d_u-d&#39;\)</span>统计到答案中。</p><p>由此我们维护好<span class="math inline">\(w_u\)</span>值，最终可以以<span class="math inline">\(O(n)\)</span>的时间完成本题。</p><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200004</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;g[N];</span><br><span class="line"><span class="type">int</span> a[N],n;</span><br><span class="line">map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt;v;</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> np,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!v[a[u]].<span class="built_in">empty</span>())&#123;</span><br><span class="line">        np=<span class="built_in">max</span>(np,v[a[u]].<span class="built_in">back</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    ans+=d-np;</span><br><span class="line">    v[a[u]].<span class="built_in">push_back</span>(d);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:g[u])&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(v,np,d+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v[a[u]].<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        g[x].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>米哈游 秋招 2023.09.24 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Mihayou-20230924/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Mihayou-20230924/</id>
    <published>2023-09-26T06:33:01.000Z</published>
    <updated>2023-09-27T06:55:48.762Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="相加异或">1、相加异或</h1><p>对于一个数组<span class="math inline">\(c\)</span>，定义<span class="math inline">\(f(c)\)</span>为<span class="math inline">\(c\)</span>数组所有元素的总和。</p><p>现在给定两个长度为<span class="math inline">\(n\)</span>的数组<span class="math inline">\(a,b\)</span>，请你恰好删除一个数组<span class="math inline">\(a\)</span>的元素或者一个数组<span class="math inline">\(b\)</span>的元素，使得<span class="math inline">\(f(a)\)</span>异或<span class="math inline">\(f(b)\)</span>最大。</p><h2 id="输入">输入</h2><p>第一行输入一个整数<span class="math inline">\(n\)</span>。</p><p>第二行输入<span class="math inline">\(n\)</span>个整数<span class="math inline">\(a_i\)</span>。</p><p>第三行输入<span class="math inline">\(n\)</span>个整数<span class="math inline">\(b_i\)</span>。</p><p><span class="math inline">\(1\le n,a_i,b_i \le 10^5\)</span></p><h2 id="输出">输出</h2><p>输出最大的异或和。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">3 2 1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">删除a数组的3。</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>令<span class="math inline">\(s_a\)</span>表示原来的数组<span class="math inline">\(a\)</span>中的元素和，<span class="math inline">\(s_b\)</span>表示原来的<span class="math inline">\(b\)</span>数组的元素和。那么对于删除<span class="math inline">\(a\)</span>中的某个元素<span class="math inline">\(a_i\)</span>后，最终<span class="math inline">\(f(a)\oplus f(b)=(s_a-a_i)\opluss_b\)</span>。对于<span class="math inline">\(b\)</span>数组也同理。因此最终答案为</p><p><span class="math display">\[\max_{i=1}^n\{\max\{(s_a-a_i)\opluss_b,(s_b-b_i)\oplus s_a\}\}\]</span></p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> sa=<span class="number">0</span>,sb=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        sa+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">        sb+=b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,(sa-a[i])^sb);</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,(sb-b[i])^sa);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="米小游与魔法少女-奇运">2、米小游与魔法少女-奇运</h1><p>米小游都快保底了还没抽到希儿，好生气哦！只能打会活动再拿点水晶。</p><p>米小游和世界第一可爱的魔法少女TeRiRi正在打BOSS，BOSS的血量为<span class="math inline">\(h\)</span>，当BOSS血量小于等于<span class="math inline">\(0\)</span>时，BOSS死亡。TeRiRi有一套牌，在一轮中，她会按顺序一张一张的将卡牌打出，套牌中有两种卡牌：</p><ol type="1"><li><strong>时来运转</strong>：获得<span class="math inline">\(x\)</span>个<strong>幸运币</strong>。</li><li><strong>幸运一掷</strong>：造成<span class="math inline">\(x\)</span>点伤害，并投掷所有<strong>幸运币</strong>，造成等于所有<strong>幸运币</strong>掷出的点数之和的伤害。</li></ol><p><strong>幸运币</strong>可以等概率的投掷出<span class="math inline">\(1\sim 6\)</span>之间的点数。（所以为什么不叫骰子呢？）</p><p>米小游想知道，TeRiRi的套牌在一轮内击杀BOSS的概率。</p><h2 id="输入-1">输入</h2><p>第一行输入两个整数<span class="math inline">\(n(1\le n\le 100),h(1\leh\le 10^9)\)</span>，分别表示卡牌张数和BOSS血量。</p><p>接下来<span class="math inline">\(n\)</span>行，每行首先输入两个整数<span class="math inline">\(t(1\le t\le2),x(1\le x\le 10)\)</span>，<span class="math inline">\(t\)</span>为<span class="math inline">\(1\)</span>表示卡牌为时来运转，<span class="math inline">\(t\)</span>为<span class="math inline">\(2\)</span>表示卡牌为幸运一掷。</p><h2 id="输出-1">输出</h2><p>输出一个实数表示答案，你的答案与标准答案的误差不超过<span class="math inline">\(10^{-4}\)</span>都被认为是正确答案。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">2 5</span><br><span class="line">1 1</span><br><span class="line">2 1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">0.5</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">幸运币掷出4及以上的概率为0.5，再加上1点固定伤害，即可击杀BOSS。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">3 1145</span><br><span class="line">1 4</span><br><span class="line">1 9</span><br><span class="line">1 9</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">无论如何都无法击杀BOSS。</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>需要注意的是，只有<strong>幸运一掷</strong>被使用出时，前面获得的<strong>幸运币</strong>才会有用处。如果到最后都没有使出过幸运一掷，那么最后得到的<strong>幸运币</strong>也是没有用处的。通过统计，我们最终可以知道有效被投掷的<strong>幸运币</strong>有<span class="math inline">\(a\)</span>个，并且<strong>幸运一掷</strong>造成的固定伤害总共为<span class="math inline">\(b\)</span>。</p><p>由于每个幸运币之间都是独立的，因此我们可以考虑将它们合并进行处理。我们将使用动态规划来解决本问题。令<span class="math inline">\(f(i,j)(0\le i\le a,0\le j\le 6i)\)</span>表示<span class="math inline">\(i\)</span>枚幸运币投掷出总点数<span class="math inline">\(j\)</span>的概率值，那么我们可以写出它的状态转移方程：</p><p><span class="math inline">\(f(i,j)= \left \{\begin{aligned}  &amp;1&amp; &amp; \text{if}\quad i=0\land j=0 \\  &amp;0 &amp; &amp;\text{if}\quad i=0\land j&gt;0\\  &amp;\dfrac{1}{6}\cdot\sum_{k=1}^{\min\{j,6\}} f(i-1,j-k) &amp;&amp; \text{if}\quad i&gt;0 \\ \end{aligned}\right.\)</span></p><p>由于每个骰子都能均等地以<span class="math inline">\(\dfrac{1}{6}\)</span>的概率投掷出从<span class="math inline">\(1\sim 6\)</span>中的一个值，因此从状态<span class="math inline">\(f(i,j)\)</span>能够以均等地概率转移到<span class="math inline">\(f(i+1,j+1),f(i+1,j+2),\dots,f(i+1,j+6)\)</span>。</p><p>由于还收到了<span class="math inline">\(b\)</span>点固定伤害，因此只需要造成至少<span class="math inline">\(h&#39;=\max\{0,h-b\}\)</span>点伤害，就能够击败BOSS，因此最终答案为<span class="math inline">\(\displaystyle{\sum_{j=h&#39;}^{6a}f(a,j)}\)</span>。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1002</span>;</span><br><span class="line"><span class="type">double</span> f[N][N*<span class="number">6</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,h,t,x;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>,tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;t,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">1</span>)&#123;</span><br><span class="line">            tmp+=x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            b+=x;a+=tmp;tmp=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=a;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=<span class="number">6</span>*a;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">6</span>&amp;&amp;k&lt;=j;k++)&#123;</span><br><span class="line">                f[i][j]+=f[i<span class="number">-1</span>][j-k]/<span class="number">6</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    h=<span class="built_in">max</span>(<span class="number">0</span>,h-b);</span><br><span class="line">    <span class="type">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=h;j&lt;=a*<span class="number">6</span>;j++)</span><br><span class="line">        ans+=f[a][j];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10f\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="米小游的极差之和">3、米小游的极差之和</h1><p>米小游拿到了一个数组<span class="math inline">\(a\)</span>，她用这个数组构造一个新数组<span class="math inline">\(b\)</span>，其中<span class="math inline">\(a_i\)</span>代表<span class="math inline">\(b\)</span>数组中有<span class="math inline">\(a_i\)</span>个<span class="math inline">\(i\)</span>。</p><p>例如，若<span class="math inline">\(a=[2,3,1]\)</span>，那么<span class="math inline">\(b=[1,1,2,2,2,3]\)</span>，因为<span class="math inline">\(a_1 = 2\)</span>，代表<span class="math inline">\(b\)</span>数组中有<span class="math inline">\(2\)</span>个<span class="math inline">\(1\)</span>；<span class="math inline">\(a_2=3\)</span>，代表<span class="math inline">\(b\)</span>数组中有<span class="math inline">\(3\)</span>个<span class="math inline">\(2\)</span>；<span class="math inline">\(a_3=1\)</span>，代表<span class="math inline">\(b\)</span>数组中有<span class="math inline">\(1\)</span>个<span class="math inline">\(3\)</span>。</p><p>现在给定<span class="math inline">\(a\)</span>数组，你需要帮米小游求出<span class="math inline">\(b\)</span>数组中所有连续子数组的极差之和。由于答案可能过大，请对<span class="math inline">\(10^9+7\)</span>取模。</p><p>数组的极差指最大值减去最小值。</p><h2 id="输入-2">输入</h2><p>第一行输入一个正整数<span class="math inline">\(n\)</span>，代表<span class="math inline">\(a\)</span>数组的元素数量。</p><p>第二行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(a_i\)</span>，代表<span class="math inline">\(a\)</span>数组的元素。</p><ul><li><span class="math inline">\(1\le n\le 10^5\)</span></li><li><span class="math inline">\(1 \le a_i \le 10^9\)</span></li></ul><h2 id="输出-2">输出</h2><p>一个整数，代表数组中所有区间的极差之和，对<span class="math inline">\(10^9+7\)</span>取模的值。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">2</span><br><span class="line">2 1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">a=[2,1]时，b数组为[1,1,2]。</span><br><span class="line">此时b数组共有6个连续子数组：</span><br><span class="line">[1]的极差为0。</span><br><span class="line">[1]的极差为0。</span><br><span class="line">[2]的极差为0。</span><br><span class="line">[1,1]的极差为0。</span><br><span class="line">[1,2]的极差为1。</span><br><span class="line">[1,1,2]的极差为1。</span><br><span class="line">因此答案是0+0+0+0+1+1=2。</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>由于<span class="math inline">\(b\)</span>是一个单调非递减数组，因此它的任意子数组极差就相当于是最后一个元素减去第一个元素的值。因此，只有最后一个元素的值和第一个不同时，才会对极差做出贡献。</p><p>可以知道，对于任意一对<span class="math inline">\(i,j(1\le i&lt;j\len)\)</span>，<span class="math inline">\(b\)</span>中都有<span class="math inline">\(a_i\cdot a_j\)</span>个子数组以<span class="math inline">\(i\)</span>开头，以<span class="math inline">\(j\)</span>结尾，它们都做出了<span class="math inline">\(j-i\)</span>的贡献。因此，这道题的答案为<span class="math inline">\(\displaystyle{\sum_{i=1}^n\sum_{j=i+1}^n(j-i)\cdot a_i\cdot a_j}\)</span>，令<span class="math inline">\(\displaystyle{s_i=\sum_{i=1}^na_i,s_0=0,t_i=\sum_{i=1}^n i\cdota_i,t_0=0}\)</span>。那么我们可以将这个结果进一步化简一下，有：</p><p><span class="math inline">\(\begin{aligned}&amp;\sum_{i=1}^n\sum_{j=i+1}^n (j-i)\cdot a_i\cdot a_j\\=&amp;\sum_{i=1}^n a_i\cdot\left(\sum_{j=i+1}^n (j-i)\cdot a_j\right)\\=&amp;\sum_{i=1}^n a_i\cdot\left(\sum_{j=i+1}^n j\cdota_j-i\cdot\sum_{j=i+1}^n a_j\right)\\ =&amp;\sum_{i=1}^na_i\cdot((t_n-t_i)-i\cdot(s_n-s_i))\\ \end{aligned}\)</span></p><p>由此，我们可以在<span class="math inline">\(O(n)\)</span>的时间内，通过计算<span class="math inline">\(s,t\)</span>，从而计算出最终结果。</p><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line">ll a[N],s1[N],s2[N];</span><br><span class="line">ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">        s1[i]=(s1[i<span class="number">-1</span>]+a[i])%mod;</span><br><span class="line">        s2[i]=(s2[i<span class="number">-1</span>]+a[i]*i)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans+=((s2[n]-s2[i])-(s1[n]-s1[i])*i%mod)*a[i]%mod;</span><br><span class="line">        ans=(ans%mod+mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>字节跳动 秋招 2023.09.24 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Zijietiaodong-20230924/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Zijietiaodong-20230924/</id>
    <published>2023-09-25T05:19:40.000Z</published>
    <updated>2023-09-25T05:19:40.673Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="小红的01串">1、小红的<code>01</code>串</h1><p>小红拿到了一个<code>01</code>串，她准备将若干个字符<code>'1'</code>染成红色，将若干个字符<code>'0'</code>染成蓝色，但有个限制：如果一个<code>'0'</code>和一个<code>'1'</code>相邻，那么它们不能同时染色。</p><p>小红想知道，最多可以染多少个字符？</p><h2 id="输入">输入</h2><p>输入仅有一行，为小红拿到的<code>01</code>串。</p><p>字符串长度不超过<span class="math inline">\(200000\)</span>。</p><h2 id="输出">输出</h2><p>一个正整数，代表能染色的最多字符。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">110011</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">染红第一个、第三个、第五个、第六个字符即可。</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>对于一个<code>01</code>相间，长度为<span class="math inline">\(n\)</span>的比特串，对它染色的最多个数为<span class="math inline">\(\lceiln/2\rceil\)</span>，因为相邻两个不能同时染色。</p><p>因此，我们对原来的字符串分拆成多个<strong>极大</strong><code>01</code>相间子串（即前一个子串的最后一个字符要和后一个子串的第一个字符相同），分别统计它们的最多染色数并相加即可。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200004</span>;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j;i&lt;=n;i=j)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;=n&amp;&amp;s[j]!=s[j<span class="number">-1</span>];++j);</span><br><span class="line">        ans+=(j-i+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小红刷抖音">2、小红刷抖音</h1><p>小红很喜欢刷抖音，抖音后台有一个推荐系统，小红向上滑动屏幕时，该推荐系统会计算应显示给小红的短视频。</p><p>用数值量化而言，每个短视频有一个内存占用<span class="math inline">\(a_i\)</span>（画质越好的视频内存占用越大），以及该视频可以带给小红愉悦度为<span class="math inline">\(b_i\)</span>。</p><p>值得注意的是，当小红每次重复刷到同一个视频时，观看该视频获得的愉悦度会除以<span class="math inline">\(2\)</span>（向下取整）。</p><p>例如，若一个视频初始给小红获得的愉悦度为<span class="math inline">\(5\)</span>，那么第二次小红获得的愉悦度会变成2，第三次为<span class="math inline">\(1\)</span>，第四次以后再刷到这个视频获得的愉悦度就为0了。</p><p>小红一共进行了<span class="math inline">\(q\)</span>次刷视频操作。</p><p>为了使得手机不卡顿，推荐系统每次会选择一个内存占用不高于<span class="math inline">\(x_i\)</span>的视频。</p><p>如果有多个这样的视频，推荐系统会推荐满足条件的播放画质最好的那个视频（即内存占用最高的视频）。</p><p>如果有多个视频的画质都是最好，那么推荐系统会推荐当前愉悦度最高的视频。</p><p>当小红观看完这个视频后，即可获得该视频的愉悦度，请你计算小红刷完所有视频时获得的总愉悦度。</p><h2 id="输入-1">输入</h2><p>第一行输入两个正整数<span class="math inline">\(n,q\)</span>，代表视频的总数量、小红刷视频的次数。</p><p>第二行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(a_i\)</span>，代表每个视频的内存占用。</p><p>第三行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(b_i\)</span>，代表每个视频第一次观看时给小红带来的愉悦值。</p><p>第四行输入<span class="math inline">\(q\)</span>个正整数<span class="math inline">\(x_i\)</span>，代表每次小红刷视频时，系统推荐的视频占用内存的上限。</p><ul><li><span class="math inline">\(1\le n,q \le 10^5\)</span></li><li><span class="math inline">\(1 \le a_i,b_i,z_i\le 10^9\)</span></li><li>保证<span class="math inline">\(x_i\)</span>一定不小于<span class="math inline">\(a_i\)</span>的最小值。</li></ul><h2 id="输出-1">输出</h2><p>一个整数，代表小红获得的愉悦度总和。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3 4</span><br><span class="line">3 5 1</span><br><span class="line">3 4 2</span><br><span class="line">3 3 6 1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">第一次刷视频，推荐系统推荐给小红第一个视频。小红获得愉悦度3。</span><br><span class="line">第二次刷视频，推荐系统推荐给小红第一个视频。由于是第二次观看，小红获得愉悦度1。</span><br><span class="line">第三次刷视频，推荐系统推荐给小红第二个视频。小红获得愉悦度4。</span><br><span class="line">第四次刷视频，推荐系统推荐给小红第三个视频。小红获得愉悦度2。</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>这题由于是优先查找内存不超过<span class="math inline">\(x_i\)</span>且取最大，再查找愉悦值最大，因此我们可以使用一个有序的数据结构进行解决。</p><p>具体做法是将每个不同的内存占用作为键，其对应的愉悦值可以用一个最大堆进行存储。由此，C++的<code>map</code>是最满足当前需要的容器。对于一次查询<span class="math inline">\(x_i\)</span>，只需要通过二分在<code>map</code>中找到最大的那个内存值，然后再将对应的最大堆元素取出，计入答案，并将其整除<span class="math inline">\(2\)</span>的值重新插入最大堆即可。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line">map&lt;<span class="type">int</span>,priority_queue&lt;<span class="type">int</span>&gt;&gt;mp;</span><br><span class="line"><span class="type">int</span> a[N],b[N],n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) mp[a[i]].<span class="built_in">push</span>(b[i]);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="keyword">auto</span> it=mp.<span class="built_in">upper_bound</span>(x);</span><br><span class="line">        --it;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>&gt;&amp;q=it-&gt;second;</span><br><span class="line">        <span class="type">int</span> k=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        ans+=k;</span><br><span class="line">        q.<span class="built_in">push</span>(k&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小红玩大富翁游戏">3、小红玩大富翁游戏</h1><p>小红在玩一个大富翁游戏，游戏的地图为一排房子，从左到右编号依次从<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>。</p><p>每个房子有一个购买价格<span class="math inline">\(a_i\)</span>和一个经过它的房租价格<span class="math inline">\(b_i\)</span>，当小红经过一个自己没有购买的房子时，她就需要交房租（已购买的房子则不需要交房租）。</p><p>在游戏开始前，小红可以购买任意数量的房子，然后开始游戏。</p><p>游戏中，小红会按照一个给定的排列<span class="math inline">\(p\)</span>的顺序依次经过所有的房子（排列<span class="math inline">\(p\)</span>为房子的编号顺序，<span class="math inline">\(p\)</span>的大小为<span class="math inline">\(n\)</span>，即每个房子都会作为一次目标）。</p><p>小红每经过一套房子都需要交租金，除非已购买。初始小红在第一个房子的左边，当她按照顺序经过了所有房子后，<strong>她会再次移动到第<span class="math inline">\(n\)</span>个房子的右边</strong>。</p><p>请你计算小红最少的总花费。</p><h2 id="输入-2">输入</h2><p>第一行输入一个整数<span class="math inline">\(n(1\le n\le10^5)\)</span>，代表房子的总数。</p><p>第二行输入一个排列<span class="math inline">\(p_i(1\le p_i\len)\)</span>，代表小红经过的房子编号顺序。</p><p>第三行输入<span class="math inline">\(n\)</span>个整数<span class="math inline">\(a_i(1\le a_i\le 10^9)\)</span>，代表编号<span class="math inline">\(i\)</span>的房子的购买价格。</p><p>第四行输入<span class="math inline">\(n\)</span>个整数<span class="math inline">\(b_i(1\le b_i \le 10^9)\)</span>，代表编号<span class="math inline">\(i\)</span>房子的经过房租价格。</p><p>保证<span class="math inline">\([1,n]\)</span>中每个数在<span class="math inline">\(p\)</span>数组中都出现且仅出现一次。</p><h2 id="输出-2">输出</h2><p>一行一个整数，表示最少的花费。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">4</span><br><span class="line">1 3 2 4</span><br><span class="line">5 4 2 4</span><br><span class="line">1 3 1 1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">游戏开始前买下第二个房子，花费4。</span><br><span class="line">开始游戏时，小红先向右走一步到达1号房子，房租价格为1。</span><br><span class="line">然后向右走2步到达3号房子，当小红经过2号房子时，由于2号房子已经购买，则不用交房租。然后到达3号房子时交房租价格为1。</span><br><span class="line">然后向左走1步到达2号房子，不需要交房租。</span><br><span class="line">然后向右走2步到达4号房子，经过的3号房子和4号房子分别交价格为1的房租。</span><br><span class="line">最后向右离开这个大富翁地图。</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>我们需要统计每个房子被经过的次数<span class="math inline">\(c_i\)</span>，那么最终答案为<span class="math inline">\(\displaystyle{\sum_{i=1}^n\min\{a_i,b_i\cdotc_i\}}\)</span>，也就是说，如果<span class="math inline">\(a_i\leb_i\cdot c_i\)</span>，那么就租下第<span class="math inline">\(i\)</span>栋房子，否则不租。</p><p>为了求出数组<span class="math inline">\(c_i\)</span>，我们可以考虑使用差分数组进行解决。假设<span class="math inline">\(t\)</span>是差分数组，并且目前处在位置<span class="math inline">\(x\)</span>，并且走向<span class="math inline">\(y\)</span>（为了避免端点重复计算，这一个过程只会计算终点<span class="math inline">\(y\)</span>的价值）。如果<span class="math inline">\(x&lt;y\)</span>，那么就对<span class="math inline">\(t_{x+1}\)</span>加上<span class="math inline">\(1\)</span>，对<span class="math inline">\(t_{y+1}\)</span>减去<span class="math inline">\(1\)</span>。如果<span class="math inline">\(x&gt;y\)</span>，那么就对<span class="math inline">\(t_x\)</span>减去<span class="math inline">\(1\)</span>，<span class="math inline">\(t_y\)</span>加上<span class="math inline">\(1\)</span>。</p><p>对于题目输入的排列。我们只需要令<span class="math inline">\(p_0=0,p_{n+1}=n+1\)</span>，那么整个过程就恰好不重不漏地完成计算，最终有<span class="math inline">\(c_i=c_{i-1}+t_i,c_0=0\)</span>。此后直接计算答案即可。</p><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200004</span>;</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="type">int</span> p[N],a[N],b[N],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">    ++s[<span class="number">1</span>];</span><br><span class="line">    --s[p[<span class="number">1</span>]+<span class="number">1</span>];</span><br><span class="line">    ++s[p[n]+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x=p[i],y=p[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(x&lt;y)&#123;</span><br><span class="line">            ++s[x+<span class="number">1</span>];--s[y+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ++s[y];--s[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        s[i]+=s[i<span class="number">-1</span>];</span><br><span class="line">        ans+=<span class="built_in">min</span>(<span class="number">1ll</span>*a[i],<span class="number">1ll</span>*b[i]*s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小红的机器人">4、小红的机器人</h1><p>小红有一个机器人，她可以对机器人进行以下<span class="math inline">\(4\)</span>种指令：</p><ul><li><code>L</code>：向左一步。</li><li><code>R</code>：向右一步。</li><li><code>U</code>: 向上一步。</li><li><code>D</code>: 向下一步。小红现在给定了一个指令集（有上下左右最多四种操作）。</li></ul><p>小红希望选出一个非空子序列（在指令集中可以不连续），使得机器人执行这段子序列指令后回到原地。小红想知道最终有多少选择方式？由于答案可能过大，请对<span class="math inline">\(10^9+7\)</span>取模。</p><p>我们定义，两个子序列中存在某位置字母的选择情况不同（例如在第一个子序列中选择了第<span class="math inline">\(x\)</span>个字符，而在第二个子序列中没选），则称为两个不同的子序列。</p><h2 id="输入-3">输入</h2><p>一行仅包含<code>'L', 'R', 'U', 'D'</code>四种字符的字符串，长度不超过<span class="math inline">\(500000\)</span>。</p><h2 id="输出-3">输出</h2><p>一个整数，代表子序列的选择方案。</p><h2 id="样例-3">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">LLRUU</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">第一种方案：选择第一个字符和第三个字符组成子序列&quot;LR&quot;，向左走一步，向右走一步，回到原点。</span><br><span class="line">第二种方案：选择第二个字符和第三个字符组成子序列&quot;LR&quot;，向左走一步，向右走一步，回到原点。</span><br></pre></td></tr></table></figure><h2 id="解答-3">解答</h2><p>可以发现，这些指令是没有顺序性的。即前面的指令执行结果并不会影响后面的执行执行结果。因此，最终机器人的位置只和不同指令的个数有关，而和顺序没有关系。</p><p>如果一条非空指令能够使机器人回到原点，那么<code>L, R</code>的数量必须相等，<code>U, D</code>的数量必须相等。并且可以发现，两个维度的坐标都是独立互不干扰的，可以使用乘法原理计算完成。</p><p>因此，假设<span class="math inline">\(c_L,c_R,c_U,c_D\)</span>分别是输入的字符串的<code>L, R, U, D</code>的指令数，那么我们可以得到最终答案为：</p><p><span class="math display">\[\left(\sum_{i=0}^{\min\{c_L,c_R\}}\dbinom{c_L}{i}\cdot\dbinom{c_R}{i}\right)\cdot\left(\sum_{i=0}^{\min\{c_U,c_D\}}\dbinom{c_U}{i}\cdot\dbinom{c_D}{i}\right)-1\]</span></p><p>其中最后的<span class="math inline">\(-1\)</span>是指指令为空的情况。</p><p>本题的实现基于线性逆元，当然也可以不写，直接求出阶乘再计算逆元也是可以的。</p><h2 id="代码-3">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">500004</span>;</span><br><span class="line">ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll fac[N],finv[N],inv[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=fac[<span class="number">1</span>]=inv[<span class="number">1</span>]=finv[<span class="number">0</span>]=finv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">        inv[i]=(mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">        finv[i]=finv[i<span class="number">-1</span>]*inv[i]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fac[n]*finv[n-m]%mod*finv[m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> cnt[<span class="number">128</span>];</span><br><span class="line"><span class="function">ll <span class="title">cal</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> w=<span class="built_in">min</span>(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=w;i++)</span><br><span class="line">        ans=(ans+<span class="built_in">C</span>(x,i)*<span class="built_in">C</span>(y,i))%mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">init</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ++cnt[s[i]];</span><br><span class="line">    ll m1=<span class="built_in">cal</span>(cnt[<span class="string">&#x27;L&#x27;</span>],cnt[<span class="string">&#x27;R&#x27;</span>]);</span><br><span class="line">    ll m2=<span class="built_in">cal</span>(cnt[<span class="string">&#x27;U&#x27;</span>],cnt[<span class="string">&#x27;D&#x27;</span>]);</span><br><span class="line">    ll ans=m1*m2%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>网易 秋招 2023.09.23 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Wangyi-20230923B/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Wangyi-20230923B/</id>
    <published>2023-09-25T05:19:38.000Z</published>
    <updated>2023-09-25T05:19:38.427Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="小红的字符串查询">1、小红的字符串查询</h1><p>小红拿到了一个字符串。她有多次查询，每次查询一个区间，你需要回答该区间包含了多少个长度为<span class="math inline">\(3\)</span>的、所有字母都相等的连续子串。</p><h2 id="输入">输入</h2><p>第一行输入两个正整数<span class="math inline">\(n,k\)</span>，代表字符率长度和查询次数。</p><p>第二行输入一个长度为<span class="math inline">\(n\)</span>的、仅包含小写字母的字符串。</p><p>接下来的<span class="math inline">\(k\)</span>行，每行输入两个正整数<span class="math inline">\(l,r\)</span>，代表一次查询。</p><ul><li><span class="math inline">\(l \le n,k \le 10^5\)</span></li><li><span class="math inline">\(1\le l\le r\le n\)</span></li></ul><h2 id="输出">输出</h2><p>输出<span class="math inline">\(k\)</span>行，每行输出一个整数表示答案。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">8 4</span><br><span class="line">aaaaabbb</span><br><span class="line">1 8</span><br><span class="line">2 7</span><br><span class="line">3 6</span><br><span class="line">4 5</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>这题使用前缀和将会变得非常简单。令<span class="math inline">\(f_i(i\ge 3)\)</span>表示字符串的三个字母<span class="math inline">\(s_{i-2},s_{i-1},s_{i}\)</span>是否相等，如果相等，那么为<span class="math inline">\(1\)</span>，否则为<span class="math inline">\(0\)</span>，其中<span class="math inline">\(f_1=f_2=0\)</span>。</p><p>那么，令<span class="math inline">\(t_i=\displaystyle{\sum_{j=1}^if_j},t_0=0\)</span>表示<span class="math inline">\(f\)</span>的前缀和，因此对于每次询问<span class="math inline">\(l,r\)</span>，只需要回答值<span class="math inline">\(\max\{0,t_r-t_{l+1}\}\)</span>即可。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"><span class="type">char</span> t[N];</span><br><span class="line"><span class="type">int</span> s[N],n,q,l,r;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %s&quot;</span>,&amp;n,&amp;q,t+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[i]==t[i<span class="number">-1</span>]&amp;&amp;t[i]==t[i<span class="number">-2</span>])&#123;</span><br><span class="line">            s[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s[i]+=s[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        l+=<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,l&gt;r?<span class="number">0</span>:s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小红的数组构造">2、小红的数组构造</h1><p>小红有一个数组，数组相邻元素的差值最多为<span class="math inline">\(1\)</span>，即<span class="math inline">\(|a_i-a_{i+1}|\le1\)</span>，并且数组元素都是正整致，即<span class="math inline">\(a_i\ge1\)</span>，现在小红知道数组的长度为<span class="math inline">\(n\)</span>，数组的和为<span class="math inline">\(m\)</span>，小红想知道所有符合条件的数组中，<span class="math inline">\(a_p\)</span>的最大值是多少。</p><h2 id="输入-1">输入</h2><p>第一行三个整数<span class="math inline">\(n,m,p\)</span>，表示数组的长度，数组的和，以及要求的位置。</p><ul><li><span class="math inline">\(1\le p\le n\le m\le 10^9\)</span></li></ul><h2 id="输出-1">输出</h2><p>输出一个整数，表示位置<span class="math inline">\(a_p\)</span>的最大值。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">4 5 2</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">数组[1,2,1,1] 满足条件，且位置2的最大值为2。</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>这道题可以使用二分法进行求解。接下来元素<span class="math inline">\(a_p\)</span>是否可以取到<span class="math inline">\(x\)</span>。</p><p>为了元素<span class="math inline">\(a_p\)</span>是否可以取到<span class="math inline">\(x\)</span>，那么其它元素得值尽可能低。于此同时为了维持相邻元素的绝对差不超过<span class="math inline">\(1\)</span>这个性质，对于元素<span class="math inline">\(a_q\)</span>，如果<span class="math inline">\(q&gt;p\)</span>，那么<span class="math inline">\(a_q\)</span>就要比<span class="math inline">\(a_{q-1}\)</span>少<span class="math inline">\(1\)</span>；如果<span class="math inline">\(q&lt;p\)</span>，那么<span class="math inline">\(a_q\)</span>就要比<span class="math inline">\(a_{q+1}\)</span>少<span class="math inline">\(1\)</span>，直到恰好为<span class="math inline">\(0\)</span>。</p><p>这种情况是最节省和值的使用的，我们可以通过逐渐为其它元素加上<span class="math inline">\(1\)</span>，直到总和达到<span class="math inline">\(m\)</span>，如果总和达不到<span class="math inline">\(m\)</span>，那么<span class="math inline">\(a_p\)</span>必定不止<span class="math inline">\(x\)</span>。因此，我们不需要考虑<span class="math inline">\(a_p\)</span>的上界。</p><p>更一般的来说，如果第<span class="math inline">\(a_p=x\)</span>，那么最节省和值方法的形状如下：</p><p><span class="math display">\[0,0,0,\dots,0,1,2\dots,x-1,x,x-1,x-2,\dots2,1,0,\dots,0\]</span></p><p>注意，两端可能没有取到<span class="math inline">\(0\)</span>就结束了。</p><p>由于两边的处理方式是一样的，因此只需要考虑其中一侧。令<span class="math inline">\(f(n,x)\)</span>表示现在有<span class="math inline">\(n\)</span>个数组元素，其中最后一个元素为<span class="math inline">\(x\)</span>时，最少需要消耗的和值。按照等差数列求和公式，那么可以写出</p><p><span class="math inline">\(f(n,x)= \left\{\begin{aligned}  &amp;\dfrac{(2x-n+1)n}{2} &amp; &amp; \text{if}\quadx\ge n \\  &amp;\dfrac{(x+1)x}{2} &amp; &amp; \text{if}\quad x&lt;n \\\end{aligned}\right.\)</span></p><p>因此，判断第<span class="math inline">\(x\)</span>栋楼高度是否为至少<span class="math inline">\(h\)</span>，只需要判断<span class="math inline">\(f(p,x)+f(n-p+1,x)-x\lem\)</span>是否满足即可。</p><h2 id="代码-1">代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">n, m, p = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cal2</span>(<span class="params">n, x</span>):</span><br><span class="line">    <span class="keyword">if</span> x &gt;= n:</span><br><span class="line">        <span class="keyword">return</span> (x + x - n + <span class="number">1</span>) * n // <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> (x + <span class="number">1</span>) * x // <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cal</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> cal2(p, x) + cal2(n - p + <span class="number">1</span>, x) - x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">l, r = <span class="number">1</span>, m</span><br><span class="line"><span class="keyword">while</span> l &lt; r:</span><br><span class="line">    mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> cal(mid) &lt;= m:</span><br><span class="line">        l = mid</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r = mid - <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(l)</span><br></pre></td></tr></table></figure><h1 id="小红的树上路径与">3、小红的树上路径与</h1><p>小红拿到了一棵树，她定义一条路径的权值为路径上所有节点权值按位与计算出的值。小红想知道，所有路径的权值之和等于多少？答案请对<span class="math inline">\(10^9+7\)</span>取模。</p><h2 id="输入-2">输入</h2><p>第一行输入一个正整数<span class="math inline">\(n\)</span>，代表树的节点数量。</p><p>第二行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(a_i\)</span>，代表每个节点的权值。</p><p>接下来的<span class="math inline">\(n-1\)</span>行，每行输入<span class="math inline">\(2\)</span>个正整数<span class="math inline">\(u,v\)</span>，代表节点<span class="math inline">\(u\)</span>和节点<span class="math inline">\(v\)</span>有一条无向边连接。</p><ul><li><span class="math inline">\(1\le n\le 10^5\)</span></li><li><span class="math inline">\(1\le a_i\le 10^9\)</span></li></ul><h2 id="输出-2">输出</h2><p>一个整数，代表所有路径的权值之和。由于答案过大，请对<span class="math inline">\(10^9+7\)</span>取模。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">3 6 4</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">路径1-2的权值为3&amp;6，管案是2。</span><br><span class="line">路径2-3的权值为6&amp;4，答案是4。</span><br><span class="line">路径1-2-3的权值为3&amp;6&amp;4，管案是0。</span><br><span class="line">因此所有路程的权值之和是2+4=6。</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>由于不同数位之间的比特都是相互独立的，因此我们对同一数位进行处理即可。</p><p>不失一般性，我们只讨论最低位的情况。对于<span class="math inline">\(u,v\)</span>间的路径的与值为<span class="math inline">\(1\)</span>，当且仅当<span class="math inline">\(u,v\)</span>之间所有的节点值都为<span class="math inline">\(1\)</span>。由于原图是一棵树，因此我们去除所有<span class="math inline">\(0\)</span>节点后，可以发现这个图变成了一个森林，其中每个连通块都是一棵树。同一连通块下的任意一对节点的与值都为<span class="math inline">\(1\)</span>，因此我们统计每个连通块的节点数<span class="math inline">\(c\)</span>后，可以知道这里面一共有<span class="math inline">\(\dfrac{c(c+1)}{2}\)</span>条路径可以添加到答案中。</p><p>这里使用了并查集来求取每个连通块中的节点数。</p><p>因此回到原题，假设所有数第<span class="math inline">\(i\)</span>位做出的贡献为<span class="math inline">\(v_i\)</span>，那么最终答案为<span class="math inline">\(\displaystyle{\sum_{i=0}^{\infty}2^i\cdotv_i}\)</span>。</p><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> pi pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line">ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> fa[N],sz[N],n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">vector&lt;pi&gt;e;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="built_in">find</span>(x),v=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(u!=v)&#123;</span><br><span class="line">        fa[v]=u;</span><br><span class="line">        sz[u]+=sz[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        fa[i]=i;sz[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[x,y]:e)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[x]&amp;&amp;b[y])</span><br><span class="line">            <span class="built_in">merge</span>(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i]&amp;&amp;i==<span class="built_in">find</span>(i))</span><br><span class="line">            ans+=<span class="number">1ll</span>*sz[i]*(sz[i]<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        e.<span class="built_in">push_back</span>(<span class="built_in">pi</span>(x<span class="number">-1</span>,y<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">b</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            b[j]=a[j]&gt;&gt;i&amp;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=(ans+(<span class="built_in">solve</span>(b)&lt;&lt;i))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小红的数列">4、小红的数列</h1><p>小红拿到了一个数列，该数列满足以下性质：</p><ol type="1"><li><span class="math inline">\(f(1)=a,f(2)=b\)</span></li><li><span class="math inline">\(f(i)=f(i-1)\cdot f(i-2)\cdotc^d\)</span></li></ol><p>请你计算出该数列的第<span class="math inline">\(n\)</span>项的因子数量。由于答案过大，请对<span class="math inline">\(10^9+7\)</span>取模。</p><h2 id="输入-3">输入</h2><p>五个正整数<span class="math inline">\(a,b,c,d,n\)</span>。</p><ul><li><span class="math inline">\(l\le a,b,c,d,n\le 10^{12}\)</span></li></ul><h2 id="输出-3">输出</h2><p>第<span class="math inline">\(n\)</span>项的因子数量对<span class="math inline">\(10^9+7\)</span>取模的值。</p><h2 id="样例-3">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">1 2 3 4 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">第三项是162，共有10个因子。</span><br></pre></td></tr></table></figure><h2 id="解答-3">解答</h2><p>如果一个数<span class="math inline">\(n\)</span>可以被分解成<span class="math inline">\(\displaystyle{n=\prod_{i=1}^mp_i^{e_i}}\)</span>，那么它的因子个数为<span class="math inline">\(\displaystyle{\sigma_0(n)=\prod_{i=1}^m(e_i+1)}\)</span>。</p><p>因此，我们可以考虑找出<span class="math inline">\(f(n)\)</span>的因式分解，并使用上面的公式进行求解出最终答案。</p><p>假设质因子<span class="math inline">\(p\)</span>在<span class="math inline">\(n\)</span>的质因数分解出现的次数记为<span class="math inline">\(g(n,p)\)</span>，令<span class="math inline">\(f_p(n)=g(f(n),p)\)</span>，那么按照上面<span class="math inline">\(f\)</span>的式子，我们可以得到：</p><p><span class="math display">\[f_p(n)=f_p(n-1)+f_p(n-2)+g(c,p)\cdotd\]</span></p><p>这和斐波那契数列非常像，更一般的，我们将它写成矩阵相乘的形式：</p><p><span class="math display">\[\begin{aligned}[f_p(n),f_p(n+1),g(c,p)\cdot d]&amp;=[f_p(n-1),f_p(n),g(c,p)\cdotd]\cdot\begin{bmatrix}0&amp;1&amp;0\\1&amp;1&amp;0\\0&amp;1&amp;1\\\end{bmatrix}\\&amp;=[f_p(1),f_p(2),g(c,p)\cdot d]\cdot\begin{bmatrix}0&amp;1&amp;0\\1&amp;1&amp;0\\0&amp;1&amp;1\\\end{bmatrix}^{n-1}\\&amp;=[g(a,p),g(b,p),g(c,p)\cdot d]\cdot\begin{bmatrix}0&amp;1&amp;0\\1&amp;1&amp;0\\0&amp;1&amp;1\\\end{bmatrix}^{n-1}\end{aligned}\]</span></p><p>其中，最后一行通过矩阵快速幂即可完成。</p><p>因此，最终答案为<span class="math inline">\(\displaystyle{\prod_p(f_p(n)+1)}\)</span>。其余的任务就是对<span class="math inline">\(a,b,c\)</span>进行因式分解，这没有任何难度。</p><h2 id="代码-3">代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> factorint</span><br><span class="line"></span><br><span class="line">mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">a: <span class="built_in">list</span>, b: <span class="built_in">list</span></span>):</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">sum</span>(a[i][k] * b[k][j] <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(b))) % mod <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(b[<span class="number">0</span>]))] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a))]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a, b, c, d, n = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">fa, fb, fc = <span class="built_in">dict</span>(factorint(a).items()), <span class="built_in">dict</span>(factorint(b).items()), <span class="built_in">dict</span>(factorint(c).items())</span><br><span class="line">mp = &#123;x: [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>(fa.keys()) + <span class="built_in">list</span>(fb.keys()) + <span class="built_in">list</span>(fc.keys())&#125;</span><br><span class="line"><span class="keyword">for</span> p, e <span class="keyword">in</span> fa.items():</span><br><span class="line">    mp[p][<span class="number">0</span>] += e</span><br><span class="line"><span class="keyword">for</span> p, e <span class="keyword">in</span> fb.items():</span><br><span class="line">    mp[p][<span class="number">1</span>] += e</span><br><span class="line"><span class="keyword">for</span> p, e <span class="keyword">in</span> fc.items():</span><br><span class="line">    mp[p][<span class="number">2</span>] += e</span><br><span class="line"></span><br><span class="line">ans = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> mp.values():</span><br><span class="line">    a = [[v[<span class="number">0</span>], v[<span class="number">1</span>], v[<span class="number">2</span>] * d]]</span><br><span class="line">    b = [[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]]</span><br><span class="line">    k = n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k:</span><br><span class="line">        <span class="keyword">if</span> k &amp; <span class="number">1</span>:</span><br><span class="line">            a = mul(a, b)</span><br><span class="line">        b = mul(b, b)</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span></span><br><span class="line">    ans = ans * (a[<span class="number">0</span>][<span class="number">0</span>] + <span class="number">1</span>) % mod</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>网易 秋招 2023.09.23 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Wangyi-20230923A/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Wangyi-20230923A/</id>
    <published>2023-09-25T05:19:36.000Z</published>
    <updated>2023-09-25T05:19:36.178Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="小红的有序数组">1、小红的有序数组</h1><p>小红有一个长度为<span class="math inline">\(n\)</span>的数组，数组下标为<span class="math inline">\(0\)</span>到<span class="math inline">\(n-1\)</span>，每次可以交换下标为<span class="math inline">\(i\)</span>和<span class="math inline">\((i+2)\%n\)</span>的数，请问小红能否通过有限次交换使得数组变成一个单调不减的数组。</p><h2 id="输入">输入</h2><p>第一行一个整数<span class="math inline">\(t\)</span>，表示数据组数。</p><p>接下来<span class="math inline">\(t\)</span>组数据，每组数据第一行一个整数<span class="math inline">\(n\)</span>，表示数组长度。</p><p>每组数据第二行<span class="math inline">\(n\)</span>个整数<span class="math inline">\(a_i\)</span>，表示数组的值。</p><ul><li><span class="math inline">\(1 \le t \le 10\)</span>-</li><li><span class="math inline">\(1 \le n \le 10^5\)</span></li><li><span class="math inline">\(1 \le a_i \le 10^9\)</span></li></ul><h2 id="输出">输出</h2><p>对于每组数据，如果能够通过有限次交换使得数组变成一个单调不减的数组，输出<code>"YES"</code>，否则输出<code>"NO"</code>。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">1 4 3 2</span><br><span class="line">4</span><br><span class="line">4 3 2 1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">YES</span><br><span class="line">NO</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">第一组数据，交换下标为1和3的数，变成[1,2,3,4]单调不减。</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>首先我们可以知道有如下性质：交换关系是有传递性的，即如果下标为<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>的元素能够进行交换，<span class="math inline">\(y\)</span>和<span class="math inline">\(z\)</span>的元素能够进行交换，那么<span class="math inline">\(x\)</span>和<span class="math inline">\(z\)</span>的元素也是能够进行交换的。</p><p>因此对于<span class="math inline">\(n\)</span>的奇偶性，我们分两种情况进行讨论：</p><ol type="1"><li><p>当<span class="math inline">\(n\)</span>为奇数时，对于<span class="math inline">\(i&lt;n-2\)</span>的情况，都是同奇偶的下标进行交换。当<span class="math inline">\(i\in\{n-2,n-1\}\)</span>时，是一个奇数下标和偶数下标元素的交换。因此按照传递性，所有元素都是直接可以交换的，因此这种情况必定成功。</p></li><li><p>当<span class="math inline">\(n\)</span>为奇数时，对于所有<span class="math inline">\(i&lt;n\)</span>的下标，都是同奇偶的下标进行交换。因此，将奇数下标和偶数下标的数处理出来后，各自排序后再按照对应位置还原到原来的数组中，再判断这个数组是否有序即可。</p></li></ol><h2 id="代码">代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    a = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    b0, b1 = [], []</span><br><span class="line">    <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(a):</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            b0.append(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            b1.append(x)</span><br><span class="line">    b0.sort()</span><br><span class="line">    b1.sort()</span><br><span class="line">    <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(b0):</span><br><span class="line">        a[i &lt;&lt; <span class="number">1</span>] = x</span><br><span class="line">    <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(b1):</span><br><span class="line">        a[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = x</span><br><span class="line">    <span class="keyword">return</span> a == <span class="built_in">sorted</span>(a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;YES&quot;</span> <span class="keyword">if</span> solve() <span class="keyword">else</span> <span class="string">&quot;NO&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小红的相似字符串">2、小红的相似字符串</h1><p>小红认为两个字符串相似，需要这两个字符串的每个字母的个数都相等。</p><p>如<code>"abcbd"</code>和<code>"dbcba"</code>相似，<code>"abcd"</code>和<code>"abcd"</code>相似。</p><p>而<code>"abb"</code>和<code>"aab"</code>不相似，<code>"ac"</code>和<code>"cca"</code>不相似。</p><p>现在小红有<span class="math inline">\(n\)</span>个字符串，她想知道有多少对字符串是相似的？</p><h2 id="输入-1">输入</h2><p>输入一个整数<span class="math inline">\(n\)</span>。</p><p>接下来<span class="math inline">\(n\)</span>行，每行输入一个仅包含小写字母的字符串<span class="math inline">\(s\)</span>。</p><ul><li><span class="math inline">\(1 \le n \le 10^5\)</span></li><li><span class="math inline">\(1 \le \text{len}(s) \le10^5\)</span></li></ul><h2 id="输出-1">输出</h2><p>输出一个整数。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">7</span><br><span class="line">abcbd</span><br><span class="line">dbcba</span><br><span class="line">abcd</span><br><span class="line">abcd</span><br><span class="line">adbc</span><br><span class="line">aa</span><br><span class="line">aa</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>如果两个字符串的字符个数都相同，那么对各自字符串的所有字符排好序后，它们的长度必定是相等的。</p><p>因此，我们只需要将每个字符串按字符排好序后，看看排好序的字符串有多少对相等即可。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;string,<span class="type">int</span>&gt;mp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string s;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        ans+=mp[s];</span><br><span class="line">        ++mp[s];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="子序列平均数之和">3、子序列平均数之和</h1><p>给定由<span class="math inline">\(n\)</span>个元素组成的数组，求所有子序列的平均数之和。答案请对<span class="math inline">\(10^9+7\)</span>取模。</p><p>子序列：原数组中选择部分元素，保持原数组的顺序形成的新数组。例如<span class="math inline">\([1,2,3,4,5]\)</span>的子序列有<span class="math inline">\([1,2,5],[2,4]\)</span>等，但<span class="math inline">\([2,2],[1,3,2]\)</span>则不是它的子序列。</p><h2 id="输入-2">输入</h2><p>第一行输入一个正整数<span class="math inline">\(n\)</span>，代表数组的元素个数。</p><p>第二行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(a_i\)</span>，用来表示数组。</p><ul><li><span class="math inline">\(1 \le n \le 10^5\)</span></li><li><span class="math inline">\(1 \le a \le 10^9\)</span></li></ul><h2 id="输出-2">输出</h2><p>所有子序列的平均数之和对<span class="math inline">\(10^9 +7\)</span>取模的值。可以证明，最终的答案一定是一个有理数，<span class="math inline">\(\dfrac{a}{b}\)</span>对<span class="math inline">\(p\)</span>取模的意义是在<span class="math inline">\([0,p-1]\)</span>区间找到一个满足<span class="math inline">\(x\cdot b\bmod p=a\)</span>。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">14</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">子序列共有7个：</span><br><span class="line">[1]的平均数是1。</span><br><span class="line">[2]的平均数是2。</span><br><span class="line">[3]的平均数是3。</span><br><span class="line">[1,2]的平均数是3/2。</span><br><span class="line">[1,3]的平均数是2。</span><br><span class="line">[2,3]的平均数是5/2。</span><br><span class="line">[1,2,3]的平均数是2。</span><br><span class="line">总和为14。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">2</span><br><span class="line">2 1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">500000008</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>由于这里考虑的是某个子序列的相同地位的元素之和，因此数组的每个贡献值都必定相等，这里只考虑其中一个元素的贡献。</p><p>对于任意一个元素<span class="math inline">\(a_k\)</span>，它能够出现在长度为<span class="math inline">\(i\)</span>的子序列一共有<span class="math inline">\(\dbinom{n-1}{i-1}\)</span>个，因为元素<span class="math inline">\(i\)</span>已经被固定选定了，在这些子序列中，它所作出的贡献是<span class="math inline">\(\dfrac{a_k}{i}\)</span>。也就是说，<span class="math inline">\(a_k\)</span>一共对答案做出了<span class="math inline">\(\displaystyle{a_k\cdot \sum_{i=1}^n\dfrac{1}{i}\dbinom{n-1}{i-1}}\)</span>的贡献。可以发现，贡献的系数和数组元素本身无关。更进一步的，我们可以化简一下这个系数<span class="math inline">\(\displaystyle{\sum_{i=1}^n\dfrac{1}{i}\dbinom{n-1}{i-1}}\)</span>，有：</p><p><span class="math inline">\(\begin{aligned} &amp;\sum_{i=1}^n\dfrac{1}{i}\dbinom{n-1}{i-1}\\ =&amp;\sum_{i=1}^n \dfrac{(n-1)!}{i\cdot(i-1)!\cdot (n-i)!}\\=&amp;\sum_{i=1}^n\dfrac{1}{n}\cdot\dfrac{n!}{i!\cdot (n-i)!}\\=&amp;\dfrac{2^n-1}{n} \end{aligned}\)</span></p><p>因此这道题的最终答案为<span class="math inline">\(\displaystyle{\dfrac{2^n-1}{n}\cdot\sum_{i=1}^na_i}\)</span>。</p><h2 id="代码-2">代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">s1 = <span class="built_in">sum</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">s2 = (<span class="built_in">pow</span>(<span class="number">2</span>, n, mod) - <span class="number">1</span>) * <span class="built_in">pow</span>(n, mod - <span class="number">2</span>, mod) % mod</span><br><span class="line">ans = s1 * s2 % mod</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure><h1 id="小红的路径覆盖">4、小红的路径覆盖</h1><p>小红拿到了一棵树，她有<span class="math inline">\(q\)</span>次询问，每次会选出一个点集，小红希望你使用尽可能少的简单路径覆盖点集中的所有节点。你能帮帮她吗？</p><h2 id="输入-3">输入</h2><p>第一行输入两个正整数<span class="math inline">\(n\)</span>和<span class="math inline">\(q\)</span>，代表树的节点数量、小红的询问次数。</p><p>接下来的<span class="math inline">\(n-1\)</span>行，每行输入两个正整数<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>，代表节点<span class="math inline">\(u\)</span>和节点<span class="math inline">\(v\)</span>有一条边连接。</p><p>接下来的<span class="math inline">\(2\timesq\)</span>行，每两行代表一次询问。每次询问的第一行为一个正整数<span class="math inline">\(m\)</span>，代表点集的大小，第二行为<span class="math inline">\(m\)</span>个正整数<span class="math inline">\(a_i\)</span>，代表点集中的节点编号。</p><ul><li><span class="math inline">\(1 \le n,q\le 2\times 10^5\)</span></li><li><span class="math inline">\(1 \le u,v,a_i\le n\)</span></li><li>所有<span class="math inline">\(m\)</span>的总和不超过<span class="math inline">\(2\times 10^5\)</span></li></ul><h2 id="输出-3">输出</h2><p>输出<span class="math inline">\(q\)</span>行，每行输出一个正整数，代表每次询问覆盖点集中所有点的最少路径数量。</p><h2 id="样例-3">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">4 2</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">3</span><br><span class="line">2 3 4</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">第一次询问可以直接选择路径：2-1-3。</span><br><span class="line">第二次询问至少需要选择两条路径，例如选择路径2-1-3和路径1-4，或者选择路径2-1-4和路径3-1-4。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">5 1</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">3 5</span><br><span class="line">4</span><br><span class="line">1 3 4 5</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">我们第一条路径选择1-2-3，第二条路经选择4-3-5，这两条路经即可覆盖1、3、4、5这四个点。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以下是这两棵树对应的图：</p><pre class="mermaid">graph TD    subgraph T1        A((1));B((2));C((3));D((4));        A---B;A---C;A---D;    end    subgraph T2        1((1));2((2));3((3));4((4));5((5));        1---2;2---3;3---4;3---5;    end</pre><h2 id="解答-3">解答</h2><p>前置知识：dfs序是对一棵树进行深度优先搜索的时候所经过的节点顺序。我们记录每个节点<span class="math inline">\(u\)</span>开始访问的时间戳<span class="math inline">\(l_u\)</span>和结束访问的时间戳<span class="math inline">\(r_u\)</span>，那么区间<span class="math inline">\([l_u,r_u]\)</span>就包含了当前以<span class="math inline">\(u\)</span>为根的子树的一些信息。并且，<span class="math inline">\(l_u\)</span>是节点<span class="math inline">\(u\)</span>的信息。假设遍历<span class="math inline">\(u\)</span>的所有子节点<span class="math inline">\(v_1,v_2,\dots\)</span>，那么构造出来的区间<span class="math inline">\([l_{v_1},r_{v_1}],[l_{v_2},r_{v_2}],\dots\)</span>它们都是<strong>首尾相接</strong>的。并且，最后一个子节点的右端点的下标恰好为<span class="math inline">\(r_u\)</span>。</p><p>对于一条备选的路径，它将会穿过一些节点，这些节点有可能在<span class="math inline">\(S\)</span>中，也有可能不在<span class="math inline">\(S\)</span>中。此外，这些路径如果起点或者终点不在<span class="math inline">\(S\)</span>内，并不会使得覆盖更加完善。因此，不失一般性，备选的路径的起点和终点都位于<span class="math inline">\(S\)</span>中。</p><p>根据上面的思想，我们可以对这棵树<span class="math inline">\(T\)</span>进行如下操作：不停地删去不在<span class="math inline">\(S\)</span>中的叶子节点和其关联的边，直到所有叶子节点都是<span class="math inline">\(S\)</span>中的节点。这时，我们数一下剩下的树<span class="math inline">\(T&#39;\)</span>中的叶子节点个数<span class="math inline">\(c\)</span>，可以发现用<span class="math inline">\(\lceilc/2\rceil\)</span>条这样的路径就能够覆盖剩下的整棵树。</p><p>这意味着，<span class="math inline">\(S\)</span>中的一个节点<span class="math inline">\(w\)</span>如果能够被<span class="math inline">\(S\)</span>中的另外两个不相同节点<span class="math inline">\(u,v\)</span>的简单路径覆盖，那么<span class="math inline">\(w\)</span>肯定不是上面所提到的树<span class="math inline">\(T&#39;\)</span>的叶子节点。在原树<span class="math inline">\(T\)</span>看来，对于任意一个在<span class="math inline">\(T&#39;\)</span>中的叶子节点<span class="math inline">\(l&#39;,S-\{l&#39;\}\)</span>必定都在<span class="math inline">\(l&#39;\)</span>的其中一棵子树当中。</p><p>那么也就是说，对于任意<span class="math inline">\(u\inS\)</span>，我们只需要判断<span class="math inline">\(S-\{u\}\)</span>是否在<span class="math inline">\(u\)</span>的某一棵子树即可。统计这些节点的个数<span class="math inline">\(c\)</span>，那么最终答案就是<span class="math inline">\(\lceil c/2\rceil\)</span>。</p><p>这个问题可以使用dfs序和树状数组进行解决。对于每次询问的<span class="math inline">\(S\)</span>，我们将每个节点的dfs序号在树状数组中标记上。然后枚举每个<span class="math inline">\(u\in S\)</span>，并且枚举<span class="math inline">\(u\)</span>的所有子节点<span class="math inline">\(v\)</span>，如果存在<span class="math inline">\(v\)</span>使得<span class="math inline">\(l_v\)</span>到<span class="math inline">\(r_v\)</span>之间的元素和为<span class="math inline">\(|S|-1\)</span>，那么<span class="math inline">\(u\)</span>是符合要求的。如果没有找到，我们还需要判断一种情况，即<span class="math inline">\(S-\{u\}\)</span>是否在<span class="math inline">\(u\)</span>所指向的父亲的那棵子树中。</p><p>但是这样子判断，如果给定<span class="math inline">\(u\)</span>，它的子节点非常多（达到了<span class="math inline">\(n-1\)</span>个），那么每次只询问<span class="math inline">\(u\)</span>也是非常消耗时间的。注意到，我们是需要找到一个子节点对应的区间<span class="math inline">\([l_v,r_v]\)</span>其区间元素之和为<span class="math inline">\(|S|-1\)</span>，这意味着，其它子节点<span class="math inline">\(v&#39;\)</span>对应的区间的元素之和都为<span class="math inline">\(0\)</span>。由于上面提到，这些子节点区间都是相邻挨着的，因此我们可以考虑使用二分，找到第一个子节点<span class="math inline">\(v\)</span>满足<span class="math inline">\([l_u-1,r_{v}]\)</span>的区间元素之和不为<span class="math inline">\(0\)</span>，然后再判断这个区间的元素和是否为<span class="math inline">\(|S|-1\)</span>即可。</p><p>因此，这题可以在<span class="math inline">\(O(n\log^2n)\)</span>的时间内完成。</p><h2 id="代码-3">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> lb(x) ((x) &amp; -(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"><span class="type">int</span> s[N],n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=p;i&lt;=n;i+=<span class="built_in">lb</span>(i))</span><br><span class="line">        s[i]+=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">que</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=p;i;i-=<span class="built_in">lb</span>(i))</span><br><span class="line">        ans+=s[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;g[N],h[N];</span><br><span class="line"><span class="type">int</span> lp[N],rp[N],tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    lp[u]=++tot;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:h[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    rp[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> sz)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(g[u].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> lsum=<span class="built_in">que</span>(lp[u]);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">que</span>(rp[u])-lsum<span class="number">-1</span>==sz<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=g[u].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> rsum=<span class="built_in">que</span>(rp[g[u][mid]]);</span><br><span class="line">        <span class="keyword">if</span>(rsum!=lsum) r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> rsum=<span class="built_in">que</span>(rp[g[u][l]]);</span><br><span class="line">    <span class="keyword">return</span> rsum-lsum==sz<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u:q)&#123;</span><br><span class="line">        <span class="built_in">add</span>(lp[u],<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u:q)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(u,q.<span class="built_in">size</span>()))&#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u:q)&#123;</span><br><span class="line">        <span class="built_in">add</span>(lp[u],<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (cnt+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> q,m,x,y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        h[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        h[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;qu;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">        qu.<span class="built_in">resize</span>(m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;qu[j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">cal</span>(qu));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>深信服 秋招 2023.09.20 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Shenxinfu-20230920/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Shenxinfu-20230920/</id>
    <published>2023-09-25T05:19:33.000Z</published>
    <updated>2023-09-25T05:19:33.906Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="馍馍检测病毒">1、馍馍检测病毒</h1><p>馍馍发现了一种新型网络病毒，可以隐藏在图片中，图片可以简单的看成一个<span class="math inline">\(N\times N\)</span>的矩阵。</p><p>这个矩阵每个格子要么是白，用字符<code>'.'</code>表示，要么是黑，用字符<code>'#'</code>表示。</p><p>经过馍馍的分析，如果一张图片中包含一个特殊的<span class="math inline">\(M\timesM\)</span>的矩阵，那么这张图片可能包含病毒。我们称<span class="math inline">\(M\timesM\)</span>的矩阵为“馍馍来检测病毒的超生逼特征矩阵”。</p><p>现在告诉你一个<span class="math inline">\(N\timesN\)</span>的图片矩阵，和一个<span class="math inline">\(M\timesM\)</span>的“馍馍来检测病毒的超生逼特征矩阵”。</p><p>你需要判断该图片是否包含病毒。即"馍馍来检测病毒的超牛逼特征矩阵"通过平移可以完全重合在图片中的一个子矩阵里。</p><h2 id="输入">输入</h2><p>第一行一个整数<span class="math inline">\(T(1\le T\le5)\)</span>，表示测试数据的组数。</p><p>对于每组测试数据，第一行两个整数<span class="math inline">\(N,M(1\leN,M\le 50)\)</span>。</p><p>接下来<span class="math inline">\(N\)</span>行，每行<span class="math inline">\(N\)</span>个字符，用来描述待判断的图片A。</p><p>接下<span class="math inline">\(来\)</span>M行，每行<span class="math inline">\(M\)</span>个字符，用来描述“馍馍来检测病毒的超牛逼特征矩阵”。</p><h2 id="输出">输出</h2><p>共<span class="math inline">\(T\)</span>行，对于每组测试数据，如果包含，输出<code>"Yes"</code>，否则输出<code>"No"</code>(不包括引号)。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">2</span><br><span class="line">3 2</span><br><span class="line">#.#</span><br><span class="line">.#.</span><br><span class="line">#.#</span><br><span class="line">#.</span><br><span class="line">.#</span><br><span class="line">4 1</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>我们只需要枚举原矩阵的每个格子作为模板的左上角即可，然后再一一和模板矩阵比对即可完成。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">54</span>;</span><br><span class="line"><span class="type">char</span> s[N][N],t[N][N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x+m<span class="number">-1</span>&lt;n;x++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>;y+m<span class="number">-1</span>&lt;n;y++)&#123;</span><br><span class="line">            <span class="type">int</span> ok=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m&amp;&amp;ok;i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m&amp;&amp;ok;j++)</span><br><span class="line">                    <span class="keyword">if</span>(s[x+i][y+j]!=t[i][j]) ok=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(ok) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="built_in">solve</span>()?<span class="string">&quot;Yes&quot;</span>:<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="sxf序数">2、SXF序数</h1><p>一个<span class="math inline">\(N\)</span>位的正整数，如果把它的各个数位重新排列，则可以得到一些新的<span class="math inline">\(N\)</span>位正整数。</p><p>如果原数在所有的新数中是第<span class="math inline">\(K\)</span>大的（降序排序的第<span class="math inline">\(K\)</span>个）则称原数的SXF序数为<span class="math inline">\(K\)</span>。</p><p>例如，一个<span class="math inline">\(4\)</span>位数<span class="math inline">\(7225\)</span>，把它的各个数位重新排列，得到的新的<span class="math inline">\(4\)</span>位数中，最大的是<span class="math inline">\(7522\)</span>，第二大的是<span class="math inline">\(7252\)</span>，第三大的就是原数<span class="math inline">\(7225\)</span>，所以<span class="math inline">\(7225\)</span>的SXF序数为<span class="math inline">\(3\)</span>。</p><p>现在给定一个正整数<span class="math inline">\(a\)</span>，请计算出它的SXF序数。</p><h2 id="输入-1">输入</h2><p>第一行是一个正整数<span class="math inline">\(T(1\leT\le10^4)\)</span>，表示接下来有<span class="math inline">\(T\)</span>组测试数据。</p><p>接下来是各组测试数据。</p><p>每组测试数据只有一行，该行仅有一个正整数<span class="math inline">\(a(1\le a\le10^9)\)</span>，表示给定的正整数。</p><h2 id="输出-1">输出</h2><p>对于每组测试数据输出一行，仅有一个整数，表示<span class="math inline">\(q\)</span>的SXF序数。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">7225</span><br><span class="line">65421</span><br><span class="line">123</span><br><span class="line">1024</span><br><span class="line">365895456</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">6</span><br><span class="line">18</span><br><span class="line">28149</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>前置知识：假设现在有<span class="math inline">\(m\)</span>类元素，第<span class="math inline">\(i\)</span>类一共有<span class="math inline">\(c_i\)</span>个，那么这些元素组成的<strong>不同</strong>的排列数量为<span class="math inline">\(\dfrac{(c_1+c_2+\dots+c_m)!}{c_1!\cdot c_2!\cdot\dots\cdot c_m!}\)</span>。</p><p>我们将输入的一个数<span class="math inline">\(n\)</span>视为是一个排列<span class="math inline">\(n_1,n_2,\dots,n_d\)</span>即可，为了计算比它字典序更大的排列数量，我们可以采取以下方法：首先假设排列的第一个元素<span class="math inline">\(p_1\)</span>比<span class="math inline">\(n_1\)</span>大，那么后面的元素可以随意填充，使用上面的公式就可以计算出排列的数量，枚举<span class="math inline">\(p_1\)</span>的值，其中<span class="math inline">\(p_1\)</span>大于<span class="math inline">\(n_1\)</span>。计算完成后，将<span class="math inline">\(n_1\)</span>填入<span class="math inline">\(p_1\)</span>，接下来对<span class="math inline">\(p_2\)</span>做类似的操作（我们这时忽略第<span class="math inline">\(1\)</span>个位置）：枚举<span class="math inline">\(p_2\)</span>填入的元素，其中<span class="math inline">\(p_2&gt;n_2\)</span>，并使用上面的公式统计排列数……一直到第<span class="math inline">\(d\)</span>位完成。</p><p>最终，我们统计出了字典序比<span class="math inline">\(n_1,n_2,\dots,n_d\)</span>大的排列数量，再加上<span class="math inline">\(1\)</span>就是题目中所提到的SXF序数。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fac[<span class="number">14</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cal_per</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;a)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> den=<span class="number">1</span>,s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x:a)&#123;</span><br><span class="line">        den*=fac[x];</span><br><span class="line">        s+=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num=fac[s];</span><br><span class="line">    <span class="keyword">return</span> num/den;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;d,<span class="built_in">c</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> m=n;m;m/=<span class="number">10</span>)&#123;</span><br><span class="line">        d.<span class="built_in">push_back</span>(m%<span class="number">10</span>);</span><br><span class="line">        ++c[m%<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=d.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> w=d[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=w+<span class="number">1</span>;j&lt;<span class="number">10</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c[j]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                --c[j];</span><br><span class="line">                ans+=<span class="built_in">cal_per</span>(c);</span><br><span class="line">                ++c[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        --c[w];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">11</span>;i++)</span><br><span class="line">        fac[i]=fac[i<span class="number">-1</span>]*i;</span><br><span class="line">    <span class="type">int</span> T,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">solve</span>(n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="cwpp平台告警">3、CWPP平台告警</h1><p>深信服CWPP平台的告警事件管理页面可以按照时间顺序或者告警等级筛选用户所关注的安全事件。现在深信服CWPP平台上已经管理了<span class="math inline">\(N\)</span>台主机，主机编号从<span class="math inline">\(1\)</span>到<span class="math inline">\(N\)</span>。这些主机根据运行的业务不同，各自的安全等级<span class="math inline">\(s_i\)</span>都不相同，举例来说，作为内网网关主机的安全等级就高于作为外部公开资源数据库的主机。每一台主机还有一个安全威胁评分<span class="math inline">\(v_i\)</span>，<span class="math inline">\(v_i\)</span>的值越大，主机就越不安全。</p><p>为了方便运维人员，深信服CWPP平台拥有筛选管理主机并优先展示高安全等级主机的功能。</p><p>具体来讲，用户可以指定一个告警闯值水位线<span class="math inline">\(h\)</span>，筛选出威胁评分高于该闽值水位线的主机，即筛选出<span class="math inline">\(h\lev_i\)</span>的主机。然后为了方便用户查看最关注的高安全等级主机，深信服CWPP平台在筛选后还会将安全等级<span class="math inline">\(s_i\)</span>最高的主机展示到第一条告警的位置。</p><p>虽然主机的安全等级可以在系统运行前就进行配置，但是主机的安全威胁评分<span class="math inline">\(v_i\)</span>是实时进行更新和维护的。</p><p>所以要求你的算法具有可维护性，即需要支持对于<span class="math inline">\(M\)</span>次连续操作（共两种操作类型，详见下文），既可以随时修改某一台主机<span class="math inline">\(x\)</span>的安全威胁评分<span class="math inline">\(v_x\)</span>，又可以随时基于不同的告警值水位线<span class="math inline">\(h\)</span>进行查询。</p><p>现在给你这<span class="math inline">\(N\)</span>台主机安全等级<span class="math inline">\(s_i\)</span>以及初始的安全威胁评分<span class="math inline">\(v_i\)</span>。请你设计一个算法支持这<span class="math inline">\(M\)</span>次连续操作。</p><h2 id="输入-2">输入</h2><p>第一行输入两个正整数<span class="math inline">\(N,M(1\le N,M\le10^5)\)</span>分别表示深信服CWPP平台上保护主机的数目<span class="math inline">\(N\)</span>和进行操作的次数<span class="math inline">\(M\)</span>。</p><p>接下来<span class="math inline">\(N\)</span>行，输入两个正整数<span class="math inline">\(s_i,u_i(1 \le s_i,v_i\le 10^9)\)</span>表示第<span class="math inline">\(i\)</span>台主机安全等级<span class="math inline">\(s_i\)</span>以及初始的安全威胁评分<span class="math inline">\(v_i\)</span>，保证安全等级<span class="math inline">\(s_i\)</span>各不相同。</p><p>接下来<span class="math inline">\(M\)</span>行，输入若干个操作，对于每个操作首先输入一个操作类型<span class="math inline">\(op\)</span>（<span class="math inline">\(op\)</span>为<span class="math inline">\(1\)</span>或<span class="math inline">\(2\)</span>）。</p><p>当<span class="math inline">\(op\)</span>的值为<span class="math inline">\(1\)</span>时，表示进行查询操作，此时还需要继续输入一个参数<span class="math inline">\(h(1\le h\le10^9)\)</span>，表示该次查询的告警闯值水位线。</p><p>当<span class="math inline">\(op\)</span>的值为<span class="math inline">\(2\)</span>时，表示进行修改操作，此时还需要继续输入两个参数<span class="math inline">\(x,v_x(1\le x\le N, 1\le v_x\le10^9)\)</span>，表示需要将第<span class="math inline">\(x\)</span>台主机的安全威胁评分改为<span class="math inline">\(v_x\)</span>。</p><p>输入保证，至少进行一次查询操作。</p><ul><li><span class="math inline">\(1\le N,M\le 10^5\)</span></li><li><span class="math inline">\(1\le s_i,v_i\le 10^9\)</span></li><li><span class="math inline">\(1\le h\le 10^9\)</span></li><li><span class="math inline">\(1\le x\le N\)</span></li></ul><h2 id="输出-2">输出</h2><p>对于每一次查询操作，输出评分超过阈值水位线的最高安全等级机器的编号。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">10 7</span><br><span class="line">10 3</span><br><span class="line">9 5</span><br><span class="line">8 9</span><br><span class="line">7 6</span><br><span class="line">6 10</span><br><span class="line">5 8</span><br><span class="line">4 7</span><br><span class="line">3 1</span><br><span class="line">2 2</span><br><span class="line">1 4</span><br><span class="line">1 10</span><br><span class="line">1 9</span><br><span class="line">1 8</span><br><span class="line">1 1</span><br><span class="line">1 99</span><br><span class="line">2 8 100</span><br><span class="line">1 99</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">-1</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>这题的做法比较麻烦，因为它涉及到了动态修改，需要一些数据结构来操作。</p><p>这里我们选择了使用支持单点修改的线段树，它支持在<span class="math inline">\(O(\logn)\)</span>的时间内对数组的元素进行修改和求解区间最大值。</p><p>我们首先对所有节点机器按照风险等级进行排序，接下来依据排序后的结果初始化线段树。对于题目的两种操作：</p><ol type="1"><li>每次修改操作则是将对应位置的机器的风险分数直接修改即可，线段树可以直接更新。</li><li>对于每次查询操作，我们考虑对后缀进行二分，也就是找到一个最短的后缀，其区间最大值至少为<span class="math inline">\(h\)</span>，那么这时这个后缀的第一个机器恰好就是所求机器，将它映射回自身的编号即可。</li></ol><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l[N&lt;&lt;<span class="number">2</span>],r[N&lt;&lt;<span class="number">2</span>],mx[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> rs p&lt;&lt;1|1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> tl,<span class="type">int</span> tr)</span></span>&#123;</span><br><span class="line">    l[p]=tl;r[p]=tr;</span><br><span class="line">    <span class="keyword">if</span>(tl==tr)&#123;</span><br><span class="line">        mx[p]=a[tl];<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(tl+tr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls,tl,mid);</span><br><span class="line">    <span class="built_in">build</span>(rs,mid+<span class="number">1</span>,tr);</span><br><span class="line">    mx[p]=<span class="built_in">max</span>(mx[ls],mx[rs]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l[p]==r[p])&#123;</span><br><span class="line">        mx[p]=x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l[p]+r[p])&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(q&lt;=mid) <span class="built_in">update</span>(ls,q,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(rs,q,x);</span><br><span class="line">    mx[p]=<span class="built_in">max</span>(mx[ls],mx[rs]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">que</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l[p]&amp;&amp;r[p]&lt;=qr) <span class="keyword">return</span> mx[p];</span><br><span class="line">    <span class="type">int</span> mid=(l[p]+r[p])&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=mid) ans=<span class="built_in">que</span>(ls,ql,qr);</span><br><span class="line">    <span class="keyword">if</span>(qr&gt;mid) ans=<span class="built_in">max</span>(ans,<span class="built_in">que</span>(rs,ql,qr));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> s[N],v[N],id[N],pos[N],n,q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">que_id</span><span class="params">(<span class="type">int</span> h)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">que</span>(<span class="number">1</span>,<span class="number">1</span>,n)&lt;h) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=n;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">que</span>(<span class="number">1</span>,mid,n)&gt;=h) l=mid;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id[l];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;s[i],&amp;v[i]);</span><br><span class="line">        id[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(id+<span class="number">1</span>,id+n+<span class="number">1</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> s[x]&lt;s[y];&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        pos[id[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        a[pos[i]]=v[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="type">int</span> op,x,y,h;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;h);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">que_id</span>(h));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>,pos[x],y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>蚂蚁集团 秋招 2023.09.19 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Mayijituan-20230919/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Mayijituan-20230919/</id>
    <published>2023-09-25T05:19:31.000Z</published>
    <updated>2023-09-25T05:19:31.645Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="最优化存储四">1、最优化存储（四）</h1><p>支付宝服务亿级消费者，每个支付宝的用户有自己独特的信息，假设每个会员存储的成本为<span class="math inline">\(a_i\)</span>，现在有<span class="math inline">\(n\)</span>个会员，和一块存储容器<span class="math inline">\(m\)</span>，希望用该容器存储更多的会员信息；</p><p>存储优化是个相当复杂的过程，为了简化问题，存储规则如下：</p><p>每个会员的存储成本可以用长度<span class="math inline">\(a_i\)</span>的线段表示。存储容器一块，可以用一段线段<span class="math inline">\(m\)</span>表示。</p><p>存储容器有个特性，如果会员<span class="math inline">\(i\)</span>存储在容器中间位置，存储成本为<span class="math inline">\(a_i\)</span>本身，但是线段容器两端有存储压缩技术，存储在靠两端位置的会员存储成本可以压缩到一半，即<span class="math inline">\(a_i/2\)</span>，而且每个会员只能压缩一次。</p><p>现在<span class="math inline">\(n\)</span>个会员，每个会员存储成本为<span class="math inline">\(a_i\)</span>，以及有一块存储资源，希望你做存储优化，使用尽可能小的存储容器存储下所有会员的信息。</p><h2 id="输入">输入</h2><p>第一行输入一个正整数<span class="math inline">\(n\)</span>，代表会员的数量。 第二行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(a_i\)</span>，代表每个会员信息的大小。</p><ul><li><span class="math inline">\(1\le n \le 10^5\)</span></li><li><span class="math inline">\(2 \le a_i\le 10^9\)</span></li><li>保证<span class="math inline">\(a_i\)</span>是偶数。</li></ul><h2 id="输出">输出</h2><p>一个正整数，代表使用的存储容器大小的最小值。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">2 4 4 8 2</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">14</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">将第三个、第四个会员放在两端即可。使用一个大小为14的容器即可存储全部会员信息。</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>按照贪心的思想，只需要将最大的两个放在两端，其余的放在中间即可，节省的空间将是最大的。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100004</span>],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">    ll ans=a[n<span class="number">-1</span>]/<span class="number">2</span>+a[n]/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        ans+=a[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小红合并数组">2、小红合并数组</h1><p>小红有一个长度为<span class="math inline">\(n\)</span>的数组，每次操作她可以选择一个<span class="math inline">\(i\)</span>，将<span class="math inline">\(a_i\)</span>加到<span class="math inline">\(a_{i-1}\)</span>或者<span class="math inline">\(a_{i+1}\)</span> (如果<span class="math inline">\(i-1\)</span>或者<span class="math inline">\(i+1\)</span>在下标范围内)，请问最少需要多少次操作，可以使数组的所有元素相等。</p><h2 id="输入-1">输入</h2><p>一行一个整数<span class="math inline">\(n\)</span>，表示数组的长度。</p><p>接下来一行<span class="math inline">\(n\)</span>个整数<span class="math inline">\(a_1,a_2,\dots, a_n\)</span>表示数组的初始值。</p><ul><li><span class="math inline">\(1\le n \le 10^3\)</span></li><li><span class="math inline">\(0 \le a_i \le 10^4\)</span></li></ul><h2 id="输出-1">输出</h2><p>输出一个整数，表示最少的操作次数。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">1 4 2 3 5</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">第一次操作，将a2加到a1，数组变为[5,2,3,5]。</span><br><span class="line">第二次操作，将a2加到a3，数组变为[5,5,5]。</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>更具体的说，这种操作是将相邻的两个数进行合并。令<span class="math inline">\(\displaystyle{s_i=\sum_{j=1}^ia_i,s_0=0}\)</span>表示数组<span class="math inline">\(a\)</span>的前缀和。如果最终数组元素都相等，假设这些元素都是<span class="math inline">\(x\)</span>，最终的长度为<span class="math inline">\(m(m\le n)\)</span>，那么必定满足<span class="math inline">\(x\cdot m=s_n\)</span>。</p><p>因此，我们可以枚举<span class="math inline">\(s_n\)</span>所有不超过<span class="math inline">\(n\)</span>的因子<span class="math inline">\(d\)</span>，那么说明<span class="math inline">\(d\)</span>是最终数组可能的长度，<span class="math inline">\(s_n/d\)</span>是最终数组的每个元素。</p><p>在前缀和的角度来看，合并操作仅仅是删除了<span class="math inline">\(s_1,s_2,\dots,s_{n-1}\)</span>中的某些元素。因此，令<span class="math inline">\(x=s_n/d\)</span>，我们只需要查看<span class="math inline">\(x,2x,\dots,dx\)</span>是否为<span class="math inline">\(s_1,s_2,\dots,s_n\)</span>的一个子序列即可。如果是，那么找到这样最大的<span class="math inline">\(d\)</span>，并返回最小操作数<span class="math inline">\(n-d\)</span>。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1004</span>;</span><br><span class="line"><span class="type">int</span> a[N],s[N],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m=s[n];</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;div;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m%i==<span class="number">0</span>)&#123;</span><br><span class="line">            div.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> d:div)&#123;</span><br><span class="line">        <span class="type">int</span> w=m/d,c=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==c*w)&#123;</span><br><span class="line">                ++c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c&gt;d)&#123;</span><br><span class="line">            ans=n-d;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小红的w五元组">3、小红的w五元组</h1><p>小红拿到了一个数组<span class="math inline">\(a_1,a_2,\dots,a_n\)</span>，她想知道有多少组<span class="math inline">\((i,j,k,h,l)\)</span>为"w五元组"：</p><p>第一、三、五个数相等。第二个数和第四个数相等，且第一个数大于第二个数。用数学语言描述：</p><ul><li><span class="math inline">\(1\le i&lt; j&lt; k&lt; h&lt; l\len\)</span></li><li><span class="math inline">\(a_i=a_k=a_l\)</span>且<span class="math inline">\(a_j=a_h\)</span>且<span class="math inline">\(a_i=a_j\)</span></li></ul><h2 id="输入-2">输入</h2><p>第一行输入一个正整数<span class="math inline">\(n\)</span>，代表数组的元素个数。</p><p>第二行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(a_i\)</span>，代表小红拿到的数组。</p><ul><li><span class="math inline">\(5\le n,a_i\le 3000\)</span></li></ul><h2 id="输出-2">输出</h2><p>w五元组的数量。由于答案可能太大，请对<span class="math inline">\(10^9+7\)</span>取模后输出。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">7</span><br><span class="line">3 1 3 1 3 1 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">6个w五元组分别为（下标表示）：</span><br><span class="line">(1,2,3,4,5)</span><br><span class="line">(1,2,3,4,7)</span><br><span class="line">(1,2,3,6,7)</span><br><span class="line">(1,2,5,6,7)</span><br><span class="line">(1,4,5,6,7)</span><br><span class="line">(3,4,5,6,7)</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>我们枚举原数组中两个不同的数<span class="math inline">\(x,y(x&gt;y)\)</span>，并且将要么是<span class="math inline">\(x\)</span>，要么是<span class="math inline">\(y\)</span>的这一些元素重新组成一个相对顺序不变的子序列，并将所有<span class="math inline">\(x\)</span>替换成<span class="math inline">\(1\)</span>，将<span class="math inline">\(y\)</span>替换成<span class="math inline">\(0\)</span>，那么我们得到了一个01比特序列<span class="math inline">\(b\)</span>，假设其长度为<span class="math inline">\(m\)</span>。我们将这个问题转化成了：<span class="math inline">\(b\)</span>中有多少个子序列是<span class="math inline">\(c=[1,0,1,0,1]\)</span>？</p><p>这是一个经典的动态规划问题，令<span class="math inline">\(f(i,j)(1\lei\le 5,1\le j\le m)\)</span>以<span class="math inline">\(b-j\)</span>为最后一个元素的子序列，有多少个是<span class="math inline">\(c_1,c_2,\dots,c_i\)</span>。我们不难写出<span class="math inline">\(f(i,j)\)</span>的状态转移方程：</p><p><span class="math inline">\(f(i,j)= \left \{\begin{aligned}  &amp;1&amp; &amp; \text{if}\quad i=1\land b_j=c_1 \\  &amp;\sum_{k=1}^{j-1}f(i-1,k) &amp; &amp; \text{if}\quad i&gt;1\land b_j=c_i \\  &amp;0 &amp;&amp; \text{if}\quad b_j\neq c_i \\ \end{aligned}\right.\)</span></p><p>其中，方程第二行表示对于所有<span class="math inline">\(f(i-1,k)\)</span>满足的序列，都添加一个元素<span class="math inline">\(b_j\)</span>，那么就变成了<span class="math inline">\(f(i,j)\)</span>中满足的子序列。</p><p>因此，最终答案为<span class="math inline">\(\displaystyle{\sum_{j=1}^mf(5,j)}\)</span>。我们可以用<span class="math inline">\(O(m)\)</span>的时间对这个问题进行求解。</p><p>回到原问题，我们枚举一对对不同的<span class="math inline">\((x,y)\)</span>，并将它们转化成一个01比特序列可以在<span class="math inline">\(O(m)\)</span>时间内完成（因为这里只需要合并两个有序列表），由于不同的元素都会被组合一次，加上每次求解时都是线性时间的复杂度<span class="math inline">\(O(m)\)</span>，因此原问题的时间复杂度为<span class="math inline">\(O(n^2)\)</span>，足够完成。</p><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3004</span>,INF=<span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> n,x;</span><br><span class="line">ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;a,vector&lt;<span class="type">int</span>&gt;&amp;b)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>,q=<span class="number">0</span>;!(a[p]==INF&amp;&amp;b[q]==INF);)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[p]&lt;b[q]) v.<span class="built_in">push_back</span>(<span class="number">0</span>),p++;</span><br><span class="line">        <span class="keyword">else</span> v.<span class="built_in">push_back</span>(<span class="number">1</span>),q++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">5</span>,m=v.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt;<span class="built_in">f</span>(n,<span class="built_in">vector</span>&lt;ll&gt;(m));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[j]==<span class="number">0</span>) f[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        ll tp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[j]==(i&amp;<span class="number">1</span>)) f[i][j]=tp;</span><br><span class="line">            tp=(tp+f[i<span class="number">-1</span>][j])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">        sum=(sum+f[n<span class="number">-1</span>][j])%mod;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt;mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        mp[x].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;ls;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[k,v]:mp)&#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(INF);</span><br><span class="line">        ls.<span class="built_in">emplace_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ls.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            ans+=<span class="built_in">solve</span>(ls[i],ls[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>阿里淘天 秋招 2023.09.20 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Alitaotian-20230920/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Alitaotian-20230920/</id>
    <published>2023-09-25T05:19:29.000Z</published>
    <updated>2023-09-25T05:19:29.371Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="小红的子数组权值">1、小红的子数组权值</h1><p>小红拿到了一个数组。她定义一个连续子数组的权值为：子数组内不同元素的个数。小红想知道，权值分别为<span class="math inline">\(1,2,3,\dots,n\)</span>的子数组数量有多少个？</p><h2 id="输入">输入</h2><p>第一行输入一个正整数<span class="math inline">\(n\)</span>，代表数组的元素数量。</p><p>第二行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(a_i\)</span>，代表小红拿到的数组。</p><p><span class="math inline">\(1\le n,a_i \le 2000\)</span></p><h2 id="输出">输出</h2><p><span class="math inline">\(n\)</span>个整数，分别代表权值为<span class="math inline">\(1,2,3,\dots,n\)</span>的子数组数量。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">4</span><br><span class="line">1 2 2 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">5 4 1 0</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>这题比较简单，只需要枚举每个数组元素作为起点，然后从右开始一个个插入一个单重集合中，再统计这个集合的大小即可。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2004</span>;</span><br><span class="line"><span class="type">int</span> c[N],a[N],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt;st;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        st.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">            st.<span class="built_in">insert</span>(a[j]);</span><br><span class="line">            ++c[st.<span class="built_in">size</span>()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>,c[i], <span class="string">&quot; \n&quot;</span>[i==n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="平均数大于k的最长子序列">2、平均数大于<span class="math inline">\(k\)</span>的最长子序列</h1><p>给定<span class="math inline">\(n\)</span>个正整数组成的数组，求平均数大于<span class="math inline">\(k\)</span>的最长子序列的长度。</p><h2 id="输入-1">输入</h2><p>第一行输入两个正整数<span class="math inline">\(n\)</span>和<span class="math inline">\(k\)</span>，用空格隔开。</p><p>第二行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(a_i\)</span>，用来表示数组。</p><ul><li><span class="math inline">\(1\le n\le 200000\)</span></li><li><span class="math inline">\(1\le k,a_i \le 10^9\)</span></li></ul><h2 id="输出-1">输出</h2><p>如果不存在子序列的平均数大于<span class="math inline">\(k\)</span>，则输出<span class="math inline">\(-1\)</span>。</p><p>否则输出最长子序列的长度。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5 2</span><br><span class="line">3 1 1 2 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">取3, 1, 2, 3，平均数为2.25.</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>我们构造<span class="math inline">\(b_i=a_i-k\)</span>，那么原题目的含义就变成了在<span class="math inline">\(b\)</span>中求取一个最长的子序列，其平均值大于<span class="math inline">\(0\)</span>，也就是说其和大于<span class="math inline">\(0\)</span>。</p><p>那么问题很简单，从大到小将<span class="math inline">\(b\)</span>中的元素加入到子序列之中，直到子序列的元素之和不超过<span class="math inline">\(0\)</span>即停止。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"><span class="type">int</span> a[N],n,k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">sort</span>(a,a+n,<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    ll s=<span class="number">0</span>;<span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p=<span class="number">0</span>;p&lt;n;p++)&#123;</span><br><span class="line">        s+=a[p]-k;</span><br><span class="line">        <span class="keyword">if</span>(s&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小红的01问号串">3、小红的<code>01</code>问号串</h1><p>小红定义一个字符串的权值为：相邻的不同字符对数。例如<code>"10011"</code>的权值为<span class="math inline">\(2\)</span>，其中有<span class="math inline">\(2\)</span>对相邻字符不同。</p><p>小红拿到了一个<span class="math inline">\(01\)</span>串，其中有一些字符是<code>'?'</code>。设<code>'?'</code>字符的数量有<span class="math inline">\(k\)</span>个，已知共有<span class="math inline">\(2^k\)</span>种不同的<code>01</code>串(每个问号可以是<span class="math inline">\(0\)</span>或者<span class="math inline">\(1\)</span>)。小红想知道，这<span class="math inline">\(2^k\)</span>种不同的<code>01</code>串的权值之和是多少？答案对<span class="math inline">\(10^9+7\)</span>取模。</p><h2 id="输入-2">输入</h2><p>一个仅包含<code>'0', '1'</code>和<code>'?'</code>的字符串，长度不超过<span class="math inline">\(10^5\)</span>。</p><p>本题有部分用例，字符串长度不超过<span class="math inline">\(20\)</span>。</p><h2 id="输出-2">输出</h2><p>最终的权值之和对<span class="math inline">\(10^9+7\)</span>取模的值。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">01?</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">&quot;011&quot;的权值为1，&quot;010&quot;的权值为2。权值和为3。</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>我们只考虑相邻一对字符串所做出的贡献值。</p><ul><li><p>假设这一对相邻的字符串是<code>01</code>或者是<code>10</code>，那么由于这个字符串有<span class="math inline">\(2^k\)</span>个，这一相邻对做出了<span class="math inline">\(2^k\)</span>的贡献。</p></li><li><p>假设这一对相邻的字符串是<code>0?, ?0, 1?, ?1</code>中的一个，那么这一对为了做出贡献，问号必须填上不同的数字。对于另外的<span class="math inline">\(k-1\)</span>个问号，它们可以随意填充。因此这一对相邻的字符串做出了<span class="math inline">\(2^{k-1}\)</span>的贡献。</p></li><li><p>假设这一对相邻的字符串是<code>??</code>，那么这一对为了做出贡献，两个问号要么是<code>01</code>，要么是<code>10</code>，有两种填法。对于其它<span class="math inline">\(k-2\)</span>个问号，可以随意填充，因此这一对相邻的字符串做出了<span class="math inline">\(2\cdot 2^{k-2}=2^{k-1}\)</span>的贡献。</p></li><li><p>对于其余情况（即<code>00</code>和<code>11</code>），它们肯定不会做出贡献，因此忽略。</p></li></ul><p>因此，将这些贡献值累加即可得到答案。</p><h2 id="代码-2">代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line">k = s.count(<span class="string">&#x27;?&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s) - <span class="number">1</span>):</span><br><span class="line">    t = s[i:i + <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> t.count(<span class="string">&#x27;?&#x27;</span>):</span><br><span class="line">        ans += <span class="built_in">pow</span>(<span class="number">2</span>, k - <span class="number">1</span>, mod)</span><br><span class="line">    <span class="keyword">elif</span> t[<span class="number">0</span>] != t[<span class="number">1</span>]:</span><br><span class="line">        ans += <span class="built_in">pow</span>(<span class="number">2</span>, k, mod)</span><br><span class="line">ans %= mod</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>携程 秋招 2023.09.21 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Xiecheng-20230921/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Xiecheng-20230921/</id>
    <published>2023-09-22T15:37:56.000Z</published>
    <updated>2023-09-22T15:37:56.047Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="游游的排列构造">1、游游的排列构造</h1><p>游游拿到了一个排列<span class="math inline">\(a\)</span>。她希望你构造一个长度相等的排列，满足<span class="math inline">\(a_i\neq b_i\)</span>且<span class="math inline">\(b\)</span>的字典序尽可能小。你能帮帮她吗？</p><p>所谓排列，即长度为<span class="math inline">\(n\)</span>的数组，其中<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>每个正整数都恰好出现了<span class="math inline">\(1\)</span>次。</p><p>排列的字典序定义如下：两个排列的字典序比较，将比较它们第一个不相等的元素，该元素小的那个排列字典序更小。例如<span class="math inline">\([2,1,3]\)</span>的字典序小于<span class="math inline">\([2,3,1]\)</span>。</p><h2 id="输入">输入</h2><p>第一行输入一个正整数<span class="math inline">\(n\)</span>，代表排列<span class="math inline">\(a\)</span>的长度。</p><p>第二行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(a_i\)</span>，代表游游拿到的排列。</p><ul><li><span class="math inline">\(2 \le n \le 10^5\)</span></li></ul><h2 id="输出">输出</h2><p><span class="math inline">\(n\)</span>个正整数<span class="math inline">\(b_i\)</span>，代表构造的排列。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2 3 1</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>我们先按照贪心算法构造出一个排列：即<span class="math inline">\(\forall i\in[1,n)\)</span>，如果<span class="math inline">\(a_i\)</span>和剩余未被填入<span class="math inline">\(b\)</span>的最小数相等，那么<span class="math inline">\(b_i\)</span>填入次小数，否则填入次小数。并且<span class="math inline">\(b_n\)</span>填入剩下的那一个数中。</p><p>可见，这种填入方式对<span class="math inline">\(b_n\)</span>可能不满足题目要求。可以发现，只有<span class="math inline">\(a_n=n\)</span>的时候才有可能发生这种情况，因为<span class="math inline">\(1,2\)</span>都只有可能在位置<span class="math inline">\(1,2\)</span>填入，<span class="math inline">\(3\)</span>只有有可能在<span class="math inline">\(2,3\)</span>位置填入，<span class="math inline">\(4\)</span>只有可能在<span class="math inline">\(3,4\)</span>位置填入……<span class="math inline">\(n-1\)</span>只有可能在<span class="math inline">\(n-2,n-1\)</span>填入。</p><p>因此，如果按照上面的方式构造出来的排列是不对的，那么我们只需要求一个字典序和它相邻且比它大的一个排列即可，这时我们只需要对前一个求出来的排列，交换<span class="math inline">\(b_{n-1},b_n\)</span>即可。因为<span class="math inline">\(a_n=n\)</span>，所以<span class="math inline">\(a_{n-1}\neq n\)</span>，并且交换后，有<span class="math inline">\(b_n\neqn,b_{n-1}=n\)</span>，那么这就是一个满足题意得最小字典序排列。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        b[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i]==a[i])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(b[i],b[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a[n]==b[n])&#123;</span><br><span class="line">        <span class="built_in">swap</span>(b[n],b[n<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>,b[i], <span class="string">&quot; \n&quot;</span>[i==n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小红的字符串">2、小红的字符串</h1><p>小红拿到了一个字符串<span class="math inline">\(s\)</span>。她可以进行任意次以下操作作：</p><p>选择字符串中的一个字母<span class="math inline">\(ch_1\)</span>和任意一个字母<span class="math inline">\(ch_2\)</span>（<span class="math inline">\(ch_2\)</span>可以不在字符串中出现），将字符串<span class="math inline">\(s\)</span>中的所有<span class="math inline">\(ch_1\)</span>变成<span class="math inline">\(ch_2\)</span>。小红想知道，自己能否通过一些操作将字符串<span class="math inline">\(s\)</span>变成<span class="math inline">\(t\)</span>？</p><h2 id="输入-1">输入</h2><p>第一行输入一个正整数<span class="math inline">\(q\)</span>，代表查询次数。</p><p>对于每次查询输入2行：</p><p>第一行输入一个字符串<span class="math inline">\(s\)</span>。</p><p>第二行输入一个字符串<span class="math inline">\(t\)</span>。</p><ul><li><span class="math inline">\(1\le q\le 10\)</span></li></ul><p>保证<span class="math inline">\(s\)</span>和<span class="math inline">\(t\)</span>的长度相同，且均由小写字母组成，长度不超过<span class="math inline">\(10000\)</span>。</p><h2 id="输出-1">输出</h2><p>输出<span class="math inline">\(q\)</span>行，每行输出一个字符串代表答案。如果可以把<span class="math inline">\(s\)</span>变成<span class="math inline">\(t\)</span>，则输出<code>Yes</code>，否则输出<code>No</code>。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">ab</span><br><span class="line">ba</span><br><span class="line">abc</span><br><span class="line">aaa</span><br><span class="line">aaaa</span><br><span class="line">abcd</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>如果字符串<span class="math inline">\(t\)</span>使用了全部的<span class="math inline">\(26\)</span>个字母，那么<span class="math inline">\(s\)</span>只能和<span class="math inline">\(t\)</span>相等，否则每做一次操作，<span class="math inline">\(s\)</span>最多只会有<span class="math inline">\(25\)</span>个不同的字母，它是没办法和<span class="math inline">\(t\)</span>相同的。</p><p>否则，对于任意两对下标<span class="math inline">\((i,j)\)</span>，如果<span class="math inline">\(s_i=s_j\)</span>，那么必须有<span class="math inline">\(t_i=t_j\)</span>。因为每一次操作都要将和<span class="math inline">\(s_i\)</span>相同的字母进行变换，变换后也一定是相同的，因此如果<span class="math inline">\(t_i\neqt_j\)</span>，那么这种情况是不可能达到的。</p><p>最后，由于<span class="math inline">\(t\)</span>不超过<span class="math inline">\(25\)</span>个字母，我们对<span class="math inline">\(s\)</span>进行变化时，可以先将其中一个字母<span class="math inline">\(c\)</span>变成<span class="math inline">\(t\)</span>中不存在的字母，然后再将其余<span class="math inline">\(t\)</span>包含<span class="math inline">\(c\)</span>的位置进行变换即可，这样不会造成混淆。因此这时一定会成功。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    map&lt;<span class="type">char</span>,vector&lt;<span class="type">int</span>&gt;&gt;mp;</span><br><span class="line">    string s,t;</span><br><span class="line">    cin&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        mp[s[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    set&lt;<span class="type">char</span>&gt;<span class="built_in">st</span>(t.<span class="built_in">begin</span>(),t.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span>(st.<span class="built_in">size</span>()==<span class="number">26</span>) <span class="keyword">return</span> s==t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[k,v]:mp)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+<span class="number">1</span>&lt;v.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t[v[i+<span class="number">1</span>]]!=t[v[i]]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="built_in">solve</span>()?<span class="string">&quot;Yes&quot;</span>:<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="游游的字母矩阵">3、游游的字母矩阵</h1><p>游游拿到了一个<span class="math inline">\(n\)</span>行<span class="math inline">\(m\)</span>列的字母矩阵，矩阵中所有字符都是小写字母。</p><p>游游想知道，有多少个子矩阵满足，每个字母最多出现一次？</p><h2 id="输入-2">输入</h2><p>第一行输入两个正整数<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>，代表矩阵的大小。接下来的<span class="math inline">\(n\)</span>行，每行输入一个长度为<span class="math inline">\(m\)</span>的、仅包含小写字母的字符串。</p><ul><li><span class="math inline">\(1\le n,m \le 500\)</span></li></ul><h2 id="输出-2">输出</h2><p>每种字母只出现一次的子矩阵数量。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">2 3</span><br><span class="line">aad</span><br><span class="line">abc</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">13</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">除了满足条件的大小为1的六个子矩阵外，还有以下7个:</span><br><span class="line">.a.     ..d     .ad     ...     .ad     ...     ...</span><br><span class="line">.b.     ..c     ...     .bc     .bc     abc     ab.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>由于英语字母只有<span class="math inline">\(26\)</span>个，因此这里的子矩阵的面积（即长和宽之积）不超过<span class="math inline">\(26\)</span>。我们这里可以直接枚举每个子矩阵进行判断。</p><p>因此，我们首先枚举矩阵中的每个元素作为所求子矩阵的左上角，接下来枚举这个子矩阵的宽度<span class="math inline">\(k\)</span>，然后向右边拓展边计数即可。</p><p>这里为了保证不会超时，采用了如下措施：</p><ol type="1"><li>使用位运算记录哪些字母被使用。</li><li>边判断边计数，避免判断一个大矩阵是否合法时，重新开始判断。</li><li>发现矩阵不合法及时退出循环，因为包含这个子矩阵的子矩阵一定也是不合法的。</li></ol><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[<span class="number">504</span>][<span class="number">504</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            s[i][j]-=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=n;x++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">1</span>;y&lt;=m;y++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">26</span>&amp;&amp;x+k<span class="number">-1</span>&lt;=n;k++)&#123;</span><br><span class="line">                <span class="type">int</span> st=<span class="number">0</span>;</span><br><span class="line">                <span class="type">bool</span> ok=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;y+j<span class="number">-1</span>&lt;=m&amp;&amp;ok;j++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k&amp;&amp;ok;i++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(st&gt;&gt;s[x+i<span class="number">-1</span>][y+j<span class="number">-1</span>]&amp;<span class="number">1</span>) ok=<span class="number">0</span>;</span><br><span class="line">                        st|=<span class="number">1</span>&lt;&lt;s[x+i<span class="number">-1</span>][y+j<span class="number">-1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(ok) ++ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="游游改数组">4、游游改数组</h1><p>游游拿到了一个正整数，她准备恰好修改其中<span class="math inline">\(k\)</span>位，使得该正整数变成<span class="math inline">\(75\)</span>的倍数。你能帮游游求出有多少种修改方案吗？修改后，仍是正整数，且不允许存在前导零，答案请对<span class="math inline">\(10^9+7\)</span>取模。</p><h2 id="输入-3">输入</h2><p>第一行输入一个正整数<span class="math inline">\(n\)</span>。</p><p>第二行输入一个正整数<span class="math inline">\(k\)</span>。</p><ul><li><span class="math inline">\(1 \le n \le 10^{1000}\)</span></li><li><span class="math inline">\(1\le k\le 1000\)</span></li></ul><h2 id="输出-3">输出</h2><p>修改的方案数，对<span class="math inline">\(10^9+7\)</span>取模。</p><h2 id="样例-3">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">355</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">9</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">共有150、225、300、450、525、675、750、825、975这9种方案。</span><br></pre></td></tr></table></figure><h2 id="解答-3">解答</h2><p>如果一个数是<span class="math inline">\(75\)</span>的倍数，那么它一定满足如下特征：</p><ul><li>所有数位之和是<span class="math inline">\(3\)</span>的倍数。</li><li>最后两位无非是<span class="math inline">\(00,25,50,75\)</span>中的一个组合。</li></ul><p>令<span class="math inline">\(m\)</span>是<span class="math inline">\(n\)</span>的位数，令<span class="math inline">\(n_i(0\le i&lt; n)\)</span>表示<span class="math inline">\(n\)</span>的从高到低的第<span class="math inline">\(i\)</span>个数位。由于最后两位是固定搭配，因此我们先只考虑第一个特征。可以知道这里可以使用动态规划来处理。令<span class="math inline">\(f(i,j,r)(0\le i\le m,0\le j\le k,0\ler&lt;3)\)</span>表示对这个数的前<span class="math inline">\(i\)</span>位修改了<span class="math inline">\(j\)</span>个位置后，所得到的数的数位之和对<span class="math inline">\(3\)</span>取模的值为<span class="math inline">\(r\)</span>的方案数。那么我们可以构造出如下转移：</p><ul><li><span class="math inline">\(1\rightarrow f(0,0,0)\)</span></li><li><span class="math inline">\(f(i,j,k)\rightarrow f(i+1,j,(k+d)\bmod3)\qquad\text{if}\qquad d=n_i\)</span></li><li><span class="math inline">\(f(i,j,k)\rightarrow f(i+1,j+1,(k+d)\bmod3)\qquad\text{if}\qquad d\neq n_i\)</span></li></ul><p>其中，第一个行的转移表示初值，一个空的数字数组没有任何数位，它的数位和是<span class="math inline">\(0\)</span>，操作次数是<span class="math inline">\(0\)</span>；第二行表示对当前位不进行修改的决策，那么增加了当前位之后，修改次数依然是<span class="math inline">\(j\)</span>，因此转移到状态<span class="math inline">\(f(i+1,j,(k+d)\bmod3)\)</span>。第三行表示对当前位进行修改，其决策<span class="math inline">\(d\)</span>有<span class="math inline">\(9\)</span>种，分别是<span class="math inline">\(\{0,1,2,\dots,9\}-\{n_i\}\)</span>，因此转移到状态<span class="math inline">\(f(i+1,j+1,(k+d)\bmod 3)\)</span>。</p><p>再加上它是<span class="math inline">\(25\)</span>倍数的，因此<span class="math inline">\(n\)</span>的最后两位必须固定成一个组合。假设第<span class="math inline">\(i\)</span>种组合的倒数第二位和第一位的数字分别是<span class="math inline">\(a_i\)</span>和<span class="math inline">\(b_i\)</span>，那么前<span class="math inline">\(m-2\)</span>位的数位之和模<span class="math inline">\(3\)</span>的值必须为<span class="math inline">\((-a_i-b_i)\bmod 3\)</span>，并且还要根据<span class="math inline">\(a_i,b_i\)</span>是否和<span class="math inline">\(n_{m-2},n_{m-1}\)</span>相同，减去相对应的修改次数。</p><p>最终，枚举每种组合并加起来，就得到了本题所需要的答案。</p><h2 id="代码-3">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1004</span>;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> f[N][N][<span class="number">3</span>],mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x+=y;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=mod) x-=mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> a[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>&#125;,b[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s %d&quot;</span>,&amp;s,&amp;k);</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        s[i]-=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-2</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> d=s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=k;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">0</span>;r&lt;<span class="number">3</span>;r++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> x=(i==<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>);x&lt;<span class="number">10</span>;x++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(x==d) <span class="built_in">add</span>(f[i+<span class="number">1</span>][j][(r+x)%<span class="number">3</span>],f[i][j][r]);</span><br><span class="line">                    <span class="keyword">else</span> <span class="built_in">add</span>(f[i+<span class="number">1</span>][j+<span class="number">1</span>][(r+x)%<span class="number">3</span>],f[i][j][r]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;n==<span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> nk=k-(s[n<span class="number">-2</span>]!=a[i])-(s[n<span class="number">-1</span>]!=b[i]),nr=(<span class="number">9</span>-a[i]-b[i])%<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(nk&gt;=<span class="number">0</span>) <span class="built_in">add</span>(ans,f[n<span class="number">-2</span>][nk][nr]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">solve</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>腾讯 秋招 2023.09.15 编程题目与题解（算法岗）</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Tengxun-20230915B/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Tengxun-20230915B/</id>
    <published>2023-09-22T15:37:53.000Z</published>
    <updated>2023-09-22T15:37:53.538Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="子序列计数">1、子序列计数</h1><p>给定一个长度为<span class="math inline">\(n\)</span>的数组，求有多少子序列满足：子序列中元素种类数<span class="math inline">\(=\)</span>子序列长度。</p><p>由于答案可能很大，请输出答案取模<span class="math inline">\(998244353\)</span>后的结果。</p><h2 id="输入">输入</h2><p>第一行一个整数<span class="math inline">\(n,1\le n\le10^5\)</span></p><p>第二行<span class="math inline">\(n\)</span>个整数，<span class="math inline">\(a_1,a_2,\dots,a_n(1\le a_i \le 10^5)\)</span></p><h2 id="输出">输出</h2><p>一行一个整数，表示答案。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">2 3 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">符合条件的子序列有（按照下标方式给出）</span><br><span class="line">&#123;1&#125;,&#123;1,2&#125;,&#123;1,3&#125;,&#123;2&#125;,&#123;3&#125;</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">1 3 4</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">符合条件的子序列有（按照下标方式给出）</span><br><span class="line">&#123;1&#125;,&#123;1,2&#125;,&#123;1,2,3&#125;,&#123;1,3&#125;,&#123;2&#125;,&#123;2,3&#125;,&#123;3&#125;</span><br></pre></td></tr></table></figure><h2 id="备注">备注</h2><p>子序列可以理解为从原数组中选择一些元素删掉（或者不删）并保持剩余元素的相对位置不变。</p><h2 id="解答">解答</h2><p>这道题意味着求出<span class="math inline">\(a\)</span>有多少个子序列，其元素各不相同。</p><p>由于元素各不相同，因此<span class="math inline">\(a\)</span>中的每个数在子序列中最多出现一次。对于不同的数而言，其出现的情况都是独立的，因此按照乘法原理，我们可以给出答案为：</p><p><span class="math display">\[\prod_{x} (c(x,a)+1)-1\]</span></p><p>其中<span class="math inline">\(c(x,a)\)</span>表示元素<span class="math inline">\(x\)</span>在<span class="math inline">\(a\)</span>出现的次数。上面的式子所表达的意思是：选择将<span class="math inline">\(x\)</span>放进子序列一共有<span class="math inline">\(c(x,a)\)</span>种方式，不将<span class="math inline">\(x\)</span>放进子序列有<span class="math inline">\(1\)</span>种方式，因此对<span class="math inline">\(x\)</span>的处理情况有<span class="math inline">\(c(x,a)+1\)</span>种。为了避免所有元素都没被放进子序列，最终答案还需要减去<span class="math inline">\(1\)</span>，即一个空子序列的情况。</p><h2 id="代码">代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>()</span><br><span class="line">c = Counter(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">mod = <span class="number">998244353</span></span><br><span class="line">ans = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> c.items():</span><br><span class="line">    ans = ans * (v + <span class="number">1</span>) % mod</span><br><span class="line">ans = (ans - <span class="number">1</span>) % mod</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="盲盲盒">2、盲盲盒</h1><p>最近盲盒活动非常火热，商家A和商家B打算进一步增加盲盒的“盲”，于是在各自的仓库，即仓库A和仓库B里面进行盲盒交换。</p><p>具体操作如下：</p><ol type="1"><li><p>首先仓库A里面有<span class="math inline">\(k\)</span>个普通盲盒以及<span class="math inline">\(1\)</span>个超珍稀盲盒，仓库B里面有<span class="math inline">\(k+1\)</span>个普通盲盒；</p></li><li><p>每次从两个仓库里面以均匀分布抽样出一个盲盒，并进行交换；经过<span class="math inline">\(n\)</span>次盲盒交换之后，超珍稀盲盒仍然在仓库A的概率为<span class="math inline">\(p/q\)</span> (最简分数)，那么<span class="math inline">\(p+q\)</span>模<span class="math inline">\(10\)</span>的数值是多少？</p></li></ol><h2 id="输入-1">输入</h2><p>第一行为测试组数<span class="math inline">\(T\)</span>，接下来有<span class="math inline">\(T\)</span>行数据，每行数据是交换次数<span class="math inline">\(n\)</span>和盲盒数量<span class="math inline">\(k\)</span>。</p><ul><li><span class="math inline">\(1&lt;n&lt;1000，1&lt;T&lt;20，1&lt;k&lt;100\)</span></li></ul><h2 id="输出-1">输出</h2><p>经过<span class="math inline">\(n\)</span>次盲盒交换之后，超珍稀盲盒仍然在仓库A的概率为<span class="math inline">\(p/q\)</span> (最简分数)，那么<span class="math inline">\(p+q\)</span>模<span class="math inline">\(10\)</span>的数值。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">4</span><br><span class="line">2 5</span><br><span class="line">2 6</span><br><span class="line">3 7</span><br><span class="line">3 9</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1</span><br><span class="line">6</span><br><span class="line">9</span><br><span class="line">9</span><br></pre></td></tr></table></figure><h2 id="备注-1">备注</h2><p>解答：若令<span class="math inline">\(X(n)\)</span>表示在<span class="math inline">\(n\)</span>次交换之后，仓库A中超珍稀盲盒的数量。那么<span class="math inline">\(X(n)\)</span>的状态空间为<span class="math inline">\(0\)</span>或者<span class="math inline">\(1\)</span>，容易得到状态转移矩阵为<span class="math inline">\(\begin{bmatrix}\dfrac{k}{k+1}&amp;\dfrac{1}{k+1}\\\dfrac{1}{k+1}&amp;\dfrac{k}{k+1}\end{bmatrix}\)</span>。令<span class="math inline">\(a=\dfrac{k}{1+k}\)</span>，可以求得<span class="math inline">\(P^n\)</span>的第一行第一列元素（即所求概率，本来超珍稀在仓库A，<span class="math inline">\(n\)</span>次操作后仍然在仓库A中的概率）为<span class="math inline">\(\dfrac{1}{2}+\dfrac{1}{2}(2a-1)^n\)</span>。另外难度在获得最简分数<span class="math inline">\(p/q\)</span>，需要用欧几里得算法及时计算最大公约数并约分，否则容易数值溢出。</p><h2 id="解答-1">解答</h2><p>根据备注，可以知道这道题的答案是<span class="math inline">\(\dfrac{(k-1)^n+(k+1)^n}{2(k+1)^n}=\dfrac{1}{2}\left(1+\dfrac{(k-1)^n}{(k+1)^n}\right)\)</span>，根据经验，这道题可以使用暴力直接过（如下面代码实现的<code>solve2</code>所示）。</p><p>接下来讲解正确做法（如下面代码实现的<code>solve1</code>）。令<span class="math inline">\(u/v=(k-1)/(k+1)\)</span>表示化简后的结果。那么可见<span class="math inline">\(\dfrac{1}{2}\cdot\dfrac{u^n+v^n}{v^n}\)</span>就是最终的概率值。此外，<span class="math inline">\(\dfrac{u^n+v^n}{v^n}\)</span>是一个最简分数。接下来考虑两种情况：</p><ul><li><p>如果<span class="math inline">\(u+v\)</span>是奇数，那么上面的分数可以写成<span class="math inline">\(\dfrac{u^n+v^n}{2v^n}\)</span>。因此这种情况的最终答案为<span class="math inline">\(((u^n\bmod 10)+(v^n\bmod 10)+(2v^n\bmod 10))\bmod10\)</span>。</p></li><li><p>如果<span class="math inline">\(u+v\)</span>是偶数，那么分母的<span class="math inline">\(2\)</span>可以进一步和分子<span class="math inline">\(u^n+v^n\)</span>进行约分，因此上面的分数可以写成<span class="math inline">\(\dfrac{(u^n+v^n)/2}{v^n}\)</span>。为了保证除法的正确性，我们先对分子对<span class="math inline">\(20\)</span>取模，然后再除以<span class="math inline">\(2\)</span>。因此这种情况的最终答案为<span class="math inline">\(\left(\dfrac{((u^n\bmod 20)+(v^n\bmod 20))\mod20}{2}+(v^n\bmod 10)\right)\bmod 10\)</span>。</p></li></ul><h2 id="代码-1">代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确做法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve1</span>(<span class="params">n, k</span>):</span><br><span class="line">    num, den = k - <span class="number">1</span>, k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        num, den = num &gt;&gt; <span class="number">1</span>, den &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (num + den) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        p = (<span class="built_in">pow</span>(num, n, <span class="number">20</span>) + <span class="built_in">pow</span>(den, n, <span class="number">20</span>)) % <span class="number">20</span> // <span class="number">2</span></span><br><span class="line">        q = <span class="built_in">pow</span>(den, n, <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = (<span class="built_in">pow</span>(num, n, <span class="number">10</span>) + <span class="built_in">pow</span>(den, n, <span class="number">10</span>)) % <span class="number">10</span></span><br><span class="line">        q = <span class="built_in">pow</span>(den, n, <span class="number">10</span>) * <span class="number">2</span> % <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> (p + q) % <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴力做法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve2</span>(<span class="params">n, k</span>):</span><br><span class="line">    f = Fraction((k + <span class="number">1</span>) ** n + (k - <span class="number">1</span>) ** n, <span class="number">2</span> * (k + <span class="number">1</span>) ** n)</span><br><span class="line">    <span class="keyword">return</span> (f.numerator + f.denominator) % <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">    n, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    <span class="built_in">print</span>(solve1(n, k))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="数组变幻">3、数组变幻</h1><p>一个长度为<span class="math inline">\(n\)</span>的数组，每秒都在发生变幻。</p><p>每一次变幻，第<span class="math inline">\(1\)</span>个位置的数字将会和第<span class="math inline">\(2\)</span>个位置的数字合并，第<span class="math inline">\(3\)</span>个位置的数字将会和第<span class="math inline">\(4\)</span>个位置的数字合并，以此类推。。</p><p>这个数组会一直变幻到只剩两个数字为止。</p><p>合并数字时，将会使得两个数字相加。例如数组<span class="math inline">\([1,2,3,4,5]\)</span>第一秒会变成<span class="math inline">\([3,7,5]\)</span>（前两个数字合并，第三和第四个数字合并，由于没有第六个数字，所以第五个数字不变）第二秒会变成<span class="math inline">\([10,5]\)</span>，此时数组中只剩两个数字，变幻结束。</p><p>小q有一个变量<span class="math inline">\(x\)</span>，初始等于<span class="math inline">\(0\)</span>。每次数组变幻后，小q会把数组的第一个元素加到<span class="math inline">\(x\)</span>上。小q希望你输出最终<span class="math inline">\(x\)</span>的值。</p><p>由于这个数组长度很大，所以小q在给你数据时采用了一种新的方式。小q总共会给出<span class="math inline">\(k\)</span>条信息，每条信息包含两个正整数 <span class="math inline">\(a,b\)</span>，表示这个数组中有一段长度为<span class="math inline">\(a\)</span>的区间，区间中所有数字均为<span class="math inline">\(b\)</span>。（详见样例）</p><p>由于答案可能很大，请输出答案对<span class="math inline">\(10^9+7\)</span>取模后的结果。</p><h2 id="输入-2">输入</h2><p>第一行给出两个正整数<span class="math inline">\(n,k\)</span>，意义如题面所示。</p><p>接下来<span class="math inline">\(k\)</span>行分别给出两个正整数<span class="math inline">\(a_i,b_i\)</span>。表示数组有<span class="math inline">\(a_i\)</span>个数字<span class="math inline">\(b_i\)</span>。注意本题保证所有<span class="math inline">\(a_i\)</span>的和为<span class="math inline">\(n\)</span>。</p><ul><li><span class="math inline">\((1\le a_i\le n \le10^{18}, 1\le b_i \le10^9, 1\le k \le10^5)\)</span></li></ul><h2 id="输出-2">输出</h2><p>输出最终<span class="math inline">\(x\)</span>的值。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5 5</span><br><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">1 5</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">13</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">初始数组为[1,2,3,4,5]</span><br><span class="line">第一次操作后，数组变成[3,7,5]，x加上3。</span><br><span class="line">第二次操作后，数组变成[10,5]，x加上10。</span><br><span class="line">最终x等于13。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">7 2</span><br><span class="line">3 1</span><br><span class="line">4 2</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">输入为3个1和4个2，即数组为[1,1,1,2,2,2,2]，第一秒变为[2,3,4,2]，第二秒变为[5,6]，最终的x等于2+5=7。</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>这题是一道模拟题，需要注意一些细节。在模拟的过程中，我们依旧使用题目中的那种对数组的表达方式，即第<span class="math inline">\(i\)</span>段元素有<span class="math inline">\(a_i\)</span>个元素<span class="math inline">\(b_i\)</span>。以下分两种情况进行讨论。</p><ol type="1"><li><p>如果<span class="math inline">\(a_i=1\)</span>，那么这时需要考虑和下一段数（如果存在的话）中的第一个进行合并。这时会产生一个段<span class="math inline">\((1,b_i+b_{i+1})\)</span>。</p></li><li><p>如果<span class="math inline">\(a_1&gt;1\)</span>，那么这一段数会产生一个新段<span class="math inline">\((\lfloor a_i/2\rfloor,2\cdotb_i)\)</span>，同时令<span class="math inline">\(a_i&#39;=a_i\bmod2\)</span>，如果<span class="math inline">\(a_i&#39;=1\)</span>，那么转为情况1继续进行，否则考虑下一段。</p></li></ol><p>由于每次变换过后，数组的元素数量都会减少一半，因此这种变换最多只会进行<span class="math inline">\(\logn\)</span>次。此外，如果两个相邻段都只有一个元素，那么这些段必定会被合并。因此，在模拟过程中，数组的总段数不会超过<span class="math inline">\(3k\)</span>。因此本题的时间复杂度为<span class="math inline">\(O(k\log n)\)</span>。</p><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> pl pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> X first</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> Y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll n,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ok</span><span class="params">(deque&lt;pl&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    ll t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[x,y]:v)&#123;</span><br><span class="line">        t+=x;</span><br><span class="line">        <span class="keyword">if</span>(t&gt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    ll a,b;</span><br><span class="line">    deque&lt;pl&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        q.<span class="built_in">push_back</span>(<span class="built_in">pl</span>(a,b));</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">ok</span>(q))&#123;</span><br><span class="line">        deque&lt;pl&gt;q2;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(q[<span class="number">0</span>].X==<span class="number">0</span>) q.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(q[<span class="number">0</span>].X==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(q.<span class="built_in">size</span>()&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">                    --q[<span class="number">1</span>].X;</span><br><span class="line">                    q2.<span class="built_in">push_back</span>(<span class="built_in">pl</span>(<span class="number">1</span>,(q[<span class="number">0</span>].Y+q[<span class="number">1</span>].Y)%mod));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> q2.<span class="built_in">push_back</span>(<span class="built_in">pl</span>(<span class="number">1</span>,q[<span class="number">0</span>].Y));</span><br><span class="line">                q.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                q2.<span class="built_in">push_back</span>(<span class="built_in">pl</span>(q[<span class="number">0</span>].X&gt;&gt;<span class="number">1</span>,(q[<span class="number">0</span>].Y&lt;&lt;<span class="number">1</span>)%mod));</span><br><span class="line">                q[<span class="number">0</span>].X&amp;=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=(ans+q2[<span class="number">0</span>].Y)%mod;</span><br><span class="line">        q=q2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="最短路">4、最短路</h1><p>初始有<span class="math inline">\(n\)</span>个点，第<span class="math inline">\(i\)</span>个点坐标为<span class="math inline">\((x_i,y_i)\)</span>，起点是第<span class="math inline">\(s\)</span>个点，终点是第<span class="math inline">\(t\)</span>个点，原本任意两点间都有一条线段代表能在两点间通行(长度为欧几里得距离)，但因为一些意外，<span class="math inline">\(s\)</span>和<span class="math inline">\(t\)</span>之间的线段被删除了，现在求<span class="math inline">\(s-t\)</span>的最短距离是多少。</p><p>其中保证<span class="math inline">\(s\neq t\)</span>。</p><p><span class="math inline">\(i,j\)</span>两点欧几里得距离即<span class="math inline">\(\sqrt{(x_i-x_j)^2+(y_i-y_j)^2}\)</span></p><h2 id="输入-3">输入</h2><p>第一行有三个正整数，依次表示有<span class="math inline">\(n\)</span>个点，以及起点<span class="math inline">\(s\)</span>和终点<span class="math inline">\(t\)</span>。</p><p>接下来<span class="math inline">\(n\)</span>行每行<span class="math inline">\(2\)</span>个整数，第<span class="math inline">\(i\)</span>行代表第个点的坐标为<span class="math inline">\(x_i,y_i\)</span>。</p><ul><li><span class="math inline">\(3 \le n \le 10^5 ,1 \le s,t \le n, 1 \lex_i,y_i \le 10^6\)</span></li></ul><h2 id="输出-3">输出</h2><p>输出一行一个数代表答案（输出四舍五入到小数点后两位）</p><h2 id="样例-3">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5 1 5</span><br><span class="line">17253 15901</span><br><span class="line">25501 15698</span><br><span class="line">28676 32041</span><br><span class="line">30711 11015</span><br><span class="line">18651 9733</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">17333.65</span><br></pre></td></tr></table></figure><h2 id="解答-3">解答</h2><p>由于每个边权都是欧几里得距离，因此这些边权满足三角形不等式。也就是说，如果存在一条路径经过了<span class="math inline">\(k\)</span>个点，那么必定存在一条更短的路径，其经过<span class="math inline">\(k-1\)</span>个点。</p><p>因此，最终答案为<span class="math inline">\(\displaystyle{\min_{1\lei\len,i\not\in\{s,t\}}\{\text{dist}(s,i)+\text{dist}(i,t)\}}\)</span>，其中<span class="math inline">\(\text{dist}(i,j)=\sqrt{(x_i-x_j)^2+(y_i-y_j)^2}\)</span>。</p><h2 id="代码-3">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line">ll x[N],y[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dis</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span></span>&#123;</span><br><span class="line">    ll dx=x[p]-x[q],dy=y[p]-y[q];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(dx*dx+dy*dy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> s,t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;n,&amp;s,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;x[i],&amp;y[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> ans=<span class="number">1e14</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==s||i==t) <span class="keyword">continue</span>;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,<span class="built_in">dis</span>(s,i)+<span class="built_in">dis</span>(t,i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="三国无双游戏">5、三国无双游戏</h1><p>牛牛最近三国演义入了迷，他时常幻想着自己是一代枭雄，坐拥城池百万，精锐无数。</p><p>然而他只能做做美梦玩玩三国无双的游戏罢了qwq。</p><p>游戏中牛牛有<span class="math inline">\(n\)</span>座城池，城池编号为<span class="math inline">\(1\simn\)</span>，由于某些城池地理位置极其重要，因此牛牛要设置一些关卡来建立防御工程。现在牛午有<span class="math inline">\(m\)</span>个工程计划，每个工程计划有两个整数<span class="math inline">\(L,R\)</span>，表示从第<span class="math inline">\(L\)</span>座城池到第<span class="math inline">\(R\)</span>座城池中，至少有一个城池被设置为关卡。</p><p>牛牛想知道，为了使得每个计划都满足，有多少中不同的设置关卡的方法？</p><p>游戏难度：<strong>保证<span class="math inline">\(m\)</span>个计划中，可能会出现相交的区间</strong>。</p><h2 id="输入-4">输入</h2><p>第一行输入两个整数<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>，其中<span class="math inline">\(n\)</span>表示城池的数量，<span class="math inline">\(m\)</span>表示工程计划的数量。</p><p>接下来<span class="math inline">\(m\)</span>行，每行两个整数<span class="math inline">\(L ,R\)</span>，表示该计划要求从第<span class="math inline">\(L\)</span>座城池到第<span class="math inline">\(R\)</span>座城池中，至少有一个城池被设置为关卡。</p><p><span class="math inline">\(1\le n,m\le 10^5,1\le L\le R\len\)</span></p><h2 id="输出-4">输出</h2><p>输出一个整数，表示设置关卡的方案数，对<span class="math inline">\(10^9+7\)</span>取模。</p><h2 id="样例-4">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3 2</span><br><span class="line">2 3</span><br><span class="line">1 2</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">用1表示关卡，0表示普通城池，那么这5种方案分别是: 010，011，110，111，101</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">12 3</span><br><span class="line">1 7</span><br><span class="line">6 12</span><br><span class="line">5 10</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">3988</span><br></pre></td></tr></table></figure><h2 id="解答-4">解答</h2><p>本题的统计要点在于：假设现在已经填了一个<span class="math inline">\(1\)</span>比特，那么下一个<span class="math inline">\(1\)</span>比特该往哪里填？需要注意的是，不存在两个相邻的<span class="math inline">\(1\)</span>比特中间包含了我们输入给定的区间。</p><p>因此，我们可以考虑使用动态规划来解决这个问题。令状态<span class="math inline">\(f(i)\)</span>表示已经填充了前<span class="math inline">\(i\)</span>个比特，其中第<span class="math inline">\(i\)</span>个比特为<span class="math inline">\(1\)</span>，并且对于右端点小于等于<span class="math inline">\(i\)</span>的区间，都满足要求的方案数。</p><p>令<span class="math inline">\(l_i\)</span>表示右端点小于等于<span class="math inline">\(i\)</span>的所有区间中，这些左端点的最大值（如果所有区间的右端点都大于<span class="math inline">\(i\)</span>，那么令<span class="math inline">\(l_i=0\)</span>。这意味着，对于任意<span class="math inline">\(i\ge 1\)</span>，如果<span class="math inline">\(l_i&gt;0\)</span>，那么从<span class="math inline">\(l_i\)</span>到<span class="math inline">\(i\)</span>必须要有至少一个<span class="math inline">\(1\)</span>。</p><p>那么我们可以写出如下状态转移方程：</p><p><span class="math inline">\(f(i)= \left \{\begin{aligned}  &amp;1&amp; &amp; \text{if}\quad i=0 \\  &amp;\sum_{j=l_{i-1}}^{i-1} f(j)&amp; &amp; \text{if}\quad i\ge 1 \\ \end{aligned}\right.\)</span></p><p>对于这个方程的第一行，这是一个空串，它显而易见是合法的。对于一个从<span class="math inline">\(f(j)\)</span>到<span class="math inline">\(f(i)\)</span>的转移，它是将第<span class="math inline">\(j+1,j+2,\dots,i-1\)</span>都填上<span class="math inline">\(0\)</span>，最后才在<span class="math inline">\(i\)</span>填上<span class="math inline">\(1\)</span>。也就是说，从<span class="math inline">\(f(l_{i-1}),f(l_{i-1}+1),\dots,f(i-1)\)</span>中转移而来的方案都是不尽相同的，它们确保了区间<span class="math inline">\([l_{i-1},i-1]\)</span>都至少包含了一个<span class="math inline">\(1\)</span>。</p><p>因此，为了确保<span class="math inline">\([l_n,n]\)</span>也是合法的，最终答案只包含<span class="math inline">\(\displaystyle{\sum_{i=l_n}^n f(i)}\)</span>。</p><p>可见，<span class="math inline">\(f(i)\)</span>的转移是<span class="math inline">\(O(n)\)</span>的，令<span class="math inline">\(\displaystyle{s(i)=\sum_{j=0}^if(j)}\)</span>表示<span class="math inline">\(f(i)\)</span>的前缀和，那么我们可以使用<span class="math inline">\(O(1)\)</span>的时间优化这个转移结果。因此最终答案为：如果<span class="math inline">\(l_n=0\)</span>，那么答案为<span class="math inline">\(s(n)\)</span>，否则为<span class="math inline">\(s(n)-s(l_n-1)\)</span>。</p><h2 id="代码-4">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line">ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> lp[N],n,m;</span><br><span class="line">ll s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        lp[y]=<span class="built_in">max</span>(lp[y],x);</span><br><span class="line">    &#125;</span><br><span class="line">    s[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ll w=s[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(l&gt;<span class="number">0</span>) w=(w-s[l<span class="number">-1</span>]+mod)%mod;</span><br><span class="line">        s[i]=(s[i<span class="number">-1</span>]+w)%mod;</span><br><span class="line">        l=<span class="built_in">max</span>(l,lp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=s[n];</span><br><span class="line">    <span class="keyword">if</span>(l&gt;<span class="number">0</span>) ans=(ans-s[l<span class="number">-1</span>]+mod)%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>腾讯 秋招 2023.09.15 编程题目与题解（研发岗）</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Tengxun-20230915A/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Tengxun-20230915A/</id>
    <published>2023-09-22T15:37:50.000Z</published>
    <updated>2023-09-22T15:37:50.985Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="牛妹的数链们">1、牛妹的数链们</h1><p>牛妹有一堆数链，这些数链里面的数字都杂乱无章，牛妹想整理一下这世数字，把它们从小到大排成一个数链。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&#123;1,3,5&#125;,&#123;2,4,6&#125;,&#123;1,2,3,4,5,6&#125;]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">&#123;1,1,2,2,3,3,4,4,5,5,6,6&#125;</span><br></pre></td></tr></table></figure><h2 id="备注">备注</h2><ul><li><span class="math inline">\(0\le val\le 10^9\)</span></li><li>总元素个数<span class="math inline">\(\le 10^5\)</span></li></ul><h2 id="解答">解答</h2><p>这里仅提供一种最暴力的做法：将所有节点都存在数组中，排完序后重新成链。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">solve</span><span class="params">(vector&lt;ListNode*&gt;&amp;a)</span></span>&#123;</span><br><span class="line">        vector&lt;ListNode*&gt;b;</span><br><span class="line">        <span class="keyword">for</span>(ListNode*head:a)&#123;</span><br><span class="line">            <span class="keyword">for</span>(ListNode*p=head;p!=<span class="literal">nullptr</span>;p=p-&gt;next)&#123;</span><br><span class="line">                b.<span class="built_in">push_back</span>(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>(),[](ListNode *a,ListNode *b)&#123;<span class="keyword">return</span> a-&gt;val&lt;b-&gt;val;&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+<span class="number">1</span>&lt;b.<span class="built_in">size</span>();i++)</span><br><span class="line">            b[i]-&gt;next=b[i+<span class="number">1</span>];</span><br><span class="line">        b.<span class="built_in">back</span>()-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="小q的奇偶操作数组">2、小Q的奇偶操作数组</h1><p>小Q有一个长度为<span class="math inline">\(n\)</span>的数组，它对这个数组有<span class="math inline">\(k\)</span>次操作机会，操作如下：</p><p>可以选择数组中的任意一个数字并改变它。</p><ol type="1"><li>如果选择的数字<span class="math inline">\(x\)</span>是奇数，那么这个奇数乘以<span class="math inline">\(2\)</span>，即<span class="math inline">\(x=x\ast2\)</span></li><li>如果选择的数字<span class="math inline">\(x\)</span>是偶数，那么这个偶数乘以<span class="math inline">\(2\)</span>再加<span class="math inline">\(1\)</span>，即<span class="math inline">\(x=x\ast2+1\)</span></li></ol><p>小Q想让这<span class="math inline">\(k\)</span>次操作之后，数组元素之和最小，请你输出这个最小值是多少？</p><p>保证最终的元素之和不超过<span class="math inline">\(10^{18}\)</span>。</p><h2 id="输入">输入</h2><p>第一行两个正整数<span class="math inline">\(n\)</span>和<span class="math inline">\(k\)</span>，用空格隔开。</p><p>第二行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(a_i\)</span>，每个<span class="math inline">\(a_i\)</span>代表数组的元素。</p><ul><li><span class="math inline">\(1\le n\le 200000\)</span></li><li><span class="math inline">\(1\le k\le 200000\)</span></li><li><span class="math inline">\(1\le a_i\le 10000000\)</span></li></ul><h2 id="输出">输出</h2><p>输出一个整数，代表<span class="math inline">\(k\)</span>次操作之后，数组元素之和的最小值。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5 3</span><br><span class="line">1 2 3 5 2</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">20</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">其中一种方案是:</span><br><span class="line">1. 将第一个元素：1=&gt;2</span><br><span class="line">2. 将第一个元素：2=&gt;5</span><br><span class="line">3. 将第二个元素：2=&gt;5</span><br><span class="line">总共3次操作，最后元素为5 5 3 5 2，数组元素之和为20</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>每次只需要取出数组中最小的元素值进行操作即可。我们可以使用贪心选择性质如下证明：</p><p>假设现在数组中，最小元素是<span class="math inline">\(x\)</span>，而选择的元素是<span class="math inline">\(y\)</span>，并且满足<span class="math inline">\(y&gt;x\)</span>。那么哪怕<span class="math inline">\(y\)</span>是偶数，<span class="math inline">\(x\)</span>是奇数，最终得到的数组和的差值满足<span class="math inline">\(2y-(2x+1)=2(y-x)-1&gt;0\)</span>，也就是说，只要选择了<span class="math inline">\(y\)</span>，最终得到的一定不是最优解。</p><p>每次寻找最小的数这个过程我们可以使用最小堆来完成。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k,x;</span><br><span class="line">    priority_queue&lt;ll,vector&lt;ll&gt;,greater&lt;ll&gt;&gt;q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        q.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        ll x=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        ll w=x&amp;<span class="number">1</span>?x&lt;&lt;<span class="number">1</span>:x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(w);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        ans+=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="赛道">3、赛道</h1><p>牛牛组织了一场拉力赛，在一条水平的赛道上，共有<span class="math inline">\(n\)</span>辆赛车，在当前时刻，牛牛记录下来了从左到右每辆车的位置<span class="math inline">\(p_1,p_2,\dots,p_n(0 \le p_1 &lt; p_2 &lt; \dots&lt; p_n)\)</span>，假设起点处位置为<span class="math inline">\(0\)</span>，因此它们当前的排名依次为: <span class="math inline">\(n,n-1,n-2,\dots,1\)</span>。现在牛牛知道在位置<span class="math inline">\(p_i\)</span>处的车辆速度为<span class="math inline">\(v_i\)</span>，假设所有的车保持匀速行驶，牛牛想知道在<span class="math inline">\(t\)</span>个单位时间后，有多少赛车的排名上升？</p><p><strong>注：如果在<span class="math inline">\(t\)</span>个单位时间后有两辆车的位置相同，则这两辆车的排名相同。一辆车的排名为在它前面的车辆的个数加<span class="math inline">\(1\)</span>。</strong></p><h2 id="输入-1">输入</h2><p>第一行输入两个正整数<span class="math inline">\(n,t\)</span>。</p><p>第二行输入<span class="math inline">\(n\)</span>个由空格隔开的整数<span class="math inline">\(p_1,p_2,\dots,p_n\)</span>。</p><p>第三行输入<span class="math inline">\(n\)</span>个由空格隔开的整数<span class="math inline">\(v_1,v_2,\dots,v_n\)</span>。</p><ul><li><span class="math inline">\(1\le n\le 10^5,0\le p_i\le 10^5,1\lev_i\le 100,1\le t\le 1000\)</span></li></ul><h2 id="输出-1">输出</h2><p>输出<span class="math inline">\(t\)</span>个单位时间之后排名上升的赛车数量。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3 1</span><br><span class="line">1 2 3</span><br><span class="line">3 1 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">原本排行第3的车在1个单位时间后到了4，而原本在第2的车在1个单位时间后到达位置3，而排行第1的车位置到达了6，因此只有1辆车的排名上升了。</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>为了编码方便，我们重新将排名定义成：当前距离在它后面的车辆的个数加<span class="math inline">\(1\)</span>，也就意味着这个排名数值越大越好。</p><p>计算出<span class="math inline">\(s_i=p_i+v_i\cdott\)</span>后，对原本所有的赛车重新进行排名。如果新排名的数值比原来高，那么就对其进行统计即可。这里需要注意的是新排名需要仔细处理距离相同的情况。</p><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"><span class="type">int</span> p[N],v[N],rk[N],s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        s[i]=p[i]+v[i]*t;</span><br><span class="line">        rk[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(rk+<span class="number">1</span>,rk+n+<span class="number">1</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> s[x]&lt;s[y];&#125;);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j;i&lt;=n;)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i;s[rk[i]]==s[rk[j]];++j);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;j;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;rk[k]) ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        i=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="旋转串">4、旋转串</h1><p>对于一个字符串，如果把字符串的第一个字符放到最后，得到的新串就是原来字符串的旋转串。</p><p>一个字符串的旋转串的旋转串也是这个字符串的旋转串。即这种关系具有传递性。</p><p>例如<code>abc</code>的旋转串有：<code>bca cab abc</code></p><p>如果存在一个字符串，既是<span class="math inline">\(x\)</span>的旋转串也是<span class="math inline">\(y\)</span>的旋转串，那么我们称<span class="math inline">\(x,y\)</span>匹配。</p><p>请回答一系列字符串中是否有两个字符串匹配。</p><h2 id="输入-2">输入</h2><p>第一行输入一个正整数<span class="math inline">\(T\)</span>，表示输入数据的组数。</p><p>每组数据第一行为一个正整数<span class="math inline">\(n\)</span>。</p><p>接下来<span class="math inline">\(n\)</span>行，每行一个只含小写字母的字符串<span class="math inline">\(s\)</span>。</p><ul><li><span class="math inline">\(1\le T\le 50,1\le n\le5000\)</span></li></ul><p>每个字符串的长度都相同且不会超过<span class="math inline">\(50\)</span></p><h2 id="输出-2">输出</h2><p>如果存在两个字符串匹配，则输出<code>YES</code>，否则输出<code>NO</code>。</p><h2 id="样例-3">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">abb</span><br><span class="line">abc</span><br><span class="line">bab</span><br><span class="line">3</span><br><span class="line">aba</span><br><span class="line">abc</span><br><span class="line">abb</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><h2 id="解答-3">解答</h2><p>如果<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>匹配，那么意味着<span class="math inline">\(x\)</span>串可以旋转操作得到<span class="math inline">\(y\)</span>。此时，<span class="math inline">\(x\)</span>通过旋转得到的最小字典序的字符串和<span class="math inline">\(y\)</span>通过相同操作得到的字符串相同。</p><p>因为，我们求出每个字符串的最小旋转串，然后再判断是否有两个最小旋转串是否相同即可。</p><p>其中，求最小旋转串只需要暴力旋转每个字符串即可。</p><h2 id="代码-3">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">to_min</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    string a=s;</span><br><span class="line">    <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        s=s.<span class="built_in">substr</span>(<span class="number">1</span>)+s[<span class="number">0</span>];</span><br><span class="line">        a=<span class="built_in">min</span>(a,s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    unordered_set&lt;string&gt;st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        s=<span class="built_in">to_min</span>(s);</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">count</span>(s)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        st.<span class="built_in">insert</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="built_in">solve</span>()?<span class="string">&quot;YES&quot;</span>:<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="红点和蓝点">5、红点和蓝点</h1><p>有<span class="math inline">\(n\)</span>个点，第<span class="math inline">\(i\)</span>个点的坐标为<span class="math inline">\(x_i\)</span>，第<span class="math inline">\(i\)</span>个点的颜色为<span class="math inline">\(c_i\)</span>。</p><p>如果<span class="math inline">\(c_i=0\)</span>，则第<span class="math inline">\(i\)</span>个点为红点。</p><p>如果<span class="math inline">\(c_i=1\)</span>，则第<span class="math inline">\(i\)</span>个点为蓝点。</p><p>每次你可以做以下两种操作之一：</p><ol type="1"><li>选择一个红点，设这个红点的坐标为<span class="math inline">\(x\)</span>，把这个点移动到<span class="math inline">\(x-1\)</span>或<span class="math inline">\(x+1\)</span>。</li><li>选择一个蓝点，将它变为红点。</li></ol><p>你可以最多做<span class="math inline">\(k\)</span>次操作2。求最少要进行多少次操作1可以使得意两个红点之间不存在蓝点。</p><p>即设两个红点分别在坐标<span class="math inline">\(x,y(x \ley)\)</span>，则不存在任何一个蓝点的坐标在区间<span class="math inline">\([x,y]\)</span>内。</p><h2 id="输入-3">输入</h2><p>第一行两个整数<span class="math inline">\(\displaystyle{n,k(1\le n\le200000,0\le k\le \sum_{i=1}^n c_i)}\)</span>。</p><p>第二行<span class="math inline">\(n\)</span>个整数<span class="math inline">\(x_1,x_2,\dots ,x_n(1\le x_1\le x_2\le \dots \lex_n \le 10^9)\)</span>。</p><p>第三行<span class="math inline">\(n\)</span>个整数<span class="math inline">\(c_1,c_2,\dots ,c_n(0\le c_i\le 1)\)</span>.</p><h2 id="输出-3">输出</h2><p>输出一行一个整数表示答案。</p><h2 id="样例-4">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5 0</span><br><span class="line">2 7 9 14 20</span><br><span class="line">0 1 0 0 1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">将第1红点移动到位置8，一共需要6次操作1。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">5 1</span><br><span class="line">2 7 9 14 20</span><br><span class="line">0 1 0 0 1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">将第2个蓝点修改为红点。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">8 0</span><br><span class="line">1 2 3 4 5 6 7 8</span><br><span class="line">0 1 1 1 1 1 1 0</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="解答-4">解答</h2><p>首先我们可以证明：如果要对蓝点染成红色，那么这些蓝点一定是相邻的。否则，将两块不相邻的蓝点染成红色后，还要将其中一块移动到中间间隔开的蓝点的另一端，这时还不如不对一块蓝点染色。因此，我们只考虑将连续一块的蓝点染成红色。</p><p>接下来我们使用双指针法来接解决这个问题。枚举每个点作为右端点<span class="math inline">\(r\)</span>，找到一个最小的<span class="math inline">\(l\)</span>使得区间<span class="math inline">\([l,r]\)</span>内至多包含<span class="math inline">\(k\)</span>个蓝色节点。那么我们只需要将区间外的节点移动到坐标范围<span class="math inline">\((x_{l-1},x_{r+1})\)</span>即可（如果区间为空，那么我们不讨论）。这时，在这个区间左侧的所有节点都移动到坐标<span class="math inline">\(x_{l-1}+1\)</span>，在这个区间右侧的坐标都移动到<span class="math inline">\(x_{r+1}-1\)</span>即可。因此，其中一个候选答案为：</p><p><span class="math display">\[\sum_{x_i\le x_{l-1}}(x_{l-1}+1-x_i)+\sum_{x_i\ge x_{r+1}} (x_i-(x_{r+1}-1))\]</span></p><p>我们最终还要算上区间<span class="math inline">\((-\infty,x_1)\)</span>和<span class="math inline">\((x_n,\infty)\)</span>的情况，最终一共有<span class="math inline">\(n+1\)</span>个候选答案，选其中一个最优即可。</p><h2 id="代码-4">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200004</span>;</span><br><span class="line"><span class="type">int</span> c[N],n,k;</span><br><span class="line"></span><br><span class="line">ll x[N],s0[N],s1[N],s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c[i]);</span><br><span class="line">        c[i]==<span class="number">0</span>?s0[i]=<span class="number">1</span>:s1[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x[<span class="number">0</span>]=<span class="number">-10</span>;x[n+<span class="number">1</span>]=<span class="number">1e9</span>+<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c[i]==<span class="number">0</span>) s[i]=x[i];</span><br><span class="line">        s[i]+=s[i<span class="number">-1</span>];</span><br><span class="line">        s0[i]+=s0[i<span class="number">-1</span>];</span><br><span class="line">        s1[i]+=s1[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">0</span>,l=<span class="number">0</span>;r&lt;=n;r++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(;s1[r]-s1[l]&gt;k;++l);</span><br><span class="line">        <span class="keyword">if</span>(x[l]+<span class="number">1</span>==x[r+<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        ll dr=x[r+<span class="number">1</span>]<span class="number">-1</span>,dl=x[l]+<span class="number">1</span>;</span><br><span class="line">        ll sl=dl*s0[l]-s[l];</span><br><span class="line">        ll sr=(s[n]-s[r])-dr*(s0[n]-s0[r]);</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,sl+sr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>阿里国际 秋招 2023.09.18 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Aliguoji-20230918/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Aliguoji-20230918/</id>
    <published>2023-09-21T14:35:54.000Z</published>
    <updated>2023-09-21T14:35:54.757Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="小红吃果子">1、小红吃果子</h1><p>有<span class="math inline">\(n\)</span>棵树，每棵树的高度为<span class="math inline">\(a_i\)</span>，每棵树在<span class="math inline">\(b_i\)</span>的高度上有一个果子。</p><p>小红从第一棵树的<span class="math inline">\(0\)</span>高度位置开始，每次可以进行如下操作：</p><ol type="1"><li>可以调整自身的高度，即从高度变为高度<span class="math inline">\(x+1\)</span>或<span class="math inline">\(x-1\)</span>，需要保证调整后高度仍然在<span class="math inline">\(0\)</span>到<span class="math inline">\(a_i\)</span>之间；</li><li>或者从第<span class="math inline">\(i\)</span>棵树的高度移动到第<span class="math inline">\(i+1\)</span>棵树的高度，需要保证<span class="math inline">\(x\le a_{i+1}\)</span>。</li></ol><p>小红始终不能超过所在树的高度。</p><p>小红吃到所有果子，最少需要几次操作？</p><h2 id="输入">输入</h2><p>第一行一个整数<span class="math inline">\(n\)</span>，表示树的数量。</p><p>第二行<span class="math inline">\(n\)</span>个整数<span class="math inline">\(a_i\)</span>，表示每棵树的高度。</p><p>第三行<span class="math inline">\(n\)</span>个整数<span class="math inline">\(b_i\)</span>，表示每棵树上果子的高度。</p><ul><li><span class="math inline">\(1\le n\le 10^5\)</span></li><li><span class="math inline">\(1\le b_i\le a_i \le 10^9\)</span></li></ul><h2 id="输出">输出</h2><p>输出一个整数，表示最少需要的操作次数。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">3 4 5 6 7</span><br><span class="line">1 2 3 4 5</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">9</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>该题目的答案为<span class="math inline">\(\displaystyle{b_1+\sum_{i=2}^n|b_i-b_{i-1}|}\)</span>。对于相邻的两棵树上面的果子，如果<span class="math inline">\(b_{i-1}\le b_{i}\)</span>，那么先从树<span class="math inline">\(i-1\)</span>移动到树<span class="math inline">\(i\)</span>，再上升到高度<span class="math inline">\(b_i\)</span>即可。如果<span class="math inline">\(b_{i-1}\ge b_i\)</span>，那么先下降到高度<span class="math inline">\(b_i\)</span>，再从树<span class="math inline">\(i-1\)</span>移动到树<span class="math inline">\(i\)</span>即可。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"><span class="type">int</span> a[N],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    ll ans=n<span class="number">-1</span>+a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        ans+=<span class="built_in">abs</span>(a[i+<span class="number">1</span>]-a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小红做游戏">2、小红做游戏</h1><p>小红在和朋友们做游戏，包括小红一共<span class="math inline">\(n\)</span>个人，大家围成了一个圈。</p><p>第<span class="math inline">\(i\)</span>个位置的人只记住了在他右手边的两个人，也就是说，位置<span class="math inline">\(1\)</span>的人记住了位置<span class="math inline">\(2\)</span>和位置<span class="math inline">\(3\)</span>的人，位置<span class="math inline">\(n-1\)</span>的人记住了位置<span class="math inline">\(n\)</span>和位置<span class="math inline">\(1\)</span>的人。</p><p>现在小红想知道，能不能还原出每个人的位置。</p><p>如果有多种可能，任意输出一种即可，保证至少存在一种符合要求的情况。</p><h2 id="输入-1">输入</h2><p>输入描述一行一个整数<span class="math inline">\(n\)</span>，表示人数。接下来<span class="math inline">\(n\)</span>行，每行两个整数<span class="math inline">\(a_i\)</span>和<span class="math inline">\(b_i\)</span>，表示第个人记住了第<span class="math inline">\(a_i\)</span>个人和第<span class="math inline">\(b_i\)</span>个人。 （<span class="math inline">\(b_i\)</span>不一定在<span class="math inline">\(a_i\)</span>的右边）。</p><ul><li><span class="math inline">\(3\le n\le 10^5\)</span></li><li><span class="math inline">\(1\le a_i,b_i\le n\)</span></li></ul><h2 id="输出-1">输出</h2><p>还原出每个人的位置，输出一行<span class="math inline">\(n\)</span>个整数，表示每个人的位置。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">2 3</span><br><span class="line">4 3</span><br><span class="line">4 5</span><br><span class="line">1 5</span><br><span class="line">2 1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>假设用一个长度为<span class="math inline">\(n\)</span>的数组<span class="math inline">\(z\)</span>来表示一个填充方案。由于这是一个环形，因此不失一般性，先固定好其中一个人的位置（这里假设是第<span class="math inline">\(1\)</span>个人，即<span class="math inline">\(z_1=1\)</span>），那么要么<span class="math inline">\(z_2=a_i,z_3=b_i\)</span>，要么<span class="math inline">\(z_2=b_1,z_3=a_i\)</span>。</p><p>考虑好其中一种情况后，我们将<span class="math inline">\(i\)</span>从<span class="math inline">\(2\)</span>一直遍历到<span class="math inline">\(n-2\)</span>，并将一个人的位置填入<span class="math inline">\(z_{i+2}\)</span>。如果<span class="math inline">\(z_{i+1}\in\{a_{z_i},b_{z_i}\}\)</span>，那么说明<span class="math inline">\(z_{i+2}\)</span>是这两个集合中的另一个数，否则这是错误的排列。</p><p>最终填好了序列<span class="math inline">\(z\)</span>后，按照定义验证填入的<span class="math inline">\(z_{n-1},z_n\)</span>是否正确即可。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N],n;</span><br><span class="line"><span class="type">int</span> z[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ok</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n<span class="number">-2</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> m=z[i],x=z[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(x==a[m]) z[i+<span class="number">2</span>]=b[m];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==b[m]) z[i+<span class="number">2</span>]=a[m];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m=z[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span>(!(a[m]==z[n]&amp;&amp;b[m]==z[<span class="number">1</span>]||a[m]==z[<span class="number">1</span>]&amp;&amp;b[m]==z[n])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    m=z[n];</span><br><span class="line">    <span class="keyword">if</span>(!(a[m]==z[<span class="number">1</span>]&amp;&amp;b[m]==z[<span class="number">2</span>]||a[m]==z[<span class="number">2</span>]&amp;&amp;b[m]==z[<span class="number">1</span>])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a[i],&amp;b[i]);</span><br><span class="line">    z[<span class="number">1</span>]=<span class="number">1</span>;z[<span class="number">2</span>]=a[<span class="number">1</span>];z[<span class="number">3</span>]=b[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">ok</span>())&#123;</span><br><span class="line">        z[<span class="number">2</span>]=b[<span class="number">1</span>];z[<span class="number">3</span>]=a[<span class="number">1</span>];<span class="built_in">ok</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>,z[i], <span class="string">&quot; \n&quot;</span>[i==n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="最长递增子数组">3、最长递增子数组</h1><p>给定两个长度为n的数组<span class="math inline">\(a,b\)</span>和一个空数组<span class="math inline">\(c\)</span>。</p><p>每次操作，可以选择<span class="math inline">\(a\)</span>数组或者<span class="math inline">\(b\)</span>数组的第一个元素，添加到<span class="math inline">\(c\)</span>数组的末尾然后从相应的数组删除。</p><p><span class="math inline">\(a\)</span>数组和<span class="math inline">\(b\)</span>数组都为空时，结束操作。</p><p>在所有可能可以获得的<span class="math inline">\(c\)</span>数组中，请你找出最长的递增子数组，子数组需要满足相邻两个元素的差的绝对值为<span class="math inline">\(1\)</span>，输出这个子数组的长度。</p><h2 id="输入-2">输入</h2><p>第一行输入一个整数<span class="math inline">\(n\)</span>。</p><p>第二行输入<span class="math inline">\(n\)</span>个整数<span class="math inline">\(a_i\)</span>。</p><p>第三行输入<span class="math inline">\(n\)</span>个整数<span class="math inline">\(b_i\)</span>。</p><p><span class="math inline">\(1\le n,a_i,b_i\le2\times10^3\)</span></p><h2 id="输出-2">输出</h2><p>输出一个整数。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">5 2 4</span><br><span class="line">7 1 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">可以得到一个c数组：7 5 1 2 3 4。</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>这道题的特征比较明显，我们可以使用动态规划来完成。</p><p>令状态<span class="math inline">\(f(i,j,k)(0\le i,j\le n,0\le k\le1)\)</span>表示当前已经将<span class="math inline">\(a\)</span>的前<span class="math inline">\(i\)</span>个元素和<span class="math inline">\(b\)</span>的前<span class="math inline">\(j\)</span>个元素插入了数组<span class="math inline">\(c\)</span>中，并且如果<span class="math inline">\(k=0\)</span>，那么<span class="math inline">\(c_{i+j}=a_i\)</span>；如果<span class="math inline">\(k=1\)</span>，那么<span class="math inline">\(c_{i+j}=b_j\)</span>的情况下，以<span class="math inline">\(c_{i+j}\)</span>为终点的最长递增且相邻之差的绝对值为<span class="math inline">\(1\)</span>子数组的长度。可见，状态<span class="math inline">\(f(\cdot,0,1)\)</span>和<span class="math inline">\(f(0,\cdot,0)\)</span>都是未定义的状态，我们令其值为<span class="math inline">\(-\infty\)</span>。</p><p>一开始，数组<span class="math inline">\(c\)</span>只有一个元素，因此它有如下初值：</p><ul><li><span class="math inline">\(f(1,0,0)=1,f(0,1,1)=1\)</span></li></ul><p>对于任意合法状态<span class="math inline">\(f(i,j,0)\)</span>，可以知道我们现在取的是<span class="math inline">\(a\)</span>中的第<span class="math inline">\(i\)</span>个数，并放进位置<span class="math inline">\(c_{i+j}\)</span>中。那么我们可以写出如下<span class="math inline">\(3\)</span>种情况的转移：</p><ul><li><span class="math inline">\(1\rightarrow f(i,j,0)\)</span></li><li><span class="math inline">\(f(i-1,j,0)+1\rightarrowf(i,j,0)\qquad\text{if}\qquad i&gt;1\land a_i=a_{i-1}+1\)</span></li><li><span class="math inline">\(f(i-1,j,1)+1\rightarrowf(i,j,0)\qquad\text{if}\qquad j\ge1\land a_i=b_j+1\)</span></li></ul><p>由于<span class="math inline">\(a_i\)</span>可以自成一个新的递增子数组，因此有第一行的转移；此外，它还可以拼接在原来自己的元素<span class="math inline">\(a_{i-1}\)</span>后面，因此有第二行的转移；它还可以拼接在之前<span class="math inline">\(b_j\)</span>的后面，因此有第三行的转移。</p><p>因此，本题的最终答案为<span class="math inline">\(\displaystyle{\max_{0\le i,j\len}\{\max\{f(i,j,0),f(i,j,1)\}\}}\)</span>。</p><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2004</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N],n;</span><br><span class="line"><span class="type">int</span> f[N][N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MAX</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y&gt;=x) x=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            f[i][j][<span class="number">0</span>]=f[i][j][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>&amp;&amp;a[i]==b[j]+<span class="number">1</span>) <span class="built_in">MAX</span>(f[i][j][<span class="number">0</span>],f[i<span class="number">-1</span>][j][<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">1</span>&amp;&amp;a[i]==a[i<span class="number">-1</span>]+<span class="number">1</span>) <span class="built_in">MAX</span>(f[i][j][<span class="number">0</span>],f[i<span class="number">-1</span>][j][<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;b[j]==a[i]+<span class="number">1</span>) <span class="built_in">MAX</span>(f[i][j][<span class="number">1</span>],f[i][j<span class="number">-1</span>][<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">1</span>&amp;&amp;b[j]==b[j<span class="number">-1</span>]+<span class="number">1</span>) <span class="built_in">MAX</span>(f[i][j][<span class="number">1</span>],f[i][j<span class="number">-1</span>][<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,<span class="built_in">max</span>(f[i][j][<span class="number">0</span>],f[i][j][<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>科大讯飞 秋招 2023.09.15 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Kedaxunfei-20230915/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Kedaxunfei-20230915/</id>
    <published>2023-09-21T11:09:49.000Z</published>
    <updated>2023-09-21T11:09:49.141Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="小红数数">1、小红数数</h1><p>小红正在数偶数：<span class="math inline">\(0,2,4,6,8,10,12,\dots\)</span></p><p>她把这些数连在了一起，形成一个无穷长的字符串：<code>"0246810121416...</code></p><p>小红想知道，这个字符串第<span class="math inline">\(n\)</span>个字符是多少？</p><h2 id="输入">输入</h2><p>一个正整数<span class="math inline">\(n\)</span>。</p><p><span class="math inline">\(1\le n\le 10^5\)</span></p><h2 id="输出">输出</h2><p>字符串的第<span class="math inline">\(n\)</span>个字符。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>本题是一道简单模拟题，只需要将每一个偶数转化成字符串拼接上已有的字符串后面，直到字符串长度超过<span class="math inline">\(n\)</span>即可，最终输出第<span class="math inline">\(n\)</span>个字符。</p><h2 id="代码">代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">k = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(s) &lt; n:</span><br><span class="line">    s += <span class="built_in">str</span>(k)</span><br><span class="line">    k += <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(s[n - <span class="number">1</span>])</span><br></pre></td></tr></table></figure><h1 id="小红的递增子序列">2、小红的递增子序列</h1><p>小红有一个长度为<span class="math inline">\(n\)</span>的排列，请你对排列进行重排，使得排列的最长递增子序列的长度为<span class="math inline">\(k\)</span>。</p><h2 id="输入-1">输入</h2><p>第一行两个整数<span class="math inline">\(n,k\)</span>，表示排列的长度和最长递增子序列的长度。</p><p><span class="math inline">\(1\le k\le n\le 10^5\)</span></p><h2 id="输出-1">输出</h2><p>输出一行，包含<span class="math inline">\(n\)</span>个整数，表示重排后的排列，如果有多种方案，输出任意一种即可。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3 1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">3 2 1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">排列[3, 2, 1]的最长递增子序列的长度为1。</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>基于贪心的思想，我们令最小的<span class="math inline">\(k\)</span>个数递增，让最大的<span class="math inline">\(n-k\)</span>个数递减即可，这样最大的<span class="math inline">\(n-k\)</span>个数不会对答案造成任何的影响。</p><h2 id="代码-1">代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">a = <span class="built_in">list</span>(<span class="built_in">range</span>(n, k, -<span class="number">1</span>)) + <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, k + <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(*a)</span><br></pre></td></tr></table></figure><h1 id="科大讯飞飞凡计划">3、科大讯飞飞凡计划</h1><p>小红是科大讯飞飞凡计划的导师。已知小红所在的组共有<span class="math inline">\(n\)</span>名成员，每名成员的业务能力为<span class="math inline">\(a_i\)</span>，沟通能力为<span class="math inline">\(b_i\)</span>。</p><p>现在，小红希望把所有成员分为两个小组进行小组竞争，为了公平，小红希望这两个小组的成员的业务能力之和相等，沟通能力之和也相等。请你帮小红给出一个合法的分组方案。</p><h2 id="输入-2">输入</h2><p>第一行输入一个正整数<span class="math inline">\(n\)</span>，代表总人数。</p><p>接下来的<span class="math inline">\(n\)</span>行，每行输入两个正整数<span class="math inline">\(a_i,b_i\)</span>，代表每个成员的业务能力。和沟通能力。</p><ul><li><span class="math inline">\(1\le n\le 50\)</span></li><li><span class="math inline">\(1\le a_i,b_i\le 20\)</span></li></ul><h2 id="输出-2">输出</h2><p>如果不存在一种合法的分配方案，则直接输出<span class="math inline">\(-1\)</span>。</p><p>否则第一行输入两个正整数<span class="math inline">\(k\)</span>和<span class="math inline">\(n-k\)</span>，分别代表两个小组的人数。</p><p>第二行输入<span class="math inline">\(k\)</span>个正整数<span class="math inline">\(p_i\)</span>，代表第一个小组的成员。</p><p>第三行输入<span class="math inline">\(n-k\)</span>个正整数<span class="math inline">\(q_i\)</span>，代表第二个小组的成员。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br><span class="line">4 6</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">第一个和第二个成员一组，第三个成员独自一组即可。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">1 2</span><br><span class="line">1 2</span><br><span class="line">1 2</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>这道题可以使用动态规划进行解决。</p><p>首先，如果所有人的<span class="math inline">\(a_i\)</span>之和或者是<span class="math inline">\(b_i\)</span>之和为奇数，那么很明显没有办法划分出满足要求的两队人。</p><p>否则，我们令<span class="math inline">\(\displaystyle{s_a=\dfrac{1}{2}\sum_{i=1}^na_i,s_b=\dfrac{1}{2}\sum_{i=1}^n b_i}\)</span>。如果存在一个子集<span class="math inline">\(S\)</span>满足<span class="math inline">\(\displaystyle{\sum_{i\in S} a_i=s_a,\sum_{i\in S}b_i=s_b}\)</span>，那么<span class="math inline">\(S\)</span>为一队人，其余人为另一队人，因此这题实际上可以使用和0-1背包问题类似的做法完成，只不过我们这里需要对状态进行追溯。</p><p>令<span class="math inline">\(f(i,j,k)\)</span>表示选择了前<span class="math inline">\(i\)</span>个人后，存在一个子集<span class="math inline">\(S\)</span>，其所有<span class="math inline">\(a_i\)</span>之和为<span class="math inline">\(j\)</span>，所有<span class="math inline">\(b_i\)</span>之和为<span class="math inline">\(k\)</span>的情况。如果<span class="math inline">\(f(i,j,k)\neq0\)</span>，那么说明这样的子集是存在的，那么我们可以写出<span class="math inline">\(f(i,j,k)\)</span>的其中一个状态转移方程为：</p><p><span class="math inline">\(f(i,j)= \left \{\begin{aligned}  &amp;-1&amp; &amp; \text{if}\quad i=1\land j=0\land k=0 \\  &amp;0 &amp; &amp;\text{if}\quad i=1\land \neg (j=0\land k=0) \\  &amp;-1 &amp; &amp;\text{if}\quad i&gt;1\land f(i-1,j,k)\neq 0 \\  &amp;1 &amp; &amp;\text{if}\quad i&gt;1\land f(i-1,j,k)= 0\land j\ge a_i\land k\geb_i\land f(i-1,j-a_i,k-b_i)\neq 0 \\  &amp;0 &amp; &amp;\text{otherwise}\quad \\ \end{aligned}\right.\)</span></p><p>其中，<span class="math inline">\(f(i,j,k)\neq0\)</span>使还记录了它是从哪个状态转移而来。如果<span class="math inline">\(f(i,j,k)=1\)</span>，那么第<span class="math inline">\(i\)</span>个人被选上了，从<span class="math inline">\(f(i-1,j-a_i,k-b_i)\)</span>转移而来；如果<span class="math inline">\(f(i,j,k)=-1\)</span>，那么第<span class="math inline">\(i\)</span>个人没被选上，从<span class="math inline">\(f(i-1,j,k)\)</span>转移而来。</p><p>因此，我们最终判断是否满足<span class="math inline">\(f(n,s_a,s_b)\neq0\)</span>即可，并且通过其值，得到它的状态转移过程，并逆推出一个方案。</p><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">504</span>][<span class="number">504</span>];</span><br><span class="line"><span class="type">int</span> n,a[N],b[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> sa=<span class="number">0</span>,sb=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a[i],&amp;b[i]);</span><br><span class="line">        sa+=a[i];sb+=b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((sa&amp;<span class="number">1</span>)||(sb&amp;<span class="number">1</span>)) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">    sa&gt;&gt;=<span class="number">1</span>;sb&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=sa;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=sb;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=a[i]&amp;&amp;k&gt;=b[i]&amp;&amp;f[i][j-a[i]][k-b[i]])&#123;</span><br><span class="line">                    f[i][j][k]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(f[i<span class="number">-1</span>][j][k]) f[i][j][k]=<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[n][sa][sb]==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;x,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n,j=sa,k=sb;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[i][j][k]==<span class="number">1</span>) x.<span class="built_in">push_back</span>(i),j-=a[i],k-=b[i];</span><br><span class="line">        <span class="keyword">else</span> y.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,x.<span class="built_in">size</span>(),y.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.<span class="built_in">size</span>();i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>,x[i], <span class="string">&quot; \n&quot;</span>[i+<span class="number">1</span>==x.<span class="built_in">size</span>()]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;y.<span class="built_in">size</span>();i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>,y[i], <span class="string">&quot; \n&quot;</span>[i+<span class="number">1</span>==y.<span class="built_in">size</span>()]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>华为 秋招 2023.09.20 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Huawei-20230920/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Huawei-20230920/</id>
    <published>2023-09-21T10:18:37.000Z</published>
    <updated>2023-09-21T13:24:30.188Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="丢失报文的位置">1、丢失报文的位置</h1><p>某通信系统持续向外发送报文，使用数组<span class="math inline">\(\texttt{nums}\)</span>保存<span class="math inline">\(n\)</span>个最近发送的报文，用于在报文未达到对端的情况下重发。报文使用序号<span class="math inline">\(sn\)</span>表示，序号<span class="math inline">\(sn\)</span>按照报文发送顺序从小到大排序，相邻报文<span class="math inline">\(sn\)</span>不完全连续且有可能相同。报文使用循环覆盖的方式保存，即<span class="math inline">\(\texttt{nums}\)</span>数组填满后，从头开始保存新的报文。假设需要重发序号为<span class="math inline">\(sn\)</span>的报文。请找出序号为<span class="math inline">\(sn\)</span>的报文在数组中的开始位置和结束位置。</p><h2 id="输入">输入</h2><p>第一行输入：数组<span class="math inline">\(\texttt{nums}\)</span>的大小<span class="math inline">\(n\)</span>，取值范围<span class="math inline">\([0,10000]\)</span>。</p><p>第二行输入：数组中的所有报文的序号<span class="math inline">\(sn\)</span>，<span class="math inline">\(sn\)</span>取值范围<span class="math inline">\([0,100000]\)</span>。</p><p>第三行输入：需要重发的报文序号<span class="math inline">\(sn\)</span>，取值范围<span class="math inline">\([0,100000]\)</span>。</p><h2 id="输出">输出</h2><p><span class="math inline">\(\texttt{start end}\)</span></p><p>说明：<span class="math inline">\(\texttt{start}\)</span>和<span class="math inline">\(\texttt{end}\)</span>代表需要重发的报文序号<span class="math inline">\(sn\)</span>在数组中的起始下标和结束下标。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">7</span><br><span class="line">0 0 1 2 2 5 6</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2 2</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">nums数组大小为7。</span><br><span class="line">保存了7个报文，sn分别是0 0 1 2 2 5 6。</span><br><span class="line">sn为1的报文在数组中仅有1个，下标是2，因此输出2 2。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">7</span><br><span class="line">0 0 1 2 2 5 6</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">3 4</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">nums数组大小为7。</span><br><span class="line">保存了7个报文，sn分别是0 0 1 2 2 5 6。</span><br><span class="line">sn为2的报文在数组中有2个，下标分别是3，4，因此输出3 4。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">7</span><br><span class="line">4 4 7 8 2 3 4</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">6 1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">nums数组大小为7。</span><br><span class="line">保存了7个报文，sn分别是4 4 7 8 2 3 4。</span><br><span class="line">sn为4的报文在数组中有3个，下标分别是0，1，6，说明数组存在记录满了从头开始记录的情况，输出6 1。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">7</span><br><span class="line">4 4 7 8 2 3 4</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">-1 -1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">nums数组大小为7。</span><br><span class="line">保存了7个报文，sn分别是4 4 7 8 2 3 4。</span><br><span class="line">数组中不存在sn为6的报文，因此输出-1 -1。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">5 5 5 5 5</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">0 4</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">nums数组大小为5</span><br><span class="line">保存了5个报文，sn分别是5 5 5 5 5</span><br><span class="line">数组中所有报文sn都是5，这种情况下认为0是start，4是end，输出0 4。</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>这题我们只需要找到最小的那个数的下标，然后以它为起点，每个数都遍历一次即可（需要遍历回开头）。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"><span class="type">int</span> a[N],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    <span class="type">int</span> p=<span class="built_in">min_element</span>(a,a+n)-a;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">-1</span>,r=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> q=(p+i)%n;</span><br><span class="line">        <span class="keyword">if</span>(a[q]==x)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l==<span class="number">-1</span>) l=q;</span><br><span class="line">            r=q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="快速传球">2、快速传球</h1><p>班级组织传球活动，男女同学随机排成<span class="math inline">\(m\)</span>行<span class="math inline">\(n\)</span>列队伍，第一列中的任意一个男同学都可以作为传球的起点，要求最终将球传到最后一列的任意一个男同学手里，求所有能够完成任务的传球路线中的最优路线（传球次数最少的路线）的传球次数。传球规则：</p><ol type="1"><li>男同学只能将球传给男同学，不能传给女同学。</li><li>球只能传给身边前后左右相邻的同学。</li><li>如果游戏不能完成，返回<span class="math inline">\(-1\)</span>。</li></ol><p>说明：</p><ol type="1"><li>传球次数最少的路线为最优路线。</li><li>最优路线可能不唯一，不同最优路线都为最少传球次数。</li></ol><h2 id="输入-1">输入</h2><p>班级同学随机排成的<span class="math inline">\(m\)</span>行<span class="math inline">\(n\)</span>列队伍，<span class="math inline">\(1\)</span>代表男同学，<span class="math inline">\(0\)</span>代表女同学。</p><p>输入第一行包含两个用空格分开的整数<span class="math inline">\(m(m\in[1,30])\)</span>和<span class="math inline">\(n(n\in[1,30])\)</span>，表示<span class="math inline">\(m\)</span>行<span class="math inline">\(n\)</span>列的队伍，接下来是<span class="math inline">\(m\)</span>行每行包含<span class="math inline">\(n\)</span>个用空格分开的整数<span class="math inline">\(1\)</span>或<span class="math inline">\(0\)</span>。</p><h2 id="输出-1">输出</h2><p>最优路线的传球次数（最少传球次数）。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">4 4</span><br><span class="line">1 1 1 0</span><br><span class="line">1 1 1 0</span><br><span class="line">0 0 1 0</span><br><span class="line">0 1 1 1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">  图一            图二             图三</span><br><span class="line">. . . 0         . . 1 0         1 1 1 0</span><br><span class="line">1 1 . 0         1 . . 0         . . . 0</span><br><span class="line">0 0 . 0         0 0 . 0         0 0 . 0</span><br><span class="line">0 1 . .         0 1 . .         0 1 . .</span><br><span class="line">图一传球路线需要传球6次。</span><br><span class="line">图二传球路线需要传球6次。</span><br><span class="line">图三传球路线需要传球5次，传球次数最少，为最优传球路线。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">3 4</span><br><span class="line">1 0 1 1</span><br><span class="line">1 1 0 0</span><br><span class="line">0 0 1 0</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">-1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">选择第1行第1列的男同学作为起点，无法实现按规则将球到最后一列男同学手里。</span><br><span class="line">选择第2行第1列的男同学作为起点，无法实现按规则将球到最后一列男同学手里。</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>本题是一道多源BFS题目。将第<span class="math inline">\(1\)</span>列的所有元素为<span class="math inline">\(1\)</span>的格子作为起点，将最后一列所有的格子都作为终点，最终只需要找一个距离最短的终点即可。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> pi pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">44</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> s[N][N],d[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="built_in">sizeof</span>(d));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;s[i][j]);</span><br><span class="line">            <span class="built_in">assert</span>(s[i][j]==<span class="number">1</span>||s[i][j]==<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    queue&lt;pi&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i][<span class="number">1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">            d[i][<span class="number">1</span>]=<span class="number">0</span>;q.<span class="built_in">push</span>(<span class="built_in">pi</span>(i,<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> [sx,sy]=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x=sx+dx[i],y=sy+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(x&lt;<span class="number">1</span>||y&lt;<span class="number">1</span>||x&gt;n||y&gt;m||d[x][y]!=<span class="number">-1</span>||s[x][y]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            d[x][y]=d[sx][sy]+<span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">pi</span>(x,y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(s[i][m]==<span class="number">1</span>) ans=<span class="built_in">min</span>(ans,d[i][m]);</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">1e9</span>) ans=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="简易计算器">3、简易计算器</h1><p>设计一款计算器软件，支持以下功能：</p><ol type="1"><li><p>支持<code>let</code>关键字。</p></li><li><p>支持通过<code>let</code>赋值表达式定义变量并初始化。</p></li></ol><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let var1 = 123</span><br><span class="line">let var = 123</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>变量需要先定义再引用，在表达式中引用未定义的变量，则表达式的结果也是未定义的。</li></ol><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let var1 = 1</span><br><span class="line">let var2 = var1 + 1 // var1是定义的</span><br><span class="line">let var3 = var4 + 1 // var4是未定义的</span><br><span class="line">let var4 = 1</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>支持整数类型数据，整数数据的输入格式只需要支持十进制，支持负整数，整数取值范围<span class="math inline">\(-2147483648 \le x \le 2147483647\)</span>。</li></ol><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let var3 = 10</span><br><span class="line">let var3 = -10</span><br></pre></td></tr></table></figure><ol start="5" type="1"><li>支持整数的加(<code>+</code>)、减(<code>-</code>)、乘(<code>*</code>)、除(<code>/</code>)四则运算，四则运算符之间没有优先级，运算数遵循左结合律，用例不考虑括号。</li></ol><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let var4 = 1 + 2 * var3</span><br></pre></td></tr></table></figure><p>上述表达式的计算顺序是，先计算<span class="math inline">\(1+2\)</span>结果为<span class="math inline">\(3\)</span>，再将<span class="math inline">\(3\)</span>乘以<code>var3</code>得到表达式的结果。</p><ol start="6" type="1"><li>支持通过<code>out</code>函数打印变量的值，函数参数只接受<span class="math inline">\(1\)</span>个变量，不需要支持表达式。</li></ol><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let var4 = 12</span><br><span class="line">out(var4)       // 将会输出12</span><br></pre></td></tr></table></figure><ol start="7" type="1"><li><p>表达式中如果引用了未定义的变量，则表达式的结果是未定义的。</p></li><li><p>如果计算结果溢出，则表达式结果是溢出。</p></li><li><p>变量命名符合通用语言变量规范，必须是以下划线(<code>_</code>)或者字母开头，遇到标点符号或者空格符时结束。</p></li></ol><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let _ = 1       // 变量名_是合法的</span><br><span class="line">let _abc = 1    // 合法</span><br><span class="line">let abc = 1     // 合法</span><br><span class="line">let Abc_1 = 1   // 合法</span><br><span class="line">let abc.x = 1   // 非法</span><br><span class="line">let abc,x = 1   // 非法</span><br><span class="line">let 12abc = 1   // 非法</span><br><span class="line">let abc x = 1   // 非法</span><br></pre></td></tr></table></figure><h2 id="输入-2">输入</h2><ol type="1"><li>每一行只有一个表达式。</li><li>最多支持<span class="math inline">\(24\)</span>行输入。</li><li>每个用例输入至少有一个<code>out</code>输出表达式，可以有多个<code>out</code>输出表达式。</li><li>每个变量只会赋值<span class="math inline">\(1\)</span>次。</li></ol><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let var1 = 1</span><br><span class="line">let var2 = 3</span><br><span class="line">let var3 = var1 + var2</span><br><span class="line">out(var3)</span><br></pre></td></tr></table></figure><h2 id="输出-2">输出</h2><ol type="1"><li>每遇到<span class="math inline">\(1\)</span>个<code>out</code>输出表达式，则打印输出变量的值。</li><li>对于<code>out</code>行，只会输出一个<code>out</code>表达式的值。</li><li>如果<code>out</code>输出的变量未定义，则打印<code>&lt;undefined&gt;</code></li><li>如果表达式结果发生了整数上溢或者下溢，则对该变量的<code>out</code>输出表达式输出<code>&lt;underflow&gt;</code>或者<code>&lt;overflow&gt;</code></li><li>如果表达式非法，则打印<code>&lt;syntax-error&gt;</code></li></ol><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">let var1 = 1</span><br><span class="line">out(var1)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">out(var)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">&lt;undefined&gt;</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">输出的var变量未定义。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">let var1 = 1</span><br><span class="line">let var2 = 3</span><br><span class="line">let var3 = var1 + var2</span><br><span class="line">out(var3)</span><br><span class="line">out(var2)</span><br><span class="line">out(var)</span><br><span class="line">let var4 = -2147483649</span><br><span class="line">let var5 = 2147483648</span><br><span class="line">out(var4)</span><br><span class="line">out(var5)</span><br><span class="line">let x.y = 1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">&lt;undefined&gt;</span><br><span class="line">&lt;underflow&gt;</span><br><span class="line">&lt;overflow&gt;</span><br><span class="line">&lt;syntax-error&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>本题是一道让人难受的字符串大模拟题，为了完成本题，需要编写很多个函数用于各种操作，如：</p><ul><li><p><code>is_variable_name</code>用于判断一个字符串是不是一个合法的变量名，按第9点的要求实现即可。</p></li><li><p><code>is_int</code>用于判断一个字符串是否为一个合法的十进制整数。</p></li><li><p><code>convert_int</code>用于将表达式中的变量名或者是数字字符串映射成一个真正的数。</p></li><li><p><code>parse_let</code>用于解析<code>let</code>命令。首先判断等号左侧是否为一个合法标识符，然后判断右侧是不是一个合法的算术表达式，如果是再做计算，进一步需要判断是否使用了未引用变量。</p></li><li><p><code>parse_out</code>用于解析<code>out</code>命令。根据对应的变量值打印对应的结果，同时处理各种溢出、未定义问题。</p></li></ul><h2 id="代码-2">代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">ls = []</span><br><span class="line">mn = - (<span class="number">1</span> &lt;&lt; <span class="number">31</span>)</span><br><span class="line">mx = (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span></span><br><span class="line">inf = <span class="number">10</span> ** <span class="number">50</span></span><br><span class="line">SYNTAX_ERROR = <span class="string">&quot;&lt;syntax-error&gt;&quot;</span></span><br><span class="line">UNDEFINED = <span class="string">&quot;&lt;undefined&gt;&quot;</span></span><br><span class="line">OVERFLOW = <span class="string">&quot;&lt;overflow&gt;&quot;</span></span><br><span class="line">UNDERFLOW = <span class="string">&quot;&lt;underflow&gt;&quot;</span></span><br><span class="line">mp = <span class="built_in">dict</span>()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        s = <span class="built_in">input</span>()</span><br><span class="line">        ls.append(s)</span><br><span class="line"><span class="keyword">except</span> EOFError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_variable_name</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(name) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (name[<span class="number">0</span>].isalpha() <span class="keyword">or</span> name[<span class="number">0</span>] == <span class="string">&#x27;_&#x27;</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> name[<span class="number">1</span>:]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (ch.isalpha() <span class="keyword">or</span> ch.isdigit() <span class="keyword">or</span> ch == <span class="string">&#x27;_&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_int</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">int</span>(s)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convert_int</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">if</span> is_int(s):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(s)</span><br><span class="line">    <span class="keyword">elif</span> s <span class="keyword">in</span> mp.keys():</span><br><span class="line">        <span class="keyword">return</span> mp[s]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_let</span>(<span class="params">s</span>):</span><br><span class="line">    s = s.strip()</span><br><span class="line">    l, r = s.split(<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">    l, r = l.strip(), r.strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> is_variable_name(l):</span><br><span class="line">        <span class="keyword">return</span> SYNTAX_ERROR</span><br><span class="line">    ls = r.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ls) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> SYNTAX_ERROR</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(ls), <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> is_int(ls[i]) <span class="keyword">and</span> <span class="keyword">not</span> is_variable_name(ls[i]):</span><br><span class="line">            <span class="keyword">return</span> SYNTAX_ERROR</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(ls), <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (<span class="built_in">len</span>(ls[i]) == <span class="number">1</span> <span class="keyword">and</span> ls[i] <span class="keyword">in</span> <span class="string">&quot;+-*/&quot;</span>):</span><br><span class="line">            <span class="keyword">return</span> SYNTAX_ERROR</span><br><span class="line">    v = convert_int(ls[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(ls), <span class="number">2</span>):</span><br><span class="line">        op, w = ls[i], convert_int(ls[i + <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> w <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> op == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            v += w</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            v -= w</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            v *= w</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            v //= w</span><br><span class="line">        <span class="keyword">if</span> v &gt; mx:</span><br><span class="line">            v = inf</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">elif</span> v &lt; mn:</span><br><span class="line">            v = -inf</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    mp[l] = v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_out</span>(<span class="params">s</span>):</span><br><span class="line">    s = s[<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> s <span class="keyword">in</span> mp.keys():</span><br><span class="line">        x = mp[s]</span><br><span class="line">        <span class="keyword">if</span> x &gt; mx:</span><br><span class="line">            <span class="keyword">return</span> OVERFLOW</span><br><span class="line">        <span class="keyword">elif</span> x &lt; mn:</span><br><span class="line">            <span class="keyword">return</span> UNDERFLOW</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> UNDEFINED</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> ls:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt;= <span class="number">3</span> <span class="keyword">and</span> s[:<span class="number">3</span>] == <span class="string">&quot;let&quot;</span>:</span><br><span class="line">        t = parse_let(s[<span class="number">3</span>:])</span><br><span class="line">        <span class="keyword">if</span> t <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(t)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(s) &gt;= <span class="number">3</span> <span class="keyword">and</span> s[:<span class="number">3</span>] == <span class="string">&quot;out&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(parse_out(s[<span class="number">3</span>:]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(SYNTAX_ERROR)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
</feed>
