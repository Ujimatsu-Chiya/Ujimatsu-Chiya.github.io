<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ujimatsu Chiya</title>
  
  
  <link href="https://ujimatsu-chiya.github.io/atom.xml" rel="self"/>
  
  <link href="https://ujimatsu-chiya.github.io/"/>
  <updated>2023-10-15T05:44:35.411Z</updated>
  <id>https://ujimatsu-chiya.github.io/</id>
  
  <author>
    <name>Ujimatsu Chiya</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网易 秋招 2023.10.15 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Wangyi-20231015/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Wangyi-20231015/</id>
    <published>2023-10-15T05:44:35.000Z</published>
    <updated>2023-10-15T05:44:35.411Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="小红的字符串变换easy">1、小红的字符串变换（easy）</h1><p>小红有一个字符串<span class="math inline">\(s\)</span>，她想把<span class="math inline">\(s\)</span>变成<span class="math inline">\(t\)</span>。</p><p>小红可以进行操作：选择两种不同的字母，然后将在<span class="math inline">\(s\)</span>中的这两种字母按任意顺序排列。</p><p>小红想知道她是否可以恰好操作一次将<span class="math inline">\(s\)</span>变成<span class="math inline">\(t\)</span>。</p><h2 id="输入">输入</h2><p>第一行输入一个字符串<span class="math inline">\(s\)</span>。</p><p>第二行输入一个字符串<span class="math inline">\(t\)</span>。</p><p><span class="math inline">\(s\)</span>和<span class="math inline">\(t\)</span>长度相等，且都不超过<span class="math inline">\(10^6\)</span>。</p><h2 id="输出">输出</h2><p>若小红可以恰好操作一次将<span class="math inline">\(s\)</span>变成<span class="math inline">\(t\)</span>，则输出<code>"YES"</code>，再输出选择的两种字母，否则输出<code>"NO"</code>。</p><p>如果有多种方案，请输出字典序最小的方案（第一种字母 ASCII码值尽可能小，若第一种字母 ASCII 码值相同，则第二种字母 ASCII码值尽可能小）。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">abab</span><br><span class="line">abba</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">YES</span><br><span class="line">a b</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">选择字母 &#x27;a&#x27; 、 &#x27;b&#x27; ，即可使 &quot;abab&quot; 变成 &quot;abba&quot;</span><br><span class="line">选择字母 &#x27;b&#x27; 、 &#x27;a&#x27; 也是答案，但此方案的字典序较大。</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>对于任意一个下标<span class="math inline">\(i\)</span>，如果<span class="math inline">\(s_i\neqt_i\)</span>，那么我们只能选择这一对字符<span class="math inline">\((s_i,t_i)\)</span>进行操作，如果只使用这一对字符进行操作仍然无法完成<span class="math inline">\(s=t\)</span>的目的，那么说明肯定还存在另一对和<span class="math inline">\((s_i,t_i)\)</span>不相同的字符串需要操作，这时肯定是无解的。如果能够达到<span class="math inline">\(s=t\)</span>的目的，那么<span class="math inline">\((s_i,t_i)\)</span>就是唯一解。</p><p>如果有多个解，那么唯有<span class="math inline">\(s=t\)</span>才可以做到。此时最小字典序的解为<span class="math inline">\((\texttt{a,b})\)</span>。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">s, t</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    v = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> s[i] != t[i]:</span><br><span class="line">            v = <span class="built_in">sorted</span>([s[i], t[i]])</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> v:</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">    s0 = <span class="built_in">set</span>(i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n) <span class="keyword">if</span> s[i] == v[<span class="number">0</span>])</span><br><span class="line">    s1 = <span class="built_in">set</span>(i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n) <span class="keyword">if</span> s[i] == v[<span class="number">1</span>])</span><br><span class="line">    t0 = <span class="built_in">set</span>(i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n) <span class="keyword">if</span> t[i] == v[<span class="number">0</span>])</span><br><span class="line">    t1 = <span class="built_in">set</span>(i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n) <span class="keyword">if</span> t[i] == v[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s0) == <span class="built_in">len</span>(t0) <span class="keyword">and</span> <span class="built_in">len</span>(s1) == <span class="built_in">len</span>(t1) <span class="keyword">and</span> (s0 | s1) == (t0 | t1):</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ans = solve(<span class="built_in">input</span>(), <span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">if</span> ans:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;YES\n&#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(ans[<span class="number">0</span>], ans[<span class="number">1</span>]))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;NO&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小红的树上染色">2、小红的树上染色</h1><p>小红有一棵<span class="math inline">\(n\)</span>个点的树，<span class="math inline">\(1\)</span>号点是根结点。树上的一些边需要被染色，小红每次可以选择一个点，将这个点到根结点的所有边染成红色。小红想知道，最少需要多少次操作，才能使得树上所有的边都被染成红色。</p><p>必须把所有需要染红的边染红，可以把一条边染色多次，也可以把不需要染色的边染成红色。</p><h2 id="输入-1">输入</h2><p>第一行一个整数<span class="math inline">\(n\)</span>，表示树上点的个数。</p><p>接下来<span class="math inline">\(n-1\)</span>行，每行三个整数<span class="math inline">\(u,v,c\)</span>，表示<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>之间有一条边，如果<span class="math inline">\(c=1\)</span>，表示这条边需要被染色，否则表示这条边可以不被染色。</p><ul><li><span class="math inline">\(2 \leq n \leq 10^5\)</span></li><li><span class="math inline">\(1 \leq u, v \leq n\)</span></li></ul><h2 id="输出-1">输出</h2><p>输出一个整数，表示最少需要的操作次数。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">1 2 1</span><br><span class="line">1 3 0</span><br><span class="line">2 4 1</span><br><span class="line">2 5 0</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">选择 4 号结点，把 (1, 2)，(2, 4) 染红。</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>基于贪心的思想，我们应该尽量选择深度足够深的节点进行染色。为了使得染色节点尽可能少，怎么做出这个选择呢？</p><p>如果一个节点<span class="math inline">\(u\)</span>连向它的父节点这条边必须被染色，但是<span class="math inline">\(u\)</span>的子树中，没有需要被染色的边，那么我们可以选择<span class="math inline">\(u\)</span>，这样子将使得<span class="math inline">\(u\)</span>到根中的所有边都会被进行染色。此外，选择<span class="math inline">\(u\)</span>的后代是没有必要的，因为选择它们的效果和选择<span class="math inline">\(u\)</span>相同。</p><p>由此我们只需要统计选择必须被选择的节点<span class="math inline">\(u\)</span>即可。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> pi pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;pi&gt;g[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [v,w]:g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> c=<span class="built_in">dfs</span>(v,u);</span><br><span class="line">        <span class="keyword">if</span>(w&amp;&amp;c==<span class="number">0</span>) ++ans;</span><br><span class="line">        cnt+=w+c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v,w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(<span class="built_in">pi</span>(v,w));</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(<span class="built_in">pi</span>(u,w));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小红的mex查询">3、小红的mex查询</h1><p>小红拿到了一个空集。她准备进行以下操作：将<span class="math inline">\([l,r]\)</span>区间的每个整数添加进集合。</p><p>请你在每次操作后，输出当前集合的<span class="math inline">\(\text{mex}\)</span>。我们定义，集合的<span class="math inline">\(\text{mex}\)</span>为：集合中最小的未出现的非负整数。</p><h2 id="输入-2">输入</h2><p>第一行输入一个正整数<span class="math inline">\(q\)</span>，代表操作次数。 接下来的<span class="math inline">\(q\)</span>行，每行输入两个正整数<span class="math inline">\(l,r\)</span>，代表一次操作。</p><ul><li><span class="math inline">\(1\leq q \leq 10^5\)</span></li><li><span class="math inline">\(1\leq l \leq r \leq 10^9\)</span></li></ul><h2 id="输出-2">输出</h2><p>输出<span class="math inline">\(q\)</span>行，每行输入一个整数，代表当前的集合<span class="math inline">\(\text{mex}\)</span>。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">4</span><br><span class="line">1 3</span><br><span class="line">7 8</span><br><span class="line">0 5</span><br><span class="line">3 6</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">6</span><br><span class="line">9</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">第一次操作后，集合为[1,2,3]，mex 为 0。</span><br><span class="line">第二次操作后，集合为[1,2,3,7,8]，mex 仍然是 0。</span><br><span class="line">第三次操作后，集合为[0,1,2,3,4,5,7,8]，mex 为 6。</span><br><span class="line">第四次操作后，集合为[0,1,2,3,4,5,6,7,8]，mex 为 9。</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>令第<span class="math inline">\(i\)</span>次操作表示为区间<span class="math inline">\([l_i,r_i]\)</span>。按照<span class="math inline">\(\text{mex}\)</span>的覆盖性质可以发现，一个候选的<span class="math inline">\(\text{mex}\)</span>值必定为集合<span class="math inline">\(U=\{r_i+1\midi\in[1,n]\}\cup\{0\}\)</span>，因为对于一个数<span class="math inline">\(k\)</span>，如果不存在<span class="math inline">\(i\)</span>使得<span class="math inline">\(r_i+1=k\)</span>，那么有两种情况：</p><ul><li><span class="math inline">\(k\)</span>不被任何一个区间所覆盖，但是<span class="math inline">\(k-1\)</span>也将不会被任何一个区间所覆盖。因此<span class="math inline">\(k\)</span>必定不是一个<span class="math inline">\(\text{mex}\)</span>值。</li><li><span class="math inline">\(k\)</span>被任何一个区间所覆盖，因此<span class="math inline">\(k\)</span>必定不是一个<span class="math inline">\(\text{mex}\)</span>值。</li></ul><p>因此，每对一个区间<span class="math inline">\([l_i,r_i]\)</span>进行操作后，将原本集合<span class="math inline">\(U\)</span>中区间<span class="math inline">\([l_i,r_i]\)</span>内的所有元素删除即可。最终输出<span class="math inline">\(S\)</span>中的最小值即可。</p><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l[N],r[N],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt;st&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;l[i],&amp;r[i]);++r[i];</span><br><span class="line">        st.<span class="built_in">insert</span>(r[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">auto</span> it=st.<span class="built_in">lower_bound</span>(l[i]);</span><br><span class="line">            <span class="keyword">if</span>(it==st.<span class="built_in">end</span>()||*it&gt;=r[i]) <span class="keyword">break</span>;</span><br><span class="line">            st.<span class="built_in">erase</span>(it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*st.<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小红的字符串回文值">4、小红的字符串回文值</h1><p>小红有一个字符串<span class="math inline">\(s\)</span>，她想知道这个字符串中字典序最大的后缀、字典序最小的后缀的回文值分别是多少。</p><p>字符串的回文值定义为：字符串的最长回文子串长度。</p><h2 id="输入-3">输入</h2><p>第一行输入一个字符串，字符串长度不超过<span class="math inline">\(2\times 10^5\)</span>。</p><h2 id="输出-3">输出</h2><p>输出两个整数表示答案。</p><h2 id="样例-3">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">abc</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1 1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">字典序最大的后缀为&quot;c&quot;，回文值为1</span><br><span class="line">字典序最小的后缀为&quot;abc&quot;，回文值为1</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">ababa</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">3 1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">字典序最大的后缀为&quot;baba&quot;，回文值为3（最大回文子串为 &quot;bab&quot; 或 &quot;aba&quot; ）</span><br><span class="line">字典序最小的后缀为&quot;a&quot;，回文值为1</span><br></pre></td></tr></table></figure><h2 id="解答-3">解答</h2><p>本题将分为两个部分进行求解。</p><p>第一部分是找到两个字典序最大和最小的后缀。这题可以直接使用后缀数组进行解决，不过这不在考察范围内。对于一对后缀<span class="math inline">\((i,j)\)</span>，我们可以使用字符串哈希，通过二分找到最小的正整数<span class="math inline">\(l\)</span>使得<span class="math inline">\(s_{i+l-1}\neq s_{j+l-1}\)</span>，并比较<span class="math inline">\(s_{i+l-1}\)</span>和<span class="math inline">\(s_{j+l-1}\)</span>的顺序，从而比较出这两个后缀的字典序大小。如果不存在<span class="math inline">\(l\)</span>，那么说明<span class="math inline">\(i,j\)</span>中其中一个是另一个的前缀，因此长度较小的那个后缀字典序比较小。</p><p>最终通过哈希算法求解字典序最大和最小的后缀。</p><p>第二部分是找到一个字符串的最长回文字符串长度，这个问题可以使用Manachar算法直接解决。也可以使用二分法和哈希法完成，具体做法是预处理出这个字符串的前缀哈希值和后缀哈希值，使用中心扩展法进行二分即可。</p><h2 id="代码-3">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200004</span>;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">ull pw[N],hs[N],B=<span class="number">131</span>;</span><br><span class="line"><span class="function">ull <span class="title">geths</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hs[r]-hs[l<span class="number">-1</span>]*pw[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lt</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m=n-y+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">geths</span>(x,x+mid<span class="number">-1</span>)!=<span class="built_in">geths</span>(y,y+mid<span class="number">-1</span>)) r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l==m+<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> s[x+l<span class="number">-1</span>]&lt;s[y+l<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(string t)</span></span>&#123;</span><br><span class="line">    string s=<span class="string">&quot;#&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> ch:t)&#123;</span><br><span class="line">        s+=ch;s+=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">d</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,l=<span class="number">0</span>,r=<span class="number">-1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> k=(i&gt;r?<span class="number">1</span>:<span class="built_in">min</span>(d[l+r-i],r-i+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(;<span class="number">0</span>&lt;=i-k&amp;&amp;i+k&lt;n&amp;&amp;s[i-k]==s[i+k];k++);</span><br><span class="line">        d[i]=k--;</span><br><span class="line">        <span class="keyword">if</span>(i+k&gt;r)&#123;</span><br><span class="line">            l=i-k;</span><br><span class="line">            r=i+k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k=*<span class="built_in">max_element</span>(d.<span class="built_in">begin</span>(),d.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> k<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    pw[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        pw[i]=pw[i<span class="number">-1</span>]*B;</span><br><span class="line">        hs[i]=hs[i<span class="number">-1</span>]*B+s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mx=<span class="number">1</span>,mn=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">lt</span>(mn,i)) mn=i;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">lt</span>(mx,i)) mx=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,<span class="built_in">solve</span>(<span class="built_in">string</span>(s+mx,s+n+<span class="number">1</span>)),<span class="built_in">solve</span>(<span class="built_in">string</span>(s+mn,s+n+<span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>华为 秋招 2023.10.11 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Huawei-20231011/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Huawei-20231011/</id>
    <published>2023-10-12T16:41:00.000Z</published>
    <updated>2023-10-12T16:41:00.839Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="计算最少流控请求数">1、计算最少流控请求数</h1><p>服务器性能有限，对于突发请求，有时需要通过流控保护系统不受冲击。假设某服务器的系统要求任意<span class="math inline">\(M\)</span>分钟内只能处理<span class="math inline">\(N\)</span>条请求，超出的请求必须流控掉。已知连续<span class="math inline">\(X\)</span>分钟，每分钟的实际请求数，请给出至少流控掉多少请求，才能保证上述系统不受冲击。</p><h2 id="输入">输入</h2><p>第一行：<span class="math inline">\(M\)</span>和<span class="math inline">\(N\)</span>，<span class="math inline">\(M\)</span>范围<span class="math inline">\([1,10]\)</span>；<span class="math inline">\(N\)</span>的范围<span class="math inline">\([0,10000]\)</span></p><p>第二行：连续分钟数<span class="math inline">\(X\)</span>，<span class="math inline">\(X\)</span>范围为<span class="math inline">\([1,100000]\)</span></p><p>第三行：每分钟的请求数范围<span class="math inline">\([0,1000]\)</span></p><h2 id="输出">输出</h2><p>最少可以流控的请求数。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">4 6</span><br><span class="line">6</span><br><span class="line">2 1 2 2 3 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">第一行系统要求：每4分钟只能接受6个请求。</span><br><span class="line">第二行：连续6分钟。</span><br><span class="line">第三行：每分钟的实际请求数。</span><br><span class="line">至少流控3个请求(可以是： 第4分钟流控1个请求，第5分钟流控1个请求，第6分钟流控1个请求)，才可以满足系统4分钟内只能处理6条请求的要求。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">2 10</span><br><span class="line">6</span><br><span class="line">1 9 1 9 8 2</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">第一行系统要求：每2分钟只能接受10个请求</span><br><span class="line">第二行：连续6分钟。</span><br><span class="line">第三行：每分钟的实际请求数。</span><br><span class="line">至少流控7个请求(可以是第5分钟流控7个请求)，才可以满足系统2分钟内只能外理10条请求的要求。</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>这题可以使用贪心轻易解决。从小到大枚举每个长度为<span class="math inline">\(m\)</span>的区间，如果当前确实必须要流控一些请求，那么按照贪心的思想，应该优先流控掉这些请求，这确保了后面的请求能过尽量少流控一些。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"><span class="type">int</span> a[N],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n,x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;m,&amp;n,&amp;x);</span><br><span class="line">    m=<span class="built_in">min</span>(m,x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x;i++)</span><br><span class="line">        sum+=a[i];</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">        s+=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m;i&lt;=x;i++)&#123;</span><br><span class="line">        s+=a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&gt;=i-m+<span class="number">1</span>&amp;&amp;s&gt;n;j--)&#123;</span><br><span class="line">            <span class="type">int</span> v=<span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">min</span>(s-n,a[j]));</span><br><span class="line">            a[j]-=v;s-=v;</span><br><span class="line">        &#125;</span><br><span class="line">        s-=a[i-m+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sum2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x;i++)sum2+=a[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum-sum2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="快乐时间">2、快乐时间</h1><p>小明在工作之余喜欢在电子书城阅读不同的书籍并且获得最大的满足感，因此根据书城针对每本书籍的评分收集了<span class="math inline">\(n\)</span>个书籍的打分清单<code>books</code>，例如第一本书的打分<code>books[0]=5</code>代表该书的满意程度为<span class="math inline">\(5\)</span>，第二本书<code>books[1]=-2</code>代表该书的满意程度为<span class="math inline">\(-2\)</span>。</p><p>阅读每本书花费的都是<span class="math inline">\(1\)</span>单位时间，<code>time</code>定义为阅读本书及之前所有书的时间之和。因此第一本阅读的书籍<code>time[0]=1</code>，第二本阅读的书籍<code>time[1]=2</code>，第三本阅读的书籍<code>time[2]=3</code>并以此类推。</p><p>每本书籍的【快乐时间】系数为阅读该书籍和之前每本书籍所花费的时间乘以对这本书籍的满意程度，即<code>time[i] * books[i]</code>，其中<span class="math inline">\(i\)</span>从<span class="math inline">\(0\)</span>开始。</p><p>小明想了解自己如何安排阅读计划才能获得最大的快乐时间，请帮忙计算一下阅读给定书籍【快乐时间】总和最大的值是多少，可以按照任意顺序调整阅读书籍顺序（即每本书对应的<code>time[i]</code>是可以对调的），也可以放弃阅读某些书籍。</p><h2 id="输入-1">输入</h2><p>输入为字符串，字符串内容为代表每本书籍的喜爱指数，例如<code>books = [4,3,2]</code>，其中<span class="math inline">\(1\le n\le -500\)</span>，满意程度 <span class="math inline">\(-1000 \le \texttt{books[i]}\le-1000\)</span>。</p><h2 id="输出-1">输出</h2><p>输出为数字，代表最大的快乐时间，例如<span class="math inline">\(20\)</span>，按照原来顺序相反的时间阅读书籍<span class="math inline">\((2\times 1 + 3\times2 + 4\times3 =20)\)</span>，评分越高的书籍越后面阅读可以获得最大的快乐时间。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">4,3,2</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">20</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">按照原来顺序相反的时间阅读书籍(2 * 1 + 3 * 2 + 4 * 3 = 20)，评分越高的书籍越后面阅读可以获得最大的快乐时间。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">-1,-4,-5</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">大家对于这些书籍评分都很低，所以不阅读任何书籍可以获得最大的快乐时间。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">-1,-8,0,5,-9</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">14</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">去掉第二个和最后一本书籍，最大的快乐时间系数和为(-1 * 1 + 0 * 2 + 5 * 3 = 14)。每本书籍都需要花费1单位时间来阅读。</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>这题是一道经典的贪心题。由于快乐值前面的系数<code>time[i]</code>都是非负整数，因此如果需要不选择一些书，那么优先去掉满意度最小的那些书。那么问题转化为最大值<span class="math inline">\(s=\displaystyle{\sum_{i=1}^m i\cdota_i}\)</span>，其中<span class="math inline">\(a_i\)</span>是被选定书籍的评分。可以发现，当我们<span class="math inline">\(a_i\)</span>是不下降的时候，<span class="math inline">\(s\)</span>值能过取得最大，因为如果存在一对<span class="math inline">\(a_j,a_i(j&lt;i)\)</span>使得<span class="math inline">\(a_j&gt;a_i\)</span>，交换它们会使得答案更优。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"><span class="type">int</span> a[N],n=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> &amp;ch:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isdigit</span>(ch)&amp;&amp;ch!=<span class="string">&#x27;-&#x27;</span>) ch=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    ss&lt;&lt;s;</span><br><span class="line">    <span class="keyword">while</span>(ss&gt;&gt;s)&#123;</span><br><span class="line">        a[++n]=<span class="built_in">atoi</span>(s.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="type">int</span> s1=<span class="number">0</span>,s2=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        s1+=a[i];</span><br><span class="line">        s2+=s1;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,s2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="稀疏存储">3、稀疏存储</h1><p>在虚拟化技术、芯片仿真器等领域，存在一种场景，即实际读写的数据量比较小，但要求可访问的地址空间却很大(要求4GB、甚至128GB地址空间)。</p><p>实现一个地址范围为32G的，可在该地址范围内任意位置读写数据的虚拟化内存机制(数据默认清零)。</p><p>对应功能：</p><ol type="1"><li>读取任意地址数据；</li><li>往任意地址写入任意数据；</li><li>清空数据，并释放内存。</li></ol><p>输入格式： <code>Command Address Length Data</code></p><p>解释：</p><ol type="1"><li><code>Command</code>为<code>Read</code>、<code>Write</code>、<code>Clear</code>之一；</li><li><code>Address</code>采用64位无符号十六进制数，全大写；</li><li><code>Length</code>采用64位无符号十进制数，单位为“字节”；</li><li><code>Data</code>采用字节流(2个16进制数表示一个<code>Byte</code>)，全大写；</li><li>如果指定的<code>Length</code>大于实际给定的<code>Data</code>，需要程序自行未尾补0，小于则未尾截断。</li></ol><h2 id="输入-2">输入</h2><p>每条指令一行，一个用例输入可以是多条指令混合，只有<code>Read</code>指令有输出。</p><p>每个用例保证指令、参数格式正确，但不保证参数范围，需要程序按照题目规格要求自行校验，参数不合法，则对应的指令无效。</p><p>每个用例保证需要存储的总数据量最大不超过<code>16MB</code>。一个用例最多不超过<span class="math inline">\(500\)</span>条指令。</p><p>例如（3表示有3条指令）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">Write 0x100 7 001122AA</span><br><span class="line">Read 0x100 4</span><br><span class="line">Clear</span><br></pre></td></tr></table></figure><h2 id="输出-2">输出</h2><p>采用字节流 (2个16进制数表示一个<code>Byte</code>)，全大写。</p><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">001122AA</span><br></pre></td></tr></table></figure><p>每条<code>Read</code>指令对应一行输出数据，如果指令给的参数不合法，对应的输出为空（不换行）。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">1</span><br><span class="line">Read 0x100 4</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">00000000</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0x100地址空间未被写入数据，默认返回全0，一共4个字节。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">Write 0x100 8 00001122AABBCCDD</span><br><span class="line">Read 0x100 12</span><br><span class="line">Clear</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">00001122AABBCCDD00000000</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0x100地址，前8个字节被写入了有效数据00001122AABBCCDD，读取0x100地址12个字节数据，后4个字节补齐默认数据0，因此结果为00001122AABBCCDDO0000000。</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>这题的地址值上限为32G，即地址范围是<span class="math inline">\(0\sim2^{35}-1\)</span>，令<span class="math inline">\(M=2^{35}\)</span>。</p><p>为了方便操作，这里直接使用一个字典来存储对应位置的字节值（由于存储的数据量不超过16MB，因此字典最多只有<span class="math inline">\(2^{24}\)</span>个项，在接受范围之内），每次进行<code>Clear</code>操作就清空字典，执行<code>Write</code>操作时，将每个字节对应的位置直接写入即可；在进行<code>Read</code>操作时，直接从字典中取值，如果取不到，那么用<code>00</code>字节替代。</p><p>以下是本代码校验时需要注意的地方：</p><ul><li><code>Write</code>操作时，需要注意给定字节串的长度是否为偶数。</li><li><code>Write</code>操作和<code>Read</code>操作时，需要判断地址是否产生溢出，以及输入的长度<code>Length</code>是否是一个非负整数。</li><li><code>Read</code>操作时，如果<code>Length</code>的值为<span class="math inline">\(0\)</span>，那么不进行任何操作。</li></ul><h2 id="代码-2">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">mp = <span class="built_in">dict</span>()</span><br><span class="line">MAX = <span class="number">32</span> &lt;&lt; <span class="number">30</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    ls = <span class="built_in">input</span>().split()</span><br><span class="line">    <span class="keyword">if</span> ls[<span class="number">0</span>] == <span class="string">&#x27;Clear&#x27;</span>:</span><br><span class="line">        mp.clear()</span><br><span class="line">    <span class="keyword">elif</span> ls[<span class="number">0</span>] == <span class="string">&#x27;Write&#x27;</span>:</span><br><span class="line">        add, sz, s = <span class="built_in">int</span>(ls[<span class="number">1</span>][<span class="number">2</span>:], <span class="number">16</span>), <span class="built_in">int</span>(ls[<span class="number">2</span>]), ls[<span class="number">3</span>]</span><br><span class="line">        <span class="keyword">if</span> sz &lt; <span class="number">0</span> <span class="keyword">or</span> add + sz - <span class="number">1</span> &gt;= MAX <span class="keyword">or</span> <span class="built_in">len</span>(s) &amp; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        sz = <span class="built_in">min</span>(sz, <span class="built_in">len</span>(s) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        s = s[:sz &lt;&lt; <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(sz):</span><br><span class="line">            mp[add + i] = s[i &lt;&lt; <span class="number">1</span>:i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">elif</span> ls[<span class="number">0</span>] == <span class="string">&quot;Read&quot;</span>:</span><br><span class="line">        add, sz = <span class="built_in">int</span>(ls[<span class="number">1</span>][<span class="number">2</span>:], <span class="number">16</span>), <span class="built_in">int</span>(ls[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">if</span> sz &lt;= <span class="number">0</span> <span class="keyword">or</span> add + sz - <span class="number">1</span> &gt;= MAX:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(sz):</span><br><span class="line">            <span class="built_in">print</span>(mp.get(add + i, <span class="string">&quot;00&quot;</span>), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>携程 秋招 2023.10.10 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Xiecheng-20231010/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Xiecheng-20231010/</id>
    <published>2023-10-11T10:56:04.000Z</published>
    <updated>2023-10-11T10:56:04.619Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="游游修改01串">1、游游修改<code>01</code>串</h1><p>游游拿到了一个<code>01</code>串，她最多可以修改字符串中的一个位置(即<code>'0'</code>变<code>'1'</code>，或<code>'1'</code>变<code>'0'</code>)。游游希望修改后字符串包含尽可能多的长度为<span class="math inline">\(3\)</span>的回文子串。你能帮帮她吗？</p><h2 id="输入">输入</h2><p>一个仅包含<code>'0'</code>和<code>'1'</code>的字符串，长度不超过<span class="math inline">\(10^5\)</span>。</p><h2 id="输出">输出</h2><p>一个整数，代表修改后的回文子串数量。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">01101</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>一个长度为<span class="math inline">\(3\)</span>的字符串<span class="math inline">\(t=t_1t_2t_3\)</span>是回文串当且仅当<span class="math inline">\(t_1=t_3\)</span>。</p><p>因此，首先统计当前输入的字符串<span class="math inline">\(s\)</span>有多少个长度为<span class="math inline">\(3\)</span>的回文串，并记录其值为<span class="math inline">\(v\)</span>。如果要修改字符<span class="math inline">\(s[i]\)</span>，那么只会影响子串<span class="math inline">\(s[i-2:i]\)</span>和<span class="math inline">\(s[i:i+2]\)</span>是否为回文串这个状态发生变化。因此改变<span class="math inline">\(s[i]\)</span>后，重新统计受影响的位置中的变化即可，最终取最大值。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">n = <span class="built_in">len</span>(s)</span><br><span class="line">v = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> s[i - <span class="number">1</span>] == s[i + <span class="number">1</span>]:</span><br><span class="line">        v += <span class="number">1</span></span><br><span class="line">mx = v</span><br><span class="line">s = <span class="built_in">list</span>(<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> s)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    k = i - <span class="number">1</span></span><br><span class="line">    w = v</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> [i - <span class="number">1</span>, i + <span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="number">1</span> &lt;= k &lt; n - <span class="number">1</span> <span class="keyword">and</span> s[k - <span class="number">1</span>] == s[k + <span class="number">1</span>]:</span><br><span class="line">            w -= <span class="number">1</span></span><br><span class="line">    s[i] ^= <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> [i - <span class="number">1</span>, i + <span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="number">1</span> &lt;= k &lt; n - <span class="number">1</span> <span class="keyword">and</span> s[k - <span class="number">1</span>] == s[k + <span class="number">1</span>]:</span><br><span class="line">            w += <span class="number">1</span></span><br><span class="line">    mx = <span class="built_in">max</span>(mx, w)</span><br><span class="line">    s[i] ^= <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(mx)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="游游的分治">2、游游的分治</h1><p>二维平面上有<span class="math inline">\(n\)</span>个点。游游准备用以下的分治手段查找出某个点。</p><ol type="1"><li><p>按横坐标从小到大排序，横坐标相等的按纵坐标从小到大排序。将排好序的点数组分成数量尽可能接近的两部分（如果此时共有奇数个点，那么第一部分的数量比第二部分少<span class="math inline">\(1\)</span>）。查找指定点在第一部分还是第二部分。</p></li><li><p>按纵坐标从小到大排序，纵坐标相等的按横坐标从小到大排序。将排好序的点数组分成数量尽可能接近的两部分（如果此时共有奇数个点，那么第一部分的数量比第二部分少<span class="math inline">\(1\)</span>）。查找指定点在第一部分还是第二部分。</p></li><li><p>回到第一步重复下去。直到最终只剩一个点时跳出。</p></li></ol><p>请你模拟游游的分治过程。</p><h2 id="输入-1">输入</h2><p>第一行输入两个正整数<span class="math inline">\(n,x\)</span>，代表点的数量、以及需要查找第几个点。</p><p>接下来的<span class="math inline">\(n\)</span>行，每行输入两个整数<span class="math inline">\(x_i,y_i\)</span>，代表点的坐标。</p><ul><li><span class="math inline">\(1 \le n \le 1000\)</span></li><li><span class="math inline">\(-10^9\le x_i,y_i\le 10^9\)</span></li></ul><h2 id="输出-1">输出</h2><p>输出一个字符串，代表每次查找的结果。</p><ol type="1"><li>如果该次查到的在第一部分，输出<code>'L'</code>。</li><li>如果该次查到的在第二部分，输出<code>'R'</code>。</li><li>如果该次查找仅包含一个点，输出<code>'O'</code>。</li></ol><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">4 2</span><br><span class="line">-1 3</span><br><span class="line">3 5</span><br><span class="line">2 6</span><br><span class="line">4 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">RRO</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>按照题目的要求进行即可。第<span class="math inline">\(i\)</span>次的搜索使用的排序规则为第<span class="math inline">\(i\bmod2\)</span>条，并舍弃另一半未被搜索的点。</p><h2 id="代码-1">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">n, x = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">a = []</span><br><span class="line">f = [<span class="keyword">lambda</span> t: t, <span class="keyword">lambda</span> t: (t[<span class="number">1</span>], t[<span class="number">0</span>])]</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    a.append(<span class="built_in">tuple</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">t = a[x - <span class="number">1</span>]</span><br><span class="line">s = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    a.sort(key=f[k &amp; <span class="number">1</span>])</span><br><span class="line">    m = <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="keyword">if</span> m == <span class="number">1</span>:</span><br><span class="line">        s += <span class="string">&quot;O&quot;</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    l, r = a[:m &gt;&gt; <span class="number">1</span>], a[m &gt;&gt; <span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">if</span> t <span class="keyword">in</span> l:</span><br><span class="line">        s += <span class="string">&quot;L&quot;</span></span><br><span class="line">        a = l</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        s += <span class="string">&quot;R&quot;</span></span><br><span class="line">        a = r</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><h1 id="游游的字符串">3、游游的字符串</h1><p>游游拿到了一个字符申，她每次接作可以梅一个字裤修改为其字母表上相邻的字母，例如<code>'a'</code>修改为<code>'b'</code>，<code>'e'</code>修改为<code>'d'</code>等。</p><p>游游希望最终字符串每个相邻字符都不相等，她想知道最终最少操作多少次？请你给出任意一个修改后的方案。</p><h2 id="输入-2">输入</h2><p>输入仅包含一行由英文小写字母组成的字符串，长度不超过<span class="math inline">\(10^5\)</span>。</p><h2 id="输出-2">输出</h2><p>第一行输出一个整数，代表最少的修改次数。</p><p>第二行输出一个字符串，代表修改后的字符串。有多解时输出任意即 可。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">aabcc</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2</span><br><span class="line">babcb</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>一个字符可以改成它字母表上相邻的字符，我们可以将第<span class="math inline">\(i\)</span>个字符最终变成另一个字符视为是一种决策，这些决策集合用<span class="math inline">\(O_i\)</span>来表示，<span class="math inline">\(o_{i,j}\)</span>表示选择的是第<span class="math inline">\(j\)</span>种决策表示的字符。</p><p>由于当前字母的决策只取决于前一个字母，因此这题我们使用动态规划不难解决。令<span class="math inline">\(s\)</span>表示输入的字符串，状态<span class="math inline">\(f(i,j)(1\le i\le n,1\le j\le|O_i|)\)</span>表示保证前<span class="math inline">\(i\)</span>个字符已经不相同的情况下，第<span class="math inline">\(i\)</span>个字符为<span class="math inline">\(o_{i,j}\)</span>所需要的最小操作次数。那么可以写出如下状态转移方程：</p><p><span class="math inline">\(f(i,j)= \left\{\begin{aligned}  &amp;[o_{i,j}\neq s_i] &amp; &amp; \text{if}\quad i=1\\  &amp;\min_{\substack{1\le k\le |O_{i-1}|\\o_{i-1,k}\neqo_{i,j}}}\{f(i-1,k)+[o_{i,j}\neq s_i]\} &amp; &amp; \text{if}\quadi&gt;1 \\ \end{aligned}\right.\)</span></p><p>其中，示性函数<span class="math inline">\([b]\)</span>表示布尔表达式<span class="math inline">\(b\)</span>如果成立，那么其值为<span class="math inline">\(1\)</span>，否则为<span class="math inline">\(0\)</span>。为了记录最优决策，我们还要记录当前状态是由<span class="math inline">\(f(i-1,\cdot)\)</span>的哪个状态转移而来，在最后构造方案时，根据记录情况，从后往前进行构造即可。</p><p>因此，最终答案为<span class="math inline">\(\displaystyle{\min_{j=1}^{|O_n|}\{f(n,j)\}}\)</span>。</p><h2 id="代码-2">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">n = <span class="built_in">len</span>(s)</span><br><span class="line"></span><br><span class="line">op = [<span class="string">&quot;&quot;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">if</span> s[i] == <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">        op[i] = <span class="string">&#x27;ab&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> s[i] == <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">        op[i] = <span class="string">&#x27;yz&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        k = <span class="built_in">ord</span>(s[i])</span><br><span class="line">        op[i] = <span class="built_in">chr</span>(k - <span class="number">1</span>) + <span class="built_in">chr</span>(k) + <span class="built_in">chr</span>(k + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">f = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(op[i]))] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">pre = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(op[i]))] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(op[<span class="number">0</span>])):</span><br><span class="line">    f[<span class="number">0</span>][j] = <span class="built_in">int</span>(op[<span class="number">0</span>][j] != s[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(op[i])):</span><br><span class="line">        f[i][j] = <span class="number">10</span> ** <span class="number">10</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(op[i - <span class="number">1</span>])):</span><br><span class="line">            <span class="keyword">if</span> op[i - <span class="number">1</span>][k] != op[i][j]:</span><br><span class="line">                v = f[i - <span class="number">1</span>][k] + <span class="built_in">int</span>(op[i][j] != s[i])</span><br><span class="line">                <span class="keyword">if</span> v &lt; f[i][j]:</span><br><span class="line">                    f[i][j] = v</span><br><span class="line">                    pre[i][j] = k</span><br><span class="line"></span><br><span class="line">k = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(op[-<span class="number">1</span>])):</span><br><span class="line">    <span class="keyword">if</span> f[-<span class="number">1</span>][j] &lt; f[-<span class="number">1</span>][k]:</span><br><span class="line">        k = j</span><br><span class="line"><span class="built_in">print</span>(f[-<span class="number">1</span>][k])</span><br><span class="line">ans = [<span class="string">&quot;&quot;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    ans[i] = op[i][k]</span><br><span class="line">    k = pre[i][k]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(ans))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="游游的树">4、游游的树</h1><p>游游拿到了一棵树，其中每个节点被染成了红色(<code>r</code>)、绿色(<code>g</code>)或蓝色(<code>b</code>)。</p><p>游游想选择一条长度为<span class="math inline">\(3\)</span>的简单路径，满足该路径上的四个点恰好共有<span class="math inline">\(3\)</span>种颜色。</p><p>游游想知道，可以选择多少不同的路径？我们认为，点<span class="math inline">\(p\)</span>到点<span class="math inline">\(q\)</span>，点<span class="math inline">\(q\)</span>到点<span class="math inline">\(p\)</span>这两条路径为同一条。</p><p>注：树指不含重边和自环的无向连通图。</p><h2 id="输入-3">输入</h2><p>第一行输入一个正整数<span class="math inline">\(n\)</span>，代表树的节点数量。</p><p>第二行输入一个长度为<span class="math inline">\(n\)</span>的、仅包含<code>'r'</code>、<code>'g'</code>、<code>'b'</code>三种字符的字符串，第<span class="math inline">\(i\)</span>个字符表示节点<span class="math inline">\(i\)</span>的颜色。</p><p>接下来的<span class="math inline">\(n-1\)</span>行，每行输入两个正整数<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>，代表点<span class="math inline">\(u\)</span>和点<span class="math inline">\(v\)</span>有一条无向边连接。</p><ul><li><span class="math inline">\(3\le n\le 10^5\)</span></li><li><span class="math inline">\(1\le u,v\le n\)</span></li></ul><h2 id="输出-3">输出</h2><p>一个整数，代表不同路径的数量。</p><h2 id="样例-3">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">4</span><br><span class="line">rgbg</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">只有一种选择：选择1-2-3-4路径</span><br></pre></td></tr></table></figure><h2 id="解答-3">解答</h2><p>由于长度的路径只有<span class="math inline">\(3\)</span>，因此我们可以用贡献法进行解决，枚举每一边作为路径的中间那条边，计算路径数，并添加到答案中。</p><p>为了表达上和编码上的方便，我们分别将三种颜色映射成三个数字<span class="math inline">\(0,1,2\)</span>。令<span class="math inline">\(a_u\)</span>表示节点<span class="math inline">\(u\)</span>的颜色，令<span class="math inline">\(c_{u,k}\)</span>表示节点<span class="math inline">\(u\)</span>有多少个相邻节点的颜色是<span class="math inline">\(k\)</span>，令<span class="math inline">\(d_u\)</span>表示节点<span class="math inline">\(u\)</span>的度数。接下来对每条边<span class="math inline">\(u,v\)</span>分两种情况进行讨论：</p><ul><li><p>如果<span class="math inline">\(a_u=a_v\)</span>，那么说明<span class="math inline">\(u\)</span>的另一个邻居<span class="math inline">\(x\)</span>和<span class="math inline">\(v\)</span>的另一个邻居<span class="math inline">\(y\)</span>必须是剩下的两种颜色。设这两种颜色分别为<span class="math inline">\(c_1\)</span>和<span class="math inline">\(c_2\)</span>，那么要么<span class="math inline">\(x\)</span>的颜色为<span class="math inline">\(c_1\)</span>，<span class="math inline">\(y\)</span>的颜色为<span class="math inline">\(c_2\)</span>；要么<span class="math inline">\(x\)</span>的颜色为<span class="math inline">\(c_2\)</span>，<span class="math inline">\(y\)</span>的颜色为<span class="math inline">\(c_1\)</span>，因此这条边总共做出的贡献为<span class="math inline">\(c_{u,c_1}\times c_{v,c_2}+c_{u,c_2}\timesc_{v,c_1}\)</span>。</p></li><li><p>如果<span class="math inline">\(a_u\neq a_v\)</span>，令<span class="math inline">\(c_0\)</span>是除去<span class="math inline">\(a_u\)</span>和<span class="math inline">\(a_v\)</span>的剩下的第三种颜色，那么<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>中必定有一个颜色是<span class="math inline">\(c_0\)</span>，另一个节点颜色随意，那么可以看出这部分做出的贡献为<span class="math inline">\(c_{u,c_0}\times(d_v-1)+c_{v,c_0}\times(d_u-1)-c_{u,c_0}\times c_{v,c_0}\)</span>，其中，前两项里面的<span class="math inline">\(-1\)</span>在于避免这条路径又回到这条边的另一个节点，从而避免把有重复节点的路径统计进去。第三项在于前面的一项将两端都是颜色c_0的情况重复计算了，需要减回去。</p></li></ul><p>因此直接累计答案即可。</p><h2 id="代码-3">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">cnt = [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">g = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">mp = &#123;<span class="string">&#x27;r&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;g&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">col = [mp[c] <span class="keyword">for</span> c <span class="keyword">in</span> s]</span><br><span class="line"></span><br><span class="line">edge = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">    x, y = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x) - <span class="number">1</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    g[x].append(y)</span><br><span class="line">    g[y].append(x)</span><br><span class="line">    edge.append((x, y))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> g[i]:</span><br><span class="line">        cnt[i][col[j]] += <span class="number">1</span></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> u, v <span class="keyword">in</span> edge:</span><br><span class="line">    <span class="keyword">if</span> col[u] == col[v]:</span><br><span class="line">        c1 = <span class="number">1</span> <span class="keyword">if</span> col[u] == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        c2 = <span class="number">3</span> - c1 - col[u]</span><br><span class="line">        ans += cnt[u][c1] * cnt[v][c2] + cnt[u][c2] * cnt[v][c1]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        c = <span class="number">3</span> - col[u] - col[v]</span><br><span class="line">        ans += cnt[u][c] * (<span class="built_in">len</span>(g[v]) - <span class="number">1</span>) + cnt[v][c] * (<span class="built_in">len</span>(g[u]) - <span class="number">1</span>) - cnt[u][c] * cnt[v][c]</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>度小满 秋招 2023.10.09 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Duxiaoman-20231009/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Duxiaoman-20231009/</id>
    <published>2023-10-11T10:56:01.000Z</published>
    <updated>2023-10-11T10:56:01.276Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="accept">1、accept</h1><p>给一个<span class="math inline">\(n\timesm\)</span>的字符矩阵，请你判断将矩阵中的某一行按从左向右顺序或者某一列按从上到下顺序取出作为一个字符串后，该字符串中是否存在子串<code>"accept"</code>。</p><h2 id="输入">输入</h2><p>第一行包含一个正整数<span class="math inline">\(T\)</span>，表示数据组数。</p><p>接下来包含<span class="math inline">\(T\)</span>组数据，对于每组数据：</p><p>第一行包含两个正整数<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>，表示矩阵的行数和列数。</p><p>接下来<span class="math inline">\(n\)</span>行，每行一个长度为<span class="math inline">\(m\)</span>的字符串，表示矩阵每一行中的内容。</p><p>保证所有字符均为小写英文字符。</p><p><span class="math inline">\(100\%\)</span>的数据保证：<span class="math inline">\(1\le T\le 10,1\le n,m\le 100\)</span></p><h2 id="输出">输出</h2><p>对于每组数据，如果存在则输出<code>"YES"</code>否则输出<code>"NO"</code>。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">2</span><br><span class="line">10</span><br><span class="line">dc</span><br><span class="line">ac</span><br><span class="line">ca</span><br><span class="line">ec</span><br><span class="line">cc</span><br><span class="line">qe</span><br><span class="line">gp</span><br><span class="line">ht</span><br><span class="line">ee</span><br><span class="line">pd</span><br><span class="line">2 10</span><br><span class="line">dscacceptd</span><br><span class="line">pqoxaccepw</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">第一组数据中，第二列中包舍了&quot;accept&quot;子串。</span><br><span class="line">第二组数据中，第一行中包含了“accept&quot;子串。</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>首先枚举<code>"accept"</code>或者是其逆序<code>"tpecca"</code>是否在字符矩阵的每一行存在即可，可以使用内置的库完成。</p><p>至于纵向的处理，只需要将这个字符矩阵进行转置，再进行和刚刚相同的操作即可。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">p1 = <span class="string">&quot;accept&quot;</span></span><br><span class="line">p2 = p1[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">ls</span>):</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> ls:</span><br><span class="line">        <span class="keyword">if</span> p1 <span class="keyword">in</span> s <span class="keyword">or</span> p2 <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    n, m = <span class="built_in">len</span>(ls), <span class="built_in">len</span>(ls[<span class="number">0</span>])</span><br><span class="line">    lt = [<span class="string">&quot;&quot;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            lt[j] += ls[i][j]</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> lt:</span><br><span class="line">        <span class="keyword">if</span> p1 <span class="keyword">in</span> s <span class="keyword">or</span> p2 <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    ls = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        ls.append(<span class="built_in">input</span>())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;YES&quot;</span> <span class="keyword">if</span> solve(ls) <span class="keyword">else</span> <span class="string">&quot;NO&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="数组排序">2、数组排序</h1><p>给定一个长度为<span class="math inline">\(n\)</span>的数组<span class="math inline">\(A\)</span>，数组下标为<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>，第<span class="math inline">\(i\)</span>个数记为<span class="math inline">\(a_i\)</span>，保证<span class="math inline">\(A\)</span>数组是<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>的一个排列。现在，小明将对<span class="math inline">\(A\)</span>数组按顺序进行<span class="math inline">\(m\)</span>次操作来对<span class="math inline">\(A\)</span>数组排序。第<span class="math inline">\(i\)</span>次操作会给定参数<span class="math inline">\(x_i\)</span>和<span class="math inline">\(y_i(x_i&lt;y_i)\)</span>，表示若<span class="math inline">\(a_{x_i}&gt;a_{y_i}\)</span>，则交换<span class="math inline">\(a_{x_i}\)</span>和<span class="math inline">\(a_{y_i}\)</span>。若数组恢复有序，小明会立刻停止操作。</p><p>现在，你需要告诉小明<span class="math inline">\(A\)</span>数组最早在什么时恢复有序（本题有序指数组单调递增，即从小到大有序），即找到一个最小的非负整数<span class="math inline">\(p\)</span>，满足第<span class="math inline">\(p\)</span>次操作后，数组<span class="math inline">\(A\)</span>有序。特别地，若<span class="math inline">\(A\)</span>数组在第<span class="math inline">\(1\)</span>次操作前就有序，则<span class="math inline">\(p=0\)</span>，若数组在<span class="math inline">\(m\)</span>次操作后仍然没有处于有序状态，则<span class="math inline">\(p=m+1\)</span>。</p><h2 id="输入-1">输入</h2><p>本题输入包含多组测试数据，输入第一行包含一个正整数<span class="math inline">\(T(1\le T\le100)\)</span>，表示数据组数。</p><p>接下来，每三行描述了一组测试数据。</p><p>每组测试数据中，第一行包含两个正整数<span class="math inline">\(n(2\le n\le 20)\)</span>和<span class="math inline">\(m(1\le m\le 200)\)</span>，分别表示<span class="math inline">\(A\)</span>数组长度和操作个数。</p><p>接下来一行包含<span class="math inline">\(n\)</span>个整数，描述了数组<span class="math inline">\(A\)</span>，保证数组<span class="math inline">\(A\)</span>为<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>的一个排列。</p><p>接下来一行包含<span class="math inline">\(2m\)</span>个整数，按操作顺序描述了小明将要进行的操作，第<span class="math inline">\(2i-1\)</span>个整数和第<span class="math inline">\(2i\)</span>个整数描述了第<span class="math inline">\(i\)</span>次操作<span class="math inline">\((1\lei\le m)\)</span>，分别代表了操作的两个参数<span class="math inline">\(x_i\)</span>和<span class="math inline">\(y_i(x_i&lt;y_i)\)</span>。</p><p>对于<span class="math inline">\(100\%\)</span>的数据，满足<span class="math inline">\(2\le n\le 20,1\le m\le 200,1\le T\le100\)</span>。</p><p>保证数组<span class="math inline">\(A\)</span>是<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>的一个排列。</p><h2 id="输出-1">输出</h2><p>对于每组测试数据，输出包含一行一个整数，即满足题意的最小非负整数。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">2</span><br><span class="line">5 2</span><br><span class="line">1 2 4 3 5</span><br><span class="line">1 2 3 4</span><br><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">1 2</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">对于样例的第一组测试数据：</span><br><span class="line">初始A数组为:1 2 4 3 5</span><br><span class="line">执行第1次操作后，数组A变为：1 2 4 3 5</span><br><span class="line">执行第2次操作后，数组A变为：1 2 3 4 5</span><br><span class="line">此时有序，故答案为2。</span><br><span class="line">对于样例的第二组测试数据，数组初始即有序，故答案为0。</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>只需要直接处理这个过程即可。如果数组<span class="math inline">\(A\)</span>已经有序，那么直接返回<span class="math inline">\(0\)</span>即可，接下来枚举每个交换操作，交换完后如果发现是有序的，那么可以直接返回。否则返回值<span class="math inline">\(m+1\)</span>。这种做法完全可以做出这个数据范围下<span class="math inline">\(O(nm)\)</span>的这题。</p><p>以下介绍一种<span class="math inline">\(O(n+m)\)</span>的做法。在整个过程中，维护一个变量<span class="math inline">\(c\)</span>，表示有多少个数已经排在了正确的位置上，当<span class="math inline">\(c=n\)</span>时，说明数组已经有序。可以在<span class="math inline">\(O(1)\)</span>的时间内维护好<span class="math inline">\(c\)</span>变量，交换前处理排好序的下标的情况，交换后也处理排好序的下标的情况，从而完成变量<span class="math inline">\(c\)</span>的维护。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N],x[N],y[N],n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x[i],&amp;y[i]);</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==i) ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt==n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[x[i]]&gt;a[y[i]])&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[x[i]]==x[i]) --cnt;</span><br><span class="line">            <span class="keyword">if</span>(a[y[i]]==y[i]) --cnt;</span><br><span class="line">            <span class="built_in">swap</span>(a[x[i]],a[y[i]]);</span><br><span class="line">            <span class="keyword">if</span>(a[x[i]]==x[i]) ++cnt;</span><br><span class="line">            <span class="keyword">if</span>(a[y[i]]==y[i]) ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt==n) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">solve</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小的区间">3、最小的区间</h1><p>给定一个长度为<span class="math inline">\(n\)</span>的数组<span class="math inline">\(A\)</span>，下标为<span class="math inline">\(1\)</span>到n。给定一个长度为<span class="math inline">\(m\)</span>的数组<span class="math inline">\(B\)</span>，下标为<span class="math inline">\(1\)</span>到<span class="math inline">\(m\)</span>，数组<span class="math inline">\(B\)</span>中第<span class="math inline">\(i\)</span>个数记为<span class="math inline">\(b_i\)</span>。请找出长度最小的连续区间<span class="math inline">\([l,r]\)</span>（<span class="math inline">\(1\le l\le r\le n\)</span>且<span class="math inline">\(l,r\)</span>为整数），使得该区间对于所有满足<span class="math inline">\(1\le x\le m\)</span>的正整数<span class="math inline">\(x\)</span>均有：正整数<span class="math inline">\(x\)</span>在<span class="math inline">\(A\)</span>数组的下标落在区间<span class="math inline">\([l,r]\)</span>的所有数中至少现了<span class="math inline">\(b_x\)</span>次。</p><p>注意，对于任意一个连续区间<span class="math inline">\([l,r]，区间的长度定义为\)</span>r-l+1$。</p><h2 id="输入-2">输入</h2><p>输入第一行包含两个数<span class="math inline">\(n(1\le n\le10^5)\)</span>和<span class="math inline">\(m(1\le m\le10^5)\)</span>，分别表示数组<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>的长度。</p><p>输入第二行包含<span class="math inline">\(n\)</span>个整数，描述了数组<span class="math inline">\(A\)</span>。</p><p>输出第三行包含<span class="math inline">\(m\)</span>个整数，描述了数组<span class="math inline">\(B\)</span>。</p><p>对于<span class="math inline">\(100\%\)</span>的数据，满足<span class="math inline">\(1\le n,m\le 10^5\)</span>。</p><p>保证数组<span class="math inline">\(A\)</span>和数组<span class="math inline">\(B\)</span>中所有数均为不超过<span class="math inline">\(10^5\)</span>的非负整数，保证数组<span class="math inline">\(B\)</span>不全为<span class="math inline">\(0\)</span>。</p><h2 id="输出-2">输出</h2><p>输出包含一行一个整数，表示最小的符合要求的区间的长度。</p><p>如果不存在符合要求的区间，请输出<span class="math inline">\(-1\)</span>。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">8 5</span><br><span class="line">2 3 3 1 2 4 2 5</span><br><span class="line">1 2 0 0 0</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">样例中，区间[4,7]是长度最小的满足条件的区间，其区间长度为7-4+1=4。</span><br><span class="line">样例中需要满足的条件是“1至少出现1次”，“2至少出现2次”，“3、4、5至少出现0次”。</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>我们可以使用双指针法完成这题。我们可以使用枚举左指针<span class="math inline">\(l\)</span>，并且找到最大的<span class="math inline">\(r(r\le n+1)\)</span>指针使得区间<span class="math inline">\([l,r)\)</span>中的所有出现次数都满足数组<span class="math inline">\(b\)</span>，从而把答案<span class="math inline">\(r-l\)</span>进行统计（如果<span class="math inline">\(r\)</span>存在）。</p><p>这个过程怎么维护呢？使用一个<span class="math inline">\(c\)</span>数组用于统计<span class="math inline">\(a[l,r)\)</span>中的元素个数，以及集合<span class="math inline">\(S\)</span>用于记录满足<span class="math inline">\(1\le x\le m,c_x&lt;b_x\)</span>的那些<span class="math inline">\(x\)</span>值。随着右指针右移，<span class="math inline">\(S\)</span>集合元素逐渐减少，直到为空，这时<span class="math inline">\(r-l\)</span>为所求的答案。接下来去除<span class="math inline">\(a_l\)</span>元素，集合<span class="math inline">\(S\)</span>有可能新添加一个元素<span class="math inline">\(a_l\)</span>。由此使用双指针法即可完成本题。</p><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N],b[N],n,m;</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt;st;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> op)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;m) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(++cnt[x]&gt;=b[x])</span><br><span class="line">            st.<span class="built_in">erase</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(--cnt[x]&lt;b[x])</span><br><span class="line">            st.<span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">        <span class="keyword">if</span>(b[i]) st.<span class="built_in">insert</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">1</span>;l&lt;=n;l++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(;r&lt;=n&amp;&amp;!st.<span class="built_in">empty</span>();r++)&#123;</span><br><span class="line">            <span class="built_in">add</span>(a[r],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,r-l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">add</span>(a[l],<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans&gt;n) ans=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>百度 秋招 2023.10.10 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Baidu-20231010/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Baidu-20231010/</id>
    <published>2023-10-11T10:55:57.000Z</published>
    <updated>2023-10-11T10:55:57.193Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="小红的精灵">1、小红的精灵</h1><p>小红有<span class="math inline">\(n\)</span>个精灵，精灵分布在<span class="math inline">\(m\)</span>个房间中，第<span class="math inline">\(i\)</span>个精灵可以施展<span class="math inline">\(a_i\)</span>次魔法，现在有<span class="math inline">\(k\)</span>个敌人要攻击，每次攻击需要一个房间的精灵都消耗一次魔法，该次攻击可以击杀一个敌人。问小红最多可以消灭多少敌人。</p><h2 id="输入">输入</h2><p>一行三个整数<span class="math inline">\(n,m,k\)</span>，分别表示精灵数量，房间数量，敌人数量。</p><p>接下来<span class="math inline">\(n\)</span>行，每行两个整数，第<span class="math inline">\(i\)</span>行表示第<span class="math inline">\(i\)</span>个精灵的所在房间编号<span class="math inline">\(b_i\)</span>和可以施展的魔法次数<span class="math inline">\(a_i\)</span>。</p><ul><li><span class="math inline">\(1\le n,m\le 10^5\)</span></li><li><span class="math inline">\(1\le b_i\le m\)</span></li><li><span class="math inline">\(1\le a_i,k \le 10^6\)</span></li></ul><h2 id="输出">输出</h2><p>输出一个整数，表示最多可以消灭的敌人数量。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">4 5 12</span><br><span class="line">2 4</span><br><span class="line">5 2</span><br><span class="line">3 6</span><br><span class="line">2 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">11</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">有12个敌人，第二个房间可以消灭3个敌人，第三个房间可以消灭6个敌人，第五个房间可以消灭2个敌人。总共可以消灭11个敌人。</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>如果第<span class="math inline">\(i\)</span>个房间没有精灵，那么第<span class="math inline">\(i\)</span>个房间并没有用处。如果第<span class="math inline">\(i\)</span>个房间有精灵，那么这个房间可以击败的敌人数为<span class="math inline">\(c_i=\displaystyle{\min_{1\le j\len,b_j=i}\{a_j\}}\)</span>。</p><p>最终把<span class="math inline">\(c_i\)</span>的值进行求和即可，并和<span class="math inline">\(k\)</span>取较小值。如果第<span class="math inline">\(i\)</span>个房间没有精灵，那么令<span class="math inline">\(c_i=0\)</span>。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n, m, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">mp = &#123;&#125;</span><br><span class="line">INF = <span class="number">10</span> ** <span class="number">9</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    b, a = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    mp[b] = <span class="built_in">min</span>(mp.get(b, INF), a)</span><br><span class="line">ans = <span class="built_in">min</span>(<span class="built_in">sum</span>(mp.values()), k)</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure><h1 id="小红分糖果">2、小红分糖果</h1><p>小红有<span class="math inline">\(n\)</span>个糖果，要分给小朋友，每个小朋友必须分到<span class="math inline">\([l,r]\)</span>个，如果可以分完，输出最少可以分给多少小朋友，最多可以分给多少小朋友，如果不能分完，输出<span class="math inline">\(-1\)</span>。</p><h2 id="输入-1">输入</h2><p>一行三个整数<span class="math inline">\(n,l,r\)</span>，表示糖果数量和每个小朋友的要求。</p><ul><li><span class="math inline">\(1\le n \le 10^9\)</span></li><li><span class="math inline">\(1\le l\le r\le 10^9\)</span></li></ul><h2 id="输出-1">输出</h2><p>如果可以分完，输出最少可以分给多少小朋友，最多可以分给多少小朋友，如果不能分完，输出<span class="math inline">\(-1\)</span>。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">10 2 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">4 5</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">最少可以分给4个小朋友，[2,2,3,3]; 最多可以分给5个小朋友，每个小朋友分到2个糖果。</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>假设现在需要求最大值，基本思想是每个小朋友都分的最少。也就是说，分得<span class="math inline">\(d=\lfloor n/l\rfloor\)</span>个小朋友，还剩下<span class="math inline">\(q=n-ld\)</span>个糖果。容易知道<span class="math inline">\(d\)</span>是答案的一个上界，<span class="math inline">\(d\)</span>不能够再大了。可见<span class="math inline">\(q&lt;l\)</span>，那么这些多出来的<span class="math inline">\(q\)</span>个糖果需要分配回去，但是为了确保满足题意，哪怕分回去每个小朋友也不能分超过<span class="math inline">\(r\)</span>个糖果，他们现在最多只能再得到<span class="math inline">\(r-l\)</span>个糖果。因此，剩下的糖果数<span class="math inline">\(q\)</span>必须满足<span class="math inline">\(q\led(r-l)\)</span>。如果不满足<span class="math inline">\(q\led(r-l)\)</span>，</p><p>那么如果分给<span class="math inline">\(d\)</span>个小朋友不可行，有没有可能通过减少小朋友从而获得一个分配方案呢？答案是不可能的，因为减少了小朋友后，就要承担原本分给他的<span class="math inline">\(l\)</span>个糖果，之前的小朋友反而还需要多承受一些糖果（总共剩余不止<span class="math inline">\(q\)</span>糖果了）。因此减少小朋友并不能获得一个合法的分配方案，上面给出的答案就是最佳答案。</p><p>假设现在需要求最小值，思想和上面的类似，每个小朋友都分的最多。也就是说，分得<span class="math inline">\(d=\lfloor n/r\rfloor\)</span>个小朋友，还剩下<span class="math inline">\(q=n-rd\)</span>个糖果。容易知道<span class="math inline">\(d\)</span>是答案的一个下界，<span class="math inline">\(d\)</span>不能够再小了。类似的，可见<span class="math inline">\(q&lt;r\)</span>。如果<span class="math inline">\(q=0\)</span>，那么这些糖果恰好分完，不需要再判断其它情况。如果<span class="math inline">\(q&gt;0\)</span>，那么还需要多一个小朋友来承受这些糖果。如果<span class="math inline">\(q\gel\)</span>，那么说明这时新的小朋友已经满足了条件，此时答案为<span class="math inline">\(d+1\)</span>，如果<span class="math inline">\(q&lt;l\)</span>，那么前面的小朋友只能都拿出<span class="math inline">\(r-l\)</span>个糖果给他。因此，如果<span class="math inline">\(q+d(r-l)\gel\)</span>仍然成立，那么这个小朋友也是符合条件的，否则他无法取到<span class="math inline">\(l\)</span>个糖果，并不可行。</p><p>同样的问题，如果分给<span class="math inline">\(d\)</span>个小朋友不可行，有没有可能通过增加小朋友从而获得一个分配方案呢？答案同样也是不可行的，因为增加了小朋友后，其余的小朋友就要拿出更多的糖果分出来，原来已经不够分配给持有<span class="math inline">\(q\)</span>个糖果的小朋友的数量，现在更加不可行。因此增加小朋友并不能获得一个合法的分配方案，上面给出的答案就是最佳答案。</p><h2 id="代码-1">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">n, l, r = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">rp, rr = <span class="built_in">divmod</span>(n, l)</span><br><span class="line"><span class="keyword">if</span> rp * (r - l) &lt; rr:</span><br><span class="line">    rp = -<span class="number">1</span></span><br><span class="line">lp, lr = <span class="built_in">divmod</span>(n, r)</span><br><span class="line"><span class="keyword">if</span> lr &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">if</span> lp * (r - l) + lr &lt; l:</span><br><span class="line">        lp = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        lp += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> rp == -<span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(lp, rp)</span><br></pre></td></tr></table></figure><h1 id="小红的树上游走">3、小红的树上游走</h1><p>小红有一棵<span class="math inline">\(n\)</span>个节点的树，节点编号为<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>。每条边有一个权值，权值是<span class="math inline">\(1\)</span>或者<span class="math inline">\(0\)</span>。</p><p>对于一个长度为<span class="math inline">\(k\)</span>的节点序列<span class="math inline">\([a_1,a_2,\dots,a_k]\)</span>，按照顺序依次访问这些节点，从<span class="math inline">\(a_i\)</span>走到<span class="math inline">\(a_{i+1}\)</span>，会按照最短路径走。</p><p>小红想知道，对于所有长度为<span class="math inline">\(k\)</span>的节点序列中（一共有<span class="math inline">\(n^k\)</span>个长度为<span class="math inline">\(k\)</span>的序列），有多少个序列满足：小红走完这个序列后，经过的所有边的权值之和不为0。</p><p>由于答案可能很大，你只需要输出答案对<span class="math inline">\(10^9+7\)</span>取模的结果。</p><p>注意，小红可以从一个节点走到它自己，也可以重复经过一条边。</p><h2 id="输入-2">输入</h2><p>一行两个整数<span class="math inline">\(n\)</span>和<span class="math inline">\(k\)</span>，表示树的节点数和序列长度。</p><p>接下来<span class="math inline">\(n-1\)</span>行，每行三个整数<span class="math inline">\(u,v,w\)</span>，表示节点<span class="math inline">\(u\)</span>和节点<span class="math inline">\(v\)</span>之间有一条边，权值为<span class="math inline">\(w\)</span>。</p><ul><li><span class="math inline">\(1\le k\le n\le 10^5\)</span></li><li><span class="math inline">\(1\le u,v \le n,0\le w\le 1\)</span></li></ul><h2 id="输出-2">输出</h2><p>输出一个整数，表示满足条件的序列个数对<span class="math inline">\(10^9+7\)</span>取模的结果。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3 2</span><br><span class="line">1 2 1</span><br><span class="line">2 3 0</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">四个序列分别为[1,2],[2,1],[1,3],[3,1]</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>这道题的对立问题是：有多少序列，经过的所有边的权值之和等于<span class="math inline">\(0\)</span>。最终用总方案数<span class="math inline">\(n^k\)</span>减去对立问题的答案数，就能过得到原问题的答案。</p><p>可以发现，求解对立问题的解比求解原问题要简单的多，只要序列<span class="math inline">\(a\)</span>相邻的两个节点之间的路径都为<span class="math inline">\(0\)</span>即可。原问题与此的区别在于，<span class="math inline">\(a\)</span>中<strong>至少</strong>存在一对相邻节点，其路径权值和不等于<span class="math inline">\(0\)</span>，由于还要考虑其它相邻对节点是否满足这个情况，因此直接求解原问题比较困难。</p><p>接下来求解这个对立问题。可见，只需要每一对相邻对节点的路径和为<span class="math inline">\(0\)</span>即可，这时不需要考虑其它相邻节点对的问题，比较简单，我们使用并查集进行解决。将所有权值为<span class="math inline">\(0\)</span>的所有边的相邻节点合并在一起，那么节点<span class="math inline">\(u\)</span>和节点<span class="math inline">\(v\)</span>的路径之和为<span class="math inline">\(0\)</span>当且仅当它们在同一个集合中。因此，一个满足对立问题的序列，要求它的所有结点都在同一个集合中。假设所有合并操作完成后，一共有<span class="math inline">\(m\)</span>个集合，第<span class="math inline">\(i\)</span>个集合一共有<span class="math inline">\(c_i\)</span>个节点，那么这个集合中，满足的节点序列答案为<span class="math inline">\(c_i^k\)</span>。因此本题的最终答案为<span class="math inline">\(\displaystyle{n^k-\sum_{i=1}^mci^k}\)</span>。</p><h2 id="代码-2">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">n, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">fa = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">sz = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> fa[x] == x:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    fa[x] = find(fa[x])</span><br><span class="line">    <span class="keyword">return</span> fa[x]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">x, y</span>):</span><br><span class="line">    u, v = find(x), find(y)</span><br><span class="line">    <span class="keyword">if</span> u != v:</span><br><span class="line">        fa[v] = u</span><br><span class="line">        sz[u] += sz[v]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">    x, y, w = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    x, y = x - <span class="number">1</span>, y - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> w == <span class="number">0</span>:</span><br><span class="line">        merge(x, y)</span><br><span class="line"></span><br><span class="line">ans = (<span class="built_in">pow</span>(n, k, mod) - <span class="built_in">sum</span>(<span class="built_in">pow</span>(sz[i], k, mod) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n) <span class="keyword">if</span> i == find(i))) % mod</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>字节跳动 秋招 2023.10.08 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Zijietiaodong-20231008/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Zijietiaodong-20231008/</id>
    <published>2023-10-08T16:57:32.000Z</published>
    <updated>2023-10-08T16:57:32.039Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="小红操作数组">1、小红操作数组</h1><p>小红拿到了一个数组，她准备进行任意次以下操作：</p><p>选择一个正整数<span class="math inline">\(x\)</span>，使得数组的每个<span class="math inline">\(a_i\)</span>都变成<span class="math inline">\(x\%a_i\)</span>。</p><p>小红希望最终数组的每个元素都相等目大于<span class="math inline">\(0\)</span>。她想要你告诉她能否达成目的。</p><h2 id="输入">输入</h2><p>有多组测试用例，第一行输入一个整数<span class="math inline">\(t\)</span>，表示用例组数。</p><p>接下来每<span class="math inline">\(2\timest\)</span>行，表示一组用例。对于每组用例：</p><p>第一行输入一个正整数<span class="math inline">\(n\)</span>，代表数组的大小。</p><p>第二行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(a_i\)</span>，代表小红拿到的数组。</p><ul><li><span class="math inline">\(1\le t, n, a_i \le 10^5\)</span></li></ul><p>保证<span class="math inline">\(n\)</span>的总和不超过<span class="math inline">\(10^5\)</span>。</p><h2 id="输出">输出</h2><p>如果可以使得所有数相等且大于<span class="math inline">\(0\)</span>，输出<code>"Yes"</code>。否则输出<code>"No"</code>。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">3 6</span><br><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">2</span><br><span class="line">3 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>如果<span class="math inline">\(a\)</span>中的这些数都相同，那么不需要任何操作就是符合题意的。</p><p>否则，就需要进行至少<span class="math inline">\(1\)</span>次操作。如果存在某个<span class="math inline">\(a_i=1\)</span>，那么无论选什么<span class="math inline">\(x\)</span>，<span class="math inline">\(a_i\)</span>都变成<span class="math inline">\(0\)</span>，这是不符合题意的；否则我们选<span class="math inline">\(x=1\)</span>进行一次操作，那么下一步<span class="math inline">\(a\)</span>中所有数都变成<span class="math inline">\(1\)</span>，这是符合题意的。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>():</span><br><span class="line">    <span class="built_in">input</span>()</span><br><span class="line">    st = <span class="built_in">set</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> st <span class="keyword">or</span> <span class="built_in">len</span>(st) == <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Yes&quot;</span> <span class="keyword">if</span> solve() <span class="keyword">else</span> <span class="string">&quot;No&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="小红的有根树">2、小红的有根树</h1><p>小红拿到了一棵有根树，其中根是<span class="math inline">\(1\)</span>号节点。小红准备给每个节点染成红色或者绿色或者蓝色。但是有以下两个要求：</p><ol type="1"><li>每个节点和它的父亲颜色不同。 （如果它存在父亲）</li><li>每个节点和它的父亲的父亲颜色不同。 （如果它存在父亲的父亲）</li></ol><p>请你输出任意一种染色方案。</p><h2 id="输入-1">输入</h2><p>第一行输入一个正整数<span class="math inline">\(n\)</span>，代表节点的数量。</p><p>接下来的<span class="math inline">\(n-1\)</span>行，每行输入两个正整数<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>，代表节点<span class="math inline">\(u\)</span>和节点<span class="math inline">\(v\)</span>有一条边连接。</p><ul><li><span class="math inline">\(1 \le n \le 10^5\)</span></li><li><span class="math inline">\(1\le u,v\le n\)</span></li></ul><h2 id="输出-1">输出</h2><p>一个长度为<span class="math inline">\(n\)</span>的、仅由<code>'R','G','B'</code>三种字母组成的字符串。第<span class="math inline">\(i\)</span>个字符为<code>'R'</code>代表<span class="math inline">\(i\)</span>号节点被染成红色，为<code>'G'</code>代表染成绿色，<code>'B'</code>代麦染成蓝色。</p><p>如果有多解，输出任意即可。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">4</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br><span class="line">1 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">BGRG</span><br></pre></td></tr></table></figure><p>样例1的染色如下图：</p><pre class="mermaid">graph TD  1((1));2((2));3((3));4((4))  classDef red-node fill:red, color:white;  classDef blue-node fill:blue, color:white;  classDef green-node fill:green, color:white;  class 1 blue-node;  class 2 green-node;  class 3 red-node;  class 4 green-node;  1---2;3---4;1---3</pre><h2 id="解答-1">解答</h2><p>从另一个角度考虑这个问题：对于一个节点<span class="math inline">\(u\)</span>，其所有直系后代和直系后代的直系后代都不能和<span class="math inline">\(u\)</span>有相同的颜色。因此，我们只需要让<span class="math inline">\(u\)</span>的所有直系后代染上同一种颜色，以及让直系后代的直系后代也染上同一种颜色即可。</p><p>也就是说，每一层染上的颜色都是相同的，只需要相邻三层的节点染上的颜色都不相同即可，这个过程通过DFS即可完成。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;g[N];</span><br><span class="line"><span class="type">char</span> s[N],t[]=<span class="string">&quot;RGB&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    s[u]=t[d%<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u,d+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,x,y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        g[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        g[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(s+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小红做糖葫芦">3、小红做糖葫芦</h1><p>小红想用山楂制作糖葫芦，一串糖葫芦用一串字符串表示，糖葫芦的甜度为串上所有字符的甜度之和。字符的甜度为这个字符与字符<code>'a'</code>的差值。</p><p>即<code>'a'</code>的甜度为<span class="math inline">\(0\)</span>，<code>'b'</code>的甜度为<span class="math inline">\(1\)</span>……，<code>'z'</code>的甜度为<span class="math inline">\(25\)</span>。小红有<span class="math inline">\(n\)</span>个山植按顺序从<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>依次摆放，山植被表示为一个字符，山植的甜度即为字符的甜度。</p><p>小红制作糖葫芦时，需要取出一段连续的山楂制作成糖葫芦。</p><p>小红想知道，在所有可能被制成的糖葫芦中，甜度第<span class="math inline">\(k\)</span>大的糖葫芦甜度为多少？</p><p>若有一根糖葫串本身或翻转后与另一串糖葫芦相同，则这两串糖葫芦被视为是相同的糖葫芦。</p><p>例如，糖葫芦<code>"abc"</code>与<code>"cba"</code>被认为是相同的。</p><p>糖动芦。</p><h2 id="输入-2">输入</h2><p>第一行输入两个整数<span class="math inline">\(n,k(1\le n\le 200,1\lek\le n \times(n+1)/2)\)</span></p><p>第二行输入一个长度为<span class="math inline">\(n\)</span>的字符串，表示山楂的摆放顺序。</p><h2 id="输出-2">输出</h2><p>一行一个整数，表示甜度第<span class="math inline">\(k\)</span>大的是多少。若可能产生的糖葫芦数小于<span class="math inline">\(k\)</span>，则输出<span class="math inline">\(-1\)</span>。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3 4</span><br><span class="line">abc</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">可能制作的糖葫芦串为a,b,c,ab,bc,abc。甜度分别为0,1,2,1,3,3，其中第4甜的糖葫芦串甜度为1。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">3 4</span><br><span class="line">aba</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">可以制作的糖葫芦只有4种：&quot;a&quot;、&quot;b&quot;、&quot;ab&quot;、&quot;aba&quot;甜度分别是0,1,1,2，第4甜的糖葫芦甜度为0。请注意，&quot;ba&quot;和&quot;ab&quot;被视为同一种糖葫芦。</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>这题可以使用暴力完成，因为它的长度只有<span class="math inline">\(n\le 200\)</span>。</p><p>使用一个集合<span class="math inline">\(S\)</span>存储一些字符串。枚举输入的字符串<span class="math inline">\(s\)</span>中的每个子串，判断它是否已经存在了<span class="math inline">\(S\)</span>中，如果不存在，那么就暴力求它的甜度值出来存放在另一个数组<span class="math inline">\(A\)</span>中，并将<span class="math inline">\(s\)</span>和<span class="math inline">\(s\)</span>的逆序存入<span class="math inline">\(S\)</span>中。</p><p>最终将<span class="math inline">\(A\)</span>排序后，输出第<span class="math inline">\(k\)</span>大的值即可，当然如果<span class="math inline">\(A\)</span>的长度不足<span class="math inline">\(k\)</span>，那么输出<span class="math inline">\(-1\)</span>。</p><h2 id="代码-2">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">n, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">st = <span class="built_in">set</span>()</span><br><span class="line">a = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">        t = s[i:j + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> t <span class="keyword">in</span> st:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        st.add(t)</span><br><span class="line">        st.add(t[::-<span class="number">1</span>])</span><br><span class="line">        a.append(<span class="built_in">sum</span>(<span class="built_in">ord</span>(ch) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) <span class="keyword">for</span> ch <span class="keyword">in</span> t))</span><br><span class="line"></span><br><span class="line">a.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(-<span class="number">1</span> <span class="keyword">if</span> k &gt; <span class="built_in">len</span>(a) <span class="keyword">else</span> a[k - <span class="number">1</span>])</span><br></pre></td></tr></table></figure><h1 id="小红合并数组">4、小红合并数组</h1><p>小红拿到了一个数组，她可以进行以下操作：选择两个相同的元素<span class="math inline">\(x\)</span>，将它们删除，并将<span class="math inline">\(2x\)</span>添加进数组。这种操作称为一次“合并”。</p><p>小红在进行合并之前可以先往数组里添加任意一个元素。之后小红希望最大化“合并”的次数。请你帮帮小红。</p><h2 id="输入-3">输入</h2><p>第一行输入一个正整数<span class="math inline">\(n\)</span>，代表数组的大小。</p><p>第二行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(a_i\)</span>，代表小红拿到的数组。</p><ul><li><span class="math inline">\(1\le n \le 10^5\)</span></li><li><span class="math inline">\(1 \le a_i \le 10^9\)</span></li></ul><h2 id="输出-3">输出</h2><p>输出两个整数，第一个数为添加的元素，第二个数为合并的最大次数。</p><p>如果有多种添加的方案，输出任意一个即可。</p><h2 id="样例-3">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">1 1 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">3 2</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">添加3后，数组变成[1,1,3,3]，可以合并两次。</span><br><span class="line">添加2也是可以的，依然可以合并2次。</span><br></pre></td></tr></table></figure><h2 id="解答-3">解答</h2><p>可见，无论一开始对<span class="math inline">\(a\)</span>怎么操作，到最后无法合并时，<span class="math inline">\(a\)</span>中的所有数都只出现了一次。并且，按照二进制中“进位”的性质，无论执行操作的次序如何，到最后无法合并时，最终得到的数组总是同一个数组（与其说是数组，不如说是集合<span class="math inline">\(S\)</span>，因为这些数都是无序的）。</p><p>对于一个新加入的<span class="math inline">\(x\)</span>，如果<span class="math inline">\(x,2x,4x,8x,\dots,2^{k-1}x\)</span>都在数组中，但是<span class="math inline">\(2^kx\)</span>不在数组中，那么我们可以进行<span class="math inline">\(k\)</span>次合并操作，并且最终得到新的数<span class="math inline">\(2^kx\)</span>。</p><p>因此，考虑已经对<span class="math inline">\(a\)</span>进行完了所有操作，得到数组<span class="math inline">\(a&#39;\)</span>，这时数组<span class="math inline">\(a&#39;\)</span>没有办法再进行下一步操作，我们将<span class="math inline">\(a&#39;\)</span>看成是一个集合<span class="math inline">\(S\)</span>。枚举<span class="math inline">\(S\)</span>中的每个数<span class="math inline">\(x\)</span>，作为一开始要添加到数组<span class="math inline">\(a\)</span>中的数，然后找到最大的<span class="math inline">\(k\)</span>使得<span class="math inline">\(x,2x,4x,8x,\dots,2^{k-1}x\)</span>都在数组中，但是<span class="math inline">\(2^kx\)</span>不在数组中。这时我们就可以多进行<span class="math inline">\(k\)</span>次操作。由于整个操作的过程中，数组的元素和保持不变，因此这个<span class="math inline">\(k\)</span>值也会很小，直接枚举即可。</p><p>最终，找到最大的<span class="math inline">\(k\)</span>值和对应的<span class="math inline">\(x\)</span>，那么总操作次数为<span class="math inline">\(n-|S|+k\)</span>。</p><h2 id="代码-3">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"></span><br><span class="line">ll a[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    unordered_set&lt;ll&gt;st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ll x=a[i];</span><br><span class="line">        <span class="keyword">while</span>(st.<span class="built_in">count</span>(x))&#123;</span><br><span class="line">            st.<span class="built_in">erase</span>(x);</span><br><span class="line">            x&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        st.<span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    ll k=<span class="number">0</span>;<span class="type">int</span> v=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll x:st)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;st.<span class="built_in">count</span>(x/<span class="number">2</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;st.<span class="built_in">count</span>(x&lt;&lt;j);++j);</span><br><span class="line">        <span class="keyword">if</span>(j&gt;v)&#123;</span><br><span class="line">            k=x;v=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %d\n&quot;</span>,k,n-st.<span class="built_in">size</span>()+v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小红统计子数组">5、小红统计子数组</h1><p>小红拿到了一个大小为<span class="math inline">\(n\)</span>的数组，她想知道，有多少个连续子数组满足，该子数组所有元素的乘积是<span class="math inline">\(k\)</span>的倍数？</p><h2 id="输入-4">输入</h2><p>第一行输入两个正整数<span class="math inline">\(n\)</span>和<span class="math inline">\(k\)</span>。</p><p>第二行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(a_i\)</span>。</p><ul><li><span class="math inline">\(1\le n \le 10^5\)</span></li><li><span class="math inline">\(1\le a_i \le 10^6\)</span></li><li><span class="math inline">\(1\le k \le 10^{12}\)</span></li></ul><h2 id="输出-4">输出</h2><p>满足条件的子数组数量。</p><h2 id="样例-4">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3 6</span><br><span class="line">2 3 4</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="解答-4">解答</h2><p>这题我们可以很轻易地想到使用双指针来解决。令<span class="math inline">\(\displaystyle{s_i=\prod_{j=1}^ia_j,s_0=1}\)</span>为数组<span class="math inline">\(a\)</span>的前缀积，那么区间<span class="math inline">\(a[l:r]\)</span>的子数组元素之积可以表示成<span class="math inline">\(\dfrac{s_r}{s_{l-1}}\)</span>。枚举每个右指针<span class="math inline">\(r\)</span>，找到一个最小的<span class="math inline">\(l(0\le l\le r)\)</span>满足<span class="math inline">\(\dfrac{s_r}{s_l}\)</span>不是<span class="math inline">\(k\)</span>的倍数。那么<span class="math inline">\(\forall i=[0,l)\)</span>，子数组<span class="math inline">\(a[i+1,r]\)</span>都是<span class="math inline">\(k\)</span>的倍数，将这<span class="math inline">\(l\)</span>个数都统计进答案即可。时间复杂度为<span class="math inline">\(O(n)\)</span>。</p><p>但是问题在于，前缀积<span class="math inline">\(s_i\)</span>的值可能很大。如何进行优化？</p><p>考虑<span class="math inline">\(k\)</span>这个数，如果一个数是<span class="math inline">\(k\)</span>的倍数，那么对于它所有在<span class="math inline">\(k\)</span>中的质因子的出现次数都至少是<span class="math inline">\(k\)</span>对应的质因子的出现次数。更正式的说，令<span class="math inline">\(k\)</span>的质因数分解为<span class="math inline">\(\displaystyle{k=\prod_{i=1}^mp_i^{e_i}}\)</span>，那么如果一个数<span class="math inline">\(n\)</span>满足它是<span class="math inline">\(k\)</span>的倍数，那么<span class="math inline">\(\forall i\in[1,m],n\)</span>至少有<span class="math inline">\(e_i\)</span>个质因子<span class="math inline">\(p_i\)</span>。</p><p>这启发我们可以换另外一种思路，将一个前缀积转化为多个前缀和的做法。首先构造<span class="math inline">\(m\)</span>个数组<span class="math inline">\(b_i\)</span>，其中<span class="math inline">\(b_{i,j}\)</span>表示<span class="math inline">\(a_j\)</span>包含的质因子<span class="math inline">\(p_i\)</span>的个数，令<span class="math inline">\(\displaystyle{t_{i,j}=\sum_{k=1}^jb_{i,k},b_{i,0}=0}\)</span>，也就是说，<span class="math inline">\(t_{i,j}\)</span>其实是<span class="math inline">\(s_{i,j}\)</span>中因子<span class="math inline">\(p_i\)</span>的次数，这时我们上面类似的思路，同样采用如下双指针法，即可完成本题：枚举每个右指针<span class="math inline">\(r\)</span>，找到一个最小的<span class="math inline">\(l(0\le l\le r)\)</span>。使得存在<span class="math inline">\(i\in[1,m],t_{i,r}-t_{i,l}&lt;e_i\)</span>成立，类似的，将<span class="math inline">\(l\)</span>统计进答案即可。时间复杂度为<span class="math inline">\(O(n\log k+\sqrt{k})\)</span>，足以通过本题。</p><h2 id="代码-4">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"></span><br><span class="line">n, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">a = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">fact = <span class="built_in">list</span>(sympy.factorint(k).items())</span><br><span class="line">ls = [[<span class="number">0</span>] * <span class="built_in">len</span>(fact)]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> a:</span><br><span class="line">    b = ls[-<span class="number">1</span>].copy()</span><br><span class="line">    <span class="keyword">for</span> i, (p, r) <span class="keyword">in</span> <span class="built_in">enumerate</span>(fact):</span><br><span class="line">        <span class="keyword">while</span> x % p == <span class="number">0</span>:</span><br><span class="line">            x //= p</span><br><span class="line">            b[i] += <span class="number">1</span></span><br><span class="line">    ls.append(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">l, r</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(fact)):</span><br><span class="line">        <span class="keyword">if</span> ls[r][i] - ls[l][i] &lt; fact[i][<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">l = <span class="number">0</span></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> check(l, r) <span class="keyword">and</span> l &lt; r:</span><br><span class="line">        l = l + <span class="number">1</span></span><br><span class="line">    ans += l</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论32 Problems 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-Problems/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-Problems/</id>
    <published>2023-10-07T16:57:31.000Z</published>
    <updated>2023-10-07T16:57:31.884Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">32-1</h1><h2 id="a">a</h2><p>首先使用KMP算法计算出<span class="math inline">\(\pi\)</span>数组，分两种情况进行考虑：</p><ul><li><p>如果<span class="math inline">\(i\bmod(i-\pi[i])=0\)</span>，那么有<span class="math inline">\(\rho(P[:i])=\dfrac{i}{i-\pi[i]}\)</span>，这意味<span class="math inline">\(P[i-\pi[i]+1:i]=P[1:\pi[i]]\)</span>，那也就是说，<span class="math inline">\(P[\pi[i]+1:2\pi[i]]=P[1,\pi[i]]\)</span>，类似的，有<span class="math inline">\(P[i-2\pi [i]+1:i]=P[i-\pi[i]+1:i]\)</span>，最终多次迭代下去，可以发现这是一个周期为<span class="math inline">\(\dfrac{i}{i-\pi[i]}\)</span>的字符串，此外，由于<span class="math inline">\(\forall k\in \pi^{\ast}[i]\)</span>，都有<span class="math inline">\(k\le \pi[i]\)</span>，因此<span class="math inline">\(i-\pi[i]\)</span>是<span class="math inline">\(i\)</span>满足条件的最小因子，它将使值<span class="math inline">\(\dfrac{i}{i-k}\)</span>达到最大，因此原结论成立。</p></li><li><p>如果<span class="math inline">\(i\bmod (i-\pi[i])\neq0\)</span>，那么<span class="math inline">\(\rho(P[:i])=1\)</span>。因为，对于一个非周期字符串<span class="math inline">\(s\)</span>（如果是周期字符串，那么可以归约到最小非周期字符串），如果存在一个正整数<span class="math inline">\(r\)</span>满足<span class="math inline">\(s^r=P[i]\)</span>，那么有<span class="math inline">\(r\mid i\)</span>。然而按照上面的方式依次取出<span class="math inline">\(r\)</span>个字母，它们不能取完整，因此这时<span class="math inline">\(P[:i]\)</span>只能由自身拼接<span class="math inline">\(1\)</span>次而成，原结论成立。</p></li></ul><p>算法<code>COMPUTE-PREFIX-RHO</code>给出了具体过程，可见其时间复杂度为<span class="math inline">\(O(n)\)</span>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">COMPUTE-PREFIX-RHO(P, m)</span><br><span class="line">  π = COMPUTE-PREFIX-FUNCTION(P, m)</span><br><span class="line">  let ρ[1 : m] be a new array</span><br><span class="line">  for i = 1 to m</span><br><span class="line">    if i % (i - π[i]) == 0</span><br><span class="line">      ρ[i] = i / (i - π[i])</span><br><span class="line">    else</span><br><span class="line">      ρ[i] = 1</span><br><span class="line">  return ρ</span><br></pre></td></tr></table></figure><h2 id="b">b</h2><p>待研究，相关链接：</p><ul><li><a href="https://www.sciencedirect.com/science/article/pii/0022000083900028">该算法相关的论文</a></li><li><a href="https://oeis.org/A216955">相关数列1</a></li><li><a href="https://oeis.org/A217941">相关数列2</a></li></ul><h2 id="c">c</h2><p>同题目32-1-b。</p><h1 id="section-1">32-2</h1><h2 id="a-1">a</h2><p>假设目前需要对比<span class="math inline">\(P\)</span>中非空后缀<span class="math inline">\(i\)</span>和<span class="math inline">\(j\)</span>，令<span class="math inline">\(P[i]\)</span>表示<span class="math inline">\(P\)</span>的第<span class="math inline">\(i\)</span>个元字符。如下考虑多种情况：</p><ol type="1"><li><p>如果<span class="math inline">\(P[i]\neqP[j]\)</span>，那么第<span class="math inline">\(i\)</span>个非空后缀和第<span class="math inline">\(j\)</span>个非空后缀的字典序由<span class="math inline">\(P[i]\)</span>和<span class="math inline">\(P[j]\)</span>决定，此时和<span class="math inline">\(P[i],P[j]\)</span>后面的字符没有任何关系，因此原结论成立。</p></li><li><p>如果<span class="math inline">\(P[i]=P[j]\)</span>，考虑<span class="math inline">\(i,j\)</span>都在<span class="math inline">\(P\)</span>中<span class="math inline">\(P_1\)</span>所占有的下标。可见，由于<span class="math inline">\(P_1[i:]\varnothing\)</span>和<span class="math inline">\(P_1[j:]\varnothing\)</span>的长度不同，并且最后一个字符<span class="math inline">\(\varnothing\)</span>都小于已经出现的字符，因此它们的字典序已经确定。此时再在独立的字符串<span class="math inline">\(P_1[i:]\varnothing,P_1[j:]\varnothing\)</span>后面再添加字符也不会改变<span class="math inline">\(P_1[i:]\varnothing\)</span>和<span class="math inline">\(P_1[j:]\)</span>的字典序。因此原结论成立。接下来考虑<span class="math inline">\(i,j\)</span>都在<span class="math inline">\(P\)</span>中<span class="math inline">\(P_2\)</span>所占有的下标，明显原结论成立，因为这些后缀恰好是<span class="math inline">\(P_2\)</span>的后缀。</p></li><li><p>如果<span class="math inline">\(P[i]=P[j]\)</span>，考虑<span class="math inline">\(i,j\)</span>在<span class="math inline">\(P\)</span>中，其中一个在<span class="math inline">\(P_1\)</span>所占有的下标，另一个在<span class="math inline">\(P_2\)</span>所占有的下标。不失一般性，假设<span class="math inline">\(i\)</span>属于前者，<span class="math inline">\(j\)</span>属于后者，那么不难得到<span class="math inline">\(i&lt;j\)</span>。由于此时<span class="math inline">\(P[i]=P[j]\)</span>，因此我们继续向下找下一个下标，直到满足这两个元字符不相同，即最小的正整数<span class="math inline">\(s\)</span>，使得<span class="math inline">\(P[i+s]\neq P[j+s]\)</span>。可以发现<span class="math inline">\(i+s\)</span>仍会在<span class="math inline">\(P_1\)</span>占有的下标中。按照步骤A的作用，<span class="math inline">\(P_1\)</span>必定会包含一个出现<span class="math inline">\(\varnothing\)</span>的元字符，因此第<span class="math inline">\(i\)</span>个非空后缀不晚于这个元字符结束。由于<span class="math inline">\(n&#39;\not\equiv n&#39;&#39;\pmod3\)</span>，因此<span class="math inline">\(i\)</span>个非空后缀和第<span class="math inline">\(j\)</span>个非空后缀必定是以不同数量的<span class="math inline">\(\varnothing\)</span>元字符作为结尾，此外由于<span class="math inline">\(\varnothing\)</span>的字典序最小，再在它们的后面任意添加字符也不会改变这两个非空后缀的字典序，因此原结论成立。</p></li></ol><p>因此，<span class="math inline">\(P\)</span>的非空后缀的排名和<span class="math inline">\(P\)</span>的后缀排名是相同的。由于早在<span class="math inline">\(\varnothing\)</span>的时候就已经确定了排名，去除<span class="math inline">\(\varnothing\)</span>后面的字符并不影响后缀的排名，因此<span class="math inline">\(P\)</span>中的后缀排名和<span class="math inline">\(T\)</span>的采样后缀的相对排名是一致的，因此原结论成立。</p><h2 id="b-1">b</h2><p>由于每个元字符都恰好是一个三元组，因此我们可以使用基数排序完成，只需要进行三趟。由于字符的大小有限，因此每趟基数排序的内部使用计数排序，最终可以在<span class="math inline">\(\Theta(n)\)</span>的时间内完成这个排序过程。需要注意的是，由于前面的字符占主导地位，因此基数排序过程是对这些三元组中的每个字符从后往前进行。如下算法<code>SA-SORT-CHARACTERS</code>给出了这个过程，可见其时间复杂度为<span class="math inline">\(\Theta(n)\)</span>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 假设字符出P中的每个字符用三元组(s[1], s[2], s[3])表示，分别表示元字符中的第一、第二和第三个字符。</span><br><span class="line">SA-SORT-CHARACTERS(P, n)</span><br><span class="line">  // L数组中的元素有两个属性：s属性是对应下标的元字符，index属性表示当前字符的下标。</span><br><span class="line">  let L[1 : n], L&#x27;[1 : n], P&#x27;[1 : n] be new arrays</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    L[i].index = i</span><br><span class="line">    L[i].s = P[i].s</span><br><span class="line">  mx = 0</span><br><span class="line">  // 这里使用mx表示元字符中，所有内部字符的最大大小。</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    mx = max&#123;mx, P[i].s[1], P[i].s[2], P[i].s[3]&#125;</span><br><span class="line">  let cnt[0 : mx] be a new array</span><br><span class="line">  for d = 3 downto 1</span><br><span class="line">    for j = 0 to mx</span><br><span class="line">      cnt[j] = 0 </span><br><span class="line">    for i = 1 to n</span><br><span class="line">      cnt[L[i].s[d]] = cnt[L[i].s[d]] + 1</span><br><span class="line">    for j = 1 to mx</span><br><span class="line">      cnt[j] = cnt[j - 1] + cnt[j]</span><br><span class="line">    for i = n downto 1</span><br><span class="line">      L&#x27;[cnt[L[i].s[d]]] = L[i]</span><br><span class="line">      cnt[L[i].s[d]] = cnt[L[i].s[d]] - 1</span><br><span class="line">    L = L&#x27;</span><br><span class="line">  r = 1</span><br><span class="line">  P&#x27;[L[1].index] = 1</span><br><span class="line">  for i = 2 to n</span><br><span class="line">    if L[i].s != L[i - 1].s</span><br><span class="line">      r = r + 1</span><br><span class="line">    P&#x27;[L[i].index] = r</span><br><span class="line">  return P&#x27;</span><br></pre></td></tr></table></figure><h2 id="c-1">c</h2><p>假设后缀<span class="math inline">\(P[i:]\)</span>是非采样后缀，那么有<span class="math inline">\(r_i=\square,r_{i+1}\)</span>是一个非负整数。如果<span class="math inline">\(r_i\neq \square\)</span>，那么说明<span class="math inline">\(r_i\)</span>是进行递归后，对应采样后缀的排名，因此这些<span class="math inline">\(r_i\)</span>是非负整数的情况下是唯一的，因此这使得二元组<span class="math inline">\((T[i],r_{i+1})\)</span>是唯一的。</p><p>由于原字符<span class="math inline">\(T[i]\)</span>的范围非常小，因此我们同样可以使用题目32-2-b的思路，使用基数排序（每趟内部使用计数排序）对这些二元组进行排序。如下算法<code>SA-SORT-CHARACTERS</code>给出了这个过程，可见其时间复杂度为<span class="math inline">\(\Theta(n)\)</span>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">SA-SORT-NONSAMPLE-SUFFIXES(T, r, n)</span><br><span class="line">  n&#x27; = ⌊n / 3⌋</span><br><span class="line">  let L[1 : n&#x27;], L&#x27;[1 : n&#x27;], nonsapmle[1 : n&#x27;] be new arrays</span><br><span class="line">  for i = 3 to n by 3</span><br><span class="line">    let L[i / 3].t[1 : 2] be a new array</span><br><span class="line">    L[i / 3].t[1] = T[i]</span><br><span class="line">    L[i / 3].t[2] = r[i + 1]</span><br><span class="line">    L[i / 3].index = i</span><br><span class="line">  mx = 0</span><br><span class="line">  // 这里使用mx表示元字符中，所有字符的大小。</span><br><span class="line">  for i = 1 to n&#x27;</span><br><span class="line">    mx = max&#123;mx, L[i].t[1], L[i].t[2]&#125;</span><br><span class="line">  let cnt[0 : mx] be a new array</span><br><span class="line">  for d = 2 downto 1</span><br><span class="line">    for j = 0 to mx</span><br><span class="line">      cnt[j] = 0 </span><br><span class="line">    for i = 1 to n&#x27;</span><br><span class="line">      cnt[L[i].t[d]] = cnt[L[i].t[d]] + 1</span><br><span class="line">    for j = 1 to mx</span><br><span class="line">      cnt[j] = cnt[j - 1] + cnt[j]</span><br><span class="line">    for i = n&#x27; downto 1</span><br><span class="line">      L&#x27;[cnt[L[i].s[d]]] = L[i]</span><br><span class="line">      cnt[L[i].s[d]] = cnt[L[i].s[d]] - 1</span><br><span class="line">    L = L&#x27;</span><br><span class="line">  return L</span><br></pre></td></tr></table></figure><h2 id="d">d</h2><p>假设字符串<span class="math inline">\(T\)</span>后面已经拼接了两个<span class="math inline">\(\varnothing\)</span>，对应到<span class="math inline">\(r\)</span>数组中其值为<span class="math inline">\(0\)</span>，也就是说，字符串<span class="math inline">\(T\)</span>现在的长度为<span class="math inline">\(n+2\)</span>。</p><p>其基本思想是，对于任意一对下标<span class="math inline">\(i,j(i\not\equiv j\pmod 3,1\le i,j\len)\)</span>，只要最多比较三次就能比较出字典序。也就是说，只要比对<span class="math inline">\((P[i],P[j]),(P[i+1],P[j+1]),(P[i+2],P[j+2])\)</span>即可。可以发现，必定存在最小的<span class="math inline">\(s(0\le s\le 2)\)</span>，使得<span class="math inline">\(r_{i+s}\neq\square\landr_{j+s}\neq\square\)</span>。</p><p>具体过程由<code>SA-SORT-MERGE</code>给出，它将原有的<span class="math inline">\(r\)</span>数组以及题目32-2-d所排好序的二元组进行归并，返回最终得到的<span class="math inline">\(SA\)</span>数组。最终这个过程在<span class="math inline">\(\Theta(n)\)</span>的时间内完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// 字符串T的长度为n+2，包括后面已经拼接了两个∅，r[n + 1] = r[n + 2] = 0。</span><br><span class="line">// 数组r如题意所示。</span><br><span class="line">// 数组nonsample是已经排好序的非采样后缀的下标，保证其大小为⌊n / 3⌋。</span><br><span class="line">SA-SORT-MERGE(T, r, nonsample, n)</span><br><span class="line">  n&#x27; = ⌊n / 3⌋</span><br><span class="line">  sample-choice = 1</span><br><span class="line">  nonsample-choice = 2</span><br><span class="line">  let sample[1 : n - n&#x27;] be a new array</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    if i % 3 != 0</span><br><span class="line">      sample[r[i]] = i</span><br><span class="line">  let SA[1 : n] be a new array</span><br><span class="line">  ls = 1</span><br><span class="line">  ln = 1</span><br><span class="line">  k = 1</span><br><span class="line">  while ls &lt;= n - n&#x27; and ln &lt;= n&#x27;</span><br><span class="line">    p = sample[ls]</span><br><span class="line">    q = nonsample[ln]</span><br><span class="line">    if T[p] != T[q]</span><br><span class="line">      if T[p] &lt; T[q]</span><br><span class="line">        choice = sample-choice</span><br><span class="line">      else</span><br><span class="line">        choice = nonsample-choice</span><br><span class="line">    else if p % 3 == 1</span><br><span class="line">      // 此时r[p + 1] != □必定成立</span><br><span class="line">      if r[p + 1] &lt; r[q + 1]</span><br><span class="line">        choice = sample-choice</span><br><span class="line">      else</span><br><span class="line">        choice = nonsample-choice</span><br><span class="line">    else</span><br><span class="line">      // 此时r[p + 1] != □必定成立</span><br><span class="line">      if T[p + 1] &lt; T[q + 1] or T[p + 1] == T[q + 1] and r[p + 2] &lt; r[q + 2]</span><br><span class="line">        choice = sample-choice</span><br><span class="line">      else</span><br><span class="line">        choice = nonsample-choice</span><br><span class="line">    if choice == sample-choice</span><br><span class="line">      SA[k] = p</span><br><span class="line">      k = k + 1</span><br><span class="line">      ls = ls + 1</span><br><span class="line">    else</span><br><span class="line">      SA[k] = q</span><br><span class="line">      k = k + 1</span><br><span class="line">      ln = ln + 1</span><br><span class="line">  while ls &lt;= n - n&#x27;</span><br><span class="line">    SA[k] = sample[ls]</span><br><span class="line">    k = k + 1</span><br><span class="line">    ls = ls + 1</span><br><span class="line">  while ls &lt;= n&#x27;</span><br><span class="line">    SA[k] = nonsample[ls]</span><br><span class="line">    k = k + 1</span><br><span class="line">    ln = ln + 1</span><br><span class="line">  return SA</span><br></pre></td></tr></table></figure><h2 id="e">e</h2><p>综上所述：</p><ol type="1"><li><p>步骤1进行的是第一步分治。子步骤A和B花费了<span class="math inline">\(\Theta(n)\)</span>的时间来构造字符串<span class="math inline">\(P,P_1,P_2\)</span>。子步骤C使用了题目32-2-b的算法，对字符串<span class="math inline">\(P\)</span>中的字符进行排序，并通过子步骤D进行产生<span class="math inline">\(P\)</span>中每个字符的排名，存在数组<span class="math inline">\(P&#39;\)</span>中，这个过程使用了基数排序和计数排序的方法，总共花费了<span class="math inline">\(\Theta(n)\)</span>的时间。子步骤E递归构造<span class="math inline">\(P&#39;\)</span>的<span class="math inline">\(SA\)</span>数组，由于其长度为<span class="math inline">\(2n/3\)</span>，因此需要花费<span class="math inline">\(T(2n/3)\)</span>的时间。子步骤F则使用<span class="math inline">\(\Theta(n)\)</span>的时间将<span class="math inline">\(P&#39;\)</span>的<span class="math inline">\(SA\)</span>数组映射回采样后缀中。</p></li><li><p>步骤2进行的是第二步分治。子步骤G使用<span class="math inline">\(\Theta(n)\)</span>的时间求出<span class="math inline">\(r\)</span>数组。子步骤H使用了题目32-2-c的算法，对<span class="math inline">\((T[i],r_{i+1})\)</span>二元组进行排序，由于同样使用了基数排序和计数排序的方法，因此总共花费了<span class="math inline">\(\Theta(n)\)</span>的时间。</p></li><li><p>步骤3进行的是归并。它将两个分支步骤的结果进行归并。使用题目32-2-d的算法在<span class="math inline">\(\Theta(n)\)</span>时间内求出最终的<span class="math inline">\(SA\)</span>数组。</p></li></ol><p>因此，除了步骤1的子步骤E需要求解规模为<span class="math inline">\(2n/3\)</span>的子问题，其余步骤都需要花费<span class="math inline">\(\Theta(n)\)</span>的时间进行处理，因此有<span class="math inline">\(T(n)=T(2n/3)+\Theta(n)\)</span>。按照主定理，有<span class="math inline">\(T(n)=\Theta(n)\)</span>，因此这是一个线性时间求解<span class="math inline">\(SA\)</span>数组的算法。</p><h1 id="section-2">32-3</h1><h2 id="a-2">a</h2><p>需要注意的是，拼接的字符<span class="math inline">\(\mathtt{\$}\)</span>的字典序是所有字符中最小的。可以假定，在为字符串构造SA数组时，它后面都有一个终结符<span class="math inline">\(\mathtt{\$}\)</span>。因此，在对所有后缀排好序后，可以发现每个后缀的排名都是唯一的，此时在这些后缀后面如何加字符，都不会影响它们原本的排名。因此，BWT只需要挪用<span class="math inline">\(SA\)</span>数组的结果即可，不过需要先在<span class="math inline">\(SA\)</span>数组的最前面再插入一个值<span class="math inline">\(|T|+1\)</span>，那么这时的结果才是BWT数组产生的结果。最终，字符串<span class="math inline">\(t[i]=T[(BWT [i]-1-1)\bmod (|T|+1) +1]\)</span>才是BWT的结果。更具体的过程由<code>BWT-KNOWN-SA</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BWT-KNOWN-SA(T, SA, n)</span><br><span class="line">  let BWT[1 : n + 1] be a new array</span><br><span class="line">  W = T$</span><br><span class="line">  t = T[n]</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    t = t W[(SA[i] - 1 - 1) mod (n + 1) + 1]</span><br><span class="line">  return t</span><br></pre></td></tr></table></figure><h2 id="b-2">b</h2><p>基于插入排序的思想就可以计算出每个下标的排名，如下给出<code>BWT-COMPUTE-RANK</code>将给出计算<span class="math inline">\(rank\)</span>数组的算法。如果字母表中一共有<span class="math inline">\(k\)</span>个字符，并且其范围是从<span class="math inline">\(1\)</span>到<span class="math inline">\(k\)</span>，那么<code>BWT-COMPUTE-RANK</code>计算<span class="math inline">\(rank\)</span>数组的时间复杂度为<span class="math inline">\(\Theta(n+k)\)</span>。如果<span class="math inline">\(k=O(n)\)</span>或者是一个常数，那么就有<span class="math inline">\(\Theta(n+k)=\Theta(n)\)</span>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BWT-COMPUTE-RANK(T, n, k)</span><br><span class="line">  let C[0 : k], rank[1 : n] be new arrays by 0</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    C[T[i]] = C[T[i]] + 1</span><br><span class="line">  for i = 1 to k</span><br><span class="line">    C[i] = C[i] + C[i-1]</span><br><span class="line">  for i = n downto 1</span><br><span class="line">    rank[i] = C[T[i]]</span><br><span class="line">    C[T[i]] = C[T[i]] - 1</span><br><span class="line">  return rank</span><br></pre></td></tr></table></figure><h2 id="c-2">c</h2><p>只需要按照题目的含义进行模拟即可，先从<span class="math inline">\(\mathtt{\$}\)</span>开始填充，因为它必定处于最后一位。整个过程由<code>BWT-INV</code>给出，可见其由于只有一个<code>for</code>循环进行常数操作，因此其时间复杂度为<span class="math inline">\(\Theta O(n)\)</span>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BWT-INV-RANK(T, rank, n)</span><br><span class="line">  let S[1 : n] be a new array</span><br><span class="line">  pos = 0</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    if T[i] == $</span><br><span class="line">      pos = i</span><br><span class="line">  for i = n downto 1</span><br><span class="line">    S[i] = T[pos]</span><br><span class="line">    pos = rank[pos]</span><br><span class="line">  interpret S[1 : n - 1] as a string s</span><br><span class="line">  return s</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论32.5 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-5-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-5-Exercises/</id>
    <published>2023-10-07T16:57:28.000Z</published>
    <updated>2023-10-07T16:57:28.858Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">32.5-1</h1><p>如下两表，是分别执行完<code>COMPUTE-SUFFIX-ARRAY</code>的第2-7行和第8行后的结果。</p><p><span class="math inline">\(\begin{array}{ccccl}i&amp;left\text{-}rank&amp;right\text{-}rank&amp;index&amp;\text{substring}\\\hline1&amp;8&amp;9&amp;1&amp;\texttt{hi}\\2&amp;9&amp;16&amp;2&amp;\texttt{ip}\\3&amp;16&amp;16&amp;3&amp;\texttt{pp}\\4&amp;16&amp;9&amp;4&amp;\texttt{pi}\\5&amp;9&amp;20&amp;5&amp;\texttt{it}\\6&amp;20&amp;25&amp;6&amp;\texttt{ty}\\7&amp;25&amp;8&amp;7&amp;\texttt{yh}\\8&amp;8&amp;15&amp;8&amp;\texttt{ho}\\9&amp;15&amp;16&amp;9&amp;\texttt{op}\\10&amp;16&amp;16&amp;10&amp;\texttt{pp}\\11&amp;16&amp;9&amp;11&amp;\texttt{pi}\\12&amp;9&amp;20&amp;12&amp;\texttt{it}\\13&amp;20&amp;25&amp;13&amp;\texttt{ty}\\14&amp;25&amp;0&amp;14&amp;\texttt{y}\\ \end{array} \qquad\begin{array}{ccccl}i&amp;left\text{-}rank&amp;right\text{-}rank&amp;index&amp;\text{substring}\\\hline1&amp;8&amp;9&amp;1&amp;\texttt{hi}\\2&amp;8&amp;15&amp;8&amp;\texttt{ho}\\3&amp;9&amp;16&amp;2&amp;\texttt{ip}\\4&amp;9&amp;20&amp;5&amp;\texttt{it}\\5&amp;9&amp;20&amp;12&amp;\texttt{it}\\6&amp;15&amp;16&amp;9&amp;\texttt{op}\\7&amp;16&amp;9&amp;4&amp;\texttt{pi}\\8&amp;16&amp;9&amp;11&amp;\texttt{pi}\\9&amp;16&amp;16&amp;3&amp;\texttt{pp}\\10&amp;16&amp;16&amp;10&amp;\texttt{pp}\\11&amp;20&amp;25&amp;6&amp;\texttt{ty}\\12&amp;20&amp;25&amp;13&amp;\texttt{ty}\\13&amp;25&amp;0&amp;14&amp;\texttt{y}\\14&amp;25&amp;8&amp;7&amp;\texttt{yh}\\ \end{array}\)</span></p><p>当<span class="math inline">\(l=2\)</span>时，分别执行完<code>COMPUTE-SUFFIX-ARRAY</code>的第11行，第12-17行和第18行的结果如下三个表所示。</p><p><span class="math inline">\(\begin{array}{ccl}i&amp;rank&amp;\text{substring}\\\hline 1&amp;1&amp;\texttt{hi}\\2&amp;3&amp;\texttt{ip}\\ 3&amp;7&amp;\texttt{pp}\\4&amp;6&amp;\texttt{pi}\\ 5&amp;4&amp;\texttt{it}\\6&amp;8&amp;\texttt{ty}\\ 7&amp;10&amp;\texttt{yh}\\8&amp;2&amp;\texttt{ho}\\ 9&amp;5&amp;\texttt{op}\\10&amp;7&amp;\texttt{pp}\\ 11&amp;6&amp;\texttt{pi}\\12&amp;4&amp;\texttt{it}\\ 13&amp;8&amp;\texttt{ty}\\14&amp;9&amp;\texttt{y}\\ \end{array}\qquad \begin{array}{ccccl}i&amp;left\text{-}rank&amp;right\text{-}rank&amp;index&amp;\text{substring}\\\hline1&amp;1&amp;7&amp;1&amp;\texttt{hipp}\\2&amp;3&amp;6&amp;2&amp;\texttt{ippi}\\3&amp;7&amp;4&amp;3&amp;\texttt{ppit}\\4&amp;6&amp;8&amp;4&amp;\texttt{pity}\\5&amp;4&amp;10&amp;5&amp;\texttt{ityh}\\6&amp;8&amp;2&amp;6&amp;\texttt{tyho}\\7&amp;10&amp;5&amp;7&amp;\texttt{yhop}\\8&amp;2&amp;7&amp;8&amp;\texttt{hopp}\\9&amp;5&amp;6&amp;9&amp;\texttt{oppi}\\10&amp;7&amp;4&amp;10&amp;\texttt{ppit}\\11&amp;6&amp;8&amp;11&amp;\texttt{pity}\\12&amp;4&amp;9&amp;12&amp;\texttt{ity}\\13&amp;8&amp;0&amp;13&amp;\texttt{ty}\\14&amp;9&amp;0&amp;14&amp;\texttt{y}\\ \end{array}\qquad\begin{array}{ccccl}i&amp;left\text{-}rank&amp;right\text{-}rank&amp;index&amp;\text{substring}\\\hline1&amp;1&amp;7&amp;1&amp;\texttt{hipp}\\2&amp;2&amp;7&amp;8&amp;\texttt{hopp}\\3&amp;3&amp;6&amp;2&amp;\texttt{ippi}\\4&amp;4&amp;9&amp;12&amp;\texttt{ity}\\5&amp;4&amp;10&amp;5&amp;\texttt{ityh}\\6&amp;5&amp;6&amp;9&amp;\texttt{oppi}\\7&amp;6&amp;8&amp;4&amp;\texttt{pity}\\8&amp;6&amp;8&amp;11&amp;\texttt{pity}\\9&amp;7&amp;4&amp;3&amp;\texttt{ppit}\\10&amp;7&amp;4&amp;10&amp;\texttt{ppit}\\11&amp;8&amp;0&amp;13&amp;\texttt{ty}\\12&amp;8&amp;2&amp;6&amp;\texttt{tyho}\\13&amp;9&amp;0&amp;14&amp;\texttt{y}\\14&amp;10&amp;5&amp;7&amp;\texttt{yhop}\\ \end{array}\)</span></p><p>当<span class="math inline">\(l=4\)</span>时，分别执行完<code>COMPUTE-SUFFIX-ARRAY</code>的第11行，第12-17行和第18行的结果如下三个表所示。</p><p><span class="math inline">\(\begin{array}{ccl}i&amp;rank&amp;\text{substring}\\\hline 1&amp;1&amp;\texttt{hipp}\\2&amp;3&amp;\texttt{ippi}\\ 3&amp;8&amp;\texttt{ppit}\\4&amp;7&amp;\texttt{pity}\\ 5&amp;5&amp;\texttt{ityh}\\6&amp;10&amp;\texttt{tyho}\\ 7&amp;12&amp;\texttt{yhop}\\8&amp;2&amp;\texttt{hopp}\\ 9&amp;6&amp;\texttt{oppi}\\10&amp;8&amp;\texttt{ppit}\\ 11&amp;7&amp;\texttt{pity}\\12&amp;4&amp;\texttt{ity}\\ 13&amp;9&amp;\texttt{ty}\\14&amp;11&amp;\texttt{y}\\ \end{array}\qquad \begin{array}{ccccl}i&amp;left\text{-}rank&amp;right\text{-}rank&amp;index&amp;\text{substring}\\\hline1&amp;1&amp;5&amp;1&amp;\texttt{hippityh}\\2&amp;3&amp;10&amp;2&amp;\texttt{ippityho}\\3&amp;8&amp;12&amp;3&amp;\texttt{ppityhop}\\4&amp;7&amp;2&amp;4&amp;\texttt{pityhopp}\\5&amp;5&amp;6&amp;5&amp;\texttt{ityhoppi}\\6&amp;10&amp;8&amp;6&amp;\texttt{tyhoppit}\\7&amp;12&amp;7&amp;7&amp;\texttt{yhoppity}\\8&amp;2&amp;4&amp;8&amp;\texttt{hoppity}\\9&amp;6&amp;9&amp;9&amp;\texttt{oppity}\\10&amp;8&amp;11&amp;10&amp;\texttt{ppity}\\11&amp;7&amp;0&amp;11&amp;\texttt{pity}\\12&amp;4&amp;0&amp;12&amp;\texttt{ity}\\13&amp;9&amp;0&amp;13&amp;\texttt{ty}\\14&amp;11&amp;0&amp;14&amp;\texttt{y}\\ \end{array}\qquad\begin{array}{ccccl}i&amp;left\text{-}rank&amp;right\text{-}rank&amp;index&amp;\text{substring}\\\hline1&amp;1&amp;5&amp;1&amp;\texttt{hippityh}\\2&amp;2&amp;4&amp;8&amp;\texttt{hoppity}\\3&amp;3&amp;10&amp;2&amp;\texttt{ippityho}\\4&amp;4&amp;0&amp;12&amp;\texttt{ity}\\5&amp;5&amp;6&amp;5&amp;\texttt{ityhoppi}\\6&amp;6&amp;9&amp;9&amp;\texttt{oppity}\\7&amp;7&amp;0&amp;11&amp;\texttt{pity}\\8&amp;7&amp;2&amp;4&amp;\texttt{pityhopp}\\9&amp;8&amp;11&amp;10&amp;\texttt{ppity}\\10&amp;8&amp;12&amp;3&amp;\texttt{ppityhop}\\11&amp;9&amp;0&amp;13&amp;\texttt{ty}\\12&amp;10&amp;8&amp;6&amp;\texttt{tyhoppit}\\13&amp;11&amp;0&amp;14&amp;\texttt{y}\\14&amp;12&amp;7&amp;7&amp;\texttt{yhoppity}\\ \end{array}\)</span></p><p>当<span class="math inline">\(l=8\)</span>时，分别执行完<code>COMPUTE-SUFFIX-ARRAY</code>的第11行，第12-17行和第18行的结果如下三个表所示。</p><p><span class="math inline">\(\begin{array}{ccl}i&amp;rank&amp;\text{substring}\\\hline 1&amp;1&amp;\texttt{hippityh}\\2&amp;3&amp;\texttt{ippityho}\\ 3&amp;10&amp;\texttt{ppityhop}\\4&amp;8&amp;\texttt{pityhopp}\\ 5&amp;5&amp;\texttt{ityhoppi}\\6&amp;12&amp;\texttt{tyhoppit}\\ 7&amp;14&amp;\texttt{yhoppity}\\8&amp;2&amp;\texttt{hoppity}\\ 9&amp;6&amp;\texttt{oppity}\\10&amp;9&amp;\texttt{ppity}\\ 11&amp;7&amp;\texttt{pity}\\12&amp;4&amp;\texttt{ity}\\ 13&amp;11&amp;\texttt{ty}\\14&amp;13&amp;\texttt{y}\\ \end{array}\qquad\begin{array}{ccccl}i&amp;left\text{-}rank&amp;right\text{-}rank&amp;index&amp;\text{substring}\\\hline1&amp;1&amp;6&amp;1&amp;\texttt{hippityhoppity}\\2&amp;3&amp;9&amp;2&amp;\texttt{ippityhoppity}\\3&amp;10&amp;7&amp;3&amp;\texttt{ppityhoppity}\\4&amp;8&amp;4&amp;4&amp;\texttt{pityhoppity}\\5&amp;5&amp;11&amp;5&amp;\texttt{ityhoppity}\\6&amp;12&amp;13&amp;6&amp;\texttt{tyhoppity}\\7&amp;14&amp;0&amp;7&amp;\texttt{yhoppity}\\8&amp;2&amp;0&amp;8&amp;\texttt{hoppity}\\9&amp;6&amp;0&amp;9&amp;\texttt{oppity}\\10&amp;9&amp;0&amp;10&amp;\texttt{ppity}\\11&amp;7&amp;0&amp;11&amp;\texttt{pity}\\12&amp;4&amp;0&amp;12&amp;\texttt{ity}\\13&amp;11&amp;0&amp;13&amp;\texttt{ty}\\14&amp;13&amp;0&amp;14&amp;\texttt{y}\\\end{array}\qquad\begin{array}{ccccl}i&amp;left\text{-}rank&amp;right\text{-}rank&amp;index&amp;\text{substring}\\\hline1&amp;1&amp;6&amp;1&amp;\texttt{hippityhoppity}\\2&amp;2&amp;0&amp;8&amp;\texttt{hoppity}\\3&amp;3&amp;9&amp;2&amp;\texttt{ippityhoppity}\\4&amp;4&amp;0&amp;12&amp;\texttt{ity}\\5&amp;5&amp;11&amp;5&amp;\texttt{ityhoppity}\\6&amp;6&amp;0&amp;9&amp;\texttt{oppity}\\7&amp;7&amp;0&amp;11&amp;\texttt{pity}\\8&amp;8&amp;4&amp;4&amp;\texttt{pityhoppity}\\9&amp;9&amp;0&amp;10&amp;\texttt{ppity}\\10&amp;10&amp;7&amp;3&amp;\texttt{ppityhoppity}\\11&amp;11&amp;0&amp;13&amp;\texttt{ty}\\12&amp;12&amp;13&amp;6&amp;\texttt{tyhoppity}\\13&amp;13&amp;0&amp;14&amp;\texttt{y}\\14&amp;14&amp;0&amp;7&amp;\texttt{yhoppity}\\ \end{array}\)</span></p><p>因此，得到的<span class="math inline">\(SA\)</span>数组为<span class="math inline">\([1,8,2,12,5,9,11,4,10,3,13,6,14,7]\)</span>。</p><p>最终，按序填入<span class="math inline">\(LCP\)</span>数组的顺序如下表所示：</p><p><span class="math inline">\(\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}\hlinei&amp;1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8&amp;9&amp;10&amp;11&amp;12&amp;13&amp;14\\\hlines&amp;1&amp;3&amp;10&amp;8&amp;5&amp;12&amp;14&amp;2&amp;6&amp;9&amp;7&amp;4&amp;11&amp;13\\\hlineLCP[i]&amp;0&amp;0&amp;5&amp;4&amp;3&amp;2&amp;1&amp;1&amp;0&amp;1&amp;0&amp;1&amp;0&amp;0\\\hline\end{array}\)</span></p><p>因此，得到的<span class="math inline">\(LCP\)</span>数组为<span class="math inline">\([0,1,0,1,3,0,0,4,1,5,0,2,0,1]\)</span>。</p><h1 id="section-1">32.5-2</h1><p>基本思想是，如果不需要<span class="math inline">\(\lfloor\lgn\rfloor-1\)</span>次<code>while</code>循环就能够区分出所有后缀的排名，那么<code>while</code>循环可以提前终止。</p><p>具体细节是，在<code>MAKE-RANKS</code>的过程中，如果最后一名的后缀的排名已经恰好达到了<span class="math inline">\(n\)</span>，那么可以终止<code>while</code>循环。修改狗的算法由<code>COMPUTE-SUFFIX-ARRAY'</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">COMPUTE-SUFFIX-ARRAY&#x27;(T, n)</span><br><span class="line">  allocate arrays substr-rank[1:n], rank[1:n], and SA[1:n]</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    substr-rank[i].left-rank = ord(T[i])</span><br><span class="line">    if i &lt; n</span><br><span class="line">      substr-rank[i].right-rank = ord(T[i + 1])</span><br><span class="line">    else substr-rank[i].right-rank = 0</span><br><span class="line">    substr-rank[i].index = i</span><br><span class="line">  sort the array substr-rank into monotonically increasing order based on the left-rank attributes, using the right-rank attributes to break ties; if still a tie, the order does not matter</span><br><span class="line">  l = 2</span><br><span class="line">  while l &lt; n</span><br><span class="line">    MAKE-RANKS(substr-rank, rank, n)</span><br><span class="line">    for i = 1 to n</span><br><span class="line">      substr-rank[i].left-rank = rank[i]</span><br><span class="line">      if i + l ≤ n</span><br><span class="line">        substr-rank[i].right-rank = rank[i + l]</span><br><span class="line">      else substr-rank[i].right-rank = 0</span><br><span class="line">      substr-rank[i].index = i</span><br><span class="line">    sort the array substr-rank into monotonically increasing order based on the left-rank attributes, using the right-rank attributes to break ties; if still a tie, the order does not matter</span><br><span class="line">    l = 2 * l</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    SA[i] = substr-rank[i].index</span><br><span class="line">  return SA</span><br></pre></td></tr></table></figure><h1 id="section-2">32.5-3</h1><p>使用一个不曾出现在<span class="math inline">\(T_1,T_2\)</span>中的字符<span class="math inline">\(\texttt{@}\)</span>，并将其和<span class="math inline">\(T_1,T_2\)</span>拼接起来，得到<span class="math inline">\(T=T_1\texttt{@}T_2\)</span>，其长度为<span class="math inline">\(n=n_1+n_2+1\)</span>。对字符串<span class="math inline">\(T\)</span>求出它的<code>SA</code>数组和<code>LCP</code>数组后，枚举<span class="math inline">\(T\)</span>中每对排名相邻的后缀<span class="math inline">\(SA[i],SA[i-1]\)</span>。如果这两个后缀来自<span class="math inline">\(T\)</span>的不同部分（也就是其中一个来自<span class="math inline">\(T_1\)</span>，另一个来自<span class="math inline">\(T_2\)</span>）那么说明这两个后缀的最长公共前缀为<span class="math inline">\(T_1,T_2\)</span>这两个字符串的子串之一，由于<span class="math inline">\(\texttt{@}\)</span>不在<span class="math inline">\(T_1\)</span>中，因此可以确保<span class="math inline">\(LCP\)</span>不会恰好经过<span class="math inline">\(\texttt{@}\)</span>。具体过程由程序<code>LONGEST-COMMON-SUBSTRINGS</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">LONGEST-COMMON-SUBSTRINGS(T1, T2, n1, n2)</span><br><span class="line">  T = T1 @ T2</span><br><span class="line">  n = n1 + n2 + 1</span><br><span class="line">  SA = COMPUTE-SUFFIX-ARRAY(T, n)</span><br><span class="line">  LCP = COMPUTE-LCP(T, SA, n)</span><br><span class="line">  len = 0</span><br><span class="line">  S = ∅</span><br><span class="line">  for i = 2 to n</span><br><span class="line">    l = SA[i - 1]</span><br><span class="line">    r = SA[i]</span><br><span class="line">    if min&#123;l, r&#125; &lt;= n1 and max(l, r) &gt; n1 + 1</span><br><span class="line">      if LCP[i] &gt; len</span><br><span class="line">        len = LCP[i]</span><br><span class="line">        S = &#123;min&#123;l, r&#125;&#125;</span><br><span class="line">    else if lCP[i] == len</span><br><span class="line">        S = S ∪ &#123;min&#123;l, r&#125;&#125;</span><br><span class="line">  let string-list be a new array</span><br><span class="line">  for l in S</span><br><span class="line">    INSERT(string-list, T1[l : l + len - 1])</span><br><span class="line">  return string-list</span><br></pre></td></tr></table></figure><h1 id="section-3">32.5-4</h1><p>这里首先需要解释一下这个约束<span class="math inline">\(SA[i-1]=n&#39;-SA[i]-LCP[i]+2\)</span>是怎么来的：</p><p>首先，<span class="math inline">\(T\)</span>中有一个子串<span class="math inline">\([l,r]\)</span>是回文串，那么在<span class="math inline">\(T&#39;\)</span>这个字符串中，其在后半段对应的位置中是<span class="math inline">\([l&#39;,r&#39;]\)</span>。这意味着<span class="math inline">\(r-l+1=r&#39;-l&#39;+1=\text{len}\)</span>，由于<span class="math inline">\(T&#39;\)</span>的最后<span class="math inline">\(n\)</span>个字符是由<span class="math inline">\(T\)</span>反转而来，并且字符<span class="math inline">\(\texttt{@}\)</span>处在下标<span class="math inline">\(\dfrac{n&#39;+1}{2}\)</span>中，因此有<span class="math inline">\(\dfrac{n&#39;+1}{2}-r=l&#39;-\dfrac{n&#39;+1}{2}\)</span>。最终联立上面两个式子可以得到<span class="math inline">\(n&#39;+1=l&#39;+l+\text{len}-1\)</span>，更进一步可以得到<span class="math inline">\(l&#39;=n&#39;-l-\text{len}+2\)</span>，和上面给定的约束很像。</p><p>因此，这个求解最长回文子串的算法的错误在于，它认为后缀<span class="math inline">\(T[l:]\)</span>和<span class="math inline">\(T[l&#39;:]\)</span>在<span class="math inline">\(SA\)</span>数组中是相邻的，然而并非如此。</p><p>考虑字符串<span class="math inline">\(T=\texttt{abbcabb}\)</span>，那么有<span class="math inline">\(T&#39;=\texttt{abbcabb@bbacbba}\)</span>。等算法结束后，我们可以得到关于这个字符串的表格：</p><p><span class="math inline">\(\begin{array}{cclc}i&amp;SA[i]&amp;\text{substring}&amp;LCP[i]&amp;SA[i-1]=n&#39;-SA[i]-LCP[i]+2\\\hline1&amp;8&amp;\texttt{@bbacbba}&amp;0&amp;\text{No}\\2&amp;15&amp;\texttt{a}&amp;0&amp;\text{No}\\3&amp;5&amp;\texttt{abb@bbacbba}&amp;1&amp;\text{No}\\4&amp;1&amp;\texttt{abbcabb@bbacbba}&amp;3&amp;\text{No}\\5&amp;11&amp;\texttt{acbba}&amp;1&amp;\text{No}\\6&amp;7&amp;\texttt{b@bbacbba}&amp;0&amp;\text{No}\\7&amp;14&amp;\texttt{ba}&amp;1&amp;\text{No}\\8&amp;10&amp;\texttt{bacbba}&amp;2&amp;\text{No}\\9&amp;6&amp;\texttt{bb@bbacbba}&amp;1&amp;\text{Yes}\\10&amp;13&amp;\texttt{bba}&amp;2&amp;\text{No}\\11&amp;9&amp;\texttt{bbacbba}&amp;3&amp;\text{No}\\12&amp;2&amp;\texttt{bbcabb@bbacbba}&amp;2&amp;\text{No}\\13&amp;3&amp;\texttt{bcabb@bbacbba}&amp;1&amp;\text{No}\\14&amp;4&amp;\texttt{cabb@bbacbba}&amp;0&amp;\text{No}\\15&amp;12&amp;\texttt{cbba}&amp;1&amp;\text{Yes}\\\end{array}\)</span></p><p>由表格可知这个算法的输出结果为<span class="math inline">\(1\)</span>，但是实际上答案为<span class="math inline">\(2\)</span>。<span class="math inline">\(T\)</span>一共有两个子串<span class="math inline">\(\texttt{bb}\)</span>满足答案。其中一对<span class="math inline">\(\texttt{bb}\)</span>及其在后半段的反转分别是<span class="math inline">\(T&#39;[2:3],T&#39;[13:14]\)</span>，但是在<span class="math inline">\(SA\)</span>数组中，<span class="math inline">\(2\)</span>和<span class="math inline">\(13\)</span>不相邻。同样的，另一对<span class="math inline">\(\texttt{bb}\)</span>则及其反转分别是在<span class="math inline">\(T&#39;[6:7],T&#39;[9:10]\)</span>，但是在<span class="math inline">\(SA\)</span>数组中，<span class="math inline">\(6\)</span>和<span class="math inline">\(10\)</span>不相邻。</p><p>最终是因为约束<span class="math inline">\(SA[i-1]=n&#39;-SA[i]-LCP[i]+2\)</span>认为后缀<span class="math inline">\(T[l:]\)</span>和<span class="math inline">\(T[l&#39;:]\)</span>在<span class="math inline">\(SA\)</span>数组中是相邻的，导致了错误。因此这个约束不正确。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论32.4 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-4-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-4-Exercises/</id>
    <published>2023-10-07T16:57:25.000Z</published>
    <updated>2023-10-07T16:57:25.833Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">32.4-1</h1><p>模式串<span class="math inline">\(P=\texttt{ababbabbabbababbabb}\)</span>的前缀数组为<span class="math inline">\(\pi=(0,0,1,2,0,1,2,0,1,2,0,1,2,3,4,5,6,7,8)\)</span>。</p><h1 id="section-1">32.4-2</h1><p><span class="math inline">\(\pi^{\ast}[q]\)</span>的大小可以达到<span class="math inline">\(q-1\)</span>。以<span class="math inline">\(m\)</span>个字符<span class="math inline">\(\texttt{a}\)</span>的模式串<span class="math inline">\(P\)</span>为例，对于<span class="math inline">\(\forallq\in[2,n],\pi^{\ast}[q]=\{1,2,\dots,q-1\}\)</span>。因此集合<span class="math inline">\(\pi^{\ast}[q]\)</span>的大小可以达到<span class="math inline">\(q-1\)</span>。</p><h1 id="section-2">32.4-3</h1><p>可见，在<span class="math inline">\(T\)</span>中出现<span class="math inline">\(P\)</span>的有效偏移量集合为<span class="math inline">\(\{q-2m:\pi[q]=m,q\ge 2m\}\)</span>。因为<span class="math inline">\(P\)</span>被拼接在了前面，因此需要减去<span class="math inline">\(P\)</span>已经占有的偏移量<span class="math inline">\(m\)</span>。此外，还需要满足<span class="math inline">\(q\ge 2m\)</span>，以避免和字符串<span class="math inline">\(P\)</span>有交叉。由于<span class="math inline">\(\pi\)</span>递增时，最多只会递增<span class="math inline">\(1\)</span>，因此只需要考虑等于<span class="math inline">\(m\)</span>的情况即可满足所有情况，而不需要考虑大于<span class="math inline">\(m\)</span>的情况。</p><h1 id="section-3">32.4-4</h1><p>不失一般性，这里只考虑<code>KMP-MATCHER</code>的主体部分（因为<code>COMPUTE-PREFIX-FUNCTION</code>的分析方式和<code>KMP-MATCHER</code>一致）。</p><p>按照定义，由于<span class="math inline">\(r=\pi[q]\)</span>是<span class="math inline">\(P[:q]\)</span>中最长的真子前缀同时也是其后缀，因此<span class="math inline">\(\pi[q]&lt;q\)</span>。这意味着第4-5中的<code>while</code>循环执行一次<span class="math inline">\(q\)</span>值就会减少。由于<span class="math inline">\(q\)</span>不可能为负数，并且第3行的每轮<code>for</code>循环中，只有第7行才会对<span class="math inline">\(q\)</span>增加（并且只增加<span class="math inline">\(1\)</span>），因此第5行最多也只会执行<span class="math inline">\(n\)</span>次。</p><p>最终，第2-10行只需要<span class="math inline">\(\Theta(n)\)</span>的时间即可完成。第1行的<code>COMPUTE-PREFIX-FUNCTION</code>使用类似分析方式可以得到其运行时间为<span class="math inline">\(\Theta(m)\)</span>。由于<span class="math inline">\(m\len\)</span>，因此<code>KMP-MATCHER</code>的时间复杂度为<span class="math inline">\(\Theta(m)+\Theta(n)=\Theta(n)\)</span>。</p><h1 id="section-4">32.4-5</h1><p>本题的分析框架和题目32.4-4的一样，只考虑<code>KMP-MATCHER</code>的主体部分。</p><p>令势函数<span class="math inline">\(\Phi(D_i)\)</span>表示第<span class="math inline">\(i\)</span>轮<code>for</code>循环结束后<span class="math inline">\(q\)</span>的值。由于<span class="math inline">\(q\)</span>的值在<code>for</code>循环开始前为<span class="math inline">\(0\)</span>，因此有<span class="math inline">\(\Phi(D_0)=0\)</span>。</p><p>令均摊开销<span class="math inline">\(\widehat{c_i}=c_i+\Phi(D_i)-\Phi(D_{i-1})\)</span>，其中<span class="math inline">\(c_i\)</span>表示真实开销。那么有<span class="math inline">\(\displaystyle{\sum_{i=1}^nc_i=\sum_{i=1}^n\widehat{c_i}-\Phi(D_n)+\Phi(D_0)}\)</span>。令每轮开销的均摊代价<span class="math inline">\(\widehat{c_i}=2\)</span>，那么有</p><p><span class="math inline">\(\begin{aligned}\sum_{i=1}^nc_i&amp;=\sum_{i=1}^n\widehat{c_i}-\Phi(D_n)+\Phi(D_0)\\&amp;\le \sum_{i=1}^nc_i+\Phi(D_0)\\ &amp;\le 2n\end{aligned}\)</span></p><p>因此<code>KMP-MATCHER</code>的第2-10行只需要<span class="math inline">\(\Theta(n)\)</span>的时间即可完成。第1行的<code>COMPUTE-PREFIX-FUNCTION</code>使用类似分析方式可以得到其运行时间为<span class="math inline">\(\Theta(m)\)</span>。由于<span class="math inline">\(m\len\)</span>，因此<code>KMP-MATCHER</code>的时间复杂度为<span class="math inline">\(\Theta(m)+\Theta(n)=\Theta(n)\)</span>。</p><h1 id="section-5">32.4-6</h1><p>按照题目给定的<span class="math inline">\(\pi&#39;\)</span>的定义，将<code>KMP-MATCHER</code>修改后的<code>KMP-MATCHER'</code>如下所示。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">COMPUTE-PREFIX-FUNCTION&#x27;(P, m)</span><br><span class="line">  π = COMPUTE-PREFIX-FUNCTION(P, m)</span><br><span class="line">  Let π&#x27;[1 : m - 1] be a new array</span><br><span class="line">  for q = 1 to m - 1</span><br><span class="line">    if π[q] == 0</span><br><span class="line">      π&#x27;[q] = 0</span><br><span class="line">    else if π[q] != 0 and P[π[q] + 1] == P[q + 1]</span><br><span class="line">      π&#x27;[q] = π&#x27;[π[q]]</span><br><span class="line">    else</span><br><span class="line">      π&#x27;[q] = π[q]</span><br><span class="line">  return π, π&#x27;</span><br><span class="line"></span><br><span class="line">KMP-MATCHER&#x27;(T, P, n, m)</span><br><span class="line">  π, π&#x27; = COMPUTE-PREFIX-FUNCTION(P, m)</span><br><span class="line">  q = 0</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    while q &gt; 0 and P[q + 1] != T[i]</span><br><span class="line">      q = π[q]</span><br><span class="line">    if P[q + 1] == T[i]</span><br><span class="line">      q = q + 1</span><br><span class="line">    if q == m</span><br><span class="line">      print &quot;Pattern occurs with shift&quot; i – m</span><br><span class="line">      q = π[q]</span><br></pre></td></tr></table></figure></p><p>接下来我们证明这个嵌套调用的<span class="math inline">\(\pi&#39;\)</span>是正确的。如果满足<span class="math inline">\(\pi&#39;\)</span>中定义的第一行和第三行的情况，那么就有<span class="math inline">\(\pi&#39;[q]=\pi[q]\)</span>，这和<code>KMP-MATCHER'</code>执行第5行的过程完全一致。</p><p>当满足<span class="math inline">\(\pi&#39;\)</span>的第二条情况时，即<span class="math inline">\(P[q+1]=P[\pi[q]+1]\)</span>，这种情况意味着在<code>KMP-MATCHER'</code>执行第5行的过程前后，都将会对<span class="math inline">\(P[q+1]\neq T[i]\)</span>和<span class="math inline">\(P[\pi [q]+1]\neqT[i]\)</span>进行判断。由于字母相同，这两种判断是没有必要的，<span class="math inline">\(\pi&#39;\)</span>将会跳到下一个和<span class="math inline">\(P[q+1]\)</span>不相同的字符<span class="math inline">\(P[\pi&#39; [q]+1]\)</span>再和<span class="math inline">\(T[i]\)</span>进行比较。因此这个过程是正确的。</p><p><span class="math inline">\(\pi&#39;\)</span>数组的存在是一个对<code>KMP-MATCHER</code>的优化，但是它不会降低<code>KMP-MATCHER</code>的时间复杂度。只有当<span class="math inline">\(T\)</span>的长度远大于<span class="math inline">\(P\)</span>的长度时，<span class="math inline">\(\pi&#39;\)</span>数组会对<code>KMP-MATCHER</code>带来常数上的优化。# 32.4-7</p><p><span class="math inline">\(T\)</span>是<span class="math inline">\(T&#39;\)</span>的旋转串，当且仅当<span class="math inline">\(T&#39;\)</span>出现在<span class="math inline">\(TT\)</span>中。因此这相当于执行了一次<code>KMP-MATCHER</code>算法。具体过程由<code>IS-CYCLIC-ROTATION</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">IS-CYCLIC-ROTATION(T, T&#x27;, m)</span><br><span class="line">  π = COMPUTE-PREFIX-FUNCTION(P, m)</span><br><span class="line">  q = 0</span><br><span class="line">  S = TT</span><br><span class="line">  for i = 1 to m + m</span><br><span class="line">    while q &gt; 0 and T[q + 1] != S[i]</span><br><span class="line">      q = π[q]</span><br><span class="line">    if T[q + 1] == S[i]</span><br><span class="line">      q = q + 1</span><br><span class="line">    if i &gt; m and q == m</span><br><span class="line">      print &quot;T&#x27; is T with shift&quot; i – m</span><br><span class="line">      q = π[q]</span><br></pre></td></tr></table></figure><h1 id="star-32.4-8"><span class="math inline">\(\star\)</span>32.4-8</h1><p>基于KMP算法的<span class="math inline">\(\pi\)</span>数组计算转移函数<span class="math inline">\(\delta\)</span>的算法由<code>COMPUTE-TRANSITION-FUNCTION-KMP</code>所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">COMPUTE-TRANSITION-FUNCTION-KMP(P, ∑, m)</span><br><span class="line">  π = COMPUTE-PREFIX-FUNCTION(P, m)</span><br><span class="line">  for each character a ∈ ∑</span><br><span class="line">    δ(0, a) = 0</span><br><span class="line">  δ(0, P[1]) = 1</span><br><span class="line">  for q = 1 to m</span><br><span class="line">    for each character a ∈ ∑</span><br><span class="line">      if q &lt; m and P[q + 1] == a</span><br><span class="line">        δ(q, a) = q + 1</span><br><span class="line">      else</span><br><span class="line">        δ(q, a) = δ(π[q], a)</span><br><span class="line">  return δ</span><br></pre></td></tr></table></figure><p>可见第2-4行对<span class="math inline">\(\delta(0,\cdot)\)</span>处理的正确性是显而易见的，在一开始没有接受到任何字符时，只有接受到正确的字符<span class="math inline">\(P[1]\)</span>时，才可以从状态<span class="math inline">\(0\)</span>转移到状态<span class="math inline">\(1\)</span>。第7-8行的处理同样也是显而易见的，遇到正确的字符那么就向前一个状态进位。</p><p>接下来证明另一种情况，即第9-10行的情况。按照<span class="math inline">\(\delta\)</span>的定义，可见<span class="math inline">\(\delta(q,a)=\sigma(P[:q]a)\)</span>，将<span class="math inline">\(\pi[q]\)</span>视为前面的<span class="math inline">\(q\)</span>，也有<span class="math inline">\(\delta(\pi[q],a)=\sigma(P[:\pi[q]]a)\)</span>。按照<span class="math inline">\(\pi\)</span>数组的定义，由于<span class="math inline">\(P[: \pi[q]]\sqsupset P[:q]\)</span>，因此<span class="math inline">\(P[:\pi[q]]a\sqsupset P[:q]a\)</span>，从而<span class="math inline">\(\sigma(P[:\pi[q]]a)\le\sigma(P[:q]a)\)</span>。由于<span class="math inline">\(\pi[q]=\sigma(P[:q])\)</span>，因此<span class="math inline">\(P[:q]\)</span>后面添加一个字符<span class="math inline">\(a\)</span>后，可以得到<span class="math inline">\(\pi[q]\ge \sigma(P[:q]a)-1\)</span>，因为<span class="math inline">\(\sigma\)</span>的函数值最多只会增加<span class="math inline">\(1\)</span>，这意味着<span class="math inline">\(\sigma(P[:\pi [q]]a)\ge\sigma(P[:q]a)\)</span>。</p><p>因此，最终可以得到<span class="math inline">\(\sigma(P[:\pi[q]]a)=\sigma(P[:q]a)\)</span>，即<span class="math inline">\(\delta(\pi[q],a)=\delta(q,a)\)</span>，原结论成立。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论32.3 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-3-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-3-Exercises/</id>
    <published>2023-10-07T16:57:22.000Z</published>
    <updated>2023-10-07T16:57:22.748Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">32.3-1</h1><p>本题的状态集合<span class="math inline">\(Q=\{0,1,2,3,4,5\}\)</span>，起始状态<span class="math inline">\(q_0=0\)</span>，接受状态为<span class="math inline">\(\{5\}\)</span>。</p><p>针对模式串<span class="math inline">\(P=\texttt{aabab}\)</span>在字符集<span class="math inline">\(\Sigma=\{a,b\}\)</span>上的状态函数<span class="math inline">\(\delta(s,c)\)</span>如下表所示。</p><p><span class="math inline">\(\begin{array}{|c|c|c|c|c|c|c|}\hlines&amp;0&amp;1&amp;2&amp;3&amp;4&amp;5\\\hline\texttt{a}&amp;1&amp;2&amp;2&amp;4&amp;2&amp;1\\\hline\texttt{b}&amp;0&amp;0&amp;3&amp;0&amp;5&amp;0\\\hline\end{array}\)</span></p><p>由此，对于文本串<span class="math inline">\(T=\texttt{aaababaabaababaab}\)</span>，它的状态转移序列为<span class="math inline">\(0,1,2,2,3,4,5,1,2,3,4,2,3,4,5,1,2,3\)</span>，由此<span class="math inline">\(P\)</span>在<span class="math inline">\(T\)</span>中出现了两次，分别为偏移量为<span class="math inline">\(1\)</span>和<span class="math inline">\(9\)</span>时出现。</p><h1 id="section-1">32.3-2</h1><p>本题的状态集合<span class="math inline">\(Q=\{0,1,2,3,\dots,20,21\}\)</span>，起始状态<span class="math inline">\(q_0=0\)</span>，接受状态为<span class="math inline">\(\{21\}\)</span>。</p><p>针对模式串<span class="math inline">\(P=\texttt{ababbabbababbababbabb}\)</span>在字符集<span class="math inline">\(\Sigma=\{a,b\}\)</span>上的状态函数<span class="math inline">\(\delta(s,c)\)</span>如下表所示。</p><p><span class="math inline">\(\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}\hlines&amp;0&amp;1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8&amp;9&amp;10&amp;11&amp;12&amp;13&amp;14&amp;15&amp;16&amp;17&amp;18&amp;19&amp;20&amp;21\\\hline\texttt{a}&amp;1&amp;1&amp;3&amp;1&amp;3&amp;6&amp;1&amp;3&amp;9&amp;1&amp;11&amp;1&amp;3&amp;14&amp;1&amp;16&amp;1&amp;3&amp;19&amp;1&amp;3&amp;9\\\hline\texttt{b}&amp;0&amp;2&amp;0&amp;4&amp;5&amp;0&amp;7&amp;8&amp;0&amp;10&amp;0&amp;12&amp;13&amp;0&amp;15&amp;8&amp;17&amp;18&amp;0&amp;20&amp;21&amp;0\\\hline\end{array}\)</span></p><h1 id="section-2">32.3-3</h1><p>假设<span class="math inline">\(P\)</span>的长度为<span class="math inline">\(m\)</span>。<span class="math inline">\(P[:k]\sqsupset P[:q]\)</span>推导出<span class="math inline">\(k=0\lork=q\)</span>意味着这个字符串只要产生了一次失配，那么就必须从头开始匹配，这意味着任何不以<span class="math inline">\(P[1]\)</span>为开头的字符串是<span class="math inline">\(P\)</span>的一个前缀，因此，这种模式串一般是<span class="math inline">\(\forall i\in[2,n],P[1]\neq P[i]\)</span>成立。</p><p>对于这种模式串，它的状态转移函数<span class="math inline">\(\delta(s,c)(s\in[0,m],c\in\Sigma)\)</span>如下：</p><p><span class="math inline">\(\delta(s,c)= \left\{\begin{aligned}  &amp;0 &amp; &amp; \text{if}\quad s=m\lor s&lt;m\land P[s+1]\neq c \\  &amp;s+1 &amp; &amp; \text{if}\quad s&lt;c\landP[s+1]=c \\ \end{aligned}\right.\)</span></p><h1 id="section-3">32.3-4</h1><p>由于<span class="math inline">\(x\sqsupset y\)</span>，因此有<span class="math inline">\(|x|\le |y|\)</span>。又因为<span class="math inline">\(x,y\)</span>同为<span class="math inline">\(P\)</span>的前缀，因此有<span class="math inline">\(x\sqsubset y\)</span>。</p><p>按照<span class="math inline">\(\sigma\)</span>的定义，有<span class="math inline">\(\sigma(x)= |x|\)</span>。但是因为<span class="math inline">\(x\sqsubset y,x\sqsupset y\)</span>，因此<span class="math inline">\(\sigma(y)\ge |x|\)</span>。最终有<span class="math inline">\(\sigma(x)\le \sigma(y)\)</span>。</p><h1 id="section-4">32.3-5</h1><p>最少的状态数即为合并<span class="math inline">\(P\)</span>和<span class="math inline">\(P&#39;\)</span>的最长公共前缀作为共同状态。更一般的说，令<span class="math inline">\(P\)</span>和<span class="math inline">\(P&#39;\)</span>的最长公共前缀的状态为<span class="math inline">\(r=\max\{i:P[:i]=P&#39;[:i]\}\)</span>，那么一共有<span class="math inline">\(|P|+|P&#39;|-r-1\)</span>个状态，直到第<span class="math inline">\(r\)</span>个字符之后，状态才会被分开。具体构建过程由<code>COMPUTE-TRANSITION-FUNCTION'</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">COMPUTE-TRANSITION-FUNCTION&#x27;(P, m, P&#x27;, m&#x27;, ∑)</span><br><span class="line">  r = 0</span><br><span class="line">  while k &lt; m amd k &lt; m&#x27; and P[r + 1] == P&#x27;[r + 1]</span><br><span class="line">    r += 1</span><br><span class="line">  for q = 0 to m</span><br><span class="line">    for each character a ∈ ∑</span><br><span class="line">      k = min &#123;m, q + 1&#125;</span><br><span class="line">    while P[:k] is not a suffix of P[:q]a</span><br><span class="line">      k = k – 1</span><br><span class="line">      δ(q, a) = k</span><br><span class="line">  for each q = r + 1 to m&#x27;</span><br><span class="line">    for each character a ∈ ∑</span><br><span class="line">      k = min &#123;m, q + 1&#125;</span><br><span class="line">    while P&#x27;[:k] is not a suffix of P&#x27;[:q]a</span><br><span class="line">      k = k – 1</span><br><span class="line">    if k &lt;= r</span><br><span class="line">      δ(q + m, a) = k</span><br><span class="line">    else</span><br><span class="line">      δ(q + m, a) = m + k</span><br><span class="line">  return δ</span><br></pre></td></tr></table></figure><h1 id="section-5">32.3-6</h1><p>对于包含通配符<span class="math inline">\(\Diamond\)</span>的一个模式串<span class="math inline">\(P\)</span>，假设我们将其划分成切割成一个个不包含通配符<span class="math inline">\(\Diamond\)</span>的模式串<span class="math inline">\(P_1,P_2,\dots,P_k\)</span>，那么将这些状态进行“首尾相接”即可，因为只要进行到当前的模式串<span class="math inline">\(P_i\)</span>，那么就不能转移到以前的模式串。可见将会一共有<span class="math inline">\(|P|+1\)</span>个状态。</p><p>具体过程由<code>COMPUTE-TRANSITION-FUNCTION-GAP</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">COMPUTE-TRANSITION-FUNCTION-GAP(P, ∑, m)</span><br><span class="line">  split P into Q[1], Q[2], ..., Q[k] by &#x27;◊&#x27;</span><br><span class="line">  pre = 0</span><br><span class="line">  for i = 1 to k</span><br><span class="line">    δt = COMPUTE-TRANSITION-FUNCTION-GAP(Q[i], ∑, |Q[i]|)</span><br><span class="line">    for s = 0 to |Q[i]|</span><br><span class="line">      for each character a ∈ ∑</span><br><span class="line">        δ(pre + s, a) = δt(s, a)</span><br><span class="line">    pre = pre + |Q[i]|</span><br><span class="line">  return δ</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论32.2 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-2-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-2-Exercises/</id>
    <published>2023-10-07T16:57:19.000Z</published>
    <updated>2023-10-07T16:57:19.479Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">32.2-1</h1><p>可见，<span class="math inline">\(p=26\bmod 11=4\)</span>。</p><p>按照算法<code>RABIN-KARP-MATCHER</code>的执行结果，可以计算出的<span class="math inline">\(t_s\)</span>值如下标：</p><p><span class="math inline">\(\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}\hlines&amp;0&amp;1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8&amp;9&amp;10&amp;11&amp;12&amp;13&amp;14\\\hlinet_s&amp;9&amp;3&amp;8&amp;4&amp;4&amp;4&amp;4&amp;10&amp;9&amp;2&amp;3&amp;1&amp;9&amp;2&amp;5\\\hline\end{array}\)</span></p><p>可见一共有<span class="math inline">\(4\)</span>次命中，但是仅有偏移<span class="math inline">\(6\)</span>是有效偏移，因此其余的偏移<span class="math inline">\(3,4,5\)</span>都是伪命中。</p><h1 id="section-1">32.2-2</h1><p>这题的思想比较简单：首先求出<span class="math inline">\(k\)</span>个模式串的<span class="math inline">\(p\)</span>值<span class="math inline">\(p_1,p_2,\dots,p_k\)</span>，并且使用一个基于链接法的哈希表来存储这些<span class="math inline">\(p\)</span>值和对应的字符串。只要哈希表的大小合适，那么只需要<span class="math inline">\(O(1)\cdot O(m(v+n/q))=O(m(v+n/q))\)</span>，其中<span class="math inline">\(v\)</span>是有效偏移的数量。需要注意的是，只有<span class="math inline">\(p_1,p_2,\dots,p_k\)</span>都是长度为<span class="math inline">\(m\)</span>的情况下才能使用该算法<code>RABIN-KARP-MATCHER'</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">RABIN-KARP-MATCHER&#x27;(T, P, n, k, m, d, q)</span><br><span class="line">  h = d^(m - 1) mod q</span><br><span class="line">  let p[1 : k] be a new array by 0</span><br><span class="line">  let T be a new hash-table.</span><br><span class="line">  t0 = 0</span><br><span class="line">  for i = 1 to m</span><br><span class="line">    t0 = (d * t0 + T[i]) mod q</span><br><span class="line">    for j = 1 to k</span><br><span class="line">    p[j] = (d * p[j] + P[j, i]) mod q</span><br><span class="line">  for j = 1 to k</span><br><span class="line">    let x be a new node</span><br><span class="line">    x.key = p[j]</span><br><span class="line">    x.p = P[j]</span><br><span class="line">    // 节点x存的是字符串和它的哈希值。</span><br><span class="line">    CHAINED-HASH-INSERT(T, x)</span><br><span class="line">  //假设CHAINED-HASH-SEARCH&#x27;返回的是哈希表中和x.key相同的所有节点，而并非只是至多一个；hash是一个哈希函数。</span><br><span class="line">  for s = 0 to n - m</span><br><span class="line">    for v, pat in CHAINED-HASH-SEARCH&#x27;(T, hash(t_s))</span><br><span class="line">      if v == t_s </span><br><span class="line">        if pat[1 : m] == T[s + 1 : s + m]</span><br><span class="line">          print &quot;Pattern &quot; pat &quot; occur with shifts&quot; s</span><br><span class="line">    if s &lt; n - m</span><br><span class="line">      t_&#123;s + 1&#125; = (d * (t_s - T[s + 1] * h) + T[s + m + 1]) mod q</span><br></pre></td></tr></table></figure><p>对于模式串不等长的情况下，不能够使用上述哈希表的情况，只能分别独立地进行查询。通过数组模拟各种查询情况，最终整个过程由程序<code>RABIN-KARP-MATCHER''</code>给出，其时间复杂度为<span class="math inline">\(O(km(v+n/q))\)</span>，其中<span class="math inline">\(v\)</span>是有效偏移的数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RABIN-KARP-MATCHER&#x27;&#x27;(T, P, n, k, d, q)</span><br><span class="line">  h = d^(m - 1) mod q</span><br><span class="line">  let p[1 : k] be a new array by 0</span><br><span class="line">  let T be a new hash-table.</span><br><span class="line">  for j = 1 to k</span><br><span class="line">    t0 = 0</span><br><span class="line">    for i = 1 to |P[j]|</span><br><span class="line">      p[j] = (d * p[j] + P[j, i]) mod q</span><br><span class="line">      t0 = (d * t0 + T[i]) mod q</span><br><span class="line">    for s = 0 to n - |P[j]|</span><br><span class="line">      if p == t_s</span><br><span class="line">        if P[j, 1 : |P[j]|] == T[s + 1 : s + m]</span><br><span class="line">          print &quot;Pattern &quot; P[j] &quot; occur with shifts&quot; s</span><br><span class="line">      if s &lt; n - m</span><br><span class="line">        t_&#123;s + 1&#125; = (d * (t_s - T[s + 1] * h) + T[s + m + 1]) mod q</span><br></pre></td></tr></table></figure><h1 id="section-2">32.2-3</h1><p>这道题的本质思想是将二维的情况转化为一维。对于每相邻<span class="math inline">\(m\)</span>行，我们先预处理出一个长度为<span class="math inline">\(n\)</span>的数组<span class="math inline">\(U\)</span>，然后再在数组<span class="math inline">\(U\)</span>上处理一维的情况，注意处理一行<span class="math inline">\(U\)</span>的情况时，不像<code>RABIN-KARP-MATCHER</code>那样以<span class="math inline">\(d\)</span>作为进制，而是以<span class="math inline">\(d&#39;=d^m\)</span>来作为进制。和<code>RABIN-KARP-MATCHER</code>同样的是，判断一个字符矩阵对应的值<span class="math inline">\(t\)</span>是否和<span class="math inline">\(p\)</span>相同只需要<span class="math inline">\(O(1)\)</span>的时间即可完成。</p><p>一共需要判断<span class="math inline">\((n-m+1)^2\)</span>种情况，因此在最坏情况下，这个二维版本的算法将会达到<span class="math inline">\(O((n-m)+1^2 \cdotm^2)=O(n^4)\)</span>。具体过程由<code>RABIN-KARP-MATCHER-2D</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">RABIN-KARP-MATCHER-2D(T, P, n, m, d, q)</span><br><span class="line">  ha = d ^ (m * (m-1)) mod q</span><br><span class="line">  hr = d ^ (m-1) mod q</span><br><span class="line">  d&#x27; = d ^ m mod q</span><br><span class="line">  p = 0</span><br><span class="line">  for j = 1 to m</span><br><span class="line">    for i = 1 to m</span><br><span class="line">      p = (d * p + P[i, j]) mod q</span><br><span class="line">  let U[1 : n] be a new array by 0</span><br><span class="line">  for j = 1 to n</span><br><span class="line">    for i = 1 to m</span><br><span class="line">      U[j] = (d * U[j] + T[i, j]) mod q</span><br><span class="line">  for rs = 0 to n - m</span><br><span class="line">    u0 = 0</span><br><span class="line">    for j = 1 to m</span><br><span class="line">      u0 = (d&#x27; * u0 + U[j]) mod q</span><br><span class="line">    for cs = 0 to n - m</span><br><span class="line">      if p == ts</span><br><span class="line">        if P[1 : m,1 : m] == T[rs + 1:rs + m,cs + 1:cs + m]</span><br><span class="line">          print &quot;Pattern occurs with shift&quot; (rs, cs)</span><br><span class="line">      if cs &lt; n - m</span><br><span class="line">        u_&#123;cs + 1&#125; = (d&#x27; * (u_&#123;cs&#125; - U[cs + 1] * ha) + U[cs + m + 1]) mod q</span><br><span class="line">    if rs &lt; n - m</span><br><span class="line">      for j = 1 to n</span><br><span class="line">        U[j] = (d * (u[j] - T[rs + 1, j] * ha) + T[rs + m + 1, j]) mod q</span><br></pre></td></tr></table></figure><h1 id="section-3">32.2-4</h1><p>考虑令<span class="math inline">\(\displaystyle{f(A,B,x)=\left(\sum_{i=0}^{n-1}(a_i-b_i)x^i\right)\bmodq}\)</span>。</p><p>如果两个文件相同，那么也就是说<span class="math inline">\(\foralli\in[0,n),a_i=b_i\)</span>均成立，那么此时任取<span class="math inline">\(x\in[0,q)\)</span>，都必定有<span class="math inline">\(A(x)=B(x)\)</span>。</p><p>否则，非零多项式<span class="math inline">\(f(A,B,x)\)</span>的次数至多为<span class="math inline">\(n\)</span>。由于<span class="math inline">\(q\)</span>是一个质数，依照题目31.4-4的结论，方程<span class="math inline">\(f(A,B,x)=0\)</span>最多有<span class="math inline">\(n\)</span>个不同的根。由于<span class="math inline">\(x\)</span>是从<span class="math inline">\([0,q)\)</span>中选择的，因此任取<span class="math inline">\(x\in [0,q),f(A,B,x)=0\)</span>的概率至多为<span class="math inline">\(\dfrac{n}{q}\)</span>。由于<span class="math inline">\(q&gt;10^3\cdot n\)</span>，因此<span class="math inline">\(f(A,B,x)=0\)</span>的概率不会超过<span class="math inline">\(10^{-3}\)</span>，原结论成立。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论32.1 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-1-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/32-1-Exercises/</id>
    <published>2023-10-07T16:57:15.000Z</published>
    <updated>2023-10-07T17:08:43.355Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">32.1-1</h1><p>令<span class="math inline">\(t(s)(s\le n-m)\)</span>表示偏移为<span class="math inline">\(s\)</span>时，进行的匹配次数，那么这些匹配次数由下表给出：</p><p><span class="math inline">\(\begin{array}{|c|l|c|c|}\hlines&amp;\mathtt{000010001010001} &amp;t(s)&amp;\text{is matched}\\\hline0&amp;\mathtt{0001}&amp;4&amp;\text{No}\\\hline 1&amp;\mathtt{\0001}&amp;4&amp;\text{Yes}\\\hline 2&amp;\mathtt{\ \0001}&amp;3&amp;\text{No}\\\hline 3&amp;\mathtt{\ \ \0001}&amp;2&amp;\text{No}\\\hline 4&amp;\mathtt{\ \ \ \0001}&amp;1&amp;\text{No}\\\hline 5&amp;\mathtt{\ \ \ \ \0001}&amp;4&amp;\text{Yes}\\\hline 6&amp;\mathtt{\ \ \ \ \ \0001}&amp;3&amp;\text{No}\\\hline 7&amp;\mathtt{\ \ \ \ \ \ \0001}&amp;2&amp;\text{No}\\\hline 8&amp;\mathtt{\ \ \ \ \ \ \ \0001}&amp;1&amp;\text{No}\\\hline 9&amp;\mathtt{\ \ \ \ \ \ \ \ \0001}&amp;2&amp;\text{No}\\\hline 10&amp;\mathtt{\ \ \ \ \ \ \ \ \ \0001}&amp;1&amp;\text{No}\\\hline 11&amp;\mathtt{\ \ \ \ \ \ \ \ \ \ \0001}&amp;4&amp;\text{Yes}\\\hline \end{array}\)</span></p><h1 id="section-1">32.1-2</h1><p>如果<span class="math inline">\(P\)</span>的各个字母都不相同，那么可以考虑从左到右遍历文本串<span class="math inline">\(T\)</span>，考察<span class="math inline">\(T\)</span>中和<span class="math inline">\(P[1]\)</span>相同的那些下标。由于<span class="math inline">\(P\)</span>中的字符各不相同，因此对于一对相邻都是字符<span class="math inline">\(P[1]\)</span>的下标<span class="math inline">\(i,j(i&lt;j)\)</span>，只有<span class="math inline">\(i+|P|\le j\)</span>时，偏移量<span class="math inline">\(i+1\)</span>才有可能是正确的，这时只需要检测一下即可。</p><p>由于<span class="math inline">\(S\)</span>中的每个字符和<span class="math inline">\(P\)</span>中的字符至多只会进行一次匹配，因此这个算法的时间复杂度为<span class="math inline">\(O(n)\)</span>。具体过程由<code>NAIVE-STRING-MATCHER'</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NAIVE-STRING-MATCHER(T, P, n, m)</span><br><span class="line">  cnt = n + 1</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    if T[i] == P[1]</span><br><span class="line">      cnt = 1</span><br><span class="line">    else</span><br><span class="line">      cnt = cnt + 1</span><br><span class="line">    if cnt == m and P[1:m] == T[i - cnt + 1:i]</span><br><span class="line">      print &quot;Pattern occurs with shift&quot; i - cnt</span><br></pre></td></tr></table></figure><h1 id="section-2">32.1-3</h1><p>对于文本串<span class="math inline">\(T\)</span>的偏移量<span class="math inline">\(s\)</span>，它能和模式串<span class="math inline">\(P\)</span>的第<span class="math inline">\(j\)</span>个字符比较当且仅当<span class="math inline">\(T[s+1:s+j-1]=P[1:j-1]\)</span>，这个概率值为<span class="math inline">\(d^{-(j-1)}\)</span>。</p><p>令随机变量<span class="math inline">\(X_{s}\)</span>表示偏移量为<span class="math inline">\(s\)</span>时，<span class="math inline">\(T[s+j-1]\)</span>和<span class="math inline">\(P[j]\)</span>发生了比较。那么有<span class="math inline">\(X_{s,j}=d^{-(j-1)}\)</span>。</p><p>令随机变量<span class="math inline">\(\displaystyle{Y=\sum_{s=0}^{n-m}\sum_{j=1}^{m}X_{ij}}\)</span>表示比较次数，那么有：</p><p><span class="math inline">\(\begin{aligned}E[Y]&amp;=\sum_{s=0}^{n-m}\sum_{j=1}^{m}E[X_{ij}]\\&amp;=\sum_{s=0}^{n-m}\sum_{j=1}^{m}\dfrac{1}{d^{j-1}}\\&amp;=\sum_{s=0}^{n-m}\dfrac{d-d^{1-m}}{d-1}\\&amp;=(n-m+1)\cdot\dfrac{d-d^{1-m}}{d-1}\\&amp;=(n-m+1)\cdot\dfrac{1-d^{m}}{1-d^{-1}}\\&amp;\le(n-m+1)\cdot\dfrac{1}{1-d^{-1}}\\&amp;\le(n-m+1)\cdot\dfrac{1}{1-2^{-1}}\\ &amp;\le2(n-m+1)\end{aligned}\)</span></p><h1 id="section-3">32.1-4</h1><p>本题可以使用动态规划进行求解。令状态<span class="math inline">\(f(i,j)(0\le i\le m,0\le j\lem)\)</span>表示使用<span class="math inline">\(P\)</span>的前<span class="math inline">\(i\)</span>个字符是否能匹配<span class="math inline">\(T\)</span>的前<span class="math inline">\(j\)</span>个字符。那么可以写出如下状态转移方程：</p><p><span class="math inline">\(f(i,j)= \left \{\begin{aligned}  &amp;1&amp; &amp; \text{if}\quad i=0\land j=0 \\  &amp;0 &amp; &amp;\text{if}\quad i=0\land j&gt;0\lor i&gt;0\land j=0\landP[i]\neq\Diamond\land f(i-1,0)=0 \\  &amp;\bigvee_{k=0}^j f(i-1,k) &amp;&amp; \text{if}\quad i&gt;0\land P[i]=\Diamond\\  &amp;f(i-1,j-1)\land\mathbf{1}\{P[i]=S[j]\} &amp; &amp; \text{if}\quad i&gt;0\landj&gt;0\land P[i]\neq\Diamond\\ \end{aligned}\right.\)</span></p><p>其中<span class="math inline">\(\mathbf{1}\{b\}\)</span>表示一个示性函数，用于表示布尔表达式<span class="math inline">\(b\)</span>是否成立。方程第三行表示这里有一个通配符<span class="math inline">\(\Diamond\)</span>，它可以匹配任意长度的字符串，因此可以从任意状态<span class="math inline">\(f(i-1,k)\)</span>转移到<span class="math inline">\(f(i,j)(k\lej)\)</span>，方程的第四行用于表示一个普通字符的匹配。</p><p>最终答案为<span class="math inline">\(f(m,n)\)</span>。</p><p>使用前缀和可以将这个转移优化到<span class="math inline">\(O(nm)\)</span>，因此可以在多项式时间复杂度内完成这个问题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论29 Problems 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/29-Problems/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/29-Problems/</id>
    <published>2023-10-04T06:40:13.000Z</published>
    <updated>2023-10-04T06:40:13.149Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">29-1</h1><h2 id="a">a</h2><p>假设现在存在一个标准型线性规划的算法<code>LP-SOLVER-A(A, b, c)</code>（其中<span class="math inline">\(\mathbf{A,b}\)</span>表示约束，<span class="math inline">\(\mathbf{c}\)</span>表示目标函数对应的向量，最大化<span class="math inline">\(\mathbf{c}^T\mathbf{x}\)</span>的值），那么按照定理29.5，这个算法无非就返回<span class="math inline">\(3\)</span>种结果：</p><ol type="1"><li>一个达到最优目标值的向量<span class="math inline">\(\mathbf{x}\)</span>。</li><li><code>"unbounded"</code>，即无界。</li><li><code>"infeasible"</code>，即这个约束不可行。</li></ol><p>那么线性不等式可行性问题检测算法<code>LINEAR-INEQUALITY-FEASIBILITY</code>用于检测标准型线性不等式可行性，只需要调用<code>LP-SOLVER-A</code>作为子程序即可。更具体的过程如下给出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LINEAR-INEQUALITY-FEASIBILITY(A, b, m, n):</span><br><span class="line">  let c[1 : n] be a new array</span><br><span class="line">  sol = LP-SOLVE-A(A, b, c)</span><br><span class="line">  if sol != &quot;infeasible&quot;</span><br><span class="line">    return sol</span><br><span class="line">  return NIL</span><br></pre></td></tr></table></figure><p>这个过程用到的变量和约束的个数分是<span class="math inline">\(n,m\)</span>，即它们本身。</p><h2 id="b">b</h2><p>如果一个标准型线性规划<span class="math inline">\(L\)</span>存在一个有限最优解（最大值），那么其对偶问题也存在一个有限最优解（最小值）。如果我们令这个最大值和最小值相等，再交由<code>LINEAR-INEQUALITY-FEASIBILITY-A</code>求出一个可行解即可。</p><p>更具体地说，线性规划<span class="math inline">\(L\)</span>可行当且仅当下面关于<span class="math inline">\(\mathbf{x,y}\)</span>的线性不等式是否可行：</p><p><span class="math inline">\(\begin{aligned}\mathbf{A}\mathbf{x}&amp;\le\mathbf{b}\\\mathbf{A}^T\mathbf{y}&amp;\ge\mathbf{c}\\\mathbf{c}^T\mathbf{x}&amp;=\mathbf{b}^T\mathbf{y}\\ \mathbf{x}&amp;\ge0\\ \mathbf{y}&amp;\ge 0\\ \end{aligned}\)</span></p><p>如果<span class="math inline">\(L\)</span>是无界的，那么上面的线性不等式同样是不可行的。因此，我们下一步只需要判断<span class="math inline">\(L\)</span>是否为可行，从而区分出无界和不可行这两种情况。只需要进行两次判断以区分这<span class="math inline">\(3\)</span>种情况即可。更具体的情况由<code>LP-SOLVE</code>给出，假定<code>LINEAR-INEQUALITY-FEASIBILITY-A</code>是用于求解标准型线性不等式可行性的算法。最终求解线性规划算法由<code>LP-SOLVE</code>给出。</p><p>将上面的线性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">LP-SOLVE(A, b, c, m, n)</span><br><span class="line">  sol1 = LINEAR-INEQUALITY-FEASIBILITY-A(A, b, m, n)</span><br><span class="line">  if sol1 == NIL</span><br><span class="line">    return &quot;infeasible&quot;</span><br><span class="line">  let A&#x27;[2 * n + 2 * m + 2, n + m] be a new table by 0</span><br><span class="line">  let b&#x27;[2 * n + 2 * m + 2] be a new array by 0</span><br><span class="line">  for i = 1 to m</span><br><span class="line">    for j = 1 to n</span><br><span class="line">      A&#x27;[i, j] = A[i, j]</span><br><span class="line">      A&#x27;[m + j][n + i] = A[i, j]</span><br><span class="line">  for i = 1 to m</span><br><span class="line">    A[m + n + 1][n + i] = -b[i]</span><br><span class="line">    A[m + n + 2][n + i] = b[i]</span><br><span class="line">  for j = 1 to n</span><br><span class="line">    A[m + n + 1][j] = c[j]</span><br><span class="line">    A[m + n + 2][j] = -c[j]</span><br><span class="line">  for k = 1 to m + n</span><br><span class="line">    A[m + n + 2 + k][k] = -1</span><br><span class="line">  for i = 1 to m</span><br><span class="line">    b&#x27;[i] = b[i]</span><br><span class="line">  for j = 1 to n</span><br><span class="line">    b&#x27;[m + i] = c[j]</span><br><span class="line">  sol2 = LINEAR-INEQUALITY-FEASIBILITY-A(A, b, 2 * n + 2 * m + 2, n + m)</span><br><span class="line">  if sol2 == NIL</span><br><span class="line">    return &quot;unbounded&quot;</span><br><span class="line">  else</span><br><span class="line">    return sol2</span><br></pre></td></tr></table></figure><p>对上面的线性不等式标准化后，将会有<span class="math inline">\(2n+2m+2\)</span>条不等式，<span class="math inline">\(n+m\)</span>个变量，它们仍然是<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>的多项式。</p><h1 id="section-1">29-2</h1><h2 id="a-1">a</h2><p>该线性规划<span class="math inline">\(L\)</span>给出的最优可行解为<span class="math inline">\(\mathbf{x}^{\ast}=(x_1,x_2,x_3)=(8,4,0)\)</span>，对于其对偶线性规划，其最优可行解为<span class="math inline">\(\mathbf{y}^{\ast}=(y_1,y_2,y_3)=(0,1/6,2/3)\)</span>。令<span class="math inline">\(\mathbf{A}\)</span>表示原约束的系数矩阵，可以知道，<span class="math inline">\(\mathbf{Ax}^{\ast}=(12,24,36)^T,\mathbf{A}^T\mathbf{y}=(3,1,13/6)^T\)</span>。将<span class="math inline">\(\mathbf{A}^T\mathbf{y^{\ast}}\)</span>和<span class="math inline">\(\mathbf{x}^{\ast}\)</span>以及<span class="math inline">\(\mathbf{Ax}\)</span>和<span class="math inline">\(\mathbf{y}^{\ast}\)</span>相对比即可完成验证。</p><h2 id="b-1">b</h2><p>必要性：假设互补松驰性成立，那么有<span class="math inline">\(\displaystyle{\sum_{j=1}^nc_j\overline{x}_j=\sum_{j=1}^n\sum_{i=1}^ma_{ij}\overline{y}_i\overline{x}_j}\)</span>。原因在于，考虑每个<span class="math inline">\(j\in[1,n]\)</span>，如果<span class="math inline">\(\overline{x}_j=0\)</span>，那么<span class="math inline">\(\displaystyle{c_j\overline{x}_j=0,\overline{x}_j\cdot\sum_{i=1}^ma_{ij}\overline{y}_i=0}\)</span>，等式<span class="math inline">\(\displaystyle{c_j\overline{x}_j=\sum_{i=1}^ma_{ij}\overline{y}_i\overline{x}_j}\)</span>成立；如果<span class="math inline">\(\overline{x}_j=0\)</span>不成立，那么按照互补松弛性，此时有<span class="math inline">\(\displaystyle{\sum_{i=1}^ma_{ij}\overline{y}_i=c_j}\)</span>，等式<span class="math inline">\(\displaystyle{c_j\overline{x}_j=\sum_{i=1}^ma_{ij}\overline{y}_i\overline{x}_j}\)</span>依旧成立。因此有<span class="math inline">\(\displaystyle{\sum_{j=1}^nc_j\overline{x}_j=\sum_{j=1}^n\sum_{i=1}^ma_{ij}\overline{y}_i\overline{x}_j}\)</span>。</p><p>可以用类似的方法证明<span class="math inline">\(\displaystyle{\sum_{i=1}^mb_i\overline{y}_i=\sum_{i=1}^m\sum_{j=1}^na_{ij}\overline{x}_j\overline{y}_i}\)</span>。考虑每个<span class="math inline">\(i\in[1,m]\)</span>，如果<span class="math inline">\(\overline{y}_i=0\)</span>，那么<span class="math inline">\(\displaystyle{b_i\overline{y}_i=0,y_i\cdot\sum_{j=1}^n}a_{ij}\overline{x}_j=0\)</span>，等式<span class="math inline">\(\displaystyle{b_i\overline{y}_i=\sum_{j=1}^na_{ij}\overline{x}_j\overline{y}_i}\)</span>成立。如果<span class="math inline">\(\overline{y}_i=0\)</span>不成立，那么按照互补松弛性，此时有<span class="math inline">\(\displaystyle{\sum_{j=1}^na_{ij}\overline{x}_j=b_i}\)</span>，等式<span class="math inline">\(\displaystyle{b_i\overline{y}_i=\sum_{j=1}^na_{ij}\overline{x}_j\overline{y}_i}\)</span>依旧成立。因此有<span class="math inline">\(\displaystyle{\sum_{i=1}^mb_i\overline{y}_i=\sum_{i=1}^m\sum_{j=1}^na_{ij}\overline{x}_j\overline{y}_i}\)</span>。</p><p>由于<span class="math inline">\(\displaystyle{\sum_{j=1}^n\sum_{i=1}^ma_{ij}\overline{y}_i\overline{x}_j=\sum_{i=1}^m\sum_{j=1}^na_{ij}\overline{x}_j\overline{y}}\)</span>，因此有<span class="math inline">\(\displaystyle{\sum_{j=1}^nc_j\overline{x}_j=\sum_{i=1}^m b_i\overline{y}_i}\)</span>，即<span class="math inline">\(\mathbf{c}^T\overline{\mathbf{x}}=\mathbf{b}^T\overline{\mathbf{y}}\)</span>。</p><p>按照定理29.4，<span class="math inline">\(\overline{\mathbf{x}},\overline{\mathbf{y}}\)</span>分别是原线性规划和对偶线性规划的最优解，原结论成立。</p><p>充分性：我们将使用反证法完成证明。假设现在<span class="math inline">\(\mathbf{x}^{\ast},\mathbf{y}^{\ast}\)</span>分别是原线性规划和对偶线性规划的最优解。假设<span class="math inline">\(\exists i\in[1,m]\)</span>满足<span class="math inline">\(y_i^{\ast}\neq 0\)</span>，并且有<span class="math inline">\(\displaystyle{\sum_{j=1}^na_{ij}x_j^{\ast}&lt;b_i}\)</span>，使用必要性种类似的计算过程，可以得到：</p><p><span class="math inline">\(\begin{aligned} \sum_{j=1}^nc_jx_j^{\ast}&amp;=\sum_{j=1}^n\sum_{i=1}^ma_{ij}y_i^{\ast}x_j^{\ast}\\&amp;=\sum_{i=1}^m\sum_{j=1}^n a_{ij}x_j^{\ast}y_i^{\ast}\\&amp;&lt;\sum_{i=1}^m\sum_{j=1}^n b_iy_i^{\ast}\\\end{aligned}\)</span></p><p>按照定理29.4，<span class="math inline">\(\overline{\mathbf{x}},\overline{\mathbf{y}}\)</span>必定不是原线性规划和对偶线性规划的最优解，因此原结论成立。</p><p>对于另外一种情况的证明过程类似，假设<span class="math inline">\(\exists j\in[1,n]\)</span>满足<span class="math inline">\(x_j^{\ast}\neq 0\)</span>，并且有<span class="math inline">\(\displaystyle{\sum_{i=1}^ma_{ij}y_i^{\ast}&gt;c_j}\)</span>，使用必要性种类似的计算过程，可以得到：</p><p><span class="math inline">\(\begin{aligned} \sum_{j=1}^nc_jx_j^{\ast}&amp;&lt;\sum_{j=1}^n\sum_{i=1}^ma_{ij}y_i^{\ast}x_j^{\ast}\\&amp;=\sum_{i=1}^m\sum_{j=1}^n a_{ij}x_j^{\ast}y_i^{\ast}\\&amp;=\sum_{i=1}^m\sum_{j=1}^n b_iy_i^{\ast}\\\end{aligned}\)</span></p><p>同样的，<span class="math inline">\(\overline{\mathbf{x}},\overline{\mathbf{y}}\)</span>必定不是原线性规划和对偶线性规划的最优解，因此原结论成立。</p><p>因此原结论成立。</p><h2 id="c">c</h2><p>本题使用29-2-b的结论即可直接证明。 充分性：由于<span class="math inline">\(\mathbf{x}^{\ast}\)</span>是原线性规划的最优解，令<span class="math inline">\(\mathbf{y}^{\ast}\)</span>是对偶线性规划的最优解，那么其必定满足条件1。按照题目29-2-b的结论，条件2和3都成立。由此充分性成立。</p><p>必要性：条件1说明了<span class="math inline">\(\overline{\mathbf{y}}\)</span>是对偶线性规划的一个可行解，根据题目29-2-b的结论，条件2和条件3说明了构造出来的可行解<span class="math inline">\(\overline{\mathbf{x,y}}\)</span>都是各自线性规划的最优解。由此必要性成立。</p><p>因此原结论成立。</p><h1 id="section-2">29-3</h1><h2 id="a-2">a</h2><p>证明过程和在线性规划时期，对引理29.1的证明过程完全相同。不失一般性，假设现在需要证明的整数规划是标准型。</p><p>令<span class="math inline">\(\mathbf{x}\)</span>是原整数规划的一个可行解，<span class="math inline">\(\mathbf{y}\)</span>是对偶整数规划的一个可行解，那么有</p><p><span class="math inline">\(\begin{aligned}\mathbf{c}^T\overline{\mathbf{x}}&amp;\le(\mathbf{A}^T\overline{\mathbf{y}})^T\overline{\mathbf{x}}\\&amp;=\overline{\mathbf{y}}^T\mathbf{A}\overline{\mathbf{x}}\\&amp;\le\overline{\mathbf{y}}^T\mathbf{b} \end{aligned}\)</span></p><p>因此原结论成立。</p><h2 id="b-2">b</h2><p>考虑如下单个变量<span class="math inline">\(x\)</span>的标准型整数规划：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;x\\ \text{subject to}&amp; \\ &amp;&amp;x&amp;\le\dfrac{1}{2}\\&amp;&amp;x&amp;\ge 0 \end{aligned}\)</span></p><p>可以发现其最优可行解只有<span class="math inline">\(x=0\)</span>，目标函数值为<span class="math inline">\(0\)</span>。</p><p>那么其对偶整数规划为：</p><p><span class="math inline">\(\begin{aligned} \text{mimimize}&amp;&amp;\dfrac{1}{2}y\\ \text{subject to}&amp; \\ &amp;&amp;y&amp;\ge 1\\&amp;&amp;y&amp;\ge 0 \end{aligned}\)</span></p><p>可以发现其最优可行解为<span class="math inline">\(y=1\)</span>，目标函数值为<span class="math inline">\(\dfrac{1}{2}\)</span>。</p><p>由于它们的最优解不相同，因此整数规划不满足对偶性。</p><h2 id="c-1">c</h2><p>不失一般性，假设现在需要证明的整数规划是标准型。</p><p>令<span class="math inline">\(L_I\)</span>是一个标准型整数规划，<span class="math inline">\(L\)</span>是<span class="math inline">\(L_I\)</span>除去整数约束后所得到的线性规划，<span class="math inline">\(L_I^D\)</span>是<span class="math inline">\(L_I\)</span>的对偶整数规划，<span class="math inline">\(L^D\)</span>是<span class="math inline">\(L\)</span>的对偶线性规划。那么<span class="math inline">\(P,D\)</span>分别是<span class="math inline">\(L,L^D\)</span>的目标函数值。按照定理29.4，有<span class="math inline">\(P=D\)</span>。</p><p>由于<span class="math inline">\(L_I\)</span>是<span class="math inline">\(L\)</span>添加上了整数约束而来，因此<span class="math inline">\(L_I\)</span>的可行域必定是<span class="math inline">\(L\)</span>的可行域的子集。这意味着在<span class="math inline">\(L\)</span>中的最优解必定不劣于<span class="math inline">\(L_I\)</span>中的最优解，因此有<span class="math inline">\(IP\le P\)</span>；类似的，在<span class="math inline">\(L^D\)</span>中的最优解必定不劣于<span class="math inline">\(L^D_I\)</span>中的最优解，因此有<span class="math inline">\(ID\ge D\)</span>。</p><p>最终有等式<span class="math inline">\(IP\le P=D\le ID\)</span>。</p><h1 id="section-3">29-4</h1><p>这里的证明参考了这篇<a href="https://people.orie.cornell.edu/dpw/orie6300/fall2008/Lectures/lec07.pdf">文章</a>。</p><p>首先列出<strong>原始</strong>Farkas引理：</p><h2 id="farkas引理">Farkas引理</h2><p>给定<span class="math inline">\(M\in\mathbb{R}^{(m+1)\timesn},g\in\mathbb{R}^{m+1}\)</span>，如下两种陈述只有一种成立：</p><ol type="1"><li><span class="math inline">\(\exists \mathbf{v}\in\mathbb{R}^{n},\mathbf{Mv=g},\mathbf{v}\ge \mathbf{0}\)</span></li><li><span class="math inline">\(\exists \mathbf{w}\in\mathbb{R}^{m+1},\mathbf{M}^T\mathbf{w}\ge\mathbf{0},\mathbf{g}^T\mathbf{w}&lt;0\)</span></li></ol><hr><p>接下来证明题目中给定的<strong>变种</strong>Farkas引理。第一步则是使用反证法证明<strong>至多</strong>只有一个陈述成立。假设这两个陈述都成立，那么我们针对<span class="math inline">\(\mathbf{v,w}\)</span>的存在性，可以列出：</p><p><span class="math inline">\(\begin{aligned} \mathbf{Mv}&amp;\le\mathbf{g}\\ \mathbf{w}^T\mathbf{M}&amp;=\mathbf{0}\\\mathbf{w}^T\mathbf{g}&amp;&lt;\mathbf{0} \end{aligned}\)</span></p><p>对第一条不等式左乘上一个恒非负的向量<span class="math inline">\(\mathbf{w^T}\)</span>，得到<span class="math inline">\(\mathbf{w}^T\mathbf{Mv}\le\mathbf{w}^T\mathbf{g}\)</span>，即得到<span class="math inline">\(\mathbf{w}^T\mathbf{g}=\mathbf{0}\)</span>，和第三条不等式矛盾，因此这两个陈述至多只有一个成立。</p><p>接下来证明第2个陈述和如下第3个陈述是等价的：</p><ol start="3" type="1"><li><span class="math inline">\(\exists \mathbf{w}\in\mathbb{R}^{m+1}\)</span>，使得<span class="math inline">\(\mathbf{w}\ge\mathbf{0},\mathbf{M}^T\mathbf{w}=0,\mathbf{w}^T\mathbf{g}=-1\)</span>。</li></ol><p>必要性显然成立，因为<span class="math inline">\(\mathbf{w}^T\mathbf{g}=-1&lt;0\)</span>，从而第2个陈述也是成立的。接下来证明充分性，令<span class="math inline">\(\mathbf{w&#39;}=-\dfrac{1}{\mathbf{w}^T\mathbf{g}}\cdotw\)</span>，那么由于<span class="math inline">\(-\dfrac{1}{\mathbf{w}^T\mathbf{g}}&lt;0\)</span>，因此<span class="math inline">\(\mathbf{w&#39;}\ge 0\)</span>仍然成立；<span class="math inline">\(\mathbf{w&#39;}^T\mathbf{g}=\dfrac{1}{\mathbf{w}^T\mathbf{g}}\cdot(\mathbf{w}^T\mathbf{g})=-1\)</span>；此外，<span class="math inline">\(\mathbf{w&#39;}^T\mathbf{M}=-\dfrac{1}{\mathbf{w}^T\mathbf{g}}\cdot(\mathbf{w}^T\mathbf{M})=0\)</span>，最终<span class="math inline">\(\mathbf{w&#39;}\)</span>的存在说明充分性成立。由此，第2个陈述和第3个陈述等价。</p><p>假设现在第2个陈述不成立，那么第3个陈述也不成立。那么可以将<span class="math inline">\(\mathbf{M}^T\mathbf{w}=\mathbf{0},\mathbf{g}^T\mathbf{w}=-1\)</span>重写成<span class="math inline">\(\mathbf{A}=(\mathbf{M},\mathbf{g})^T,\mathbf{b}=(0,0,\dots,0,-1)^T\)</span>。</p><p>由于第3个陈述不成立，这意味着<span class="math inline">\(\nexists\mathbf{x}\in\mathbb{R}^{m+1},\mathbf{x}\ge 0\)</span>使得<span class="math inline">\(\mathbf{Ax=b}\)</span>。也就是说，这时不满足<strong>原始</strong>Farkas引理的第1个陈述，那么这意味着<strong>原始</strong>Farkas引理第2个陈述必须成立，因此通过这条陈述，给出了<span class="math inline">\(\exists\mathbf{y}\in\mathbb{R}^{n+1},\mathbf{A}^T\mathbf{y}\ge0,\mathbf{b}^T\mathbf{y}&lt;0\)</span>。</p><p>令<span class="math inline">\(\mathbf{y}=\begin{pmatrix}\mathbf{z}\\\lambda\end{pmatrix}\)</span>，其中<span class="math inline">\(\mathbf{z}\in \mathbb{R}^n,\lambda\in\mathbb{R}\)</span>。由于<span class="math inline">\(\mathbf{b}^T\)</span>前<span class="math inline">\(n\)</span>个分量都是<span class="math inline">\(0\)</span>，因此<span class="math inline">\(\mathbf{b}^T\mathbf{y}=-\lambda&lt;0\)</span>，因此得到<span class="math inline">\(\lambda&gt;0\)</span>。<span class="math inline">\(\mathbf{A}^T\mathbf{y}\ge 0\)</span>意味着<span class="math inline">\(\begin{pmatrix}\mathbf{M}&amp;\mathbf{g}\end{pmatrix}\begin{pmatrix}\mathbf{z}\\\lambda\end{pmatrix}\ge0\)</span>，这给出了<span class="math inline">\(\mathbf{Mz}+\lambda\mathbf{g}\ge 0\)</span>，即<span class="math inline">\(\mathbf{M}(-\mathbf{z}/\lambda)\leg\)</span>。向量<span class="math inline">\((-\mathbf{z}/\lambda)\)</span>的存在证明了<strong>变种</strong>Farkas引理的第1条陈述是正确的，因此原结论成立。</p><h1 id="section-4">29-5</h1><h2 id="a-3">a</h2><p>由于删除了一些约束，因此这个问题的线性规划可以从最小费用流问题转化而来：</p><p><span class="math inline">\(\begin{aligned} \text{minimize}&amp;&amp;\sum_{(u,v)\in E}a(u,v)\cdot f_{uv}\\ \text{subject to}&amp; \\&amp;&amp;f_{uv}&amp;\le c(u,v) &amp;&amp;\forall (u,v)\in E \\&amp;&amp;f_{uv}&amp;\ge 0 &amp;&amp;\forall (u,v)\in E \\&amp;&amp;\sum_{(u,v)\in E} f_{uv}&amp;=\sum_{(v,u)\in E} f_{vu}&amp;&amp;\forall u\in V \end{aligned}\)</span></p><h2 id="b-3">b</h2><p>由于花费函数<span class="math inline">\(a(u,v)&gt;0\)</span>，并且线性规划的目标函数是最小化费用。因此线性规划的最优方案将是：不使用任何边进行流动，那么这样将不会产生任何花费。因此，这个流是的大小为<span class="math inline">\(0\)</span>。</p><h2 id="c-2">c</h2><p>不失一般性，我们可以删除<span class="math inline">\(E\)</span>中<span class="math inline">\((t,s)\)</span>的边，这不会减少最大流的值。</p><p>我们构造图<span class="math inline">\(G&#39;=(V&#39;,E&#39;)\)</span>，其中<span class="math inline">\(V&#39;=V,E&#39;=E\cup\{(t,s)\}\)</span>。令<span class="math inline">\(a(t,s)=-1,c(t,s)=+\infty\)</span>，对于<span class="math inline">\(\forall(u,v)\in E\)</span>，都有<span class="math inline">\(a(u,v)=0,c(u,v)\)</span>为原最大流问题中，有向边<span class="math inline">\((u,v)\)</span>的容量。考虑新构造后的图<span class="math inline">\(G&#39;\)</span>，以及对应的容量函数<span class="math inline">\(c\)</span>和费用函数<span class="math inline">\(a\)</span>，那么最大流问题就相当于解决如此一个最小费用流通问题。</p><p>在<span class="math inline">\(G&#39;\)</span>中，如果一个“流”从<span class="math inline">\(t\)</span>流动到<span class="math inline">\(s\)</span>，那么将会有一个真正的流从<span class="math inline">\(s\)</span>流动到<span class="math inline">\(t\)</span>。并且由于<span class="math inline">\(a(t,s)=-1\)</span>，因此线性规划算法将会“激励”尽量多的流产生，并且产生一个真正的流并不会添加任何代价。由于<span class="math inline">\(c(t,s)=+\infty\)</span>，因此这将不会限制从<span class="math inline">\(s\)</span>到<span class="math inline">\(t\)</span>的流产生。</p><p>最终，舍去变量<span class="math inline">\(f_{ts}\)</span>的值（或者是让其值为<span class="math inline">\(0\)</span>），那么计算出的一组解<span class="math inline">\(f\)</span>为原图<span class="math inline">\(G\)</span>上的最大流。</p><h2 id="d">d</h2><p>令<span class="math inline">\(\displaystyle{A=1+\sum_{(u,v)\inE}a(u,v)}\)</span>，其中<span class="math inline">\(a(u,v)\)</span>是从<span class="math inline">\(u\)</span>到<span class="math inline">\(v\)</span>的距离。也就是说，<span class="math inline">\(M\)</span>是一个足够大的数，但并非是无穷大。</p><p>同样的，不失一般性，我们可以删除<span class="math inline">\(E\)</span>中<span class="math inline">\(s\)</span>的所有入边，这不会增加从<span class="math inline">\(s\)</span>到任意节点的最短路径。</p><p>可以构造图<span class="math inline">\(G&#39;=(V&#39;,E&#39;)\)</span>，其中<span class="math inline">\(V&#39;=V,E&#39;=E\cup\{(v,s):v\inV-\{s\}\}\)</span>。<span class="math inline">\(\forall (v,s)\inE&#39;\)</span>，令<span class="math inline">\(c(v,s)=1,a(v,s)=-A\)</span>。<span class="math inline">\(\forall (u,v)\inE,c(u,v)=+\infty,a(u,v)\)</span>为原最短路问题中，从<span class="math inline">\(u\)</span>到<span class="math inline">\(v\)</span>的距离边权。考虑新构造后的图<span class="math inline">\(G&#39;\)</span>，以及对应的容量函数<span class="math inline">\(c\)</span>和费用函数<span class="math inline">\(a\)</span>，那么最短路问题就相当于解决如此一个最小费用流通问题。</p><p>在<span class="math inline">\(G&#39;\)</span>中，任意一条<strong>简单路径</strong>的长度都小于<span class="math inline">\(A\)</span>。因此在一个最小费用流通问题中，使用边<span class="math inline">\((v,s)\inE&#39;\)</span>一定是更优的。对于任意<span class="math inline">\(v\inV-\{s\}\)</span>，这意味着必定有一个流从<span class="math inline">\(s\)</span>到达<span class="math inline">\(v\)</span>，并且这个流的费用是最小的，这时从<span class="math inline">\(s\)</span>到<span class="math inline">\(v\)</span>的这个流恰好就对应了原问题的最短路径。</p><p>最终，舍去所有变量<span class="math inline">\(f_{vs}(s\inV-\{s\})\)</span>（或者是让其值为<span class="math inline">\(0\)</span>）。对于任意节点<span class="math inline">\(v\in V-\{s\}\)</span>，求出从<span class="math inline">\(s\)</span>到<span class="math inline">\(v\)</span>的最短路径，需要从<span class="math inline">\(v\)</span>开始，逐渐向前移动，找到这个流的起点即可。最终处理出来的流就是对应最短路径。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论29.3 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/29-3-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/29-3-Exercises/</id>
    <published>2023-10-04T06:40:10.000Z</published>
    <updated>2023-10-04T06:40:10.016Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">29.3-1</h1><p>该线性规划的对偶线性规划为：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;50y_1+100y_2+25y_3\\ \text{subject to}&amp; \\&amp;&amp;-2y_1+5y_2+3y_3&amp;\le 1\\ &amp;&amp;8y_1+2y_2-5y_3&amp;\le1\\ &amp;&amp;0y_1+0y_2+10y_3&amp;\le 1\\&amp;&amp;10y_1+0y_2-2y_3&amp;\le 1\\ &amp;&amp;y_1,y_2,y_3&amp;\ge 0\end{aligned}\)</span></p><h1 id="section-1">29.3-2</h1><p>整个过程分成两个步骤进行：</p><ol type="1"><li><p>是将所有约束的比较符号的方向统一化。不失一般性，如果现在需要将除去非负约束以外的<span class="math inline">\(\ge\)</span>的约束转化成<span class="math inline">\(\le\)</span>的约束，那么只需要对原约束两侧乘上<span class="math inline">\(-1\)</span>，并将比较符号反向即可。</p></li><li><p>假设经第1个步骤处理后，原线性规划的目标函数为<span class="math inline">\(\mathbf{c}^T\mathbf{x}\)</span>，并且朝某一个方向优化（最大/最小），约束是<span class="math inline">\(\mathbf{A}^T\mathbf{x}\circ\mathbf{b}\)</span>，其中<span class="math inline">\(\circ\in\{\le,\ge\}\)</span>。那么原线性规划的对偶线性规划的目标函数是<span class="math inline">\(\mathbf{b}^T\mathbf{y}\)</span>，并且朝<strong>另一个</strong>方向优化（最小/最大），约束是<span class="math inline">\(\mathbf{A}^T\mathbf{y}\overline{\circ}\mathbf{c}\)</span>，即将统一前的比较符号均取反即可。</p></li></ol><h1 id="section-2">29.3-3</h1><p>我们可以给出最大流问题线性规划的标准型为：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;\sum_{(s,v)\in E} f_{sv}-\sum_{(v,s)\in E} f_{vs}\\ \text{subjectto}&amp; \\ &amp;&amp;f_{uv}&amp;\le c(u,v) &amp;&amp;\forall (u,v)\in E\\ &amp;&amp;f_{uv}&amp;\ge 0 &amp;&amp;\forall (u,v)\in E \\&amp;&amp;\sum_{(u,v)\in E} f_{uv}-\sum_{(v,u)\in E} f_{vu}&amp;\le 0&amp;&amp;\forall u\in V-\{s,t\}\\ &amp;&amp;\sum_{(v,u)\in E}f_{vu}-\sum_{(u,v)\in E} f_{uv}&amp;\le 0 &amp;&amp;\forall u\inV-\{s,t\} \end{aligned}\)</span></p><p>可见，令左边的系数矩阵为<span class="math inline">\(\mathbf{A}\)</span>，其大小为<span class="math inline">\((2|V|+2|E|-4)\times |E|\)</span>，右边的<span class="math inline">\(\mathbf{b}\)</span>是一个<span class="math inline">\(2|V|+2|E|-4\)</span>维的向量，其目标函数<span class="math inline">\(\mathbf{c}^T\mathbf{x}\)</span>中的向量<span class="math inline">\(\mathbf{c}^T\)</span>长度为<span class="math inline">\(|E|\)</span>。因此最大流问题的对偶线性规划为</p><p><span class="math inline">\(\begin{aligned} \text{minimize}&amp;&amp;\mathbf{b}^T\mathbf{y}\\ \text{subject to}&amp; \\&amp;&amp;\mathbf{A}^T\mathbf{y}&amp;\ge\mathbf{c}\end{aligned}\)</span></p><h1 id="section-3">29.3-4</h1><p>我们可以给出最小费用流问题线性规划的统一符号方向后的结果为：</p><p><span class="math inline">\(\begin{aligned} \text{minimize}&amp;&amp;\sum_{(u,v)\in E} a(u,v)\cdot f_{uv}\\ \text{subject to}&amp; \\&amp;&amp;f_{uv}&amp;\le c(u,v) &amp;&amp;\forall (u,v)\in E \\&amp;&amp;f_{uv}&amp;\ge 0 &amp;&amp;\forall (u,v)\in E \\&amp;&amp;\sum_{(u,v)\in E} f_{uv}-\sum_{(v,u)\in E} f_{vu}&amp;\le 0&amp;&amp;\forall u\in V-\{s,t\}\\ &amp;&amp;\sum_{(v,u)\in E}f_{vu}-\sum_{(u,v)\in E} f_{uv}&amp;\le 0 &amp;&amp;\forall u\inV-\{s,t\}\\ &amp;&amp;\sum_{(s,v)\in E} f_{sv}-\sum_{(v,s)\in E}f_{vs}&amp;\le d\\ &amp;&amp;\sum_{(v,s)\in E} f_{vs}-\sum_{(s,v)\in E}f_{sv}&amp;\le -d \end{aligned}\)</span></p><p>可见，令左边的系数矩阵为<span class="math inline">\(\mathbf{A}\)</span>，其大小为<span class="math inline">\((2|V|+2|E|-2)\times |E|\)</span>，右边的<span class="math inline">\(\mathbf{b}\)</span>是一个<span class="math inline">\(2|V|+2|E|-2\)</span>维的向量，其目标函数<span class="math inline">\(\mathbf{c}^T\mathbf{x}\)</span>中的向量<span class="math inline">\(\mathbf{c}^T\)</span>长度为<span class="math inline">\(|E|\)</span>。因此最小费用流问题的对偶线性规划为</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;\mathbf{b}^T\mathbf{y}\\ \text{subject to}&amp; \\&amp;&amp;\mathbf{A}^T\mathbf{y}&amp;\ge\mathbf{c}\end{aligned}\)</span></p><h1 id="section-4">29.3-5</h1><p>不失一般性，这里仅考虑标准型的线性规划：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;\mathbf{c}^T\mathbf{x}\\ \text{subject to}&amp; \\&amp;&amp;\mathbf{A}\mathbf{x}&amp;\le\mathbf{b}\\&amp;&amp;\mathbf{x}&amp;\ge\mathbf{0} \end{aligned}\)</span></p><p>按照定义，其对偶线性规划为：</p><p><span class="math inline">\(\begin{aligned} \text{minimize}&amp;&amp;\mathbf{b}^T\mathbf{y}\\ \text{subject to}&amp; \\&amp;&amp;\mathbf{A}^T\mathbf{y}&amp;\ge\mathbf{c}\\&amp;&amp;\mathbf{y}&amp;\ge\mathbf{0} \end{aligned}\)</span></p><p>该对偶线性规划的对偶线性规划为：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;\mathbf{c}^T\mathbf{x&#39;}\\ \text{subject to}&amp; \\&amp;&amp;\mathbf{A}\mathbf{x&#39;}&amp;\le\mathbf{b}\\&amp;&amp;\mathbf{x&#39;}&amp;\ge\mathbf{0} \end{aligned}\)</span></p><p>可见，第一个线性规划和第三个线性规划的形式是完全一致的，因此一个线性规划对偶的对偶是它本身。</p><h1 id="section-5">29.3-6</h1><p>最大流问题中，推论24.5最大流的值的上界被最小割值限制着，这可以被解释成最大流问题的弱对偶。</p><h1 id="section-6">29.3-7</h1><p>本题以分类讨论为主。</p><p>对于原线性规划：</p><ul><li>当<span class="math inline">\(r&gt;0,s&lt;0\)</span>时，原线性规划的可行域是<span class="math inline">\(\varnothing\)</span>，因此它不可行。</li><li>当<span class="math inline">\(r&gt;0,s\ge0\)</span>时，原线性规划的可行域是<span class="math inline">\(0\le x\les/r\)</span>。此时目标值必定是有限的。</li><li>当<span class="math inline">\(r=0,s&lt;0\)</span>时，原线性规划的可行域是<span class="math inline">\(\varnothing\)</span>，因此它不可行。</li><li>当<span class="math inline">\(r=0,s\ge0\)</span>时，原线性规划的可行域是<span class="math inline">\(x\ge0\)</span>。如果<span class="math inline">\(t\le0\)</span>，那么其目标值有限，否则是无界的。</li><li>当<span class="math inline">\(r&lt;0,s&lt;0\)</span>时，原线性规划的可行域是<span class="math inline">\(x\ge s/r\)</span>。如果<span class="math inline">\(t\le0\)</span>，那么其目标值有限，否则是无界的。</li><li>当<span class="math inline">\(r&lt;0,s\ge0\)</span>时，原线性规划的可行域是<span class="math inline">\(x\ge0\)</span>。如果<span class="math inline">\(t\le0\)</span>，那么其目标值有限，否则是无界的。</li></ul><p>可见这个线性规划的对偶线性规划是：</p><p><span class="math inline">\(\begin{aligned} \text{minimize}&amp;&amp;sy\\ \text{subject to}&amp; \\ &amp;&amp;ry&amp;\ge t\\&amp;&amp;y&amp;\ge0 \end{aligned}\)</span></p><ul><li>当<span class="math inline">\(r&gt;0,t\le0\)</span>时，对偶线性规划的可行域是<span class="math inline">\(y\ge0\)</span>。如果<span class="math inline">\(s\ge0\)</span>，那么其目标值有限，否则是无界的。</li><li>当<span class="math inline">\(r&gt;0,t&gt;0\)</span>时，对偶线性规划的可行域是<span class="math inline">\(y\ge t/r\)</span>。如果<span class="math inline">\(s\ge0\)</span>，那么其目标值有限，否则是无界的。</li><li>当<span class="math inline">\(r=0,t\le0\)</span>时，对偶线性规划的可行域是<span class="math inline">\(y\ge0\)</span>。如果<span class="math inline">\(s\ge0\)</span>，那么其目标值有限，否则是无界的。</li><li>当<span class="math inline">\(r=0,t&gt;0\)</span>时，对偶线性规划的可行域是<span class="math inline">\(\varnothing\)</span>，因此它不可行。</li><li>当<span class="math inline">\(r&lt;0,t\le0\)</span>时，对偶线性规划的可行域是<span class="math inline">\(0\lex\le t/r\)</span>。此时目标值必定是有限的。</li><li>当<span class="math inline">\(r&lt;0,t&gt;0\)</span>时，对偶线性规划的可行域是<span class="math inline">\(\varnothing\)</span>，因此它不可行。</li></ul><p>综上所述：</p><ol type="1"><li>当<span class="math inline">\((r=0\land s\ge 0\land t\le0)\lor(r&gt;0\land r&gt;0\land s\ge 0)\lor(r&lt;0\land t\le0)\)</span>为真时，满足第一个断言。</li><li>当<span class="math inline">\((r=0\land s\ge 0\land t&gt;0)\lor(r&lt;0\land t&gt; 0)\)</span>为真时，满足第二个断言。</li><li>当<span class="math inline">\((r=0\land s&lt; 0\land t\le0)\lor(r&gt;0\land s&lt; 0)\)</span>为真时，满足第三个断言。</li><li>当<span class="math inline">\(r=0\land s&lt; 0\land t&gt;0\)</span>为真时，满足第四个断言。</li></ol><h1 id="section-7">29.3-8</h1><p>如果一个线性规划无解，即不存在一个向量<span class="math inline">\(\mathbf{x}\)</span>满足各个约束，那么说明这个标准线性规划是不可行的。</p><p>否则，必定存在一系列可行解，使得多个向量<span class="math inline">\(\mathbf{x}\)</span>满足这些约束。如果这个线性规划没有有限的最优目标值，那么说明这个可行域必定是无界的。否则按照最优性（即要么最大，要么最小），有一个有限目标值的最优解。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论29.2 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/29-2-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/29-2-Exercises/</id>
    <published>2023-10-04T06:40:06.000Z</published>
    <updated>2023-10-04T06:40:06.717Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">29.2-1</h1><p>这个最短路问题的对应线性规划问题如下：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;d_x\\ \text{subject to}&amp; \\ &amp;&amp;d_t&amp;\le d_s+3\\&amp;&amp;d_y&amp;\le d_s+5\\ &amp;&amp;d_x&amp;\le d_t+6\\&amp;&amp;d_y&amp;\le d_t+2\\ &amp;&amp;d_z&amp;\le d_x+2\\&amp;&amp;d_t&amp;\le d_y+1\\ &amp;&amp;d_x&amp;\le d_y+4\\&amp;&amp;d_z&amp;\le d_y+6\\ &amp;&amp;d_s&amp;\le d_z+3\\&amp;&amp;d_x&amp;\le d_z+7\\ &amp;&amp;d_s&amp;=0\end{aligned}\)</span></p><h1 id="section-1">29.2-2</h1><p>这和第29.2章介绍的线性规划系统类似，如下给出：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;\sum_{v\in V} d_v\\ \text{subject to}&amp; \\ &amp;&amp;d_v&amp;\led_u+w(u,v) &amp;&amp;\forall (u,v)\in E \\ &amp;&amp;d_s&amp;=0\end{aligned}\)</span></p><p>两条约束和29.2所给出的约束相同，区别在于目标函数。由于目前是希望最大化所有变量<span class="math inline">\(d_v\)</span>，但是最短路径的松弛性质仍然保持，因此这时的最优解对应了<span class="math inline">\(s\)</span>到所有节点的最短路径长度。</p><h1 id="section-2">29.2-3</h1><p>这个最大流问题的对应线性规划问题如下：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;f_{sv_1}+f_{sv_2}\\ \text{subject to}&amp; \\ &amp;&amp;f_{uv}&amp;\ge 0&amp;&amp;\forall (u,v)\in E \\ &amp;&amp;f_{sv_1}&amp;\le 16\\&amp;&amp;f_{sv_2}&amp;\le 14\\ &amp;&amp;f_{v_1v_3}&amp;\le 12\\&amp;&amp;f_{v_2v_1}&amp;\le 4\\ &amp;&amp;f_{v_2v_4}&amp;\le 14\\&amp;&amp;f_{v_3v_2}&amp;\le 9\\ &amp;&amp;f_{v_3v_t}&amp;\le 20\\&amp;&amp;f_{v_4v_3}&amp;\le 7\\ &amp;&amp;f_{v_4t}&amp;\le 4\\&amp;&amp;f_{sv_1}+f_{v_2v_1}&amp;= f_{v_1v_3}\\&amp;&amp;f_{sv_2}+f_{v_3v_2}&amp;= f_{v_2v_1}+f_{v_2v_4}\\&amp;&amp;f_{v_1v_3}+f_{v_4v_3}&amp;= f_{v_3v_2}+f_{v_3t}\\&amp;&amp;f_{v_2v_4}&amp;= f_{v_4v_3}+f_{v_4t}\\\end{aligned}\)</span></p><h1 id="section-3">29.2-4</h1><p>这里使用题目24.1-4的结果：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;\sum_{(s,v)\in E} f_{sv}-\sum_{(v,s)\in E} f_{vs}\\ \text{subjectto}&amp; \\ &amp;&amp;f_{uv}&amp;\ge 0 &amp;&amp;\forall (u,v)\in E \\&amp;&amp;f_{uv}&amp;\le c(u,v) &amp;&amp;\forall (u,v)\in E \\&amp;&amp;\sum_{(u,v)\in E} f_{uv}&amp;=\sum_{(v,u)\in E} f_{vu}&amp;&amp;\forall u\in V-\{s,t\} \end{aligned}\)</span></p><p>可见，这里一共有<span class="math inline">\(2|E|+|V|-2=O(V+E)\)</span>条约束。</p><h1 id="section-4">29.2-5</h1><p>令二分图<span class="math inline">\(G=(V,E),V=L\cupR\)</span>。使用第24.3章的结论，我们可以将这个问题转化成最大流问题进行解答：令<span class="math inline">\(V&#39;=V\cup\{s,t\},E&#39;=\{(s,l):l\inL\}\cup\{(r,t):r\in R\}\cup E\)</span>，对于<span class="math inline">\(\forall (u,v)\in E&#39;\)</span>，都有<span class="math inline">\(c(u,v)=1\)</span>。那么图<span class="math inline">\(G\)</span>的二分图最大匹配数量相当于是图<span class="math inline">\(G&#39;=(V&#39;,E&#39;)\)</span>中从<span class="math inline">\(s\)</span>到<span class="math inline">\(t\)</span>的最大流。这个线性规划将使用题目29.2-4的结论，如下：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;\sum_{l\in L}f_{sl} \\ \text{subject to}&amp; \\&amp;&amp;f_{uv}&amp;\ge 0 &amp;&amp;\forall (u,v)\in E&#39; \\&amp;&amp;f_{uv}&amp;\le c(u,v) &amp;&amp;\forall (u,v)\in E&#39; \\&amp;&amp;\sum_{(u,v)\in E&#39;} f_{uv}&amp;=\sum_{(v,u)\in E&#39;}f_{vu} &amp;&amp;\forall u\in V \end{aligned}\)</span></p><h1 id="section-5">29.2-6</h1><p>这意味着对于任意一条路径<span class="math inline">\(p_i\)</span>，如果其经过边<span class="math inline">\((u,v)\)</span>，那么这条路径就需要受到这条边容量的限制。因此，对于路径<span class="math inline">\(P\)</span>，我们可以写出如下线性规划：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;\sum_{i=1}^px_i \\ \text{subject to}&amp; \\ &amp;&amp;x_{i}&amp;\ge 0&amp;&amp;\forall i\in[1,p] \\ &amp;&amp;\sum_{1\le i\le p,(u,v)\inP_i}x_i&amp;\le c(u,v) &amp;&amp;\forall (u,v)\in E \\\end{aligned}\)</span></p><p>如果<span class="math inline">\(G\)</span>是一个有<span class="math inline">\(\dfrac{|V|(|V|-1)}{2}\)</span>条边的有向无环图，那么<span class="math inline">\(p\)</span>的值可以达到<span class="math inline">\(2^{|V|-2}\)</span>。因此使用这个线性规划求解最大流问题是不明智的，因为约束的大小和数量都太多（呈指数级数量）。</p><h1 id="section-6">29.2-7</h1><p>只需要对多商品流问题的目标函数进行修改即可。修改后的线性规划问题如下：</p><p><span class="math inline">\(\begin{aligned} \text{minimize}&amp;&amp;\sum_{(u,v)\in E}a(u,v)\cdot\left(\sum_{i=1}^k f_{i,u,v}\right) \\\text{subject to}&amp; \\ &amp;&amp;\sum_{i=1}^kf_{i,u,v}&amp;\le c(u,v)&amp;&amp;\forall (u,v)\in E\\ &amp;&amp;\sum_{(u,v)\inE}f_{i,u,v}-\sum_{(v,u)\in E}f_{i,v,u}&amp;= 0 &amp;&amp;\foralli\in[1,k],\forall u\in V-\{s_i,t_i\} \\ &amp;&amp;\sum_{(s_i,v)\inE}f_{i,s_i,v}-\sum_{(v,s_i)\in E}f_{i,v,s_i}&amp;= d_i &amp;&amp;\foralli\in[1,k]\\ &amp;&amp;f_{i,u,v}&amp;\ge 0 &amp;&amp;\foralli\in[1,k],\forall (u,v)\in E\\ \end{aligned}\)</span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论29.1 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/29-1-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/29-1-Exercises/</id>
    <published>2023-10-04T06:40:02.000Z</published>
    <updated>2023-10-04T06:47:57.910Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">29.1-1</h1><p><span class="math inline">\((0,7),(1,6),(2,5)\)</span>分别是这个线性规划的<span class="math inline">\(3\)</span>个可行解，其目标函数值分别为<span class="math inline">\(21,16,11\)</span>。</p><h1 id="section-1">29.1-2</h1><p><span class="math inline">\((7,3,0),(7,4,0),(7,5,0)\)</span>分别是这个线性规划的<span class="math inline">\(3\)</span>个可行解，其目标函数值分别为<span class="math inline">\(35,42,49\)</span>。</p><h1 id="section-2">29.1-3</h1><p>对第二条约束变形后，得到<span class="math inline">\(x_1+x_2\ge5\)</span>，这和第一条约束<span class="math inline">\(x_1+x_2\le2\)</span>是明显冲突的。因此，这个线性规划是不可行的。</p><h1 id="section-3">29.1-4</h1><p>考虑令<span class="math inline">\(x_1=2t,x_2=t\)</span>，那么目标函数为<span class="math inline">\(t\)</span>。当<span class="math inline">\(t\ge0\)</span>时，第一条约束化成<span class="math inline">\(-3t\le-1\)</span>，第二条约束化成<span class="math inline">\(-4t\le-2\)</span>，其余约束化成<span class="math inline">\(t\ge0\)</span>。哪怕<span class="math inline">\(t\)</span>趋向于正无穷，这些约束仍然是成立的。由于需要最大化目标值，那么目标值可以到达正无穷，因此这个线性规划是无界的。</p><h1 id="section-4">29.1-5</h1><p>构造出的线性规划问题如下：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;x_1+x_2\\ \text{subject to}&amp; \\ &amp;&amp;x_1+2x_2&amp;\le 4\\&amp;&amp;2x_1+x_2&amp;\le 5 \end{aligned}\)</span></p><p>虽然可行解是无界的，但是最优解只有一个：<span class="math inline">\((2,1)\)</span>，其目标值为<span class="math inline">\(3\)</span>。</p><h1 id="section-5">29.1-6</h1><h2 id="a">a</h2><p>只需要将等式约束<span class="math inline">\(\displaystyle{\sum_{j=1}^na_{ij}x_j=b_j}\)</span>替换成如下两个约束即可：</p><p><span class="math inline">\(\begin{aligned} \sum_{j=1}^n a_{ij}x_j&amp;\le b_i\\ \sum_{j=1}^n a_{ij}x_j &amp;\ge b_i\end{aligned}\)</span></p><h2 id="b">b</h2><p>将不等式约束<span class="math inline">\(\displaystyle{\sum_{j=1}^na_{ij}x_j\le b_j}\)</span>替换成如下两个约束即可：</p><p><span class="math inline">\(\begin{aligned} \sum_{j=1}^n a_{ij}x_j&amp;= b_i-s\\ s&amp;\ge 0 \end{aligned}\)</span></p><h1 id="section-6">29.1-7</h1><p>如果当前是对某个目标函数<span class="math inline">\(f(x)\)</span>最小化，那么其等价的最大化线性约束就是对目标函数<span class="math inline">\(g(x)=-f(x)\)</span>最大化。</p><p>令<span class="math inline">\(S\)</span>是第一个线性规划的可行域，<span class="math inline">\(x_0\in S\)</span>是其一个最优解。这意味着<span class="math inline">\(\forall x\in S\)</span>，都有<span class="math inline">\(f(x)\ge f(x_0)\)</span>。代入<span class="math inline">\(g(x)=-f(x)\)</span>，那么有<span class="math inline">\(f\forall x \in S\)</span>，均有<span class="math inline">\(g(x)\leg(x_0)\)</span>。因此，原线性规划和新线性规划是等价的。</p><h1 id="section-7">29.1-8</h1><p>还需要添加如下约束，以确保真实投票人数不会超过人口数：</p><p><span class="math inline">\(\begin{aligned}-2x_1+8x_2+0x_3+10x_4&amp;\le 100\\ 5x_1+2x_2+0x_3+0x_4&amp;\le 200\\3x_1-5x_2+10x_3-2x_4&amp;\le 50\\ \end{aligned}\)</span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论26 Problems 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/26-Problems/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/26-Problems/</id>
    <published>2023-10-01T11:28:03.000Z</published>
    <updated>2023-10-01T11:51:14.574Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">26-1</h1><h2 id="a">a</h2><p>使用得到<code>P-MAT-VEC-RECURSIVE</code>类似的方法对<code>SUM-ARRAYS</code>进行修改，同样可以得到其基于递归的并行版本<code>SUM-ARRAYS-RECURSIVE</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SUM-ARRAYS-RECURSIVE(A, B, C, i, i&#x27;)</span><br><span class="line">  if i == i&#x27;</span><br><span class="line">    C[i] = A[i] + B[i]</span><br><span class="line">  else</span><br><span class="line">    mid = ⌊(i + i&#x27;) / 2⌋</span><br><span class="line">    spawn SUM-ARRAYS-RECURSIVE(A, B, C, i, mid)</span><br><span class="line">    spawn SUM-ARRAYS-RECURSIVE(A, B, C, mid + 1, i&#x27;)</span><br><span class="line">    sync</span><br></pre></td></tr></table></figure><p>可见这个算法的工作量为<span class="math inline">\(T_1(n)=\Theta(n)\)</span>。由于其递归深度达到<span class="math inline">\(\Theta(\lg n)\)</span>，并且只需要花费<span class="math inline">\(\Theta(1)\)</span>的时间即可完成，因此其持续时间为<span class="math inline">\(T_{\infty}(n)=\Theta(\lgn)\cdot\Theta(1)=\Theta(\lg n)\)</span>。因此的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n/\lgn)\)</span>。</p><h2 id="b">b</h2><p>如果<span class="math inline">\(grain\text{-}size=1\)</span>，那么<span class="math inline">\(r=n\)</span>，<code>SUM-ARRAYS'</code>中的<code>for</code>循环将会串行地执行<span class="math inline">\(n\)</span>次，每次调用<code>ADD-SUBARRAY</code>都只花费<span class="math inline">\(\Theta(1)\)</span>的时间。因此持续时间<span class="math inline">\(T_{\infty}(n)=n\cdot\Theta(1)=\Theta(n)\)</span>。可以知道其工作量为<span class="math inline">\(T_1(n)=\Theta(n)\)</span>，因此其并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(1)\)</span>。</p><h2 id="c">c</h2><p>令<span class="math inline">\(g=grain\text{-}size\)</span>。执行单次<code>ADD-SUBARRAY</code>所需要的时间为<span class="math inline">\(O(g)\)</span>。在<code>SUM-ARRAYS'</code>中，一共需要执行<span class="math inline">\(n/g\)</span>次<code>ADD-SUBARRAY</code>，但是<code>for</code>循环并没有带有<code>parrllel</code>关键字，也就是说，这些调用<code>ADD-SUBARRAY</code>的线程是按顺序启动的，它们并非同时启动的，因此这里仍然需要花费<span class="math inline">\(O(n/g)\)</span>的时间完成这个<code>for</code>循环。</p><p>因此，<code>SUM-ARRAYS'</code>需要花费<span class="math inline">\(O(g+n/g)\)</span>的时间完成。令<span class="math inline">\(f(g)=g+n/g\)</span>，那么有<span class="math inline">\(f&#39;(g)=1-n/g^2\)</span>。令<span class="math inline">\(f&#39;(g)=00\)</span>，即<span class="math inline">\(g=\sqrt{n}\)</span>时，<code>SUM-ARRAYS'</code>只需要花费<span class="math inline">\(O(\sqrt{n})\)</span>的时间就可以完成。</p><h1 id="section-1">26-2</h1><h2 id="a-1">a</h2><p>修改后的代码由<code>P-MATRIX-MULTIPLY-RECURSIVE'</code>所示，它消去了临时矩阵<span class="math inline">\(D\)</span>的存在。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A, B, C, n)</span><br><span class="line">  if n == 1</span><br><span class="line">    c11 = c11 + a11 · b11</span><br><span class="line">    return</span><br><span class="line">  partition A, B, C, and D into n/2 × n/2 submatrices A11, A12, A21, A22; B11, B12, B21, B22; and C11, C12, C21, C22; respectively</span><br><span class="line">  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A11, B11, C11, n / 2)</span><br><span class="line">  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A11, B12, C12, n / 2)</span><br><span class="line">  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A21, B11, C21, n / 2)</span><br><span class="line">  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A21, B12, C22, n / 2)</span><br><span class="line">  sync</span><br><span class="line">  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A12, B21, C11, n / 2)</span><br><span class="line">  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A12, B22, C12, n / 2)</span><br><span class="line">  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A22, B21, C21, n / 2)</span><br><span class="line">  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A22, B22, C22, n / 2)</span><br><span class="line">  sync</span><br></pre></td></tr></table></figure><p>可见，它的串行投影是<code>MATRIX-MULTIPLY-RECURSIVE</code>，因此其工作量为<span class="math inline">\(\Theta(n^3)\)</span>。</p><h2 id="b-1">b</h2><p>对于其工作量<span class="math inline">\(T_1(n)\)</span>，可以给出其递推式<span class="math inline">\(T_1(n)=8T_1(n/2)+\Theta(n^2)\)</span>，因此得到<span class="math inline">\(T_1(n)=\Theta(n^3)\)</span>。</p><p>对于其持续时间，除了递归调用，<code>P-MATRIX-MULTIPLY-RECURSIVE'</code>没有再做其它工作。因此可以给出其递推式<span class="math inline">\(T_{\infty}(n)=2T_{\infty}(n/2)+\Theta(1)\)</span>，最终通过主定理可以得知<span class="math inline">\(T_{\infty}(n)=\Theta(n)\)</span>。</p><p>也就是说，算法<code>P-MATRIX-MULTIPLY-RECURSIVE'</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^2)\)</span>。</p><h2 id="c-1">c</h2><p>忽略掉<span class="math inline">\(\Theta\)</span>符号后，对于<span class="math inline">\(1000\times1000\)</span>的矩阵而言，调用<code>P-MATRIX-MULTIPLY-RECURSIVE'</code>的并行度为<span class="math inline">\(10^6\)</span>。相比于调用<code>P-MATRIX-MULTIPLY-RECURSIVE</code>得到<span class="math inline">\(10^7\)</span>的并行度，计算机依旧不会有这么多的处理器，但是在算法的运行时间的常数却明显减少了，因此这种权衡是值得的。</p><h1 id="section-2">26-3</h1><h2 id="a-2">a</h2><p>对<code>LU-DECOMPOSITION</code>修改后得到的并行化版本为<code>P-LU-DECOMPOSITION</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">P-LU-DECOMPOSITION(A, n)</span><br><span class="line">  let L and U be new n × n matrices </span><br><span class="line">  initialize U with 0s below the diagonal</span><br><span class="line">  initialize L with 1s on the diagonal and 0s above the diagonal</span><br><span class="line">  for k = 1 to n</span><br><span class="line">    u_&#123;kk&#125; = a_&#123;kk&#125;</span><br><span class="line">    parallel for i = k + 1 to n</span><br><span class="line">      l_&#123;ik&#125; = a_&#123;ik&#125; / a_&#123;kk&#125;</span><br><span class="line">      u_&#123;ki&#125; = a_&#123;ki&#125;</span><br><span class="line">    parallel for i = k + 1 to n</span><br><span class="line">      parallel for j = k + 1 to n</span><br><span class="line">        a_&#123;ij&#125; = a_&#123;ij&#125; − l_&#123;ik&#125; * u_&#123;kj&#125;</span><br><span class="line">  return L and U</span><br></pre></td></tr></table></figure><p>也就是说，所有内循环都可以进行并行，但是最外层的那一层循环不允许并行。第一个内循环能够并行的原因是：它只读取<span class="math inline">\(a\)</span>矩阵的元素，并修改<span class="math inline">\(L,U\)</span>对应行和对应列的元素，并不会进行多次存取。第二个双重内循环能够并行的原因是第<span class="math inline">\(i\)</span>轮二层循环，第<span class="math inline">\(j\)</span>轮三次循环中，他只会读取<span class="math inline">\(L,U\)</span>矩阵的值并且修改<span class="math inline">\(a_{ij}\)</span>的值，不会造成冲突。外层循环不能是并行的原因是按照LU分解的定义，后一次的运行依赖于前一次的结果。</p><p><code>P-LU-DECOMPOSITION</code>的串行投影是<code>LU-DECOMPOSITION</code>，因此其工作量为<span class="math inline">\(T_1(n)=\Theta(n^3)\)</span>。</p><p>对于<code>P-LU-DECOMPOSITION</code>的持续时间，第一层的第一次内循环花费的时间是<span class="math inline">\(\Theta(\lg(n-k))=\Theta(\lgn)\)</span>，因为转化成<code>spawn ... sync</code>结构后就变成了分支法，然后进行递归。第二次的两个双重嵌套寻呼按的原因相同，其花费的时间为<span class="math inline">\(\Theta(\lg(n-k))+\Theta(\lg(n-k))=\Theta(\lgn)\)</span>。因此，外层<code>for</code>循环需要<span class="math inline">\(\Theta(\lgn)\)</span>的时间完成一次。最终，<code>P-LU-DECOMPOSITION</code>的持续时间为<span class="math inline">\(T_{\infty}(n)=n\cdot \Theta(\lg n)=\Theta(n\lgn)\)</span>。</p><p>最终我们可以计算出<code>P-LU-DECOMPOSITION</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^2/\lgn)\)</span>。</p><h2 id="b-2">b</h2><p>对<code>LUP-DECOMPOSITION</code>修改后得到的并行化版本为<code>P-LUP-DECOMPOSITION</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">P-LUP-DECOMPOSITION(A, n)</span><br><span class="line">  let π[1 : n] be a new array</span><br><span class="line">  parallel for i = 1 to n</span><br><span class="line">    π[i] = i</span><br><span class="line">  for k = 1 to n</span><br><span class="line">    p = 0</span><br><span class="line">    parallel for i = k to n</span><br><span class="line">      if |a_&#123;ik&#125;| &gt; p</span><br><span class="line">        p = |a_&#123;ik&#125;|</span><br><span class="line">        k&#x27; = i</span><br><span class="line">    if p == 0</span><br><span class="line">      error &quot;singular matrix&quot;</span><br><span class="line">    exchange π[k] with π[k&#x27;]</span><br><span class="line">    parallel for i = 1 to n</span><br><span class="line">      exchange a_&#123;ki&#125; with a_&#123;k&#x27;i&#125; </span><br><span class="line">    parallel for i = k + 1 to n</span><br><span class="line">      a_&#123;ik&#125; = a_&#123;ik&#125; / a_&#123;kk&#125;</span><br><span class="line">      parallel for j = k + 1 to n</span><br><span class="line">        a_&#123;ij&#125; = a_&#123;ij&#125; − a_&#123;ik&#125; * a_&#123;kj&#125;</span><br></pre></td></tr></table></figure><p>第2行的<code>for</code>循环可以并行，这是显而易见的。第6-9行的<code>for</code>循环是可以并行的，因为这是寻找一个最大值，在这个过程中，<span class="math inline">\(n\)</span>个元素构成一棵<span class="math inline">\(n\)</span>个叶节点的二叉树，对于内部节点，它是两个子节点中的最大值，由于这棵树的深度为<span class="math inline">\(\Theta(\lgn)\)</span>，因此这段循环的持续时间为<span class="math inline">\(\Theta(\lgn)\)</span>。第13行的<code>for</code>循环用于交换两行元素，显而易见是可以并行的。对于第15行和17行的<code>for</code>循环，第16行仅仅是对<span class="math inline">\(a_{ik}\)</span>进行更新，此后都是对<span class="math inline">\(a_{ij}(j&gt;k)\)</span>中的所有元素进行更新。至于先对哪一行操作都是没有关系的，因此第15行和17行的<code>for</code>循环它们都可以并行。外面针对<span class="math inline">\(k\)</span>的<code>for</code>循环不能并行，因为会导致数据读取冲突。</p><p><code>P-LUP-DECOMPOSITION</code>的串行投影是<code>LUP-DECOMPOSITION</code>，因此其工作量为<span class="math inline">\(T_1(n)=\Theta(n^3)\)</span>。</p><p>对于<code>P-LUP-DECOMPOSITION</code>的持续时间，分析和<code>P-LU-DECOMPOSITION</code>非常相似。第6，13，15，17行的<code>for</code>循环都可以进行，因此这部分只使用<span class="math inline">\(\Theta(\lgn)\)</span>的时间即可完成。最终，<code>P-LUP-DECOMPOSITION</code>的持续时间为<span class="math inline">\(T_{\infty}(n)=n\cdot \Theta(\lg n)=\Theta(n\lgn)\)</span>。</p><p>最终我们可以计算出<code>P-LUP-DECOMPOSITION</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^2/\lgn)\)</span>。</p><h2 id="c-2">c</h2><p>对<code>LUP-SOLVE</code>修改后得到的并行化版本为<code>P-LUP-SOLVE</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">P-LUP-SOLVE(L, U, π, b, n)</span><br><span class="line">  let x and y be new vectors of length n</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    val = 0</span><br><span class="line">    parallel for j = 1 to i - 1</span><br><span class="line">      val = val + l_&#123;ij&#125; * y_j</span><br><span class="line">    y_i = b_&#123;π[i]&#125; - val</span><br><span class="line">  for i = n downto 1</span><br><span class="line">    val = 0</span><br><span class="line">    parallel for j = i + 1 to n</span><br><span class="line">      val = val + u_&#123;ij&#125; * x_j</span><br><span class="line">    x_i = (y_u - val) / u_&#123;ii&#125;</span><br><span class="line">  return x</span><br></pre></td></tr></table></figure><p>第4和9行的<code>for</code>循环可以并行，只需要将长度为<span class="math inline">\(n\)</span>的序列构造出一棵<span class="math inline">\(n\)</span>个叶子节点的完全二叉树即可，对于内部节点，它是两个子节点中的值之和。因此，这两个内部<code>for</code>循环都能够在<span class="math inline">\(\Theta(\lgn)\)</span>的时间内完成。对于第2和7行的<code>for</code>循环，因为后面计算<span class="math inline">\(x,y\)</span>值需要依赖前面已经计算出的<span class="math inline">\(x,y\)</span>值。</p><p>最终，<code>P-LUP-SOLVE</code>的串行投影即为<code>LUP-SOLVE</code>，因此其工作量为<span class="math inline">\(T_1(n)=\Theta(n^2)\)</span>。按照上面的结论，可以得到持续时间<span class="math inline">\(T_{\infty}(n)=n\cdot \Theta(\lg n)=\Theta(n\lgn)\)</span>。最终我们可以计算出<code>P-LUP-SOLVE</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n/\lgn)\)</span>。</p><h2 id="d">d</h2><p>一个对正定矩阵求逆的并行算法由<code>P-MATRIX-INVERSION-POSITIVE-DEFINITE</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">P-MATRIX-INVERSION-POSITIVE-DEFINITE(A, n)</span><br><span class="line">  partition A into n/2 × n/2 submatrices B, CT, C, D; respectively</span><br><span class="line">  let W[1 : n, 1 : n], X[1 : n, 1 : n], Y[1 : n, 1 : n], Z[1 : n, 1 : n], S[1 : n, 1 : n] be new matrices</span><br><span class="line">  B&#x27; = P-MATRIX-INVERSION-POSITIVE-DEFINITE(B, n / 2)</span><br><span class="line">  W = P-MATRIX-MULTIPLY(C, B&#x27;, W, n / 2)</span><br><span class="line">  WT = W</span><br><span class="line">  P-TRANSPOSE(WT, n / 2)</span><br><span class="line">  P-MATRIX-MULTIPLY(W, CT, X, n / 2)</span><br><span class="line">  S = D - X</span><br><span class="line">  S&#x27; = P-MATRIX-INVERSION-POSITIVE-DEFINITE(S, n / 2)</span><br><span class="line">  P-MATRIX-MULTIPLY(S&#x27;, W, Y, n / 2)</span><br><span class="line">  YT = Y</span><br><span class="line">  P-TRANSPOSE(YT, n / 2)</span><br><span class="line">  P-MATRIX-MULTIPLY(WT, y, Z)</span><br><span class="line">  R = B&#x27; + Z</span><br><span class="line">  A&#x27; = [[R, -YT], [-Y, S&#x27;]]</span><br><span class="line">  return A&#x27;</span><br></pre></td></tr></table></figure><p>按照第28.2章的结论以及不等式28.15，可以知道其工作量<span class="math inline">\(I_1(n)\le2I_1(n/2)+4M_1(n/2)+O(n^2)\)</span>，最终得到<span class="math inline">\(I_1(n)=O(M(n))\)</span>。</p><p>在并行版本中，由题目26.1-8，26.2-3和题26-1-a可知，矩阵的转置、加法和乘法都可以在<span class="math inline">\(\Theta(\lgn)\)</span>时间内完成。在<code>P-MATRIX-INVERSION-POSITIVE-DEFINITE</code>中，一共进行了<span class="math inline">\(2\)</span>次矩阵转置，<span class="math inline">\(4\)</span>次矩阵加减法，<span class="math inline">\(4\)</span>次矩阵乘法。同样的，它们还进行了<span class="math inline">\(2\)</span>次大小为<span class="math inline">\(n/2\timesn/2\)</span>矩阵的求逆。可见，这些步骤都是依赖于前一步的结果，因此步骤之间不能直接并行。我们可以写出它的持续时间<span class="math inline">\(I_{\infty}(n)\)</span>满足<span class="math inline">\(I_{\infty}(n)=2I_{\infty}(n/2)+10\cdot\Theta(\lgn)\)</span>，因此最终得到<span class="math inline">\(I_{\infty}(n)=\Theta(n)\)</span>。</p><p>最终我们可以得到它的并行度为<span class="math inline">\(I_1(n)/I_{\infty}(n)=O(M(n)/n)\)</span>。</p><h1 id="section-3">26-4</h1><h2 id="a-3">a</h2><p>设计的<code>P-REDUCE</code>如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">P-REDUCE(x, i, j)</span><br><span class="line">  if i == j</span><br><span class="line">    return x[i]</span><br><span class="line">  else</span><br><span class="line">    mid = ⌊(i + j) / 2⌋</span><br><span class="line">    l = spawn P-REDUCE(x, i, mid)</span><br><span class="line">    r = spawn P-REDUCE(x, mid + 1, j)</span><br><span class="line">    sync</span><br><span class="line">    return l ⊗ r</span><br></pre></td></tr></table></figure><p>不难发现它的串行投影即为<code>REDUCE</code>，因此它的工作量为<span class="math inline">\(T_1(n)=\Theta(n)\)</span>。由于这棵进行搜索的二叉树的深度为<span class="math inline">\(\Theta(\lgn)\)</span>，因此这个算法的持续时间为<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)\)</span>。</p><h2 id="b-3">b</h2><p>这个算法相当于是以<span class="math inline">\(k=1,2,\dots,n\)</span>对<code>P-REDUCE</code>都进行了一次调用。因此<code>P-SCAN-1</code>的工作量为<span class="math inline">\(\displaystyle{T_1(n)=\sum_{k=1}^n\Theta(k)=\Theta(n^2)}\)</span>。</p><p>接下来求解<code>P-SCAN-1</code>的持续时间。由于对<code>P-SCAN-1</code>对<code>P-REDUCE</code>的间接调用呈树形，假设伪代码中，第<span class="math inline">\(i\)</span>次对<code>P-REDUCE</code>的调用的持续时间为<span class="math inline">\(iter(i)\)</span>，那么有<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)+\max\{iter(i):1\lei\le n\}\)</span>，按照题目26-4-a的结论，有<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)\)</span>。</p><p>因此<code>P-SCAN-1</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^2/\lgn)\)</span>。</p><h2 id="c-3">c</h2><p>我们可以使用归纳法进行证明其正确性。即证明，调用<code>P-SCAN-2-AUX(i, j)</code>，对于<span class="math inline">\(\forall k\in[i,j]\)</span>，它都正确计算出了<span class="math inline">\(y[k]=x[i]\otimes x[i+1]\otimes\dots\otimesx[k]\)</span>。</p><p>对于基本情况：<span class="math inline">\(i=j\)</span>，<code>P-SCAN-2-AUX</code>都正确计算出了<span class="math inline">\(y\)</span>数组，这由<code>P-SCAN-2-AUX</code>的前两行明显可知。</p><p>当<span class="math inline">\(i&lt;j\)</span>时，假设对于区间<span class="math inline">\([i,j]\)</span>内的所有真子区间<span class="math inline">\([i&#39;,j&#39;]\)</span>，即<span class="math inline">\(i\le i&#39;\le j&#39;\le j\)</span>，且<span class="math inline">\(i=i&#39;,j=j&#39;\)</span>不同时成立，<code>P-SCAN-2-AUX</code>都计算出了正确的结果。那么第三行得到了一个<span class="math inline">\(k=\lfloor(i+j)/2\rfloor\)</span>。对于第4和5行的代码，它们分别对<span class="math inline">\(y\)</span>数组的区间<span class="math inline">\([i,k]\)</span>和<span class="math inline">\([k+1,j]\)</span>进行写入，并且读取的内容也不相交，因此这两行代码不会构成竞争。在第6行结束后，<span class="math inline">\(y\)</span>数组满足：如果<span class="math inline">\(p\le k\)</span>，那么<span class="math inline">\(y[p]=x[i]\otimes x[i+1]\otimes\dots\otimesx[p]\)</span>，否则<span class="math inline">\(y[p]=x[k+1]\otimesx[k+2]\otimes\dots\otimes x[k]\)</span>。对于<span class="math inline">\(p&gt;k\)</span>的情况，第8行将<span class="math inline">\(y[p]\)</span>重新赋值成<span class="math inline">\(y[k]\otimes y[p]\)</span>。这个步骤完成后，<span class="math inline">\(\forall p\in[i,j]\)</span>，都有<span class="math inline">\(y[p]=x[i]\otimes x[i+1]\otimes\dots\otimesx[p]\)</span>。因此<code>P-SCAN-2-AUX</code>是正确的。</p><p>接下来考虑<code>P-SCAN-2-AUX</code>的工作量<span class="math inline">\(T_1(n)\)</span>，消去最后的<code>for</code>循环中的<code>parallel</code>关键字后，那么除去递归部分，它的运行时间是<span class="math inline">\(\Theta(n)\)</span>。因此可以写出<span class="math inline">\(T_1(n)=2T_1(n/2)+\Theta(n)\)</span>，从而得到<span class="math inline">\(T_1(n)=\Theta(n\lg n)\)</span>。</p><p>接下来考虑其持续时间<span class="math inline">\(T_{\infty}(n)\)</span>。可见出了递归部分，其余部分仍然需要<span class="math inline">\(\Theta(\lg n)\)</span>进行。因此有<span class="math inline">\(T_{\infty}(n)=T_{\infty}(n/2)+\Theta(\lgn)\)</span>，最终得到<span class="math inline">\(T_{\infty}(n)=\Theta(\lg^2n)\)</span>。</p><p>因此<code>P-SCAN-2</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n/\lgn)\)</span>。</p><h2 id="d-1">d</h2><p><code>P-SCAN-UP</code>第8行填入的是$<code>right ⊗ t[k]</code>；<code>P-SCAN-DOWN</code>的第5行填入<code>v</code>，第6行填入<code>v ⊗ t[k]</code>。</p><p>需要注意的是，<span class="math inline">\(t[k]\)</span>存储的是当一个区间<span class="math inline">\([i,j]\)</span>被尽量均匀地划分成两个区间<span class="math inline">\([i,k],[k+1,j]\)</span>后，<span class="math inline">\(t[k]\)</span>就是记录区间<span class="math inline">\([i,j]\)</span>前面一半元素（即<span class="math inline">\([i,k]\)</span>）的元素之和<span class="math inline">\(t[k]=x[i]\otimes x[i+1]\otimes\dots\otimesx[k]\)</span>。</p><p>首先证明，调用时每个<span class="math inline">\(t[k]\)</span>最多只会被赋值一次（因此，在执行<code>P-SCAN-DOWN</code>时不会造成任何冲突）。只有调用<code>P-SCAN-UP</code>，当<span class="math inline">\(i&lt;j\)</span>时，才会对<span class="math inline">\(t[k]\)</span>进行赋值，在此之后更深的递归讲不会再对<span class="math inline">\(t[k]\)</span>进行赋值，原因如下。如果递归的区间是左半子区间<span class="math inline">\([i,k]\)</span>，那么对于所有<span class="math inline">\([i,k]\)</span>的长度大于等于<span class="math inline">\(2\)</span>的（等于<span class="math inline">\(1\)</span>则不会进入到这个分支）真子区间<span class="math inline">\([i&#39;,k&#39;]\)</span>，都有<span class="math inline">\(\lfloor(i&#39;+k&#39;)/2\rfloor&lt;k\)</span>，因此<span class="math inline">\(t[k]\)</span>不会被重复赋值；如果递归的是右子区间<span class="math inline">\([k+1,j]\)</span>，那么它的访问和读写只会在这个区间内进行，更不会对<span class="math inline">\(t[k]\)</span>进行访问。因此，<span class="math inline">\(t[k]\)</span>确实能够正确记录区间<span class="math inline">\([i,j]\)</span>的信息。根据<code>P-SCAN-DOWB</code>的第5行代码，就可以知道<span class="math inline">\(t[k]\)</span>记录的是区间i,j的左半区间的元素之和。并且，<code>P-SCAN-UP</code>的返回值是<span class="math inline">\([i,j]\)</span>这个区间的所有元素之和，因此结论成立。</p><p>接下来证明每次调用<code>P-SCAN-DOWN(v, x, t, y, i, j)</code>时，总满足<span class="math inline">\(v=x[1]\otimes x[2]\otimes\dots\otimesx[i-1]\)</span>。同样使用归纳法来证明。在<code>P-SCAN-3</code>调用<code>P-SCAN-DOWN</code>时，有<span class="math inline">\(v=x[1],i=2\)</span>，因此基本情况下是成立的。<code>P-SCAN-DOWN</code>首先调用<code>P-SCAN-DOWN(v, x, t, y, i, k)</code>，由于参数<span class="math inline">\(i\)</span>没有变化，因此<span class="math inline">\(v\)</span>仍然使用原来的<span class="math inline">\(v\)</span>，原结论成立；然后调用<code>P-SCAN-DOWN(v ⊗ t[k], x, t, y, k + 1, j)</code>，由于此时<span class="math inline">\(t[k]=x[i]\otimes x[i+1]\otimes\dots\otimesx[k]\)</span>，因此有<span class="math inline">\(v\otimest[k]=x[1]\otimes x[2]\otimes\dots\otimesx[k]\)</span>。因此第二次调用时同样满足题目的条件。因此当<code>P-SCAN-DOWN</code>进入第2行后，<code>y[i] = v ⊗ x[i]</code>则是<span class="math inline">\(y[i]=x[1]\otimes x[2]\otimes\dots\otimesx[i]\)</span>，<span class="math inline">\(y[i]\)</span>被正确地计算出来。</p><p>因此，算法<code>P-SCAN-3</code>是正确的。</p><h2 id="e">e</h2><p>可以发现，这棵树的节点数仍然是<span class="math inline">\(\Theta(n)\)</span>，因此<code>P-SCAN-3</code>的工作量<span class="math inline">\(T_1(n)=\Theta(n)\)</span>。</p><p>接下来首先考虑<code>P-SCAN-UP</code>。由于其每次划分出了两个长度尽量均等的区间，并且其余处理部分都只要<span class="math inline">\(\Theta(1)\)</span>的时间，因此<code>P-SCAN-UP</code>这段代码的持续时间满足<span class="math inline">\(T_{\infty}(n)=T_{\infty}(n/2)+\Theta(1)\)</span>，从而得到<span class="math inline">\(T_{\infty}(n)=\Theta(\lgn)\)</span>。<code>P-SCAN-DOWN</code>和<code>P-SCAN-UP</code>的结构基本相同，因此对其分析也一样。</p><p>最终，<code>P-SCAN-3</code>的持续时间为<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)\)</span>。</p><p>因此，<code>P-SCAN-3</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n/\lgn)\)</span>。</p><h2 id="f">f</h2><p>修改后的<code>P-SCAN-3</code>由<code>P-SCAN-3'</code>给出。代价是并发度将会降低。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">P-SCAN-3&#x27;(x, n)</span><br><span class="line">  let y[1 : n] be a new array</span><br><span class="line">  y[1] = x[1]</span><br><span class="line">  if n &gt; 1</span><br><span class="line">    P-SCAN-3-AUX(x[1], x, y, 2, n)</span><br><span class="line">  return y</span><br><span class="line"></span><br><span class="line">P-SCAN-SUM-ARRAYS(x, i, j)</span><br><span class="line">  if i == j</span><br><span class="line">    return x[i]</span><br><span class="line">  else</span><br><span class="line">    k = ⌊(i + j) / 2⌋</span><br><span class="line">    l = spawn P-SCAN-SUM-ARRAYS(x, t, i, k)</span><br><span class="line">    r = P-SCAN-SUM-ARRAYS(x, t, k + 1, j)</span><br><span class="line">    return l ⊗ r</span><br><span class="line"></span><br><span class="line">P-SCAN-3-AUX(v, x, y, i, j)</span><br><span class="line">  if i == j</span><br><span class="line">    y[i] = v ⊗ x[i]</span><br><span class="line">  else</span><br><span class="line">    k = ⌊(i + j) / 2⌋</span><br><span class="line">    spawn P-SCAN-3-AUX(v, x, y, i, k)</span><br><span class="line">    t = P-SCAN-SUM-ARRAYS(x, i, k)</span><br><span class="line">    P-SCAN-3-AUX(v ⊗ t, x, y, k + 1, j)</span><br><span class="line">    sync</span><br></pre></td></tr></table></figure><h2 id="star-g"><span class="math inline">\(\star\)</span> g</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">P-SCAN-4(x, n)</span><br><span class="line">  l = 1</span><br><span class="line">  while l &lt;= n</span><br><span class="line">    parallel for i = 1 to n by l * 2</span><br><span class="line">      parallel j = 0 to l - 1</span><br><span class="line">        if i + l + j &lt;= n</span><br><span class="line">          x[i + l + j] = x[i + l + j] + x[i + l - 1]</span><br><span class="line">    l = l * 2</span><br></pre></td></tr></table></figure><p>这个算法的基本思想是，将<span class="math inline">\(x\)</span>分成<span class="math inline">\(\lceiln/(2l)\rceil\)</span>块，每一块的长度为<span class="math inline">\(2l\)</span>（最后一块不足<span class="math inline">\(2l\)</span>也以一块记），并且<span class="math inline">\(l\)</span>是<span class="math inline">\(2\)</span>的幂。一开始<span class="math inline">\(l=1\)</span>，将前半块的最后一个元素<span class="math inline">\(x[i+l-1]\)</span>添加到后半块<span class="math inline">\(x[i+l+j](0\lej&lt;l)\)</span>中的每一个元素。从而最终完成后，每一块内部都是对应值的前缀和。可见两个<code>parallel for</code>循环不会导致冲突，因此这个算法的持续时间为<span class="math inline">\(T_{\infty}(n)=\Theta(\lg^2n)\)</span>。</p><h2 id="h">h</h2><p>将字符串中的<code>(</code>视为<span class="math inline">\(+1\)</span>，<code>')'</code>视为<span class="math inline">\(-1\)</span>，得到一个数组<span class="math inline">\(x\)</span>，求出其前缀和<span class="math inline">\(y\)</span>。那么一个括号字符串是合法的，当且仅当<span class="math inline">\(\forall i\in[1,n],y_i\ge 0\)</span>，并且有<span class="math inline">\(y_n=0\)</span>。通过对<code>P-SCAN-3</code>进行改造，我们可以得到一个在<span class="math inline">\(\Theta(\lgn)\)</span>时间内判断一个括号字符串是否合法的程序<code>PARENTHESES-IS-WELL-FORMED</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">PARENTHESES-IS-WELL-FORMED(s, n)</span><br><span class="line">  let y[0 : n] and t[1 : n] be new arrays</span><br><span class="line">  y[0] = 0</span><br><span class="line">  P-SCAN-UP&#x27;(s, t, 1, n)</span><br><span class="line">  mn = P-SCAN-DOWN&#x27;(0, s, t, y, 1, n)</span><br><span class="line">  return mn &gt;= 0 and y[n] == 0</span><br><span class="line"></span><br><span class="line">P-SCAN-UP&#x27;(s, t, i, j)</span><br><span class="line">  if i == j</span><br><span class="line">    if s[i] == &#x27;(&#x27;</span><br><span class="line">      return 1</span><br><span class="line">    else</span><br><span class="line">      return -1</span><br><span class="line">  else</span><br><span class="line">    k = ⌊(i + j) / 2⌋</span><br><span class="line">    t[k] = spawn P-SCAN-UP&#x27;(s, t, i, k)</span><br><span class="line">    right = P-SCAN-UP&#x27;(s, t, k + 1, j)</span><br><span class="line">    sync</span><br><span class="line">    return t[k] + right</span><br><span class="line"></span><br><span class="line">P-SCAN-DOWN&#x27;(v, s, t, y, i, j)</span><br><span class="line">  if i == j</span><br><span class="line">    y[i] = v + x[i]</span><br><span class="line">    return y[i]</span><br><span class="line">  else</span><br><span class="line">    k = ⌊(i + j) / 2⌋</span><br><span class="line">    l = spawn P-SCAN-DOWN (v, x, t, y, i, k)</span><br><span class="line">    r = P-SCAN-DOWN(v + t[k], x, t, y, k + 1, j)</span><br><span class="line">    sync</span><br><span class="line">    return min&#123;l, r&#125;</span><br></pre></td></tr></table></figure><p>改造后的程序还返回了前缀和数组中的最小值。</p><h1 id="section-4">26-5</h1><h2 id="a-4">a</h2><p>不失一般性，这里假设矩阵<span class="math inline">\(A\)</span>的大小<span class="math inline">\(n\)</span>是<span class="math inline">\(2\)</span>的幂次。基于等式26.9，那么对矩阵<span class="math inline">\(A\)</span>的填充并行分治算法由<code>SIMPLE-STENCIL</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SIMPLE-STENCIL(A, n)</span><br><span class="line">  if n == 1</span><br><span class="line">    generate the value of a11</span><br><span class="line">    return</span><br><span class="line">  partition A into n/2 × n/2 submatrices A11, A12, A21, A22; respectively</span><br><span class="line">  SIMPLE-STENCIL(A11, n / 2)</span><br><span class="line">  spawn SIMPLE-STENCIL(A12, n / 2)</span><br><span class="line">  spawn SIMPLE-STENCIL(A21, n / 2)</span><br><span class="line">  sync</span><br><span class="line">  SIMPLE-STENCIL(A22, n / 2)</span><br></pre></td></tr></table></figure><p>可见这个算法只是为了填充原来矩阵的所有元素，由其串行投影可以知道其工作量满足<span class="math inline">\(T_1(n)=4T_1(n/2)+\Theta(1)\)</span>，可以得到<span class="math inline">\(T_1(n)=\Theta(n^2)\)</span>。</p><p>这个算法的持续时间满足<span class="math inline">\(T_{\infty}(n)=3T_\infty(n/2)+\Theta(1)\)</span>，可以得到<span class="math inline">\(T_{\infty}(n)=\Theta(n^{\lg 3})\)</span>。</p><p>最终可以得到并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^{2-\lg3})\)</span>。</p><h2 id="b-4">b</h2><p>不失一般性，这里假设矩阵<span class="math inline">\(A\)</span>的大小<span class="math inline">\(n\)</span>是<span class="math inline">\(3\)</span>的幂次，那么按照题目26-5-a的结果，我们可以对<code>SIMPLE-STENCIL</code>修改成<code>SIMPLE-STENCIL3</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SIMPLE-STENCIL3(A, n)</span><br><span class="line">  if n == 1</span><br><span class="line">    generate the value of a11</span><br><span class="line">    return</span><br><span class="line">  partition A into n/3 × n/3 submatrices A11, A12, A13, A21, A22, A23, A31, A32, A33; respectively</span><br><span class="line">  SIMPLE-STENCIL3(A11, n / 3)</span><br><span class="line">  spawn SIMPLE-STENCIL3(A12, n / 3)</span><br><span class="line">  spawn SIMPLE-STENCIL3(A21, n / 3)</span><br><span class="line">  sync</span><br><span class="line">  spawn SIMPLE-STENCIL3(A13, n / 3)</span><br><span class="line">  spawn SIMPLE-STENCIL3(A22, n / 3)</span><br><span class="line">  spawn SIMPLE-STENCIL3(A31, n / 3)</span><br><span class="line">  sync</span><br><span class="line">  spawn SIMPLE-STENCIL3(A23, n / 3)</span><br><span class="line">  spawn SIMPLE-STENCIL3(A32, n / 3)</span><br><span class="line">  sync</span><br><span class="line">  SIMPLE-STENCIL3(A33, n / 3)</span><br></pre></td></tr></table></figure><p>和题目26-3-a分析的过程类似，可以知道其工作量满足<span class="math inline">\(T_1(n)=9T_1(n/3)+\Theta(1)\)</span>，可以得到<span class="math inline">\(T_1(n)=\Theta(n^2)\)</span>。</p><p>这个算法的持续时间满足<span class="math inline">\(T_{\infty}(n)=5T_\infty(n/3)+\Theta(1)\)</span>，可以得到<span class="math inline">\(T_{\infty}(n)=\Theta(n^{\log_3 5})\)</span>。</p><p>最终可以得到并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^{2-\log_35})\)</span>。</p><h2 id="c-4">c</h2><p>利用类似的方式修改题目26-5-a和26-5-b的代码，可以给出<code>SIMPLE-STENCIL-B</code>代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SIMPLE-STENCIL-B(A, n)</span><br><span class="line">  if n == 1</span><br><span class="line">    generate the value of a11</span><br><span class="line">    return</span><br><span class="line">  partition A into n/b × n/b submatrices A11, A12, ..., A1b, A21, A22, ..., A2b, ...,  Ab1, Ab2, ..., Abb; respectively</span><br><span class="line">  for k = 2 to b * b</span><br><span class="line">    //注意这里的parallel for 循环将是以硬编码的形式构造出来，因此后面的分析不会对Θ(lg n)这个因子进行考虑。</span><br><span class="line">    parallel for i = 1 to b</span><br><span class="line">      j = k - i</span><br><span class="line">      if 1 &lt;= j and j &lt;= b</span><br><span class="line">      SIMPLE-STENCIL3(Aij, n / b)</span><br></pre></td></tr></table></figure><p>和题目26-3-a和26-3-b分析的过程类似，可以知道其工作量满足<span class="math inline">\(T_1(n)=b^2T_1(n/b)+\Theta(1)\)</span>，可以得到<span class="math inline">\(T_1(n)=\Theta(n^2)\)</span>。</p><p>这个算法的持续时间满足<span class="math inline">\(T_{\infty}(n)=(2b-1)T_\infty(n/b)+\Theta(1)\)</span>，可以得到<span class="math inline">\(T_{\infty}(n)=\Theta(n^{\log_b(2b-1)})\)</span>。</p><p>最终可以得到并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^{2-\log_b(2b-1)})\)</span>。</p><p>为了证明<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^{2-\log_b(2b-1)})=o(n)\)</span>，那么需要证明<span class="math inline">\(f\forallb\ge 2\)</span>，都有<span class="math inline">\(2-\log_b(2b-1)&lt;1\)</span>，即证明<span class="math inline">\(\log_b(2b-1)&gt;1\)</span>。由于<span class="math inline">\(\forall b\ge 2\)</span>，都有<span class="math inline">\(2b-1&gt;b\)</span>，因此<span class="math inline">\(\log_b(2b-1)&gt;1\)</span>成立是很显然的。因此有<span class="math inline">\(T_1(n)/T_{\infty}(n)=o(n)\)</span>。</p><h2 id="d-2">d</h2><p>这个算法由<code>STENCIL</code>给出，并且它还能对更一般形式的矩阵进行填充。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">STENCIL(A, n)</span><br><span class="line">  for k = 2 to n + n - 1</span><br><span class="line">    up = max&#123;1, k - n&#125;</span><br><span class="line">    down = min&#123;n, k - 1&#125;</span><br><span class="line">    parallel for i = up to down</span><br><span class="line">      j = k - i</span><br><span class="line">      generate the value of aij</span><br></pre></td></tr></table></figure><p>可以知道<code>STENCIL</code>的工作量是<span class="math inline">\(T_1(n)=\Theta(n^2)\)</span>，因为它仅仅是从小到大枚举矩阵的每条副对角线，并按顺序填入一个个元素。</p><p>可以知道<code>STENCIL</code>的持续时间满足<span class="math inline">\(T_\infty(n)=n\cdot\Theta(\lg n)=\Theta(n\lgn)\)</span>。因为第<span class="math inline">\(k\)</span>轮迭代最多也只会进行<span class="math inline">\(n\)</span>次操作。如果去掉关键字<code>parallel</code>关键字并转化为<code>spawn ... sync</code>结构，那么这一部分需要花费<span class="math inline">\(\Theta(\lg n)\)</span>的时间。</p><p>因此，<code>STENCIL</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n/\lgn)\)</span>。</p><p>如果需要达到<span class="math inline">\(\Theta(n)\)</span>的并行度，那么可以将<code>parallel for</code>循环转化成硬编码形式，从而去掉这个<code>parallel for</code>循环，并且一次性在<span class="math inline">\(\Theta(1)\)</span>的时间内生产<span class="math inline">\(\Theta(n)\)</span>个元素，从而使并行度提升到<span class="math inline">\(\Theta(n)\)</span>。但是这里使用了<code>parallel for</code>循环，它是基于分治法实现的，因此达不到这个最大并行度。</p><h1 id="section-5">26-6</h1><h2 id="a-5">a</h2><p>工作量定律将改写成<span class="math inline">\(E[T_P]\geE[T_1]/P\)</span>；持续时间定律将改写成<span class="math inline">\(E[T_P]\geE[T_{\infty}]\)</span>；贪心调度界限改写成<span class="math inline">\(E[T_P]\le E[T_1]/P+E[T_{\infty}]\)</span>。</p><h2 id="b-5">b</h2><p>按照题目给出的数据，令<span class="math inline">\(P=10000\)</span>，那么可以写出以下三条式子：</p><p><span class="math inline">\(\begin{aligned} E[T_1]&amp;=10^4\cdot0.01+10^9\cdot 0.99\\ E[T_P]&amp;=1\cdot 0.01+10^9\cdot0.99\\E[T_1/T_P]&amp;=\dfrac{10^4}{1}\cdot0.01+\dfrac{10^9}{10^9}\cdot0.99\\\end{aligned}\)</span></p><p>从而得到<span class="math inline">\(E[T_1/T_P]\approx100,\dfrac{E[T_1]}{E[T_P]}\approx1\)</span>。</p><p>选用<span class="math inline">\(\dfrac{E[T_1]}{E[T_P]}\)</span>的原因有如下两个：</p><ol type="1"><li><p>由于在绝大多数时间中，无论是<span class="math inline">\(P=1\)</span>还是<span class="math inline">\(P=10000\)</span>，其运行时间大多数都在<span class="math inline">\(10^9\)</span>，因此说明这个添加到<span class="math inline">\(P=10000\)</span>的操作应该对加速作用不大，因此选用<span class="math inline">\(\dfrac{E[T_1]}{E[T_P]}\)</span>是一个比较恰当的值。</p></li><li><p><span class="math inline">\(T_1/T_P\)</span>这个随机变量并不成立。题目中没有提到<span class="math inline">\(T_1=10^4\)</span>和<span class="math inline">\(T_1=10^9\)</span>的时机是否和<span class="math inline">\(T_P=1\)</span>和<span class="math inline">\(T_P=10^9\)</span>的时机相同。也就是说，它们不一定是相关的。因此采用独立计算更加合适，即选用<span class="math inline">\(\dfrac{E[T_1]}{E[T_P]}\)</span>。</p></li></ol><h2 id="c-5">c</h2><p>当<span class="math inline">\(P\)</span>趋于无穷时，期望的加速比应该和并行度相等。这和题目26-6-b使用的定义是一致的。</p><h2 id="d-3">d</h2><p>我们可以对第7.3章提到的<code>RANDOMIZED-QUICKSORT</code>算法提出其并行化版本<code>P-RANDOMIZED-QUICKSORT</code>（按照题目要求，不对<code>RANDOMIZED-PARTITION</code>并行化）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">P-RANDOMIZED-QUICKSORT(A, p, r)</span><br><span class="line">  if p &lt; r:</span><br><span class="line">    q = RANDOMIZED-PARTITION(A, p, r)</span><br><span class="line">    spawn P-RANDOMIZED-QUICKSORT(A, p, q - 1)</span><br><span class="line">    spawn P-RANDOMIZED-QUICKSORT(A, q + 1, r)</span><br><span class="line">    sync</span><br></pre></td></tr></table></figure><h2 id="e-1">e</h2><p>可见，<code>P-RANDOMIZED-QUICKSORT</code>的串行投影为<code>RANDOMIZED-QUICKSORT</code>，因此其期望工作量<span class="math inline">\(E[T_1(n)]=O(n\lg n)\)</span>。</p><p>对于<code>P-RANDOMIZED-QUICKSORT</code>持续时间，考虑将<code>P-RANDOMIZED-QUICKSORT</code>和<code>RANDOMIZED-SELECT</code>的行为进行对比。<code>P-RANDOMIZED-QUICKSORT</code>的<code>RANDOMIZED-PARTITION</code>和<code>RANDOMIZED-SELECT</code>中的一样，这部分都是占据了主导的时间<span class="math inline">\(\Theta(n)\)</span>。因此，对其划分的推导也和第9.2章给的完全一样。接下来考虑其递归部分。可以发现，<code>P-RANDOMIZED-QUICKSORT</code>的阶段划分和<code>RANDOMIZED-SELECT</code>也相同，并且证明过程同样也考虑了那个执行时间比较长的执行分支。因此对<code>P-RANDOMIZED-QUICKSORT</code>持续时间<span class="math inline">\(T_{\infty}(n)\)</span>的分析过程和<code>RANDOMIZED-SELECT</code>的分析过程完全一致。按照定理9.2的结论，我们得到<span class="math inline">\(T_{\infty}(n)=\Theta(n)\)</span>。</p><p>因此，<code>P-RANDOMIZED-QUICKSORT</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=O(\lg n)\)</span>。</p><h2 id="f-1">f</h2><p><code>RANDOMIZED-SELECT</code>的并行化版本由<code>P-RANDOMIZED-SELECT</code>给出。其中，给定的<code>P-RANDOMIZED-PARTITION</code>由题目26.3-3的<code>P-PARTITION</code>实现而来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">P-RANDOMIZED-PARTITION(A, p, r)</span><br><span class="line">  i = RANDOM(p, r)</span><br><span class="line">  exchange A[r] with A[i]</span><br><span class="line">  return P-PARTITION(A, p, r)</span><br><span class="line"></span><br><span class="line">P-RANDOMIZED-SELECT(A, p, r, i)</span><br><span class="line">  if p == r</span><br><span class="line">    return A[p]</span><br><span class="line">  q = P-RANDOMIZED-PARTITION(A, p, r)</span><br><span class="line">  k = q – p + 1</span><br><span class="line">  if i == k</span><br><span class="line">    return A[q]</span><br><span class="line">  else if i &lt; k</span><br><span class="line">    return P-RANDOMIZED-SELECT(A, p, q – 1, i)</span><br><span class="line">  else </span><br><span class="line">    return P-RANDOMIZED-SELECT(A, q + 1, r, i – k)</span><br></pre></td></tr></table></figure><p>可见这个算法的串行投影为<code>RANDOMIZED-SELECT</code>，因此它的工作量为<span class="math inline">\(T_1(n)=\Theta(n)\)</span>。</p><p>令示性遍历<span class="math inline">\(X_k\)</span>表示<code>P-RANDOMIZED-PARTITION</code>划分出来后的元素在于位置<span class="math inline">\(k\)</span>。那么由于程序的其余部分都需要<span class="math inline">\(\Theta(\lgn)\)</span>完成（根据题目26.3-3的结论，这里的主要开销就在于<code>P-RANDOMIZED-PARTITION</code>需要花费<span class="math inline">\(\Theta(\lgn)\)</span>的时间），因此可以对随机变量<span class="math inline">\(T_{\infty}(n)\)</span>可以写出如下递推式：</p><p><span class="math display">\[T_{\infty}(n)=\sum_{i=1}^n X_k\cdotT_{\infty}(\max\{k-1,n-k\})+\Theta(\lg n)\]</span></p><p>可见<span class="math inline">\(E[X_k]=\dfrac{1}{n}\)</span>，因为每个位置都有可能被选到。那么对式子左右两侧取期望值，那么有</p><p><span class="math inline">\(\begin{aligned}E[T_{\infty}(n)]&amp;=\sum_{k=1}^n E[X_k]\cdotE[T_{\infty}(\max\{k-1,n-k\})]+\Theta(\lg n)\\&amp;\le\dfrac{2}{n}\sum_{k=\lfloor n/2\rfloor}^{n-1}E[T_{\infty}(k)]+\Theta(\lg n)\\ \end{aligned}\)</span></p><p>接下来使用代入法证明<span class="math inline">\(E[T_{\infty}(n)]=O(n^d)\)</span>，即<span class="math inline">\(\exists c,n_0&gt;0,d\in(0,1)\)</span>，使得<span class="math inline">\(\forall n\ge n_0\)</span>，都有<span class="math inline">\(E[T_{\infty}(n)]\le c\cdotn^{d}\)</span>。那么就可以得到</p><p><span class="math inline">\(\begin{aligned}E[T_{\infty}(n)]&amp;\le\dfrac{2}{n}\sum_{k=\lfloor n/2\rfloor}^{n-1}E[T_{\infty}(k)]+\Theta(\lg n)\\ &amp;\le\dfrac{2}{n}\sum_{k=\lfloorn/2\rfloor}^{n-1} c\cdot k^d+\Theta(\lg n)\\&amp;=\dfrac{2c}{n}\sum_{k=\lfloor n/2\rfloor}^{n-1} k^d+\Theta(\lg n)\\&amp;\le \dfrac{2c}{n}\int_{\lfloor n/2\rfloor}^n x^d dx+\Theta(\lg n)\\&amp;=\dfrac{2c}{n}\cdot\left.\dfrac{x^{d+1}}{d+1}\right|_{x=\lfloorn/2\rfloor}^n+\Theta(\lg n)\\ &amp;=c\cdot\dfrac{2-2^{-d}}{d+1}\cdot n^d+ \Theta(\lg n) \end{aligned}\)</span></p><p>考虑关于<span class="math inline">\(d\)</span>的一元一次不等式<span class="math inline">\(\dfrac{2-2^{-d}}{d+1}&lt;1\)</span>，可以得到<span class="math inline">\(d&gt;0\)</span>。</p><p>也就是说，无论<span class="math inline">\(d\)</span>取<span class="math inline">\((0,1)\)</span>中的什么值，只要第一个项中的<span class="math inline">\(c\)</span>足够大，它就可以覆盖到<span class="math inline">\(\Theta(\lg n)\)</span>中的常数，从而最终得到<span class="math inline">\(T_{\infty}(n)\)</span></p><p>因此，<span class="math inline">\(T_{\infty}(n)=o(n^d)\)</span>，其中<span class="math inline">\(d\)</span>是任意正数。</p><p>最终可以得到并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^{1-d})\)</span>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论26.3 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/26-3-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/26-3-Exercises/</id>
    <published>2023-10-01T11:28:01.000Z</published>
    <updated>2023-10-01T11:28:01.400Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">26.3-1</h1><p>基本思想是，只需要当前排序的数组长度小于等于某个很小的阈值<span class="math inline">\(K\)</span>，那么就选择使用原本串行的归并方式。否则使用当前优化过的归并方式，这个过程由<code>P-MERGE'</code>给出。其中<code>MEGRE'</code>和<code>MERGE</code>相比，表示将排序结果存储到<span class="math inline">\(B\)</span>中（而不是原本的<span class="math inline">\(A\)</span>中）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">P-MERGE&#x27;(A, p, q, r)</span><br><span class="line">  let B[p : r] be a new array             // allocate scratch array</span><br><span class="line">  if r - p &gt; M</span><br><span class="line">    P-MERGE-AUX(A, p, q, q + 1, r, B, p)  // merge from A into B</span><br><span class="line">  else</span><br><span class="line">    MERGE&#x27;(A, p, q, r, B)</span><br><span class="line">  parallel for i = p to r                 // copy B back to A in parallel</span><br><span class="line">    A[i] = B[i]</span><br></pre></td></tr></table></figure><h1 id="section-1">26.3-2</h1><p>通过对题目9.3-10给出的<code>MEDIAN3</code>进行改造，我们给出了一个程序<code>MEDIAN4</code>，它用于求解两个有序数组<span class="math inline">\(A[1:n],B[1:m]\)</span>中的中位数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 找出数组A[i : n], B[j : m]中的第k小数。</span><br><span class="line">SELECT4(A, i, n, B, j, m, k)</span><br><span class="line">  if i &gt; n</span><br><span class="line">    return B[j + k - 1]</span><br><span class="line">  else if j &gt; m</span><br><span class="line">    return A[j + k - 1]</span><br><span class="line">  else if k == 1</span><br><span class="line">    return min&#123;A[i], B[j]&#125;</span><br><span class="line">  if i + ⌊k/2⌋ - 1 &lt;= n</span><br><span class="line">    midl = A[i + ⌊k/2⌋ - 1]</span><br><span class="line">  else</span><br><span class="line">    midl = +∞</span><br><span class="line">  if j + ⌊k/2⌋ - 1 &lt;= m</span><br><span class="line">    midr = B[i + ⌊k/2⌋ - 1]</span><br><span class="line">  else</span><br><span class="line">    midr = +∞</span><br><span class="line">  if midl &lt; midr</span><br><span class="line">    return SELECT4(A, i + ⌊k/2⌋, n, B, j, m, k - ⌊k/2⌋, n)</span><br><span class="line">  else</span><br><span class="line">    return SELECT4(A, i, n, B, j + ⌊k/2⌋, m, k - ⌊k/2⌋, n)</span><br><span class="line"></span><br><span class="line">MEDIAN4(A, B, n, m)</span><br><span class="line">  return SELECT4(A, 1, n, B, 1, m, ⌊(n + m) / 2⌋)</span><br></pre></td></tr></table></figure><p>由此可以将<code>P-MERGE-AUX</code>修改成<code>P-MERGE-AUX'</code>，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">P-MERGE-AUX(A, p1, r1, p2, r2, B, p3)</span><br><span class="line">  if p1 &gt; r1 and p2 &gt; r2</span><br><span class="line">    return</span><br><span class="line">  if r1 − p1 &lt; r2 − p2</span><br><span class="line">    exchange p1 with p2</span><br><span class="line">    exchange r1 with r2</span><br><span class="line">  x = MEDIAN4(A[p1 : r1], B[p2 : r2], r1 - p1 + 1, r2 - p2 + 2)</span><br><span class="line">  q2 = FIND-SPLIT-POINT(A, p2, r2, x)</span><br><span class="line">  q3 = p3 + (q1 − p1) + (q2 − p2) </span><br><span class="line">  B[q3] = x</span><br><span class="line">  spawn P-MERGE-AUX(A, p1, q1 − 1, p2, q2 − 1, B, p3)</span><br><span class="line">  spawn P-MERGE-AUX(A, q1 + 1, r1, q2, r2, B, q3 + 1)</span><br><span class="line">  sync</span><br></pre></td></tr></table></figure><p>先求解<code>P-MERGE-AUX'</code>的工作量<span class="math inline">\(T_1(n)\)</span>。可见，由于每次都淘汰了数组中一半的元素，并且每一轮除了递归部分，只需要<span class="math inline">\(\Theta(\lg n)\)</span>的时间运行。因此有<span class="math inline">\(T_1(n)=2T_1(n/2)+\Theta(\lgn)\)</span>。根据主定理可以得到<span class="math inline">\(T_1(n)=\Theta(n)\)</span>。</p><p>接下来求解<code>P-MERGE-AUX'</code>的持续时间<span class="math inline">\(T_{\infty}(n)\)</span>。同样的，我们得到<span class="math inline">\(T_\infty(n)=T_\infty(n/2)+\Theta(\lgn)\)</span>。从而得到<span class="math inline">\(T_{\infty}(n)=\Theta(\lg^2n)\)</span>。</p><p>由于<code>P-MERGE-AUX'</code>的工作量和持续时间都不变，因此得到的<code>P-MERGE'</code>得到的工作量和持续时间和第26.3章分析的一样，分别为<span class="math inline">\(\Theta(n)\)</span>和<span class="math inline">\(\Theta(\lg^2n)\)</span>。因此其并行量仍然为<span class="math inline">\(\Theta(n/\lg^2 n)\)</span>。</p><h1 id="section-2">26.3-3</h1><p><code>PARTITION</code>的并行化版本<code>P-PARTITION</code>如下展示。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// 令T[p, r]表示一棵二叉树T存储了区间[p, r]内所有数的相关信息，包括：</span><br><span class="line">// small：A[p, r]中小于等于x的数的个数。</span><br><span class="line">// large：[p, r]中大于x的数的个数。</span><br><span class="line">P-PARTITION-CAL(A, p, r, x)</span><br><span class="line">  if p == r</span><br><span class="line">    if A[p] &lt;= x</span><br><span class="line">      T[p, r].small = 1</span><br><span class="line">      T[p, r].large = 0</span><br><span class="line">      return (1, 0)</span><br><span class="line">    else</span><br><span class="line">      T[p, r].small = 0</span><br><span class="line">      T[p, r].large = 1</span><br><span class="line">      return (0, 1)</span><br><span class="line">  else</span><br><span class="line">    mid = ⌊(p + r) / 2⌋</span><br><span class="line">    cl-small, cl-large = spawn P-PARTITION-CAL(A, p, mid, x)</span><br><span class="line">    cr-small, cr-large = spawn P-PARTITION-CAL(A, mid + 1, q, x)</span><br><span class="line">    sync</span><br><span class="line">    T[p, r].small = cl-small + cr-small</span><br><span class="line">    T[p, r].large = cl-large + cr-large</span><br><span class="line">    return (T[p, r].small, T[p, r].large)</span><br><span class="line"></span><br><span class="line">P-PARTITION-FILL(A, p, r, x, B, ls, rs, ll, rl)</span><br><span class="line">  if p == r:</span><br><span class="line">    if A[p] &lt;= x</span><br><span class="line">      B[ls] = A[p]</span><br><span class="line">    else</span><br><span class="line">      B[ll] = A[p]</span><br><span class="line">  else</span><br><span class="line">    mid = ⌊(p + r) / 2⌋</span><br><span class="line">    spawn P-PARTITION-FILL(A, p, mid, x, B, ls, ls + T[p, mid].small - 1, ll, ll + T[p, mid].large + 1)</span><br><span class="line">    spawn P-PARTITION-FILL(A, p, mid, x, B, rs - T[mid + 1, r].small + 1, rs, rl - T[mid + 1, r].large + 1, rl)</span><br><span class="line">    sync</span><br><span class="line"></span><br><span class="line">P-PARTITION(A, p, r)</span><br><span class="line">  if p == r</span><br><span class="line">    return p</span><br><span class="line">  x = A[r]</span><br><span class="line">  c-small, c-large = P-PARTITION-CAL(A, p, r - 1, x)</span><br><span class="line">  let B[p : r] be a new array</span><br><span class="line">  q = p + c-small</span><br><span class="line">  B[q] = x</span><br><span class="line">  P-PARTION-FILL(A, p, r, x, B, p, p + c-small - 1, r - c-large + 1, r)</span><br><span class="line">  parallel for i = p to r</span><br><span class="line">    A[i] = B[i]</span><br><span class="line">  return q</span><br></pre></td></tr></table></figure></p><p>我们可以首先并行化地构筑出一棵二叉树<span class="math inline">\(T\)</span>，其中<span class="math inline">\(T[l,r]\)</span>存储区间<span class="math inline">\([l,r]\)</span>内的信息：小于等于<span class="math inline">\(x\)</span>的元素个数和大于<span class="math inline">\(x\)</span>的元素个数。我们可以知道这棵树的节点数为<span class="math inline">\(\displaystyle{\sum_{i=0}^{\infty}\left\lceil\dfrac{n}{2^i}\right\rceil}=\Theta(n)\)</span>。</p><p>因此，第一趟遍历首先是将这棵树的所有节点信息先处理出来（如<code>P-PARTITION-CAL</code>所示），由于这棵树一共有<span class="math inline">\(\Theta(n)\)</span>个节点，其深度为<span class="math inline">\(\Theta(\lgn)\)</span>，因此这一部分的工作量为<span class="math inline">\(\Theta(n)\)</span>，持续时间为<span class="math inline">\(\Theta(\lg n)\)</span>。</p><p>第二趟遍历则是按照树给定的信息，自底向上地将所有元素填入新数组<span class="math inline">\(B\)</span>中（如<code>P-PARTITION-FILL</code>所示）。这一部分的分析和第一趟类似，这一部分的工作量为<span class="math inline">\(\Theta(n)\)</span>，持续时间为<span class="math inline">\(\Theta(\lg n)\)</span>。</p><p>第三趟遍历则是将<span class="math inline">\(B\)</span>数组并行地填入<span class="math inline">\(A\)</span>中对应位置，因此这一部分的工作量为<span class="math inline">\(\Theta(n)\)</span>，持续时间为<span class="math inline">\(\Theta(\lg n)\)</span>。</p><p>也就是说，<code>P-PARTITION</code>的工作量<span class="math inline">\(T_1(n)\)</span>满足<span class="math inline">\(T_1(n)=2T_1(n/2)+\Theta(1)\)</span>，即得到<span class="math inline">\(T_1(n)=\Theta(n)\)</span>。其工作时间<span class="math inline">\(T_{\infty}(n)\)</span>满足<span class="math inline">\(T_\infty(n)=T_{\infty}(n/2)+\Theta(1)=\Theta(\lgn)\)</span>。因此其并行度为<span class="math inline">\(\Theta(n/\lgn)\)</span>。</p><h1 id="section-3">26.3-4</h1><p>给出的<code>FFT</code>的并行版本<code>P-FFT</code>如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FFT(a, n)</span><br><span class="line">  if n == 1</span><br><span class="line">    return a</span><br><span class="line">  let a-even_&#123;0 : n / 2 - 1&#125;, a-odd_&#123;0 : n / 2 - 1&#125; be new arrays</span><br><span class="line">  parallel for k = 0 to n / 2 - 1</span><br><span class="line">    a-even_&#123;k&#125; = a_&#123;k * 2&#125;</span><br><span class="line">    a_odd_&#123;k&#125; = a_&#123;k * 2 + 1&#125;</span><br><span class="line">  y-even = spawn FFT(a-even, n / 2)</span><br><span class="line">  y-odd = spawn FFT(a-odd, n / 2)</span><br><span class="line">  sync</span><br><span class="line">  parallel for k = 0 to n / 2 - 1</span><br><span class="line">    ω = exp(2 * π * i * k / n)</span><br><span class="line">    y_k = y-even_&#123;k&#125; + ω * y-odd_&#123;k&#125;</span><br><span class="line">    y_&#123;k + n / 2&#125; = y-even_&#123;k&#125; - ω * y-odd_&#123;k&#125;</span><br><span class="line">  return y</span><br></pre></td></tr></table></figure><p><code>P-FFT</code>和其串行投影<code>FFT</code>的区别在于：将<span class="math inline">\(a\)</span>向量进行奇偶划分的过程可以并行完成。其次，<span class="math inline">\(y^{even},y^{odd}\)</span>的计算也是同时派生出两个子线程再进行合并。此外，<span class="math inline">\(\omega_n^k\)</span>的值不能够递推计算，它只能以<span class="math inline">\((\omega_n)^k\)</span>的方式进行计算。</p><p>可见其串行投影为普通的<code>FFT</code>，因此其工作量为<span class="math inline">\(T_1(n)=\Theta(n\lg n)\)</span>。</p><p>每次递归，它都会将两个大小恰好为一半的两个子问题进行递归计算，其余部分只需要<span class="math inline">\(\Theta(\lgn)\)</span>的时间就能够完成好（如两次次<code>parallel for</code>循环以及<span class="math inline">\(\omega_n^k\)</span>的计算），因此其持续时间满足<span class="math inline">\(T_{\infty}(n)=T_{\infty}(n/2)+\Theta(\lgn)\)</span>，最终得到<span class="math inline">\(T_{\infty}(n)=\Theta(\lg^2n)\)</span>。</p><p>因此，<code>P-FFT</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n/\lgn)\)</span>。</p><h1 id="star-26.3-5"><span class="math inline">\(\star\)</span>26.3-5</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">P-SELECT(A, p, r, i)</span><br><span class="line">  g = ⌊(r – p + 1) / 5⌋</span><br><span class="line">  f = (r - p + 1) % 5</span><br><span class="line">  parallel for j = p to p + g – 1</span><br><span class="line">    sort〈A[j], A[j + g], A[j + 2 * g], A[j + 3 * g], A[j + 4 * g]〉in place</span><br><span class="line">  for j = 0 to t - 1</span><br><span class="line">    exchange A[p + 3 * g + j] with A[p + 5 * g + j] </span><br><span class="line">  x = P-SELECT(A, p + 2 * g, p + 3 * g + f – 1, ⌈(g + f) /2⌉)</span><br><span class="line">  q = P-PARTITION-AROUND(A, p, r, x)</span><br><span class="line">  k = q – p + 1</span><br><span class="line">  if i == k</span><br><span class="line">    return A[q]</span><br><span class="line">  else if i &lt; k</span><br><span class="line">    return P-SELECT(A, p, q – 1, i)</span><br><span class="line">  else </span><br><span class="line">    return P-SELECT(A, q + 1, r, i – k)</span><br></pre></td></tr></table></figure><p>修改后得到的<code>P-SELECT</code>算法如上。相比于<code>SELECT</code>，<code>P-SELECT</code>将未满一个组的五个元素进行了延后处理。此外，套用题目26.3-3的结论，<code>P-PARTITION-AROUND</code>可以由<code>PARTITION-AROUND</code>转化而来。其余部分只需要<span class="math inline">\(\Theta(\lg n)\)</span>的时间即可完成。</p><p>因此，<code>P-SELECT</code>的工作量<span class="math inline">\(T_1(n)\)</span>和<code>SELECT</code>的运行时间一样，为<span class="math inline">\(\Theta(n)\)</span>。</p><p><code>P-SELECT</code>的持续时间<span class="math inline">\(T_{\infty}(n)\)</span>可以由<span class="math inline">\(T_{\infty}(n)\leT_{\infty}(n/5)+T_{\infty}(7n/10)+\Theta(\lgn)\)</span>给出。这里可以考虑使用第4.7章介绍的Akra-Bazzi方法进行求解。</p><p>令<span class="math inline">\(c_1=\dfrac{1}{5},c_2=\dfrac{7}{10}\)</span>，构造关于未知数<span class="math inline">\(p\)</span>的方程<span class="math inline">\(c_1^p+c_2^p=1\)</span>，可以得到<span class="math inline">\(p\approx0.84\)</span>。因此，使用等式4.23，可以得到</p><p><span class="math inline">\(\begin{aligned}T_{\infty}(n)&amp;=\Theta\left(n^p\left(1+\int_{1}^n\dfrac{f(x)}{x^{p+1}}dx\right)\right) \\&amp;=\Theta\left(n^p\left(1+\int_{1}^n \dfrac{\lgx}{x^{p+1}}dx\right)\right) \\&amp;=\Theta\left(n^p\left(1+\left(\dfrac{1-n^{-p}(1+p\ln n)}{p^2\ln2}\right)\right)\right) \\ &amp;=\Theta(n^p) \end{aligned}\)</span></p><p>因此，<code>P-SELECT</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^{1-p})\approx\Theta(n^{0.16})\)</span>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论26.2 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/26-2-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/26-2-Exercises/</id>
    <published>2023-10-01T11:27:58.000Z</published>
    <updated>2023-10-01T11:27:58.941Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">26.2-1</h1><p>使用<code>P-MATRIX-MULTIPLY</code>计算<span class="math inline">\(2\times 2\)</span>矩阵的轨迹如下图所示：</p><p><img data-src="26.2-1.png"></p><p>可见，图中有<span class="math inline">\(13\)</span>个节点，因此其工作量为<span class="math inline">\(13\)</span>。此外，粗线表示这个有向无环图的最长链，其一共有<span class="math inline">\(6\)</span>个节点，因此其持续时间为<span class="math inline">\(6\)</span>，最终我们得到并行度为<span class="math inline">\(\dfrac{13}{6}\)</span>。</p><h1 id="section-1">26.2-2</h1><p>使用<code>P-MATRIX-MULTIPLY-RECURSIVE</code>计算<span class="math inline">\(2\times 2\)</span>矩阵的轨迹如下图所示：</p><p><img data-src="26.2-2.png"></p><p>可见，图中有<span class="math inline">\(42\)</span>个节点，因此其工作量为<span class="math inline">\(42\)</span>。此外，粗线表示这个有向无环图的最长链，其一共有<span class="math inline">\(23\)</span>个节点，因此其持续时间为<span class="math inline">\(23\)</span>，最终我们得到并行度为<span class="math inline">\(\dfrac{42}{23}\)</span>。</p><h1 id="section-2">26.2-3</h1><p>对<code>P-MATRIX-MULTIPLY</code>修改后，由<code>P-MATRIX-MULTIPLY'</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, k, k&#x27;)</span><br><span class="line">  if k == k&#x27;</span><br><span class="line">    return a_&#123;ik&#125; * b_&#123;kj&#125;</span><br><span class="line">  else</span><br><span class="line">    mid = ⌊(k + k&#x27;) / 2⌋</span><br><span class="line">    l = spawn P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, k, mid)</span><br><span class="line">    r = P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, mid, k&#x27;)</span><br><span class="line">    sync</span><br><span class="line">    return l + r</span><br><span class="line"></span><br><span class="line">P-MATRIX-MULTIPLY&#x27;(A, B, C, n)</span><br><span class="line">  parallel for i = 1 to n</span><br><span class="line">    parallel for j = 1 to n</span><br><span class="line">      C_&#123;ij&#125; = P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, 1, n)</span><br></pre></td></tr></table></figure><p>可以知道其工作量为<span class="math inline">\(T_1(n)=\Theta(n^3)\)</span>。</p><p>对程序<code>P-MATRIX-MULTIPLY-AUX'</code>的分析和对题目26.1-7中对<code>P-MAT-VEC-RECURSIVE-AUX'</code>的分析完全一致。因此，假设<span class="math inline">\(iter_n(i,j)\)</span>表示外层循环为<span class="math inline">\(i\)</span>，内层循环为<span class="math inline">\(j\)</span>时的运行时间，那么有<span class="math inline">\(iter_n(i,j)=O(\lg n)\)</span>。</p><p>由于<code>P-MATRIX-MULTIPLY'</code>首先沿着<code>parallel for</code>循环<span class="math inline">\(i\)</span>的递归树的路径向下，然后沿着内层循环<code>parallel for</code>循环<span class="math inline">\(j\)</span>的递归树的路径向下，因此这个算法的持续时间为<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)+\Theta(\lgn)+\max\{iter_n(i,j):1\le i,j\le n\}=\Theta(\lg n)\)</span>。</p><p>因此并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^3/\lgn)\)</span>。</p><h1 id="section-3">26.2-4</h1><p>考虑对题目26.2-3的代码<code>P-MATRIX-MULTIPLY'</code>进行修改，最终由<code>P-MATRIX-MULTIPLY''</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">P-MATRIX-MULTIPLY-AUX&#x27;&#x27;(A, B, i, j, k, k&#x27;)</span><br><span class="line">  if k == k&#x27;</span><br><span class="line">    return a_&#123;ik&#125; * b_&#123;kj&#125;</span><br><span class="line">  else</span><br><span class="line">    mid = ⌊(k + k&#x27;) / 2⌋</span><br><span class="line">    l = spawn P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, k, mid)</span><br><span class="line">    r = P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, mid, k&#x27;)</span><br><span class="line">    sync</span><br><span class="line">    return l + r</span><br><span class="line"></span><br><span class="line">P-MATRIX-MULTIPLY&#x27;&#x27;(A, B, C, p, q, r)</span><br><span class="line">  parallel for i = 1 to p</span><br><span class="line">    parallel for j = 1 to r</span><br><span class="line">      C_&#123;ij&#125; = P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, 1, q)</span><br></pre></td></tr></table></figure><p>使用和题目26.2-3一样的分析方式，我们可以知道这个算法的工作量为<span class="math inline">\(T_1(n)=\Theta(pqr)\)</span>。</p><p>如果假设<span class="math inline">\(iter_n(i,j)\)</span>表示外层循环为<span class="math inline">\(i\)</span>，内层循环为<span class="math inline">\(j\)</span>时的运行时间，那么有<span class="math inline">\(iter_n(i,j)=O(\lgq)\)</span>。那么这个算法的持续时间为<span class="math inline">\(T_{\infty}(n)=\Theta(\lg p)+\Theta(\lgr)+\max\{iter_n(i,j):1\le i\le p,1\le j\le r\}=\Theta(\lg(pqr))\)</span>。</p><p>因此并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(pqr/\lg(pqr))\)</span>。</p><h1 id="section-4">26.2-5</h1><p>修改后的可并行化的Floyd-Warshall算法由<code>P-FLOYD-WARSHALL'</code>给出（使用题目23.2-4的Floyd-Warshall算法伪代码<code>FLOYD-WARSHALL'</code>进行修改）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">P-FLOYD-WARSHALL&#x27;(W, n)</span><br><span class="line">  D = W</span><br><span class="line">  for k = 1 to n</span><br><span class="line">    parallel for i = 1 to n</span><br><span class="line">      parallel for j = 1 to n</span><br><span class="line">        d_&#123;ij&#125; = min &#123;d_&#123;ij&#125;, d_&#123;ik&#125; + d_&#123;kj&#125; &#125;</span><br><span class="line">6 return D</span><br></pre></td></tr></table></figure><p>首先说明一下这样修改的正确性。可见，在第<span class="math inline">\(k\)</span>轮循环中，<code>P-FLOYD-WARSHALL'</code>的第5行只会使用<span class="math inline">\(D\)</span>的第<span class="math inline">\(k\)</span>行和第<span class="math inline">\(k\)</span>列中的元素进行读取，并对其它元素进行修改。由于原来的图是一个非负边权的图，因此哪怕对<span class="math inline">\(d_{ik},d_{kj}\)</span>这样的元素进行更新，也不会对原本的值进行改变。因此。这个算法通过如此并行化完成是正确的。</p><p>这个程序的串行投影需要花费<span class="math inline">\(\Theta(n^3)\)</span>的时间完成，因此其工作量为<span class="math inline">\(T_1(n)=\Theta(n^3)\)</span>。</p><p>接下来求解持续时间<span class="math inline">\(T_{\infty}(n)\)</span>。假设<span class="math inline">\(iter_n(i,j)\)</span>表示外层<code>parallel for</code>循环为<span class="math inline">\(i\)</span>，内层<code>parallel for</code>循环为<span class="math inline">\(j\)</span>时的运行时间，那么有<span class="math inline">\(iter_n(i,j)=O(1)\)</span>，因为接下来只有一个较小值更新操作和加法操作。将两层循环中的<code>parallel</code>关键字转化为<code>spawn ... sync</code>结构后，那么可以得知<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)+\Theta(\lgn)+\max\{iter_n(i,j):1\le i,j\le n\}=\Theta(\lgn)\)</span>。由于这个两层<code>parallel for</code>循环需要串行地执行<span class="math inline">\(k\)</span>次，因此我们可以求出<span class="math inline">\(T_{\infty}(n)=n\cdot \Theta(\lg n)=\Theta(n\lgn)\)</span>。</p><p>最终并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^3/(n\lgn))=\Theta(n^2/\lg n)\)</span>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论26.1 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/26-1-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/26-1-Exercises/</id>
    <published>2023-10-01T11:27:56.000Z</published>
    <updated>2023-10-01T11:27:56.423Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">26.1-1</h1><p>一个串行算法的运行轨迹是看起来是一个单链表。相比于图26.2和图26.4所展示的运行轨迹，每个节点最多只有一条入边和一条出边。</p><h1 id="section-1">26.1-2</h1><p>相比于原来，现在<code>P-FIB</code>变成了<code>P-FIB'</code>，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">P-FIB&#x27;(n)</span><br><span class="line">  if n &lt;= 1</span><br><span class="line">    return n</span><br><span class="line">  else </span><br><span class="line">    x = spawn P-FIB&#x27;(n − 1)</span><br><span class="line">    y = spawn P-FIB&#x27;(n − 2)</span><br><span class="line">    sync</span><br><span class="line">    return x + y</span><br></pre></td></tr></table></figure><p>与原来的区别在于，父线程一进入<code>else</code>就被挂起，并且产生了两个子线程来求解<code>P-FIB'(n − 1)</code>和<code>P-FIB'(n − 2)</code>，父线程会一直等待，直到这两个线程完成执行，最终才返回计算结果。</p><p>因此，除了增加了一些线程本身的空间占用，这种做法并不会产生任何的改进，因此其渐进工作量<span class="math inline">\(T_1&#39;\)</span>仍然为<span class="math inline">\(\Theta(\phi^n)\)</span>，其持续时间仍然是<span class="math inline">\(T_{\infty}&#39;=\Theta(n)\)</span>，并行度为<span class="math inline">\(T_1&#39;/T_{\infty}&#39;=\Theta(\phi^n/n)\)</span>。</p><h1 id="section-2">26.1-3</h1><p>如下图所示，为<code>P-FIB(5)</code>的计算有向无环图。可见，图中有<span class="math inline">\(29\)</span>个节点，因此其工作量为<span class="math inline">\(29\)</span>。此外，粗线表示这个有向无环图的最长链，其一共有<span class="math inline">\(10\)</span>个节点，因此其持续时间为<span class="math inline">\(10\)</span>，最终我们得到并行度为<span class="math inline">\(2.9\)</span>。</p><p><img data-src="26.1-3.png"></p><h1 id="section-3">26.1-4</h1><p>假设这些时间步中，一共有<span class="math inline">\(x\)</span>个非完全步，一共有<span class="math inline">\(y\)</span>个完全步。那么必定有<span class="math inline">\(y\le\lfloor(T_1 -x)/P\rfloor\)</span>。我们通过反证法来证明这个不等式是成立的。</p><p>由于每个非完全步至少有<span class="math inline">\(1\)</span>的工作量，因此至多只有<span class="math inline">\(T_1-x\)</span>的工作量在完全步完成，也就是说，有<span class="math inline">\(Py\le T_1-x\)</span>。假设<span class="math inline">\(y&gt;\lfloor(T_1 -x)/P\rfloor\)</span>，那么有</p><p><span class="math inline">\(\begin{aligned} Py&amp;\geP\cdot(\lfloor(T_1 - x)/P\rfloor+1)\\ &amp;=P\cdot\lfloor(T_1 -x)/P\rfloor+P\\ &amp;=P\cdot\left(\dfrac{T_1-x}{P}-((T_1-x)\bmodP)\right) + P\\ &amp;=T_1-x+P-((T_1-x)\bmod P)\\ &amp;&gt;T_1-x\end{aligned}\)</span></p><p>这和<span class="math inline">\(Py\le T_1-x\)</span>矛盾，因此有<span class="math inline">\(y\le\lfloor(T_1 - x)/P\rfloor\)</span>。</p><p>那么有<span class="math inline">\(T_p=x+y\le x+\lfloor(T_1 -x)/P\rfloor\)</span>。由于<span class="math inline">\(x\leT_\infty\)</span>，即<span class="math inline">\(x\)</span>是所有时间步的一个子集，因此有</p><p><span class="math inline">\(\begin{aligned} T_p&amp;\le x+\lfloor(T_1- x)/P\rfloor\\ &amp;\le x+(T_1 - x)/P\\ &amp;\le T_\infty+(T_1 -T_\infty)/P\\ \end{aligned}\)</span></p><p>原结论成立。</p><h1 id="section-4">26.1-5</h1><p><img data-src="26.1-5.png"></p><p>假设现在有<span class="math inline">\(k\)</span>个处理器，<span class="math inline">\(k+1\)</span>个任务，其中每个串行任务内部一共有<span class="math inline">\(m\)</span>个节点。那么左图是贪心调度器的一种调度，接下来的<span class="math inline">\(m\)</span>个时间步它先完成<span class="math inline">\(k\)</span>个任务的串行节点，然后再花费<span class="math inline">\(m\)</span>个时间步进行剩下的那一个任务，在这种调度下，花费了<span class="math inline">\(2m+2\)</span>个时间步完成整个程序的运行（注意，这里加上了开始和结束的时间步）。如左图所示。</p><p>另一种调度则是，每次优先选择剩余时间最长的<span class="math inline">\(k\)</span>个任务运行一个时间步，直到完成所有任务为止。因此，这个过程总共需要<span class="math inline">\(\left\lceil\dfrac{(k+1)m}{k}\right\rceil+2=\left\lceilm+\dfrac{m}{k}\right\rceil+2\)</span>个时间步进行。如右图所示。</p><p>因此，有<span class="math inline">\(\displaystyle{\lim_{k\rightarrow+\infty}(2m+2)/\left(\left\lceilm+\dfrac{m}{k}\right\rceil+2\right)=2}\)</span>，这时第一种调度所花费的时间步是第二种调度的接近<span class="math inline">\(2\)</span>倍。</p><h1 id="section-5">26.1-6</h1><p>根据工作量定律，有<span class="math inline">\(T_1\le \min\{4\cdotT_4,10\cdot T_{10},64\cdot T_{64}\}\)</span>，从而得到<span class="math inline">\(T_1\le 320\)</span>。</p><p>根据持续时间定理，有<span class="math inline">\(T_\infty\le\min\{T_4,T_{10},T_{64}\}\)</span>，从而得到<span class="math inline">\(T_\infty\le 10\)</span>。</p><p>对<span class="math inline">\(T_{10}\)</span>对应的情况应用不等式26.5，那么有</p><p><span class="math inline">\(\begin{aligned} T_{10}&amp;\le\dfrac{T_1-T_\infty}{10}+T_\infty\\ &amp;\le \dfrac{T_1+9T_\infty}{10}\\&amp;\le 32+\dfrac{9T_\infty}{10} \end{aligned}\)</span></p><p>从而得到<span class="math inline">\(T_\infty&gt;\dfrac{100}{9}\)</span>，这和给出的<span class="math inline">\(T_{\infty}\le10\)</span>是矛盾的，因此这个教授是在撒谎。</p><h1 id="section-6">26.1-7</h1><p>可以将提供的<code>P-MAT-VEC-RECURSIVE</code>进行改造后，得到如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">P-MAT-VEC-RECURSIVE-AUX&#x27;(A, x, n, i, j, j&#x27;)</span><br><span class="line">  if j == j&#x27;</span><br><span class="line">    return a_&#123;i, j&#125; * x_j</span><br><span class="line">  else</span><br><span class="line">    mid = ⌊(j + j&#x27;) / 2⌋</span><br><span class="line">    l = spawn P-MAT-VEC-RECURSIVE-AUX&#x27;(A, x, n, i, j, mid)</span><br><span class="line">    r = P-MAT-VEC-RECURSIVE-AUX&#x27;(A, x, n, i, mid + 1, j&#x27;)</span><br><span class="line">    sync</span><br><span class="line">    return l + r</span><br><span class="line"></span><br><span class="line">P-MAT-VEC-RECURSIVE&#x27;(A, x, y, n)</span><br><span class="line">  parallel for i = 1 to n</span><br><span class="line">    y_i = P-MAT-VEC-RECURSIVE-AUX&#x27;(A, x, n, i, 1, n)</span><br></pre></td></tr></table></figure><p>其基本思想在于，对于<span class="math inline">\(A\)</span>的每一行都和<span class="math inline">\(x\)</span>独立相乘，得到一个值。然后，先计算这一行左半部分和<span class="math inline">\(x\)</span>的左半部分点积；右半部分和<span class="math inline">\(x\)</span>的左半部分点并行进行计算，最终将结果合并。</p><p>因此，<code>P-MAT-VEC-RECURSIVE'</code>的工作量为<span class="math inline">\(T_1(n)=\Theta(n^2)\)</span>，因为它仍然运行了<span class="math inline">\(n^2\)</span>次乘法运算。</p><p><code>P-MAT-VEC-RECURSIVE'</code>的持续时间<span class="math inline">\(T_{\infty}(n)\)</span>如下计算。由于<code>P-MAT-VEC-RECURSIVE'</code>中的每次循环都是独立的，因此令<span class="math inline">\(iter_{\infty}(n,i)\)</span>表示第<span class="math inline">\(i\)</span>次的循环结果，我们可以得到：</p><p><span class="math display">\[T_{\infty}(n)=\Theta(\lgn)+\max\{iter_{\infty}(n,i):1\le i\le n\}\]</span></p><p>对于每一次<code>P-MAT-VEC-RECURSIVE-AUX'</code>的调用，我们可以发现，每一次调用都将求和的范围减小，因此有<span class="math inline">\(iter_{\infty}(n,i)=iter_{\infty}(n/2,i)+\Theta(1)\)</span>。根据主定理，可以得到：</p><p><span class="math display">\[iter_{\infty}(n,i)=\Theta(\lgn)+\Theta(\lg n)\]</span></p><p>因此，我们最终得到<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)+\Theta(\lgn)=\Theta(\lg n)\)</span>。</p><p>最终我们得到这个算法的并行度为<span class="math inline">\(T_1(n)/T_\infty(n)=\Theta(n^2/\lgn)\)</span>。</p><h1 id="section-7">26.1-8</h1><p>可见，这个程序的串行投影需要花费<span class="math inline">\(\Theta(n^2)\)</span>的时间完成，因此其工作量为<span class="math inline">\(T_1(n)=\Theta(n^2)\)</span>。</p><p>接下来求解持续时间<span class="math inline">\(T_{\infty}(n)\)</span>。令<span class="math inline">\(iter_1(j)(2\le j\len)\)</span>表示其外层循环所需要的时间，<span class="math inline">\(iter_2(i)(1\le j&lt;n)\)</span>表示其内层循环所需要的时间。</p><p>如果将内层<code>for</code>循环的<code>parallel</code>关键字转化为<code>spawn ... sync</code>结构后，那么可以得知<span class="math inline">\(iter_1(i)=\Theta(\lg i)+\max\{iter_2(j):1\lej&lt;i\}\)</span>。可以知道，由于<span class="math inline">\(iter_2(j)=\Theta(1)\)</span>，因此有<span class="math inline">\(iter_1(i)=\Theta(\lg i)+\Theta(1)=\Theta(\lgi)\)</span>。</p><p>再将外层<code>for</code>循环的<code>parallel</code>关键字转化为<code>spawn ... sync</code>结构后，那么可以得知<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)+\max\{iter_1(i):2\lej\le n\}=\Theta(\lg n)+\Theta(\lg n)\)</span>。从而得到<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)\)</span>。</p><p>因此并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^2/\lgn)\)</span>。</p><h1 id="section-8">26.1-9</h1><p>也就是说，现在的程序转化为<code>P-TRANSPOSE'</code>，即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P-TRANSPOSE(A, n)</span><br><span class="line">  parallel for j = 2 to n</span><br><span class="line">    for i = 1 to j − 1</span><br><span class="line">      exchange a_&#123;ij&#125; with a_&#123;ji&#125;</span><br></pre></td></tr></table></figure><p>工作量和题目28.1-8的情况一样，为<span class="math inline">\(T_1(n)=\Theta(n^2)\)</span>。</p><p>接下来求解持续时间<span class="math inline">\(T_{\infty}(n)\)</span>。令<span class="math inline">\(iter(j)(2\le j\len)\)</span>表示其外层循环所需要的时间，由内层循环可以知道，<span class="math inline">\(iter(j)=\Theta(j)\)</span>。将外层<code>for</code>循环的<code>parallel</code>关键字转化为<code>spawn ... sync</code>结构后，那么可以得知<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)+\max\{iter(i):2\lej\le n\}=\Theta(\lg n)+\Theta(n)\)</span>。因此，我们最终得到<span class="math inline">\(T_{\infty}(n)=\Theta(\lgn)+\Theta(n)=\Theta(n)\)</span>。</p><p>因此并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^2/n)=\Theta(n)\)</span>。</p><h1 id="section-9">26.1-10</h1><p>相当于解如下关于未知数<span class="math inline">\(P,T_P,T_P&#39;\)</span>的方程组：</p><p><span class="math display">\[\left \{\begin{aligned}  &amp;T_P=\dfrac{T_1}{P}+T_\infty\\  &amp;T_P&#39;=\dfrac{T_1&#39;}{P}+T_\infty&#39;\\  &amp;T_P=T_P&#39;\\\end{aligned}\right.\]</span></p><p>其中<span class="math inline">\(T_1=2048,T_{\infty}=1,T_1&#39;=1024,T_{\infty}&#39;=8\)</span>，最终得到解：</p><p><span class="math display">\[\left \{\begin{aligned}  &amp;P=\dfrac{1024}{7}\\  &amp;T_P=15\\  &amp;T_P&#39;=15\\\end{aligned}\right.\]</span></p><p>也就是说，只需要约<span class="math inline">\(146\)</span>或者<span class="math inline">\(147\)</span>个处理器就能使这两个版本的算法运行时间相同。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
</feed>
