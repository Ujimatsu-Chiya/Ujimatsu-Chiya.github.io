<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ujimatsu Chiya</title>
  
  
  <link href="https://ujimatsu-chiya.github.io/atom.xml" rel="self"/>
  
  <link href="https://ujimatsu-chiya.github.io/"/>
  <updated>2023-10-04T06:40:13.149Z</updated>
  <id>https://ujimatsu-chiya.github.io/</id>
  
  <author>
    <name>Ujimatsu Chiya</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法导论29 Problems 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/29-Problems/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/29-Problems/</id>
    <published>2023-10-04T06:40:13.000Z</published>
    <updated>2023-10-04T06:40:13.149Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">29-1</h1><h2 id="a">a</h2><p>假设现在存在一个标准型线性规划的算法<code>LP-SOLVER-A(A, b, c)</code>（其中<span class="math inline">\(\mathbf{A,b}\)</span>表示约束，<span class="math inline">\(\mathbf{c}\)</span>表示目标函数对应的向量，最大化<span class="math inline">\(\mathbf{c}^T\mathbf{x}\)</span>的值），那么按照定理29.5，这个算法无非就返回<span class="math inline">\(3\)</span>种结果：</p><ol type="1"><li>一个达到最优目标值的向量<span class="math inline">\(\mathbf{x}\)</span>。</li><li><code>"unbounded"</code>，即无界。</li><li><code>"infeasible"</code>，即这个约束不可行。</li></ol><p>那么线性不等式可行性问题检测算法<code>LINEAR-INEQUALITY-FEASIBILITY</code>用于检测标准型线性不等式可行性，只需要调用<code>LP-SOLVER-A</code>作为子程序即可。更具体的过程如下给出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LINEAR-INEQUALITY-FEASIBILITY(A, b, m, n):</span><br><span class="line">  let c[1 : n] be a new array</span><br><span class="line">  sol = LP-SOLVE-A(A, b, c)</span><br><span class="line">  if sol != &quot;infeasible&quot;</span><br><span class="line">    return sol</span><br><span class="line">  return NIL</span><br></pre></td></tr></table></figure><p>这个过程用到的变量和约束的个数分是<span class="math inline">\(n,m\)</span>，即它们本身。</p><h2 id="b">b</h2><p>如果一个标准型线性规划<span class="math inline">\(L\)</span>存在一个有限最优解（最大值），那么其对偶问题也存在一个有限最优解（最小值）。如果我们令这个最大值和最小值相等，再交由<code>LINEAR-INEQUALITY-FEASIBILITY-A</code>求出一个可行解即可。</p><p>更具体地说，线性规划<span class="math inline">\(L\)</span>可行当且仅当下面关于<span class="math inline">\(\mathbf{x,y}\)</span>的线性不等式是否可行：</p><p><span class="math inline">\(\begin{aligned}\mathbf{A}\mathbf{x}&amp;\le\mathbf{b}\\\mathbf{A}^T\mathbf{y}&amp;\ge\mathbf{c}\\\mathbf{c}^T\mathbf{x}&amp;=\mathbf{b}^T\mathbf{y}\\ \mathbf{x}&amp;\ge0\\ \mathbf{y}&amp;\ge 0\\ \end{aligned}\)</span></p><p>如果<span class="math inline">\(L\)</span>是无界的，那么上面的线性不等式同样是不可行的。因此，我们下一步只需要判断<span class="math inline">\(L\)</span>是否为可行，从而区分出无界和不可行这两种情况。只需要进行两次判断以区分这<span class="math inline">\(3\)</span>种情况即可。更具体的情况由<code>LP-SOLVE</code>给出，假定<code>LINEAR-INEQUALITY-FEASIBILITY-A</code>是用于求解标准型线性不等式可行性的算法。最终求解线性规划算法由<code>LP-SOLVE</code>给出。</p><p>将上面的线性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">LP-SOLVE(A, b, c, m, n)</span><br><span class="line">  sol1 = LINEAR-INEQUALITY-FEASIBILITY-A(A, b, m, n)</span><br><span class="line">  if sol1 == NIL</span><br><span class="line">    return &quot;infeasible&quot;</span><br><span class="line">  let A&#x27;[2 * n + 2 * m + 2, n + m] be a new table by 0</span><br><span class="line">  let b&#x27;[2 * n + 2 * m + 2] be a new array by 0</span><br><span class="line">  for i = 1 to m</span><br><span class="line">    for j = 1 to n</span><br><span class="line">      A&#x27;[i, j] = A[i, j]</span><br><span class="line">      A&#x27;[m + j][n + i] = A[i, j]</span><br><span class="line">  for i = 1 to m</span><br><span class="line">    A[m + n + 1][n + i] = -b[i]</span><br><span class="line">    A[m + n + 2][n + i] = b[i]</span><br><span class="line">  for j = 1 to n</span><br><span class="line">    A[m + n + 1][j] = c[j]</span><br><span class="line">    A[m + n + 2][j] = -c[j]</span><br><span class="line">  for k = 1 to m + n</span><br><span class="line">    A[m + n + 2 + k][k] = -1</span><br><span class="line">  for i = 1 to m</span><br><span class="line">    b&#x27;[i] = b[i]</span><br><span class="line">  for j = 1 to n</span><br><span class="line">    b&#x27;[m + i] = c[j]</span><br><span class="line">  sol2 = LINEAR-INEQUALITY-FEASIBILITY-A(A, b, 2 * n + 2 * m + 2, n + m)</span><br><span class="line">  if sol2 == NIL</span><br><span class="line">    return &quot;unbounded&quot;</span><br><span class="line">  else</span><br><span class="line">    return sol2</span><br></pre></td></tr></table></figure><p>对上面的线性不等式标准化后，将会有<span class="math inline">\(2n+2m+2\)</span>条不等式，<span class="math inline">\(n+m\)</span>个变量，它们仍然是<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>的多项式。</p><h1 id="section-1">29-2</h1><h2 id="a-1">a</h2><p>该线性规划<span class="math inline">\(L\)</span>给出的最优可行解为<span class="math inline">\(\mathbf{x}^{\ast}=(x_1,x_2,x_3)=(8,4,0)\)</span>，对于其对偶线性规划，其最优可行解为<span class="math inline">\(\mathbf{y}^{\ast}=(y_1,y_2,y_3)=(0,1/6,2/3)\)</span>。令<span class="math inline">\(\mathbf{A}\)</span>表示原约束的系数矩阵，可以知道，<span class="math inline">\(\mathbf{Ax}^{\ast}=(12,24,36)^T,\mathbf{A}^T\mathbf{y}=(3,1,13/6)^T\)</span>。将<span class="math inline">\(\mathbf{A}^T\mathbf{y^{\ast}}\)</span>和<span class="math inline">\(\mathbf{x}^{\ast}\)</span>以及<span class="math inline">\(\mathbf{Ax}\)</span>和<span class="math inline">\(\mathbf{y}^{\ast}\)</span>相对比即可完成验证。</p><h2 id="b-1">b</h2><p>必要性：假设互补松驰性成立，那么有<span class="math inline">\(\displaystyle{\sum_{j=1}^nc_j\overline{x}_j=\sum_{j=1}^n\sum_{i=1}^ma_{ij}\overline{y}_i\overline{x}_j}\)</span>。原因在于，考虑每个<span class="math inline">\(j\in[1,n]\)</span>，如果<span class="math inline">\(\overline{x}_j=0\)</span>，那么<span class="math inline">\(\displaystyle{c_j\overline{x}_j=0,\overline{x}_j\cdot\sum_{i=1}^ma_{ij}\overline{y}_i=0}\)</span>，等式<span class="math inline">\(\displaystyle{c_j\overline{x}_j=\sum_{i=1}^ma_{ij}\overline{y}_i\overline{x}_j}\)</span>成立；如果<span class="math inline">\(\overline{x}_j=0\)</span>不成立，那么按照互补松弛性，此时有<span class="math inline">\(\displaystyle{\sum_{i=1}^ma_{ij}\overline{y}_i=c_j}\)</span>，等式<span class="math inline">\(\displaystyle{c_j\overline{x}_j=\sum_{i=1}^ma_{ij}\overline{y}_i\overline{x}_j}\)</span>依旧成立。因此有<span class="math inline">\(\displaystyle{\sum_{j=1}^nc_j\overline{x}_j=\sum_{j=1}^n\sum_{i=1}^ma_{ij}\overline{y}_i\overline{x}_j}\)</span>。</p><p>可以用类似的方法证明<span class="math inline">\(\displaystyle{\sum_{i=1}^mb_i\overline{y}_i=\sum_{i=1}^m\sum_{j=1}^na_{ij}\overline{x}_j\overline{y}_i}\)</span>。考虑每个<span class="math inline">\(i\in[1,m]\)</span>，如果<span class="math inline">\(\overline{y}_i=0\)</span>，那么<span class="math inline">\(\displaystyle{b_i\overline{y}_i=0,y_i\cdot\sum_{j=1}^n}a_{ij}\overline{x}_j=0\)</span>，等式<span class="math inline">\(\displaystyle{b_i\overline{y}_i=\sum_{j=1}^na_{ij}\overline{x}_j\overline{y}_i}\)</span>成立。如果<span class="math inline">\(\overline{y}_i=0\)</span>不成立，那么按照互补松弛性，此时有<span class="math inline">\(\displaystyle{\sum_{j=1}^na_{ij}\overline{x}_j=b_i}\)</span>，等式<span class="math inline">\(\displaystyle{b_i\overline{y}_i=\sum_{j=1}^na_{ij}\overline{x}_j\overline{y}_i}\)</span>依旧成立。因此有<span class="math inline">\(\displaystyle{\sum_{i=1}^mb_i\overline{y}_i=\sum_{i=1}^m\sum_{j=1}^na_{ij}\overline{x}_j\overline{y}_i}\)</span>。</p><p>由于<span class="math inline">\(\displaystyle{\sum_{j=1}^n\sum_{i=1}^ma_{ij}\overline{y}_i\overline{x}_j=\sum_{i=1}^m\sum_{j=1}^na_{ij}\overline{x}_j\overline{y}}\)</span>，因此有<span class="math inline">\(\displaystyle{\sum_{j=1}^nc_j\overline{x}_j=\sum_{i=1}^m b_i\overline{y}_i}\)</span>，即<span class="math inline">\(\mathbf{c}^T\overline{\mathbf{x}}=\mathbf{b}^T\overline{\mathbf{y}}\)</span>。</p><p>按照定理29.4，<span class="math inline">\(\overline{\mathbf{x}},\overline{\mathbf{y}}\)</span>分别是原线性规划和对偶线性规划的最优解，原结论成立。</p><p>充分性：我们将使用反证法完成证明。假设现在<span class="math inline">\(\mathbf{x}^{\ast},\mathbf{y}^{\ast}\)</span>分别是原线性规划和对偶线性规划的最优解。假设<span class="math inline">\(\exists i\in[1,m]\)</span>满足<span class="math inline">\(y_i^{\ast}\neq 0\)</span>，并且有<span class="math inline">\(\displaystyle{\sum_{j=1}^na_{ij}x_j^{\ast}&lt;b_i}\)</span>，使用必要性种类似的计算过程，可以得到：</p><p><span class="math inline">\(\begin{aligned} \sum_{j=1}^nc_jx_j^{\ast}&amp;=\sum_{j=1}^n\sum_{i=1}^ma_{ij}y_i^{\ast}x_j^{\ast}\\&amp;=\sum_{i=1}^m\sum_{j=1}^n a_{ij}x_j^{\ast}y_i^{\ast}\\&amp;&lt;\sum_{i=1}^m\sum_{j=1}^n b_iy_i^{\ast}\\\end{aligned}\)</span></p><p>按照定理29.4，<span class="math inline">\(\overline{\mathbf{x}},\overline{\mathbf{y}}\)</span>必定不是原线性规划和对偶线性规划的最优解，因此原结论成立。</p><p>对于另外一种情况的证明过程类似，假设<span class="math inline">\(\exists j\in[1,n]\)</span>满足<span class="math inline">\(x_j^{\ast}\neq 0\)</span>，并且有<span class="math inline">\(\displaystyle{\sum_{i=1}^ma_{ij}y_i^{\ast}&gt;c_j}\)</span>，使用必要性种类似的计算过程，可以得到：</p><p><span class="math inline">\(\begin{aligned} \sum_{j=1}^nc_jx_j^{\ast}&amp;&lt;\sum_{j=1}^n\sum_{i=1}^ma_{ij}y_i^{\ast}x_j^{\ast}\\&amp;=\sum_{i=1}^m\sum_{j=1}^n a_{ij}x_j^{\ast}y_i^{\ast}\\&amp;=\sum_{i=1}^m\sum_{j=1}^n b_iy_i^{\ast}\\\end{aligned}\)</span></p><p>同样的，<span class="math inline">\(\overline{\mathbf{x}},\overline{\mathbf{y}}\)</span>必定不是原线性规划和对偶线性规划的最优解，因此原结论成立。</p><p>因此原结论成立。</p><h2 id="c">c</h2><p>本题使用29-2-b的结论即可直接证明。 充分性：由于<span class="math inline">\(\mathbf{x}^{\ast}\)</span>是原线性规划的最优解，令<span class="math inline">\(\mathbf{y}^{\ast}\)</span>是对偶线性规划的最优解，那么其必定满足条件1。按照题目29-2-b的结论，条件2和3都成立。由此充分性成立。</p><p>必要性：条件1说明了<span class="math inline">\(\overline{\mathbf{y}}\)</span>是对偶线性规划的一个可行解，根据题目29-2-b的结论，条件2和条件3说明了构造出来的可行解<span class="math inline">\(\overline{\mathbf{x,y}}\)</span>都是各自线性规划的最优解。由此必要性成立。</p><p>因此原结论成立。</p><h1 id="section-2">29-3</h1><h2 id="a-2">a</h2><p>证明过程和在线性规划时期，对引理29.1的证明过程完全相同。不失一般性，假设现在需要证明的整数规划是标准型。</p><p>令<span class="math inline">\(\mathbf{x}\)</span>是原整数规划的一个可行解，<span class="math inline">\(\mathbf{y}\)</span>是对偶整数规划的一个可行解，那么有</p><p><span class="math inline">\(\begin{aligned}\mathbf{c}^T\overline{\mathbf{x}}&amp;\le(\mathbf{A}^T\overline{\mathbf{y}})^T\overline{\mathbf{x}}\\&amp;=\overline{\mathbf{y}}^T\mathbf{A}\overline{\mathbf{x}}\\&amp;\le\overline{\mathbf{y}}^T\mathbf{b} \end{aligned}\)</span></p><p>因此原结论成立。</p><h2 id="b-2">b</h2><p>考虑如下单个变量<span class="math inline">\(x\)</span>的标准型整数规划：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;x\\ \text{subject to}&amp; \\ &amp;&amp;x&amp;\le\dfrac{1}{2}\\&amp;&amp;x&amp;\ge 0 \end{aligned}\)</span></p><p>可以发现其最优可行解只有<span class="math inline">\(x=0\)</span>，目标函数值为<span class="math inline">\(0\)</span>。</p><p>那么其对偶整数规划为：</p><p><span class="math inline">\(\begin{aligned} \text{mimimize}&amp;&amp;\dfrac{1}{2}y\\ \text{subject to}&amp; \\ &amp;&amp;y&amp;\ge 1\\&amp;&amp;y&amp;\ge 0 \end{aligned}\)</span></p><p>可以发现其最优可行解为<span class="math inline">\(y=1\)</span>，目标函数值为<span class="math inline">\(\dfrac{1}{2}\)</span>。</p><p>由于它们的最优解不相同，因此整数规划不满足对偶性。</p><h2 id="c-1">c</h2><p>不失一般性，假设现在需要证明的整数规划是标准型。</p><p>令<span class="math inline">\(L_I\)</span>是一个标准型整数规划，<span class="math inline">\(L\)</span>是<span class="math inline">\(L_I\)</span>除去整数约束后所得到的线性规划，<span class="math inline">\(L_I^D\)</span>是<span class="math inline">\(L_I\)</span>的对偶整数规划，<span class="math inline">\(L^D\)</span>是<span class="math inline">\(L\)</span>的对偶线性规划。那么<span class="math inline">\(P,D\)</span>分别是<span class="math inline">\(L,L^D\)</span>的目标函数值。按照定理29.4，有<span class="math inline">\(P=D\)</span>。</p><p>由于<span class="math inline">\(L_I\)</span>是<span class="math inline">\(L\)</span>添加上了整数约束而来，因此<span class="math inline">\(L_I\)</span>的可行域必定是<span class="math inline">\(L\)</span>的可行域的子集。这意味着在<span class="math inline">\(L\)</span>中的最优解必定不劣于<span class="math inline">\(L_I\)</span>中的最优解，因此有<span class="math inline">\(IP\le P\)</span>；类似的，在<span class="math inline">\(L^D\)</span>中的最优解必定不劣于<span class="math inline">\(L^D_I\)</span>中的最优解，因此有<span class="math inline">\(ID\ge D\)</span>。</p><p>最终有等式<span class="math inline">\(IP\le P=D\le ID\)</span>。</p><h1 id="section-3">29-4</h1><p>这里的证明参考了这篇<a href="https://people.orie.cornell.edu/dpw/orie6300/fall2008/Lectures/lec07.pdf">文章</a>。</p><p>首先列出<strong>原始</strong>Farkas引理：</p><h2 id="farkas引理">Farkas引理</h2><p>给定<span class="math inline">\(M\in\mathbb{R}^{(m+1)\timesn},g\in\mathbb{R}^{m+1}\)</span>，如下两种陈述只有一种成立：</p><ol type="1"><li><span class="math inline">\(\exists \mathbf{v}\in\mathbb{R}^{n},\mathbf{Mv=g},\mathbf{v}\ge \mathbf{0}\)</span></li><li><span class="math inline">\(\exists \mathbf{w}\in\mathbb{R}^{m+1},\mathbf{M}^T\mathbf{w}\ge\mathbf{0},\mathbf{g}^T\mathbf{w}&lt;0\)</span></li></ol><hr><p>接下来证明题目中给定的<strong>变种</strong>Farkas引理。第一步则是使用反证法证明<strong>至多</strong>只有一个陈述成立。假设这两个陈述都成立，那么我们针对<span class="math inline">\(\mathbf{v,w}\)</span>的存在性，可以列出：</p><p><span class="math inline">\(\begin{aligned} \mathbf{Mv}&amp;\le\mathbf{g}\\ \mathbf{w}^T\mathbf{M}&amp;=\mathbf{0}\\\mathbf{w}^T\mathbf{g}&amp;&lt;\mathbf{0} \end{aligned}\)</span></p><p>对第一条不等式左乘上一个恒非负的向量<span class="math inline">\(\mathbf{w^T}\)</span>，得到<span class="math inline">\(\mathbf{w}^T\mathbf{Mv}\le\mathbf{w}^T\mathbf{g}\)</span>，即得到<span class="math inline">\(\mathbf{w}^T\mathbf{g}=\mathbf{0}\)</span>，和第三条不等式矛盾，因此这两个陈述至多只有一个成立。</p><p>接下来证明第2个陈述和如下第3个陈述是等价的：</p><ol start="3" type="1"><li><span class="math inline">\(\exists \mathbf{w}\in\mathbb{R}^{m+1}\)</span>，使得<span class="math inline">\(\mathbf{w}\ge\mathbf{0},\mathbf{M}^T\mathbf{w}=0,\mathbf{w}^T\mathbf{g}=-1\)</span>。</li></ol><p>必要性显然成立，因为<span class="math inline">\(\mathbf{w}^T\mathbf{g}=-1&lt;0\)</span>，从而第2个陈述也是成立的。接下来证明充分性，令<span class="math inline">\(\mathbf{w&#39;}=-\dfrac{1}{\mathbf{w}^T\mathbf{g}}\cdotw\)</span>，那么由于<span class="math inline">\(-\dfrac{1}{\mathbf{w}^T\mathbf{g}}&lt;0\)</span>，因此<span class="math inline">\(\mathbf{w&#39;}\ge 0\)</span>仍然成立；<span class="math inline">\(\mathbf{w&#39;}^T\mathbf{g}=\dfrac{1}{\mathbf{w}^T\mathbf{g}}\cdot(\mathbf{w}^T\mathbf{g})=-1\)</span>；此外，<span class="math inline">\(\mathbf{w&#39;}^T\mathbf{M}=-\dfrac{1}{\mathbf{w}^T\mathbf{g}}\cdot(\mathbf{w}^T\mathbf{M})=0\)</span>，最终<span class="math inline">\(\mathbf{w&#39;}\)</span>的存在说明充分性成立。由此，第2个陈述和第3个陈述等价。</p><p>假设现在第2个陈述不成立，那么第3个陈述也不成立。那么可以将<span class="math inline">\(\mathbf{M}^T\mathbf{w}=\mathbf{0},\mathbf{g}^T\mathbf{w}=-1\)</span>重写成<span class="math inline">\(\mathbf{A}=(\mathbf{M},\mathbf{g})^T,\mathbf{b}=(0,0,\dots,0,-1)^T\)</span>。</p><p>由于第3个陈述不成立，这意味着<span class="math inline">\(\nexists\mathbf{x}\in\mathbb{R}^{m+1},\mathbf{x}\ge 0\)</span>使得<span class="math inline">\(\mathbf{Ax=b}\)</span>。也就是说，这时不满足<strong>原始</strong>Farkas引理的第1个陈述，那么这意味着<strong>原始</strong>Farkas引理第2个陈述必须成立，因此通过这条陈述，给出了<span class="math inline">\(\exists\mathbf{y}\in\mathbb{R}^{n+1},\mathbf{A}^T\mathbf{y}\ge0,\mathbf{b}^T\mathbf{y}&lt;0\)</span>。</p><p>令<span class="math inline">\(\mathbf{y}=\begin{pmatrix}\mathbf{z}\\\lambda\end{pmatrix}\)</span>，其中<span class="math inline">\(\mathbf{z}\in \mathbb{R}^n,\lambda\in\mathbb{R}\)</span>。由于<span class="math inline">\(\mathbf{b}^T\)</span>前<span class="math inline">\(n\)</span>个分量都是<span class="math inline">\(0\)</span>，因此<span class="math inline">\(\mathbf{b}^T\mathbf{y}=-\lambda&lt;0\)</span>，因此得到<span class="math inline">\(\lambda&gt;0\)</span>。<span class="math inline">\(\mathbf{A}^T\mathbf{y}\ge 0\)</span>意味着<span class="math inline">\(\begin{pmatrix}\mathbf{M}&amp;\mathbf{g}\end{pmatrix}\begin{pmatrix}\mathbf{z}\\\lambda\end{pmatrix}\ge0\)</span>，这给出了<span class="math inline">\(\mathbf{Mz}+\lambda\mathbf{g}\ge 0\)</span>，即<span class="math inline">\(\mathbf{M}(-\mathbf{z}/\lambda)\leg\)</span>。向量<span class="math inline">\((-\mathbf{z}/\lambda)\)</span>的存在证明了<strong>变种</strong>Farkas引理的第1条陈述是正确的，因此原结论成立。</p><h1 id="section-4">29-5</h1><h2 id="a-3">a</h2><p>由于删除了一些约束，因此这个问题的线性规划可以从最小费用流问题转化而来：</p><p><span class="math inline">\(\begin{aligned} \text{minimize}&amp;&amp;\sum_{(u,v)\in E}a(u,v)\cdot f_{uv}\\ \text{subject to}&amp; \\&amp;&amp;f_{uv}&amp;\le c(u,v) &amp;&amp;\forall (u,v)\in E \\&amp;&amp;f_{uv}&amp;\ge 0 &amp;&amp;\forall (u,v)\in E \\&amp;&amp;\sum_{(u,v)\in E} f_{uv}&amp;=\sum_{(v,u)\in E} f_{vu}&amp;&amp;\forall u\in V \end{aligned}\)</span></p><h2 id="b-3">b</h2><p>由于花费函数<span class="math inline">\(a(u,v)&gt;0\)</span>，并且线性规划的目标函数是最小化费用。因此线性规划的最优方案将是：不使用任何边进行流动，那么这样将不会产生任何花费。因此，这个流是的大小为<span class="math inline">\(0\)</span>。</p><h2 id="c-2">c</h2><p>不失一般性，我们可以删除<span class="math inline">\(E\)</span>中<span class="math inline">\((t,s)\)</span>的边，这不会减少最大流的值。</p><p>我们构造图<span class="math inline">\(G&#39;=(V&#39;,E&#39;)\)</span>，其中<span class="math inline">\(V&#39;=V,E&#39;=E\cup\{(t,s)\}\)</span>。令<span class="math inline">\(a(t,s)=-1,c(t,s)=+\infty\)</span>，对于<span class="math inline">\(\forall(u,v)\in E\)</span>，都有<span class="math inline">\(a(u,v)=0,c(u,v)\)</span>为原最大流问题中，有向边<span class="math inline">\((u,v)\)</span>的容量。考虑新构造后的图<span class="math inline">\(G&#39;\)</span>，以及对应的容量函数<span class="math inline">\(c\)</span>和费用函数<span class="math inline">\(a\)</span>，那么最大流问题就相当于解决如此一个最小费用流通问题。</p><p>在<span class="math inline">\(G&#39;\)</span>中，如果一个“流”从<span class="math inline">\(t\)</span>流动到<span class="math inline">\(s\)</span>，那么将会有一个真正的流从<span class="math inline">\(s\)</span>流动到<span class="math inline">\(t\)</span>。并且由于<span class="math inline">\(a(t,s)=-1\)</span>，因此线性规划算法将会“激励”尽量多的流产生，并且产生一个真正的流并不会添加任何代价。由于<span class="math inline">\(c(t,s)=+\infty\)</span>，因此这将不会限制从<span class="math inline">\(s\)</span>到<span class="math inline">\(t\)</span>的流产生。</p><p>最终，舍去变量<span class="math inline">\(f_{ts}\)</span>的值（或者是让其值为<span class="math inline">\(0\)</span>），那么计算出的一组解<span class="math inline">\(f\)</span>为原图<span class="math inline">\(G\)</span>上的最大流。</p><h2 id="d">d</h2><p>令<span class="math inline">\(\displaystyle{A=1+\sum_{(u,v)\inE}a(u,v)}\)</span>，其中<span class="math inline">\(a(u,v)\)</span>是从<span class="math inline">\(u\)</span>到<span class="math inline">\(v\)</span>的距离。也就是说，<span class="math inline">\(M\)</span>是一个足够大的数，但并非是无穷大。</p><p>同样的，不失一般性，我们可以删除<span class="math inline">\(E\)</span>中<span class="math inline">\(s\)</span>的所有入边，这不会增加从<span class="math inline">\(s\)</span>到任意节点的最短路径。</p><p>可以构造图<span class="math inline">\(G&#39;=(V&#39;,E&#39;)\)</span>，其中<span class="math inline">\(V&#39;=V,E&#39;=E\cup\{(v,s):v\inV-\{s\}\}\)</span>。<span class="math inline">\(\forall (v,s)\inE&#39;\)</span>，令<span class="math inline">\(c(v,s)=1,a(v,s)=-A\)</span>。<span class="math inline">\(\forall (u,v)\inE,c(u,v)=+\infty,a(u,v)\)</span>为原最短路问题中，从<span class="math inline">\(u\)</span>到<span class="math inline">\(v\)</span>的距离边权。考虑新构造后的图<span class="math inline">\(G&#39;\)</span>，以及对应的容量函数<span class="math inline">\(c\)</span>和费用函数<span class="math inline">\(a\)</span>，那么最短路问题就相当于解决如此一个最小费用流通问题。</p><p>在<span class="math inline">\(G&#39;\)</span>中，任意一条<strong>简单路径</strong>的长度都小于<span class="math inline">\(A\)</span>。因此在一个最小费用流通问题中，使用边<span class="math inline">\((v,s)\inE&#39;\)</span>一定是更优的。对于任意<span class="math inline">\(v\inV-\{s\}\)</span>，这意味着必定有一个流从<span class="math inline">\(s\)</span>到达<span class="math inline">\(v\)</span>，并且这个流的费用是最小的，这时从<span class="math inline">\(s\)</span>到<span class="math inline">\(v\)</span>的这个流恰好就对应了原问题的最短路径。</p><p>最终，舍去所有变量<span class="math inline">\(f_{vs}(s\inV-\{s\})\)</span>（或者是让其值为<span class="math inline">\(0\)</span>）。对于任意节点<span class="math inline">\(v\in V-\{s\}\)</span>，求出从<span class="math inline">\(s\)</span>到<span class="math inline">\(v\)</span>的最短路径，需要从<span class="math inline">\(v\)</span>开始，逐渐向前移动，找到这个流的起点即可。最终处理出来的流就是对应最短路径。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论29.3 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/29-3-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/29-3-Exercises/</id>
    <published>2023-10-04T06:40:10.000Z</published>
    <updated>2023-10-04T06:40:10.016Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">29.3-1</h1><p>该线性规划的对偶线性规划为：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;50y_1+100y_2+25y_3\\ \text{subject to}&amp; \\&amp;&amp;-2y_1+5y_2+3y_3&amp;\le 1\\ &amp;&amp;8y_1+2y_2-5y_3&amp;\le1\\ &amp;&amp;0y_1+0y_2+10y_3&amp;\le 1\\&amp;&amp;10y_1+0y_2-2y_3&amp;\le 1\\ &amp;&amp;y_1,y_2,y_3&amp;\ge 0\end{aligned}\)</span></p><h1 id="section-1">29.3-2</h1><p>整个过程分成两个步骤进行：</p><ol type="1"><li><p>是将所有约束的比较符号的方向统一化。不失一般性，如果现在需要将除去非负约束以外的<span class="math inline">\(\ge\)</span>的约束转化成<span class="math inline">\(\le\)</span>的约束，那么只需要对原约束两侧乘上<span class="math inline">\(-1\)</span>，并将比较符号反向即可。</p></li><li><p>假设经第1个步骤处理后，原线性规划的目标函数为<span class="math inline">\(\mathbf{c}^T\mathbf{x}\)</span>，并且朝某一个方向优化（最大/最小），约束是<span class="math inline">\(\mathbf{A}^T\mathbf{x}\circ\mathbf{b}\)</span>，其中<span class="math inline">\(\circ\in\{\le,\ge\}\)</span>。那么原线性规划的对偶线性规划的目标函数是<span class="math inline">\(\mathbf{b}^T\mathbf{y}\)</span>，并且朝<strong>另一个</strong>方向优化（最小/最大），约束是<span class="math inline">\(\mathbf{A}^T\mathbf{y}\overline{\circ}\mathbf{c}\)</span>，即将统一前的比较符号均取反即可。</p></li></ol><h1 id="section-2">29.3-3</h1><p>我们可以给出最大流问题线性规划的标准型为：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;\sum_{(s,v)\in E} f_{sv}-\sum_{(v,s)\in E} f_{vs}\\ \text{subjectto}&amp; \\ &amp;&amp;f_{uv}&amp;\le c(u,v) &amp;&amp;\forall (u,v)\in E\\ &amp;&amp;f_{uv}&amp;\ge 0 &amp;&amp;\forall (u,v)\in E \\&amp;&amp;\sum_{(u,v)\in E} f_{uv}-\sum_{(v,u)\in E} f_{vu}&amp;\le 0&amp;&amp;\forall u\in V-\{s,t\}\\ &amp;&amp;\sum_{(v,u)\in E}f_{vu}-\sum_{(u,v)\in E} f_{uv}&amp;\le 0 &amp;&amp;\forall u\inV-\{s,t\} \end{aligned}\)</span></p><p>可见，令左边的系数矩阵为<span class="math inline">\(\mathbf{A}\)</span>，其大小为<span class="math inline">\((2|V|+2|E|-4)\times |E|\)</span>，右边的<span class="math inline">\(\mathbf{b}\)</span>是一个<span class="math inline">\(2|V|+2|E|-4\)</span>维的向量，其目标函数<span class="math inline">\(\mathbf{c}^T\mathbf{x}\)</span>中的向量<span class="math inline">\(\mathbf{c}^T\)</span>长度为<span class="math inline">\(|E|\)</span>。因此最大流问题的对偶线性规划为</p><p><span class="math inline">\(\begin{aligned} \text{minimize}&amp;&amp;\mathbf{b}^T\mathbf{y}\\ \text{subject to}&amp; \\&amp;&amp;\mathbf{A}^T\mathbf{y}&amp;\ge\mathbf{c}\end{aligned}\)</span></p><h1 id="section-3">29.3-4</h1><p>我们可以给出最小费用流问题线性规划的统一符号方向后的结果为：</p><p><span class="math inline">\(\begin{aligned} \text{minimize}&amp;&amp;\sum_{(u,v)\in E} a(u,v)\cdot f_{uv}\\ \text{subject to}&amp; \\&amp;&amp;f_{uv}&amp;\le c(u,v) &amp;&amp;\forall (u,v)\in E \\&amp;&amp;f_{uv}&amp;\ge 0 &amp;&amp;\forall (u,v)\in E \\&amp;&amp;\sum_{(u,v)\in E} f_{uv}-\sum_{(v,u)\in E} f_{vu}&amp;\le 0&amp;&amp;\forall u\in V-\{s,t\}\\ &amp;&amp;\sum_{(v,u)\in E}f_{vu}-\sum_{(u,v)\in E} f_{uv}&amp;\le 0 &amp;&amp;\forall u\inV-\{s,t\}\\ &amp;&amp;\sum_{(s,v)\in E} f_{sv}-\sum_{(v,s)\in E}f_{vs}&amp;\le d\\ &amp;&amp;\sum_{(v,s)\in E} f_{vs}-\sum_{(s,v)\in E}f_{sv}&amp;\le -d \end{aligned}\)</span></p><p>可见，令左边的系数矩阵为<span class="math inline">\(\mathbf{A}\)</span>，其大小为<span class="math inline">\((2|V|+2|E|-2)\times |E|\)</span>，右边的<span class="math inline">\(\mathbf{b}\)</span>是一个<span class="math inline">\(2|V|+2|E|-2\)</span>维的向量，其目标函数<span class="math inline">\(\mathbf{c}^T\mathbf{x}\)</span>中的向量<span class="math inline">\(\mathbf{c}^T\)</span>长度为<span class="math inline">\(|E|\)</span>。因此最小费用流问题的对偶线性规划为</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;\mathbf{b}^T\mathbf{y}\\ \text{subject to}&amp; \\&amp;&amp;\mathbf{A}^T\mathbf{y}&amp;\ge\mathbf{c}\end{aligned}\)</span></p><h1 id="section-4">29.3-5</h1><p>不失一般性，这里仅考虑标准型的线性规划：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;\mathbf{c}^T\mathbf{x}\\ \text{subject to}&amp; \\&amp;&amp;\mathbf{A}\mathbf{x}&amp;\le\mathbf{b}\\&amp;&amp;\mathbf{x}&amp;\ge\mathbf{0} \end{aligned}\)</span></p><p>按照定义，其对偶线性规划为：</p><p><span class="math inline">\(\begin{aligned} \text{minimize}&amp;&amp;\mathbf{b}^T\mathbf{y}\\ \text{subject to}&amp; \\&amp;&amp;\mathbf{A}^T\mathbf{y}&amp;\ge\mathbf{c}\\&amp;&amp;\mathbf{y}&amp;\ge\mathbf{0} \end{aligned}\)</span></p><p>该对偶线性规划的对偶线性规划为：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;\mathbf{c}^T\mathbf{x&#39;}\\ \text{subject to}&amp; \\&amp;&amp;\mathbf{A}\mathbf{x&#39;}&amp;\le\mathbf{b}\\&amp;&amp;\mathbf{x&#39;}&amp;\ge\mathbf{0} \end{aligned}\)</span></p><p>可见，第一个线性规划和第三个线性规划的形式是完全一致的，因此一个线性规划对偶的对偶是它本身。</p><h1 id="section-5">29.3-6</h1><p>最大流问题中，推论24.5最大流的值的上界被最小割值限制着，这可以被解释成最大流问题的弱对偶。</p><h1 id="section-6">29.3-7</h1><p>本题以分类讨论为主。</p><p>对于原线性规划：</p><ul><li>当<span class="math inline">\(r&gt;0,s&lt;0\)</span>时，原线性规划的可行域是<span class="math inline">\(\varnothing\)</span>，因此它不可行。</li><li>当<span class="math inline">\(r&gt;0,s\ge0\)</span>时，原线性规划的可行域是<span class="math inline">\(0\le x\les/r\)</span>。此时目标值必定是有限的。</li><li>当<span class="math inline">\(r=0,s&lt;0\)</span>时，原线性规划的可行域是<span class="math inline">\(\varnothing\)</span>，因此它不可行。</li><li>当<span class="math inline">\(r=0,s\ge0\)</span>时，原线性规划的可行域是<span class="math inline">\(x\ge0\)</span>。如果<span class="math inline">\(t\le0\)</span>，那么其目标值有限，否则是无界的。</li><li>当<span class="math inline">\(r&lt;0,s&lt;0\)</span>时，原线性规划的可行域是<span class="math inline">\(x\ge s/r\)</span>。如果<span class="math inline">\(t\le0\)</span>，那么其目标值有限，否则是无界的。</li><li>当<span class="math inline">\(r&lt;0,s\ge0\)</span>时，原线性规划的可行域是<span class="math inline">\(x\ge0\)</span>。如果<span class="math inline">\(t\le0\)</span>，那么其目标值有限，否则是无界的。</li></ul><p>可见这个线性规划的对偶线性规划是：</p><p><span class="math inline">\(\begin{aligned} \text{minimize}&amp;&amp;sy\\ \text{subject to}&amp; \\ &amp;&amp;ry&amp;\ge t\\&amp;&amp;y&amp;\ge0 \end{aligned}\)</span></p><ul><li>当<span class="math inline">\(r&gt;0,t\le0\)</span>时，对偶线性规划的可行域是<span class="math inline">\(y\ge0\)</span>。如果<span class="math inline">\(s\ge0\)</span>，那么其目标值有限，否则是无界的。</li><li>当<span class="math inline">\(r&gt;0,t&gt;0\)</span>时，对偶线性规划的可行域是<span class="math inline">\(y\ge t/r\)</span>。如果<span class="math inline">\(s\ge0\)</span>，那么其目标值有限，否则是无界的。</li><li>当<span class="math inline">\(r=0,t\le0\)</span>时，对偶线性规划的可行域是<span class="math inline">\(y\ge0\)</span>。如果<span class="math inline">\(s\ge0\)</span>，那么其目标值有限，否则是无界的。</li><li>当<span class="math inline">\(r=0,t&gt;0\)</span>时，对偶线性规划的可行域是<span class="math inline">\(\varnothing\)</span>，因此它不可行。</li><li>当<span class="math inline">\(r&lt;0,t\le0\)</span>时，对偶线性规划的可行域是<span class="math inline">\(0\lex\le t/r\)</span>。此时目标值必定是有限的。</li><li>当<span class="math inline">\(r&lt;0,t&gt;0\)</span>时，对偶线性规划的可行域是<span class="math inline">\(\varnothing\)</span>，因此它不可行。</li></ul><p>综上所述：</p><ol type="1"><li>当<span class="math inline">\((r=0\land s\ge 0\land t\le0)\lor(r&gt;0\land r&gt;0\land s\ge 0)\lor(r&lt;0\land t\le0)\)</span>为真时，满足第一个断言。</li><li>当<span class="math inline">\((r=0\land s\ge 0\land t&gt;0)\lor(r&lt;0\land t&gt; 0)\)</span>为真时，满足第二个断言。</li><li>当<span class="math inline">\((r=0\land s&lt; 0\land t\le0)\lor(r&gt;0\land s&lt; 0)\)</span>为真时，满足第三个断言。</li><li>当<span class="math inline">\(r=0\land s&lt; 0\land t&gt;0\)</span>为真时，满足第四个断言。</li></ol><h1 id="section-7">29.3-8</h1><p>如果一个线性规划无解，即不存在一个向量<span class="math inline">\(\mathbf{x}\)</span>满足各个约束，那么说明这个标准线性规划是不可行的。</p><p>否则，必定存在一系列可行解，使得多个向量<span class="math inline">\(\mathbf{x}\)</span>满足这些约束。如果这个线性规划没有有限的最优目标值，那么说明这个可行域必定是无界的。否则按照最优性（即要么最大，要么最小），有一个有限目标值的最优解。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论29.2 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/29-2-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/29-2-Exercises/</id>
    <published>2023-10-04T06:40:06.000Z</published>
    <updated>2023-10-04T06:40:06.717Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">29.2-1</h1><p>这个最短路问题的对应线性规划问题如下：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;d_x\\ \text{subject to}&amp; \\ &amp;&amp;d_t&amp;\le d_s+3\\&amp;&amp;d_y&amp;\le d_s+5\\ &amp;&amp;d_x&amp;\le d_t+6\\&amp;&amp;d_y&amp;\le d_t+2\\ &amp;&amp;d_z&amp;\le d_x+2\\&amp;&amp;d_t&amp;\le d_y+1\\ &amp;&amp;d_x&amp;\le d_y+4\\&amp;&amp;d_z&amp;\le d_y+6\\ &amp;&amp;d_s&amp;\le d_z+3\\&amp;&amp;d_x&amp;\le d_z+7\\ &amp;&amp;d_s&amp;=0\end{aligned}\)</span></p><h1 id="section-1">29.2-2</h1><p>这和第29.2章介绍的线性规划系统类似，如下给出：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;\sum_{v\in V} d_v\\ \text{subject to}&amp; \\ &amp;&amp;d_v&amp;\led_u+w(u,v) &amp;&amp;\forall (u,v)\in E \\ &amp;&amp;d_s&amp;=0\end{aligned}\)</span></p><p>两条约束和29.2所给出的约束相同，区别在于目标函数。由于目前是希望最大化所有变量<span class="math inline">\(d_v\)</span>，但是最短路径的松弛性质仍然保持，因此这时的最优解对应了<span class="math inline">\(s\)</span>到所有节点的最短路径长度。</p><h1 id="section-2">29.2-3</h1><p>这个最大流问题的对应线性规划问题如下：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;f_{sv_1}+f_{sv_2}\\ \text{subject to}&amp; \\ &amp;&amp;f_{uv}&amp;\ge 0&amp;&amp;\forall (u,v)\in E \\ &amp;&amp;f_{sv_1}&amp;\le 16\\&amp;&amp;f_{sv_2}&amp;\le 14\\ &amp;&amp;f_{v_1v_3}&amp;\le 12\\&amp;&amp;f_{v_2v_1}&amp;\le 4\\ &amp;&amp;f_{v_2v_4}&amp;\le 14\\&amp;&amp;f_{v_3v_2}&amp;\le 9\\ &amp;&amp;f_{v_3v_t}&amp;\le 20\\&amp;&amp;f_{v_4v_3}&amp;\le 7\\ &amp;&amp;f_{v_4t}&amp;\le 4\\&amp;&amp;f_{sv_1}+f_{v_2v_1}&amp;= f_{v_1v_3}\\&amp;&amp;f_{sv_2}+f_{v_3v_2}&amp;= f_{v_2v_1}+f_{v_2v_4}\\&amp;&amp;f_{v_1v_3}+f_{v_4v_3}&amp;= f_{v_3v_2}+f_{v_3t}\\&amp;&amp;f_{v_2v_4}&amp;= f_{v_4v_3}+f_{v_4t}\\\end{aligned}\)</span></p><h1 id="section-3">29.2-4</h1><p>这里使用题目24.1-4的结果：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;\sum_{(s,v)\in E} f_{sv}-\sum_{(v,s)\in E} f_{vs}\\ \text{subjectto}&amp; \\ &amp;&amp;f_{uv}&amp;\ge 0 &amp;&amp;\forall (u,v)\in E \\&amp;&amp;f_{uv}&amp;\le c(u,v) &amp;&amp;\forall (u,v)\in E \\&amp;&amp;\sum_{(u,v)\in E} f_{uv}&amp;=\sum_{(v,u)\in E} f_{vu}&amp;&amp;\forall u\in V-\{s,t\} \end{aligned}\)</span></p><p>可见，这里一共有<span class="math inline">\(2|E|+|V|-2=O(V+E)\)</span>条约束。</p><h1 id="section-4">29.2-5</h1><p>令二分图<span class="math inline">\(G=(V,E),V=L\cupR\)</span>。使用第24.3章的结论，我们可以将这个问题转化成最大流问题进行解答：令<span class="math inline">\(V&#39;=V\cup\{s,t\},E&#39;=\{(s,l):l\inL\}\cup\{(r,t):r\in R\}\cup E\)</span>，对于<span class="math inline">\(\forall (u,v)\in E&#39;\)</span>，都有<span class="math inline">\(c(u,v)=1\)</span>。那么图<span class="math inline">\(G\)</span>的二分图最大匹配数量相当于是图<span class="math inline">\(G&#39;=(V&#39;,E&#39;)\)</span>中从<span class="math inline">\(s\)</span>到<span class="math inline">\(t\)</span>的最大流。这个线性规划将使用题目29.2-4的结论，如下：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;\sum_{l\in L}f_{sl} \\ \text{subject to}&amp; \\&amp;&amp;f_{uv}&amp;\ge 0 &amp;&amp;\forall (u,v)\in E&#39; \\&amp;&amp;f_{uv}&amp;\le c(u,v) &amp;&amp;\forall (u,v)\in E&#39; \\&amp;&amp;\sum_{(u,v)\in E&#39;} f_{uv}&amp;=\sum_{(v,u)\in E&#39;}f_{vu} &amp;&amp;\forall u\in V \end{aligned}\)</span></p><h1 id="section-5">29.2-6</h1><p>这意味着对于任意一条路径<span class="math inline">\(p_i\)</span>，如果其经过边<span class="math inline">\((u,v)\)</span>，那么这条路径就需要受到这条边容量的限制。因此，对于路径<span class="math inline">\(P\)</span>，我们可以写出如下线性规划：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;\sum_{i=1}^px_i \\ \text{subject to}&amp; \\ &amp;&amp;x_{i}&amp;\ge 0&amp;&amp;\forall i\in[1,p] \\ &amp;&amp;\sum_{1\le i\le p,(u,v)\inP_i}x_i&amp;\le c(u,v) &amp;&amp;\forall (u,v)\in E \\\end{aligned}\)</span></p><p>如果<span class="math inline">\(G\)</span>是一个有<span class="math inline">\(\dfrac{|V|(|V|-1)}{2}\)</span>条边的有向无环图，那么<span class="math inline">\(p\)</span>的值可以达到<span class="math inline">\(2^{|V|-2}\)</span>。因此使用这个线性规划求解最大流问题是不明智的，因为约束的大小和数量都太多（呈指数级数量）。</p><h1 id="section-6">29.2-7</h1><p>只需要对多商品流问题的目标函数进行修改即可。修改后的线性规划问题如下：</p><p><span class="math inline">\(\begin{aligned} \text{minimize}&amp;&amp;\sum_{(u,v)\in E}a(u,v)\cdot\left(\sum_{i=1}^k f_{i,u,v}\right) \\\text{subject to}&amp; \\ &amp;&amp;\sum_{i=1}^kf_{i,u,v}&amp;\le c(u,v)&amp;&amp;\forall (u,v)\in E\\ &amp;&amp;\sum_{(u,v)\inE}f_{i,u,v}-\sum_{(v,u)\in E}f_{i,v,u}&amp;= 0 &amp;&amp;\foralli\in[1,k],\forall u\in V-\{s_i,t_i\} \\ &amp;&amp;\sum_{(s_i,v)\inE}f_{i,s_i,v}-\sum_{(v,s_i)\in E}f_{i,v,s_i}&amp;= d_i &amp;&amp;\foralli\in[1,k]\\ &amp;&amp;f_{i,u,v}&amp;\ge 0 &amp;&amp;\foralli\in[1,k],\forall (u,v)\in E\\ \end{aligned}\)</span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论29.1 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/29-1-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/29-1-Exercises/</id>
    <published>2023-10-04T06:40:02.000Z</published>
    <updated>2023-10-04T06:47:57.910Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">29.1-1</h1><p><span class="math inline">\((0,7),(1,6),(2,5)\)</span>分别是这个线性规划的<span class="math inline">\(3\)</span>个可行解，其目标函数值分别为<span class="math inline">\(21,16,11\)</span>。</p><h1 id="section-1">29.1-2</h1><p><span class="math inline">\((7,3,0),(7,4,0),(7,5,0)\)</span>分别是这个线性规划的<span class="math inline">\(3\)</span>个可行解，其目标函数值分别为<span class="math inline">\(35,42,49\)</span>。</p><h1 id="section-2">29.1-3</h1><p>对第二条约束变形后，得到<span class="math inline">\(x_1+x_2\ge5\)</span>，这和第一条约束<span class="math inline">\(x_1+x_2\le2\)</span>是明显冲突的。因此，这个线性规划是不可行的。</p><h1 id="section-3">29.1-4</h1><p>考虑令<span class="math inline">\(x_1=2t,x_2=t\)</span>，那么目标函数为<span class="math inline">\(t\)</span>。当<span class="math inline">\(t\ge0\)</span>时，第一条约束化成<span class="math inline">\(-3t\le-1\)</span>，第二条约束化成<span class="math inline">\(-4t\le-2\)</span>，其余约束化成<span class="math inline">\(t\ge0\)</span>。哪怕<span class="math inline">\(t\)</span>趋向于正无穷，这些约束仍然是成立的。由于需要最大化目标值，那么目标值可以到达正无穷，因此这个线性规划是无界的。</p><h1 id="section-4">29.1-5</h1><p>构造出的线性规划问题如下：</p><p><span class="math inline">\(\begin{aligned} \text{maximize}&amp;&amp;x_1+x_2\\ \text{subject to}&amp; \\ &amp;&amp;x_1+2x_2&amp;\le 4\\&amp;&amp;2x_1+x_2&amp;\le 5 \end{aligned}\)</span></p><p>虽然可行解是无界的，但是最优解只有一个：<span class="math inline">\((2,1)\)</span>，其目标值为<span class="math inline">\(3\)</span>。</p><h1 id="section-5">29.1-6</h1><h2 id="a">a</h2><p>只需要将等式约束<span class="math inline">\(\displaystyle{\sum_{j=1}^na_{ij}x_j=b_j}\)</span>替换成如下两个约束即可：</p><p><span class="math inline">\(\begin{aligned} \sum_{j=1}^n a_{ij}x_j&amp;\le b_i\\ \sum_{j=1}^n a_{ij}x_j &amp;\ge b_i\end{aligned}\)</span></p><h2 id="b">b</h2><p>将不等式约束<span class="math inline">\(\displaystyle{\sum_{j=1}^na_{ij}x_j\le b_j}\)</span>替换成如下两个约束即可：</p><p><span class="math inline">\(\begin{aligned} \sum_{j=1}^n a_{ij}x_j&amp;= b_i-s\\ s&amp;\ge 0 \end{aligned}\)</span></p><h1 id="section-6">29.1-7</h1><p>如果当前是对某个目标函数<span class="math inline">\(f(x)\)</span>最小化，那么其等价的最大化线性约束就是对目标函数<span class="math inline">\(g(x)=-f(x)\)</span>最大化。</p><p>令<span class="math inline">\(S\)</span>是第一个线性规划的可行域，<span class="math inline">\(x_0\in S\)</span>是其一个最优解。这意味着<span class="math inline">\(\forall x\in S\)</span>，都有<span class="math inline">\(f(x)\ge f(x_0)\)</span>。代入<span class="math inline">\(g(x)=-f(x)\)</span>，那么有<span class="math inline">\(f\forall x \in S\)</span>，均有<span class="math inline">\(g(x)\leg(x_0)\)</span>。因此，原线性规划和新线性规划是等价的。</p><h1 id="section-7">29.1-8</h1><p>还需要添加如下约束，以确保真实投票人数不会超过人口数：</p><p><span class="math inline">\(\begin{aligned}-2x_1+8x_2+0x_3+10x_4&amp;\le 100\\ 5x_1+2x_2+0x_3+0x_4&amp;\le 200\\3x_1-5x_2+10x_3-2x_4&amp;\le 50\\ \end{aligned}\)</span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论26 Problems 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/26-Problems/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/26-Problems/</id>
    <published>2023-10-01T11:28:03.000Z</published>
    <updated>2023-10-01T11:51:14.574Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">26-1</h1><h2 id="a">a</h2><p>使用得到<code>P-MAT-VEC-RECURSIVE</code>类似的方法对<code>SUM-ARRAYS</code>进行修改，同样可以得到其基于递归的并行版本<code>SUM-ARRAYS-RECURSIVE</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SUM-ARRAYS-RECURSIVE(A, B, C, i, i&#x27;)</span><br><span class="line">  if i == i&#x27;</span><br><span class="line">    C[i] = A[i] + B[i]</span><br><span class="line">  else</span><br><span class="line">    mid = ⌊(i + i&#x27;) / 2⌋</span><br><span class="line">    spawn SUM-ARRAYS-RECURSIVE(A, B, C, i, mid)</span><br><span class="line">    spawn SUM-ARRAYS-RECURSIVE(A, B, C, mid + 1, i&#x27;)</span><br><span class="line">    sync</span><br></pre></td></tr></table></figure><p>可见这个算法的工作量为<span class="math inline">\(T_1(n)=\Theta(n)\)</span>。由于其递归深度达到<span class="math inline">\(\Theta(\lg n)\)</span>，并且只需要花费<span class="math inline">\(\Theta(1)\)</span>的时间即可完成，因此其持续时间为<span class="math inline">\(T_{\infty}(n)=\Theta(\lgn)\cdot\Theta(1)=\Theta(\lg n)\)</span>。因此的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n/\lgn)\)</span>。</p><h2 id="b">b</h2><p>如果<span class="math inline">\(grain\text{-}size=1\)</span>，那么<span class="math inline">\(r=n\)</span>，<code>SUM-ARRAYS'</code>中的<code>for</code>循环将会串行地执行<span class="math inline">\(n\)</span>次，每次调用<code>ADD-SUBARRAY</code>都只花费<span class="math inline">\(\Theta(1)\)</span>的时间。因此持续时间<span class="math inline">\(T_{\infty}(n)=n\cdot\Theta(1)=\Theta(n)\)</span>。可以知道其工作量为<span class="math inline">\(T_1(n)=\Theta(n)\)</span>，因此其并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(1)\)</span>。</p><h2 id="c">c</h2><p>令<span class="math inline">\(g=grain\text{-}size\)</span>。执行单次<code>ADD-SUBARRAY</code>所需要的时间为<span class="math inline">\(O(g)\)</span>。在<code>SUM-ARRAYS'</code>中，一共需要执行<span class="math inline">\(n/g\)</span>次<code>ADD-SUBARRAY</code>，但是<code>for</code>循环并没有带有<code>parrllel</code>关键字，也就是说，这些调用<code>ADD-SUBARRAY</code>的线程是按顺序启动的，它们并非同时启动的，因此这里仍然需要花费<span class="math inline">\(O(n/g)\)</span>的时间完成这个<code>for</code>循环。</p><p>因此，<code>SUM-ARRAYS'</code>需要花费<span class="math inline">\(O(g+n/g)\)</span>的时间完成。令<span class="math inline">\(f(g)=g+n/g\)</span>，那么有<span class="math inline">\(f&#39;(g)=1-n/g^2\)</span>。令<span class="math inline">\(f&#39;(g)=00\)</span>，即<span class="math inline">\(g=\sqrt{n}\)</span>时，<code>SUM-ARRAYS'</code>只需要花费<span class="math inline">\(O(\sqrt{n})\)</span>的时间就可以完成。</p><h1 id="section-1">26-2</h1><h2 id="a-1">a</h2><p>修改后的代码由<code>P-MATRIX-MULTIPLY-RECURSIVE'</code>所示，它消去了临时矩阵<span class="math inline">\(D\)</span>的存在。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A, B, C, n)</span><br><span class="line">  if n == 1</span><br><span class="line">    c11 = c11 + a11 · b11</span><br><span class="line">    return</span><br><span class="line">  partition A, B, C, and D into n/2 × n/2 submatrices A11, A12, A21, A22; B11, B12, B21, B22; and C11, C12, C21, C22; respectively</span><br><span class="line">  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A11, B11, C11, n / 2)</span><br><span class="line">  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A11, B12, C12, n / 2)</span><br><span class="line">  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A21, B11, C21, n / 2)</span><br><span class="line">  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A21, B12, C22, n / 2)</span><br><span class="line">  sync</span><br><span class="line">  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A12, B21, C11, n / 2)</span><br><span class="line">  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A12, B22, C12, n / 2)</span><br><span class="line">  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A22, B21, C21, n / 2)</span><br><span class="line">  spawn P-MATRIX-MULTIPLY-RECURSIVE&#x27;(A22, B22, C22, n / 2)</span><br><span class="line">  sync</span><br></pre></td></tr></table></figure><p>可见，它的串行投影是<code>MATRIX-MULTIPLY-RECURSIVE</code>，因此其工作量为<span class="math inline">\(\Theta(n^3)\)</span>。</p><h2 id="b-1">b</h2><p>对于其工作量<span class="math inline">\(T_1(n)\)</span>，可以给出其递推式<span class="math inline">\(T_1(n)=8T_1(n/2)+\Theta(n^2)\)</span>，因此得到<span class="math inline">\(T_1(n)=\Theta(n^3)\)</span>。</p><p>对于其持续时间，除了递归调用，<code>P-MATRIX-MULTIPLY-RECURSIVE'</code>没有再做其它工作。因此可以给出其递推式<span class="math inline">\(T_{\infty}(n)=2T_{\infty}(n/2)+\Theta(1)\)</span>，最终通过主定理可以得知<span class="math inline">\(T_{\infty}(n)=\Theta(n)\)</span>。</p><p>也就是说，算法<code>P-MATRIX-MULTIPLY-RECURSIVE'</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^2)\)</span>。</p><h2 id="c-1">c</h2><p>忽略掉<span class="math inline">\(\Theta\)</span>符号后，对于<span class="math inline">\(1000\times1000\)</span>的矩阵而言，调用<code>P-MATRIX-MULTIPLY-RECURSIVE'</code>的并行度为<span class="math inline">\(10^6\)</span>。相比于调用<code>P-MATRIX-MULTIPLY-RECURSIVE</code>得到<span class="math inline">\(10^7\)</span>的并行度，计算机依旧不会有这么多的处理器，但是在算法的运行时间的常数却明显减少了，因此这种权衡是值得的。</p><h1 id="section-2">26-3</h1><h2 id="a-2">a</h2><p>对<code>LU-DECOMPOSITION</code>修改后得到的并行化版本为<code>P-LU-DECOMPOSITION</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">P-LU-DECOMPOSITION(A, n)</span><br><span class="line">  let L and U be new n × n matrices </span><br><span class="line">  initialize U with 0s below the diagonal</span><br><span class="line">  initialize L with 1s on the diagonal and 0s above the diagonal</span><br><span class="line">  for k = 1 to n</span><br><span class="line">    u_&#123;kk&#125; = a_&#123;kk&#125;</span><br><span class="line">    parallel for i = k + 1 to n</span><br><span class="line">      l_&#123;ik&#125; = a_&#123;ik&#125; / a_&#123;kk&#125;</span><br><span class="line">      u_&#123;ki&#125; = a_&#123;ki&#125;</span><br><span class="line">    parallel for i = k + 1 to n</span><br><span class="line">      parallel for j = k + 1 to n</span><br><span class="line">        a_&#123;ij&#125; = a_&#123;ij&#125; − l_&#123;ik&#125; * u_&#123;kj&#125;</span><br><span class="line">  return L and U</span><br></pre></td></tr></table></figure><p>也就是说，所有内循环都可以进行并行，但是最外层的那一层循环不允许并行。第一个内循环能够并行的原因是：它只读取<span class="math inline">\(a\)</span>矩阵的元素，并修改<span class="math inline">\(L,U\)</span>对应行和对应列的元素，并不会进行多次存取。第二个双重内循环能够并行的原因是第<span class="math inline">\(i\)</span>轮二层循环，第<span class="math inline">\(j\)</span>轮三次循环中，他只会读取<span class="math inline">\(L,U\)</span>矩阵的值并且修改<span class="math inline">\(a_{ij}\)</span>的值，不会造成冲突。外层循环不能是并行的原因是按照LU分解的定义，后一次的运行依赖于前一次的结果。</p><p><code>P-LU-DECOMPOSITION</code>的串行投影是<code>LU-DECOMPOSITION</code>，因此其工作量为<span class="math inline">\(T_1(n)=\Theta(n^3)\)</span>。</p><p>对于<code>P-LU-DECOMPOSITION</code>的持续时间，第一层的第一次内循环花费的时间是<span class="math inline">\(\Theta(\lg(n-k))=\Theta(\lgn)\)</span>，因为转化成<code>spawn ... sync</code>结构后就变成了分支法，然后进行递归。第二次的两个双重嵌套寻呼按的原因相同，其花费的时间为<span class="math inline">\(\Theta(\lg(n-k))+\Theta(\lg(n-k))=\Theta(\lgn)\)</span>。因此，外层<code>for</code>循环需要<span class="math inline">\(\Theta(\lgn)\)</span>的时间完成一次。最终，<code>P-LU-DECOMPOSITION</code>的持续时间为<span class="math inline">\(T_{\infty}(n)=n\cdot \Theta(\lg n)=\Theta(n\lgn)\)</span>。</p><p>最终我们可以计算出<code>P-LU-DECOMPOSITION</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^2/\lgn)\)</span>。</p><h2 id="b-2">b</h2><p>对<code>LUP-DECOMPOSITION</code>修改后得到的并行化版本为<code>P-LUP-DECOMPOSITION</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">P-LUP-DECOMPOSITION(A, n)</span><br><span class="line">  let π[1 : n] be a new array</span><br><span class="line">  parallel for i = 1 to n</span><br><span class="line">    π[i] = i</span><br><span class="line">  for k = 1 to n</span><br><span class="line">    p = 0</span><br><span class="line">    parallel for i = k to n</span><br><span class="line">      if |a_&#123;ik&#125;| &gt; p</span><br><span class="line">        p = |a_&#123;ik&#125;|</span><br><span class="line">        k&#x27; = i</span><br><span class="line">    if p == 0</span><br><span class="line">      error &quot;singular matrix&quot;</span><br><span class="line">    exchange π[k] with π[k&#x27;]</span><br><span class="line">    parallel for i = 1 to n</span><br><span class="line">      exchange a_&#123;ki&#125; with a_&#123;k&#x27;i&#125; </span><br><span class="line">    parallel for i = k + 1 to n</span><br><span class="line">      a_&#123;ik&#125; = a_&#123;ik&#125; / a_&#123;kk&#125;</span><br><span class="line">      parallel for j = k + 1 to n</span><br><span class="line">        a_&#123;ij&#125; = a_&#123;ij&#125; − a_&#123;ik&#125; * a_&#123;kj&#125;</span><br></pre></td></tr></table></figure><p>第2行的<code>for</code>循环可以并行，这是显而易见的。第6-9行的<code>for</code>循环是可以并行的，因为这是寻找一个最大值，在这个过程中，<span class="math inline">\(n\)</span>个元素构成一棵<span class="math inline">\(n\)</span>个叶节点的二叉树，对于内部节点，它是两个子节点中的最大值，由于这棵树的深度为<span class="math inline">\(\Theta(\lgn)\)</span>，因此这段循环的持续时间为<span class="math inline">\(\Theta(\lgn)\)</span>。第13行的<code>for</code>循环用于交换两行元素，显而易见是可以并行的。对于第15行和17行的<code>for</code>循环，第16行仅仅是对<span class="math inline">\(a_{ik}\)</span>进行更新，此后都是对<span class="math inline">\(a_{ij}(j&gt;k)\)</span>中的所有元素进行更新。至于先对哪一行操作都是没有关系的，因此第15行和17行的<code>for</code>循环它们都可以并行。外面针对<span class="math inline">\(k\)</span>的<code>for</code>循环不能并行，因为会导致数据读取冲突。</p><p><code>P-LUP-DECOMPOSITION</code>的串行投影是<code>LUP-DECOMPOSITION</code>，因此其工作量为<span class="math inline">\(T_1(n)=\Theta(n^3)\)</span>。</p><p>对于<code>P-LUP-DECOMPOSITION</code>的持续时间，分析和<code>P-LU-DECOMPOSITION</code>非常相似。第6，13，15，17行的<code>for</code>循环都可以进行，因此这部分只使用<span class="math inline">\(\Theta(\lgn)\)</span>的时间即可完成。最终，<code>P-LUP-DECOMPOSITION</code>的持续时间为<span class="math inline">\(T_{\infty}(n)=n\cdot \Theta(\lg n)=\Theta(n\lgn)\)</span>。</p><p>最终我们可以计算出<code>P-LUP-DECOMPOSITION</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^2/\lgn)\)</span>。</p><h2 id="c-2">c</h2><p>对<code>LUP-SOLVE</code>修改后得到的并行化版本为<code>P-LUP-SOLVE</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">P-LUP-SOLVE(L, U, π, b, n)</span><br><span class="line">  let x and y be new vectors of length n</span><br><span class="line">  for i = 1 to n</span><br><span class="line">    val = 0</span><br><span class="line">    parallel for j = 1 to i - 1</span><br><span class="line">      val = val + l_&#123;ij&#125; * y_j</span><br><span class="line">    y_i = b_&#123;π[i]&#125; - val</span><br><span class="line">  for i = n downto 1</span><br><span class="line">    val = 0</span><br><span class="line">    parallel for j = i + 1 to n</span><br><span class="line">      val = val + u_&#123;ij&#125; * x_j</span><br><span class="line">    x_i = (y_u - val) / u_&#123;ii&#125;</span><br><span class="line">  return x</span><br></pre></td></tr></table></figure><p>第4和9行的<code>for</code>循环可以并行，只需要将长度为<span class="math inline">\(n\)</span>的序列构造出一棵<span class="math inline">\(n\)</span>个叶子节点的完全二叉树即可，对于内部节点，它是两个子节点中的值之和。因此，这两个内部<code>for</code>循环都能够在<span class="math inline">\(\Theta(\lgn)\)</span>的时间内完成。对于第2和7行的<code>for</code>循环，因为后面计算<span class="math inline">\(x,y\)</span>值需要依赖前面已经计算出的<span class="math inline">\(x,y\)</span>值。</p><p>最终，<code>P-LUP-SOLVE</code>的串行投影即为<code>LUP-SOLVE</code>，因此其工作量为<span class="math inline">\(T_1(n)=\Theta(n^2)\)</span>。按照上面的结论，可以得到持续时间<span class="math inline">\(T_{\infty}(n)=n\cdot \Theta(\lg n)=\Theta(n\lgn)\)</span>。最终我们可以计算出<code>P-LUP-SOLVE</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n/\lgn)\)</span>。</p><h2 id="d">d</h2><p>一个对正定矩阵求逆的并行算法由<code>P-MATRIX-INVERSION-POSITIVE-DEFINITE</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">P-MATRIX-INVERSION-POSITIVE-DEFINITE(A, n)</span><br><span class="line">  partition A into n/2 × n/2 submatrices B, CT, C, D; respectively</span><br><span class="line">  let W[1 : n, 1 : n], X[1 : n, 1 : n], Y[1 : n, 1 : n], Z[1 : n, 1 : n], S[1 : n, 1 : n] be new matrices</span><br><span class="line">  B&#x27; = P-MATRIX-INVERSION-POSITIVE-DEFINITE(B, n / 2)</span><br><span class="line">  W = P-MATRIX-MULTIPLY(C, B&#x27;, W, n / 2)</span><br><span class="line">  WT = W</span><br><span class="line">  P-TRANSPOSE(WT, n / 2)</span><br><span class="line">  P-MATRIX-MULTIPLY(W, CT, X, n / 2)</span><br><span class="line">  S = D - X</span><br><span class="line">  S&#x27; = P-MATRIX-INVERSION-POSITIVE-DEFINITE(S, n / 2)</span><br><span class="line">  P-MATRIX-MULTIPLY(S&#x27;, W, Y, n / 2)</span><br><span class="line">  YT = Y</span><br><span class="line">  P-TRANSPOSE(YT, n / 2)</span><br><span class="line">  P-MATRIX-MULTIPLY(WT, y, Z)</span><br><span class="line">  R = B&#x27; + Z</span><br><span class="line">  A&#x27; = [[R, -YT], [-Y, S&#x27;]]</span><br><span class="line">  return A&#x27;</span><br></pre></td></tr></table></figure><p>按照第28.2章的结论以及不等式28.15，可以知道其工作量<span class="math inline">\(I_1(n)\le2I_1(n/2)+4M_1(n/2)+O(n^2)\)</span>，最终得到<span class="math inline">\(I_1(n)=O(M(n))\)</span>。</p><p>在并行版本中，由题目26.1-8，26.2-3和题26-1-a可知，矩阵的转置、加法和乘法都可以在<span class="math inline">\(\Theta(\lgn)\)</span>时间内完成。在<code>P-MATRIX-INVERSION-POSITIVE-DEFINITE</code>中，一共进行了<span class="math inline">\(2\)</span>次矩阵转置，<span class="math inline">\(4\)</span>次矩阵加减法，<span class="math inline">\(4\)</span>次矩阵乘法。同样的，它们还进行了<span class="math inline">\(2\)</span>次大小为<span class="math inline">\(n/2\timesn/2\)</span>矩阵的求逆。可见，这些步骤都是依赖于前一步的结果，因此步骤之间不能直接并行。我们可以写出它的持续时间<span class="math inline">\(I_{\infty}(n)\)</span>满足<span class="math inline">\(I_{\infty}(n)=2I_{\infty}(n/2)+10\cdot\Theta(\lgn)\)</span>，因此最终得到<span class="math inline">\(I_{\infty}(n)=\Theta(n)\)</span>。</p><p>最终我们可以得到它的并行度为<span class="math inline">\(I_1(n)/I_{\infty}(n)=O(M(n)/n)\)</span>。</p><h1 id="section-3">26-4</h1><h2 id="a-3">a</h2><p>设计的<code>P-REDUCE</code>如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">P-REDUCE(x, i, j)</span><br><span class="line">  if i == j</span><br><span class="line">    return x[i]</span><br><span class="line">  else</span><br><span class="line">    mid = ⌊(i + j) / 2⌋</span><br><span class="line">    l = spawn P-REDUCE(x, i, mid)</span><br><span class="line">    r = spawn P-REDUCE(x, mid + 1, j)</span><br><span class="line">    sync</span><br><span class="line">    return l ⊗ r</span><br></pre></td></tr></table></figure><p>不难发现它的串行投影即为<code>REDUCE</code>，因此它的工作量为<span class="math inline">\(T_1(n)=\Theta(n)\)</span>。由于这棵进行搜索的二叉树的深度为<span class="math inline">\(\Theta(\lgn)\)</span>，因此这个算法的持续时间为<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)\)</span>。</p><h2 id="b-3">b</h2><p>这个算法相当于是以<span class="math inline">\(k=1,2,\dots,n\)</span>对<code>P-REDUCE</code>都进行了一次调用。因此<code>P-SCAN-1</code>的工作量为<span class="math inline">\(\displaystyle{T_1(n)=\sum_{k=1}^n\Theta(k)=\Theta(n^2)}\)</span>。</p><p>接下来求解<code>P-SCAN-1</code>的持续时间。由于对<code>P-SCAN-1</code>对<code>P-REDUCE</code>的间接调用呈树形，假设伪代码中，第<span class="math inline">\(i\)</span>次对<code>P-REDUCE</code>的调用的持续时间为<span class="math inline">\(iter(i)\)</span>，那么有<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)+\max\{iter(i):1\lei\le n\}\)</span>，按照题目26-4-a的结论，有<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)\)</span>。</p><p>因此<code>P-SCAN-1</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^2/\lgn)\)</span>。</p><h2 id="c-3">c</h2><p>我们可以使用归纳法进行证明其正确性。即证明，调用<code>P-SCAN-2-AUX(i, j)</code>，对于<span class="math inline">\(\forall k\in[i,j]\)</span>，它都正确计算出了<span class="math inline">\(y[k]=x[i]\otimes x[i+1]\otimes\dots\otimesx[k]\)</span>。</p><p>对于基本情况：<span class="math inline">\(i=j\)</span>，<code>P-SCAN-2-AUX</code>都正确计算出了<span class="math inline">\(y\)</span>数组，这由<code>P-SCAN-2-AUX</code>的前两行明显可知。</p><p>当<span class="math inline">\(i&lt;j\)</span>时，假设对于区间<span class="math inline">\([i,j]\)</span>内的所有真子区间<span class="math inline">\([i&#39;,j&#39;]\)</span>，即<span class="math inline">\(i\le i&#39;\le j&#39;\le j\)</span>，且<span class="math inline">\(i=i&#39;,j=j&#39;\)</span>不同时成立，<code>P-SCAN-2-AUX</code>都计算出了正确的结果。那么第三行得到了一个<span class="math inline">\(k=\lfloor(i+j)/2\rfloor\)</span>。对于第4和5行的代码，它们分别对<span class="math inline">\(y\)</span>数组的区间<span class="math inline">\([i,k]\)</span>和<span class="math inline">\([k+1,j]\)</span>进行写入，并且读取的内容也不相交，因此这两行代码不会构成竞争。在第6行结束后，<span class="math inline">\(y\)</span>数组满足：如果<span class="math inline">\(p\le k\)</span>，那么<span class="math inline">\(y[p]=x[i]\otimes x[i+1]\otimes\dots\otimesx[p]\)</span>，否则<span class="math inline">\(y[p]=x[k+1]\otimesx[k+2]\otimes\dots\otimes x[k]\)</span>。对于<span class="math inline">\(p&gt;k\)</span>的情况，第8行将<span class="math inline">\(y[p]\)</span>重新赋值成<span class="math inline">\(y[k]\otimes y[p]\)</span>。这个步骤完成后，<span class="math inline">\(\forall p\in[i,j]\)</span>，都有<span class="math inline">\(y[p]=x[i]\otimes x[i+1]\otimes\dots\otimesx[p]\)</span>。因此<code>P-SCAN-2-AUX</code>是正确的。</p><p>接下来考虑<code>P-SCAN-2-AUX</code>的工作量<span class="math inline">\(T_1(n)\)</span>，消去最后的<code>for</code>循环中的<code>parallel</code>关键字后，那么除去递归部分，它的运行时间是<span class="math inline">\(\Theta(n)\)</span>。因此可以写出<span class="math inline">\(T_1(n)=2T_1(n/2)+\Theta(n)\)</span>，从而得到<span class="math inline">\(T_1(n)=\Theta(n\lg n)\)</span>。</p><p>接下来考虑其持续时间<span class="math inline">\(T_{\infty}(n)\)</span>。可见出了递归部分，其余部分仍然需要<span class="math inline">\(\Theta(\lg n)\)</span>进行。因此有<span class="math inline">\(T_{\infty}(n)=T_{\infty}(n/2)+\Theta(\lgn)\)</span>，最终得到<span class="math inline">\(T_{\infty}(n)=\Theta(\lg^2n)\)</span>。</p><p>因此<code>P-SCAN-2</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n/\lgn)\)</span>。</p><h2 id="d-1">d</h2><p><code>P-SCAN-UP</code>第8行填入的是$<code>right ⊗ t[k]</code>；<code>P-SCAN-DOWN</code>的第5行填入<code>v</code>，第6行填入<code>v ⊗ t[k]</code>。</p><p>需要注意的是，<span class="math inline">\(t[k]\)</span>存储的是当一个区间<span class="math inline">\([i,j]\)</span>被尽量均匀地划分成两个区间<span class="math inline">\([i,k],[k+1,j]\)</span>后，<span class="math inline">\(t[k]\)</span>就是记录区间<span class="math inline">\([i,j]\)</span>前面一半元素（即<span class="math inline">\([i,k]\)</span>）的元素之和<span class="math inline">\(t[k]=x[i]\otimes x[i+1]\otimes\dots\otimesx[k]\)</span>。</p><p>首先证明，调用时每个<span class="math inline">\(t[k]\)</span>最多只会被赋值一次（因此，在执行<code>P-SCAN-DOWN</code>时不会造成任何冲突）。只有调用<code>P-SCAN-UP</code>，当<span class="math inline">\(i&lt;j\)</span>时，才会对<span class="math inline">\(t[k]\)</span>进行赋值，在此之后更深的递归讲不会再对<span class="math inline">\(t[k]\)</span>进行赋值，原因如下。如果递归的区间是左半子区间<span class="math inline">\([i,k]\)</span>，那么对于所有<span class="math inline">\([i,k]\)</span>的长度大于等于<span class="math inline">\(2\)</span>的（等于<span class="math inline">\(1\)</span>则不会进入到这个分支）真子区间<span class="math inline">\([i&#39;,k&#39;]\)</span>，都有<span class="math inline">\(\lfloor(i&#39;+k&#39;)/2\rfloor&lt;k\)</span>，因此<span class="math inline">\(t[k]\)</span>不会被重复赋值；如果递归的是右子区间<span class="math inline">\([k+1,j]\)</span>，那么它的访问和读写只会在这个区间内进行，更不会对<span class="math inline">\(t[k]\)</span>进行访问。因此，<span class="math inline">\(t[k]\)</span>确实能够正确记录区间<span class="math inline">\([i,j]\)</span>的信息。根据<code>P-SCAN-DOWB</code>的第5行代码，就可以知道<span class="math inline">\(t[k]\)</span>记录的是区间i,j的左半区间的元素之和。并且，<code>P-SCAN-UP</code>的返回值是<span class="math inline">\([i,j]\)</span>这个区间的所有元素之和，因此结论成立。</p><p>接下来证明每次调用<code>P-SCAN-DOWN(v, x, t, y, i, j)</code>时，总满足<span class="math inline">\(v=x[1]\otimes x[2]\otimes\dots\otimesx[i-1]\)</span>。同样使用归纳法来证明。在<code>P-SCAN-3</code>调用<code>P-SCAN-DOWN</code>时，有<span class="math inline">\(v=x[1],i=2\)</span>，因此基本情况下是成立的。<code>P-SCAN-DOWN</code>首先调用<code>P-SCAN-DOWN(v, x, t, y, i, k)</code>，由于参数<span class="math inline">\(i\)</span>没有变化，因此<span class="math inline">\(v\)</span>仍然使用原来的<span class="math inline">\(v\)</span>，原结论成立；然后调用<code>P-SCAN-DOWN(v ⊗ t[k], x, t, y, k + 1, j)</code>，由于此时<span class="math inline">\(t[k]=x[i]\otimes x[i+1]\otimes\dots\otimesx[k]\)</span>，因此有<span class="math inline">\(v\otimest[k]=x[1]\otimes x[2]\otimes\dots\otimesx[k]\)</span>。因此第二次调用时同样满足题目的条件。因此当<code>P-SCAN-DOWN</code>进入第2行后，<code>y[i] = v ⊗ x[i]</code>则是<span class="math inline">\(y[i]=x[1]\otimes x[2]\otimes\dots\otimesx[i]\)</span>，<span class="math inline">\(y[i]\)</span>被正确地计算出来。</p><p>因此，算法<code>P-SCAN-3</code>是正确的。</p><h2 id="e">e</h2><p>可以发现，这棵树的节点数仍然是<span class="math inline">\(\Theta(n)\)</span>，因此<code>P-SCAN-3</code>的工作量<span class="math inline">\(T_1(n)=\Theta(n)\)</span>。</p><p>接下来首先考虑<code>P-SCAN-UP</code>。由于其每次划分出了两个长度尽量均等的区间，并且其余处理部分都只要<span class="math inline">\(\Theta(1)\)</span>的时间，因此<code>P-SCAN-UP</code>这段代码的持续时间满足<span class="math inline">\(T_{\infty}(n)=T_{\infty}(n/2)+\Theta(1)\)</span>，从而得到<span class="math inline">\(T_{\infty}(n)=\Theta(\lgn)\)</span>。<code>P-SCAN-DOWN</code>和<code>P-SCAN-UP</code>的结构基本相同，因此对其分析也一样。</p><p>最终，<code>P-SCAN-3</code>的持续时间为<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)\)</span>。</p><p>因此，<code>P-SCAN-3</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n/\lgn)\)</span>。</p><h2 id="f">f</h2><p>修改后的<code>P-SCAN-3</code>由<code>P-SCAN-3'</code>给出。代价是并发度将会降低。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">P-SCAN-3&#x27;(x, n)</span><br><span class="line">  let y[1 : n] be a new array</span><br><span class="line">  y[1] = x[1]</span><br><span class="line">  if n &gt; 1</span><br><span class="line">    P-SCAN-3-AUX(x[1], x, y, 2, n)</span><br><span class="line">  return y</span><br><span class="line"></span><br><span class="line">P-SCAN-SUM-ARRAYS(x, i, j)</span><br><span class="line">  if i == j</span><br><span class="line">    return x[i]</span><br><span class="line">  else</span><br><span class="line">    k = ⌊(i + j) / 2⌋</span><br><span class="line">    l = spawn P-SCAN-SUM-ARRAYS(x, t, i, k)</span><br><span class="line">    r = P-SCAN-SUM-ARRAYS(x, t, k + 1, j)</span><br><span class="line">    return l ⊗ r</span><br><span class="line"></span><br><span class="line">P-SCAN-3-AUX(v, x, y, i, j)</span><br><span class="line">  if i == j</span><br><span class="line">    y[i] = v ⊗ x[i]</span><br><span class="line">  else</span><br><span class="line">    k = ⌊(i + j) / 2⌋</span><br><span class="line">    spawn P-SCAN-3-AUX(v, x, y, i, k)</span><br><span class="line">    t = P-SCAN-SUM-ARRAYS(x, i, k)</span><br><span class="line">    P-SCAN-3-AUX(v ⊗ t, x, y, k + 1, j)</span><br><span class="line">    sync</span><br></pre></td></tr></table></figure><h2 id="star-g"><span class="math inline">\(\star\)</span> g</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">P-SCAN-4(x, n)</span><br><span class="line">  l = 1</span><br><span class="line">  while l &lt;= n</span><br><span class="line">    parallel for i = 1 to n by l * 2</span><br><span class="line">      parallel j = 0 to l - 1</span><br><span class="line">        if i + l + j &lt;= n</span><br><span class="line">          x[i + l + j] = x[i + l + j] + x[i + l - 1]</span><br><span class="line">    l = l * 2</span><br></pre></td></tr></table></figure><p>这个算法的基本思想是，将<span class="math inline">\(x\)</span>分成<span class="math inline">\(\lceiln/(2l)\rceil\)</span>块，每一块的长度为<span class="math inline">\(2l\)</span>（最后一块不足<span class="math inline">\(2l\)</span>也以一块记），并且<span class="math inline">\(l\)</span>是<span class="math inline">\(2\)</span>的幂。一开始<span class="math inline">\(l=1\)</span>，将前半块的最后一个元素<span class="math inline">\(x[i+l-1]\)</span>添加到后半块<span class="math inline">\(x[i+l+j](0\lej&lt;l)\)</span>中的每一个元素。从而最终完成后，每一块内部都是对应值的前缀和。可见两个<code>parallel for</code>循环不会导致冲突，因此这个算法的持续时间为<span class="math inline">\(T_{\infty}(n)=\Theta(\lg^2n)\)</span>。</p><h2 id="h">h</h2><p>将字符串中的<code>(</code>视为<span class="math inline">\(+1\)</span>，<code>')'</code>视为<span class="math inline">\(-1\)</span>，得到一个数组<span class="math inline">\(x\)</span>，求出其前缀和<span class="math inline">\(y\)</span>。那么一个括号字符串是合法的，当且仅当<span class="math inline">\(\forall i\in[1,n],y_i\ge 0\)</span>，并且有<span class="math inline">\(y_n=0\)</span>。通过对<code>P-SCAN-3</code>进行改造，我们可以得到一个在<span class="math inline">\(\Theta(\lgn)\)</span>时间内判断一个括号字符串是否合法的程序<code>PARENTHESES-IS-WELL-FORMED</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">PARENTHESES-IS-WELL-FORMED(s, n)</span><br><span class="line">  let y[0 : n] and t[1 : n] be new arrays</span><br><span class="line">  y[0] = 0</span><br><span class="line">  P-SCAN-UP&#x27;(s, t, 1, n)</span><br><span class="line">  mn = P-SCAN-DOWN&#x27;(0, s, t, y, 1, n)</span><br><span class="line">  return mn &gt;= 0 and y[n] == 0</span><br><span class="line"></span><br><span class="line">P-SCAN-UP&#x27;(s, t, i, j)</span><br><span class="line">  if i == j</span><br><span class="line">    if s[i] == &#x27;(&#x27;</span><br><span class="line">      return 1</span><br><span class="line">    else</span><br><span class="line">      return -1</span><br><span class="line">  else</span><br><span class="line">    k = ⌊(i + j) / 2⌋</span><br><span class="line">    t[k] = spawn P-SCAN-UP&#x27;(s, t, i, k)</span><br><span class="line">    right = P-SCAN-UP&#x27;(s, t, k + 1, j)</span><br><span class="line">    sync</span><br><span class="line">    return t[k] + right</span><br><span class="line"></span><br><span class="line">P-SCAN-DOWN&#x27;(v, s, t, y, i, j)</span><br><span class="line">  if i == j</span><br><span class="line">    y[i] = v + x[i]</span><br><span class="line">    return y[i]</span><br><span class="line">  else</span><br><span class="line">    k = ⌊(i + j) / 2⌋</span><br><span class="line">    l = spawn P-SCAN-DOWN (v, x, t, y, i, k)</span><br><span class="line">    r = P-SCAN-DOWN(v + t[k], x, t, y, k + 1, j)</span><br><span class="line">    sync</span><br><span class="line">    return min&#123;l, r&#125;</span><br></pre></td></tr></table></figure><p>改造后的程序还返回了前缀和数组中的最小值。</p><h1 id="section-4">26-5</h1><h2 id="a-4">a</h2><p>不失一般性，这里假设矩阵<span class="math inline">\(A\)</span>的大小<span class="math inline">\(n\)</span>是<span class="math inline">\(2\)</span>的幂次。基于等式26.9，那么对矩阵<span class="math inline">\(A\)</span>的填充并行分治算法由<code>SIMPLE-STENCIL</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SIMPLE-STENCIL(A, n)</span><br><span class="line">  if n == 1</span><br><span class="line">    generate the value of a11</span><br><span class="line">    return</span><br><span class="line">  partition A into n/2 × n/2 submatrices A11, A12, A21, A22; respectively</span><br><span class="line">  SIMPLE-STENCIL(A11, n / 2)</span><br><span class="line">  spawn SIMPLE-STENCIL(A12, n / 2)</span><br><span class="line">  spawn SIMPLE-STENCIL(A21, n / 2)</span><br><span class="line">  sync</span><br><span class="line">  SIMPLE-STENCIL(A22, n / 2)</span><br></pre></td></tr></table></figure><p>可见这个算法只是为了填充原来矩阵的所有元素，由其串行投影可以知道其工作量满足<span class="math inline">\(T_1(n)=4T_1(n/2)+\Theta(1)\)</span>，可以得到<span class="math inline">\(T_1(n)=\Theta(n^2)\)</span>。</p><p>这个算法的持续时间满足<span class="math inline">\(T_{\infty}(n)=3T_\infty(n/2)+\Theta(1)\)</span>，可以得到<span class="math inline">\(T_{\infty}(n)=\Theta(n^{\lg 3})\)</span>。</p><p>最终可以得到并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^{2-\lg3})\)</span>。</p><h2 id="b-4">b</h2><p>不失一般性，这里假设矩阵<span class="math inline">\(A\)</span>的大小<span class="math inline">\(n\)</span>是<span class="math inline">\(3\)</span>的幂次，那么按照题目26-5-a的结果，我们可以对<code>SIMPLE-STENCIL</code>修改成<code>SIMPLE-STENCIL3</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SIMPLE-STENCIL3(A, n)</span><br><span class="line">  if n == 1</span><br><span class="line">    generate the value of a11</span><br><span class="line">    return</span><br><span class="line">  partition A into n/3 × n/3 submatrices A11, A12, A13, A21, A22, A23, A31, A32, A33; respectively</span><br><span class="line">  SIMPLE-STENCIL3(A11, n / 3)</span><br><span class="line">  spawn SIMPLE-STENCIL3(A12, n / 3)</span><br><span class="line">  spawn SIMPLE-STENCIL3(A21, n / 3)</span><br><span class="line">  sync</span><br><span class="line">  spawn SIMPLE-STENCIL3(A13, n / 3)</span><br><span class="line">  spawn SIMPLE-STENCIL3(A22, n / 3)</span><br><span class="line">  spawn SIMPLE-STENCIL3(A31, n / 3)</span><br><span class="line">  sync</span><br><span class="line">  spawn SIMPLE-STENCIL3(A23, n / 3)</span><br><span class="line">  spawn SIMPLE-STENCIL3(A32, n / 3)</span><br><span class="line">  sync</span><br><span class="line">  SIMPLE-STENCIL3(A33, n / 3)</span><br></pre></td></tr></table></figure><p>和题目26-3-a分析的过程类似，可以知道其工作量满足<span class="math inline">\(T_1(n)=9T_1(n/3)+\Theta(1)\)</span>，可以得到<span class="math inline">\(T_1(n)=\Theta(n^2)\)</span>。</p><p>这个算法的持续时间满足<span class="math inline">\(T_{\infty}(n)=5T_\infty(n/3)+\Theta(1)\)</span>，可以得到<span class="math inline">\(T_{\infty}(n)=\Theta(n^{\log_3 5})\)</span>。</p><p>最终可以得到并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^{2-\log_35})\)</span>。</p><h2 id="c-4">c</h2><p>利用类似的方式修改题目26-5-a和26-5-b的代码，可以给出<code>SIMPLE-STENCIL-B</code>代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SIMPLE-STENCIL-B(A, n)</span><br><span class="line">  if n == 1</span><br><span class="line">    generate the value of a11</span><br><span class="line">    return</span><br><span class="line">  partition A into n/b × n/b submatrices A11, A12, ..., A1b, A21, A22, ..., A2b, ...,  Ab1, Ab2, ..., Abb; respectively</span><br><span class="line">  for k = 2 to b * b</span><br><span class="line">    //注意这里的parallel for 循环将是以硬编码的形式构造出来，因此后面的分析不会对Θ(lg n)这个因子进行考虑。</span><br><span class="line">    parallel for i = 1 to b</span><br><span class="line">      j = k - i</span><br><span class="line">      if 1 &lt;= j and j &lt;= b</span><br><span class="line">      SIMPLE-STENCIL3(Aij, n / b)</span><br></pre></td></tr></table></figure><p>和题目26-3-a和26-3-b分析的过程类似，可以知道其工作量满足<span class="math inline">\(T_1(n)=b^2T_1(n/b)+\Theta(1)\)</span>，可以得到<span class="math inline">\(T_1(n)=\Theta(n^2)\)</span>。</p><p>这个算法的持续时间满足<span class="math inline">\(T_{\infty}(n)=(2b-1)T_\infty(n/b)+\Theta(1)\)</span>，可以得到<span class="math inline">\(T_{\infty}(n)=\Theta(n^{\log_b(2b-1)})\)</span>。</p><p>最终可以得到并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^{2-\log_b(2b-1)})\)</span>。</p><p>为了证明<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^{2-\log_b(2b-1)})=o(n)\)</span>，那么需要证明<span class="math inline">\(f\forallb\ge 2\)</span>，都有<span class="math inline">\(2-\log_b(2b-1)&lt;1\)</span>，即证明<span class="math inline">\(\log_b(2b-1)&gt;1\)</span>。由于<span class="math inline">\(\forall b\ge 2\)</span>，都有<span class="math inline">\(2b-1&gt;b\)</span>，因此<span class="math inline">\(\log_b(2b-1)&gt;1\)</span>成立是很显然的。因此有<span class="math inline">\(T_1(n)/T_{\infty}(n)=o(n)\)</span>。</p><h2 id="d-2">d</h2><p>这个算法由<code>STENCIL</code>给出，并且它还能对更一般形式的矩阵进行填充。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">STENCIL(A, n)</span><br><span class="line">  for k = 2 to n + n - 1</span><br><span class="line">    up = max&#123;1, k - n&#125;</span><br><span class="line">    down = min&#123;n, k - 1&#125;</span><br><span class="line">    parallel for i = up to down</span><br><span class="line">      j = k - i</span><br><span class="line">      generate the value of aij</span><br></pre></td></tr></table></figure><p>可以知道<code>STENCIL</code>的工作量是<span class="math inline">\(T_1(n)=\Theta(n^2)\)</span>，因为它仅仅是从小到大枚举矩阵的每条副对角线，并按顺序填入一个个元素。</p><p>可以知道<code>STENCIL</code>的持续时间满足<span class="math inline">\(T_\infty(n)=n\cdot\Theta(\lg n)=\Theta(n\lgn)\)</span>。因为第<span class="math inline">\(k\)</span>轮迭代最多也只会进行<span class="math inline">\(n\)</span>次操作。如果去掉关键字<code>parallel</code>关键字并转化为<code>spawn ... sync</code>结构，那么这一部分需要花费<span class="math inline">\(\Theta(\lg n)\)</span>的时间。</p><p>因此，<code>STENCIL</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n/\lgn)\)</span>。</p><p>如果需要达到<span class="math inline">\(\Theta(n)\)</span>的并行度，那么可以将<code>parallel for</code>循环转化成硬编码形式，从而去掉这个<code>parallel for</code>循环，并且一次性在<span class="math inline">\(\Theta(1)\)</span>的时间内生产<span class="math inline">\(\Theta(n)\)</span>个元素，从而使并行度提升到<span class="math inline">\(\Theta(n)\)</span>。但是这里使用了<code>parallel for</code>循环，它是基于分治法实现的，因此达不到这个最大并行度。</p><h1 id="section-5">26-6</h1><h2 id="a-5">a</h2><p>工作量定律将改写成<span class="math inline">\(E[T_P]\geE[T_1]/P\)</span>；持续时间定律将改写成<span class="math inline">\(E[T_P]\geE[T_{\infty}]\)</span>；贪心调度界限改写成<span class="math inline">\(E[T_P]\le E[T_1]/P+E[T_{\infty}]\)</span>。</p><h2 id="b-5">b</h2><p>按照题目给出的数据，令<span class="math inline">\(P=10000\)</span>，那么可以写出以下三条式子：</p><p><span class="math inline">\(\begin{aligned} E[T_1]&amp;=10^4\cdot0.01+10^9\cdot 0.99\\ E[T_P]&amp;=1\cdot 0.01+10^9\cdot0.99\\E[T_1/T_P]&amp;=\dfrac{10^4}{1}\cdot0.01+\dfrac{10^9}{10^9}\cdot0.99\\\end{aligned}\)</span></p><p>从而得到<span class="math inline">\(E[T_1/T_P]\approx100,\dfrac{E[T_1]}{E[T_P]}\approx1\)</span>。</p><p>选用<span class="math inline">\(\dfrac{E[T_1]}{E[T_P]}\)</span>的原因有如下两个：</p><ol type="1"><li><p>由于在绝大多数时间中，无论是<span class="math inline">\(P=1\)</span>还是<span class="math inline">\(P=10000\)</span>，其运行时间大多数都在<span class="math inline">\(10^9\)</span>，因此说明这个添加到<span class="math inline">\(P=10000\)</span>的操作应该对加速作用不大，因此选用<span class="math inline">\(\dfrac{E[T_1]}{E[T_P]}\)</span>是一个比较恰当的值。</p></li><li><p><span class="math inline">\(T_1/T_P\)</span>这个随机变量并不成立。题目中没有提到<span class="math inline">\(T_1=10^4\)</span>和<span class="math inline">\(T_1=10^9\)</span>的时机是否和<span class="math inline">\(T_P=1\)</span>和<span class="math inline">\(T_P=10^9\)</span>的时机相同。也就是说，它们不一定是相关的。因此采用独立计算更加合适，即选用<span class="math inline">\(\dfrac{E[T_1]}{E[T_P]}\)</span>。</p></li></ol><h2 id="c-5">c</h2><p>当<span class="math inline">\(P\)</span>趋于无穷时，期望的加速比应该和并行度相等。这和题目26-6-b使用的定义是一致的。</p><h2 id="d-3">d</h2><p>我们可以对第7.3章提到的<code>RANDOMIZED-QUICKSORT</code>算法提出其并行化版本<code>P-RANDOMIZED-QUICKSORT</code>（按照题目要求，不对<code>RANDOMIZED-PARTITION</code>并行化）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">P-RANDOMIZED-QUICKSORT(A, p, r)</span><br><span class="line">  if p &lt; r:</span><br><span class="line">    q = RANDOMIZED-PARTITION(A, p, r)</span><br><span class="line">    spawn P-RANDOMIZED-QUICKSORT(A, p, q - 1)</span><br><span class="line">    spawn P-RANDOMIZED-QUICKSORT(A, q + 1, r)</span><br><span class="line">    sync</span><br></pre></td></tr></table></figure><h2 id="e-1">e</h2><p>可见，<code>P-RANDOMIZED-QUICKSORT</code>的串行投影为<code>RANDOMIZED-QUICKSORT</code>，因此其期望工作量<span class="math inline">\(E[T_1(n)]=O(n\lg n)\)</span>。</p><p>对于<code>P-RANDOMIZED-QUICKSORT</code>持续时间，考虑将<code>P-RANDOMIZED-QUICKSORT</code>和<code>RANDOMIZED-SELECT</code>的行为进行对比。<code>P-RANDOMIZED-QUICKSORT</code>的<code>RANDOMIZED-PARTITION</code>和<code>RANDOMIZED-SELECT</code>中的一样，这部分都是占据了主导的时间<span class="math inline">\(\Theta(n)\)</span>。因此，对其划分的推导也和第9.2章给的完全一样。接下来考虑其递归部分。可以发现，<code>P-RANDOMIZED-QUICKSORT</code>的阶段划分和<code>RANDOMIZED-SELECT</code>也相同，并且证明过程同样也考虑了那个执行时间比较长的执行分支。因此对<code>P-RANDOMIZED-QUICKSORT</code>持续时间<span class="math inline">\(T_{\infty}(n)\)</span>的分析过程和<code>RANDOMIZED-SELECT</code>的分析过程完全一致。按照定理9.2的结论，我们得到<span class="math inline">\(T_{\infty}(n)=\Theta(n)\)</span>。</p><p>因此，<code>P-RANDOMIZED-QUICKSORT</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=O(\lg n)\)</span>。</p><h2 id="f-1">f</h2><p><code>RANDOMIZED-SELECT</code>的并行化版本由<code>P-RANDOMIZED-SELECT</code>给出。其中，给定的<code>P-RANDOMIZED-PARTITION</code>由题目26.3-3的<code>P-PARTITION</code>实现而来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">P-RANDOMIZED-PARTITION(A, p, r)</span><br><span class="line">  i = RANDOM(p, r)</span><br><span class="line">  exchange A[r] with A[i]</span><br><span class="line">  return P-PARTITION(A, p, r)</span><br><span class="line"></span><br><span class="line">P-RANDOMIZED-SELECT(A, p, r, i)</span><br><span class="line">  if p == r</span><br><span class="line">    return A[p]</span><br><span class="line">  q = P-RANDOMIZED-PARTITION(A, p, r)</span><br><span class="line">  k = q – p + 1</span><br><span class="line">  if i == k</span><br><span class="line">    return A[q]</span><br><span class="line">  else if i &lt; k</span><br><span class="line">    return P-RANDOMIZED-SELECT(A, p, q – 1, i)</span><br><span class="line">  else </span><br><span class="line">    return P-RANDOMIZED-SELECT(A, q + 1, r, i – k)</span><br></pre></td></tr></table></figure><p>可见这个算法的串行投影为<code>RANDOMIZED-SELECT</code>，因此它的工作量为<span class="math inline">\(T_1(n)=\Theta(n)\)</span>。</p><p>令示性遍历<span class="math inline">\(X_k\)</span>表示<code>P-RANDOMIZED-PARTITION</code>划分出来后的元素在于位置<span class="math inline">\(k\)</span>。那么由于程序的其余部分都需要<span class="math inline">\(\Theta(\lgn)\)</span>完成（根据题目26.3-3的结论，这里的主要开销就在于<code>P-RANDOMIZED-PARTITION</code>需要花费<span class="math inline">\(\Theta(\lgn)\)</span>的时间），因此可以对随机变量<span class="math inline">\(T_{\infty}(n)\)</span>可以写出如下递推式：</p><p><span class="math display">\[T_{\infty}(n)=\sum_{i=1}^n X_k\cdotT_{\infty}(\max\{k-1,n-k\})+\Theta(\lg n)\]</span></p><p>可见<span class="math inline">\(E[X_k]=\dfrac{1}{n}\)</span>，因为每个位置都有可能被选到。那么对式子左右两侧取期望值，那么有</p><p><span class="math inline">\(\begin{aligned}E[T_{\infty}(n)]&amp;=\sum_{k=1}^n E[X_k]\cdotE[T_{\infty}(\max\{k-1,n-k\})]+\Theta(\lg n)\\&amp;\le\dfrac{2}{n}\sum_{k=\lfloor n/2\rfloor}^{n-1}E[T_{\infty}(k)]+\Theta(\lg n)\\ \end{aligned}\)</span></p><p>接下来使用代入法证明<span class="math inline">\(E[T_{\infty}(n)]=O(n^d)\)</span>，即<span class="math inline">\(\exists c,n_0&gt;0,d\in(0,1)\)</span>，使得<span class="math inline">\(\forall n\ge n_0\)</span>，都有<span class="math inline">\(E[T_{\infty}(n)]\le c\cdotn^{d}\)</span>。那么就可以得到</p><p><span class="math inline">\(\begin{aligned}E[T_{\infty}(n)]&amp;\le\dfrac{2}{n}\sum_{k=\lfloor n/2\rfloor}^{n-1}E[T_{\infty}(k)]+\Theta(\lg n)\\ &amp;\le\dfrac{2}{n}\sum_{k=\lfloorn/2\rfloor}^{n-1} c\cdot k^d+\Theta(\lg n)\\&amp;=\dfrac{2c}{n}\sum_{k=\lfloor n/2\rfloor}^{n-1} k^d+\Theta(\lg n)\\&amp;\le \dfrac{2c}{n}\int_{\lfloor n/2\rfloor}^n x^d dx+\Theta(\lg n)\\&amp;=\dfrac{2c}{n}\cdot\left.\dfrac{x^{d+1}}{d+1}\right|_{x=\lfloorn/2\rfloor}^n+\Theta(\lg n)\\ &amp;=c\cdot\dfrac{2-2^{-d}}{d+1}\cdot n^d+ \Theta(\lg n) \end{aligned}\)</span></p><p>考虑关于<span class="math inline">\(d\)</span>的一元一次不等式<span class="math inline">\(\dfrac{2-2^{-d}}{d+1}&lt;1\)</span>，可以得到<span class="math inline">\(d&gt;0\)</span>。</p><p>也就是说，无论<span class="math inline">\(d\)</span>取<span class="math inline">\((0,1)\)</span>中的什么值，只要第一个项中的<span class="math inline">\(c\)</span>足够大，它就可以覆盖到<span class="math inline">\(\Theta(\lg n)\)</span>中的常数，从而最终得到<span class="math inline">\(T_{\infty}(n)\)</span></p><p>因此，<span class="math inline">\(T_{\infty}(n)=o(n^d)\)</span>，其中<span class="math inline">\(d\)</span>是任意正数。</p><p>最终可以得到并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^{1-d})\)</span>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论26.3 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/26-3-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/26-3-Exercises/</id>
    <published>2023-10-01T11:28:01.000Z</published>
    <updated>2023-10-01T11:28:01.400Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">26.3-1</h1><p>基本思想是，只需要当前排序的数组长度小于等于某个很小的阈值<span class="math inline">\(K\)</span>，那么就选择使用原本串行的归并方式。否则使用当前优化过的归并方式，这个过程由<code>P-MERGE'</code>给出。其中<code>MEGRE'</code>和<code>MERGE</code>相比，表示将排序结果存储到<span class="math inline">\(B\)</span>中（而不是原本的<span class="math inline">\(A\)</span>中）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">P-MERGE&#x27;(A, p, q, r)</span><br><span class="line">  let B[p : r] be a new array             // allocate scratch array</span><br><span class="line">  if r - p &gt; M</span><br><span class="line">    P-MERGE-AUX(A, p, q, q + 1, r, B, p)  // merge from A into B</span><br><span class="line">  else</span><br><span class="line">    MERGE&#x27;(A, p, q, r, B)</span><br><span class="line">  parallel for i = p to r                 // copy B back to A in parallel</span><br><span class="line">    A[i] = B[i]</span><br></pre></td></tr></table></figure><h1 id="section-1">26.3-2</h1><p>通过对题目9.3-10给出的<code>MEDIAN3</code>进行改造，我们给出了一个程序<code>MEDIAN4</code>，它用于求解两个有序数组<span class="math inline">\(A[1:n],B[1:m]\)</span>中的中位数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 找出数组A[i : n], B[j : m]中的第k小数。</span><br><span class="line">SELECT4(A, i, n, B, j, m, k)</span><br><span class="line">  if i &gt; n</span><br><span class="line">    return B[j + k - 1]</span><br><span class="line">  else if j &gt; m</span><br><span class="line">    return A[j + k - 1]</span><br><span class="line">  else if k == 1</span><br><span class="line">    return min&#123;A[i], B[j]&#125;</span><br><span class="line">  if i + ⌊k/2⌋ - 1 &lt;= n</span><br><span class="line">    midl = A[i + ⌊k/2⌋ - 1]</span><br><span class="line">  else</span><br><span class="line">    midl = +∞</span><br><span class="line">  if j + ⌊k/2⌋ - 1 &lt;= m</span><br><span class="line">    midr = B[i + ⌊k/2⌋ - 1]</span><br><span class="line">  else</span><br><span class="line">    midr = +∞</span><br><span class="line">  if midl &lt; midr</span><br><span class="line">    return SELECT4(A, i + ⌊k/2⌋, n, B, j, m, k - ⌊k/2⌋, n)</span><br><span class="line">  else</span><br><span class="line">    return SELECT4(A, i, n, B, j + ⌊k/2⌋, m, k - ⌊k/2⌋, n)</span><br><span class="line"></span><br><span class="line">MEDIAN4(A, B, n, m)</span><br><span class="line">  return SELECT4(A, 1, n, B, 1, m, ⌊(n + m) / 2⌋)</span><br></pre></td></tr></table></figure><p>由此可以将<code>P-MERGE-AUX</code>修改成<code>P-MERGE-AUX'</code>，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">P-MERGE-AUX(A, p1, r1, p2, r2, B, p3)</span><br><span class="line">  if p1 &gt; r1 and p2 &gt; r2</span><br><span class="line">    return</span><br><span class="line">  if r1 − p1 &lt; r2 − p2</span><br><span class="line">    exchange p1 with p2</span><br><span class="line">    exchange r1 with r2</span><br><span class="line">  x = MEDIAN4(A[p1 : r1], B[p2 : r2], r1 - p1 + 1, r2 - p2 + 2)</span><br><span class="line">  q2 = FIND-SPLIT-POINT(A, p2, r2, x)</span><br><span class="line">  q3 = p3 + (q1 − p1) + (q2 − p2) </span><br><span class="line">  B[q3] = x</span><br><span class="line">  spawn P-MERGE-AUX(A, p1, q1 − 1, p2, q2 − 1, B, p3)</span><br><span class="line">  spawn P-MERGE-AUX(A, q1 + 1, r1, q2, r2, B, q3 + 1)</span><br><span class="line">  sync</span><br></pre></td></tr></table></figure><p>先求解<code>P-MERGE-AUX'</code>的工作量<span class="math inline">\(T_1(n)\)</span>。可见，由于每次都淘汰了数组中一半的元素，并且每一轮除了递归部分，只需要<span class="math inline">\(\Theta(\lg n)\)</span>的时间运行。因此有<span class="math inline">\(T_1(n)=2T_1(n/2)+\Theta(\lgn)\)</span>。根据主定理可以得到<span class="math inline">\(T_1(n)=\Theta(n)\)</span>。</p><p>接下来求解<code>P-MERGE-AUX'</code>的持续时间<span class="math inline">\(T_{\infty}(n)\)</span>。同样的，我们得到<span class="math inline">\(T_\infty(n)=T_\infty(n/2)+\Theta(\lgn)\)</span>。从而得到<span class="math inline">\(T_{\infty}(n)=\Theta(\lg^2n)\)</span>。</p><p>由于<code>P-MERGE-AUX'</code>的工作量和持续时间都不变，因此得到的<code>P-MERGE'</code>得到的工作量和持续时间和第26.3章分析的一样，分别为<span class="math inline">\(\Theta(n)\)</span>和<span class="math inline">\(\Theta(\lg^2n)\)</span>。因此其并行量仍然为<span class="math inline">\(\Theta(n/\lg^2 n)\)</span>。</p><h1 id="section-2">26.3-3</h1><p><code>PARTITION</code>的并行化版本<code>P-PARTITION</code>如下展示。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// 令T[p, r]表示一棵二叉树T存储了区间[p, r]内所有数的相关信息，包括：</span><br><span class="line">// small：A[p, r]中小于等于x的数的个数。</span><br><span class="line">// large：[p, r]中大于x的数的个数。</span><br><span class="line">P-PARTITION-CAL(A, p, r, x)</span><br><span class="line">  if p == r</span><br><span class="line">    if A[p] &lt;= x</span><br><span class="line">      T[p, r].small = 1</span><br><span class="line">      T[p, r].large = 0</span><br><span class="line">      return (1, 0)</span><br><span class="line">    else</span><br><span class="line">      T[p, r].small = 0</span><br><span class="line">      T[p, r].large = 1</span><br><span class="line">      return (0, 1)</span><br><span class="line">  else</span><br><span class="line">    mid = ⌊(p + r) / 2⌋</span><br><span class="line">    cl-small, cl-large = spawn P-PARTITION-CAL(A, p, mid, x)</span><br><span class="line">    cr-small, cr-large = spawn P-PARTITION-CAL(A, mid + 1, q, x)</span><br><span class="line">    sync</span><br><span class="line">    T[p, r].small = cl-small + cr-small</span><br><span class="line">    T[p, r].large = cl-large + cr-large</span><br><span class="line">    return (T[p, r].small, T[p, r].large)</span><br><span class="line"></span><br><span class="line">P-PARTITION-FILL(A, p, r, x, B, ls, rs, ll, rl)</span><br><span class="line">  if p == r:</span><br><span class="line">    if A[p] &lt;= x</span><br><span class="line">      B[ls] = A[p]</span><br><span class="line">    else</span><br><span class="line">      B[ll] = A[p]</span><br><span class="line">  else</span><br><span class="line">    mid = ⌊(p + r) / 2⌋</span><br><span class="line">    spawn P-PARTITION-FILL(A, p, mid, x, B, ls, ls + T[p, mid].small - 1, ll, ll + T[p, mid].large + 1)</span><br><span class="line">    spawn P-PARTITION-FILL(A, p, mid, x, B, rs - T[mid + 1, r].small + 1, rs, rl - T[mid + 1, r].large + 1, rl)</span><br><span class="line">    sync</span><br><span class="line"></span><br><span class="line">P-PARTITION(A, p, r)</span><br><span class="line">  if p == r</span><br><span class="line">    return p</span><br><span class="line">  x = A[r]</span><br><span class="line">  c-small, c-large = P-PARTITION-CAL(A, p, r - 1, x)</span><br><span class="line">  let B[p : r] be a new array</span><br><span class="line">  q = p + c-small</span><br><span class="line">  B[q] = x</span><br><span class="line">  P-PARTION-FILL(A, p, r, x, B, p, p + c-small - 1, r - c-large + 1, r)</span><br><span class="line">  parallel for i = p to r</span><br><span class="line">    A[i] = B[i]</span><br><span class="line">  return q</span><br></pre></td></tr></table></figure></p><p>我们可以首先并行化地构筑出一棵二叉树<span class="math inline">\(T\)</span>，其中<span class="math inline">\(T[l,r]\)</span>存储区间<span class="math inline">\([l,r]\)</span>内的信息：小于等于<span class="math inline">\(x\)</span>的元素个数和大于<span class="math inline">\(x\)</span>的元素个数。我们可以知道这棵树的节点数为<span class="math inline">\(\displaystyle{\sum_{i=0}^{\infty}\left\lceil\dfrac{n}{2^i}\right\rceil}=\Theta(n)\)</span>。</p><p>因此，第一趟遍历首先是将这棵树的所有节点信息先处理出来（如<code>P-PARTITION-CAL</code>所示），由于这棵树一共有<span class="math inline">\(\Theta(n)\)</span>个节点，其深度为<span class="math inline">\(\Theta(\lgn)\)</span>，因此这一部分的工作量为<span class="math inline">\(\Theta(n)\)</span>，持续时间为<span class="math inline">\(\Theta(\lg n)\)</span>。</p><p>第二趟遍历则是按照树给定的信息，自底向上地将所有元素填入新数组<span class="math inline">\(B\)</span>中（如<code>P-PARTITION-FILL</code>所示）。这一部分的分析和第一趟类似，这一部分的工作量为<span class="math inline">\(\Theta(n)\)</span>，持续时间为<span class="math inline">\(\Theta(\lg n)\)</span>。</p><p>第三趟遍历则是将<span class="math inline">\(B\)</span>数组并行地填入<span class="math inline">\(A\)</span>中对应位置，因此这一部分的工作量为<span class="math inline">\(\Theta(n)\)</span>，持续时间为<span class="math inline">\(\Theta(\lg n)\)</span>。</p><p>也就是说，<code>P-PARTITION</code>的工作量<span class="math inline">\(T_1(n)\)</span>满足<span class="math inline">\(T_1(n)=2T_1(n/2)+\Theta(1)\)</span>，即得到<span class="math inline">\(T_1(n)=\Theta(n)\)</span>。其工作时间<span class="math inline">\(T_{\infty}(n)\)</span>满足<span class="math inline">\(T_\infty(n)=T_{\infty}(n/2)+\Theta(1)=\Theta(\lgn)\)</span>。因此其并行度为<span class="math inline">\(\Theta(n/\lgn)\)</span>。</p><h1 id="section-3">26.3-4</h1><p>给出的<code>FFT</code>的并行版本<code>P-FFT</code>如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FFT(a, n)</span><br><span class="line">  if n == 1</span><br><span class="line">    return a</span><br><span class="line">  let a-even_&#123;0 : n / 2 - 1&#125;, a-odd_&#123;0 : n / 2 - 1&#125; be new arrays</span><br><span class="line">  parallel for k = 0 to n / 2 - 1</span><br><span class="line">    a-even_&#123;k&#125; = a_&#123;k * 2&#125;</span><br><span class="line">    a_odd_&#123;k&#125; = a_&#123;k * 2 + 1&#125;</span><br><span class="line">  y-even = spawn FFT(a-even, n / 2)</span><br><span class="line">  y-odd = spawn FFT(a-odd, n / 2)</span><br><span class="line">  sync</span><br><span class="line">  parallel for k = 0 to n / 2 - 1</span><br><span class="line">    ω = exp(2 * π * i * k / n)</span><br><span class="line">    y_k = y-even_&#123;k&#125; + ω * y-odd_&#123;k&#125;</span><br><span class="line">    y_&#123;k + n / 2&#125; = y-even_&#123;k&#125; - ω * y-odd_&#123;k&#125;</span><br><span class="line">  return y</span><br></pre></td></tr></table></figure><p><code>P-FFT</code>和其串行投影<code>FFT</code>的区别在于：将<span class="math inline">\(a\)</span>向量进行奇偶划分的过程可以并行完成。其次，<span class="math inline">\(y^{even},y^{odd}\)</span>的计算也是同时派生出两个子线程再进行合并。此外，<span class="math inline">\(\omega_n^k\)</span>的值不能够递推计算，它只能以<span class="math inline">\((\omega_n)^k\)</span>的方式进行计算。</p><p>可见其串行投影为普通的<code>FFT</code>，因此其工作量为<span class="math inline">\(T_1(n)=\Theta(n\lg n)\)</span>。</p><p>每次递归，它都会将两个大小恰好为一半的两个子问题进行递归计算，其余部分只需要<span class="math inline">\(\Theta(\lgn)\)</span>的时间就能够完成好（如两次次<code>parallel for</code>循环以及<span class="math inline">\(\omega_n^k\)</span>的计算），因此其持续时间满足<span class="math inline">\(T_{\infty}(n)=T_{\infty}(n/2)+\Theta(\lgn)\)</span>，最终得到<span class="math inline">\(T_{\infty}(n)=\Theta(\lg^2n)\)</span>。</p><p>因此，<code>P-FFT</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n/\lgn)\)</span>。</p><h1 id="star-26.3-5"><span class="math inline">\(\star\)</span>26.3-5</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">P-SELECT(A, p, r, i)</span><br><span class="line">  g = ⌊(r – p + 1) / 5⌋</span><br><span class="line">  f = (r - p + 1) % 5</span><br><span class="line">  parallel for j = p to p + g – 1</span><br><span class="line">    sort〈A[j], A[j + g], A[j + 2 * g], A[j + 3 * g], A[j + 4 * g]〉in place</span><br><span class="line">  for j = 0 to t - 1</span><br><span class="line">    exchange A[p + 3 * g + j] with A[p + 5 * g + j] </span><br><span class="line">  x = P-SELECT(A, p + 2 * g, p + 3 * g + f – 1, ⌈(g + f) /2⌉)</span><br><span class="line">  q = P-PARTITION-AROUND(A, p, r, x)</span><br><span class="line">  k = q – p + 1</span><br><span class="line">  if i == k</span><br><span class="line">    return A[q]</span><br><span class="line">  else if i &lt; k</span><br><span class="line">    return P-SELECT(A, p, q – 1, i)</span><br><span class="line">  else </span><br><span class="line">    return P-SELECT(A, q + 1, r, i – k)</span><br></pre></td></tr></table></figure><p>修改后得到的<code>P-SELECT</code>算法如上。相比于<code>SELECT</code>，<code>P-SELECT</code>将未满一个组的五个元素进行了延后处理。此外，套用题目26.3-3的结论，<code>P-PARTITION-AROUND</code>可以由<code>PARTITION-AROUND</code>转化而来。其余部分只需要<span class="math inline">\(\Theta(\lg n)\)</span>的时间即可完成。</p><p>因此，<code>P-SELECT</code>的工作量<span class="math inline">\(T_1(n)\)</span>和<code>SELECT</code>的运行时间一样，为<span class="math inline">\(\Theta(n)\)</span>。</p><p><code>P-SELECT</code>的持续时间<span class="math inline">\(T_{\infty}(n)\)</span>可以由<span class="math inline">\(T_{\infty}(n)\leT_{\infty}(n/5)+T_{\infty}(7n/10)+\Theta(\lgn)\)</span>给出。这里可以考虑使用第4.7章介绍的Akra-Bazzi方法进行求解。</p><p>令<span class="math inline">\(c_1=\dfrac{1}{5},c_2=\dfrac{7}{10}\)</span>，构造关于未知数<span class="math inline">\(p\)</span>的方程<span class="math inline">\(c_1^p+c_2^p=1\)</span>，可以得到<span class="math inline">\(p\approx0.84\)</span>。因此，使用等式4.23，可以得到</p><p><span class="math inline">\(\begin{aligned}T_{\infty}(n)&amp;=\Theta\left(n^p\left(1+\int_{1}^n\dfrac{f(x)}{x^{p+1}}dx\right)\right) \\&amp;=\Theta\left(n^p\left(1+\int_{1}^n \dfrac{\lgx}{x^{p+1}}dx\right)\right) \\&amp;=\Theta\left(n^p\left(1+\left(\dfrac{1-n^{-p}(1+p\ln n)}{p^2\ln2}\right)\right)\right) \\ &amp;=\Theta(n^p) \end{aligned}\)</span></p><p>因此，<code>P-SELECT</code>的并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^{1-p})\approx\Theta(n^{0.16})\)</span>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论26.2 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/26-2-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/26-2-Exercises/</id>
    <published>2023-10-01T11:27:58.000Z</published>
    <updated>2023-10-01T11:27:58.941Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">26.2-1</h1><p>使用<code>P-MATRIX-MULTIPLY</code>计算<span class="math inline">\(2\times 2\)</span>矩阵的轨迹如下图所示：</p><p><img data-src="26.2-1.png"></p><p>可见，图中有<span class="math inline">\(13\)</span>个节点，因此其工作量为<span class="math inline">\(13\)</span>。此外，粗线表示这个有向无环图的最长链，其一共有<span class="math inline">\(6\)</span>个节点，因此其持续时间为<span class="math inline">\(6\)</span>，最终我们得到并行度为<span class="math inline">\(\dfrac{13}{6}\)</span>。</p><h1 id="section-1">26.2-2</h1><p>使用<code>P-MATRIX-MULTIPLY-RECURSIVE</code>计算<span class="math inline">\(2\times 2\)</span>矩阵的轨迹如下图所示：</p><p><img data-src="26.2-2.png"></p><p>可见，图中有<span class="math inline">\(42\)</span>个节点，因此其工作量为<span class="math inline">\(42\)</span>。此外，粗线表示这个有向无环图的最长链，其一共有<span class="math inline">\(23\)</span>个节点，因此其持续时间为<span class="math inline">\(23\)</span>，最终我们得到并行度为<span class="math inline">\(\dfrac{42}{23}\)</span>。</p><h1 id="section-2">26.2-3</h1><p>对<code>P-MATRIX-MULTIPLY</code>修改后，由<code>P-MATRIX-MULTIPLY'</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, k, k&#x27;)</span><br><span class="line">  if k == k&#x27;</span><br><span class="line">    return a_&#123;ik&#125; * b_&#123;kj&#125;</span><br><span class="line">  else</span><br><span class="line">    mid = ⌊(k + k&#x27;) / 2⌋</span><br><span class="line">    l = spawn P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, k, mid)</span><br><span class="line">    r = P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, mid, k&#x27;)</span><br><span class="line">    sync</span><br><span class="line">    return l + r</span><br><span class="line"></span><br><span class="line">P-MATRIX-MULTIPLY&#x27;(A, B, C, n)</span><br><span class="line">  parallel for i = 1 to n</span><br><span class="line">    parallel for j = 1 to n</span><br><span class="line">      C_&#123;ij&#125; = P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, 1, n)</span><br></pre></td></tr></table></figure><p>可以知道其工作量为<span class="math inline">\(T_1(n)=\Theta(n^3)\)</span>。</p><p>对程序<code>P-MATRIX-MULTIPLY-AUX'</code>的分析和对题目26.1-7中对<code>P-MAT-VEC-RECURSIVE-AUX'</code>的分析完全一致。因此，假设<span class="math inline">\(iter_n(i,j)\)</span>表示外层循环为<span class="math inline">\(i\)</span>，内层循环为<span class="math inline">\(j\)</span>时的运行时间，那么有<span class="math inline">\(iter_n(i,j)=O(\lg n)\)</span>。</p><p>由于<code>P-MATRIX-MULTIPLY'</code>首先沿着<code>parallel for</code>循环<span class="math inline">\(i\)</span>的递归树的路径向下，然后沿着内层循环<code>parallel for</code>循环<span class="math inline">\(j\)</span>的递归树的路径向下，因此这个算法的持续时间为<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)+\Theta(\lgn)+\max\{iter_n(i,j):1\le i,j\le n\}=\Theta(\lg n)\)</span>。</p><p>因此并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^3/\lgn)\)</span>。</p><h1 id="section-3">26.2-4</h1><p>考虑对题目26.2-3的代码<code>P-MATRIX-MULTIPLY'</code>进行修改，最终由<code>P-MATRIX-MULTIPLY''</code>给出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">P-MATRIX-MULTIPLY-AUX&#x27;&#x27;(A, B, i, j, k, k&#x27;)</span><br><span class="line">  if k == k&#x27;</span><br><span class="line">    return a_&#123;ik&#125; * b_&#123;kj&#125;</span><br><span class="line">  else</span><br><span class="line">    mid = ⌊(k + k&#x27;) / 2⌋</span><br><span class="line">    l = spawn P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, k, mid)</span><br><span class="line">    r = P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, mid, k&#x27;)</span><br><span class="line">    sync</span><br><span class="line">    return l + r</span><br><span class="line"></span><br><span class="line">P-MATRIX-MULTIPLY&#x27;&#x27;(A, B, C, p, q, r)</span><br><span class="line">  parallel for i = 1 to p</span><br><span class="line">    parallel for j = 1 to r</span><br><span class="line">      C_&#123;ij&#125; = P-MATRIX-MULTIPLY-AUX&#x27;(A, B, i, j, 1, q)</span><br></pre></td></tr></table></figure><p>使用和题目26.2-3一样的分析方式，我们可以知道这个算法的工作量为<span class="math inline">\(T_1(n)=\Theta(pqr)\)</span>。</p><p>如果假设<span class="math inline">\(iter_n(i,j)\)</span>表示外层循环为<span class="math inline">\(i\)</span>，内层循环为<span class="math inline">\(j\)</span>时的运行时间，那么有<span class="math inline">\(iter_n(i,j)=O(\lgq)\)</span>。那么这个算法的持续时间为<span class="math inline">\(T_{\infty}(n)=\Theta(\lg p)+\Theta(\lgr)+\max\{iter_n(i,j):1\le i\le p,1\le j\le r\}=\Theta(\lg(pqr))\)</span>。</p><p>因此并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(pqr/\lg(pqr))\)</span>。</p><h1 id="section-4">26.2-5</h1><p>修改后的可并行化的Floyd-Warshall算法由<code>P-FLOYD-WARSHALL'</code>给出（使用题目23.2-4的Floyd-Warshall算法伪代码<code>FLOYD-WARSHALL'</code>进行修改）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">P-FLOYD-WARSHALL&#x27;(W, n)</span><br><span class="line">  D = W</span><br><span class="line">  for k = 1 to n</span><br><span class="line">    parallel for i = 1 to n</span><br><span class="line">      parallel for j = 1 to n</span><br><span class="line">        d_&#123;ij&#125; = min &#123;d_&#123;ij&#125;, d_&#123;ik&#125; + d_&#123;kj&#125; &#125;</span><br><span class="line">6 return D</span><br></pre></td></tr></table></figure><p>首先说明一下这样修改的正确性。可见，在第<span class="math inline">\(k\)</span>轮循环中，<code>P-FLOYD-WARSHALL'</code>的第5行只会使用<span class="math inline">\(D\)</span>的第<span class="math inline">\(k\)</span>行和第<span class="math inline">\(k\)</span>列中的元素进行读取，并对其它元素进行修改。由于原来的图是一个非负边权的图，因此哪怕对<span class="math inline">\(d_{ik},d_{kj}\)</span>这样的元素进行更新，也不会对原本的值进行改变。因此。这个算法通过如此并行化完成是正确的。</p><p>这个程序的串行投影需要花费<span class="math inline">\(\Theta(n^3)\)</span>的时间完成，因此其工作量为<span class="math inline">\(T_1(n)=\Theta(n^3)\)</span>。</p><p>接下来求解持续时间<span class="math inline">\(T_{\infty}(n)\)</span>。假设<span class="math inline">\(iter_n(i,j)\)</span>表示外层<code>parallel for</code>循环为<span class="math inline">\(i\)</span>，内层<code>parallel for</code>循环为<span class="math inline">\(j\)</span>时的运行时间，那么有<span class="math inline">\(iter_n(i,j)=O(1)\)</span>，因为接下来只有一个较小值更新操作和加法操作。将两层循环中的<code>parallel</code>关键字转化为<code>spawn ... sync</code>结构后，那么可以得知<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)+\Theta(\lgn)+\max\{iter_n(i,j):1\le i,j\le n\}=\Theta(\lgn)\)</span>。由于这个两层<code>parallel for</code>循环需要串行地执行<span class="math inline">\(k\)</span>次，因此我们可以求出<span class="math inline">\(T_{\infty}(n)=n\cdot \Theta(\lg n)=\Theta(n\lgn)\)</span>。</p><p>最终并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^3/(n\lgn))=\Theta(n^2/\lg n)\)</span>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法导论26.1 Exercises 答案</title>
    <link href="https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/26-1-Exercises/"/>
    <id>https://ujimatsu-chiya.github.io/INTRODUCTION-TO-ALGORITHMS/26-1-Exercises/</id>
    <published>2023-10-01T11:27:56.000Z</published>
    <updated>2023-10-01T11:27:56.423Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="section">26.1-1</h1><p>一个串行算法的运行轨迹是看起来是一个单链表。相比于图26.2和图26.4所展示的运行轨迹，每个节点最多只有一条入边和一条出边。</p><h1 id="section-1">26.1-2</h1><p>相比于原来，现在<code>P-FIB</code>变成了<code>P-FIB'</code>，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">P-FIB&#x27;(n)</span><br><span class="line">  if n &lt;= 1</span><br><span class="line">    return n</span><br><span class="line">  else </span><br><span class="line">    x = spawn P-FIB&#x27;(n − 1)</span><br><span class="line">    y = spawn P-FIB&#x27;(n − 2)</span><br><span class="line">    sync</span><br><span class="line">    return x + y</span><br></pre></td></tr></table></figure><p>与原来的区别在于，父线程一进入<code>else</code>就被挂起，并且产生了两个子线程来求解<code>P-FIB'(n − 1)</code>和<code>P-FIB'(n − 2)</code>，父线程会一直等待，直到这两个线程完成执行，最终才返回计算结果。</p><p>因此，除了增加了一些线程本身的空间占用，这种做法并不会产生任何的改进，因此其渐进工作量<span class="math inline">\(T_1&#39;\)</span>仍然为<span class="math inline">\(\Theta(\phi^n)\)</span>，其持续时间仍然是<span class="math inline">\(T_{\infty}&#39;=\Theta(n)\)</span>，并行度为<span class="math inline">\(T_1&#39;/T_{\infty}&#39;=\Theta(\phi^n/n)\)</span>。</p><h1 id="section-2">26.1-3</h1><p>如下图所示，为<code>P-FIB(5)</code>的计算有向无环图。可见，图中有<span class="math inline">\(29\)</span>个节点，因此其工作量为<span class="math inline">\(29\)</span>。此外，粗线表示这个有向无环图的最长链，其一共有<span class="math inline">\(10\)</span>个节点，因此其持续时间为<span class="math inline">\(10\)</span>，最终我们得到并行度为<span class="math inline">\(2.9\)</span>。</p><p><img data-src="26.1-3.png"></p><h1 id="section-3">26.1-4</h1><p>假设这些时间步中，一共有<span class="math inline">\(x\)</span>个非完全步，一共有<span class="math inline">\(y\)</span>个完全步。那么必定有<span class="math inline">\(y\le\lfloor(T_1 -x)/P\rfloor\)</span>。我们通过反证法来证明这个不等式是成立的。</p><p>由于每个非完全步至少有<span class="math inline">\(1\)</span>的工作量，因此至多只有<span class="math inline">\(T_1-x\)</span>的工作量在完全步完成，也就是说，有<span class="math inline">\(Py\le T_1-x\)</span>。假设<span class="math inline">\(y&gt;\lfloor(T_1 -x)/P\rfloor\)</span>，那么有</p><p><span class="math inline">\(\begin{aligned} Py&amp;\geP\cdot(\lfloor(T_1 - x)/P\rfloor+1)\\ &amp;=P\cdot\lfloor(T_1 -x)/P\rfloor+P\\ &amp;=P\cdot\left(\dfrac{T_1-x}{P}-((T_1-x)\bmodP)\right) + P\\ &amp;=T_1-x+P-((T_1-x)\bmod P)\\ &amp;&gt;T_1-x\end{aligned}\)</span></p><p>这和<span class="math inline">\(Py\le T_1-x\)</span>矛盾，因此有<span class="math inline">\(y\le\lfloor(T_1 - x)/P\rfloor\)</span>。</p><p>那么有<span class="math inline">\(T_p=x+y\le x+\lfloor(T_1 -x)/P\rfloor\)</span>。由于<span class="math inline">\(x\leT_\infty\)</span>，即<span class="math inline">\(x\)</span>是所有时间步的一个子集，因此有</p><p><span class="math inline">\(\begin{aligned} T_p&amp;\le x+\lfloor(T_1- x)/P\rfloor\\ &amp;\le x+(T_1 - x)/P\\ &amp;\le T_\infty+(T_1 -T_\infty)/P\\ \end{aligned}\)</span></p><p>原结论成立。</p><h1 id="section-4">26.1-5</h1><p><img data-src="26.1-5.png"></p><p>假设现在有<span class="math inline">\(k\)</span>个处理器，<span class="math inline">\(k+1\)</span>个任务，其中每个串行任务内部一共有<span class="math inline">\(m\)</span>个节点。那么左图是贪心调度器的一种调度，接下来的<span class="math inline">\(m\)</span>个时间步它先完成<span class="math inline">\(k\)</span>个任务的串行节点，然后再花费<span class="math inline">\(m\)</span>个时间步进行剩下的那一个任务，在这种调度下，花费了<span class="math inline">\(2m+2\)</span>个时间步完成整个程序的运行（注意，这里加上了开始和结束的时间步）。如左图所示。</p><p>另一种调度则是，每次优先选择剩余时间最长的<span class="math inline">\(k\)</span>个任务运行一个时间步，直到完成所有任务为止。因此，这个过程总共需要<span class="math inline">\(\left\lceil\dfrac{(k+1)m}{k}\right\rceil+2=\left\lceilm+\dfrac{m}{k}\right\rceil+2\)</span>个时间步进行。如右图所示。</p><p>因此，有<span class="math inline">\(\displaystyle{\lim_{k\rightarrow+\infty}(2m+2)/\left(\left\lceilm+\dfrac{m}{k}\right\rceil+2\right)=2}\)</span>，这时第一种调度所花费的时间步是第二种调度的接近<span class="math inline">\(2\)</span>倍。</p><h1 id="section-5">26.1-6</h1><p>根据工作量定律，有<span class="math inline">\(T_1\le \min\{4\cdotT_4,10\cdot T_{10},64\cdot T_{64}\}\)</span>，从而得到<span class="math inline">\(T_1\le 320\)</span>。</p><p>根据持续时间定理，有<span class="math inline">\(T_\infty\le\min\{T_4,T_{10},T_{64}\}\)</span>，从而得到<span class="math inline">\(T_\infty\le 10\)</span>。</p><p>对<span class="math inline">\(T_{10}\)</span>对应的情况应用不等式26.5，那么有</p><p><span class="math inline">\(\begin{aligned} T_{10}&amp;\le\dfrac{T_1-T_\infty}{10}+T_\infty\\ &amp;\le \dfrac{T_1+9T_\infty}{10}\\&amp;\le 32+\dfrac{9T_\infty}{10} \end{aligned}\)</span></p><p>从而得到<span class="math inline">\(T_\infty&gt;\dfrac{100}{9}\)</span>，这和给出的<span class="math inline">\(T_{\infty}\le10\)</span>是矛盾的，因此这个教授是在撒谎。</p><h1 id="section-6">26.1-7</h1><p>可以将提供的<code>P-MAT-VEC-RECURSIVE</code>进行改造后，得到如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">P-MAT-VEC-RECURSIVE-AUX&#x27;(A, x, n, i, j, j&#x27;)</span><br><span class="line">  if j == j&#x27;</span><br><span class="line">    return a_&#123;i, j&#125; * x_j</span><br><span class="line">  else</span><br><span class="line">    mid = ⌊(j + j&#x27;) / 2⌋</span><br><span class="line">    l = spawn P-MAT-VEC-RECURSIVE-AUX&#x27;(A, x, n, i, j, mid)</span><br><span class="line">    r = P-MAT-VEC-RECURSIVE-AUX&#x27;(A, x, n, i, mid + 1, j&#x27;)</span><br><span class="line">    sync</span><br><span class="line">    return l + r</span><br><span class="line"></span><br><span class="line">P-MAT-VEC-RECURSIVE&#x27;(A, x, y, n)</span><br><span class="line">  parallel for i = 1 to n</span><br><span class="line">    y_i = P-MAT-VEC-RECURSIVE-AUX&#x27;(A, x, n, i, 1, n)</span><br></pre></td></tr></table></figure><p>其基本思想在于，对于<span class="math inline">\(A\)</span>的每一行都和<span class="math inline">\(x\)</span>独立相乘，得到一个值。然后，先计算这一行左半部分和<span class="math inline">\(x\)</span>的左半部分点积；右半部分和<span class="math inline">\(x\)</span>的左半部分点并行进行计算，最终将结果合并。</p><p>因此，<code>P-MAT-VEC-RECURSIVE'</code>的工作量为<span class="math inline">\(T_1(n)=\Theta(n^2)\)</span>，因为它仍然运行了<span class="math inline">\(n^2\)</span>次乘法运算。</p><p><code>P-MAT-VEC-RECURSIVE'</code>的持续时间<span class="math inline">\(T_{\infty}(n)\)</span>如下计算。由于<code>P-MAT-VEC-RECURSIVE'</code>中的每次循环都是独立的，因此令<span class="math inline">\(iter_{\infty}(n,i)\)</span>表示第<span class="math inline">\(i\)</span>次的循环结果，我们可以得到：</p><p><span class="math display">\[T_{\infty}(n)=\Theta(\lgn)+\max\{iter_{\infty}(n,i):1\le i\le n\}\]</span></p><p>对于每一次<code>P-MAT-VEC-RECURSIVE-AUX'</code>的调用，我们可以发现，每一次调用都将求和的范围减小，因此有<span class="math inline">\(iter_{\infty}(n,i)=iter_{\infty}(n/2,i)+\Theta(1)\)</span>。根据主定理，可以得到：</p><p><span class="math display">\[iter_{\infty}(n,i)=\Theta(\lgn)+\Theta(\lg n)\]</span></p><p>因此，我们最终得到<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)+\Theta(\lgn)=\Theta(\lg n)\)</span>。</p><p>最终我们得到这个算法的并行度为<span class="math inline">\(T_1(n)/T_\infty(n)=\Theta(n^2/\lgn)\)</span>。</p><h1 id="section-7">26.1-8</h1><p>可见，这个程序的串行投影需要花费<span class="math inline">\(\Theta(n^2)\)</span>的时间完成，因此其工作量为<span class="math inline">\(T_1(n)=\Theta(n^2)\)</span>。</p><p>接下来求解持续时间<span class="math inline">\(T_{\infty}(n)\)</span>。令<span class="math inline">\(iter_1(j)(2\le j\len)\)</span>表示其外层循环所需要的时间，<span class="math inline">\(iter_2(i)(1\le j&lt;n)\)</span>表示其内层循环所需要的时间。</p><p>如果将内层<code>for</code>循环的<code>parallel</code>关键字转化为<code>spawn ... sync</code>结构后，那么可以得知<span class="math inline">\(iter_1(i)=\Theta(\lg i)+\max\{iter_2(j):1\lej&lt;i\}\)</span>。可以知道，由于<span class="math inline">\(iter_2(j)=\Theta(1)\)</span>，因此有<span class="math inline">\(iter_1(i)=\Theta(\lg i)+\Theta(1)=\Theta(\lgi)\)</span>。</p><p>再将外层<code>for</code>循环的<code>parallel</code>关键字转化为<code>spawn ... sync</code>结构后，那么可以得知<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)+\max\{iter_1(i):2\lej\le n\}=\Theta(\lg n)+\Theta(\lg n)\)</span>。从而得到<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)\)</span>。</p><p>因此并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^2/\lgn)\)</span>。</p><h1 id="section-8">26.1-9</h1><p>也就是说，现在的程序转化为<code>P-TRANSPOSE'</code>，即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P-TRANSPOSE(A, n)</span><br><span class="line">  parallel for j = 2 to n</span><br><span class="line">    for i = 1 to j − 1</span><br><span class="line">      exchange a_&#123;ij&#125; with a_&#123;ji&#125;</span><br></pre></td></tr></table></figure><p>工作量和题目28.1-8的情况一样，为<span class="math inline">\(T_1(n)=\Theta(n^2)\)</span>。</p><p>接下来求解持续时间<span class="math inline">\(T_{\infty}(n)\)</span>。令<span class="math inline">\(iter(j)(2\le j\len)\)</span>表示其外层循环所需要的时间，由内层循环可以知道，<span class="math inline">\(iter(j)=\Theta(j)\)</span>。将外层<code>for</code>循环的<code>parallel</code>关键字转化为<code>spawn ... sync</code>结构后，那么可以得知<span class="math inline">\(T_{\infty}(n)=\Theta(\lg n)+\max\{iter(i):2\lej\le n\}=\Theta(\lg n)+\Theta(n)\)</span>。因此，我们最终得到<span class="math inline">\(T_{\infty}(n)=\Theta(\lgn)+\Theta(n)=\Theta(n)\)</span>。</p><p>因此并行度为<span class="math inline">\(T_1(n)/T_{\infty}(n)=\Theta(n^2/n)=\Theta(n)\)</span>。</p><h1 id="section-9">26.1-10</h1><p>相当于解如下关于未知数<span class="math inline">\(P,T_P,T_P&#39;\)</span>的方程组：</p><p><span class="math display">\[\left \{\begin{aligned}  &amp;T_P=\dfrac{T_1}{P}+T_\infty\\  &amp;T_P&#39;=\dfrac{T_1&#39;}{P}+T_\infty&#39;\\  &amp;T_P=T_P&#39;\\\end{aligned}\right.\]</span></p><p>其中<span class="math inline">\(T_1=2048,T_{\infty}=1,T_1&#39;=1024,T_{\infty}&#39;=8\)</span>，最终得到解：</p><p><span class="math display">\[\left \{\begin{aligned}  &amp;P=\dfrac{1024}{7}\\  &amp;T_P=15\\  &amp;T_P&#39;=15\\\end{aligned}\right.\]</span></p><p>也就是说，只需要约<span class="math inline">\(146\)</span>或者<span class="math inline">\(147\)</span>个处理器就能使这两个版本的算法运行时间相同。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法导论" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>滴滴 秋招 2023.09.28 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Didi-20230928/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Didi-20230928/</id>
    <published>2023-09-29T09:06:03.000Z</published>
    <updated>2023-09-29T09:06:03.565Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="圆木加工">1、圆木加工</h1><p>一家木材厂需要加工三根圆木。这三根圆木长度分别为<span class="math inline">\(a,b,c\)</span>，一共需要进行不超过<span class="math inline">\(n\)</span>次加工程序。第<span class="math inline">\(i\)</span>道加工程序需要选择其中一根长度严格大于<span class="math inline">\(i\)</span>的圆木，将其切割，使其长度减少<span class="math inline">\(i\)</span>。被切下的部分不再进入后续的加工流程。如果这三根圆木的长度能够组成一个面积大于<span class="math inline">\(0\)</span>的三角形，那么就称此时的圆木长度三元组<span class="math inline">\((a&#39;,b&#39;,c&#39;)\)</span>是好的。</p><p>现在的问题是：一共可能形成多少种好的三元组？</p><h2 id="输入">输入</h2><p>输入仅一行四个正整数<span class="math inline">\(n,a,b,c\)</span>。</p><p>对于<span class="math inline">\(100\%\)</span>的数据，<span class="math inline">\(1\le n,a,b,c \le 100\)</span>。</p><h2 id="输出">输出</h2><p>输出一行，一个整数，表示好的三元组的个数。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5 3 4 5</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">有如下10种三元组</span><br><span class="line">(1,4,4),(2,2,2),(2,4,3),(2,4,5),(3,2,4),(3,3,3),(3,3,5),(3,4,2),(3,4,4),(3,4,5)</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>对于三种原木<span class="math inline">\((a,b,c)\)</span>是否能拼接成一个三角形，只需要判断<span class="math inline">\(a+b&gt;c,a+c&gt;b,b+c&gt;a\)</span>是否都成立即可。</p><p>由于第<span class="math inline">\(i\)</span>次加工程序切除原木的长度只依赖于<span class="math inline">\(i\)</span>本身，因此，如果从原木<span class="math inline">\((a,b,c)\)</span>经过若干道加工程序变成<span class="math inline">\((a&#39;,b&#39;,c&#39;)\)</span>后，其使用的加工轮数必定是确定的。也就是说，只要从<span class="math inline">\((a,b,c)\)</span>变成<span class="math inline">\((a&#39;,b&#39;,c&#39;)\)</span>，那么必定进行了<span class="math inline">\(k\)</span>轮，并且<span class="math inline">\(k\)</span>是一个常数，不依赖于现有的决策。</p><p>因此，我们使用带有记忆化的深度优先搜索即可完成本题。如果发现当前状态<span class="math inline">\((a,b,c)\)</span>被遍历过，那么就直接返回，否则进一步向下进行枚举即可。这保证了每个不同的三元组<span class="math inline">\((a,b,c)\)</span>都只被遍历一次。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">104</span>;</span><br><span class="line"><span class="type">int</span> n,a,b,c;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> vis[N][N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[a][b][c]) <span class="keyword">return</span>;</span><br><span class="line">    vis[a][b][c]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a+b&gt;c&amp;&amp;a+c&gt;b&amp;&amp;b+c&gt;a) ++ans;</span><br><span class="line">    <span class="keyword">if</span>(k==n+<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;k) <span class="built_in">dfs</span>(k+<span class="number">1</span>,a-k,b,c);</span><br><span class="line">    <span class="keyword">if</span>(b&gt;k) <span class="built_in">dfs</span>(k+<span class="number">1</span>,a,b-k,c);</span><br><span class="line">    <span class="keyword">if</span>(c&gt;k) <span class="built_in">dfs</span>(k+<span class="number">1</span>,a,b,c-k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>,&amp;n,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,a,b,c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="平衡树">2、平衡树</h1><p>小明正在玩一棵树，它正在研究树的平衡性，它为了辅助研究，为树定义了一个函数<span class="math inline">\(S(x)\)</span>，表示对树中节点<span class="math inline">\(x\)</span>，其到树中其他所有节点的距离之和，注意树上相邻节点之间距离为<span class="math inline">\(1\)</span>，而且树根为<span class="math inline">\(1\)</span>号节点。现在他想让你帮他进行计算！</p><h2 id="输入-1">输入</h2><p>第一行两个正整数<span class="math inline">\(n,m\)</span>分别表示树上的节点数和询问数。</p><p>接下来一行<span class="math inline">\(n-1个数\)</span>p_2,p_3,p_n<span class="math inline">\(。表示节点\)</span>i<span class="math inline">\(的父亲为\)</span>p_i$。</p><p>接下来一行<span class="math inline">\(m\)</span>个数，<span class="math inline">\(x_1,x_2,\dotsx_m\)</span>，分别表示每次询问所使用的<span class="math inline">\(x\)</span>值。</p><p>对于所有数据，<span class="math inline">\(1\le n,m\le 20000,1\lep_i&lt; n, 1 \le x_i \le n\)</span>。</p><h2 id="输出-1">输出</h2><p>输出一行<span class="math inline">\(m\)</span>个数，单空格隔开，分别表示每次询问的答案。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3 3</span><br><span class="line">1 1</span><br><span class="line">1 2 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2 3 3</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>这道题是原题Leetcode834。其使用的基本思想是换根动态规划，进行两次深度优先搜索即可完成，其中第二次搜索使用了动态规划的思想。</p><p>其基本思想是，首先我们先以<span class="math inline">\(O(n)\)</span>的时间复杂度求出一个节点的答案值，然后再将其转移到每个节点的答案。</p><p>令<span class="math inline">\(d_i\)</span>表示节点<span class="math inline">\(i\)</span>的深度，<span class="math inline">\(s_i\)</span>表示以节点<span class="math inline">\(i\)</span>为根的子树中的节点数个数，<span class="math inline">\(f_i\)</span>表示<span class="math inline">\(i\)</span>到其它节点的所有距离之和。</p><p>通过第一次深度优先搜索，我们可以求出数组<span class="math inline">\(d,s\)</span>。并且，我们能够利用好数组<span class="math inline">\(d\)</span>给出第一个转移：</p><ul><li><span class="math inline">\(\displaystyle{\sum_{i=1}^nd_i\rightarrow f_1}\)</span></li></ul><p>以上根据定义是显而易见的。令<span class="math inline">\(\text{son}(u)\)</span>表示<span class="math inline">\(u\)</span>的所有子节点，那么考虑<span class="math inline">\(v\in\text{son}(u)\)</span>，我们可以列出如下转移：</p><ul><li><span class="math inline">\(f_u+(n-s_v)-s_v\rightarrowf_v\)</span></li></ul><p>当我们已经求出了节点<span class="math inline">\(u\)</span>的<span class="math inline">\(f_u\)</span>值后，那么对于<span class="math inline">\(u\)</span>其中的一个子节点，<span class="math inline">\(f_u\)</span>值会发生什么变化呢？对于一个节点<span class="math inline">\(w\)</span>，如果它在<span class="math inline">\(v\)</span>的子树，那么从<span class="math inline">\(u\)</span>走到<span class="math inline">\(w\)</span>的距离减少了<span class="math inline">\(1\)</span>，因此需要减去<span class="math inline">\(s_v\)</span>；如果它不在<span class="math inline">\(v\)</span>的子树，那么从<span class="math inline">\(u\)</span>走到<span class="math inline">\(w\)</span>的距离增加了<span class="math inline">\(1\)</span>，因此可以得出如上转移。这在<span class="math inline">\(O(n)\)</span>的时间内可以完成。</p><p>对于给定的每个询问<span class="math inline">\(x\)</span>，直接输出<span class="math inline">\(f_x\)</span>的值即可。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">20004</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans[N],d[N],sz[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;g[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> dis)</span></span>&#123;</span><br><span class="line">    d[u]=dis;</span><br><span class="line">    sz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:g[u])&#123;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,dis+<span class="number">1</span>);</span><br><span class="line">        sz[u]+=sz[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:g[u])&#123;</span><br><span class="line">        ans[v]=ans[u]-sz[v]+(n-sz[v]);</span><br><span class="line">        <span class="built_in">dfs2</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        g[x].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans[<span class="number">1</span>]+=d[i];</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>,ans[x],<span class="string">&quot; \n&quot;</span>[i==m]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>华为 秋招 2023.09.27 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Huawei-20230927/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Huawei-20230927/</id>
    <published>2023-09-27T16:14:45.000Z</published>
    <updated>2023-09-27T16:14:45.218Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="价格优惠">1、价格优惠</h1><p>某商城进行“双十一”促销活动，活动采用等价格减免的方式，某位客人一次购买了<span class="math inline">\(N\)</span>件商品，需要帮忙计算本次购买能获得的总优惠。给定商品价格数组<span class="math inline">\(p\)</span>，其中<span class="math inline">\(p[i]\)</span>表示第i件商品的价格，第<span class="math inline">\(i\)</span>件商品能获得的优惠为第<span class="math inline">\(i\)</span>件商品之前的第<span class="math inline">\(j\)</span>件商品的价格，其中<span class="math inline">\(p[j]\le p[i]\)</span>，并目<span class="math inline">\(j\le i\)</span>，且<span class="math inline">\(p[j]\)</span>是离<span class="math inline">\(p[i]\)</span>最近的一个小于等于<span class="math inline">\(p[i]\)</span>的商品。求本次购买能获得的总优惠。</p><p>例如：给定价格数组<span class="math inline">\(p=[9,4,3,5],p[3]=5\)</span>能获得的优惠为<span class="math inline">\(p[2]=3,p[2]\)</span>是满足条件离<span class="math inline">\(p[3]\)</span>最近的一个商品，其中<span class="math inline">\(p[1]=4\)</span>也小于<span class="math inline">\(p[3]\)</span>，但不是离<span class="math inline">\(p[3]\)</span>最近的商品。</p><h2 id="输入">输入</h2><p>第一行是商品的个数<span class="math inline">\(N,1\le N\le100000\)</span>。</p><p>第二行是用空格分隔的<span class="math inline">\(N\)</span>个整数，数组元素的值表示商品的价格<span class="math inline">\(0&lt; p[i]\le 100000\)</span>。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">9 4 5 2 4 </span><br></pre></td></tr></table></figure><h2 id="输出">输出</h2><p>输出为一个整数，表示本次购买获得的总优惠。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">9 4 5 2 4</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">商品0的价格为p[0]=9，第一件商品之前无其他商品，该商品获得的优惠为0。</span><br><span class="line">商品1的价格为p[1]=4，p[1]之前不存在满足条件的商品，该商品获得的优惠为0。</span><br><span class="line">商品2的价格为p[2]=5，p[2]之前满足条件的最近的一个商品为p[1]=4，该商品获得的优惠为4。</span><br><span class="line">商品3的价格为p[3]=2，p[3]之前没有满足条件的商品，该商品获得的优惠为0。</span><br><span class="line">商品4的价格为p[4]=4。p[4]之前满足条件的最近的一个商品为p[3]=2，该商品获得的优惠为2。</span><br><span class="line">由此可以计算出本次购买可以获得的总优惠为： 4+2=6。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">4</span><br><span class="line">1 2 3 5</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">商品0的价格为p[0]=1，第一件商品之前无其他商品，该商品获得的优惠为0。</span><br><span class="line">商品1的价格为p[1]=2，p[1]之前满足条件的最近的一个商品为p[0]=1，该商品获得的优惠为1。</span><br><span class="line">商品2的价格为p[2]=3，p[2]之前满足条件的最近的一个商品为p[1]=2，该商品获得的优惠为2。</span><br><span class="line">商品3的价格为p[3]=5，p[3]之前满足条件的最近的一个商品为p[2]=3，该商品获得的优惠为3。</span><br><span class="line">由此可以计算出本次购买可以获得的总优惠为：1+2+3=6。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">4</span><br><span class="line">4 3 2 1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">商品0的价格为p[0]=9，第一件商品之前无其他商品，该商品获得的优惠为0。</span><br><span class="line">商品1的价格为p[1]=4，p[1]之前不存在满足条件的商品，该商品获得的优惠为0。</span><br><span class="line">商品2的价格为p[2]=5，p[2]之前满足条件的最近的一个商品为p[1]=4，该商品获得的优惠为4。</span><br><span class="line">商品3的价格为p[3]=2，p[3]之前没有满足条件的商品，该商品获得的优惠为0。</span><br><span class="line">商品4的价格为p[4]=4。p[4]之前满足条件的最近的一个商品为p[3]=2，该商品获得的优惠为2。</span><br><span class="line">本次购买每件商品都没有满足条件的优惠，本次购买可获得的优惠为0。</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>本题是Leetcode 496的变种。相当于是为每一个数<span class="math inline">\(p[i]\)</span>找到左边第一个不超过它的数，并加上它。</p><p>因此，使用单调栈可以完美解决这个问题，我们通过维护一个非单调递减的栈来记录元素的值，当把栈中所有比当前元素大的元素弹出后，栈顶即为我们所需要求的值，再把当前的数推进栈中。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"><span class="type">int</span> p[N],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;st;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()&amp;&amp;p[i]&lt;st.<span class="built_in">top</span>()) st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(!st.<span class="built_in">empty</span>())</span><br><span class="line">            ans+=st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">push</span>(p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多项式计算">2、多项式计算</h1><p>给定两个一元多项式以及多项式运算符，计算输出两个多项式运算的结果，计算规则见样例。</p><h2 id="输入-1">输入</h2><p>分三行输入，第一行输入多项式<span class="math inline">\(A\)</span>的系数数组（按照阶数高到低顺序），第二行输入多项式<span class="math inline">\(B\)</span>的系数数组，第三行输入多项式运算符。运算符包括加<code>(+)</code>减<code>(-)</code>乘<code>(*)</code>三种，系数数组大小小于<span class="math inline">\(128\)</span>，系数取值范围<span class="math inline">\([-512,512]\)</span>。</p><h2 id="输出-1">输出</h2><p>输出多项式运算结果的系数数组，如果计算后多项式为<span class="math inline">\(0\)</span>，则输出0。从第<span class="math inline">\(1\)</span>个非零的系数开始输出。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[1 2 3 4 5 6]</span><br><span class="line">[2 3 -4]</span><br><span class="line">+</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[1 2 3 6 8 2]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">多项式系数数组[1 2 3 4 5 6]表示多项式A(x)=x^5 + 2x^4+ 3x^3 + 4x^2 + 5x + 6</span><br><span class="line">多项式系数数组[2 3 -4]表示多项式B(x)=2x^2 + 3x - 4</span><br><span class="line">A(x) + B(x) = x^5 + 2x^4 + 3x^3 + 6x^2 + 8x + 2，对应的多项式系数数组为[1 2 3 6 8 2]。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[1 2 3]</span><br><span class="line">[1 2 1]</span><br><span class="line">-</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[2]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">(x^2 + 2x + 3) - (x^2 + 2x + 1) = 2</span><br><span class="line">高阶的0系数不输出。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[1 1]</span><br><span class="line">[1 1]</span><br><span class="line">*</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[1 2 1]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">(x + 1) * (x + 1) = x^2 + 2x + 1</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>本题是一道输入输出处理题和模拟题。建议使用<code>python</code>结合<code>eval</code>函数来完成。接下来为了方便处理按照多项式的形式进行处理，需要将输入的数组<span class="math inline">\(A,B\)</span>进行逆序。</p><p>逆序完成后，我们可以将下标作为指数，按照多项式的定义进行计算。</p><p>需要注意的是，计算完多项式的结果后，按照题目要求需要注意如下事项：</p><ol type="1"><li>去掉高次中的<span class="math inline">\(0\)</span>系数项。</li><li>如果多项式的结果为<span class="math inline">\(0\)</span>，那么还需要避免输出的多项式为空，需要往对应数组添加回一个<span class="math inline">\(0\)</span>。</li><li>对输出的多项式进行逆序。</li></ol><h2 id="代码-1">代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="built_in">list</span>(<span class="built_in">reversed</span>(<span class="built_in">eval</span>(<span class="built_in">input</span>().replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;,&#x27;</span>))))</span><br><span class="line">B = <span class="built_in">list</span>(<span class="built_in">reversed</span>(<span class="built_in">eval</span>(<span class="built_in">input</span>().replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;,&#x27;</span>))))</span><br><span class="line">op = <span class="built_in">input</span>()</span><br><span class="line">n = <span class="built_in">max</span>(<span class="built_in">len</span>(A), <span class="built_in">len</span>(B))</span><br><span class="line">A += [<span class="number">0</span>] * (n - <span class="built_in">len</span>(A))</span><br><span class="line">B += [<span class="number">0</span>] * (n - <span class="built_in">len</span>(B))</span><br><span class="line"><span class="keyword">if</span> op == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">    C = [A[i] + B[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="keyword">elif</span> op == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">    C = [A[i] - B[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    C = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            C[i + j] += A[i] * A[j]</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(C) &gt; <span class="number">0</span> <span class="keyword">and</span> C[-<span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">    C.pop()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(C) == <span class="number">0</span>:</span><br><span class="line">    C = [<span class="number">0</span>]</span><br><span class="line">C.reverse()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(C).replace(<span class="string">&#x27;, &#x27;</span>, <span class="string">&#x27; &#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="货物运输">3、货物运输</h1><p>有<span class="math inline">\(m\)</span>件货物和<span class="math inline">\(n\)</span>辆卡车，每辆卡车只能运送<strong>一件</strong>货物，卡车的载重量需要<strong>大于等于</strong>货物重量才能运输；</p><p>另有<span class="math inline">\(x\)</span>个载重为<span class="math inline">\(y\)</span>的拖斗，每辆卡车<strong>最多</strong>可以拖挂一个拖斗以提升载重量，共同运输一件更重的货物；</p><p>请你返回<strong>最多</strong>可以运输多少件货物。</p><h2 id="输入-2">输入</h2><p>三行数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m n x y</span><br><span class="line">weight0 weight1 weight2...</span><br><span class="line">load0 load1 load2...</span><br></pre></td></tr></table></figure><p>第<span class="math inline">\(1\)</span>行包含四个数字，分别为：</p><ul><li><span class="math inline">\(m\)</span>：货物数量</li><li><span class="math inline">\(n\)</span>：卡车数量</li><li><span class="math inline">\(x\)</span>：拖斗数量</li><li><span class="math inline">\(y\)</span>：拖斗载重</li></ul><p>第<span class="math inline">\(2\)</span>行为货物的重量列表，以空格分隔；</p><p>第<span class="math inline">\(3\)</span>行为卡车的载重列表，以空格分隔；</p><p>范围：</p><ul><li><span class="math inline">\(1\le\)</span> 货物/卡车<span class="math inline">\(\le 50000\)</span></li><li><span class="math inline">\(0\le\)</span> 拖斗数量<span class="math inline">\(\le 50000\)</span></li><li><span class="math inline">\(0\le\)</span>货物重量/卡车载重量/拖斗载重量<span class="math inline">\(\le1000000000\)</span></li></ul><h2 id="输出-2">输出</h2><p>一个整数，最多可以运输货物的数量。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5 5 1 5</span><br><span class="line">5 5 8 9 9</span><br><span class="line">1 2 4 6 6</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">2号卡车运输1号货物，6&gt;=5</span><br><span class="line">4号卡车运输5号货物，6&gt;=5</span><br><span class="line">5号卡车挂拖斗，运输3号货物，4+5&gt;=8</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">4 4 2 3</span><br><span class="line">9 6 7 8</span><br><span class="line">5 2 3 4</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1号卡车挂拖斗，运输4号货物，5+3&gt;=8</span><br><span class="line">4号卡车挂拖斗，运输3号货物，4+3&gt;=7</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>这道题是Leetcode 2071的原题。按照贪心的思想，如果我们可以完成<span class="math inline">\(k\)</span>个货物的运输，那么用载重最重的<span class="math inline">\(k\)</span>辆卡车运送<span class="math inline">\(k\)</span>个最轻的货物必定是一个解（包括使用拖斗），并且这个解是最极端的情况。</p><p>如果能够运送<span class="math inline">\(k\)</span>件货物，那么就存在一个运送<span class="math inline">\(k-1\)</span>个货物的方案，因此这道题我们可以使用二分进行求解。</p><p>现在需要判断<span class="math inline">\(k\)</span>件货物是否能够被运送。我们将使用载重最大的<span class="math inline">\(k\)</span>辆卡车运送最轻的<span class="math inline">\(k\)</span>个货物。我们从小到大遍历每个货物，每个货物用一个载重比它大，且最载重最小的卡车运行，这才符合我们贪心地思想。如果当前卡车并不能运送当前货物，那么在此之后它也不能够运送其它货物，他这时需要一个拖斗才能够运送，我们需要为这辆卡车添加一个拖斗，并且延后它的使用时期。如果这辆卡车装了拖斗依旧不能运送这个货物，那么说明这个<span class="math inline">\(k\)</span>不可行。最终，我们只需要判断拖斗的使用数量是否不超过<span class="math inline">\(x\)</span>即可。</p><p>此外还需要注意的是，如果一个卡车已经装载了拖斗后，和另一个没装拖斗的卡车载重相等，那么优先使用前一个卡车，因为后一个仍然有提升载重的潜力。</p><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> pi pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[N],l[N],n,m,x,y;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ok</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;pi,vector&lt;pi&gt;,greater&lt;pi&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">pi</span>(l[n-k+i],<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;)&#123;</span><br><span class="line">        <span class="keyword">auto</span> [ld,tp]=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(ld&gt;=w[i])&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tp==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">pi</span>(ld+y,<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt&lt;=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>,&amp;m,&amp;n,&amp;x,&amp;y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;l[i]);</span><br><span class="line">    <span class="built_in">sort</span>(w+<span class="number">1</span>,w+m+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(l+<span class="number">1</span>,l+n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">ok</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="built_in">min</span>(m,n);</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">ok</span>(mid)) l=mid;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>阿里控股 秋招 2023.09.23 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Alikonggu-20230923/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Alikonggu-20230923/</id>
    <published>2023-09-27T16:14:41.000Z</published>
    <updated>2023-09-28T07:26:16.300Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="小红的三元组">1、小红的三元组</h1><p>小红有一个长度为<span class="math inline">\(n\)</span>的数组<span class="math inline">\(a\)</span>，她每次操作可以删掉一个三元组<span class="math inline">\((x,y,z)\)</span>，要求<span class="math inline">\(x&lt;y&lt;z\)</span>，<span class="math inline">\(y\)</span>是<span class="math inline">\(x\)</span>的倍数，<span class="math inline">\(z\)</span>是<span class="math inline">\(y\)</span>的倍数。小红想知道最多可以执行多少次操作。</p><h2 id="输入">输入</h2><p>第一行一个整数<span class="math inline">\(n\)</span>，表示数组的长度。</p><p>第二行<span class="math inline">\(n\)</span>个整数<span class="math inline">\(a_1,a_2,\dots,a_n\)</span>，表示数组的元素。</p><ul><li><span class="math inline">\(1\le n\le 10^5\)</span></li><li><span class="math inline">\(1\le a_i\le 6\)</span></li></ul><h2 id="输出">输出</h2><p>输出一个整数，表示最多可以执行的操作次数。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">7</span><br><span class="line">1 1 2 3 4 5 6</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">先删除(1,2,4)，再删除(1,3,6)。</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>可见，满足题意的三元组只有可能是如下三种情况：<span class="math inline">\((1,2,4),(1,2,6),(1,3,6)\)</span>。</p><p>由于<span class="math inline">\(3,4\)</span>都在这些组合都出现了一次，因此我们优先取走<span class="math inline">\((1,2,4),(1,3,6)\)</span>这些组合，再取走<span class="math inline">\((1,2,6)\)</span>这种组合。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">14</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;v&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        ++a[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> u:v)&#123;</span><br><span class="line">        <span class="type">int</span> t=<span class="built_in">min</span>(a[u[<span class="number">0</span>]],<span class="built_in">min</span>(a[u[<span class="number">1</span>]],a[u[<span class="number">2</span>]]));</span><br><span class="line">        ans+=t;</span><br><span class="line">        a[u[<span class="number">0</span>]]-=t;</span><br><span class="line">        a[u[<span class="number">1</span>]]-=t;</span><br><span class="line">        a[u[<span class="number">2</span>]]-=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小红的连续字符串">2、小红的连续字符串</h1><p>小红有一个字符串<span class="math inline">\(s\)</span>，只包含小写字母。如果一个字符串中，不包含连续的三个相同的字母，并且不存在两个相同的字母紧挨着两个相同的字母，那么这个字符串就是合法的。例如，字符串<code>"aaa"</code>是不合法的，字符串<code>"aabb"</code>也是不合法的。字符串<code>"aab"</code>是合法的。</p><p>小红想知道，最少需要删除多少个字符，才能使得字符串变成合法的。</p><h2 id="输入-1">输入</h2><p>第一行一个字符串<span class="math inline">\(s\)</span>，长度不超过<span class="math inline">\(10^5\)</span>，只包含小写字母。</p><h2 id="输出-1">输出</h2><p>输出一个整数，表示最少需要删除的字符个数。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">aabbaa</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">删除一个字符b，得到aabaa，是一个合法的字符串。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">aaabbb</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">删除三个字符，得到aab，是一个合法的字符串。</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>由于不允许连续三个字母挨在一起，因此我们首先将连续多于两个字母的都删剩两个，然后再考虑下一步。</p><p>接下来每一块相同的字母不超过<span class="math inline">\(2\)</span>个。我们接下来从前往后遍历每个连续块。如果当前连续块的字母个数为<span class="math inline">\(2\)</span>，并且前一个连续块字母个数也为<span class="math inline">\(2\)</span>，那么删除当前块的一个字母（因为删除前面的并不会使结果变得更优）。</p><p>因此，只需要统计两个过程删去的字符数即可。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"><span class="type">int</span> a[N],m=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>,pre=s[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==pre) ++cnt;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            a[++m]=cnt;</span><br><span class="line">            cnt=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        a[i]=<span class="built_in">min</span>(a[i],<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">2</span>&amp;&amp;a[i]==<span class="number">2</span>&amp;&amp;a[i<span class="number">-1</span>]==<span class="number">2</span>)&#123;</span><br><span class="line">            --a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        s+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n-s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="有根树无重复数的路径">3、有根树无重复数的路径</h1><p>小红拿到了一个有根树，根节点为<span class="math inline">\(1\)</span>号节点，每个节点到其每个孩子有一条有向边。小红想取一条路径，满足路径上所有节点的权值都不相等。小红想知道，自己有多少种选择方案？</p><h2 id="输入-2">输入</h2><p>第一行输入一个正整数<span class="math inline">\(n\)</span>，代表节点的数量。</p><p>第二行输入<span class="math inline">\(n-1\)</span>个正整数<span class="math inline">\(a_i\)</span>，代表<span class="math inline">\(2\)</span>号节点到<span class="math inline">\(n\)</span>号节点每个节点的父亲编号。</p><p>第三行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(v_i\)</span>，代表<span class="math inline">\(1\)</span>号节点到<span class="math inline">\(n\)</span>号节点每个节点的权值。</p><ul><li><span class="math inline">\(2\le n\le 2\times 10^5\)</span></li><li><span class="math inline">\(1\le a_i&lt; i\le2\times10^5\)</span></li><li><span class="math inline">\(1\le v_i\le 10^9\)</span></li></ul><h2 id="输出-2">输出</h2><p>小山选择路径的方案数。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">1 1 1 2</span><br><span class="line">1 1 2 2 2</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">路径上有一个节点，有5种取法。</span><br><span class="line">路径上有两个节点的取法有： 1-3、1-4、2-5</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">1 1</span><br><span class="line">1 2 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">路径上有一个节点，有3种取法。</span><br><span class="line">路径上有两个节点的取法有： 1-2、1-3</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>假设我们现在处在节点<span class="math inline">\(u\)</span>，现在一直向父亲节点移动。在移动的过程中，一旦发现一个节点<span class="math inline">\(u&#39;\)</span>的权值出现过，那么说明再往上的路径都是不符合要求的。也就是说，如果<span class="math inline">\(w\)</span>是<span class="math inline">\(u&#39;\)</span>的子节点，又是<span class="math inline">\(u\)</span>的祖先，那么从<span class="math inline">\(w\)</span>到<span class="math inline">\(u\)</span>的路径中，以<span class="math inline">\(u\)</span>为终点的路径都是符合要求的，我们直接统计即可。</p><p>在实现过程中，我们并不能够直接寻找<span class="math inline">\(w\)</span>，因为这将导致<span class="math inline">\(O(n^2)\)</span>的时间复杂度。我们使用的做法是，假设现在遍历到了一个<span class="math inline">\(u\)</span>节点，并且已经知道了其父亲节点所对应的<span class="math inline">\(w\)</span>节点的深度为<span class="math inline">\(d\)</span>，那么如果<span class="math inline">\(u\)</span>的权值<span class="math inline">\(v_u\)</span>已经在从根到<span class="math inline">\(u\)</span>的路径上出现过，那么令其最深的深度为<span class="math inline">\(w_u\)</span>（否则，令<span class="math inline">\(w_u=0\)</span>，这里假设根节点的深度为<span class="math inline">\(1\)</span>），那么令<span class="math inline">\(d&#39;=\max\{d,w_u\}\)</span>，假设<span class="math inline">\(u\)</span>节点的深度为<span class="math inline">\(d_u\)</span>，那么就可以直接把<span class="math inline">\(d_u-d&#39;\)</span>统计到答案中。</p><p>由此我们维护好<span class="math inline">\(w_u\)</span>值，最终可以以<span class="math inline">\(O(n)\)</span>的时间完成本题。</p><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200004</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;g[N];</span><br><span class="line"><span class="type">int</span> a[N],n;</span><br><span class="line">map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt;v;</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> np,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!v[a[u]].<span class="built_in">empty</span>())&#123;</span><br><span class="line">        np=<span class="built_in">max</span>(np,v[a[u]].<span class="built_in">back</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    ans+=d-np;</span><br><span class="line">    v[a[u]].<span class="built_in">push_back</span>(d);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:g[u])&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(v,np,d+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v[a[u]].<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        g[x].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>米哈游 秋招 2023.09.24 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Mihayou-20230924/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Mihayou-20230924/</id>
    <published>2023-09-26T06:33:01.000Z</published>
    <updated>2023-09-27T06:55:48.762Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="相加异或">1、相加异或</h1><p>对于一个数组<span class="math inline">\(c\)</span>，定义<span class="math inline">\(f(c)\)</span>为<span class="math inline">\(c\)</span>数组所有元素的总和。</p><p>现在给定两个长度为<span class="math inline">\(n\)</span>的数组<span class="math inline">\(a,b\)</span>，请你恰好删除一个数组<span class="math inline">\(a\)</span>的元素或者一个数组<span class="math inline">\(b\)</span>的元素，使得<span class="math inline">\(f(a)\)</span>异或<span class="math inline">\(f(b)\)</span>最大。</p><h2 id="输入">输入</h2><p>第一行输入一个整数<span class="math inline">\(n\)</span>。</p><p>第二行输入<span class="math inline">\(n\)</span>个整数<span class="math inline">\(a_i\)</span>。</p><p>第三行输入<span class="math inline">\(n\)</span>个整数<span class="math inline">\(b_i\)</span>。</p><p><span class="math inline">\(1\le n,a_i,b_i \le 10^5\)</span></p><h2 id="输出">输出</h2><p>输出最大的异或和。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">3 2 1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">删除a数组的3。</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>令<span class="math inline">\(s_a\)</span>表示原来的数组<span class="math inline">\(a\)</span>中的元素和，<span class="math inline">\(s_b\)</span>表示原来的<span class="math inline">\(b\)</span>数组的元素和。那么对于删除<span class="math inline">\(a\)</span>中的某个元素<span class="math inline">\(a_i\)</span>后，最终<span class="math inline">\(f(a)\oplus f(b)=(s_a-a_i)\opluss_b\)</span>。对于<span class="math inline">\(b\)</span>数组也同理。因此最终答案为</p><p><span class="math display">\[\max_{i=1}^n\{\max\{(s_a-a_i)\opluss_b,(s_b-b_i)\oplus s_a\}\}\]</span></p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> sa=<span class="number">0</span>,sb=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        sa+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">        sb+=b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,(sa-a[i])^sb);</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,(sb-b[i])^sa);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="米小游与魔法少女-奇运">2、米小游与魔法少女-奇运</h1><p>米小游都快保底了还没抽到希儿，好生气哦！只能打会活动再拿点水晶。</p><p>米小游和世界第一可爱的魔法少女TeRiRi正在打BOSS，BOSS的血量为<span class="math inline">\(h\)</span>，当BOSS血量小于等于<span class="math inline">\(0\)</span>时，BOSS死亡。TeRiRi有一套牌，在一轮中，她会按顺序一张一张的将卡牌打出，套牌中有两种卡牌：</p><ol type="1"><li><strong>时来运转</strong>：获得<span class="math inline">\(x\)</span>个<strong>幸运币</strong>。</li><li><strong>幸运一掷</strong>：造成<span class="math inline">\(x\)</span>点伤害，并投掷所有<strong>幸运币</strong>，造成等于所有<strong>幸运币</strong>掷出的点数之和的伤害。</li></ol><p><strong>幸运币</strong>可以等概率的投掷出<span class="math inline">\(1\sim 6\)</span>之间的点数。（所以为什么不叫骰子呢？）</p><p>米小游想知道，TeRiRi的套牌在一轮内击杀BOSS的概率。</p><h2 id="输入-1">输入</h2><p>第一行输入两个整数<span class="math inline">\(n(1\le n\le 100),h(1\leh\le 10^9)\)</span>，分别表示卡牌张数和BOSS血量。</p><p>接下来<span class="math inline">\(n\)</span>行，每行首先输入两个整数<span class="math inline">\(t(1\le t\le2),x(1\le x\le 10)\)</span>，<span class="math inline">\(t\)</span>为<span class="math inline">\(1\)</span>表示卡牌为时来运转，<span class="math inline">\(t\)</span>为<span class="math inline">\(2\)</span>表示卡牌为幸运一掷。</p><h2 id="输出-1">输出</h2><p>输出一个实数表示答案，你的答案与标准答案的误差不超过<span class="math inline">\(10^{-4}\)</span>都被认为是正确答案。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">2 5</span><br><span class="line">1 1</span><br><span class="line">2 1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">0.5</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">幸运币掷出4及以上的概率为0.5，再加上1点固定伤害，即可击杀BOSS。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">3 1145</span><br><span class="line">1 4</span><br><span class="line">1 9</span><br><span class="line">1 9</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">无论如何都无法击杀BOSS。</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>需要注意的是，只有<strong>幸运一掷</strong>被使用出时，前面获得的<strong>幸运币</strong>才会有用处。如果到最后都没有使出过幸运一掷，那么最后得到的<strong>幸运币</strong>也是没有用处的。通过统计，我们最终可以知道有效被投掷的<strong>幸运币</strong>有<span class="math inline">\(a\)</span>个，并且<strong>幸运一掷</strong>造成的固定伤害总共为<span class="math inline">\(b\)</span>。</p><p>由于每个幸运币之间都是独立的，因此我们可以考虑将它们合并进行处理。我们将使用动态规划来解决本问题。令<span class="math inline">\(f(i,j)(0\le i\le a,0\le j\le 6i)\)</span>表示<span class="math inline">\(i\)</span>枚幸运币投掷出总点数<span class="math inline">\(j\)</span>的概率值，那么我们可以写出它的状态转移方程：</p><p><span class="math inline">\(f(i,j)= \left \{\begin{aligned}  &amp;1&amp; &amp; \text{if}\quad i=0\land j=0 \\  &amp;0 &amp; &amp;\text{if}\quad i=0\land j&gt;0\\  &amp;\dfrac{1}{6}\cdot\sum_{k=1}^{\min\{j,6\}} f(i-1,j-k) &amp;&amp; \text{if}\quad i&gt;0 \\ \end{aligned}\right.\)</span></p><p>由于每个骰子都能均等地以<span class="math inline">\(\dfrac{1}{6}\)</span>的概率投掷出从<span class="math inline">\(1\sim 6\)</span>中的一个值，因此从状态<span class="math inline">\(f(i,j)\)</span>能够以均等地概率转移到<span class="math inline">\(f(i+1,j+1),f(i+1,j+2),\dots,f(i+1,j+6)\)</span>。</p><p>由于还收到了<span class="math inline">\(b\)</span>点固定伤害，因此只需要造成至少<span class="math inline">\(h&#39;=\max\{0,h-b\}\)</span>点伤害，就能够击败BOSS，因此最终答案为<span class="math inline">\(\displaystyle{\sum_{j=h&#39;}^{6a}f(a,j)}\)</span>。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1002</span>;</span><br><span class="line"><span class="type">double</span> f[N][N*<span class="number">6</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,h,t,x;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>,tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;t,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">1</span>)&#123;</span><br><span class="line">            tmp+=x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            b+=x;a+=tmp;tmp=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=a;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=<span class="number">6</span>*a;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">6</span>&amp;&amp;k&lt;=j;k++)&#123;</span><br><span class="line">                f[i][j]+=f[i<span class="number">-1</span>][j-k]/<span class="number">6</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    h=<span class="built_in">max</span>(<span class="number">0</span>,h-b);</span><br><span class="line">    <span class="type">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=h;j&lt;=a*<span class="number">6</span>;j++)</span><br><span class="line">        ans+=f[a][j];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10f\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="米小游的极差之和">3、米小游的极差之和</h1><p>米小游拿到了一个数组<span class="math inline">\(a\)</span>，她用这个数组构造一个新数组<span class="math inline">\(b\)</span>，其中<span class="math inline">\(a_i\)</span>代表<span class="math inline">\(b\)</span>数组中有<span class="math inline">\(a_i\)</span>个<span class="math inline">\(i\)</span>。</p><p>例如，若<span class="math inline">\(a=[2,3,1]\)</span>，那么<span class="math inline">\(b=[1,1,2,2,2,3]\)</span>，因为<span class="math inline">\(a_1 = 2\)</span>，代表<span class="math inline">\(b\)</span>数组中有<span class="math inline">\(2\)</span>个<span class="math inline">\(1\)</span>；<span class="math inline">\(a_2=3\)</span>，代表<span class="math inline">\(b\)</span>数组中有<span class="math inline">\(3\)</span>个<span class="math inline">\(2\)</span>；<span class="math inline">\(a_3=1\)</span>，代表<span class="math inline">\(b\)</span>数组中有<span class="math inline">\(1\)</span>个<span class="math inline">\(3\)</span>。</p><p>现在给定<span class="math inline">\(a\)</span>数组，你需要帮米小游求出<span class="math inline">\(b\)</span>数组中所有连续子数组的极差之和。由于答案可能过大，请对<span class="math inline">\(10^9+7\)</span>取模。</p><p>数组的极差指最大值减去最小值。</p><h2 id="输入-2">输入</h2><p>第一行输入一个正整数<span class="math inline">\(n\)</span>，代表<span class="math inline">\(a\)</span>数组的元素数量。</p><p>第二行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(a_i\)</span>，代表<span class="math inline">\(a\)</span>数组的元素。</p><ul><li><span class="math inline">\(1\le n\le 10^5\)</span></li><li><span class="math inline">\(1 \le a_i \le 10^9\)</span></li></ul><h2 id="输出-2">输出</h2><p>一个整数，代表数组中所有区间的极差之和，对<span class="math inline">\(10^9+7\)</span>取模的值。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">2</span><br><span class="line">2 1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">a=[2,1]时，b数组为[1,1,2]。</span><br><span class="line">此时b数组共有6个连续子数组：</span><br><span class="line">[1]的极差为0。</span><br><span class="line">[1]的极差为0。</span><br><span class="line">[2]的极差为0。</span><br><span class="line">[1,1]的极差为0。</span><br><span class="line">[1,2]的极差为1。</span><br><span class="line">[1,1,2]的极差为1。</span><br><span class="line">因此答案是0+0+0+0+1+1=2。</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>由于<span class="math inline">\(b\)</span>是一个单调非递减数组，因此它的任意子数组极差就相当于是最后一个元素减去第一个元素的值。因此，只有最后一个元素的值和第一个不同时，才会对极差做出贡献。</p><p>可以知道，对于任意一对<span class="math inline">\(i,j(1\le i&lt;j\len)\)</span>，<span class="math inline">\(b\)</span>中都有<span class="math inline">\(a_i\cdot a_j\)</span>个子数组以<span class="math inline">\(i\)</span>开头，以<span class="math inline">\(j\)</span>结尾，它们都做出了<span class="math inline">\(j-i\)</span>的贡献。因此，这道题的答案为<span class="math inline">\(\displaystyle{\sum_{i=1}^n\sum_{j=i+1}^n(j-i)\cdot a_i\cdot a_j}\)</span>，令<span class="math inline">\(\displaystyle{s_i=\sum_{i=1}^na_i,s_0=0,t_i=\sum_{i=1}^n i\cdota_i,t_0=0}\)</span>。那么我们可以将这个结果进一步化简一下，有：</p><p><span class="math inline">\(\begin{aligned}&amp;\sum_{i=1}^n\sum_{j=i+1}^n (j-i)\cdot a_i\cdot a_j\\=&amp;\sum_{i=1}^n a_i\cdot\left(\sum_{j=i+1}^n (j-i)\cdot a_j\right)\\=&amp;\sum_{i=1}^n a_i\cdot\left(\sum_{j=i+1}^n j\cdota_j-i\cdot\sum_{j=i+1}^n a_j\right)\\ =&amp;\sum_{i=1}^na_i\cdot((t_n-t_i)-i\cdot(s_n-s_i))\\ \end{aligned}\)</span></p><p>由此，我们可以在<span class="math inline">\(O(n)\)</span>的时间内，通过计算<span class="math inline">\(s,t\)</span>，从而计算出最终结果。</p><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line">ll a[N],s1[N],s2[N];</span><br><span class="line">ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">        s1[i]=(s1[i<span class="number">-1</span>]+a[i])%mod;</span><br><span class="line">        s2[i]=(s2[i<span class="number">-1</span>]+a[i]*i)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans+=((s2[n]-s2[i])-(s1[n]-s1[i])*i%mod)*a[i]%mod;</span><br><span class="line">        ans=(ans%mod+mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>字节跳动 秋招 2023.09.24 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Zijietiaodong-20230924/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Zijietiaodong-20230924/</id>
    <published>2023-09-25T05:19:40.000Z</published>
    <updated>2023-09-25T05:19:40.673Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="小红的01串">1、小红的<code>01</code>串</h1><p>小红拿到了一个<code>01</code>串，她准备将若干个字符<code>'1'</code>染成红色，将若干个字符<code>'0'</code>染成蓝色，但有个限制：如果一个<code>'0'</code>和一个<code>'1'</code>相邻，那么它们不能同时染色。</p><p>小红想知道，最多可以染多少个字符？</p><h2 id="输入">输入</h2><p>输入仅有一行，为小红拿到的<code>01</code>串。</p><p>字符串长度不超过<span class="math inline">\(200000\)</span>。</p><h2 id="输出">输出</h2><p>一个正整数，代表能染色的最多字符。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">110011</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">染红第一个、第三个、第五个、第六个字符即可。</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>对于一个<code>01</code>相间，长度为<span class="math inline">\(n\)</span>的比特串，对它染色的最多个数为<span class="math inline">\(\lceiln/2\rceil\)</span>，因为相邻两个不能同时染色。</p><p>因此，我们对原来的字符串分拆成多个<strong>极大</strong><code>01</code>相间子串（即前一个子串的最后一个字符要和后一个子串的第一个字符相同），分别统计它们的最多染色数并相加即可。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200004</span>;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j;i&lt;=n;i=j)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;=n&amp;&amp;s[j]!=s[j<span class="number">-1</span>];++j);</span><br><span class="line">        ans+=(j-i+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小红刷抖音">2、小红刷抖音</h1><p>小红很喜欢刷抖音，抖音后台有一个推荐系统，小红向上滑动屏幕时，该推荐系统会计算应显示给小红的短视频。</p><p>用数值量化而言，每个短视频有一个内存占用<span class="math inline">\(a_i\)</span>（画质越好的视频内存占用越大），以及该视频可以带给小红愉悦度为<span class="math inline">\(b_i\)</span>。</p><p>值得注意的是，当小红每次重复刷到同一个视频时，观看该视频获得的愉悦度会除以<span class="math inline">\(2\)</span>（向下取整）。</p><p>例如，若一个视频初始给小红获得的愉悦度为<span class="math inline">\(5\)</span>，那么第二次小红获得的愉悦度会变成2，第三次为<span class="math inline">\(1\)</span>，第四次以后再刷到这个视频获得的愉悦度就为0了。</p><p>小红一共进行了<span class="math inline">\(q\)</span>次刷视频操作。</p><p>为了使得手机不卡顿，推荐系统每次会选择一个内存占用不高于<span class="math inline">\(x_i\)</span>的视频。</p><p>如果有多个这样的视频，推荐系统会推荐满足条件的播放画质最好的那个视频（即内存占用最高的视频）。</p><p>如果有多个视频的画质都是最好，那么推荐系统会推荐当前愉悦度最高的视频。</p><p>当小红观看完这个视频后，即可获得该视频的愉悦度，请你计算小红刷完所有视频时获得的总愉悦度。</p><h2 id="输入-1">输入</h2><p>第一行输入两个正整数<span class="math inline">\(n,q\)</span>，代表视频的总数量、小红刷视频的次数。</p><p>第二行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(a_i\)</span>，代表每个视频的内存占用。</p><p>第三行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(b_i\)</span>，代表每个视频第一次观看时给小红带来的愉悦值。</p><p>第四行输入<span class="math inline">\(q\)</span>个正整数<span class="math inline">\(x_i\)</span>，代表每次小红刷视频时，系统推荐的视频占用内存的上限。</p><ul><li><span class="math inline">\(1\le n,q \le 10^5\)</span></li><li><span class="math inline">\(1 \le a_i,b_i,z_i\le 10^9\)</span></li><li>保证<span class="math inline">\(x_i\)</span>一定不小于<span class="math inline">\(a_i\)</span>的最小值。</li></ul><h2 id="输出-1">输出</h2><p>一个整数，代表小红获得的愉悦度总和。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3 4</span><br><span class="line">3 5 1</span><br><span class="line">3 4 2</span><br><span class="line">3 3 6 1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">第一次刷视频，推荐系统推荐给小红第一个视频。小红获得愉悦度3。</span><br><span class="line">第二次刷视频，推荐系统推荐给小红第一个视频。由于是第二次观看，小红获得愉悦度1。</span><br><span class="line">第三次刷视频，推荐系统推荐给小红第二个视频。小红获得愉悦度4。</span><br><span class="line">第四次刷视频，推荐系统推荐给小红第三个视频。小红获得愉悦度2。</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>这题由于是优先查找内存不超过<span class="math inline">\(x_i\)</span>且取最大，再查找愉悦值最大，因此我们可以使用一个有序的数据结构进行解决。</p><p>具体做法是将每个不同的内存占用作为键，其对应的愉悦值可以用一个最大堆进行存储。由此，C++的<code>map</code>是最满足当前需要的容器。对于一次查询<span class="math inline">\(x_i\)</span>，只需要通过二分在<code>map</code>中找到最大的那个内存值，然后再将对应的最大堆元素取出，计入答案，并将其整除<span class="math inline">\(2\)</span>的值重新插入最大堆即可。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line">map&lt;<span class="type">int</span>,priority_queue&lt;<span class="type">int</span>&gt;&gt;mp;</span><br><span class="line"><span class="type">int</span> a[N],b[N],n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) mp[a[i]].<span class="built_in">push</span>(b[i]);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="keyword">auto</span> it=mp.<span class="built_in">upper_bound</span>(x);</span><br><span class="line">        --it;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>&gt;&amp;q=it-&gt;second;</span><br><span class="line">        <span class="type">int</span> k=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        ans+=k;</span><br><span class="line">        q.<span class="built_in">push</span>(k&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小红玩大富翁游戏">3、小红玩大富翁游戏</h1><p>小红在玩一个大富翁游戏，游戏的地图为一排房子，从左到右编号依次从<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>。</p><p>每个房子有一个购买价格<span class="math inline">\(a_i\)</span>和一个经过它的房租价格<span class="math inline">\(b_i\)</span>，当小红经过一个自己没有购买的房子时，她就需要交房租（已购买的房子则不需要交房租）。</p><p>在游戏开始前，小红可以购买任意数量的房子，然后开始游戏。</p><p>游戏中，小红会按照一个给定的排列<span class="math inline">\(p\)</span>的顺序依次经过所有的房子（排列<span class="math inline">\(p\)</span>为房子的编号顺序，<span class="math inline">\(p\)</span>的大小为<span class="math inline">\(n\)</span>，即每个房子都会作为一次目标）。</p><p>小红每经过一套房子都需要交租金，除非已购买。初始小红在第一个房子的左边，当她按照顺序经过了所有房子后，<strong>她会再次移动到第<span class="math inline">\(n\)</span>个房子的右边</strong>。</p><p>请你计算小红最少的总花费。</p><h2 id="输入-2">输入</h2><p>第一行输入一个整数<span class="math inline">\(n(1\le n\le10^5)\)</span>，代表房子的总数。</p><p>第二行输入一个排列<span class="math inline">\(p_i(1\le p_i\len)\)</span>，代表小红经过的房子编号顺序。</p><p>第三行输入<span class="math inline">\(n\)</span>个整数<span class="math inline">\(a_i(1\le a_i\le 10^9)\)</span>，代表编号<span class="math inline">\(i\)</span>的房子的购买价格。</p><p>第四行输入<span class="math inline">\(n\)</span>个整数<span class="math inline">\(b_i(1\le b_i \le 10^9)\)</span>，代表编号<span class="math inline">\(i\)</span>房子的经过房租价格。</p><p>保证<span class="math inline">\([1,n]\)</span>中每个数在<span class="math inline">\(p\)</span>数组中都出现且仅出现一次。</p><h2 id="输出-2">输出</h2><p>一行一个整数，表示最少的花费。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">4</span><br><span class="line">1 3 2 4</span><br><span class="line">5 4 2 4</span><br><span class="line">1 3 1 1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">游戏开始前买下第二个房子，花费4。</span><br><span class="line">开始游戏时，小红先向右走一步到达1号房子，房租价格为1。</span><br><span class="line">然后向右走2步到达3号房子，当小红经过2号房子时，由于2号房子已经购买，则不用交房租。然后到达3号房子时交房租价格为1。</span><br><span class="line">然后向左走1步到达2号房子，不需要交房租。</span><br><span class="line">然后向右走2步到达4号房子，经过的3号房子和4号房子分别交价格为1的房租。</span><br><span class="line">最后向右离开这个大富翁地图。</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>我们需要统计每个房子被经过的次数<span class="math inline">\(c_i\)</span>，那么最终答案为<span class="math inline">\(\displaystyle{\sum_{i=1}^n\min\{a_i,b_i\cdotc_i\}}\)</span>，也就是说，如果<span class="math inline">\(a_i\leb_i\cdot c_i\)</span>，那么就租下第<span class="math inline">\(i\)</span>栋房子，否则不租。</p><p>为了求出数组<span class="math inline">\(c_i\)</span>，我们可以考虑使用差分数组进行解决。假设<span class="math inline">\(t\)</span>是差分数组，并且目前处在位置<span class="math inline">\(x\)</span>，并且走向<span class="math inline">\(y\)</span>（为了避免端点重复计算，这一个过程只会计算终点<span class="math inline">\(y\)</span>的价值）。如果<span class="math inline">\(x&lt;y\)</span>，那么就对<span class="math inline">\(t_{x+1}\)</span>加上<span class="math inline">\(1\)</span>，对<span class="math inline">\(t_{y+1}\)</span>减去<span class="math inline">\(1\)</span>。如果<span class="math inline">\(x&gt;y\)</span>，那么就对<span class="math inline">\(t_x\)</span>减去<span class="math inline">\(1\)</span>，<span class="math inline">\(t_y\)</span>加上<span class="math inline">\(1\)</span>。</p><p>对于题目输入的排列。我们只需要令<span class="math inline">\(p_0=0,p_{n+1}=n+1\)</span>，那么整个过程就恰好不重不漏地完成计算，最终有<span class="math inline">\(c_i=c_{i-1}+t_i,c_0=0\)</span>。此后直接计算答案即可。</p><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200004</span>;</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="type">int</span> p[N],a[N],b[N],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">    ++s[<span class="number">1</span>];</span><br><span class="line">    --s[p[<span class="number">1</span>]+<span class="number">1</span>];</span><br><span class="line">    ++s[p[n]+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x=p[i],y=p[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(x&lt;y)&#123;</span><br><span class="line">            ++s[x+<span class="number">1</span>];--s[y+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ++s[y];--s[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        s[i]+=s[i<span class="number">-1</span>];</span><br><span class="line">        ans+=<span class="built_in">min</span>(<span class="number">1ll</span>*a[i],<span class="number">1ll</span>*b[i]*s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小红的机器人">4、小红的机器人</h1><p>小红有一个机器人，她可以对机器人进行以下<span class="math inline">\(4\)</span>种指令：</p><ul><li><code>L</code>：向左一步。</li><li><code>R</code>：向右一步。</li><li><code>U</code>: 向上一步。</li><li><code>D</code>: 向下一步。小红现在给定了一个指令集（有上下左右最多四种操作）。</li></ul><p>小红希望选出一个非空子序列（在指令集中可以不连续），使得机器人执行这段子序列指令后回到原地。小红想知道最终有多少选择方式？由于答案可能过大，请对<span class="math inline">\(10^9+7\)</span>取模。</p><p>我们定义，两个子序列中存在某位置字母的选择情况不同（例如在第一个子序列中选择了第<span class="math inline">\(x\)</span>个字符，而在第二个子序列中没选），则称为两个不同的子序列。</p><h2 id="输入-3">输入</h2><p>一行仅包含<code>'L', 'R', 'U', 'D'</code>四种字符的字符串，长度不超过<span class="math inline">\(500000\)</span>。</p><h2 id="输出-3">输出</h2><p>一个整数，代表子序列的选择方案。</p><h2 id="样例-3">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">LLRUU</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">第一种方案：选择第一个字符和第三个字符组成子序列&quot;LR&quot;，向左走一步，向右走一步，回到原点。</span><br><span class="line">第二种方案：选择第二个字符和第三个字符组成子序列&quot;LR&quot;，向左走一步，向右走一步，回到原点。</span><br></pre></td></tr></table></figure><h2 id="解答-3">解答</h2><p>可以发现，这些指令是没有顺序性的。即前面的指令执行结果并不会影响后面的执行执行结果。因此，最终机器人的位置只和不同指令的个数有关，而和顺序没有关系。</p><p>如果一条非空指令能够使机器人回到原点，那么<code>L, R</code>的数量必须相等，<code>U, D</code>的数量必须相等。并且可以发现，两个维度的坐标都是独立互不干扰的，可以使用乘法原理计算完成。</p><p>因此，假设<span class="math inline">\(c_L,c_R,c_U,c_D\)</span>分别是输入的字符串的<code>L, R, U, D</code>的指令数，那么我们可以得到最终答案为：</p><p><span class="math display">\[\left(\sum_{i=0}^{\min\{c_L,c_R\}}\dbinom{c_L}{i}\cdot\dbinom{c_R}{i}\right)\cdot\left(\sum_{i=0}^{\min\{c_U,c_D\}}\dbinom{c_U}{i}\cdot\dbinom{c_D}{i}\right)-1\]</span></p><p>其中最后的<span class="math inline">\(-1\)</span>是指指令为空的情况。</p><p>本题的实现基于线性逆元，当然也可以不写，直接求出阶乘再计算逆元也是可以的。</p><h2 id="代码-3">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">500004</span>;</span><br><span class="line">ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll fac[N],finv[N],inv[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=fac[<span class="number">1</span>]=inv[<span class="number">1</span>]=finv[<span class="number">0</span>]=finv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">        inv[i]=(mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">        finv[i]=finv[i<span class="number">-1</span>]*inv[i]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fac[n]*finv[n-m]%mod*finv[m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> cnt[<span class="number">128</span>];</span><br><span class="line"><span class="function">ll <span class="title">cal</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> w=<span class="built_in">min</span>(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=w;i++)</span><br><span class="line">        ans=(ans+<span class="built_in">C</span>(x,i)*<span class="built_in">C</span>(y,i))%mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">init</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ++cnt[s[i]];</span><br><span class="line">    ll m1=<span class="built_in">cal</span>(cnt[<span class="string">&#x27;L&#x27;</span>],cnt[<span class="string">&#x27;R&#x27;</span>]);</span><br><span class="line">    ll m2=<span class="built_in">cal</span>(cnt[<span class="string">&#x27;U&#x27;</span>],cnt[<span class="string">&#x27;D&#x27;</span>]);</span><br><span class="line">    ll ans=m1*m2%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>网易 秋招 2023.09.23 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Wangyi-20230923B/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Wangyi-20230923B/</id>
    <published>2023-09-25T05:19:38.000Z</published>
    <updated>2023-09-25T05:19:38.427Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="小红的字符串查询">1、小红的字符串查询</h1><p>小红拿到了一个字符串。她有多次查询，每次查询一个区间，你需要回答该区间包含了多少个长度为<span class="math inline">\(3\)</span>的、所有字母都相等的连续子串。</p><h2 id="输入">输入</h2><p>第一行输入两个正整数<span class="math inline">\(n,k\)</span>，代表字符率长度和查询次数。</p><p>第二行输入一个长度为<span class="math inline">\(n\)</span>的、仅包含小写字母的字符串。</p><p>接下来的<span class="math inline">\(k\)</span>行，每行输入两个正整数<span class="math inline">\(l,r\)</span>，代表一次查询。</p><ul><li><span class="math inline">\(l \le n,k \le 10^5\)</span></li><li><span class="math inline">\(1\le l\le r\le n\)</span></li></ul><h2 id="输出">输出</h2><p>输出<span class="math inline">\(k\)</span>行，每行输出一个整数表示答案。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">8 4</span><br><span class="line">aaaaabbb</span><br><span class="line">1 8</span><br><span class="line">2 7</span><br><span class="line">3 6</span><br><span class="line">4 5</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>这题使用前缀和将会变得非常简单。令<span class="math inline">\(f_i(i\ge 3)\)</span>表示字符串的三个字母<span class="math inline">\(s_{i-2},s_{i-1},s_{i}\)</span>是否相等，如果相等，那么为<span class="math inline">\(1\)</span>，否则为<span class="math inline">\(0\)</span>，其中<span class="math inline">\(f_1=f_2=0\)</span>。</p><p>那么，令<span class="math inline">\(t_i=\displaystyle{\sum_{j=1}^if_j},t_0=0\)</span>表示<span class="math inline">\(f\)</span>的前缀和，因此对于每次询问<span class="math inline">\(l,r\)</span>，只需要回答值<span class="math inline">\(\max\{0,t_r-t_{l+1}\}\)</span>即可。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"><span class="type">char</span> t[N];</span><br><span class="line"><span class="type">int</span> s[N],n,q,l,r;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %s&quot;</span>,&amp;n,&amp;q,t+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[i]==t[i<span class="number">-1</span>]&amp;&amp;t[i]==t[i<span class="number">-2</span>])&#123;</span><br><span class="line">            s[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s[i]+=s[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        l+=<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,l&gt;r?<span class="number">0</span>:s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小红的数组构造">2、小红的数组构造</h1><p>小红有一个数组，数组相邻元素的差值最多为<span class="math inline">\(1\)</span>，即<span class="math inline">\(|a_i-a_{i+1}|\le1\)</span>，并且数组元素都是正整致，即<span class="math inline">\(a_i\ge1\)</span>，现在小红知道数组的长度为<span class="math inline">\(n\)</span>，数组的和为<span class="math inline">\(m\)</span>，小红想知道所有符合条件的数组中，<span class="math inline">\(a_p\)</span>的最大值是多少。</p><h2 id="输入-1">输入</h2><p>第一行三个整数<span class="math inline">\(n,m,p\)</span>，表示数组的长度，数组的和，以及要求的位置。</p><ul><li><span class="math inline">\(1\le p\le n\le m\le 10^9\)</span></li></ul><h2 id="输出-1">输出</h2><p>输出一个整数，表示位置<span class="math inline">\(a_p\)</span>的最大值。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">4 5 2</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">数组[1,2,1,1] 满足条件，且位置2的最大值为2。</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>这道题可以使用二分法进行求解。接下来元素<span class="math inline">\(a_p\)</span>是否可以取到<span class="math inline">\(x\)</span>。</p><p>为了元素<span class="math inline">\(a_p\)</span>是否可以取到<span class="math inline">\(x\)</span>，那么其它元素得值尽可能低。于此同时为了维持相邻元素的绝对差不超过<span class="math inline">\(1\)</span>这个性质，对于元素<span class="math inline">\(a_q\)</span>，如果<span class="math inline">\(q&gt;p\)</span>，那么<span class="math inline">\(a_q\)</span>就要比<span class="math inline">\(a_{q-1}\)</span>少<span class="math inline">\(1\)</span>；如果<span class="math inline">\(q&lt;p\)</span>，那么<span class="math inline">\(a_q\)</span>就要比<span class="math inline">\(a_{q+1}\)</span>少<span class="math inline">\(1\)</span>，直到恰好为<span class="math inline">\(0\)</span>。</p><p>这种情况是最节省和值的使用的，我们可以通过逐渐为其它元素加上<span class="math inline">\(1\)</span>，直到总和达到<span class="math inline">\(m\)</span>，如果总和达不到<span class="math inline">\(m\)</span>，那么<span class="math inline">\(a_p\)</span>必定不止<span class="math inline">\(x\)</span>。因此，我们不需要考虑<span class="math inline">\(a_p\)</span>的上界。</p><p>更一般的来说，如果第<span class="math inline">\(a_p=x\)</span>，那么最节省和值方法的形状如下：</p><p><span class="math display">\[0,0,0,\dots,0,1,2\dots,x-1,x,x-1,x-2,\dots2,1,0,\dots,0\]</span></p><p>注意，两端可能没有取到<span class="math inline">\(0\)</span>就结束了。</p><p>由于两边的处理方式是一样的，因此只需要考虑其中一侧。令<span class="math inline">\(f(n,x)\)</span>表示现在有<span class="math inline">\(n\)</span>个数组元素，其中最后一个元素为<span class="math inline">\(x\)</span>时，最少需要消耗的和值。按照等差数列求和公式，那么可以写出</p><p><span class="math inline">\(f(n,x)= \left\{\begin{aligned}  &amp;\dfrac{(2x-n+1)n}{2} &amp; &amp; \text{if}\quadx\ge n \\  &amp;\dfrac{(x+1)x}{2} &amp; &amp; \text{if}\quad x&lt;n \\\end{aligned}\right.\)</span></p><p>因此，判断第<span class="math inline">\(x\)</span>栋楼高度是否为至少<span class="math inline">\(h\)</span>，只需要判断<span class="math inline">\(f(p,x)+f(n-p+1,x)-x\lem\)</span>是否满足即可。</p><h2 id="代码-1">代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">n, m, p = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cal2</span>(<span class="params">n, x</span>):</span><br><span class="line">    <span class="keyword">if</span> x &gt;= n:</span><br><span class="line">        <span class="keyword">return</span> (x + x - n + <span class="number">1</span>) * n // <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> (x + <span class="number">1</span>) * x // <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cal</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> cal2(p, x) + cal2(n - p + <span class="number">1</span>, x) - x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">l, r = <span class="number">1</span>, m</span><br><span class="line"><span class="keyword">while</span> l &lt; r:</span><br><span class="line">    mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> cal(mid) &lt;= m:</span><br><span class="line">        l = mid</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r = mid - <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(l)</span><br></pre></td></tr></table></figure><h1 id="小红的树上路径与">3、小红的树上路径与</h1><p>小红拿到了一棵树，她定义一条路径的权值为路径上所有节点权值按位与计算出的值。小红想知道，所有路径的权值之和等于多少？答案请对<span class="math inline">\(10^9+7\)</span>取模。</p><h2 id="输入-2">输入</h2><p>第一行输入一个正整数<span class="math inline">\(n\)</span>，代表树的节点数量。</p><p>第二行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(a_i\)</span>，代表每个节点的权值。</p><p>接下来的<span class="math inline">\(n-1\)</span>行，每行输入<span class="math inline">\(2\)</span>个正整数<span class="math inline">\(u,v\)</span>，代表节点<span class="math inline">\(u\)</span>和节点<span class="math inline">\(v\)</span>有一条无向边连接。</p><ul><li><span class="math inline">\(1\le n\le 10^5\)</span></li><li><span class="math inline">\(1\le a_i\le 10^9\)</span></li></ul><h2 id="输出-2">输出</h2><p>一个整数，代表所有路径的权值之和。由于答案过大，请对<span class="math inline">\(10^9+7\)</span>取模。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">3 6 4</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">路径1-2的权值为3&amp;6，管案是2。</span><br><span class="line">路径2-3的权值为6&amp;4，答案是4。</span><br><span class="line">路径1-2-3的权值为3&amp;6&amp;4，管案是0。</span><br><span class="line">因此所有路程的权值之和是2+4=6。</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>由于不同数位之间的比特都是相互独立的，因此我们对同一数位进行处理即可。</p><p>不失一般性，我们只讨论最低位的情况。对于<span class="math inline">\(u,v\)</span>间的路径的与值为<span class="math inline">\(1\)</span>，当且仅当<span class="math inline">\(u,v\)</span>之间所有的节点值都为<span class="math inline">\(1\)</span>。由于原图是一棵树，因此我们去除所有<span class="math inline">\(0\)</span>节点后，可以发现这个图变成了一个森林，其中每个连通块都是一棵树。同一连通块下的任意一对节点的与值都为<span class="math inline">\(1\)</span>，因此我们统计每个连通块的节点数<span class="math inline">\(c\)</span>后，可以知道这里面一共有<span class="math inline">\(\dfrac{c(c+1)}{2}\)</span>条路径可以添加到答案中。</p><p>这里使用了并查集来求取每个连通块中的节点数。</p><p>因此回到原题，假设所有数第<span class="math inline">\(i\)</span>位做出的贡献为<span class="math inline">\(v_i\)</span>，那么最终答案为<span class="math inline">\(\displaystyle{\sum_{i=0}^{\infty}2^i\cdotv_i}\)</span>。</p><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> pi pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line">ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> fa[N],sz[N],n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">vector&lt;pi&gt;e;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="built_in">find</span>(x),v=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(u!=v)&#123;</span><br><span class="line">        fa[v]=u;</span><br><span class="line">        sz[u]+=sz[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        fa[i]=i;sz[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[x,y]:e)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[x]&amp;&amp;b[y])</span><br><span class="line">            <span class="built_in">merge</span>(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i]&amp;&amp;i==<span class="built_in">find</span>(i))</span><br><span class="line">            ans+=<span class="number">1ll</span>*sz[i]*(sz[i]<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        e.<span class="built_in">push_back</span>(<span class="built_in">pi</span>(x<span class="number">-1</span>,y<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">b</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            b[j]=a[j]&gt;&gt;i&amp;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=(ans+(<span class="built_in">solve</span>(b)&lt;&lt;i))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小红的数列">4、小红的数列</h1><p>小红拿到了一个数列，该数列满足以下性质：</p><ol type="1"><li><span class="math inline">\(f(1)=a,f(2)=b\)</span></li><li><span class="math inline">\(f(i)=f(i-1)\cdot f(i-2)\cdotc^d\)</span></li></ol><p>请你计算出该数列的第<span class="math inline">\(n\)</span>项的因子数量。由于答案过大，请对<span class="math inline">\(10^9+7\)</span>取模。</p><h2 id="输入-3">输入</h2><p>五个正整数<span class="math inline">\(a,b,c,d,n\)</span>。</p><ul><li><span class="math inline">\(l\le a,b,c,d,n\le 10^{12}\)</span></li></ul><h2 id="输出-3">输出</h2><p>第<span class="math inline">\(n\)</span>项的因子数量对<span class="math inline">\(10^9+7\)</span>取模的值。</p><h2 id="样例-3">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">1 2 3 4 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">第三项是162，共有10个因子。</span><br></pre></td></tr></table></figure><h2 id="解答-3">解答</h2><p>如果一个数<span class="math inline">\(n\)</span>可以被分解成<span class="math inline">\(\displaystyle{n=\prod_{i=1}^mp_i^{e_i}}\)</span>，那么它的因子个数为<span class="math inline">\(\displaystyle{\sigma_0(n)=\prod_{i=1}^m(e_i+1)}\)</span>。</p><p>因此，我们可以考虑找出<span class="math inline">\(f(n)\)</span>的因式分解，并使用上面的公式进行求解出最终答案。</p><p>假设质因子<span class="math inline">\(p\)</span>在<span class="math inline">\(n\)</span>的质因数分解出现的次数记为<span class="math inline">\(g(n,p)\)</span>，令<span class="math inline">\(f_p(n)=g(f(n),p)\)</span>，那么按照上面<span class="math inline">\(f\)</span>的式子，我们可以得到：</p><p><span class="math display">\[f_p(n)=f_p(n-1)+f_p(n-2)+g(c,p)\cdotd\]</span></p><p>这和斐波那契数列非常像，更一般的，我们将它写成矩阵相乘的形式：</p><p><span class="math display">\[\begin{aligned}[f_p(n),f_p(n+1),g(c,p)\cdot d]&amp;=[f_p(n-1),f_p(n),g(c,p)\cdotd]\cdot\begin{bmatrix}0&amp;1&amp;0\\1&amp;1&amp;0\\0&amp;1&amp;1\\\end{bmatrix}\\&amp;=[f_p(1),f_p(2),g(c,p)\cdot d]\cdot\begin{bmatrix}0&amp;1&amp;0\\1&amp;1&amp;0\\0&amp;1&amp;1\\\end{bmatrix}^{n-1}\\&amp;=[g(a,p),g(b,p),g(c,p)\cdot d]\cdot\begin{bmatrix}0&amp;1&amp;0\\1&amp;1&amp;0\\0&amp;1&amp;1\\\end{bmatrix}^{n-1}\end{aligned}\]</span></p><p>其中，最后一行通过矩阵快速幂即可完成。</p><p>因此，最终答案为<span class="math inline">\(\displaystyle{\prod_p(f_p(n)+1)}\)</span>。其余的任务就是对<span class="math inline">\(a,b,c\)</span>进行因式分解，这没有任何难度。</p><h2 id="代码-3">代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> factorint</span><br><span class="line"></span><br><span class="line">mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">a: <span class="built_in">list</span>, b: <span class="built_in">list</span></span>):</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">sum</span>(a[i][k] * b[k][j] <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(b))) % mod <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(b[<span class="number">0</span>]))] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a))]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a, b, c, d, n = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">fa, fb, fc = <span class="built_in">dict</span>(factorint(a).items()), <span class="built_in">dict</span>(factorint(b).items()), <span class="built_in">dict</span>(factorint(c).items())</span><br><span class="line">mp = &#123;x: [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>(fa.keys()) + <span class="built_in">list</span>(fb.keys()) + <span class="built_in">list</span>(fc.keys())&#125;</span><br><span class="line"><span class="keyword">for</span> p, e <span class="keyword">in</span> fa.items():</span><br><span class="line">    mp[p][<span class="number">0</span>] += e</span><br><span class="line"><span class="keyword">for</span> p, e <span class="keyword">in</span> fb.items():</span><br><span class="line">    mp[p][<span class="number">1</span>] += e</span><br><span class="line"><span class="keyword">for</span> p, e <span class="keyword">in</span> fc.items():</span><br><span class="line">    mp[p][<span class="number">2</span>] += e</span><br><span class="line"></span><br><span class="line">ans = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> mp.values():</span><br><span class="line">    a = [[v[<span class="number">0</span>], v[<span class="number">1</span>], v[<span class="number">2</span>] * d]]</span><br><span class="line">    b = [[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]]</span><br><span class="line">    k = n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k:</span><br><span class="line">        <span class="keyword">if</span> k &amp; <span class="number">1</span>:</span><br><span class="line">            a = mul(a, b)</span><br><span class="line">        b = mul(b, b)</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span></span><br><span class="line">    ans = ans * (a[<span class="number">0</span>][<span class="number">0</span>] + <span class="number">1</span>) % mod</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>网易 秋招 2023.09.23 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Wangyi-20230923A/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Wangyi-20230923A/</id>
    <published>2023-09-25T05:19:36.000Z</published>
    <updated>2023-09-25T05:19:36.178Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="小红的有序数组">1、小红的有序数组</h1><p>小红有一个长度为<span class="math inline">\(n\)</span>的数组，数组下标为<span class="math inline">\(0\)</span>到<span class="math inline">\(n-1\)</span>，每次可以交换下标为<span class="math inline">\(i\)</span>和<span class="math inline">\((i+2)\%n\)</span>的数，请问小红能否通过有限次交换使得数组变成一个单调不减的数组。</p><h2 id="输入">输入</h2><p>第一行一个整数<span class="math inline">\(t\)</span>，表示数据组数。</p><p>接下来<span class="math inline">\(t\)</span>组数据，每组数据第一行一个整数<span class="math inline">\(n\)</span>，表示数组长度。</p><p>每组数据第二行<span class="math inline">\(n\)</span>个整数<span class="math inline">\(a_i\)</span>，表示数组的值。</p><ul><li><span class="math inline">\(1 \le t \le 10\)</span>-</li><li><span class="math inline">\(1 \le n \le 10^5\)</span></li><li><span class="math inline">\(1 \le a_i \le 10^9\)</span></li></ul><h2 id="输出">输出</h2><p>对于每组数据，如果能够通过有限次交换使得数组变成一个单调不减的数组，输出<code>"YES"</code>，否则输出<code>"NO"</code>。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">1 4 3 2</span><br><span class="line">4</span><br><span class="line">4 3 2 1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">YES</span><br><span class="line">NO</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">第一组数据，交换下标为1和3的数，变成[1,2,3,4]单调不减。</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>首先我们可以知道有如下性质：交换关系是有传递性的，即如果下标为<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>的元素能够进行交换，<span class="math inline">\(y\)</span>和<span class="math inline">\(z\)</span>的元素能够进行交换，那么<span class="math inline">\(x\)</span>和<span class="math inline">\(z\)</span>的元素也是能够进行交换的。</p><p>因此对于<span class="math inline">\(n\)</span>的奇偶性，我们分两种情况进行讨论：</p><ol type="1"><li><p>当<span class="math inline">\(n\)</span>为奇数时，对于<span class="math inline">\(i&lt;n-2\)</span>的情况，都是同奇偶的下标进行交换。当<span class="math inline">\(i\in\{n-2,n-1\}\)</span>时，是一个奇数下标和偶数下标元素的交换。因此按照传递性，所有元素都是直接可以交换的，因此这种情况必定成功。</p></li><li><p>当<span class="math inline">\(n\)</span>为奇数时，对于所有<span class="math inline">\(i&lt;n\)</span>的下标，都是同奇偶的下标进行交换。因此，将奇数下标和偶数下标的数处理出来后，各自排序后再按照对应位置还原到原来的数组中，再判断这个数组是否有序即可。</p></li></ol><h2 id="代码">代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    a = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    b0, b1 = [], []</span><br><span class="line">    <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(a):</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            b0.append(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            b1.append(x)</span><br><span class="line">    b0.sort()</span><br><span class="line">    b1.sort()</span><br><span class="line">    <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(b0):</span><br><span class="line">        a[i &lt;&lt; <span class="number">1</span>] = x</span><br><span class="line">    <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(b1):</span><br><span class="line">        a[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = x</span><br><span class="line">    <span class="keyword">return</span> a == <span class="built_in">sorted</span>(a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;YES&quot;</span> <span class="keyword">if</span> solve() <span class="keyword">else</span> <span class="string">&quot;NO&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小红的相似字符串">2、小红的相似字符串</h1><p>小红认为两个字符串相似，需要这两个字符串的每个字母的个数都相等。</p><p>如<code>"abcbd"</code>和<code>"dbcba"</code>相似，<code>"abcd"</code>和<code>"abcd"</code>相似。</p><p>而<code>"abb"</code>和<code>"aab"</code>不相似，<code>"ac"</code>和<code>"cca"</code>不相似。</p><p>现在小红有<span class="math inline">\(n\)</span>个字符串，她想知道有多少对字符串是相似的？</p><h2 id="输入-1">输入</h2><p>输入一个整数<span class="math inline">\(n\)</span>。</p><p>接下来<span class="math inline">\(n\)</span>行，每行输入一个仅包含小写字母的字符串<span class="math inline">\(s\)</span>。</p><ul><li><span class="math inline">\(1 \le n \le 10^5\)</span></li><li><span class="math inline">\(1 \le \text{len}(s) \le10^5\)</span></li></ul><h2 id="输出-1">输出</h2><p>输出一个整数。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">7</span><br><span class="line">abcbd</span><br><span class="line">dbcba</span><br><span class="line">abcd</span><br><span class="line">abcd</span><br><span class="line">adbc</span><br><span class="line">aa</span><br><span class="line">aa</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>如果两个字符串的字符个数都相同，那么对各自字符串的所有字符排好序后，它们的长度必定是相等的。</p><p>因此，我们只需要将每个字符串按字符排好序后，看看排好序的字符串有多少对相等即可。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;string,<span class="type">int</span>&gt;mp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string s;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        ans+=mp[s];</span><br><span class="line">        ++mp[s];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="子序列平均数之和">3、子序列平均数之和</h1><p>给定由<span class="math inline">\(n\)</span>个元素组成的数组，求所有子序列的平均数之和。答案请对<span class="math inline">\(10^9+7\)</span>取模。</p><p>子序列：原数组中选择部分元素，保持原数组的顺序形成的新数组。例如<span class="math inline">\([1,2,3,4,5]\)</span>的子序列有<span class="math inline">\([1,2,5],[2,4]\)</span>等，但<span class="math inline">\([2,2],[1,3,2]\)</span>则不是它的子序列。</p><h2 id="输入-2">输入</h2><p>第一行输入一个正整数<span class="math inline">\(n\)</span>，代表数组的元素个数。</p><p>第二行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(a_i\)</span>，用来表示数组。</p><ul><li><span class="math inline">\(1 \le n \le 10^5\)</span></li><li><span class="math inline">\(1 \le a \le 10^9\)</span></li></ul><h2 id="输出-2">输出</h2><p>所有子序列的平均数之和对<span class="math inline">\(10^9 +7\)</span>取模的值。可以证明，最终的答案一定是一个有理数，<span class="math inline">\(\dfrac{a}{b}\)</span>对<span class="math inline">\(p\)</span>取模的意义是在<span class="math inline">\([0,p-1]\)</span>区间找到一个满足<span class="math inline">\(x\cdot b\bmod p=a\)</span>。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">14</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">子序列共有7个：</span><br><span class="line">[1]的平均数是1。</span><br><span class="line">[2]的平均数是2。</span><br><span class="line">[3]的平均数是3。</span><br><span class="line">[1,2]的平均数是3/2。</span><br><span class="line">[1,3]的平均数是2。</span><br><span class="line">[2,3]的平均数是5/2。</span><br><span class="line">[1,2,3]的平均数是2。</span><br><span class="line">总和为14。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">2</span><br><span class="line">2 1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">500000008</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>由于这里考虑的是某个子序列的相同地位的元素之和，因此数组的每个贡献值都必定相等，这里只考虑其中一个元素的贡献。</p><p>对于任意一个元素<span class="math inline">\(a_k\)</span>，它能够出现在长度为<span class="math inline">\(i\)</span>的子序列一共有<span class="math inline">\(\dbinom{n-1}{i-1}\)</span>个，因为元素<span class="math inline">\(i\)</span>已经被固定选定了，在这些子序列中，它所作出的贡献是<span class="math inline">\(\dfrac{a_k}{i}\)</span>。也就是说，<span class="math inline">\(a_k\)</span>一共对答案做出了<span class="math inline">\(\displaystyle{a_k\cdot \sum_{i=1}^n\dfrac{1}{i}\dbinom{n-1}{i-1}}\)</span>的贡献。可以发现，贡献的系数和数组元素本身无关。更进一步的，我们可以化简一下这个系数<span class="math inline">\(\displaystyle{\sum_{i=1}^n\dfrac{1}{i}\dbinom{n-1}{i-1}}\)</span>，有：</p><p><span class="math inline">\(\begin{aligned} &amp;\sum_{i=1}^n\dfrac{1}{i}\dbinom{n-1}{i-1}\\ =&amp;\sum_{i=1}^n \dfrac{(n-1)!}{i\cdot(i-1)!\cdot (n-i)!}\\=&amp;\sum_{i=1}^n\dfrac{1}{n}\cdot\dfrac{n!}{i!\cdot (n-i)!}\\=&amp;\dfrac{2^n-1}{n} \end{aligned}\)</span></p><p>因此这道题的最终答案为<span class="math inline">\(\displaystyle{\dfrac{2^n-1}{n}\cdot\sum_{i=1}^na_i}\)</span>。</p><h2 id="代码-2">代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">s1 = <span class="built_in">sum</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">s2 = (<span class="built_in">pow</span>(<span class="number">2</span>, n, mod) - <span class="number">1</span>) * <span class="built_in">pow</span>(n, mod - <span class="number">2</span>, mod) % mod</span><br><span class="line">ans = s1 * s2 % mod</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure><h1 id="小红的路径覆盖">4、小红的路径覆盖</h1><p>小红拿到了一棵树，她有<span class="math inline">\(q\)</span>次询问，每次会选出一个点集，小红希望你使用尽可能少的简单路径覆盖点集中的所有节点。你能帮帮她吗？</p><h2 id="输入-3">输入</h2><p>第一行输入两个正整数<span class="math inline">\(n\)</span>和<span class="math inline">\(q\)</span>，代表树的节点数量、小红的询问次数。</p><p>接下来的<span class="math inline">\(n-1\)</span>行，每行输入两个正整数<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>，代表节点<span class="math inline">\(u\)</span>和节点<span class="math inline">\(v\)</span>有一条边连接。</p><p>接下来的<span class="math inline">\(2\timesq\)</span>行，每两行代表一次询问。每次询问的第一行为一个正整数<span class="math inline">\(m\)</span>，代表点集的大小，第二行为<span class="math inline">\(m\)</span>个正整数<span class="math inline">\(a_i\)</span>，代表点集中的节点编号。</p><ul><li><span class="math inline">\(1 \le n,q\le 2\times 10^5\)</span></li><li><span class="math inline">\(1 \le u,v,a_i\le n\)</span></li><li>所有<span class="math inline">\(m\)</span>的总和不超过<span class="math inline">\(2\times 10^5\)</span></li></ul><h2 id="输出-3">输出</h2><p>输出<span class="math inline">\(q\)</span>行，每行输出一个正整数，代表每次询问覆盖点集中所有点的最少路径数量。</p><h2 id="样例-3">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">4 2</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">3</span><br><span class="line">2 3 4</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">第一次询问可以直接选择路径：2-1-3。</span><br><span class="line">第二次询问至少需要选择两条路径，例如选择路径2-1-3和路径1-4，或者选择路径2-1-4和路径3-1-4。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">5 1</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">3 5</span><br><span class="line">4</span><br><span class="line">1 3 4 5</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">我们第一条路径选择1-2-3，第二条路经选择4-3-5，这两条路经即可覆盖1、3、4、5这四个点。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以下是这两棵树对应的图：</p><pre class="mermaid">graph TD    subgraph T1        A((1));B((2));C((3));D((4));        A---B;A---C;A---D;    end    subgraph T2        1((1));2((2));3((3));4((4));5((5));        1---2;2---3;3---4;3---5;    end</pre><h2 id="解答-3">解答</h2><p>前置知识：dfs序是对一棵树进行深度优先搜索的时候所经过的节点顺序。我们记录每个节点<span class="math inline">\(u\)</span>开始访问的时间戳<span class="math inline">\(l_u\)</span>和结束访问的时间戳<span class="math inline">\(r_u\)</span>，那么区间<span class="math inline">\([l_u,r_u]\)</span>就包含了当前以<span class="math inline">\(u\)</span>为根的子树的一些信息。并且，<span class="math inline">\(l_u\)</span>是节点<span class="math inline">\(u\)</span>的信息。假设遍历<span class="math inline">\(u\)</span>的所有子节点<span class="math inline">\(v_1,v_2,\dots\)</span>，那么构造出来的区间<span class="math inline">\([l_{v_1},r_{v_1}],[l_{v_2},r_{v_2}],\dots\)</span>它们都是<strong>首尾相接</strong>的。并且，最后一个子节点的右端点的下标恰好为<span class="math inline">\(r_u\)</span>。</p><p>对于一条备选的路径，它将会穿过一些节点，这些节点有可能在<span class="math inline">\(S\)</span>中，也有可能不在<span class="math inline">\(S\)</span>中。此外，这些路径如果起点或者终点不在<span class="math inline">\(S\)</span>内，并不会使得覆盖更加完善。因此，不失一般性，备选的路径的起点和终点都位于<span class="math inline">\(S\)</span>中。</p><p>根据上面的思想，我们可以对这棵树<span class="math inline">\(T\)</span>进行如下操作：不停地删去不在<span class="math inline">\(S\)</span>中的叶子节点和其关联的边，直到所有叶子节点都是<span class="math inline">\(S\)</span>中的节点。这时，我们数一下剩下的树<span class="math inline">\(T&#39;\)</span>中的叶子节点个数<span class="math inline">\(c\)</span>，可以发现用<span class="math inline">\(\lceilc/2\rceil\)</span>条这样的路径就能够覆盖剩下的整棵树。</p><p>这意味着，<span class="math inline">\(S\)</span>中的一个节点<span class="math inline">\(w\)</span>如果能够被<span class="math inline">\(S\)</span>中的另外两个不相同节点<span class="math inline">\(u,v\)</span>的简单路径覆盖，那么<span class="math inline">\(w\)</span>肯定不是上面所提到的树<span class="math inline">\(T&#39;\)</span>的叶子节点。在原树<span class="math inline">\(T\)</span>看来，对于任意一个在<span class="math inline">\(T&#39;\)</span>中的叶子节点<span class="math inline">\(l&#39;,S-\{l&#39;\}\)</span>必定都在<span class="math inline">\(l&#39;\)</span>的其中一棵子树当中。</p><p>那么也就是说，对于任意<span class="math inline">\(u\inS\)</span>，我们只需要判断<span class="math inline">\(S-\{u\}\)</span>是否在<span class="math inline">\(u\)</span>的某一棵子树即可。统计这些节点的个数<span class="math inline">\(c\)</span>，那么最终答案就是<span class="math inline">\(\lceil c/2\rceil\)</span>。</p><p>这个问题可以使用dfs序和树状数组进行解决。对于每次询问的<span class="math inline">\(S\)</span>，我们将每个节点的dfs序号在树状数组中标记上。然后枚举每个<span class="math inline">\(u\in S\)</span>，并且枚举<span class="math inline">\(u\)</span>的所有子节点<span class="math inline">\(v\)</span>，如果存在<span class="math inline">\(v\)</span>使得<span class="math inline">\(l_v\)</span>到<span class="math inline">\(r_v\)</span>之间的元素和为<span class="math inline">\(|S|-1\)</span>，那么<span class="math inline">\(u\)</span>是符合要求的。如果没有找到，我们还需要判断一种情况，即<span class="math inline">\(S-\{u\}\)</span>是否在<span class="math inline">\(u\)</span>所指向的父亲的那棵子树中。</p><p>但是这样子判断，如果给定<span class="math inline">\(u\)</span>，它的子节点非常多（达到了<span class="math inline">\(n-1\)</span>个），那么每次只询问<span class="math inline">\(u\)</span>也是非常消耗时间的。注意到，我们是需要找到一个子节点对应的区间<span class="math inline">\([l_v,r_v]\)</span>其区间元素之和为<span class="math inline">\(|S|-1\)</span>，这意味着，其它子节点<span class="math inline">\(v&#39;\)</span>对应的区间的元素之和都为<span class="math inline">\(0\)</span>。由于上面提到，这些子节点区间都是相邻挨着的，因此我们可以考虑使用二分，找到第一个子节点<span class="math inline">\(v\)</span>满足<span class="math inline">\([l_u-1,r_{v}]\)</span>的区间元素之和不为<span class="math inline">\(0\)</span>，然后再判断这个区间的元素和是否为<span class="math inline">\(|S|-1\)</span>即可。</p><p>因此，这题可以在<span class="math inline">\(O(n\log^2n)\)</span>的时间内完成。</p><h2 id="代码-3">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> lb(x) ((x) &amp; -(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"><span class="type">int</span> s[N],n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=p;i&lt;=n;i+=<span class="built_in">lb</span>(i))</span><br><span class="line">        s[i]+=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">que</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=p;i;i-=<span class="built_in">lb</span>(i))</span><br><span class="line">        ans+=s[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;g[N],h[N];</span><br><span class="line"><span class="type">int</span> lp[N],rp[N],tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    lp[u]=++tot;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:h[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    rp[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> sz)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(g[u].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> lsum=<span class="built_in">que</span>(lp[u]);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">que</span>(rp[u])-lsum<span class="number">-1</span>==sz<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=g[u].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> rsum=<span class="built_in">que</span>(rp[g[u][mid]]);</span><br><span class="line">        <span class="keyword">if</span>(rsum!=lsum) r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> rsum=<span class="built_in">que</span>(rp[g[u][l]]);</span><br><span class="line">    <span class="keyword">return</span> rsum-lsum==sz<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u:q)&#123;</span><br><span class="line">        <span class="built_in">add</span>(lp[u],<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u:q)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(u,q.<span class="built_in">size</span>()))&#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u:q)&#123;</span><br><span class="line">        <span class="built_in">add</span>(lp[u],<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (cnt+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> q,m,x,y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        h[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        h[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;qu;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">        qu.<span class="built_in">resize</span>(m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;qu[j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">cal</span>(qu));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>深信服 秋招 2023.09.20 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Shenxinfu-20230920/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Shenxinfu-20230920/</id>
    <published>2023-09-25T05:19:33.000Z</published>
    <updated>2023-09-25T05:19:33.906Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="馍馍检测病毒">1、馍馍检测病毒</h1><p>馍馍发现了一种新型网络病毒，可以隐藏在图片中，图片可以简单的看成一个<span class="math inline">\(N\times N\)</span>的矩阵。</p><p>这个矩阵每个格子要么是白，用字符<code>'.'</code>表示，要么是黑，用字符<code>'#'</code>表示。</p><p>经过馍馍的分析，如果一张图片中包含一个特殊的<span class="math inline">\(M\timesM\)</span>的矩阵，那么这张图片可能包含病毒。我们称<span class="math inline">\(M\timesM\)</span>的矩阵为“馍馍来检测病毒的超生逼特征矩阵”。</p><p>现在告诉你一个<span class="math inline">\(N\timesN\)</span>的图片矩阵，和一个<span class="math inline">\(M\timesM\)</span>的“馍馍来检测病毒的超生逼特征矩阵”。</p><p>你需要判断该图片是否包含病毒。即"馍馍来检测病毒的超牛逼特征矩阵"通过平移可以完全重合在图片中的一个子矩阵里。</p><h2 id="输入">输入</h2><p>第一行一个整数<span class="math inline">\(T(1\le T\le5)\)</span>，表示测试数据的组数。</p><p>对于每组测试数据，第一行两个整数<span class="math inline">\(N,M(1\leN,M\le 50)\)</span>。</p><p>接下来<span class="math inline">\(N\)</span>行，每行<span class="math inline">\(N\)</span>个字符，用来描述待判断的图片A。</p><p>接下<span class="math inline">\(来\)</span>M行，每行<span class="math inline">\(M\)</span>个字符，用来描述“馍馍来检测病毒的超牛逼特征矩阵”。</p><h2 id="输出">输出</h2><p>共<span class="math inline">\(T\)</span>行，对于每组测试数据，如果包含，输出<code>"Yes"</code>，否则输出<code>"No"</code>(不包括引号)。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">2</span><br><span class="line">3 2</span><br><span class="line">#.#</span><br><span class="line">.#.</span><br><span class="line">#.#</span><br><span class="line">#.</span><br><span class="line">.#</span><br><span class="line">4 1</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>我们只需要枚举原矩阵的每个格子作为模板的左上角即可，然后再一一和模板矩阵比对即可完成。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">54</span>;</span><br><span class="line"><span class="type">char</span> s[N][N],t[N][N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x+m<span class="number">-1</span>&lt;n;x++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>;y+m<span class="number">-1</span>&lt;n;y++)&#123;</span><br><span class="line">            <span class="type">int</span> ok=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m&amp;&amp;ok;i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m&amp;&amp;ok;j++)</span><br><span class="line">                    <span class="keyword">if</span>(s[x+i][y+j]!=t[i][j]) ok=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(ok) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="built_in">solve</span>()?<span class="string">&quot;Yes&quot;</span>:<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="sxf序数">2、SXF序数</h1><p>一个<span class="math inline">\(N\)</span>位的正整数，如果把它的各个数位重新排列，则可以得到一些新的<span class="math inline">\(N\)</span>位正整数。</p><p>如果原数在所有的新数中是第<span class="math inline">\(K\)</span>大的（降序排序的第<span class="math inline">\(K\)</span>个）则称原数的SXF序数为<span class="math inline">\(K\)</span>。</p><p>例如，一个<span class="math inline">\(4\)</span>位数<span class="math inline">\(7225\)</span>，把它的各个数位重新排列，得到的新的<span class="math inline">\(4\)</span>位数中，最大的是<span class="math inline">\(7522\)</span>，第二大的是<span class="math inline">\(7252\)</span>，第三大的就是原数<span class="math inline">\(7225\)</span>，所以<span class="math inline">\(7225\)</span>的SXF序数为<span class="math inline">\(3\)</span>。</p><p>现在给定一个正整数<span class="math inline">\(a\)</span>，请计算出它的SXF序数。</p><h2 id="输入-1">输入</h2><p>第一行是一个正整数<span class="math inline">\(T(1\leT\le10^4)\)</span>，表示接下来有<span class="math inline">\(T\)</span>组测试数据。</p><p>接下来是各组测试数据。</p><p>每组测试数据只有一行，该行仅有一个正整数<span class="math inline">\(a(1\le a\le10^9)\)</span>，表示给定的正整数。</p><h2 id="输出-1">输出</h2><p>对于每组测试数据输出一行，仅有一个整数，表示<span class="math inline">\(q\)</span>的SXF序数。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">7225</span><br><span class="line">65421</span><br><span class="line">123</span><br><span class="line">1024</span><br><span class="line">365895456</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">6</span><br><span class="line">18</span><br><span class="line">28149</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>前置知识：假设现在有<span class="math inline">\(m\)</span>类元素，第<span class="math inline">\(i\)</span>类一共有<span class="math inline">\(c_i\)</span>个，那么这些元素组成的<strong>不同</strong>的排列数量为<span class="math inline">\(\dfrac{(c_1+c_2+\dots+c_m)!}{c_1!\cdot c_2!\cdot\dots\cdot c_m!}\)</span>。</p><p>我们将输入的一个数<span class="math inline">\(n\)</span>视为是一个排列<span class="math inline">\(n_1,n_2,\dots,n_d\)</span>即可，为了计算比它字典序更大的排列数量，我们可以采取以下方法：首先假设排列的第一个元素<span class="math inline">\(p_1\)</span>比<span class="math inline">\(n_1\)</span>大，那么后面的元素可以随意填充，使用上面的公式就可以计算出排列的数量，枚举<span class="math inline">\(p_1\)</span>的值，其中<span class="math inline">\(p_1\)</span>大于<span class="math inline">\(n_1\)</span>。计算完成后，将<span class="math inline">\(n_1\)</span>填入<span class="math inline">\(p_1\)</span>，接下来对<span class="math inline">\(p_2\)</span>做类似的操作（我们这时忽略第<span class="math inline">\(1\)</span>个位置）：枚举<span class="math inline">\(p_2\)</span>填入的元素，其中<span class="math inline">\(p_2&gt;n_2\)</span>，并使用上面的公式统计排列数……一直到第<span class="math inline">\(d\)</span>位完成。</p><p>最终，我们统计出了字典序比<span class="math inline">\(n_1,n_2,\dots,n_d\)</span>大的排列数量，再加上<span class="math inline">\(1\)</span>就是题目中所提到的SXF序数。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fac[<span class="number">14</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cal_per</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;a)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> den=<span class="number">1</span>,s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x:a)&#123;</span><br><span class="line">        den*=fac[x];</span><br><span class="line">        s+=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num=fac[s];</span><br><span class="line">    <span class="keyword">return</span> num/den;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;d,<span class="built_in">c</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> m=n;m;m/=<span class="number">10</span>)&#123;</span><br><span class="line">        d.<span class="built_in">push_back</span>(m%<span class="number">10</span>);</span><br><span class="line">        ++c[m%<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=d.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> w=d[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=w+<span class="number">1</span>;j&lt;<span class="number">10</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c[j]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                --c[j];</span><br><span class="line">                ans+=<span class="built_in">cal_per</span>(c);</span><br><span class="line">                ++c[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        --c[w];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">11</span>;i++)</span><br><span class="line">        fac[i]=fac[i<span class="number">-1</span>]*i;</span><br><span class="line">    <span class="type">int</span> T,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">solve</span>(n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="cwpp平台告警">3、CWPP平台告警</h1><p>深信服CWPP平台的告警事件管理页面可以按照时间顺序或者告警等级筛选用户所关注的安全事件。现在深信服CWPP平台上已经管理了<span class="math inline">\(N\)</span>台主机，主机编号从<span class="math inline">\(1\)</span>到<span class="math inline">\(N\)</span>。这些主机根据运行的业务不同，各自的安全等级<span class="math inline">\(s_i\)</span>都不相同，举例来说，作为内网网关主机的安全等级就高于作为外部公开资源数据库的主机。每一台主机还有一个安全威胁评分<span class="math inline">\(v_i\)</span>，<span class="math inline">\(v_i\)</span>的值越大，主机就越不安全。</p><p>为了方便运维人员，深信服CWPP平台拥有筛选管理主机并优先展示高安全等级主机的功能。</p><p>具体来讲，用户可以指定一个告警闯值水位线<span class="math inline">\(h\)</span>，筛选出威胁评分高于该闽值水位线的主机，即筛选出<span class="math inline">\(h\lev_i\)</span>的主机。然后为了方便用户查看最关注的高安全等级主机，深信服CWPP平台在筛选后还会将安全等级<span class="math inline">\(s_i\)</span>最高的主机展示到第一条告警的位置。</p><p>虽然主机的安全等级可以在系统运行前就进行配置，但是主机的安全威胁评分<span class="math inline">\(v_i\)</span>是实时进行更新和维护的。</p><p>所以要求你的算法具有可维护性，即需要支持对于<span class="math inline">\(M\)</span>次连续操作（共两种操作类型，详见下文），既可以随时修改某一台主机<span class="math inline">\(x\)</span>的安全威胁评分<span class="math inline">\(v_x\)</span>，又可以随时基于不同的告警值水位线<span class="math inline">\(h\)</span>进行查询。</p><p>现在给你这<span class="math inline">\(N\)</span>台主机安全等级<span class="math inline">\(s_i\)</span>以及初始的安全威胁评分<span class="math inline">\(v_i\)</span>。请你设计一个算法支持这<span class="math inline">\(M\)</span>次连续操作。</p><h2 id="输入-2">输入</h2><p>第一行输入两个正整数<span class="math inline">\(N,M(1\le N,M\le10^5)\)</span>分别表示深信服CWPP平台上保护主机的数目<span class="math inline">\(N\)</span>和进行操作的次数<span class="math inline">\(M\)</span>。</p><p>接下来<span class="math inline">\(N\)</span>行，输入两个正整数<span class="math inline">\(s_i,u_i(1 \le s_i,v_i\le 10^9)\)</span>表示第<span class="math inline">\(i\)</span>台主机安全等级<span class="math inline">\(s_i\)</span>以及初始的安全威胁评分<span class="math inline">\(v_i\)</span>，保证安全等级<span class="math inline">\(s_i\)</span>各不相同。</p><p>接下来<span class="math inline">\(M\)</span>行，输入若干个操作，对于每个操作首先输入一个操作类型<span class="math inline">\(op\)</span>（<span class="math inline">\(op\)</span>为<span class="math inline">\(1\)</span>或<span class="math inline">\(2\)</span>）。</p><p>当<span class="math inline">\(op\)</span>的值为<span class="math inline">\(1\)</span>时，表示进行查询操作，此时还需要继续输入一个参数<span class="math inline">\(h(1\le h\le10^9)\)</span>，表示该次查询的告警闯值水位线。</p><p>当<span class="math inline">\(op\)</span>的值为<span class="math inline">\(2\)</span>时，表示进行修改操作，此时还需要继续输入两个参数<span class="math inline">\(x,v_x(1\le x\le N, 1\le v_x\le10^9)\)</span>，表示需要将第<span class="math inline">\(x\)</span>台主机的安全威胁评分改为<span class="math inline">\(v_x\)</span>。</p><p>输入保证，至少进行一次查询操作。</p><ul><li><span class="math inline">\(1\le N,M\le 10^5\)</span></li><li><span class="math inline">\(1\le s_i,v_i\le 10^9\)</span></li><li><span class="math inline">\(1\le h\le 10^9\)</span></li><li><span class="math inline">\(1\le x\le N\)</span></li></ul><h2 id="输出-2">输出</h2><p>对于每一次查询操作，输出评分超过阈值水位线的最高安全等级机器的编号。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">10 7</span><br><span class="line">10 3</span><br><span class="line">9 5</span><br><span class="line">8 9</span><br><span class="line">7 6</span><br><span class="line">6 10</span><br><span class="line">5 8</span><br><span class="line">4 7</span><br><span class="line">3 1</span><br><span class="line">2 2</span><br><span class="line">1 4</span><br><span class="line">1 10</span><br><span class="line">1 9</span><br><span class="line">1 8</span><br><span class="line">1 1</span><br><span class="line">1 99</span><br><span class="line">2 8 100</span><br><span class="line">1 99</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">-1</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>这题的做法比较麻烦，因为它涉及到了动态修改，需要一些数据结构来操作。</p><p>这里我们选择了使用支持单点修改的线段树，它支持在<span class="math inline">\(O(\logn)\)</span>的时间内对数组的元素进行修改和求解区间最大值。</p><p>我们首先对所有节点机器按照风险等级进行排序，接下来依据排序后的结果初始化线段树。对于题目的两种操作：</p><ol type="1"><li>每次修改操作则是将对应位置的机器的风险分数直接修改即可，线段树可以直接更新。</li><li>对于每次查询操作，我们考虑对后缀进行二分，也就是找到一个最短的后缀，其区间最大值至少为<span class="math inline">\(h\)</span>，那么这时这个后缀的第一个机器恰好就是所求机器，将它映射回自身的编号即可。</li></ol><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l[N&lt;&lt;<span class="number">2</span>],r[N&lt;&lt;<span class="number">2</span>],mx[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> rs p&lt;&lt;1|1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> tl,<span class="type">int</span> tr)</span></span>&#123;</span><br><span class="line">    l[p]=tl;r[p]=tr;</span><br><span class="line">    <span class="keyword">if</span>(tl==tr)&#123;</span><br><span class="line">        mx[p]=a[tl];<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(tl+tr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls,tl,mid);</span><br><span class="line">    <span class="built_in">build</span>(rs,mid+<span class="number">1</span>,tr);</span><br><span class="line">    mx[p]=<span class="built_in">max</span>(mx[ls],mx[rs]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l[p]==r[p])&#123;</span><br><span class="line">        mx[p]=x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l[p]+r[p])&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(q&lt;=mid) <span class="built_in">update</span>(ls,q,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(rs,q,x);</span><br><span class="line">    mx[p]=<span class="built_in">max</span>(mx[ls],mx[rs]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">que</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l[p]&amp;&amp;r[p]&lt;=qr) <span class="keyword">return</span> mx[p];</span><br><span class="line">    <span class="type">int</span> mid=(l[p]+r[p])&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=mid) ans=<span class="built_in">que</span>(ls,ql,qr);</span><br><span class="line">    <span class="keyword">if</span>(qr&gt;mid) ans=<span class="built_in">max</span>(ans,<span class="built_in">que</span>(rs,ql,qr));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> s[N],v[N],id[N],pos[N],n,q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">que_id</span><span class="params">(<span class="type">int</span> h)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">que</span>(<span class="number">1</span>,<span class="number">1</span>,n)&lt;h) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=n;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">que</span>(<span class="number">1</span>,mid,n)&gt;=h) l=mid;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id[l];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;s[i],&amp;v[i]);</span><br><span class="line">        id[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(id+<span class="number">1</span>,id+n+<span class="number">1</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> s[x]&lt;s[y];&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        pos[id[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        a[pos[i]]=v[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="type">int</span> op,x,y,h;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;h);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">que_id</span>(h));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>,pos[x],y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>蚂蚁集团 秋招 2023.09.19 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Mayijituan-20230919/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Mayijituan-20230919/</id>
    <published>2023-09-25T05:19:31.000Z</published>
    <updated>2023-09-25T05:19:31.645Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="最优化存储四">1、最优化存储（四）</h1><p>支付宝服务亿级消费者，每个支付宝的用户有自己独特的信息，假设每个会员存储的成本为<span class="math inline">\(a_i\)</span>，现在有<span class="math inline">\(n\)</span>个会员，和一块存储容器<span class="math inline">\(m\)</span>，希望用该容器存储更多的会员信息；</p><p>存储优化是个相当复杂的过程，为了简化问题，存储规则如下：</p><p>每个会员的存储成本可以用长度<span class="math inline">\(a_i\)</span>的线段表示。存储容器一块，可以用一段线段<span class="math inline">\(m\)</span>表示。</p><p>存储容器有个特性，如果会员<span class="math inline">\(i\)</span>存储在容器中间位置，存储成本为<span class="math inline">\(a_i\)</span>本身，但是线段容器两端有存储压缩技术，存储在靠两端位置的会员存储成本可以压缩到一半，即<span class="math inline">\(a_i/2\)</span>，而且每个会员只能压缩一次。</p><p>现在<span class="math inline">\(n\)</span>个会员，每个会员存储成本为<span class="math inline">\(a_i\)</span>，以及有一块存储资源，希望你做存储优化，使用尽可能小的存储容器存储下所有会员的信息。</p><h2 id="输入">输入</h2><p>第一行输入一个正整数<span class="math inline">\(n\)</span>，代表会员的数量。 第二行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(a_i\)</span>，代表每个会员信息的大小。</p><ul><li><span class="math inline">\(1\le n \le 10^5\)</span></li><li><span class="math inline">\(2 \le a_i\le 10^9\)</span></li><li>保证<span class="math inline">\(a_i\)</span>是偶数。</li></ul><h2 id="输出">输出</h2><p>一个正整数，代表使用的存储容器大小的最小值。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">2 4 4 8 2</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">14</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">将第三个、第四个会员放在两端即可。使用一个大小为14的容器即可存储全部会员信息。</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>按照贪心的思想，只需要将最大的两个放在两端，其余的放在中间即可，节省的空间将是最大的。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100004</span>],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">    ll ans=a[n<span class="number">-1</span>]/<span class="number">2</span>+a[n]/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        ans+=a[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小红合并数组">2、小红合并数组</h1><p>小红有一个长度为<span class="math inline">\(n\)</span>的数组，每次操作她可以选择一个<span class="math inline">\(i\)</span>，将<span class="math inline">\(a_i\)</span>加到<span class="math inline">\(a_{i-1}\)</span>或者<span class="math inline">\(a_{i+1}\)</span> (如果<span class="math inline">\(i-1\)</span>或者<span class="math inline">\(i+1\)</span>在下标范围内)，请问最少需要多少次操作，可以使数组的所有元素相等。</p><h2 id="输入-1">输入</h2><p>一行一个整数<span class="math inline">\(n\)</span>，表示数组的长度。</p><p>接下来一行<span class="math inline">\(n\)</span>个整数<span class="math inline">\(a_1,a_2,\dots, a_n\)</span>表示数组的初始值。</p><ul><li><span class="math inline">\(1\le n \le 10^3\)</span></li><li><span class="math inline">\(0 \le a_i \le 10^4\)</span></li></ul><h2 id="输出-1">输出</h2><p>输出一个整数，表示最少的操作次数。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">1 4 2 3 5</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">第一次操作，将a2加到a1，数组变为[5,2,3,5]。</span><br><span class="line">第二次操作，将a2加到a3，数组变为[5,5,5]。</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>更具体的说，这种操作是将相邻的两个数进行合并。令<span class="math inline">\(\displaystyle{s_i=\sum_{j=1}^ia_i,s_0=0}\)</span>表示数组<span class="math inline">\(a\)</span>的前缀和。如果最终数组元素都相等，假设这些元素都是<span class="math inline">\(x\)</span>，最终的长度为<span class="math inline">\(m(m\le n)\)</span>，那么必定满足<span class="math inline">\(x\cdot m=s_n\)</span>。</p><p>因此，我们可以枚举<span class="math inline">\(s_n\)</span>所有不超过<span class="math inline">\(n\)</span>的因子<span class="math inline">\(d\)</span>，那么说明<span class="math inline">\(d\)</span>是最终数组可能的长度，<span class="math inline">\(s_n/d\)</span>是最终数组的每个元素。</p><p>在前缀和的角度来看，合并操作仅仅是删除了<span class="math inline">\(s_1,s_2,\dots,s_{n-1}\)</span>中的某些元素。因此，令<span class="math inline">\(x=s_n/d\)</span>，我们只需要查看<span class="math inline">\(x,2x,\dots,dx\)</span>是否为<span class="math inline">\(s_1,s_2,\dots,s_n\)</span>的一个子序列即可。如果是，那么找到这样最大的<span class="math inline">\(d\)</span>，并返回最小操作数<span class="math inline">\(n-d\)</span>。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1004</span>;</span><br><span class="line"><span class="type">int</span> a[N],s[N],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m=s[n];</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;div;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m%i==<span class="number">0</span>)&#123;</span><br><span class="line">            div.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> d:div)&#123;</span><br><span class="line">        <span class="type">int</span> w=m/d,c=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==c*w)&#123;</span><br><span class="line">                ++c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c&gt;d)&#123;</span><br><span class="line">            ans=n-d;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小红的w五元组">3、小红的w五元组</h1><p>小红拿到了一个数组<span class="math inline">\(a_1,a_2,\dots,a_n\)</span>，她想知道有多少组<span class="math inline">\((i,j,k,h,l)\)</span>为"w五元组"：</p><p>第一、三、五个数相等。第二个数和第四个数相等，且第一个数大于第二个数。用数学语言描述：</p><ul><li><span class="math inline">\(1\le i&lt; j&lt; k&lt; h&lt; l\len\)</span></li><li><span class="math inline">\(a_i=a_k=a_l\)</span>且<span class="math inline">\(a_j=a_h\)</span>且<span class="math inline">\(a_i=a_j\)</span></li></ul><h2 id="输入-2">输入</h2><p>第一行输入一个正整数<span class="math inline">\(n\)</span>，代表数组的元素个数。</p><p>第二行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(a_i\)</span>，代表小红拿到的数组。</p><ul><li><span class="math inline">\(5\le n,a_i\le 3000\)</span></li></ul><h2 id="输出-2">输出</h2><p>w五元组的数量。由于答案可能太大，请对<span class="math inline">\(10^9+7\)</span>取模后输出。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">7</span><br><span class="line">3 1 3 1 3 1 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">6个w五元组分别为（下标表示）：</span><br><span class="line">(1,2,3,4,5)</span><br><span class="line">(1,2,3,4,7)</span><br><span class="line">(1,2,3,6,7)</span><br><span class="line">(1,2,5,6,7)</span><br><span class="line">(1,4,5,6,7)</span><br><span class="line">(3,4,5,6,7)</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>我们枚举原数组中两个不同的数<span class="math inline">\(x,y(x&gt;y)\)</span>，并且将要么是<span class="math inline">\(x\)</span>，要么是<span class="math inline">\(y\)</span>的这一些元素重新组成一个相对顺序不变的子序列，并将所有<span class="math inline">\(x\)</span>替换成<span class="math inline">\(1\)</span>，将<span class="math inline">\(y\)</span>替换成<span class="math inline">\(0\)</span>，那么我们得到了一个01比特序列<span class="math inline">\(b\)</span>，假设其长度为<span class="math inline">\(m\)</span>。我们将这个问题转化成了：<span class="math inline">\(b\)</span>中有多少个子序列是<span class="math inline">\(c=[1,0,1,0,1]\)</span>？</p><p>这是一个经典的动态规划问题，令<span class="math inline">\(f(i,j)(1\lei\le 5,1\le j\le m)\)</span>以<span class="math inline">\(b-j\)</span>为最后一个元素的子序列，有多少个是<span class="math inline">\(c_1,c_2,\dots,c_i\)</span>。我们不难写出<span class="math inline">\(f(i,j)\)</span>的状态转移方程：</p><p><span class="math inline">\(f(i,j)= \left \{\begin{aligned}  &amp;1&amp; &amp; \text{if}\quad i=1\land b_j=c_1 \\  &amp;\sum_{k=1}^{j-1}f(i-1,k) &amp; &amp; \text{if}\quad i&gt;1\land b_j=c_i \\  &amp;0 &amp;&amp; \text{if}\quad b_j\neq c_i \\ \end{aligned}\right.\)</span></p><p>其中，方程第二行表示对于所有<span class="math inline">\(f(i-1,k)\)</span>满足的序列，都添加一个元素<span class="math inline">\(b_j\)</span>，那么就变成了<span class="math inline">\(f(i,j)\)</span>中满足的子序列。</p><p>因此，最终答案为<span class="math inline">\(\displaystyle{\sum_{j=1}^mf(5,j)}\)</span>。我们可以用<span class="math inline">\(O(m)\)</span>的时间对这个问题进行求解。</p><p>回到原问题，我们枚举一对对不同的<span class="math inline">\((x,y)\)</span>，并将它们转化成一个01比特序列可以在<span class="math inline">\(O(m)\)</span>时间内完成（因为这里只需要合并两个有序列表），由于不同的元素都会被组合一次，加上每次求解时都是线性时间的复杂度<span class="math inline">\(O(m)\)</span>，因此原问题的时间复杂度为<span class="math inline">\(O(n^2)\)</span>，足够完成。</p><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3004</span>,INF=<span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> n,x;</span><br><span class="line">ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;a,vector&lt;<span class="type">int</span>&gt;&amp;b)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>,q=<span class="number">0</span>;!(a[p]==INF&amp;&amp;b[q]==INF);)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[p]&lt;b[q]) v.<span class="built_in">push_back</span>(<span class="number">0</span>),p++;</span><br><span class="line">        <span class="keyword">else</span> v.<span class="built_in">push_back</span>(<span class="number">1</span>),q++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">5</span>,m=v.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt;<span class="built_in">f</span>(n,<span class="built_in">vector</span>&lt;ll&gt;(m));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[j]==<span class="number">0</span>) f[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        ll tp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[j]==(i&amp;<span class="number">1</span>)) f[i][j]=tp;</span><br><span class="line">            tp=(tp+f[i<span class="number">-1</span>][j])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">        sum=(sum+f[n<span class="number">-1</span>][j])%mod;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt;mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        mp[x].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;ls;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[k,v]:mp)&#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(INF);</span><br><span class="line">        ls.<span class="built_in">emplace_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ls.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            ans+=<span class="built_in">solve</span>(ls[i],ls[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>阿里淘天 秋招 2023.09.20 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Alitaotian-20230920/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Alitaotian-20230920/</id>
    <published>2023-09-25T05:19:29.000Z</published>
    <updated>2023-09-25T05:19:29.371Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="小红的子数组权值">1、小红的子数组权值</h1><p>小红拿到了一个数组。她定义一个连续子数组的权值为：子数组内不同元素的个数。小红想知道，权值分别为<span class="math inline">\(1,2,3,\dots,n\)</span>的子数组数量有多少个？</p><h2 id="输入">输入</h2><p>第一行输入一个正整数<span class="math inline">\(n\)</span>，代表数组的元素数量。</p><p>第二行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(a_i\)</span>，代表小红拿到的数组。</p><p><span class="math inline">\(1\le n,a_i \le 2000\)</span></p><h2 id="输出">输出</h2><p><span class="math inline">\(n\)</span>个整数，分别代表权值为<span class="math inline">\(1,2,3,\dots,n\)</span>的子数组数量。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">4</span><br><span class="line">1 2 2 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">5 4 1 0</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>这题比较简单，只需要枚举每个数组元素作为起点，然后从右开始一个个插入一个单重集合中，再统计这个集合的大小即可。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2004</span>;</span><br><span class="line"><span class="type">int</span> c[N],a[N],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt;st;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        st.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">            st.<span class="built_in">insert</span>(a[j]);</span><br><span class="line">            ++c[st.<span class="built_in">size</span>()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>,c[i], <span class="string">&quot; \n&quot;</span>[i==n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="平均数大于k的最长子序列">2、平均数大于<span class="math inline">\(k\)</span>的最长子序列</h1><p>给定<span class="math inline">\(n\)</span>个正整数组成的数组，求平均数大于<span class="math inline">\(k\)</span>的最长子序列的长度。</p><h2 id="输入-1">输入</h2><p>第一行输入两个正整数<span class="math inline">\(n\)</span>和<span class="math inline">\(k\)</span>，用空格隔开。</p><p>第二行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(a_i\)</span>，用来表示数组。</p><ul><li><span class="math inline">\(1\le n\le 200000\)</span></li><li><span class="math inline">\(1\le k,a_i \le 10^9\)</span></li></ul><h2 id="输出-1">输出</h2><p>如果不存在子序列的平均数大于<span class="math inline">\(k\)</span>，则输出<span class="math inline">\(-1\)</span>。</p><p>否则输出最长子序列的长度。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5 2</span><br><span class="line">3 1 1 2 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">取3, 1, 2, 3，平均数为2.25.</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>我们构造<span class="math inline">\(b_i=a_i-k\)</span>，那么原题目的含义就变成了在<span class="math inline">\(b\)</span>中求取一个最长的子序列，其平均值大于<span class="math inline">\(0\)</span>，也就是说其和大于<span class="math inline">\(0\)</span>。</p><p>那么问题很简单，从大到小将<span class="math inline">\(b\)</span>中的元素加入到子序列之中，直到子序列的元素之和不超过<span class="math inline">\(0\)</span>即停止。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"><span class="type">int</span> a[N],n,k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">sort</span>(a,a+n,<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    ll s=<span class="number">0</span>;<span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p=<span class="number">0</span>;p&lt;n;p++)&#123;</span><br><span class="line">        s+=a[p]-k;</span><br><span class="line">        <span class="keyword">if</span>(s&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小红的01问号串">3、小红的<code>01</code>问号串</h1><p>小红定义一个字符串的权值为：相邻的不同字符对数。例如<code>"10011"</code>的权值为<span class="math inline">\(2\)</span>，其中有<span class="math inline">\(2\)</span>对相邻字符不同。</p><p>小红拿到了一个<span class="math inline">\(01\)</span>串，其中有一些字符是<code>'?'</code>。设<code>'?'</code>字符的数量有<span class="math inline">\(k\)</span>个，已知共有<span class="math inline">\(2^k\)</span>种不同的<code>01</code>串(每个问号可以是<span class="math inline">\(0\)</span>或者<span class="math inline">\(1\)</span>)。小红想知道，这<span class="math inline">\(2^k\)</span>种不同的<code>01</code>串的权值之和是多少？答案对<span class="math inline">\(10^9+7\)</span>取模。</p><h2 id="输入-2">输入</h2><p>一个仅包含<code>'0', '1'</code>和<code>'?'</code>的字符串，长度不超过<span class="math inline">\(10^5\)</span>。</p><p>本题有部分用例，字符串长度不超过<span class="math inline">\(20\)</span>。</p><h2 id="输出-2">输出</h2><p>最终的权值之和对<span class="math inline">\(10^9+7\)</span>取模的值。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">01?</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">&quot;011&quot;的权值为1，&quot;010&quot;的权值为2。权值和为3。</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>我们只考虑相邻一对字符串所做出的贡献值。</p><ul><li><p>假设这一对相邻的字符串是<code>01</code>或者是<code>10</code>，那么由于这个字符串有<span class="math inline">\(2^k\)</span>个，这一相邻对做出了<span class="math inline">\(2^k\)</span>的贡献。</p></li><li><p>假设这一对相邻的字符串是<code>0?, ?0, 1?, ?1</code>中的一个，那么这一对为了做出贡献，问号必须填上不同的数字。对于另外的<span class="math inline">\(k-1\)</span>个问号，它们可以随意填充。因此这一对相邻的字符串做出了<span class="math inline">\(2^{k-1}\)</span>的贡献。</p></li><li><p>假设这一对相邻的字符串是<code>??</code>，那么这一对为了做出贡献，两个问号要么是<code>01</code>，要么是<code>10</code>，有两种填法。对于其它<span class="math inline">\(k-2\)</span>个问号，可以随意填充，因此这一对相邻的字符串做出了<span class="math inline">\(2\cdot 2^{k-2}=2^{k-1}\)</span>的贡献。</p></li><li><p>对于其余情况（即<code>00</code>和<code>11</code>），它们肯定不会做出贡献，因此忽略。</p></li></ul><p>因此，将这些贡献值累加即可得到答案。</p><h2 id="代码-2">代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line">k = s.count(<span class="string">&#x27;?&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s) - <span class="number">1</span>):</span><br><span class="line">    t = s[i:i + <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> t.count(<span class="string">&#x27;?&#x27;</span>):</span><br><span class="line">        ans += <span class="built_in">pow</span>(<span class="number">2</span>, k - <span class="number">1</span>, mod)</span><br><span class="line">    <span class="keyword">elif</span> t[<span class="number">0</span>] != t[<span class="number">1</span>]:</span><br><span class="line">        ans += <span class="built_in">pow</span>(<span class="number">2</span>, k, mod)</span><br><span class="line">ans %= mod</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>携程 秋招 2023.09.21 编程题目与题解</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Xiecheng-20230921/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Xiecheng-20230921/</id>
    <published>2023-09-22T15:37:56.000Z</published>
    <updated>2023-09-22T15:37:56.047Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="游游的排列构造">1、游游的排列构造</h1><p>游游拿到了一个排列<span class="math inline">\(a\)</span>。她希望你构造一个长度相等的排列，满足<span class="math inline">\(a_i\neq b_i\)</span>且<span class="math inline">\(b\)</span>的字典序尽可能小。你能帮帮她吗？</p><p>所谓排列，即长度为<span class="math inline">\(n\)</span>的数组，其中<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>每个正整数都恰好出现了<span class="math inline">\(1\)</span>次。</p><p>排列的字典序定义如下：两个排列的字典序比较，将比较它们第一个不相等的元素，该元素小的那个排列字典序更小。例如<span class="math inline">\([2,1,3]\)</span>的字典序小于<span class="math inline">\([2,3,1]\)</span>。</p><h2 id="输入">输入</h2><p>第一行输入一个正整数<span class="math inline">\(n\)</span>，代表排列<span class="math inline">\(a\)</span>的长度。</p><p>第二行输入<span class="math inline">\(n\)</span>个正整数<span class="math inline">\(a_i\)</span>，代表游游拿到的排列。</p><ul><li><span class="math inline">\(2 \le n \le 10^5\)</span></li></ul><h2 id="输出">输出</h2><p><span class="math inline">\(n\)</span>个正整数<span class="math inline">\(b_i\)</span>，代表构造的排列。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2 3 1</span><br></pre></td></tr></table></figure><h2 id="解答">解答</h2><p>我们先按照贪心算法构造出一个排列：即<span class="math inline">\(\forall i\in[1,n)\)</span>，如果<span class="math inline">\(a_i\)</span>和剩余未被填入<span class="math inline">\(b\)</span>的最小数相等，那么<span class="math inline">\(b_i\)</span>填入次小数，否则填入次小数。并且<span class="math inline">\(b_n\)</span>填入剩下的那一个数中。</p><p>可见，这种填入方式对<span class="math inline">\(b_n\)</span>可能不满足题目要求。可以发现，只有<span class="math inline">\(a_n=n\)</span>的时候才有可能发生这种情况，因为<span class="math inline">\(1,2\)</span>都只有可能在位置<span class="math inline">\(1,2\)</span>填入，<span class="math inline">\(3\)</span>只有有可能在<span class="math inline">\(2,3\)</span>位置填入，<span class="math inline">\(4\)</span>只有可能在<span class="math inline">\(3,4\)</span>位置填入……<span class="math inline">\(n-1\)</span>只有可能在<span class="math inline">\(n-2,n-1\)</span>填入。</p><p>因此，如果按照上面的方式构造出来的排列是不对的，那么我们只需要求一个字典序和它相邻且比它大的一个排列即可，这时我们只需要对前一个求出来的排列，交换<span class="math inline">\(b_{n-1},b_n\)</span>即可。因为<span class="math inline">\(a_n=n\)</span>，所以<span class="math inline">\(a_{n-1}\neq n\)</span>，并且交换后，有<span class="math inline">\(b_n\neqn,b_{n-1}=n\)</span>，那么这就是一个满足题意得最小字典序排列。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        b[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i]==a[i])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(b[i],b[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a[n]==b[n])&#123;</span><br><span class="line">        <span class="built_in">swap</span>(b[n],b[n<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>,b[i], <span class="string">&quot; \n&quot;</span>[i==n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小红的字符串">2、小红的字符串</h1><p>小红拿到了一个字符串<span class="math inline">\(s\)</span>。她可以进行任意次以下操作作：</p><p>选择字符串中的一个字母<span class="math inline">\(ch_1\)</span>和任意一个字母<span class="math inline">\(ch_2\)</span>（<span class="math inline">\(ch_2\)</span>可以不在字符串中出现），将字符串<span class="math inline">\(s\)</span>中的所有<span class="math inline">\(ch_1\)</span>变成<span class="math inline">\(ch_2\)</span>。小红想知道，自己能否通过一些操作将字符串<span class="math inline">\(s\)</span>变成<span class="math inline">\(t\)</span>？</p><h2 id="输入-1">输入</h2><p>第一行输入一个正整数<span class="math inline">\(q\)</span>，代表查询次数。</p><p>对于每次查询输入2行：</p><p>第一行输入一个字符串<span class="math inline">\(s\)</span>。</p><p>第二行输入一个字符串<span class="math inline">\(t\)</span>。</p><ul><li><span class="math inline">\(1\le q\le 10\)</span></li></ul><p>保证<span class="math inline">\(s\)</span>和<span class="math inline">\(t\)</span>的长度相同，且均由小写字母组成，长度不超过<span class="math inline">\(10000\)</span>。</p><h2 id="输出-1">输出</h2><p>输出<span class="math inline">\(q\)</span>行，每行输出一个字符串代表答案。如果可以把<span class="math inline">\(s\)</span>变成<span class="math inline">\(t\)</span>，则输出<code>Yes</code>，否则输出<code>No</code>。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">ab</span><br><span class="line">ba</span><br><span class="line">abc</span><br><span class="line">aaa</span><br><span class="line">aaaa</span><br><span class="line">abcd</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="解答-1">解答</h2><p>如果字符串<span class="math inline">\(t\)</span>使用了全部的<span class="math inline">\(26\)</span>个字母，那么<span class="math inline">\(s\)</span>只能和<span class="math inline">\(t\)</span>相等，否则每做一次操作，<span class="math inline">\(s\)</span>最多只会有<span class="math inline">\(25\)</span>个不同的字母，它是没办法和<span class="math inline">\(t\)</span>相同的。</p><p>否则，对于任意两对下标<span class="math inline">\((i,j)\)</span>，如果<span class="math inline">\(s_i=s_j\)</span>，那么必须有<span class="math inline">\(t_i=t_j\)</span>。因为每一次操作都要将和<span class="math inline">\(s_i\)</span>相同的字母进行变换，变换后也一定是相同的，因此如果<span class="math inline">\(t_i\neqt_j\)</span>，那么这种情况是不可能达到的。</p><p>最后，由于<span class="math inline">\(t\)</span>不超过<span class="math inline">\(25\)</span>个字母，我们对<span class="math inline">\(s\)</span>进行变化时，可以先将其中一个字母<span class="math inline">\(c\)</span>变成<span class="math inline">\(t\)</span>中不存在的字母，然后再将其余<span class="math inline">\(t\)</span>包含<span class="math inline">\(c\)</span>的位置进行变换即可，这样不会造成混淆。因此这时一定会成功。</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    map&lt;<span class="type">char</span>,vector&lt;<span class="type">int</span>&gt;&gt;mp;</span><br><span class="line">    string s,t;</span><br><span class="line">    cin&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        mp[s[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    set&lt;<span class="type">char</span>&gt;<span class="built_in">st</span>(t.<span class="built_in">begin</span>(),t.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span>(st.<span class="built_in">size</span>()==<span class="number">26</span>) <span class="keyword">return</span> s==t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[k,v]:mp)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+<span class="number">1</span>&lt;v.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t[v[i+<span class="number">1</span>]]!=t[v[i]]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="built_in">solve</span>()?<span class="string">&quot;Yes&quot;</span>:<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="游游的字母矩阵">3、游游的字母矩阵</h1><p>游游拿到了一个<span class="math inline">\(n\)</span>行<span class="math inline">\(m\)</span>列的字母矩阵，矩阵中所有字符都是小写字母。</p><p>游游想知道，有多少个子矩阵满足，每个字母最多出现一次？</p><h2 id="输入-2">输入</h2><p>第一行输入两个正整数<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>，代表矩阵的大小。接下来的<span class="math inline">\(n\)</span>行，每行输入一个长度为<span class="math inline">\(m\)</span>的、仅包含小写字母的字符串。</p><ul><li><span class="math inline">\(1\le n,m \le 500\)</span></li></ul><h2 id="输出-2">输出</h2><p>每种字母只出现一次的子矩阵数量。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">2 3</span><br><span class="line">aad</span><br><span class="line">abc</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">13</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">除了满足条件的大小为1的六个子矩阵外，还有以下7个:</span><br><span class="line">.a.     ..d     .ad     ...     .ad     ...     ...</span><br><span class="line">.b.     ..c     ...     .bc     .bc     abc     ab.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>由于英语字母只有<span class="math inline">\(26\)</span>个，因此这里的子矩阵的面积（即长和宽之积）不超过<span class="math inline">\(26\)</span>。我们这里可以直接枚举每个子矩阵进行判断。</p><p>因此，我们首先枚举矩阵中的每个元素作为所求子矩阵的左上角，接下来枚举这个子矩阵的宽度<span class="math inline">\(k\)</span>，然后向右边拓展边计数即可。</p><p>这里为了保证不会超时，采用了如下措施：</p><ol type="1"><li>使用位运算记录哪些字母被使用。</li><li>边判断边计数，避免判断一个大矩阵是否合法时，重新开始判断。</li><li>发现矩阵不合法及时退出循环，因为包含这个子矩阵的子矩阵一定也是不合法的。</li></ol><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[<span class="number">504</span>][<span class="number">504</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            s[i][j]-=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=n;x++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">1</span>;y&lt;=m;y++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">26</span>&amp;&amp;x+k<span class="number">-1</span>&lt;=n;k++)&#123;</span><br><span class="line">                <span class="type">int</span> st=<span class="number">0</span>;</span><br><span class="line">                <span class="type">bool</span> ok=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;y+j<span class="number">-1</span>&lt;=m&amp;&amp;ok;j++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k&amp;&amp;ok;i++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(st&gt;&gt;s[x+i<span class="number">-1</span>][y+j<span class="number">-1</span>]&amp;<span class="number">1</span>) ok=<span class="number">0</span>;</span><br><span class="line">                        st|=<span class="number">1</span>&lt;&lt;s[x+i<span class="number">-1</span>][y+j<span class="number">-1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(ok) ++ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="游游改数组">4、游游改数组</h1><p>游游拿到了一个正整数，她准备恰好修改其中<span class="math inline">\(k\)</span>位，使得该正整数变成<span class="math inline">\(75\)</span>的倍数。你能帮游游求出有多少种修改方案吗？修改后，仍是正整数，且不允许存在前导零，答案请对<span class="math inline">\(10^9+7\)</span>取模。</p><h2 id="输入-3">输入</h2><p>第一行输入一个正整数<span class="math inline">\(n\)</span>。</p><p>第二行输入一个正整数<span class="math inline">\(k\)</span>。</p><ul><li><span class="math inline">\(1 \le n \le 10^{1000}\)</span></li><li><span class="math inline">\(1\le k\le 1000\)</span></li></ul><h2 id="输出-3">输出</h2><p>修改的方案数，对<span class="math inline">\(10^9+7\)</span>取模。</p><h2 id="样例-3">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">355</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">9</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">共有150、225、300、450、525、675、750、825、975这9种方案。</span><br></pre></td></tr></table></figure><h2 id="解答-3">解答</h2><p>如果一个数是<span class="math inline">\(75\)</span>的倍数，那么它一定满足如下特征：</p><ul><li>所有数位之和是<span class="math inline">\(3\)</span>的倍数。</li><li>最后两位无非是<span class="math inline">\(00,25,50,75\)</span>中的一个组合。</li></ul><p>令<span class="math inline">\(m\)</span>是<span class="math inline">\(n\)</span>的位数，令<span class="math inline">\(n_i(0\le i&lt; n)\)</span>表示<span class="math inline">\(n\)</span>的从高到低的第<span class="math inline">\(i\)</span>个数位。由于最后两位是固定搭配，因此我们先只考虑第一个特征。可以知道这里可以使用动态规划来处理。令<span class="math inline">\(f(i,j,r)(0\le i\le m,0\le j\le k,0\ler&lt;3)\)</span>表示对这个数的前<span class="math inline">\(i\)</span>位修改了<span class="math inline">\(j\)</span>个位置后，所得到的数的数位之和对<span class="math inline">\(3\)</span>取模的值为<span class="math inline">\(r\)</span>的方案数。那么我们可以构造出如下转移：</p><ul><li><span class="math inline">\(1\rightarrow f(0,0,0)\)</span></li><li><span class="math inline">\(f(i,j,k)\rightarrow f(i+1,j,(k+d)\bmod3)\qquad\text{if}\qquad d=n_i\)</span></li><li><span class="math inline">\(f(i,j,k)\rightarrow f(i+1,j+1,(k+d)\bmod3)\qquad\text{if}\qquad d\neq n_i\)</span></li></ul><p>其中，第一个行的转移表示初值，一个空的数字数组没有任何数位，它的数位和是<span class="math inline">\(0\)</span>，操作次数是<span class="math inline">\(0\)</span>；第二行表示对当前位不进行修改的决策，那么增加了当前位之后，修改次数依然是<span class="math inline">\(j\)</span>，因此转移到状态<span class="math inline">\(f(i+1,j,(k+d)\bmod3)\)</span>。第三行表示对当前位进行修改，其决策<span class="math inline">\(d\)</span>有<span class="math inline">\(9\)</span>种，分别是<span class="math inline">\(\{0,1,2,\dots,9\}-\{n_i\}\)</span>，因此转移到状态<span class="math inline">\(f(i+1,j+1,(k+d)\bmod 3)\)</span>。</p><p>再加上它是<span class="math inline">\(25\)</span>倍数的，因此<span class="math inline">\(n\)</span>的最后两位必须固定成一个组合。假设第<span class="math inline">\(i\)</span>种组合的倒数第二位和第一位的数字分别是<span class="math inline">\(a_i\)</span>和<span class="math inline">\(b_i\)</span>，那么前<span class="math inline">\(m-2\)</span>位的数位之和模<span class="math inline">\(3\)</span>的值必须为<span class="math inline">\((-a_i-b_i)\bmod 3\)</span>，并且还要根据<span class="math inline">\(a_i,b_i\)</span>是否和<span class="math inline">\(n_{m-2},n_{m-1}\)</span>相同，减去相对应的修改次数。</p><p>最终，枚举每种组合并加起来，就得到了本题所需要的答案。</p><h2 id="代码-3">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1004</span>;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> f[N][N][<span class="number">3</span>],mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x+=y;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=mod) x-=mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> a[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>&#125;,b[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s %d&quot;</span>,&amp;s,&amp;k);</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        s[i]-=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-2</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> d=s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=k;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">0</span>;r&lt;<span class="number">3</span>;r++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> x=(i==<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>);x&lt;<span class="number">10</span>;x++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(x==d) <span class="built_in">add</span>(f[i+<span class="number">1</span>][j][(r+x)%<span class="number">3</span>],f[i][j][r]);</span><br><span class="line">                    <span class="keyword">else</span> <span class="built_in">add</span>(f[i+<span class="number">1</span>][j+<span class="number">1</span>][(r+x)%<span class="number">3</span>],f[i][j][r]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;n==<span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> nk=k-(s[n<span class="number">-2</span>]!=a[i])-(s[n<span class="number">-1</span>]!=b[i]),nr=(<span class="number">9</span>-a[i]-b[i])%<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(nk&gt;=<span class="number">0</span>) <span class="built_in">add</span>(ans,f[n<span class="number">-2</span>][nk][nr]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">solve</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>腾讯 秋招 2023.09.15 编程题目与题解（算法岗）</title>
    <link href="https://ujimatsu-chiya.github.io/EXAM/Tengxun-20230915B/"/>
    <id>https://ujimatsu-chiya.github.io/EXAM/Tengxun-20230915B/</id>
    <published>2023-09-22T15:37:53.000Z</published>
    <updated>2023-09-22T15:37:53.538Z</updated>
    
    <content type="html"><![CDATA[<p><escape><span id="more"></span></escape></p><h1 id="子序列计数">1、子序列计数</h1><p>给定一个长度为<span class="math inline">\(n\)</span>的数组，求有多少子序列满足：子序列中元素种类数<span class="math inline">\(=\)</span>子序列长度。</p><p>由于答案可能很大，请输出答案取模<span class="math inline">\(998244353\)</span>后的结果。</p><h2 id="输入">输入</h2><p>第一行一个整数<span class="math inline">\(n,1\le n\le10^5\)</span></p><p>第二行<span class="math inline">\(n\)</span>个整数，<span class="math inline">\(a_1,a_2,\dots,a_n(1\le a_i \le 10^5)\)</span></p><h2 id="输出">输出</h2><p>一行一个整数，表示答案。</p><h2 id="样例">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">2 3 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">符合条件的子序列有（按照下标方式给出）</span><br><span class="line">&#123;1&#125;,&#123;1,2&#125;,&#123;1,3&#125;,&#123;2&#125;,&#123;3&#125;</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">1 3 4</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">符合条件的子序列有（按照下标方式给出）</span><br><span class="line">&#123;1&#125;,&#123;1,2&#125;,&#123;1,2,3&#125;,&#123;1,3&#125;,&#123;2&#125;,&#123;2,3&#125;,&#123;3&#125;</span><br></pre></td></tr></table></figure><h2 id="备注">备注</h2><p>子序列可以理解为从原数组中选择一些元素删掉（或者不删）并保持剩余元素的相对位置不变。</p><h2 id="解答">解答</h2><p>这道题意味着求出<span class="math inline">\(a\)</span>有多少个子序列，其元素各不相同。</p><p>由于元素各不相同，因此<span class="math inline">\(a\)</span>中的每个数在子序列中最多出现一次。对于不同的数而言，其出现的情况都是独立的，因此按照乘法原理，我们可以给出答案为：</p><p><span class="math display">\[\prod_{x} (c(x,a)+1)-1\]</span></p><p>其中<span class="math inline">\(c(x,a)\)</span>表示元素<span class="math inline">\(x\)</span>在<span class="math inline">\(a\)</span>出现的次数。上面的式子所表达的意思是：选择将<span class="math inline">\(x\)</span>放进子序列一共有<span class="math inline">\(c(x,a)\)</span>种方式，不将<span class="math inline">\(x\)</span>放进子序列有<span class="math inline">\(1\)</span>种方式，因此对<span class="math inline">\(x\)</span>的处理情况有<span class="math inline">\(c(x,a)+1\)</span>种。为了避免所有元素都没被放进子序列，最终答案还需要减去<span class="math inline">\(1\)</span>，即一个空子序列的情况。</p><h2 id="代码">代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>()</span><br><span class="line">c = Counter(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">mod = <span class="number">998244353</span></span><br><span class="line">ans = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> c.items():</span><br><span class="line">    ans = ans * (v + <span class="number">1</span>) % mod</span><br><span class="line">ans = (ans - <span class="number">1</span>) % mod</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="盲盲盒">2、盲盲盒</h1><p>最近盲盒活动非常火热，商家A和商家B打算进一步增加盲盒的“盲”，于是在各自的仓库，即仓库A和仓库B里面进行盲盒交换。</p><p>具体操作如下：</p><ol type="1"><li><p>首先仓库A里面有<span class="math inline">\(k\)</span>个普通盲盒以及<span class="math inline">\(1\)</span>个超珍稀盲盒，仓库B里面有<span class="math inline">\(k+1\)</span>个普通盲盒；</p></li><li><p>每次从两个仓库里面以均匀分布抽样出一个盲盒，并进行交换；经过<span class="math inline">\(n\)</span>次盲盒交换之后，超珍稀盲盒仍然在仓库A的概率为<span class="math inline">\(p/q\)</span> (最简分数)，那么<span class="math inline">\(p+q\)</span>模<span class="math inline">\(10\)</span>的数值是多少？</p></li></ol><h2 id="输入-1">输入</h2><p>第一行为测试组数<span class="math inline">\(T\)</span>，接下来有<span class="math inline">\(T\)</span>行数据，每行数据是交换次数<span class="math inline">\(n\)</span>和盲盒数量<span class="math inline">\(k\)</span>。</p><ul><li><span class="math inline">\(1&lt;n&lt;1000，1&lt;T&lt;20，1&lt;k&lt;100\)</span></li></ul><h2 id="输出-1">输出</h2><p>经过<span class="math inline">\(n\)</span>次盲盒交换之后，超珍稀盲盒仍然在仓库A的概率为<span class="math inline">\(p/q\)</span> (最简分数)，那么<span class="math inline">\(p+q\)</span>模<span class="math inline">\(10\)</span>的数值。</p><h2 id="样例-1">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">4</span><br><span class="line">2 5</span><br><span class="line">2 6</span><br><span class="line">3 7</span><br><span class="line">3 9</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1</span><br><span class="line">6</span><br><span class="line">9</span><br><span class="line">9</span><br></pre></td></tr></table></figure><h2 id="备注-1">备注</h2><p>解答：若令<span class="math inline">\(X(n)\)</span>表示在<span class="math inline">\(n\)</span>次交换之后，仓库A中超珍稀盲盒的数量。那么<span class="math inline">\(X(n)\)</span>的状态空间为<span class="math inline">\(0\)</span>或者<span class="math inline">\(1\)</span>，容易得到状态转移矩阵为<span class="math inline">\(\begin{bmatrix}\dfrac{k}{k+1}&amp;\dfrac{1}{k+1}\\\dfrac{1}{k+1}&amp;\dfrac{k}{k+1}\end{bmatrix}\)</span>。令<span class="math inline">\(a=\dfrac{k}{1+k}\)</span>，可以求得<span class="math inline">\(P^n\)</span>的第一行第一列元素（即所求概率，本来超珍稀在仓库A，<span class="math inline">\(n\)</span>次操作后仍然在仓库A中的概率）为<span class="math inline">\(\dfrac{1}{2}+\dfrac{1}{2}(2a-1)^n\)</span>。另外难度在获得最简分数<span class="math inline">\(p/q\)</span>，需要用欧几里得算法及时计算最大公约数并约分，否则容易数值溢出。</p><h2 id="解答-1">解答</h2><p>根据备注，可以知道这道题的答案是<span class="math inline">\(\dfrac{(k-1)^n+(k+1)^n}{2(k+1)^n}=\dfrac{1}{2}\left(1+\dfrac{(k-1)^n}{(k+1)^n}\right)\)</span>，根据经验，这道题可以使用暴力直接过（如下面代码实现的<code>solve2</code>所示）。</p><p>接下来讲解正确做法（如下面代码实现的<code>solve1</code>）。令<span class="math inline">\(u/v=(k-1)/(k+1)\)</span>表示化简后的结果。那么可见<span class="math inline">\(\dfrac{1}{2}\cdot\dfrac{u^n+v^n}{v^n}\)</span>就是最终的概率值。此外，<span class="math inline">\(\dfrac{u^n+v^n}{v^n}\)</span>是一个最简分数。接下来考虑两种情况：</p><ul><li><p>如果<span class="math inline">\(u+v\)</span>是奇数，那么上面的分数可以写成<span class="math inline">\(\dfrac{u^n+v^n}{2v^n}\)</span>。因此这种情况的最终答案为<span class="math inline">\(((u^n\bmod 10)+(v^n\bmod 10)+(2v^n\bmod 10))\bmod10\)</span>。</p></li><li><p>如果<span class="math inline">\(u+v\)</span>是偶数，那么分母的<span class="math inline">\(2\)</span>可以进一步和分子<span class="math inline">\(u^n+v^n\)</span>进行约分，因此上面的分数可以写成<span class="math inline">\(\dfrac{(u^n+v^n)/2}{v^n}\)</span>。为了保证除法的正确性，我们先对分子对<span class="math inline">\(20\)</span>取模，然后再除以<span class="math inline">\(2\)</span>。因此这种情况的最终答案为<span class="math inline">\(\left(\dfrac{((u^n\bmod 20)+(v^n\bmod 20))\mod20}{2}+(v^n\bmod 10)\right)\bmod 10\)</span>。</p></li></ul><h2 id="代码-1">代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确做法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve1</span>(<span class="params">n, k</span>):</span><br><span class="line">    num, den = k - <span class="number">1</span>, k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        num, den = num &gt;&gt; <span class="number">1</span>, den &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (num + den) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        p = (<span class="built_in">pow</span>(num, n, <span class="number">20</span>) + <span class="built_in">pow</span>(den, n, <span class="number">20</span>)) % <span class="number">20</span> // <span class="number">2</span></span><br><span class="line">        q = <span class="built_in">pow</span>(den, n, <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = (<span class="built_in">pow</span>(num, n, <span class="number">10</span>) + <span class="built_in">pow</span>(den, n, <span class="number">10</span>)) % <span class="number">10</span></span><br><span class="line">        q = <span class="built_in">pow</span>(den, n, <span class="number">10</span>) * <span class="number">2</span> % <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> (p + q) % <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴力做法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve2</span>(<span class="params">n, k</span>):</span><br><span class="line">    f = Fraction((k + <span class="number">1</span>) ** n + (k - <span class="number">1</span>) ** n, <span class="number">2</span> * (k + <span class="number">1</span>) ** n)</span><br><span class="line">    <span class="keyword">return</span> (f.numerator + f.denominator) % <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">    n, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    <span class="built_in">print</span>(solve1(n, k))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="数组变幻">3、数组变幻</h1><p>一个长度为<span class="math inline">\(n\)</span>的数组，每秒都在发生变幻。</p><p>每一次变幻，第<span class="math inline">\(1\)</span>个位置的数字将会和第<span class="math inline">\(2\)</span>个位置的数字合并，第<span class="math inline">\(3\)</span>个位置的数字将会和第<span class="math inline">\(4\)</span>个位置的数字合并，以此类推。。</p><p>这个数组会一直变幻到只剩两个数字为止。</p><p>合并数字时，将会使得两个数字相加。例如数组<span class="math inline">\([1,2,3,4,5]\)</span>第一秒会变成<span class="math inline">\([3,7,5]\)</span>（前两个数字合并，第三和第四个数字合并，由于没有第六个数字，所以第五个数字不变）第二秒会变成<span class="math inline">\([10,5]\)</span>，此时数组中只剩两个数字，变幻结束。</p><p>小q有一个变量<span class="math inline">\(x\)</span>，初始等于<span class="math inline">\(0\)</span>。每次数组变幻后，小q会把数组的第一个元素加到<span class="math inline">\(x\)</span>上。小q希望你输出最终<span class="math inline">\(x\)</span>的值。</p><p>由于这个数组长度很大，所以小q在给你数据时采用了一种新的方式。小q总共会给出<span class="math inline">\(k\)</span>条信息，每条信息包含两个正整数 <span class="math inline">\(a,b\)</span>，表示这个数组中有一段长度为<span class="math inline">\(a\)</span>的区间，区间中所有数字均为<span class="math inline">\(b\)</span>。（详见样例）</p><p>由于答案可能很大，请输出答案对<span class="math inline">\(10^9+7\)</span>取模后的结果。</p><h2 id="输入-2">输入</h2><p>第一行给出两个正整数<span class="math inline">\(n,k\)</span>，意义如题面所示。</p><p>接下来<span class="math inline">\(k\)</span>行分别给出两个正整数<span class="math inline">\(a_i,b_i\)</span>。表示数组有<span class="math inline">\(a_i\)</span>个数字<span class="math inline">\(b_i\)</span>。注意本题保证所有<span class="math inline">\(a_i\)</span>的和为<span class="math inline">\(n\)</span>。</p><ul><li><span class="math inline">\((1\le a_i\le n \le10^{18}, 1\le b_i \le10^9, 1\le k \le10^5)\)</span></li></ul><h2 id="输出-2">输出</h2><p>输出最终<span class="math inline">\(x\)</span>的值。</p><h2 id="样例-2">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5 5</span><br><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">1 5</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">13</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">初始数组为[1,2,3,4,5]</span><br><span class="line">第一次操作后，数组变成[3,7,5]，x加上3。</span><br><span class="line">第二次操作后，数组变成[10,5]，x加上10。</span><br><span class="line">最终x等于13。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">7 2</span><br><span class="line">3 1</span><br><span class="line">4 2</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">输入为3个1和4个2，即数组为[1,1,1,2,2,2,2]，第一秒变为[2,3,4,2]，第二秒变为[5,6]，最终的x等于2+5=7。</span><br></pre></td></tr></table></figure><h2 id="解答-2">解答</h2><p>这题是一道模拟题，需要注意一些细节。在模拟的过程中，我们依旧使用题目中的那种对数组的表达方式，即第<span class="math inline">\(i\)</span>段元素有<span class="math inline">\(a_i\)</span>个元素<span class="math inline">\(b_i\)</span>。以下分两种情况进行讨论。</p><ol type="1"><li><p>如果<span class="math inline">\(a_i=1\)</span>，那么这时需要考虑和下一段数（如果存在的话）中的第一个进行合并。这时会产生一个段<span class="math inline">\((1,b_i+b_{i+1})\)</span>。</p></li><li><p>如果<span class="math inline">\(a_1&gt;1\)</span>，那么这一段数会产生一个新段<span class="math inline">\((\lfloor a_i/2\rfloor,2\cdotb_i)\)</span>，同时令<span class="math inline">\(a_i&#39;=a_i\bmod2\)</span>，如果<span class="math inline">\(a_i&#39;=1\)</span>，那么转为情况1继续进行，否则考虑下一段。</p></li></ol><p>由于每次变换过后，数组的元素数量都会减少一半，因此这种变换最多只会进行<span class="math inline">\(\logn\)</span>次。此外，如果两个相邻段都只有一个元素，那么这些段必定会被合并。因此，在模拟过程中，数组的总段数不会超过<span class="math inline">\(3k\)</span>。因此本题的时间复杂度为<span class="math inline">\(O(k\log n)\)</span>。</p><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> pl pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> X first</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> Y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll n,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ok</span><span class="params">(deque&lt;pl&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    ll t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[x,y]:v)&#123;</span><br><span class="line">        t+=x;</span><br><span class="line">        <span class="keyword">if</span>(t&gt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    ll a,b;</span><br><span class="line">    deque&lt;pl&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        q.<span class="built_in">push_back</span>(<span class="built_in">pl</span>(a,b));</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">ok</span>(q))&#123;</span><br><span class="line">        deque&lt;pl&gt;q2;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(q[<span class="number">0</span>].X==<span class="number">0</span>) q.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(q[<span class="number">0</span>].X==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(q.<span class="built_in">size</span>()&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">                    --q[<span class="number">1</span>].X;</span><br><span class="line">                    q2.<span class="built_in">push_back</span>(<span class="built_in">pl</span>(<span class="number">1</span>,(q[<span class="number">0</span>].Y+q[<span class="number">1</span>].Y)%mod));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> q2.<span class="built_in">push_back</span>(<span class="built_in">pl</span>(<span class="number">1</span>,q[<span class="number">0</span>].Y));</span><br><span class="line">                q.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                q2.<span class="built_in">push_back</span>(<span class="built_in">pl</span>(q[<span class="number">0</span>].X&gt;&gt;<span class="number">1</span>,(q[<span class="number">0</span>].Y&lt;&lt;<span class="number">1</span>)%mod));</span><br><span class="line">                q[<span class="number">0</span>].X&amp;=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=(ans+q2[<span class="number">0</span>].Y)%mod;</span><br><span class="line">        q=q2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="最短路">4、最短路</h1><p>初始有<span class="math inline">\(n\)</span>个点，第<span class="math inline">\(i\)</span>个点坐标为<span class="math inline">\((x_i,y_i)\)</span>，起点是第<span class="math inline">\(s\)</span>个点，终点是第<span class="math inline">\(t\)</span>个点，原本任意两点间都有一条线段代表能在两点间通行(长度为欧几里得距离)，但因为一些意外，<span class="math inline">\(s\)</span>和<span class="math inline">\(t\)</span>之间的线段被删除了，现在求<span class="math inline">\(s-t\)</span>的最短距离是多少。</p><p>其中保证<span class="math inline">\(s\neq t\)</span>。</p><p><span class="math inline">\(i,j\)</span>两点欧几里得距离即<span class="math inline">\(\sqrt{(x_i-x_j)^2+(y_i-y_j)^2}\)</span></p><h2 id="输入-3">输入</h2><p>第一行有三个正整数，依次表示有<span class="math inline">\(n\)</span>个点，以及起点<span class="math inline">\(s\)</span>和终点<span class="math inline">\(t\)</span>。</p><p>接下来<span class="math inline">\(n\)</span>行每行<span class="math inline">\(2\)</span>个整数，第<span class="math inline">\(i\)</span>行代表第个点的坐标为<span class="math inline">\(x_i,y_i\)</span>。</p><ul><li><span class="math inline">\(3 \le n \le 10^5 ,1 \le s,t \le n, 1 \lex_i,y_i \le 10^6\)</span></li></ul><h2 id="输出-3">输出</h2><p>输出一行一个数代表答案（输出四舍五入到小数点后两位）</p><h2 id="样例-3">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5 1 5</span><br><span class="line">17253 15901</span><br><span class="line">25501 15698</span><br><span class="line">28676 32041</span><br><span class="line">30711 11015</span><br><span class="line">18651 9733</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">17333.65</span><br></pre></td></tr></table></figure><h2 id="解答-3">解答</h2><p>由于每个边权都是欧几里得距离，因此这些边权满足三角形不等式。也就是说，如果存在一条路径经过了<span class="math inline">\(k\)</span>个点，那么必定存在一条更短的路径，其经过<span class="math inline">\(k-1\)</span>个点。</p><p>因此，最终答案为<span class="math inline">\(\displaystyle{\min_{1\lei\len,i\not\in\{s,t\}}\{\text{dist}(s,i)+\text{dist}(i,t)\}}\)</span>，其中<span class="math inline">\(\text{dist}(i,j)=\sqrt{(x_i-x_j)^2+(y_i-y_j)^2}\)</span>。</p><h2 id="代码-3">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line">ll x[N],y[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dis</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span></span>&#123;</span><br><span class="line">    ll dx=x[p]-x[q],dy=y[p]-y[q];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(dx*dx+dy*dy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> s,t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;n,&amp;s,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;x[i],&amp;y[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> ans=<span class="number">1e14</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==s||i==t) <span class="keyword">continue</span>;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,<span class="built_in">dis</span>(s,i)+<span class="built_in">dis</span>(t,i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="三国无双游戏">5、三国无双游戏</h1><p>牛牛最近三国演义入了迷，他时常幻想着自己是一代枭雄，坐拥城池百万，精锐无数。</p><p>然而他只能做做美梦玩玩三国无双的游戏罢了qwq。</p><p>游戏中牛牛有<span class="math inline">\(n\)</span>座城池，城池编号为<span class="math inline">\(1\simn\)</span>，由于某些城池地理位置极其重要，因此牛牛要设置一些关卡来建立防御工程。现在牛午有<span class="math inline">\(m\)</span>个工程计划，每个工程计划有两个整数<span class="math inline">\(L,R\)</span>，表示从第<span class="math inline">\(L\)</span>座城池到第<span class="math inline">\(R\)</span>座城池中，至少有一个城池被设置为关卡。</p><p>牛牛想知道，为了使得每个计划都满足，有多少中不同的设置关卡的方法？</p><p>游戏难度：<strong>保证<span class="math inline">\(m\)</span>个计划中，可能会出现相交的区间</strong>。</p><h2 id="输入-4">输入</h2><p>第一行输入两个整数<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>，其中<span class="math inline">\(n\)</span>表示城池的数量，<span class="math inline">\(m\)</span>表示工程计划的数量。</p><p>接下来<span class="math inline">\(m\)</span>行，每行两个整数<span class="math inline">\(L ,R\)</span>，表示该计划要求从第<span class="math inline">\(L\)</span>座城池到第<span class="math inline">\(R\)</span>座城池中，至少有一个城池被设置为关卡。</p><p><span class="math inline">\(1\le n,m\le 10^5,1\le L\le R\len\)</span></p><h2 id="输出-4">输出</h2><p>输出一个整数，表示设置关卡的方案数，对<span class="math inline">\(10^9+7\)</span>取模。</p><h2 id="样例-4">样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3 2</span><br><span class="line">2 3</span><br><span class="line">1 2</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">用1表示关卡，0表示普通城池，那么这5种方案分别是: 010，011，110，111，101</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">12 3</span><br><span class="line">1 7</span><br><span class="line">6 12</span><br><span class="line">5 10</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">3988</span><br></pre></td></tr></table></figure><h2 id="解答-4">解答</h2><p>本题的统计要点在于：假设现在已经填了一个<span class="math inline">\(1\)</span>比特，那么下一个<span class="math inline">\(1\)</span>比特该往哪里填？需要注意的是，不存在两个相邻的<span class="math inline">\(1\)</span>比特中间包含了我们输入给定的区间。</p><p>因此，我们可以考虑使用动态规划来解决这个问题。令状态<span class="math inline">\(f(i)\)</span>表示已经填充了前<span class="math inline">\(i\)</span>个比特，其中第<span class="math inline">\(i\)</span>个比特为<span class="math inline">\(1\)</span>，并且对于右端点小于等于<span class="math inline">\(i\)</span>的区间，都满足要求的方案数。</p><p>令<span class="math inline">\(l_i\)</span>表示右端点小于等于<span class="math inline">\(i\)</span>的所有区间中，这些左端点的最大值（如果所有区间的右端点都大于<span class="math inline">\(i\)</span>，那么令<span class="math inline">\(l_i=0\)</span>。这意味着，对于任意<span class="math inline">\(i\ge 1\)</span>，如果<span class="math inline">\(l_i&gt;0\)</span>，那么从<span class="math inline">\(l_i\)</span>到<span class="math inline">\(i\)</span>必须要有至少一个<span class="math inline">\(1\)</span>。</p><p>那么我们可以写出如下状态转移方程：</p><p><span class="math inline">\(f(i)= \left \{\begin{aligned}  &amp;1&amp; &amp; \text{if}\quad i=0 \\  &amp;\sum_{j=l_{i-1}}^{i-1} f(j)&amp; &amp; \text{if}\quad i\ge 1 \\ \end{aligned}\right.\)</span></p><p>对于这个方程的第一行，这是一个空串，它显而易见是合法的。对于一个从<span class="math inline">\(f(j)\)</span>到<span class="math inline">\(f(i)\)</span>的转移，它是将第<span class="math inline">\(j+1,j+2,\dots,i-1\)</span>都填上<span class="math inline">\(0\)</span>，最后才在<span class="math inline">\(i\)</span>填上<span class="math inline">\(1\)</span>。也就是说，从<span class="math inline">\(f(l_{i-1}),f(l_{i-1}+1),\dots,f(i-1)\)</span>中转移而来的方案都是不尽相同的，它们确保了区间<span class="math inline">\([l_{i-1},i-1]\)</span>都至少包含了一个<span class="math inline">\(1\)</span>。</p><p>因此，为了确保<span class="math inline">\([l_n,n]\)</span>也是合法的，最终答案只包含<span class="math inline">\(\displaystyle{\sum_{i=l_n}^n f(i)}\)</span>。</p><p>可见，<span class="math inline">\(f(i)\)</span>的转移是<span class="math inline">\(O(n)\)</span>的，令<span class="math inline">\(\displaystyle{s(i)=\sum_{j=0}^if(j)}\)</span>表示<span class="math inline">\(f(i)\)</span>的前缀和，那么我们可以使用<span class="math inline">\(O(1)\)</span>的时间优化这个转移结果。因此最终答案为：如果<span class="math inline">\(l_n=0\)</span>，那么答案为<span class="math inline">\(s(n)\)</span>，否则为<span class="math inline">\(s(n)-s(l_n-1)\)</span>。</p><h2 id="代码-4">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100004</span>;</span><br><span class="line">ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> lp[N],n,m;</span><br><span class="line">ll s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        lp[y]=<span class="built_in">max</span>(lp[y],x);</span><br><span class="line">    &#125;</span><br><span class="line">    s[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ll w=s[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(l&gt;<span class="number">0</span>) w=(w-s[l<span class="number">-1</span>]+mod)%mod;</span><br><span class="line">        s[i]=(s[i<span class="number">-1</span>]+w)%mod;</span><br><span class="line">        l=<span class="built_in">max</span>(l,lp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=s[n];</span><br><span class="line">    <span class="keyword">if</span>(l&gt;<span class="number">0</span>) ans=(ans-s[l<span class="number">-1</span>]+mod)%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;escape&gt;&lt;/escape&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔试" scheme="https://ujimatsu-chiya.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
</feed>
