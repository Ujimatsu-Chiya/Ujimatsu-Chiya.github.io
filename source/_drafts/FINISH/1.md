
Q389

```C++
# include <bits/stdc++.h>
using namespace std;
vector<int>d={4,6,8,12,20};
int main(){
    int m=1;
    vector<double>fp1(2);
    fp1[1]=1;
    for(int x:d){
        vector<double>fp2(1,1);
        vector<double>fn1(m*x+1,0);
        for(int i=1;i<=m;i++){
            vector<double>fn2(x*i+1);
            for(int j=0;j<=x*(i-1);j++)
                for(int k=1;k<=x;k++)
                    fn2[j+k]+=fp2[j]/x;
            fp2=fn2;
            for(int j=1;j<=x*i;j++)
                fn1[j]+=fp1[i]*fp2[j];
        }
        fp1=fn1;
        m*=x;
    }
    double ex1=0,ex2=0;
    for(int i=1;i<=m;i++){
        ex1+=fp1[i]*i;
        ex2+=fp1[i]*i*i;
    }
    double ans=ex2-ex1*ex1;
    printf("%.4f\n",ans);
}
```

Q395

```C++
# include <bits/stdc++.h>
using namespace std;
const double eps = 1e-15;
double minx = 0, miny = 0, maxx = 1, maxy = 1;
double leftRotate = acos(0.8);
//直接将正方形的下边旋转约180-53度。
double rightRotate = -acos(0.6);
double tag = 5;
struct Square {
    double len, x, y, rad;
};

int main() {

    queue<Square> q;
    q.push({1, 0, 0, 0});
    while (!q.empty()) {
        Square prm = q.front();q.pop();
        //正方形左下角的点。
        double len = prm.len, ldx = prm.x, ldy = prm.y, rad = prm.rad;

        minx = min(minx, ldx);
        maxx = max(maxx, ldx);
        miny = min(miny, ldy);
        maxy = max(maxy, ldy);

        double cosrad = cos(rad);
        double sinrad = sin(rad);
        double dx = len * cosrad;
        double dy = len * sinrad;
        //正方形左上角的点。
        double lux = ldx - dy, luy = ldy + dx;
        //正方形位于上边上面的新点。
        double tx = lux + ((dx * 0.8) - (dy * 0.6)) * 0.8,ty = luy + ((dx * 0.6) + (dy * 0.8)) * 0.8;

        if (len * 0.8 > eps) {
            double pl = len * tag * 0.8;
            if (lux > maxx - pl || lux < minx + pl || luy > maxy - pl || luy < miny + pl) {
                q.push({len * 0.8, lux, luy, rad + leftRotate});
            }

            if (len * 0.6 > eps) {
                pl = len * tag * 0.6;
                if (tx > maxx - pl || tx < minx + pl || ty > maxy - pl || ty < miny + pl) {
                    q.push({len * 0.6, tx, ty, rad + rightRotate});
                }
            }
        }
    }
    double ans = (maxx - minx) * (maxy - miny);
    printf("%.10f\n", ans);
}
```

Q407

```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e7;
int mxp[N+4];
int main(){
    for(int p=2;p<=N;p++)
        if(!mxp[p])
            for(int i=p;i<=N;i+=p) mxp[i]=p;
    ll ans=0;
    for(int n=1;n<=N;n++){
        int m=1;
        for(int tp=n;tp>1;){
            int t=1;
            for(int p=mxp[tp];tp%p==0;tp/=p,t*=p);
            m=max(m,t);
        }
        int a=n-1;
        for(a=a-a%m;a>=0;a-=m){
            if(a+1<n&&1ll*a*(a+1)%n==0){
                ++a;break;
            }
            if(1ll*a*(a-1)%n==0) break;
        }
        ans+=a;
    }
    printf("%lld\n",ans);
}
```

Q425

```C++
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e7;
int pr[N+4],v[N+4],m=0;
int fa[N+4];
int now[1004],p=0;
int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
void merge(int x,int y){fa[find(x)]=find(y);}
int main(){
    for(int i=1;i<=N;i++)
        fa[i]=i;
    for(int i=2;i<=N;i++){
        if(v[i]==0){
            v[i]=i;pr[++m]=i;
        }
        for(int j=1;j<=m;j++){
            if(pr[j]>v[i]||pr[j]>N/i) break;
            v[i*pr[j]]=pr[j];
        }
    }
    ll ans=0;
    for(int i=1;i<=m;i++){
        int u=pr[i];
        string s=to_string(u);
        string t=s;
        p=0;
        for(int i=0;i<s.size();i++){
            char ch=s[i];
            for(int j=(i==0?1:0);j<10;j++){
                t[i]='0'+j;
                now[++p]=atoi(t.c_str());
            }
            t[i]=ch;
        }
        if(t.size()>=2&&t[1]!='0'){
            t=t.substr(1);
            now[++p]=atoi(t.c_str());
        }
        for(int i=1;i<=p;i++){
            int k=now[i];
            if(k>=u||v[k]!=k) continue;
            merge(k,u);
        }
        if(find(2)!=find(u)) ans+=u;
    }
    printf("%lld\n",ans);
}

```

Q443

```C++
# include <bits/stdc++.h>
# define X first
# define Y second
# define lb(x) ((x) & (-x))
# define mem(a,b) memset(a,b,sizeof(a))
# define debug freopen("r.txt","r",stdin)
# define pi pair<int,int>
using namespace std;
typedef long long ll;
const ll Q = 1e15;
const int N=sqrt(Q)*2;
int v[N],pr[N],p=0;
ll px[34],q=0;
void fact(ll x){
    q=0;
    for(int i=1;i<=p&&1ll*pr[i]*pr[i]<=x;i++)
    if(x%pr[i]==0){
        px[++q]=pr[i];
        for(;x%pr[i]==0;x/=pr[i]);
    }
    if(x!=1) px[++q]=x;
}
int main(){
    for (int i = 2; i < N; i++) {
        if (v[i] == 0) {
            pr[++p] = i;
            v[i] = i;
        }
        for (int j = 1; j <= p; j++) {
            if (pr[j] > v[i] || pr[j] > N / i) break;
            v[i * pr[j]] = pr[j];
        }
    }
    ll n=4,g=13;
    //找最小的k使得gcd(n+k+1,g+k)!=1，等价于gcd(g-n-1,n+k+1)!=1;
    for(;;){
        fact(g-n-1);
        ll nxt=1e18;
        //找到下一个最小的n'>n，使得gcd(n',g(n'-1))>1，
        //tn则是一个新的g(n'-1)，使得此时的gcd(n',g(n'-1))>1。
        for(int i=1;i<=q;i++){
            ll tn=(g+px[i]-1)/px[i]*px[i];
            nxt=min(nxt,tn);
        }
        ll k=nxt-g;
        ll np=n+1+k;
        if(np>Q){
            g+=Q-n;
            break;
        }
        g=nxt+__gcd(np,nxt);
        n=np;
        if(n>=Q) break;
    }
    printf("%lld\n",g);
}

```

Q461

```C++
#include <bits/stdc++.h>
# define mem(a,b) memset(a,b,sizeof(a))
# define pdi pair<double,int>
# define X first
# define Y second
using namespace std;
const int N=10000;
double e=exp(1),pi=acos(-1.0);
pdi pa[N*N];
double f[N+N];
int m=0,n=0;
int main(){
    double pi=acos(-1);
    double mx=log(pi+1);
    for(int i=0;i<N+N;i++){
        double e=1.0*i/N;
        f[m++]=exp(e)-1;
        if(e>mx) break;
    }
    for(int i=0;i<m;i++)
        for(int j=0;j<=i;j++){
            double w=f[i]+f[j];
            pa[n++]=pdi(w,i*i+j*j);
            if(w>pi) break;
        }
    sort(pa,pa+n);
    double eps=1e9;
    int ans=0;
    for(int l=0,r=n-1;l<n;l++){
        for(;r>=0&&pa[l].X+pa[r].X>pi;--r);
        if(r>0){
            double w=abs(pi-pa[l].X-pa[r].X);
            if(w<eps){
                eps=w;ans=pa[l].Y+pa[r].Y;
            }
        }
        if(r+1<n){
            double w=abs(pi-pa[l].X-pa[r+1].X);
            if(w<eps){
                eps=w;ans=pa[l].Y+pa[r+1].Y;
            }
        }
    }
    printf("%d\n",ans);
}

```

Q491

```Python
B = 2
B += 1
f = [{} for i in range(B ** 10)]
for i in range(1, 10):
    f[B ** i][i] = 1
for st in range(len(f)):
    ls = []
    for i in range(10):
        ls.append(st // (B ** i) % B)
    cnt = sum(ls)
    for s, val in f[st].items():
        for i in range(10):
            if ls[i] == B - 1:
                continue
            if cnt % 2 == 0:
                now = s + i
            else:
                now = s - i
            newst = st + B ** i
            if now not in f[newst].keys():
                f[newst][now] = 0
            f[newst][now] += val
ans = sum(val for s, val in f[-1].items() if s % 11 == 0)
print(ans)
```

Q501

```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll Q = 1000000000000;
const ll M = pow(Q,2.0/3) + 2;


char vis[M + 1];
int sum[M + 1],pr[M + 1],m;

unordered_map<ll,ll> mp,mq;
ll g(ll x, ll a) {
    if (a == 1 || x == 0)return (x + 1) / 2;
    ll &v = mp[(x << 10) + a];
    if (v)return v;
    return v = g(x, a - 1) - g(x / pr[a], a - 1);
}
ll cal(ll n) {
    if (n <= M)return sum[n];
    ll &v = mq[n];
    if (v) return v;
    ll a = cal(pow(n, 1.0 / 4));
    ll b = cal(sqrt(n));
    ll c = cal(pow(n, 1.0 / 3));
    ll s = g(n, a) + (b + a - 2) * (b - a + 1) / 2;
    for (ll i = a + 1; i <= b; i++) {
        ll w = n / pr[i];
        s -= cal(w);
        ll csqw = cal(sqrt(w));
        if (i <= c) {
            for (ll j = i; j <= csqw; j++)
                s += j - 1 - cal(w / pr[j]);
        }
    }
    return v = s;
}
int main() {
    ll ans = 0;
    for (ll i = 2; i <= M; i++) {
        if (!vis[i]) {
            for (ll j = i * i; j <= M; j += i) vis[j] = 1;
            pr[++m] = i;
        }
        sum[i] = m;
    }
    for (ll i = 1; i <= m && pr[i] <= pow(Q, 1.0 / 7); i++)
        ans++;
    ll tmp;
    for (int i = 1; i <= m && (tmp = Q / (1ll * pr[i] * pr[i] * pr[i])) >= 2; i++) {
        ans += cal(tmp) - (tmp >= pr[i]);
    }
    for (ll i = 1; 1ll * pr[i] * pr[i] * pr[i] <= Q; i++)
        for (ll j = i + 1; j <= m && pr[j + 1] <= (tmp = Q / (1ll * pr[i] * pr[j])); j++)
            ans += cal(tmp) - cal(pr[j]);
    printf("%lld\n", ans);
    return 0;
}
```

Q506

```Python
from gmpy2 import is_prime

# A028355
# 发现，该序列的周期为15，第i个鼠是第i-15个数后面拼接一个固定的6位数。
# 将每个n分解成n=x*15+y再进行计算。

N = 10**14
mod = 123454321
inv1e6 = 96007682
m = 10 ** 6
a = [1, 2, 3, 4, 32, 123, 43, 2123, 432, 1234, 32123, 43212, 34321, 23432, 123432]
b = [234321, 343212, 432123, 321234, 123432, 432123, 212343, 432123, 123432, 321234, 432123, 343212, 234321, 123432, 123432]
T = 15
ans = 0
for i in range(T):
    cnt = N // T + (i < N % T)
    c1 = (pow(m, cnt, mod) - 1) * inv1e6 % mod
    c2 = (c1 - cnt + mod) * inv1e6 % mod
    ans = (ans + a[i] * c1 + b[i] * c2) % mod
print(ans)

```

Q511

```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1234567898765,M=4321,O=64;
ll mod=1e9;
ll cnt[M];
ll a[M],b[O][M];
void getd(ll N){
    for(ll i=1;i*i<=N;i++)
    if(N%i==0){
        ++cnt[(i+1)%M];
        if(i*i!=N) ++cnt[(N/i+1)%M];
    }
}
void cal(ll a[M],ll b[M],ll ans[M]){
    ll c[M]={0};
    for(int i=0;i<M;i++)
        for(int j=0;j<M;j++)
            c[(i+j)%M]=(c[(i+j)%M]+a[i]*b[j])%mod;
    memcpy(ans,c,sizeof(c));
}
int main(){
    getd(N);
    a[0]=1;
    memcpy(b[0],cnt,sizeof(b[0]));
    for(int i=1;i<O;i++)
        cal(b[i-1],b[i-1],b[i]);
    for(int i=0;i<O;i++)
        if(N>>i&1)
            cal(a,b[i],a);
    printf("%lld\n",a[0]);
}
```

Q523

```Python
# A279683

N = 30
fac = [1]
a = [0]
for i in range(1, N + 1):
    fac.append(fac[-1] * i)
    a.append(a[i - 1] * i + fac[i - 1] * (2 ** (i - 1) - 1))

ans = a[N] / fac[N]
print("{:.2f}".format(ans))

```

Q531

```C++
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int L=1000000,R=1005000;
int phi[R+4];
ll ex_gcd(ll a,ll b,ll &x,ll &y){
    if(b==0){
        x=1;y=0;return a;
    }
    ll g=ex_gcd(b,a%b,x,y);
    ll z=x-(a/b)*y;
    x=y;y=z;return g;
}
//解不定方程ax+my=c。
ll congruence(ll a,ll c,ll m){
    ll x,y,g;
    g=ex_gcd(a,m,x,y);
    if(c%g!=0) return -1;
    x*=c/g;
    ll t=m/g;
    return (x%t+t)%t;
}
ll CRT(ll b,ll m,ll c,ll n){
    ll y=congruence(m,c-b,n);
    if(y==-1) return -1;
    ll x=m*y+b;
    ll t=m*n;
    return (x%t+t)%t;
}
int main(){
    for(int i=1;i<R;i++)
        phi[i]=i;
    for(int i=2;i<R;i++){
        if(phi[i]!=i) continue;
        phi[i]=i-1;
        for(int j=i+i;j<R;j+=i)
            phi[j]=phi[j]/i*(i-1);
    }
    ll ans=0;
    for(int i=L;i<R;i++){
        for(int j=i+1;j<R;j++){
            ll x=CRT(phi[i],i,phi[j],j);
            if(x!=-1) ans+=x;
        }
    }
    printf("%lld\n",ans);
}
```

Q549

```C++
#include <bits/stdc++.h>
# define X first
# define Y second
using namespace std;
typedef long long ll;
const int N=1e8;
int s[N+4];
int solve(int p,int e){
    ll k;
    for(k=p;;k+=p){
        ll t=k;
        for(;t%p==0&&e>0;--e,t/=p);
        if(e==0) break;
    }
    return k;
}
int main(){
    for(int i=2;i<=N;i++){
        if(s[i]!=0) continue;
        for(ll j=i,c=1;j<=N;j*=i,++c){
            int mx=solve(i,c);
            for(ll k=j;k<=N;k+=j)
                s[k]=max(s[k],mx);
        }
    }
    ll ans=0;
    for(int i=2;i<=N;i++){
        ans+=s[i];
    }
    printf("%lld\n",ans);
}
```

Q561

```Python
# E(m,n)=((n+1)(n+2)/2)^m-(n+1)^m，对式子提公因式(n+1)^m，然后进行判定。

Q = 10 ** 12
M = 904961


def cal(n: int):
    cnt = 0
    M = len(bin(n)[2:])
    for i in range(1, M + 1):
        cnt += (n + 2 ** (i - 1)) // (2 ** i) * i
    return cnt


c0 = Q // 4
c3 = (Q + 1) // 4
ans = cal(c3) * M
if M % 2 == 0:
    tp = cal(c3 >> 1) + cal((c3 + 1) >> 1)
    v = bin(M)[::-1].find('1')
    tp += c0 * (v + 1)
    ans += tp
else:
    ans += cal(c0)
print(ans)
```

Q577

```Python
N = 12345
ans = 0
for n in range(N-2):
    ans += Fraction(1, 216) * n ** 4 + Fraction(1, 12) * n ** 3 + Fraction(37, 72) * n ** 2 + [Fraction(5, 4), Fraction(139, 108), Fraction(131, 108)][n % 3] * n + [1, Fraction(10, 9), Fraction(7, 9)][n % 3]
print(ans)
# A011779
```

Q581

```C++
# include <bits/stdc++.h>
using namespace std;
const int M=47;
int pr[M+4],m=0,b[M+4];
typedef long long ll;
int main(){
    ll N=2e12;
    for(int i=2;i<=M;i++){
        if(b[i]) continue;
        pr[++m]=i;
        for(int j=i+i;j<=M;j+=i)
            b[j]=1;
    }
    priority_queue<ll,vector<ll>,greater<ll>>q;
    q.push(1);
    ll ans=0,pre=1;
    while(!q.empty()){
        ll u=q.top();q.pop();
        if(u==pre+1){
            ans+=pre;
        }
        pre=u;
        for(int i=1;i<=m;i++){
            ll v=u*pr[i];
            if(v>N) break;
            q.push(v);
            if(u%pr[i]==0) break;
        }
    }
    printf("%lld\n",ans);
}

```

Q622

```Python
Q = 60
R = 2 ** Q - 1
ls = Get_Divisors(R)
ans = 0
for d in ls:
    p = 1
    while p <= Q:
        if quick_power(2, p, d) == 1:
            break
        p += 1
    if p == Q:
        ans += d+1
print(ans)
'''
原问题等价于求2模n-1的阶数r。其中有多少个r的值为60。
'''
```

Q630

```C++
# include <bits/stdc++.h>
# define pi pair<int,int>
using namespace std;
typedef long long ll;
const int N=2500;
int S[N*2+4],T[N*2+4];
ll solve(vector<pi>&v){
    map<pi,unordered_set<double>>mp;
    sort(v.begin(),v.end());
    v.resize(unique(v.begin(),v.end())-v.begin());
    int x1,y1,x2,y2;
    for(int i=0;i<v.size();i++)
    for(int j=0;j<i;j++){
        tie(x1,y1)=v[i];
        tie(x2,y2)=v[j];
        int x=x2-x1,y=y1-y2;
        double z=x1*y2-x2*y1;
        int g=__gcd(x,y);
        x/=g;y/=g;z/=g;
        if(x<0||x==0&&y<0){
            x=-x;y=-y;z=-z;
        }
        mp[pi(x,y)].insert(z);
    }
    int m=0;
    for(auto &[k,st]:mp)
        m+=st.size();
    ll ans=0;
    for(auto &[k,st]:mp)
        ans+=1ll*st.size()*(m-st.size());
    return ans;
}
int main(){
    S[0]=290797;
    for(int i=1;i<=N*2;i++){
        S[i]=1ll*S[i-1]*S[i-1]%50515093;
        T[i]=S[i]%2000-1000;
    }
    vector<pi>v;
    for(int i=2;i<=N*2;i+=2)
        v.push_back(pi(T[i-1],T[i]));
    printf("%lld\n",solve(v));
}

```

Q686

```Python
i, c = 1, 0
lg = log10(2)

lt = [196, 289, 485]
l, r = log10(1.23), log10(1.24)
pre = 0
i = 90
c = 2
s = lg * i
while c < 678910:
    j = 0
    while j < 3:
        ns = s + lg * lt[j]
        if l <= ns - int(ns) < r:
            break
        j += 1
    if j == 4:
        print("FAIL")
        exit()
    s += lg * lt[j]
    i += lt[j]
    c += 1
print(i)
```

Q688

```C++
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const ll Q=1e16;
ll mod=1e9+7;
ll inv2=(mod+1)>>1;
int main(){
    ll ans=0;
    for(ll k=1;;k++){
        ll w=k*(k+1)/2;
        if(w>Q) break;
        ll t=Q-w;
        ll block=(t+1)/k%mod,res=(t+1)%k%mod;
        ans=(ans+k*block%mod*(block+1)%mod*inv2%mod+(block+1)*res%mod)%mod;
    }
    printf("%lld\n",ans);
}
```

Q692

```Python
import bisect
# Zeckendorf's theorem
f = [1, 2]
for i in range(100):
    f.append(f[-1] + f[-2])
G = {1: 1, 2: 3}


def getG(n: int):
    if n in G.keys():
        return G[n]
    p = bisect.bisect_right(f, n) - 1
    if f[p] == n:
        G[n] = getG(f[p - 2]) + getG(f[p - 1]) + f[p] - f[p - 2]
    else:
        G[n] = getG(f[p]) + getG(n - f[p])
    return G[n]


print(getG(23416728348467685))
```

Q694

```C++
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const ll Q=1e18;
const int M=pow(Q,1.0/3);
bool b[M+4];
int pr[M/3+100],m=0;
int main(){
    for(int i=2;i<=M;i++){
        if(b[i]) continue;
        pr[++m]=i;
        for(ll j=1ll*i*i;j<=M;j+=i)
            b[j]=1;
    }
    set<ll>st;
    unordered_set<ll>st2;
    st.insert(1);
    for(int i=1;i<=m;i++){
        st2.clear();
        for(ll x:st){
            int cnt=0;
            while(x<=Q/pr[i]){
                x*=pr[i];
                if(++cnt>=3)
                    st2.insert(x);
            }
            if(cnt<3) break;
        }
        for(ll x:st2)
            st.insert(x);
    }
    vector<ll>v(st.begin(),st.end());
    sort(v.begin(),v.end());
    ll ans=0;
    for(ll x:st)
        ans+=Q/x;
    //printf("%lld\n",st.size());
    printf("%lld\n",ans);
}
```

Q700

```Python
mod = 4503599627370517
a = 1504170715041707
l = r = ans = a
while l > 0:
    nxt = (l + r) % mod
    if nxt < l:
        l = nxt
        ans += l
    else:
        r = nxt
print(ans)
```

Q704

```Python
# A119387
N = 10**16
# 1~N中所有数加起来一共有cnt位
cnt = 0
l = 1
while l <= N:
    r = min(l * 2 - 1, N)
    cnt += (r - l + 1) * len(bin(l)[2:])
    l = r + 1

# cnt1: 1~N中所有数，如果最后x位是以01...1结尾，那么cnt1+=x。
cnt1 = 0
M = len(bin(N)[2:])
for i in range(1, M + 1):
    cnt1 += (N + 2 ** (i - 1) + 1) // (2 ** i) * i - 1
ans = cnt - cnt1
print(ans)
```

Q706

```C++
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=100000;
ll f[N+4][3][3][3][3],mod=1e9+7;
/*
数字串的前缀和为s[0]~s[n]
f[m][i][j][k][l]表示前m+1个值s[0]~s[m]中，有
 s[?]%3==1的个数 % 3 = i
 s[?]%3==2的个数 % 3 = j
 s[m]%3==k
 已经有的非空子串数目 % 3 = l.
 */
void add(ll &x,ll y){
    x=(x+y)%mod;
}

int main(){
    f[1][0][0][0][1] = 3;
    f[1][1][0][1][0] = 3;
    f[1][0][1][2][0] = 3;
    for(int m=1;m<N;m++)
        for(int i=0;i<3;i++)
            for(int j=0;j<3;j++)
                for(int k=0;k<3;k++)
                    for(int l=0;l<3;l++){
                        //0~m中一共有m+1个值。
                        int c0=(m+1-i-j+6)%3;
                        ll &now = f[m][i][j][k][l];
                        if(now == 0)
                            continue;
                        if(k==0){
                            add(f[m+1][i][j][k][(l+c0)%3],now*4); //0,3,6,9
                            add(f[m+1][(i+1)%3][j][(k+1)%3][(l+i)%3],now*3);//1,4,7
                            add(f[m+1][i][(j+1)%3][(k+2)%3][(l+j)%3],now*3);//2,5,8
                        }
                        else if(k==1){
                            add(f[m+1][(i+1)%3][j][k][(l+i)%3],now*4);//0,3,6,9
                            add(f[m+1][i][(j+1)%3][(k+1)%3][(l+j)%3],now*3);// 1,4,7
                            add(f[m+1][i][j][(k+2)%3][(l+c0)%3],now*3);//2,5,8
                        }
                        else{
                            add(f[m+1][i][(j+1)%3][k][(l+j)%3],now*4);//0,3,6,9
                            add(f[m+1][i][j][(k+1)%3][(l+c0)%3],now*3);//1,4,7
                            add(f[m+1][(i+1)%3][j][(k+2)%3][(l+i)%3],now*3);//2,5,8
                        }
                    }
    ll ans=0;
    for(int i=0;i<3;i++)
        for(int j=0;j<3;j++)
            for(int k=0;k<3;k++)
                add(ans,f[N][i][j][k][0]);
    printf("%lld\n",ans);
}

```

Q710

```C++
# include <bits/stdc++.h>
using namespace std;
const int N = 2000004;
int s[N][2],f[N][2],mod=1000000;
int main(){
    f[0][0]=s[0][0]=1;
    f[1][0]=1;s[1][0]=2;
    for(int n=2;n<N;n++){
        f[n][0]=(s[n-1][0]-f[n-2][0]+mod)%mod;
        f[n][1]=(s[n-1][1]+f[n-2][0])%mod;
        s[n][0]=(s[n-1][0]+f[n][0])%mod;
        s[n][1]=(s[n-1][1]+f[n][1])%mod;
        int a=s[n/2][1];
        if(n%2==0) a=(a+f[n/2-1][0])%mod;
        if(n>42&&a%mod==0) {printf("%d\n",n);break;}
    }
}
```

Q713

```Python
# A134546
for N in range(2, 11):
    ans = 0
    for r in range(1, N):
        q, s = divmod(N, r)
        ans += r * q * (q - 1) // 2 + s * q
        print(N, r, r * q * (q - 1) // 2 + s * q)

for n in range(2, 11):
    for k in range(2, n):
        m = n // k
        print(n, k, (n - m) * (n - m - 1) // 2 + (k - 1) * (m + 1) * m // 2)

'''
Fleshing out the explanation - thinking of the N fuses as nodes, after some number of tries we can construct the graph G
 in which two nodes (fuses) are adjacent if and only if they have not been tested together. A strategy is guaranteed to
  succeed if and only if G contains no clique of size m. The optimal strategy minimizes the number of tries, or
  equivalently maximizes the number of edges in G. So we are looking for the graph with the maximum number of edges that
  contains no clique of size m. By Turan's Theorem, this is the Turan graph T(n,m-1). The optimal strategy is then defined
  by partitioning the N nodes into m-1 subsets of as equal size as possible, and testing each pair within each subset.
'''

```

Q719

```C++
# include <bits/stdc++.h>
typedef long long ll;
using namespace std;
ll n=1000000,m;
int a[15],p=0;
bool dfs(int f,ll s,ll w){
    if(s>m||w>m) return 0;
    if(f==p){
        return s+w==m;
    }
    if(dfs(f+1,s+w,a[f])) return 1;
    if(dfs(f+1,s,w*10+a[f])) return 1;
    return 0;
}
int main(){
    ll ans=n*n;
    for(m=4;m<n;m++){
        ll v=m*m;
        p=0;
        for(;v;v/=10) a[p++]=v%10;
        reverse(a,a+p);
        if(dfs(0,0,0)) ans+=m*m;
    }
    printf("%lld\n",ans);
}
```

Q725

```Python
n = 2020
mod = int(1e16)
c = [0 for _ in range(10)]
f = [1]
for _ in range(n):
    f.append((f[-1] * 10 + 1) % mod)
fac = [1]
for i in range(1, 11):
    fac.append(fac[-1] * i)

ans = 0


def cal(d: list, bt: int):
    s = 0
    for j in range(10):
        if d[j] == 0:
            continue
        d[j] -= 1
        val = 1
        for k in range(bt - 1 - d[0]):
            val *= bt - k - 1
        for k in range(1, 10):
            val //= fac[d[k]]
        s += j * val
        d[j] += 1
    return s


def solve(s: int):
    global ans
    d = list(c)
    d[s] += 1
    cnt = sum(d)
    d[0] = n - cnt
    value = cal(d, n)
    ans = (ans + f[n - 1] * value) % mod


def dfs(s: int, nw: int):
    if s > 9:
        return
    c[nw] += 1
    solve(s)
    for j in range(nw, 10):
        dfs(s + j, j)
    c[nw] -= 1


for i in range(1, 10):
    dfs(i, i)
print(ans)
```

Q731

```Python
N = 10 ** 16
'''
模拟除法。
如果需要计算1/k的后面第n位小数，那么就是计算10^(n-1)/k后面的第1位小数。
根据题目要求，这题并不关心除k之后的整数部分。
另外(10^(n-1)%k)/k和10^(n-1)/k的小数部分相同。
'''
f = 0
i = 0
while True:
    if N < 3 ** i + 1:
        break
    f += pow(10, N - 3 ** i - 1, 3 ** i) / 3 ** i
    f -= int(f)
    i += 1
ans = str(f)[2:][:10]
print(ans)

```

Q739

```C++
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const int N = 1e8;
const int M = N*2;
const int n=N-1;
ll mod=1e9+7;
ll inv(ll n,ll p){
    ll ans=1,m=p-2;
    for(;m;m>>=1){
        if(m&1) ans=ans*n%mod;
        n=n*n%mod;
    }
    return ans;
}

int *fac,*finv;
int l[N+4],invn=inv(n,mod);
int C(int n,int m){
    return 1ll*fac[n]*finv[m]%mod*finv[n-m]%mod;
}
int T(int n,int k){
    //A106566
    if(n==0) return 0;
    else return 1ll*C(2*n-k-1,n-k)*k%mod*invn%mod;
}
int main(){
    fac = new int[M+4];
    finv = new int[M+4];
    fac[0]=fac[1]=1;
    finv[0]=1;
    for(int i=2;i<=M;i++)
        fac[i]=1ll*fac[i-1]*i%mod;
    finv[M]=inv(fac[M],mod);
    for(int i=M-1;i>0;i--)
        finv[i]=1ll*finv[i+1]*(i+1)%mod;
    int x=1,y=3;
    int ans=0;
    for(int i=0;i<=n;i++){
        ans=(ans+1ll*T(n,i)*x)%mod;
        int t=(x+y)%mod;
        x=y;y=t;
    }
    delete fac;
    delete finv;
    printf("%d\n",ans);
}
```

Q745

```C++
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=10000004;
int f[N],mod=1e9+7;// Jordan function J_2(n)
int pr[N/4],v[N],m=0;
int main(){
    f[1]=1;
    ll k=1e14;
    ll ans=k;
    int n=sqrt(k);
    for(int i=2;i<=n;i++){
        if(v[i]==0){
            v[i]=i;f[i]=(1ll*i*i-1)%mod;
            pr[++m]=i;
        }
        for(int j=1;j<=m;j++){
            if(pr[j]>v[i]||pr[j]>n/i) break;
            v[i*pr[j]]=pr[j];
            if(pr[j]==v[i]) f[i*pr[j]]=1ll*f[i]*pr[j]*pr[j]%mod;
            else f[i*pr[j]]=1ll*f[i]*(1ll*pr[j]*pr[j]-1)%mod;
        }
        ans=(ans+1ll*f[i]*(k/(1ll*i*i)%mod))%mod;
    }
    printf("%lld\n",ans);
}
```

Q749

```C++
#include <bits/stdc++.h>
# define mem(a,b) memset(a,b,sizeof(a))
typedef long long ll;
using namespace std;
const int N=16;
const ll M=1e16;
const int O=64;
ll pw[14][66];
int c0[10],c1[10];
int n;
vector<ll>a;
bool ok(ll x){
    memcpy(c1,c0,sizeof(c1));
    for(int i=0;i<N;i++,x/=10)
        if(--c1[x%10]<0) return 0;
    return x==0;
}
void dfs(int k,int n,int p,ll s){
    if(p==0){
        c0[0]=n;
        if(ok(s-1))
            a.push_back(s-1);
        if(ok(s+1)) a.push_back(s+1);
        return;
    }
    for(int i=0;i<=n;i++){
        if(pw[p][k]==-1) break;
        c0[p]=i;
        dfs(k,n-i,p-1,s+pw[p][k]*i);
    }
}

int main(){
    mem(pw,-1);
    pw[0][0]=1;
    for(int j=1;j<O;j++)
        pw[0][j]=0;
    for(int i=0;i<10;i++){
        pw[i][0]=1;
        for(int j=1;j<O;j++){
            pw[i][j]=pw[i][j-1]*i;
            if(i>0&&pw[i][j]>M/i) break;
        }
    }
    for(int k=2;k<=N;k++)
        dfs(k,N,9,0);
    ll ans=0;
    sort(a.begin(),a.end());
    for(ll x:a)
        ans+=x;
    printf("%lld\n",ans);
}

```

Q751

```Python
l, r, n = 2, 3, 30
for _ in range(100):
    theta = 0.5 * (l + r)
    b = [theta]
    a = [int(theta)]
    for i in range(n):
        b.append(int(b[-1]) * (b[-1] - int(b[-1]) + 1))
        a.append(int(b[-1]))
    tau = str(a[0]) + "."
    for i in range(1, n):
        tau += str(a[i])
    tau = float(tau)
    if tau < theta:
        r = theta
    else:
        l = theta
print("{}.".format(a[0]) + "".join(str(x) for x in a[1:])[:24])
```

Q754

```C++
# include <bits/stdc++.h>
using namespace std;
const int N=10002,M=100000000;
bool b[N];
int a[2004],p=0;
int pr[N],q=0;
int mod=1000000007;
int qpow(int n,int m){
    int ans=1;
    for(;m;m>>=1){
        if(m&1) ans=1ll*ans*n%mod;
        n=1ll*n*n%mod;
    }
    return ans;
}
void fact(int x){
    p=0;
    for(int i=1;i<=q&&pr[i]*pr[i]<=x;++i){
        if(x%pr[i]==0){
            a[p++]=pr[i];
            for(;x%pr[i]==0;x/=pr[i]);
        }
    }
    if(x!=1) a[p++]=x;
}
int main(){
    for(int i=2;i<N;++i){
        if(b[i]) continue;
        pr[++q]=i;
        for(int j=i*i;j<N;j+=i)
            b[j]=1;
    }
    int ans=1;
    for(int i=2;i<=M;i++){
         fact(i);
         int s=0;
         for(int st=0;st<(1<<p);st++){
             int m=1,c=0;
             for(int i=0;i<p;i++)
                if(st>>i&1) m*=a[i],++c;
             if(c&1) s-=(M-i)/m;
             else s+=(M-i)/m;
         }
         ans=1ll*ans*qpow(i,s)%mod;
    }
    printf("%d\n",ans);
}

```

Q755

```Python
f = [1, 2]
s = [1, 3]
N = 10 ** 13
for i in range(100):
    w = f[-1] + f[-2]
    if w > N:
        break
    f.append(w)
    s.append(s[-1] + w)


def dfs(fl: int, now: int):
    if now < 0:
        return 0
    if fl == -1:
        return 1
    elif s[fl] <= now:
        return 1 << (fl + 1)
    else:
        return dfs(fl - 1, now) + dfs(fl - 1, now - f[fl])


print(dfs(len(f) - 1, N))
```

Q757

```Python
N = 10**14
lm2 = int(N ** 0.5 + 2)
lm4 = int(N ** 0.25 + 2)
st = set()
for dis in range(1, lm4):
    for mid in range(dis, lm2):
        u = mid * dis
        if u > lm2:
            break
        v, a, b = u - dis, mid + u - dis - 1, mid + u
        n = a * u
        if n > N:
            break
        if n == b * v:
            st.add(n)
print(len(st)-1)
```

Q788

```Python
N = 2022
mod = 10 ** 9 + 7
C = [[0 for i in range(j + 1)] for j in range(N + 1)]
for i in range(N + 1):
    C[i][0] = C[i][i] = 1
    for j in range(1, i):
        C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod
ans = 0
for n in range(1, N + 1):
    ans += 9
    for i in range(n // 2 + 1, n):
        ans = (ans + 9 * C[n - 1][i - 1] * pow(9, n - i, mod) + 9 * C[n - 1][i] * pow(9, n - i, mod)) % mod
print(ans)
```

Q793

```C++
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const int N=1000003;
ll S[N+4],m=(1ll*N*(N-1)/2+1)>>1;
bool ok(ll x){
    ll ans=0;
    for(int i=0;i<N;i++){
        ll w=x/S[i];
        int p=upper_bound(S,S+N,w)-S;
        if(p<=i) break;
        ans+=p-i-1;
    }
    return ans>=m;
}
int main(){
    S[0]=290797;
    for(int i=1;i<N;i++)
        S[i]=S[i-1]*S[i-1]%50515093;
    sort(S,S+N);
    ll l=1,r=1e17;
    while(l<r){
        ll mid=(l+r)>>1;
        if(ok(mid)) r=mid;
        else l=mid+1;
    }
    printf("%lld\n",l);
}

```
