Q561

```Python
# E(m,n)=((n+1)(n+2)/2)^m-(n+1)^m，对式子提公因式(n+1)^m，然后进行判定。

Q = 10 ** 12
M = 904961


def cal(n: int):
    cnt = 0
    M = len(bin(n)[2:])
    for i in range(1, M + 1):
        cnt += (n + 2 ** (i - 1)) // (2 ** i) * i
    return cnt


c0 = Q // 4
c3 = (Q + 1) // 4
ans = cal(c3) * M
if M % 2 == 0:
    tp = cal(c3 >> 1) + cal((c3 + 1) >> 1)
    v = bin(M)[::-1].find('1')
    tp += c0 * (v + 1)
    ans += tp
else:
    ans += cal(c0)
print(ans)
```

Q577

```Python
N = 12345
ans = 0
for n in range(N-2):
    ans += Fraction(1, 216) * n ** 4 + Fraction(1, 12) * n ** 3 + Fraction(37, 72) * n ** 2 + [Fraction(5, 4), Fraction(139, 108), Fraction(131, 108)][n % 3] * n + [1, Fraction(10, 9), Fraction(7, 9)][n % 3]
print(ans)
# A011779
```

Q581

```C++
# include <bits/stdc++.h>
using namespace std;
const int M=47;
int pr[M+4],m=0,b[M+4];
typedef long long ll;
int main(){
    ll N=2e12;
    for(int i=2;i<=M;i++){
        if(b[i]) continue;
        pr[++m]=i;
        for(int j=i+i;j<=M;j+=i)
            b[j]=1;
    }
    priority_queue<ll,vector<ll>,greater<ll>>q;
    q.push(1);
    ll ans=0,pre=1;
    while(!q.empty()){
        ll u=q.top();q.pop();
        if(u==pre+1){
            ans+=pre;
        }
        pre=u;
        for(int i=1;i<=m;i++){
            ll v=u*pr[i];
            if(v>N) break;
            q.push(v);
            if(u%pr[i]==0) break;
        }
    }
    printf("%lld\n",ans);
}

```

Q622

```Python
Q = 60
R = 2 ** Q - 1
ls = Get_Divisors(R)
ans = 0
for d in ls:
    p = 1
    while p <= Q:
        if quick_power(2, p, d) == 1:
            break
        p += 1
    if p == Q:
        ans += d+1
print(ans)
'''
原问题等价于求2模n-1的阶数r。其中有多少个r的值为60。
'''
```

Q630

```C++
# include <bits/stdc++.h>
# define pi pair<int,int>
using namespace std;
typedef long long ll;
const int N=2500;
int S[N*2+4],T[N*2+4];
ll solve(vector<pi>&v){
    map<pi,unordered_set<double>>mp;
    sort(v.begin(),v.end());
    v.resize(unique(v.begin(),v.end())-v.begin());
    int x1,y1,x2,y2;
    for(int i=0;i<v.size();i++)
    for(int j=0;j<i;j++){
        tie(x1,y1)=v[i];
        tie(x2,y2)=v[j];
        int x=x2-x1,y=y1-y2;
        double z=x1*y2-x2*y1;
        int g=__gcd(x,y);
        x/=g;y/=g;z/=g;
        if(x<0||x==0&&y<0){
            x=-x;y=-y;z=-z;
        }
        mp[pi(x,y)].insert(z);
    }
    int m=0;
    for(auto &[k,st]:mp)
        m+=st.size();
    ll ans=0;
    for(auto &[k,st]:mp)
        ans+=1ll*st.size()*(m-st.size());
    return ans;
}
int main(){
    S[0]=290797;
    for(int i=1;i<=N*2;i++){
        S[i]=1ll*S[i-1]*S[i-1]%50515093;
        T[i]=S[i]%2000-1000;
    }
    vector<pi>v;
    for(int i=2;i<=N*2;i+=2)
        v.push_back(pi(T[i-1],T[i]));
    printf("%lld\n",solve(v));
}

```

Q686

```Python
i, c = 1, 0
lg = log10(2)

lt = [196, 289, 485]
l, r = log10(1.23), log10(1.24)
pre = 0
i = 90
c = 2
s = lg * i
while c < 678910:
    j = 0
    while j < 3:
        ns = s + lg * lt[j]
        if l <= ns - int(ns) < r:
            break
        j += 1
    if j == 4:
        print("FAIL")
        exit()
    s += lg * lt[j]
    i += lt[j]
    c += 1
print(i)
```

Q688

```C++
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const ll Q=1e16;
ll mod=1e9+7;
ll inv2=(mod+1)>>1;
int main(){
    ll ans=0;
    for(ll k=1;;k++){
        ll w=k*(k+1)/2;
        if(w>Q) break;
        ll t=Q-w;
        ll block=(t+1)/k%mod,res=(t+1)%k%mod;
        ans=(ans+k*block%mod*(block+1)%mod*inv2%mod+(block+1)*res%mod)%mod;
    }
    printf("%lld\n",ans);
}
```

Q692

```Python
import bisect
# Zeckendorf's theorem
f = [1, 2]
for i in range(100):
    f.append(f[-1] + f[-2])
G = {1: 1, 2: 3}


def getG(n: int):
    if n in G.keys():
        return G[n]
    p = bisect.bisect_right(f, n) - 1
    if f[p] == n:
        G[n] = getG(f[p - 2]) + getG(f[p - 1]) + f[p] - f[p - 2]
    else:
        G[n] = getG(f[p]) + getG(n - f[p])
    return G[n]


print(getG(23416728348467685))
```

Q694

```C++
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const ll Q=1e18;
const int M=pow(Q,1.0/3);
bool b[M+4];
int pr[M/3+100],m=0;
int main(){
    for(int i=2;i<=M;i++){
        if(b[i]) continue;
        pr[++m]=i;
        for(ll j=1ll*i*i;j<=M;j+=i)
            b[j]=1;
    }
    set<ll>st;
    unordered_set<ll>st2;
    st.insert(1);
    for(int i=1;i<=m;i++){
        st2.clear();
        for(ll x:st){
            int cnt=0;
            while(x<=Q/pr[i]){
                x*=pr[i];
                if(++cnt>=3)
                    st2.insert(x);
            }
            if(cnt<3) break;
        }
        for(ll x:st2)
            st.insert(x);
    }
    vector<ll>v(st.begin(),st.end());
    sort(v.begin(),v.end());
    ll ans=0;
    for(ll x:st)
        ans+=Q/x;
    //printf("%lld\n",st.size());
    printf("%lld\n",ans);
}
```

Q700

```Python
mod = 4503599627370517
a = 1504170715041707
l = r = ans = a
while l > 0:
    nxt = (l + r) % mod
    if nxt < l:
        l = nxt
        ans += l
    else:
        r = nxt
print(ans)
```

Q704

```Python
# A119387
N = 10**16
# 1~N中所有数加起来一共有cnt位
cnt = 0
l = 1
while l <= N:
    r = min(l * 2 - 1, N)
    cnt += (r - l + 1) * len(bin(l)[2:])
    l = r + 1

# cnt1: 1~N中所有数，如果最后x位是以01...1结尾，那么cnt1+=x。
cnt1 = 0
M = len(bin(N)[2:])
for i in range(1, M + 1):
    cnt1 += (N + 2 ** (i - 1) + 1) // (2 ** i) * i - 1
ans = cnt - cnt1
print(ans)
```

Q706

```C++
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=100000;
ll f[N+4][3][3][3][3],mod=1e9+7;
/*
数字串的前缀和为s[0]~s[n]
f[m][i][j][k][l]表示前m+1个值s[0]~s[m]中，有
 s[?]%3==1的个数 % 3 = i
 s[?]%3==2的个数 % 3 = j
 s[m]%3==k
 已经有的非空子串数目 % 3 = l.
 */
void add(ll &x,ll y){
    x=(x+y)%mod;
}

int main(){
    f[1][0][0][0][1] = 3;
    f[1][1][0][1][0] = 3;
    f[1][0][1][2][0] = 3;
    for(int m=1;m<N;m++)
        for(int i=0;i<3;i++)
            for(int j=0;j<3;j++)
                for(int k=0;k<3;k++)
                    for(int l=0;l<3;l++){
                        //0~m中一共有m+1个值。
                        int c0=(m+1-i-j+6)%3;
                        ll &now = f[m][i][j][k][l];
                        if(now == 0)
                            continue;
                        if(k==0){
                            add(f[m+1][i][j][k][(l+c0)%3],now*4); //0,3,6,9
                            add(f[m+1][(i+1)%3][j][(k+1)%3][(l+i)%3],now*3);//1,4,7
                            add(f[m+1][i][(j+1)%3][(k+2)%3][(l+j)%3],now*3);//2,5,8
                        }
                        else if(k==1){
                            add(f[m+1][(i+1)%3][j][k][(l+i)%3],now*4);//0,3,6,9
                            add(f[m+1][i][(j+1)%3][(k+1)%3][(l+j)%3],now*3);// 1,4,7
                            add(f[m+1][i][j][(k+2)%3][(l+c0)%3],now*3);//2,5,8
                        }
                        else{
                            add(f[m+1][i][(j+1)%3][k][(l+j)%3],now*4);//0,3,6,9
                            add(f[m+1][i][j][(k+1)%3][(l+c0)%3],now*3);//1,4,7
                            add(f[m+1][(i+1)%3][j][(k+2)%3][(l+i)%3],now*3);//2,5,8
                        }
                    }
    ll ans=0;
    for(int i=0;i<3;i++)
        for(int j=0;j<3;j++)
            for(int k=0;k<3;k++)
                add(ans,f[N][i][j][k][0]);
    printf("%lld\n",ans);
}

```

Q710

```C++
# include <bits/stdc++.h>
using namespace std;
const int N = 2000004;
int s[N][2],f[N][2],mod=1000000;
int main(){
    f[0][0]=s[0][0]=1;
    f[1][0]=1;s[1][0]=2;
    for(int n=2;n<N;n++){
        f[n][0]=(s[n-1][0]-f[n-2][0]+mod)%mod;
        f[n][1]=(s[n-1][1]+f[n-2][0])%mod;
        s[n][0]=(s[n-1][0]+f[n][0])%mod;
        s[n][1]=(s[n-1][1]+f[n][1])%mod;
        int a=s[n/2][1];
        if(n%2==0) a=(a+f[n/2-1][0])%mod;
        if(n>42&&a%mod==0) {printf("%d\n",n);break;}
    }
}
```

Q713

```Python
# A134546
for N in range(2, 11):
    ans = 0
    for r in range(1, N):
        q, s = divmod(N, r)
        ans += r * q * (q - 1) // 2 + s * q
        print(N, r, r * q * (q - 1) // 2 + s * q)

for n in range(2, 11):
    for k in range(2, n):
        m = n // k
        print(n, k, (n - m) * (n - m - 1) // 2 + (k - 1) * (m + 1) * m // 2)

'''
Fleshing out the explanation - thinking of the N fuses as nodes, after some number of tries we can construct the graph G
 in which two nodes (fuses) are adjacent if and only if they have not been tested together. A strategy is guaranteed to
  succeed if and only if G contains no clique of size m. The optimal strategy minimizes the number of tries, or
  equivalently maximizes the number of edges in G. So we are looking for the graph with the maximum number of edges that
  contains no clique of size m. By Turan's Theorem, this is the Turan graph T(n,m-1). The optimal strategy is then defined
  by partitioning the N nodes into m-1 subsets of as equal size as possible, and testing each pair within each subset.
'''

```

Q719

```C++
# include <bits/stdc++.h>
typedef long long ll;
using namespace std;
ll n=1000000,m;
int a[15],p=0;
bool dfs(int f,ll s,ll w){
    if(s>m||w>m) return 0;
    if(f==p){
        return s+w==m;
    }
    if(dfs(f+1,s+w,a[f])) return 1;
    if(dfs(f+1,s,w*10+a[f])) return 1;
    return 0;
}
int main(){
    ll ans=n*n;
    for(m=4;m<n;m++){
        ll v=m*m;
        p=0;
        for(;v;v/=10) a[p++]=v%10;
        reverse(a,a+p);
        if(dfs(0,0,0)) ans+=m*m;
    }
    printf("%lld\n",ans);
}
```

Q725

```Python
n = 2020
mod = int(1e16)
c = [0 for _ in range(10)]
f = [1]
for _ in range(n):
    f.append((f[-1] * 10 + 1) % mod)
fac = [1]
for i in range(1, 11):
    fac.append(fac[-1] * i)

ans = 0


def cal(d: list, bt: int):
    s = 0
    for j in range(10):
        if d[j] == 0:
            continue
        d[j] -= 1
        val = 1
        for k in range(bt - 1 - d[0]):
            val *= bt - k - 1
        for k in range(1, 10):
            val //= fac[d[k]]
        s += j * val
        d[j] += 1
    return s


def solve(s: int):
    global ans
    d = list(c)
    d[s] += 1
    cnt = sum(d)
    d[0] = n - cnt
    value = cal(d, n)
    ans = (ans + f[n - 1] * value) % mod


def dfs(s: int, nw: int):
    if s > 9:
        return
    c[nw] += 1
    solve(s)
    for j in range(nw, 10):
        dfs(s + j, j)
    c[nw] -= 1


for i in range(1, 10):
    dfs(i, i)
print(ans)
```

Q731

```Python
N = 10 ** 16
'''
模拟除法。
如果需要计算1/k的后面第n位小数，那么就是计算10^(n-1)/k后面的第1位小数。
根据题目要求，这题并不关心除k之后的整数部分。
另外(10^(n-1)%k)/k和10^(n-1)/k的小数部分相同。
'''
f = 0
i = 0
while True:
    if N < 3 ** i + 1:
        break
    f += pow(10, N - 3 ** i - 1, 3 ** i) / 3 ** i
    f -= int(f)
    i += 1
ans = str(f)[2:][:10]
print(ans)

```

Q739

```C++
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const int N = 1e8;
const int M = N*2;
const int n=N-1;
ll mod=1e9+7;
ll inv(ll n,ll p){
    ll ans=1,m=p-2;
    for(;m;m>>=1){
        if(m&1) ans=ans*n%mod;
        n=n*n%mod;
    }
    return ans;
}

int *fac,*finv;
int l[N+4],invn=inv(n,mod);
int C(int n,int m){
    return 1ll*fac[n]*finv[m]%mod*finv[n-m]%mod;
}
int T(int n,int k){
    //A106566
    if(n==0) return 0;
    else return 1ll*C(2*n-k-1,n-k)*k%mod*invn%mod;
}
int main(){
    fac = new int[M+4];
    finv = new int[M+4];
    fac[0]=fac[1]=1;
    finv[0]=1;
    for(int i=2;i<=M;i++)
        fac[i]=1ll*fac[i-1]*i%mod;
    finv[M]=inv(fac[M],mod);
    for(int i=M-1;i>0;i--)
        finv[i]=1ll*finv[i+1]*(i+1)%mod;
    int x=1,y=3;
    int ans=0;
    for(int i=0;i<=n;i++){
        ans=(ans+1ll*T(n,i)*x)%mod;
        int t=(x+y)%mod;
        x=y;y=t;
    }
    delete fac;
    delete finv;
    printf("%d\n",ans);
}
```

Q745

```C++
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=10000004;
int f[N],mod=1e9+7;// Jordan function J_2(n)
int pr[N/4],v[N],m=0;
int main(){
    f[1]=1;
    ll k=1e14;
    ll ans=k;
    int n=sqrt(k);
    for(int i=2;i<=n;i++){
        if(v[i]==0){
            v[i]=i;f[i]=(1ll*i*i-1)%mod;
            pr[++m]=i;
        }
        for(int j=1;j<=m;j++){
            if(pr[j]>v[i]||pr[j]>n/i) break;
            v[i*pr[j]]=pr[j];
            if(pr[j]==v[i]) f[i*pr[j]]=1ll*f[i]*pr[j]*pr[j]%mod;
            else f[i*pr[j]]=1ll*f[i]*(1ll*pr[j]*pr[j]-1)%mod;
        }
        ans=(ans+1ll*f[i]*(k/(1ll*i*i)%mod))%mod;
    }
    printf("%lld\n",ans);
}
```

Q749

```C++
#include <bits/stdc++.h>
# define mem(a,b) memset(a,b,sizeof(a))
typedef long long ll;
using namespace std;
const int N=16;
const ll M=1e16;
const int O=64;
ll pw[14][66];
int c0[10],c1[10];
int n;
vector<ll>a;
bool ok(ll x){
    memcpy(c1,c0,sizeof(c1));
    for(int i=0;i<N;i++,x/=10)
        if(--c1[x%10]<0) return 0;
    return x==0;
}
void dfs(int k,int n,int p,ll s){
    if(p==0){
        c0[0]=n;
        if(ok(s-1))
            a.push_back(s-1);
        if(ok(s+1)) a.push_back(s+1);
        return;
    }
    for(int i=0;i<=n;i++){
        if(pw[p][k]==-1) break;
        c0[p]=i;
        dfs(k,n-i,p-1,s+pw[p][k]*i);
    }
}

int main(){
    mem(pw,-1);
    pw[0][0]=1;
    for(int j=1;j<O;j++)
        pw[0][j]=0;
    for(int i=0;i<10;i++){
        pw[i][0]=1;
        for(int j=1;j<O;j++){
            pw[i][j]=pw[i][j-1]*i;
            if(i>0&&pw[i][j]>M/i) break;
        }
    }
    for(int k=2;k<=N;k++)
        dfs(k,N,9,0);
    ll ans=0;
    sort(a.begin(),a.end());
    for(ll x:a)
        ans+=x;
    printf("%lld\n",ans);
}

```

Q751

```Python
l, r, n = 2, 3, 30
for _ in range(100):
    theta = 0.5 * (l + r)
    b = [theta]
    a = [int(theta)]
    for i in range(n):
        b.append(int(b[-1]) * (b[-1] - int(b[-1]) + 1))
        a.append(int(b[-1]))
    tau = str(a[0]) + "."
    for i in range(1, n):
        tau += str(a[i])
    tau = float(tau)
    if tau < theta:
        r = theta
    else:
        l = theta
print("{}.".format(a[0]) + "".join(str(x) for x in a[1:])[:24])
```

Q754

```C++
# include <bits/stdc++.h>
using namespace std;
const int N=10002,M=100000000;
bool b[N];
int a[2004],p=0;
int pr[N],q=0;
int mod=1000000007;
int qpow(int n,int m){
    int ans=1;
    for(;m;m>>=1){
        if(m&1) ans=1ll*ans*n%mod;
        n=1ll*n*n%mod;
    }
    return ans;
}
void fact(int x){
    p=0;
    for(int i=1;i<=q&&pr[i]*pr[i]<=x;++i){
        if(x%pr[i]==0){
            a[p++]=pr[i];
            for(;x%pr[i]==0;x/=pr[i]);
        }
    }
    if(x!=1) a[p++]=x;
}
int main(){
    for(int i=2;i<N;++i){
        if(b[i]) continue;
        pr[++q]=i;
        for(int j=i*i;j<N;j+=i)
            b[j]=1;
    }
    int ans=1;
    for(int i=2;i<=M;i++){
         fact(i);
         int s=0;
         for(int st=0;st<(1<<p);st++){
             int m=1,c=0;
             for(int i=0;i<p;i++)
                if(st>>i&1) m*=a[i],++c;
             if(c&1) s-=(M-i)/m;
             else s+=(M-i)/m;
         }
         ans=1ll*ans*qpow(i,s)%mod;
    }
    printf("%d\n",ans);
}

```

Q755

```Python
f = [1, 2]
s = [1, 3]
N = 10 ** 13
for i in range(100):
    w = f[-1] + f[-2]
    if w > N:
        break
    f.append(w)
    s.append(s[-1] + w)


def dfs(fl: int, now: int):
    if now < 0:
        return 0
    if fl == -1:
        return 1
    elif s[fl] <= now:
        return 1 << (fl + 1)
    else:
        return dfs(fl - 1, now) + dfs(fl - 1, now - f[fl])


print(dfs(len(f) - 1, N))
```

Q757

```Python
N = 10**14
lm2 = int(N ** 0.5 + 2)
lm4 = int(N ** 0.25 + 2)
st = set()
for dis in range(1, lm4):
    for mid in range(dis, lm2):
        u = mid * dis
        if u > lm2:
            break
        v, a, b = u - dis, mid + u - dis - 1, mid + u
        n = a * u
        if n > N:
            break
        if n == b * v:
            st.add(n)
print(len(st)-1)
```

Q788

```Python
N = 2022
mod = 10 ** 9 + 7
C = [[0 for i in range(j + 1)] for j in range(N + 1)]
for i in range(N + 1):
    C[i][0] = C[i][i] = 1
    for j in range(1, i):
        C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod
ans = 0
for n in range(1, N + 1):
    ans += 9
    for i in range(n // 2 + 1, n):
        ans = (ans + 9 * C[n - 1][i - 1] * pow(9, n - i, mod) + 9 * C[n - 1][i] * pow(9, n - i, mod)) % mod
print(ans)
```

Q793

```C++
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const int N=1000003;
ll S[N+4],m=(1ll*N*(N-1)/2+1)>>1;
bool ok(ll x){
    ll ans=0;
    for(int i=0;i<N;i++){
        ll w=x/S[i];
        int p=upper_bound(S,S+N,w)-S;
        if(p<=i) break;
        ans+=p-i-1;
    }
    return ans>=m;
}
int main(){
    S[0]=290797;
    for(int i=1;i<N;i++)
        S[i]=S[i-1]*S[i-1]%50515093;
    sort(S,S+N);
    ll l=1,r=1e17;
    while(l<r){
        ll mid=(l+r)>>1;
        if(ok(mid)) r=mid;
        else l=mid+1;
    }
    printf("%lld\n",l);
}

```
