Q239

```Python
N = 100
n = 25  # 一共25个质数
m = 22
C = [[0 for x in range(y + 1)] for y in range(N + 1)]
for i in range(N + 1):
    C[i][0] = C[i][i] = 1
    for j in range(1, i):
        C[i][j] = C[i - 1][j - 1] + C[i - 1][j]
fac = [1]
for i in range(1, N + 1):
    fac.append(fac[-1] * i)
f = [[0 for x in range(y + 1)] for y in range(m + 1)]  # A047920
for i in range(m + 1):
    f[i][0] = fac[i]
    for j in range(1, i + 1):
        f[i][j] = f[i][j - 1] - f[i - 1][j - 1]
mul = C[n][n - m]
ans = 0
for i in range(m + 1):
    ans += C[m][i] * C[N - n][m - i] * fac[N - n] * f[m][i] * mul
print("{:.12f}".format(ans / fac[N]))
```

Q240

```Python
from collections import Counter

N = 20
M = 12
C = 10
S = 70
MX = S // C
al = [0 for i in range(N - C)]
ar = [0 for i in range(C)]
ls = [[] for i in range(M + 1)]
fac = [1]
for i in range(1, N + 1):
    fac.append(fac[-1] * i)
ans = 0


def cal(a: list):
    s = fac[N]
    mp = Counter(a)
    for x in mp.values():
        s //= fac[x]
    return s


def dfs1(f: int, pre: int):
    if f == N - C:
        ls[al[-1]].append(al.copy())
        return
    for i in range(pre, MX + 1):
        al[f] = i
        dfs1(f + 1, i)


def dfs2(f: int, pre: int, now: int):
    if now < C - f or now > M * (C - f):
        return
    if f == C:
        global ans
        for i in range(1, ar[0] + 1):
            for v in ls[i]:
                ans += cal(v + ar)
        return
    for i in range(pre, M + 1):
        ar[f] = i
        dfs2(f + 1, i, now - i)


dfs1(0, 1)
dfs2(0, 1, S)
print(ans)
```

Q242

```Python
# 观察f[i][j]三角形易得出答案。
N = 10 ** 12
N = (N - 1) // 4 + 1
s = bin(N)[2:]
s = s[::-1]
l = len(s)
C = [[0 for x in range(y + 1)] for y in range(l + 1)]
for i in range(l + 1):
    C[i][0] = C[i][i] = 1
    for j in range(1, i):
        C[i][j] = C[i - 1][j - 1] + C[i - 1][j]
cnt = [0 for i in range(l + 1)]
now = 0
for i in range(l - 1, -1, -1):
    if s[i] == '1':
        for j in range(i + 1):
            cnt[now + j] += C[i][j]
        now += 1
ans = 0
for i in range(l+1):
    ans += cnt[i]*2**i
print(ans)
```

Q244

```Python
from queue import Queue


def encode(a: list):
    ans = 0
    for i in range(4):
        for j in range(4):
            ans = ans * 3 + a[i][j]
    return ans


dis = {}
val = {}
mod = 100000007
dx = [0, 0, -1, 1]
dy = [-1, 1, 0, 0]
code = [82, 76, 68, 85]
st = [[0, 1, 2, 2], [1, 1, 2, 2], [1, 1, 2, 2], [1, 1, 2, 2]]
ed = [[0, 2, 1, 2], [2, 1, 2, 1], [1, 2, 1, 2], [2, 1, 2, 1]]
dis[encode(st)] = 0
val[encode(st)] = [0]
q = Queue()
q.put(st)
while not q.empty():
    u = q.get()
    pre = encode(u)
    for i in range(16):
        if u[i >> 2][i & 3] == 0:
            x, y = i >> 2, i & 3
            break
    for k in range(4):
        nx, ny = x + dx[k], y + dy[k]
        if nx < 0 or ny < 0 or nx >= 4 or ny >= 4:
            continue
        v = [a.copy() for a in u]
        v[nx][ny], v[x][y] = v[x][y], v[nx][ny]
        now = encode(v)
        if now not in dis.keys():
            dis[now] = dis[pre] + 1
            val[now] = []
            q.put(v)
        if dis[now] == dis[pre] + 1:
            for w in val[pre]:
                val[now].append((w * 243 + code[k]) % mod)
print(sum(val[encode(ed)]))
```

Q252

```Python
N = 500


class V:
    def __init__(self, x: int, y: int):
        self.x, self.y = x, y

    def __add__(self, other):
        return V(self.x + other.x, self.y + other.y)

    def __sub__(self, other):
        return V(self.x - other.x, self.y - other.y)

    def __mul__(self, other):
        return self.x * other.y - self.y * other.x

    def __str__(self):
        return "({}, {})".format(self.x, self.y)

    def __lt__(self, other):
        return atan2(self.y, self.x) < atan2(other.y, other.x)


S = [290797]
T = []
ans = 0


def solve(p: list):
    m = len(p)
    p.sort()
    global ans
    dp = [[0 for j in range(m)] for i in range(m)]
    for i in range(m):
        j = i - 1
        while j >= 0 and p[i] * p[j] == 0:
            j -= 1
        flag = (j == i - 1)
        while j >= 0:
            k = j - 1
            while k >= 0 and (p[i] - p[k]) * (p[j] - p[k]) > 0:
                k -= 1
            s = abs(p[i] * p[j])
            if k >= 0:
                s += dp[j][k]
            if flag:
                dp[i][j] = s
            ans = max(ans, s)
            j = k
        if flag:
            for j in range(1, i):
                dp[i][j] = max(dp[i][j], dp[i][j - 1])


for i in range(N + N):
    S.append(S[-1] * S[-1] % 50515093)
for x in S:
    T.append(x % 2000 - 1000)
pts = []
for i in range(2, N + N + 1, 2):
    pts.append(V(T[i - 1], T[i]))
for p in pts:
    ls = []
    for q in pts:
        if q.y > p.y or q.y == p.y and q.x > p.x:
            ls.append(q - p)
    solve(ls)
print(ans / 2)
'''
枚举每个点，作为原点O。把在点O下面或在O点的正左向的所有点抛弃。
dp[i][j]表示最后一个三角形为Oij
(i>j)的点。那么满足dp[i][j]=\max(dp[j][k]+三角形Oij的面积)，其中k只能在向量ij的右侧以保证这个多边形是凸的。
对于j0=i-1，三角形Oij0一定是个合法的三角形，如果O,i,j0三点共线，那么顺时针找j0，找到第一个与Oi不共线为止。
然后找最大的j1，使得j1在向量ij0右侧，此时经排序后三角形ij0j1中不包含任何点。故有转移dp[i][j0]=max(dp[i][j0],dp[i][j1]+三角形Oij1的面积)。这将可以进行快速转移。并且，不合法的Oij的值最终为0。并且，j1之前的点都可以由此转移而来。
设g[i][j]=max(dp[i][k],1<=k<=j), 因此dp[i][j0]=g[j0][j1]+三角形Oij0的面积。
'''
```

Q253

```Python
N = 40
M = (N + 1) >> 1
mp = [[{} for j in range(M + 1)] for i in range(N + 1)]


def insert(i: int, j: int, mq: dict, suf: list, val: int):
    if suf[0] > suf[1]:
        suf[0], suf[1] = suf[1], suf[0]
    ls = []
    for u, v in mq.items():
        if v > 0:
            ls.append((u, v))
    ls.sort()
    ls = tuple(ls)
    lt = (ls, tuple(suf))
    if lt not in mp[i][j].keys():
        mp[i][j][lt] = 0
    mp[i][j][lt] += val


for i in range(1, N + 1):
    insert(1, 1, {}, [i - 1, N - i], 1)
for i in range(1, N):
    for j in range(1, M + 1):
        for tup, val in mp[i][j].items():
            tp = {}
            for x, y in tup[0]:
                tp[x] = y
            for x, y in tup[0]:
                for k in range(1, x + 1):
                    tq = tp.copy()
                    if k > 1:
                        if k - 1 not in tq.keys():
                            tq[k - 1] = 0
                        tq[k - 1] += 1
                    if k < x:
                        if x - k not in tq.keys():
                            tq[x - k] = 0
                        tq[x - k] += 1
                    tq[x] -= 1
                    s = max(j, sum(tq.values()) + 1)
                    insert(i + 1, s, tq, [tup[1][0], tup[1][1]], val * y)
            suf = tup[1]
            for r in range(2):
                for k in range(1, suf[r] + 1):
                    tq = tp.copy()
                    if k > 1:
                        if k - 1 not in tq.keys():
                            tq[k - 1] = 0
                        tq[k - 1] += 1
                    s = max(j, sum(tq.values()) + 1)
                    if r == 0:
                        insert(i + 1, s, tq, [suf[0] - k, suf[1]], val)
                    else:
                        insert(i + 1, s, tq, [suf[0], suf[1] - k], val)
s0 = s1 = 0
for i in range(1, M + 1):
    v = mp[N][i][((), (0, 0))]
    s0 += i * v
    s1 += v
print("{:.6f}".format(s0 / s1))
```

Q254

```C++
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int Q=150,B=19,S=9,MX=1e7;
const int W=362880,N=63;
ll pw[B],fac[B];
int dcnt[W][S],sd[W],cd[W];
int lq[N],pq[N][S];
bool ok(int a[],int b[]) {
    for (int i = 0; i < S; i++)
        if (a[i] != b[i]) return a[i] < b[i];
    return 0;
}
int main() {
    pw[0] = fac[0] = 1;
    for (int i = 1; i < B; i++)
        pw[i] = pw[i - 1] * 10, fac[i] = fac[i - 1] * i;
    // 每个数i，贪心取最大的值，尽量取完，然后再取最小的。dcnt[i][j]表示从i中分出dcnt[i][j]个fac[j]。
    // sd[i]= sum j=1^9 dcnt[i][j]*j, cd[i]表示i分出来的最少份数。
    for (int i = 0; i < W; i++) {
        for (int j = 8, t = i; j > 0; j--) {
            dcnt[i][j] = t / fac[j];
            sd[i] += dcnt[i][j] * j;
            cd[i] += dcnt[i][j];
            t %= fac[j];
        }
    }
    //1~62时直接暴力枚举。枚举范围是10^7。
    for (int r = 0; r <= MX; r++) {
        int a = r / W, b = r % W;
        int s = 0;
        for (int x = r; x; x /= 10)
            s += x % 10;
        if (s >= N) continue;
        if (lq[s] == 0 || lq[s] > cd[b] + a || lq[s] == cd[b] + a && ok(pq[s], dcnt[b])) {
            lq[s] = cd[b] + a;
            for (int i = 0; i < S; i++)
                pq[s][i] = dcnt[b][i];

        }
    }
    ll ans = 0;
    for (int i = 1; i <= Q && i < N; i++) {
        ans += lq[i] * 9;
        for (int j = 1; j < S; j++)
            ans -= pq[i][j] * (9 - j);
    }
    //63以后全部贪心取9。
    for (int i = N; i <= Q; i++) {
        long long t = (i % 9 + 1) * pw[i / 9] - 1;
        ans += (t / W) * 9 + sd[t % W];
    }
    printf("%lld\n", ans);
}
```

Q260

```C++
#include <bits/stdc++.h>
const int N = 1000;

bool P1[N+1][N+1];
bool P2[N+1][N+1];
bool P3[N+1][N+1];
/*
当前是必败态，那么后继的都是必胜态。假设在每一堆中取的是s个石头。
用P1[y-x][z-y]表示后继状态{x-s,y-s,z-s}
P2[x][y-x]表示{x,y-s,z-s}
P2[y][z-x]表示{x-s,y,z-s}
P2[z][y-x]表示{x-s,y-s,z}
P3[x][y]表示{x,y,z-s}
P3[x][z]表示{x,y-s,z}
P3[y][z]表示{x-s,y,z}
 */
int main() {

    long long int ct = 0;
    for (int x = 0; x <= N; x++)
        for (int y = x; y <= N; y++)
            for (int z = y; z <= N; z++) {
                if (!(P1[y - x][z - y] || P2[z][y - x] || P2[y][z - x] || P2[x][z - y] || P3[y][z] || P3[x][z] ||
                      P3[x][y])) {
                    P1[y - x][z - y] = 1;
                    P2[z][y - x] = 1;
                    P2[y][z - x] = 1;
                    P2[x][z - y] = 1;
                    P3[x][y] = 1;
                    P3[x][z] = 1;
                    P3[y][z] = 1;
                    //printf("%d %d %d\n",x,y,z);
                    ct += x + y + z;
                }

            }
    printf("%lld\n", ct);
}
```

Q265

```Python
N = 5
M = 1 << N
g = [[] for i in range(M)]
vis = [0 for i in range(M)]
a = [0 for i in range(M)]
vis[0] = 1
ans = 0


def dfs(f: int):
    if f == M - 1:
        if a[-1] == (M >> 1):
            s = 0
            for i in range(M - N + 1):
                s = s << 1 | (a[i] & 1)
            global ans
            ans += s
        return
    for v in g[a[f]]:
        if vis[v]:
            continue
        vis[v] = 1
        a[f + 1] = v
        dfs(f + 1)
        vis[v] = 0


for i in range(M):
    for j in range(M):
        if i == j:
            continue
        x = bin(i)[2:]
        y = bin(j)[2:]
        x = '0' * (N - len(x)) + x
        y = '0' * (N - len(y)) + y
        if x[1:] == y[:-1]:
            g[i].append(j)
dfs(0)
print(ans)
```

Q267

```Python
d = 10 ** -5
M = 10 ** 9
M = log2(M)
f = d
N = 1000
mn = N
while f <= 1:
    l, r = 0, N
    while l < r:
        mid = (l + r) >> 1
        if mid * log2(1 + 2 * f) + (N - mid) * log2(1 - f) >= M:
            r = mid
        else:
            l = mid + 1
    mn = min(mn, l)
    f += d
C = [[0 for x in range(y + 1)] for y in range(N + 1)]
for i in range(N + 1):
    C[i][0] = C[i][i] = 1
    for j in range(1, i):
        C[i][j] = C[i - 1][j - 1] + C[i - 1][j]
s0, s1 = 0, 1 << N
for i in range(mn, N + 1):
    s0 += C[N][i]
ans = s0 / s1
print("{:.12f}".format(ans))
```

Q268

```Python
N = 10 ** 16 - 1
lp, ln = [], []
pr = Get_Primes(100)
cnt = [0 for i in range(len(pr) + 1)]


def dfs(f: int, n: int, v: int):
    if n > N:
        return
    if f == len(pr):
        cnt[v] += N // n
        return
    dfs(f + 1, n, v)
    dfs(f + 1, n * pr[f], v + 1)


dfs(0, 1, 0)
ans = 0
flag = True
for i in range(4, len(cnt)):
    if flag:
        ans += cnt[i] * (i - 1) * (i - 2) * (i - 3) // 6
    else:
        ans -= cnt[i] * (i - 1) * (i - 2) * (i - 3) // 6
    flag = not flag
print(ans)
```

Q271

```Python
pr = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]  # 13082761331670030=2*3*5*7*11*13*17*19*23*29*31*37*41*43


def ex_gcd(a: int, b: int):
    if b == 0:
        return 1, 0, a
    else:
        x, y, g = ex_gcd(b, a % b)
        return y, x - (a // b) * y, g


def solve_ax_plus_by_is_c(a: int, b: int, c: int):
    if a < 0:
        a, b, c = -a, -b, -c
    x, y, g = ex_gcd(a, b)
    if c % g != 0:
        return None
    ma = abs(a // g)
    mc = c // g
    x *= mc
    y *= mc
    y = (y % ma + ma) % ma
    x = (c - b * y) // a
    return x, y, abs(g)


def CRT(a1: int, m1: int, a2: int, m2: int):  # 中国剩余定理
    # m1*t==a2-a1(mod m2)
    t = solve_ax_plus_by_is_c(m1, m2, a2 - a1)[0]
    x = (a1 + t * m1) % (m1 * m2)
    return x


solpr = {}
for x in pr:
    solpr[x] = []
    for i in range(x):
        if i ** 3 % x == 1:
            solpr[x].append(i)
sol = solpr[pr[0]]
mul = pr[0]
for i in range(1, len(pr)):
    tmp = []
    for n in sol:
        for m in solpr[pr[i]]:
            tmp.append(CRT(n, mul, m, pr[i]))
    mul *= pr[i]
    sol = tmp
if 1 in sol:
    sol.remove(1)
print(sum(sol))
```

Q273

```C++
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 150;
vector<int> a, u, v;
int main() {
    for (int i = 5; i < N; i += 4) {
        bool isp = true;
        for (int j = 2; j * j <= i; j++)
            if (i % j == 0) isp = false;
        if (isp) {
            a.push_back(i);
            for (int j = 1; j <= i; j++)
                for (int k = j; k <= i; k++)
                    if (j * j + k * k == i) {
                        u.push_back(j);
                        v.push_back(k);
                        break;
                    }
        }
    }
    ll ans = 0;
    int m = a.size();
    int msk = pow(3, m);
    for (int s = 1; s < msk; s++) {
        int t = s;
        ll a = 0, b = 1;
        for (int i = 0; i < m; i++) {
            int d = t % 3;
            t /= 3;
            if (d == 1) {
                ll p = u[i], q = v[i];
                ll y = a * p + b * q, z = abs(a * q - b * p);
                a = y;
                b = z;
            } else if (d == 2) {
                ll p = v[i], q = u[i];
                ll y = a * p + b * q, z = abs(a * q - b * p);
                a = y;
                b = z;
            }
        }
        if (a > b) swap(a, b);
        ans += a;
    }
    printf("%lld\n", ans >> 1);
}
```

Q277

```Python
def ex_gcd(a: int, b: int):
    if b == 0:
        return 1, 0, a
    else:
        x, y, g = ex_gcd(b, a % b)
        return y, x - (a // b) * y, g


N = 10 ** 15
s = "UDDDUdddDDUDDddDdDddDDUDDdUUDd"
k = Fraction(1)
b = Fraction(0)
for ch in s:
    if ch == 'U':
        k = k * 4 / 3
        b = (b * 4 + 2) / 3
    elif ch == 'D':
        k /= 3
        b /= 3
    else:
        k = k * 2 / 3
        b = (b * 2 - 1) / 3
a, n, c = k.numerator, k.denominator, -b.numerator
x, y, g = ex_gcd(a, n)
x = x * c % n
d = (N - x + n - 1) // n
ans = x + d * n
print(ans)
```

Q293

```Python
pr = [2, 3, 5, 7, 11, 13, 17, 19, 23]
N = 10 ** 9
st = set()


def solve(n: int):
    m = 2
    while m <= 100000:
        if Miller_Rabin(n + m):
            return m
        m += 1
    return -1


def dfs(f: int, n: int):
    if f == len(pr):
        return
    for k in range(100):
        n *= pr[f]
        if n >= N:
            break
        st.add(solve(n))
        dfs(f + 1, n)


dfs(0, 1)
ans = sum(st)
print(ans)
```

Q294

```C++
# include <bits/stdc++.h>
# define mem(a,b) memset(a,b,sizeof(a))
using namespace std;
typedef long long ll;
const ll N=3138428376721;
const int M=23*24;
ll a[M],b[M][M],mod=1e9;
ll c[M][M]={0};
void mul_self(ll b[M][M]){
    mem(c,0);
    for(int i=0;i<M;i++)
        for(int k=0;k<M;k++)
            for(int j=0;j<M;j++)
                c[i][j]=(c[i][j]+b[i][k]*b[k][j])%mod;
    memcpy(b,c,sizeof(c));
}
void mul(ll a[M],ll b[M][M]){
    ll c[M]={0};
    for(int i=0;i<M;i++)
        for(int k=0;k<M;k++)
            c[i]=(c[i]+a[k]*b[k][i])%mod;
    memcpy(a,c,sizeof(c));

}
int enc[23][24],m=0;
int main(){
    for(int i=0;i<23;i++)
        for(int j=0;j<24;j++)
            enc[i][j]=m++;
    for(int i=0;i<10;i++)
        a[enc[i][i]]=1;
    for(int i=0;i<23;i++)
        for(int j=0;j<24;j++)
            for(int k=0;k<10&&j+k<24;k++){
                b[enc[i][j]][enc[(i*10+k)%23][j+k]]=1;
            }
    for(ll m=N-1;m;m>>=1){
        if(m&1) mul(a,b);
        mul_self(b);
    }
    ll ans=a[enc[0][23]];
    printf("%lld\n",ans);
}
//todo Thread

```

Q297

```Python
N = 10 ** 17 - 1
f = [1, 2]
mp = {0: 0, 1: 1, 2: 2, 3: 3}
while True:
    f.append(f[-1] + f[-2])
    if f[-1] > N:
        break


def dfs(n: int):
    if n in mp.keys():
        return mp[n]
    p = 0
    while p + 1 < len(f) and f[p + 1] <= n:
        p += 1
    ans = dfs(f[p] - 1) + dfs(n - f[p]) + n - f[p] + 1
    mp[n] = ans
    return ans


print(dfs(N))
```

Q300

```C++
# include <bits/stdc++.h>
# define pi pair<int,int>
# define X first
# define Y second
# define lb(x) ((x) & -(x))
using namespace std;
typedef long long ll;
const int N=15;
int f[N+N+4][N+N+4];
int dx[4]={-1,1,0,0},dy[4]={0,0,-1,1};
int ans[1<<N];
//将每个接触面进行编码。z[i][j]表示第i个格子和第j个格子相邻。
//显而易见的是，如果第i个格子和第j个相邻，那么i和j不同奇偶性。
ll z[N][N];
int x[N*N],y[N*N];
unordered_set<ll>st;
void dfs(int fl,int px,int py,ll s){
    for(int i=0;i<4;i++){
        int nx=px+dx[i],ny=py+dy[i];
        if(f[nx][ny]!=-1){
            s|=1ll<<z[fl-1][f[nx][ny]];
        }
    }
    if(fl==N){
        st.insert(s);
        return;
    }
    for(int i=0;i<4;i++){
        int nx=px+dx[i],ny=py+dy[i];
        if(f[nx][ny]==-1){
            f[nx][ny]=fl;
            dfs(fl+1,nx,ny,s);
            f[nx][ny]=-1;
        }
    }

}
const int B=16,M=(1<<16)-1;
int bits[1<<B];
int calbits(ll x){
    int ans=0;
    for(;x;x>>=B)
        ans+=bits[x&M];
    return ans;
}
//计算出对应的分子。
int solve(){
    memset(f,-1,sizeof(f));
    if(N==1) return 1;
    int m=0;
    for(int i=0;i<N;i+=2)
        for(int j=1;j<N;j+=2){
            x[m]=i;y[m]=j;
            z[i][j]=z[j][i]=m++;
        }
    f[N][N]=0;f[N][N+1]=1;
    dfs(2,N,N+1,z[0][1]);
    int sum=0;
    for(int s=0;s<(1<<N);s++){
        int mx=0;
        ll y=0;
        for(int i=0;i<N;i+=2)
            for(int j=1;j<N;j+=2)
                if((s>>i&1)&&(s>>j&1))
                    y|=1ll<<z[i][j];
        for(ll x:st)
            mx=max(mx,calbits(x&y));
        sum+=mx;
    }
    return sum;
}
int main(){
    for(int i=0;i<(1<<B);i++)
        for(int j=0;j<B;j++)
            bits[i]+=i>>j&1;
    int fz=solve(),fm=1<<N;
    int g=__gcd(fz,fm);
    fz/=g;fm/=g;
    int pw2=log2(fm+1e-6);
    double ans=1.0*fz/fm;
    printf("%.*f\n",pw2,ans);
}

```

Q301

```Python
k = 30
f = [1, 2]
for i in range(k):
    f.append(f[-1] + f[-2])
print(f[k])
```

Q303

```Python
N = 10 ** 4
O = 10
M = 3 ** O
Euler_sieve(int(10 ** (O / 2)))
f = [0 for i in range(N + 1)]
st = {i for i in range(1, N + 1)}


def dfs(fl: int, v: int, n: int, ls: list):
    if v > N:
        return
    if fl == len(ls):
        if f[v] == 0:
            f[v] = n // v
            st.remove(v)
        return
    p, e = ls[fl]
    for i in range(e + 1):
        dfs(fl + 1, v, n, ls)
        v *= p


a = []
for i in range(1, M):
    x, y, pw = 0, i, 1
    while y:
        x += y % 3 * pw
        pw *= 10
        y //= 3
    a.append(x)
    print(x, len(st))
    dfs(0, 1, x, factorization(x))
    ls = []
    for v in st:
        if x % v == 0:
            f[v] = x // v
            ls.append(v)
        for v in ls:
            st.remove(v)
for x in st:
    ml, mr = {}, {}
    mr[0] = 0
    con = 10 ** O % x
    for v in a:
        l = con * v % x
        r = v % x
        if l not in ml.keys():
            ml[l] = v
        if r not in mr.keys():
            mr[r] = v
    flag = 1
    ans = 10 ** 30
    for modl, l in ml.items():
        modr = (x - modl) % x
        if modr in mr.keys():
            ans = min(ans, l * 10 ** O + mr[modr])
    f[x] = ans // x
print(sum(f))
```

Q306

```Python
N = 10 ** 6
a = [0, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 0, 5, 2, 2, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 2, 7, 4, 0, 1, 1, 2,
     0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 2, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4]
z = [8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4]
ans = 0
for i in range(min(N, len(a))):
    if a[i] > 0:
        ans += 1
if N > len(a):
    N -= len(a)
    block, res = divmod(N, len(z))
    ans += block * (len(z) - z.count(0)) + res - z[:res].count(0)
print(ans)
```

Q307

```C++
# include <bits/stdc++.h>
typedef long double ld;
using namespace std;
const int K=20000,N=1000000;
ld fac[N+K+2];
ld A(int n,int m){
    return fac[n]-fac[n-m];
}
ld C(int n,int m){
    return fac[n]-fac[n-m]-fac[m];
}
int main(){
    for(int i=1;i<=N+K;i++)
        fac[i]=fac[i-1]+log(i);
    ld ans=0;
    for(int i=0;i<=K/2;i++){
        if(i>N||K-2*i>N-i) continue;
        ld val=C(N,i)+A(K,i*2)-log((ld)2)*i+A(N-i,K-i*2)-K*log(N);
        ans+=exp(val);
    }
    ans=(ld)1-ans;
    printf("%.10Lf\n",ans);
}
```

Q310

```C++
# include <bits/stdc++.h>
# define mem(a,b) memset(a,b,sizeof(a))
using namespace std;
typedef long long ll;
const int N=100000;
const int M=sqrt(N)/4+10;
int sg[N+4];
bool mex[M+4];
int cnt[M+4];
int main(){
    for(int i=1;i<=N;i++){
        mem(mex,0);
        for(int j=1;j*j<=i;j++)
            mex[sg[i-j*j]]=1;
        int j=0;
        for(;mex[j];++j);
        sg[i]=j;
        ++cnt[sg[i]];
    }
    ++cnt[0];
    int mx=*max_element(sg+1,sg+N+1);
    ll ans=0;
    for(int i=0;i<=mx;i++)
        for(int j=i+1;j<=mx;j++){
            int k=i^j;
            if(mx>=k&&k>j)
                ans+=1ll*cnt[i]*cnt[j]*cnt[k];
        }
    for(int i=1;i<=mx;i++)
        ans+=1ll*cnt[i]*(cnt[i]+1)/2*cnt[0];
    ans+=1ll*cnt[0]*(cnt[0]+1)*(cnt[0]+2)/6;
    printf("%lld\n",ans);
}

```

Q313

```Python
ans = 0
n = 1000000
pr = Get_Primes(n)
for p in pr:
    ans += ceil((p * p + 11) / 6) - floor((p * p + 13) / 8) - 1
ans <<= 1
print(ans)
```

Q315

```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2e7,M=1e7;
const int O=10,P=7;
int f1[N+4],f2[N+4];
int v[N+4],pr[N+4],m=0;
int b[O]={119, 36, 93, 109, 46, 107, 123, 39, 127, 111};
int g[O][O],c[1<<P];
int getnext(int n){
    int a=0;
    for(;n;n/=10)
        a+=n%10;
    return a;
}
int cal(int n){
    int a=0;
    for(;n;n/=10)
        a+=c[b[n%10]];
    return a;
}
int main(){
    for(int i=1;i<(1<<P);i++)
        for(int j=0;j<P;j++)
            if(i>>j&1) ++c[i];
    for(int i=2;i<=N;i++){
        if(v[i]==0) v[i]=i,pr[++m]=i;
        for(int j=1;j<=m;j++){
            if(pr[j]>v[i]||pr[j]>N/i) break;
            v[i*pr[j]]=pr[j];
        }
    }
    for(int i=0;i<O;i++)
        for(int j=0;j<O;j++)
            g[i][j]=c[b[i]&b[j]];
    for(int i=0;i<O;i++){
        f2[i]=f1[i]=c[b[i]]*2;
    }
    for(int i=O;i<=N;i++){
        int x=getnext(i);
        f1[i]=f1[x]+cal(i)*2;
        int d=0;
        for(int y=x,z=i;y;y/=10,z/=10)
            d+=g[y%10][z%10];
        f2[i]=f2[x]+cal(i)*2-d*2;

    }
    int ans=0;
    for(int i=1;i<=m;i++)
        if(pr[i]>=M)
            ans+=f1[pr[i]]-f2[pr[i]];
    printf("%d\n",ans);
}
```

Q329

```Python
s = "PPPPNNPPPNPPNPN"
N = 500
l = len(s)
f1 = Fraction(1, 3)
f2 = Fraction(2, 3)
f = [[Fraction(0, 1) for x in range(N + 1)] for y in range(l)]
pr = []
flag = [0 for _ in range(N + 1)]
flag[0] = flag[1] = 1
for i in range(2, N + 1):
    if flag[i] == 0:
        pr.append(i)
        for j in range(i * i, N + 1, i):
            flag[j] = 1
for j in range(1, N + 1):
    f[0][j] = Fraction(1, N)
    if (s[0] == 'P') ^ (not flag[j]):
        f[0][j] *= f1
    else:
        f[0][j] *= f2
for i in range(l - 1):
    for j in range(1, N + 1):
        if j == 1 or j == N:
            con = Fraction(1)
        else:
            con = Fraction(1, 2)
        if j > 1:
            if (s[i + 1] == 'P') ^ (not flag[j - 1]):
                f[i + 1][j - 1] += f[i][j] * f1 * con
            else:
                f[i + 1][j - 1] += f[i][j] * f2 * con
        if j < N:
            if (s[i + 1] == 'P') ^ (not flag[j + 1]):
                f[i + 1][j + 1] += f[i][j] * f1 * con
            else:
                f[i + 1][j + 1] += f[i][j] * f2 * con
print(sum(f[l - 1]))
```

Q336

```C++
#include <bits/stdc++.h>
using namespace std;
const int N=11,Q=2011;
int a[N],b[N];
int main(){
    a[0]=2;a[1]=0;a[2]=1;
    for(int i=3;i<N;i++)
        a[i]=i;
    int v=2*N-3,cnt=0;
    do{
        int c=0;
        memcpy(b,a,sizeof(a));
        for(int i=0,p=0;i<N;i++){
            if(b[i]==i) continue;
            if(b[N-1]!=i){
                for(p=i+1;b[p]!=i;p++);
                reverse(b+p,b+N);
                ++c;
            }
            reverse(b+i,b+N);
            ++c;
        }
        if(c==v&&++cnt==Q) break;
    }while(next_permutation(a,a+N));
    for(int i=0;i<N;i++)
        putchar('A'+a[i]);
    puts("");
}
```

Q343

```C++
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2e6;
//f(n)=n+1的最大质因数-1。
//n^3+1=(n+1)(n^2-n+1)
ll v1[N+4],b[N+4],v2[N+4];
int main(){
    for(int i=2;i<=N+1;i++){
        if(v1[i]==0){
            for(int j=i;j<=N+1;j+=i)
                v1[j]=i;
        }
    }
    for(int i=1;i<=N;i++)
        v1[i]=v1[i+1];
    for(int i=1;i<=N;i++)
        b[i]=1ll*i*i-i+1;
    for(int i=2;i<=N;i++){
        ll p=b[i];
        if(p==1) continue;
        for(ll j=i;j<=N;j+=p)
            while(b[j]%p==0)
                b[j]/=p,v2[j]=max(v2[j],p);
    }
    ll ans=0;
    for(int i=1;i<=N;i++)
        ans+=max(v1[i],v2[i])-1;
    printf("%lld\n",ans);
}

```

Q345

```C++
#include <bits/stdc++.h>
using namespace std;
const int N=16;
vector<int>g[N+1];
int f[1<<N];
int a[N][N];
int main(){
    freopen("r.txt","r",stdin);
    int n=15;
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            scanf("%d",&a[i][j]);
    for(int s=0;s<(1<<n);s++){
        int c=0;
        for(int i=0;i<n;i++)
            c+=s>>i&1;
        for(int i=0;i<n;i++){
            if(s>>i&1) continue;
            f[s|1<<i]=max(f[s|1<<i],f[s]+a[c][i]);
        }
    }
    printf("%d\n",f[(1<<n)-1]);
}
```

Q348

```C++
#include <bits/stdc++.h>
# define X first
# define Y second
using namespace std;
int N=8e8,Q=5;
map<int,int>mp;
bool ok(int n){
    string s=to_string(n);
    int l=0,r=s.size()-1;
    for(;l<r&&s[l]==s[r];++l,--r);
    return l>=r;
}
int main(){
    for(int i=1;i*i*i<=N;i++){
        cout<<i<<endl;
        for(int j=1;i*i*i+j*j<=N;j++)
            ++mp[i*i*i+j*j];
    }
    int cnt=0;
    int s=0;
    for(auto it=mp.begin();it!=mp.end();it++)
        if(it->Y==4&&ok(it->X)){
            s+=it->X;
            if(++cnt==Q) break;
        }
    printf("%d\n",s);
}
```

Q349

```C++
#include <bits/stdc++.h>
# define pi pair<int,int>
# define X first
# define Y second
# define lb(x) ((x)&-(x))
using namespace std;
typedef long long ll;
const ll Q=1e18;
map<pi,int>mp;
int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};
const int N=100000;
int a[N+4],nxt[N+4];
int main(){
    int x=0,y=0;
    for(int i=1,k=0;i<=N;i++){
        pi pa(x,y);
        if(mp[pa]==0)
            k=(k-1)&3,a[i]=1;
        else
            k=(k+1)&3,a[i]=0;
        mp[pa]^=1;
        x+=dx[k];
        y+=dy[k];
    }
    map<int,int>mq;
    reverse(a+1,a+N+1);
    for(int i=2,j=0;i<=N;i++){
        while(j&&a[j+1]!=a[i]) j=nxt[j];
        if(a[j+1]==a[i]) ++j;
        nxt[i]=j;
        if(i%(i-nxt[i])==0)
            ++mq[i-nxt[i]];
    }
    int T=0,mx=0;
    ll ans=0;
    for(pi pa:mq)
        if(pa.Y>mx)
            tie(T,mx)=pa;
    reverse(a+1,a+N+1);
    if(Q<=N){
        for(int i=1;i<=Q;i++)
            if(a[i]) ++ans;
            else --ans;
    }
    else{
        ll nw=0;
        for(int i=1;i<=N;i++)
            if(a[i]) ++ans;
            else --ans;
        for(int i=0;i<T;i++)
            if(a[N-i]) ++nw;
            else --nw;
        ll g=(Q-N)/T,res=(Q-N)%T;
        ans+=g*nw;
        for(int i=1;i<=res;i++)
            if(a[N-T+i]) ++ans;
            else --ans;
    }
    printf("%lld\n",ans);
}
```

Q353

```C++
# include <bits/stdc++.h>
using namespace std;
const int N=100000,M=15;
typedef long long ll;
double pi=acos(-1.0);
bool vis[N+4];
ll x[N+4],y[N+4],z[N+4],r,m;
double d[N+4];
void add(int i,int j,int k){
    x[++m]=i;y[m]=j;z[m]=k;
    if(i>0){
        x[++m]=-i;y[m]=j;z[m]=k;
    }
}
double dis(int i,int j){
    ll v=x[i]*x[j]+max(y[i]*y[j]+z[i]*z[j],y[i]*z[j]+z[i]*y[j]);
    return pow(acos(1.0*v/r/r),2);
}
double solve(ll r){
    m=0;::r=r;
    for(ll i=0;i*i<=r*r;i++)
    for(ll j=i;i*i+j*j<=r*r;j++){
        ll k=sqrt(r*r-i*i-j*j+1e-10);
        if(i*i+j*j+k*k!=r*r) continue;
        if(k<j) break;
        add(i,j,k);
        if(i!=j) add(j,i,k);
        if(j!=k) add(k,i,j);
    }
    memset(vis,0,sizeof(vis));
    for(int i=1;i<=m;i++)
        d[i]=(x[i]==-r?0:1e100);
    int p;
    for(;;){
        p=0;
        for(int i=1;i<=m;i++){
            if(vis[i]) continue;
            if(p==0||d[i]<d[p]) p=i;
        }
        if(x[p]==r) break;
        vis[p]=1;
        for(int j=1;j<=m;j++)
            if(!vis[j])
                d[j]=min(d[j],d[p]+dis(p,j));
    }
    return d[p]/pi/pi;
}
int main(){
    double ans=0;
    for(int i=1;i<=M;i++){
        ans+=solve((1<<i)-1);
    }
    printf("%.10f\n",ans);
}

```

Q358

```Python
def is_primitive_root(a: int, p: int):
    pr = [v[0] for v in naive_factorization(p - 1)]
    for d in pr:
        if quick_power(a, (p - 1) // d, p) == 1:
            return False
    return True


left = "00000000137"
right = "56789"
val = float("0." + left)
ed = floor(1 / val)
val += 10 ** -len(left)
st = ceil(1 / val)
mod = 10 ** len(right)
ph = phi(mod)
modv = int(right)
for x in range(st // 2 * 2 + 1, ed + 1, 2):
    k = (quick_power(10, x - 1, mod) - 1) * quick_power(x, ph - 1, mod) % mod
    if k == modv and Miller_Rabin(x) and is_primitive_root(10, x):
        ans = (x - 1) // 2 * 9
        break
print(ans)
```

Q359

```Python
N = 71328803586048
mod = 10 ** 8


def cal(n: int, f: int):
    k = n >> 1
    if f == 0:
        return k * (k + 1) * (2 * k + 1) // 6 * 4
    else:
        return n * (n + 1) * (2 * n + 1) // 6 - k * (k + 1) * (2 * k + 1) // 6 * 4


def fun(n: int, k: int):
    if n == 0:
        return (k + 1) * (k + 2) // 2
    else:
        v = 2 * int((n + 1) // 2) + k
        if k % 2 == 0:
            f = 1
        else:
            f = -1
        return (cal(v, v & 1) - cal(v - k, v & 1)) - (cal(v - 1, (v & 1) ^ 1) - cal(v - k, (v & 1) ^ 1)) + f * (
                (n + 1) ** 2 // 2)


ans = 0
for x in Get_Divisors(N):
    ans = (ans + fun(x - 1, N // x - 1)) % mod
print("{:08}".format(ans))
# A083362
```

Q364

```C++
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int Q=1000000;
const int N=Q*2+4;
ll fac[N],inv[N],finv[N],pw2[N],mod=1e8+7;
ll C(int n,int m){
    return fac[n]*finv[n-m]%mod*finv[m]%mod;
}
ll cal(int Q){
    ll ans=0;
    for(int s=0;s<4;s++){
        int v1=s&1,v2=s>>1&1;
        for(int k=0;3*k<=Q-1-v1-v2;k++){
            int m=Q-1-v1-v2-3*k;
            if(m&1) continue;
            m>>=1;
            ans=(ans+fac[m+k+1]*C(m+k,m)%mod*pw2[k]%mod*fac[k+v1+v2]%mod*fac[m+k])%mod;
        }
    }
    return ans;
}
int main(){
    //A192008
    fac[0]=fac[1]=inv[1]=finv[0]=finv[1]=pw2[0]=1;
    pw2[1]=2%mod;
    for(int i=2;i<N;i++){
        fac[i]=fac[i-1]*i%mod;
        inv[i]=(mod-mod/i)*inv[mod%i]%mod;
        finv[i]=finv[i-1]*inv[i]%mod;
        pw2[i]=pw2[i-1]*2%mod;
    }
    printf("%lld\n",cal(Q));
}

```

Q365

```C++
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1e18,M=1e9;
const int L=1000,R=5000;
bool vis[R+4];
vector<int>pr,res;
int fac[R+4];
ll inv(ll n,ll p){
    ll a=1,m=p-2;
    for(;m;m>>=1){
        if(m&1) a=a*n%p;
        n=n*n%p;
    }
    return a;
}
ll ex_gcd(ll a,ll b,ll &x,ll &y){
    if(b==0){
        x=1;y=0;return a;
    }
    ll g=ex_gcd(b,a%b,x,y);
    ll z=x-(a/b)*y;
    x=y;y=z;return g;
}
//解不定方程ax+my=c。
ll congruence(ll a,ll c,ll m){
    ll x,y,g;
    g=ex_gcd(a,m,x,y);
    if(c%g!=0) return -1;
    x*=c/g;
    ll t=m/g;
    return (x%t+t)%t;
}
ll CRT(ll b,ll m,ll c,ll n){
    ll y=congruence(m,c-b,n);
    ll x=m*y+b;
    ll t=m*n;
    return (x%t+t)%t;
}
int C(int n,int m,int p){
    if(m>n) return 0;
    return fac[n]*inv(fac[m],p)%p*inv(fac[n-m],p)%p;
}
ll lucas(ll n,ll m,ll p){
    return n==0?1:C(n%p,m%p,p)*lucas(n/p,m/p,p)%p;
}
int main(){
    for(int i=2;i<R;i++){
        if(vis[i]) continue;
        if(i>L) pr.push_back(i);
        for(int j=i+i;j<R;j+=i)
            vis[j]=1;
    }
    for(int p:pr){
        fac[0]=1;
        for(int i=1;i<p;i++)
            fac[i]=fac[i-1]*i%p;
        res.push_back(lucas(N,M,p));
    }
    ll ans=0;
    for(int i=0;i<pr.size();i++)
        for(int j=0;j<i;j++){
            ll x=CRT(res[i],pr[i],res[j],pr[j]);
            for(int k=0;k<j;k++){
                ll y=CRT(x,pr[i]*pr[j],res[k],pr[k]);
                ans+=y;
            }
        }
    printf("%lld\n",ans);
}


```

Q371

```Python
k = 499
f = [[0, 0] for i in range(k + 2)]
for i in range(k, -1, -1):
    f[i][1] = (2 * (499 - i) * f[i + 1][1] + 1000) / (999 - i)
    f[i][0] = (2 * (499 - i) * f[i + 1][0] + f[i][1] + 1000) / (999 - i)
ans = f[0][0]
print("{:.8f}".format(ans))
```

Q375

```C++
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
int Q=2e9,T;
const int A=290797,M=50515093;
//容易知道，S1到后面为一个循环数组，其中周期为T。
int S[M*3];
int l[M*3],r[M*3];
void gen(int m){
    stack<int>st;
    for(int i=0;i<m;i++){
        while(!st.empty() && S[i] < S[st.top()])
            st.pop();
        if(st.empty()) l[i]=0;
        else l[i]=st.top()+1;
        st.push(i);
    }
    while(!st.empty())
        st.pop();
    for(int i=m-1;i>=0;i--){
        while(!st.empty() && S[i] < S[st.top()])
            st.pop();
        if(st.empty()) r[i]=m-1;
        else r[i]=st.top()-1;
        st.push(i);
    }
}
ll solve(){
    //由于S数组是一个循环数组，故分类处理。
    int mn=*min_element(S, S + T);
    ll res=1ll*Q*(Q+1)/2,ans=0;
    if(Q<=T*2){
        for(int i=T;i<Q;i++)
            S[i]=S[i-T];
        gen(Q);
        for(int i=0;i<Q;i++){
            ll tp=1ll*(i-l[i]+1)*(r[i]-i+1);
            ans+=tp*S[i];
            res-=tp;
        }
        ans+=res*mn;
    }
    else{
        for(int i=0;i<T;i++)
            S[i+T]=S[i+T+T]=S[i];
        int block=Q/T,rest=Q%T;
        gen(2*T+rest);
        for(int i=0;i<T;i++){
            ll tp=1ll*(i-l[i]+1)*(r[i]-i+1);
            ans+=tp*S[i];
            res-=tp;
            int j=2*T+rest-1-i;
            tp=1ll*(j-l[j]+1)*(r[j]-j+1);
            ans+=tp*S[j];
            res-=tp;
            tp=1ll*(i+T-l[i+T]+1)*(r[i]-i+1);
            ll c=block-2+(i<rest);
            ans+=tp*S[i]*c;
            res-=tp*c;
        }
        ans+=res*mn;
    }
    return ans;
}
int main(){
    S[0]=1ll*A*A%M;
    for(int i=1;i<M;i++){
        S[i]=1ll*S[i-1]*S[i-1]%M;
        if(S[i]==S[0]){
            T=i;break;
        }
    }
    printf("%lld\n",solve());
}
```

Q387

```Python
from Miller_Rabin import Miller_Rabin

ls = [[1, 2, 3, 4, 5, 6, 7, 8, 9]]
tp = [1, 3, 7, 9]


def is_Harshad(n: int):
    return n % sum(int(x) for x in str(n)) == 0


for i in range(12):
    ls.append([])
    for x in ls[i]:
        for j in range(10):
            t = x * 10 + j
            if is_Harshad(t):
                ls[i + 1].append(t)

ans = 0
for v in ls:
    for n in v:
        if not Miller_Rabin(n // sum(int(x) for x in str(n))):
            continue
        for y in tp:
            w = n * 10 + y
            if Miller_Rabin(w):
                ans += w
print(ans)
```

Q389

```C++
# include <bits/stdc++.h>
using namespace std;
vector<int>d={4,6,8,12,20};
int main(){
    int m=1;
    vector<double>fp1(2);
    fp1[1]=1;
    for(int x:d){
        vector<double>fp2(1,1);
        vector<double>fn1(m*x+1,0);
        for(int i=1;i<=m;i++){
            vector<double>fn2(x*i+1);
            for(int j=0;j<=x*(i-1);j++)
                for(int k=1;k<=x;k++)
                    fn2[j+k]+=fp2[j]/x;
            fp2=fn2;
            for(int j=1;j<=x*i;j++)
                fn1[j]+=fp1[i]*fp2[j];
        }
        fp1=fn1;
        m*=x;
    }
    double ex1=0,ex2=0;
    for(int i=1;i<=m;i++){
        ex1+=fp1[i]*i;
        ex2+=fp1[i]*i*i;
    }
    double ans=ex2-ex1*ex1;
    printf("%.4f\n",ans);
}
```

Q395

```C++
# include <bits/stdc++.h>
using namespace std;
const double eps = 1e-15;
double minx = 0, miny = 0, maxx = 1, maxy = 1;
double leftRotate = acos(0.8);
//直接将正方形的下边旋转约180-53度。
double rightRotate = -acos(0.6);
double tag = 5;
struct Square {
    double len, x, y, rad;
};

int main() {

    queue<Square> q;
    q.push({1, 0, 0, 0});
    while (!q.empty()) {
        Square prm = q.front();q.pop();
        //正方形左下角的点。
        double len = prm.len, ldx = prm.x, ldy = prm.y, rad = prm.rad;

        minx = min(minx, ldx);
        maxx = max(maxx, ldx);
        miny = min(miny, ldy);
        maxy = max(maxy, ldy);

        double cosrad = cos(rad);
        double sinrad = sin(rad);
        double dx = len * cosrad;
        double dy = len * sinrad;
        //正方形左上角的点。
        double lux = ldx - dy, luy = ldy + dx;
        //正方形位于上边上面的新点。
        double tx = lux + ((dx * 0.8) - (dy * 0.6)) * 0.8,ty = luy + ((dx * 0.6) + (dy * 0.8)) * 0.8;

        if (len * 0.8 > eps) {
            double pl = len * tag * 0.8;
            if (lux > maxx - pl || lux < minx + pl || luy > maxy - pl || luy < miny + pl) {
                q.push({len * 0.8, lux, luy, rad + leftRotate});
            }

            if (len * 0.6 > eps) {
                pl = len * tag * 0.6;
                if (tx > maxx - pl || tx < minx + pl || ty > maxy - pl || ty < miny + pl) {
                    q.push({len * 0.6, tx, ty, rad + rightRotate});
                }
            }
        }
    }
    double ans = (maxx - minx) * (maxy - miny);
    printf("%.10f\n", ans);
}
```

Q407

```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e7;
int mxp[N+4];
int main(){
    for(int p=2;p<=N;p++)
        if(!mxp[p])
            for(int i=p;i<=N;i+=p) mxp[i]=p;
    ll ans=0;
    for(int n=1;n<=N;n++){
        int m=1;
        for(int tp=n;tp>1;){
            int t=1;
            for(int p=mxp[tp];tp%p==0;tp/=p,t*=p);
            m=max(m,t);
        }
        int a=n-1;
        for(a=a-a%m;a>=0;a-=m){
            if(a+1<n&&1ll*a*(a+1)%n==0){
                ++a;break;
            }
            if(1ll*a*(a-1)%n==0) break;
        }
        ans+=a;
    }
    printf("%lld\n",ans);
}
```

Q425

```C++
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e7;
int pr[N+4],v[N+4],m=0;
int fa[N+4];
int now[1004],p=0;
int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
void merge(int x,int y){fa[find(x)]=find(y);}
int main(){
    for(int i=1;i<=N;i++)
        fa[i]=i;
    for(int i=2;i<=N;i++){
        if(v[i]==0){
            v[i]=i;pr[++m]=i;
        }
        for(int j=1;j<=m;j++){
            if(pr[j]>v[i]||pr[j]>N/i) break;
            v[i*pr[j]]=pr[j];
        }
    }
    ll ans=0;
    for(int i=1;i<=m;i++){
        int u=pr[i];
        string s=to_string(u);
        string t=s;
        p=0;
        for(int i=0;i<s.size();i++){
            char ch=s[i];
            for(int j=(i==0?1:0);j<10;j++){
                t[i]='0'+j;
                now[++p]=atoi(t.c_str());
            }
            t[i]=ch;
        }
        if(t.size()>=2&&t[1]!='0'){
            t=t.substr(1);
            now[++p]=atoi(t.c_str());
        }
        for(int i=1;i<=p;i++){
            int k=now[i];
            if(k>=u||v[k]!=k) continue;
            merge(k,u);
        }
        if(find(2)!=find(u)) ans+=u;
    }
    printf("%lld\n",ans);
}

```

Q443

```C++
# include <bits/stdc++.h>
# define X first
# define Y second
# define lb(x) ((x) & (-x))
# define mem(a,b) memset(a,b,sizeof(a))
# define debug freopen("r.txt","r",stdin)
# define pi pair<int,int>
using namespace std;
typedef long long ll;
const ll Q = 1e15;
const int N=sqrt(Q)*2;
int v[N],pr[N],p=0;
ll px[34],q=0;
void fact(ll x){
    q=0;
    for(int i=1;i<=p&&1ll*pr[i]*pr[i]<=x;i++)
    if(x%pr[i]==0){
        px[++q]=pr[i];
        for(;x%pr[i]==0;x/=pr[i]);
    }
    if(x!=1) px[++q]=x;
}
int main(){
    for (int i = 2; i < N; i++) {
        if (v[i] == 0) {
            pr[++p] = i;
            v[i] = i;
        }
        for (int j = 1; j <= p; j++) {
            if (pr[j] > v[i] || pr[j] > N / i) break;
            v[i * pr[j]] = pr[j];
        }
    }
    ll n=4,g=13;
    //找最小的k使得gcd(n+k+1,g+k)!=1，等价于gcd(g-n-1,n+k+1)!=1;
    for(;;){
        fact(g-n-1);
        ll nxt=1e18;
        //找到下一个最小的n'>n，使得gcd(n',g(n'-1))>1，
        //tn则是一个新的g(n'-1)，使得此时的gcd(n',g(n'-1))>1。
        for(int i=1;i<=q;i++){
            ll tn=(g+px[i]-1)/px[i]*px[i];
            nxt=min(nxt,tn);
        }
        ll k=nxt-g;
        ll np=n+1+k;
        if(np>Q){
            g+=Q-n;
            break;
        }
        g=nxt+__gcd(np,nxt);
        n=np;
        if(n>=Q) break;
    }
    printf("%lld\n",g);
}

```

Q461

```C++
#include <bits/stdc++.h>
# define mem(a,b) memset(a,b,sizeof(a))
# define pdi pair<double,int>
# define X first
# define Y second
using namespace std;
const int N=10000;
double e=exp(1),pi=acos(-1.0);
pdi pa[N*N];
double f[N+N];
int m=0,n=0;
int main(){
    double pi=acos(-1);
    double mx=log(pi+1);
    for(int i=0;i<N+N;i++){
        double e=1.0*i/N;
        f[m++]=exp(e)-1;
        if(e>mx) break;
    }
    for(int i=0;i<m;i++)
        for(int j=0;j<=i;j++){
            double w=f[i]+f[j];
            pa[n++]=pdi(w,i*i+j*j);
            if(w>pi) break;
        }
    sort(pa,pa+n);
    double eps=1e9;
    int ans=0;
    for(int l=0,r=n-1;l<n;l++){
        for(;r>=0&&pa[l].X+pa[r].X>pi;--r);
        if(r>0){
            double w=abs(pi-pa[l].X-pa[r].X);
            if(w<eps){
                eps=w;ans=pa[l].Y+pa[r].Y;
            }
        }
        if(r+1<n){
            double w=abs(pi-pa[l].X-pa[r+1].X);
            if(w<eps){
                eps=w;ans=pa[l].Y+pa[r+1].Y;
            }
        }
    }
    printf("%d\n",ans);
}

```

Q491

```Python
B = 2
B += 1
f = [{} for i in range(B ** 10)]
for i in range(1, 10):
    f[B ** i][i] = 1
for st in range(len(f)):
    ls = []
    for i in range(10):
        ls.append(st // (B ** i) % B)
    cnt = sum(ls)
    for s, val in f[st].items():
        for i in range(10):
            if ls[i] == B - 1:
                continue
            if cnt % 2 == 0:
                now = s + i
            else:
                now = s - i
            newst = st + B ** i
            if now not in f[newst].keys():
                f[newst][now] = 0
            f[newst][now] += val
ans = sum(val for s, val in f[-1].items() if s % 11 == 0)
print(ans)
```

Q501

```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll Q = 1000000000000;
const ll M = pow(Q,2.0/3) + 2;


char vis[M + 1];
int sum[M + 1],pr[M + 1],m;

unordered_map<ll,ll> mp,mq;
ll g(ll x, ll a) {
    if (a == 1 || x == 0)return (x + 1) / 2;
    ll &v = mp[(x << 10) + a];
    if (v)return v;
    return v = g(x, a - 1) - g(x / pr[a], a - 1);
}
ll cal(ll n) {
    if (n <= M)return sum[n];
    ll &v = mq[n];
    if (v) return v;
    ll a = cal(pow(n, 1.0 / 4));
    ll b = cal(sqrt(n));
    ll c = cal(pow(n, 1.0 / 3));
    ll s = g(n, a) + (b + a - 2) * (b - a + 1) / 2;
    for (ll i = a + 1; i <= b; i++) {
        ll w = n / pr[i];
        s -= cal(w);
        ll csqw = cal(sqrt(w));
        if (i <= c) {
            for (ll j = i; j <= csqw; j++)
                s += j - 1 - cal(w / pr[j]);
        }
    }
    return v = s;
}
int main() {
    ll ans = 0;
    for (ll i = 2; i <= M; i++) {
        if (!vis[i]) {
            for (ll j = i * i; j <= M; j += i) vis[j] = 1;
            pr[++m] = i;
        }
        sum[i] = m;
    }
    for (ll i = 1; i <= m && pr[i] <= pow(Q, 1.0 / 7); i++)
        ans++;
    ll tmp;
    for (int i = 1; i <= m && (tmp = Q / (1ll * pr[i] * pr[i] * pr[i])) >= 2; i++) {
        ans += cal(tmp) - (tmp >= pr[i]);
    }
    for (ll i = 1; 1ll * pr[i] * pr[i] * pr[i] <= Q; i++)
        for (ll j = i + 1; j <= m && pr[j + 1] <= (tmp = Q / (1ll * pr[i] * pr[j])); j++)
            ans += cal(tmp) - cal(pr[j]);
    printf("%lld\n", ans);
    return 0;
}
```

Q506

```Python
from gmpy2 import is_prime

# A028355
# 发现，该序列的周期为15，第i个鼠是第i-15个数后面拼接一个固定的6位数。
# 将每个n分解成n=x*15+y再进行计算。

N = 10**14
mod = 123454321
inv1e6 = 96007682
m = 10 ** 6
a = [1, 2, 3, 4, 32, 123, 43, 2123, 432, 1234, 32123, 43212, 34321, 23432, 123432]
b = [234321, 343212, 432123, 321234, 123432, 432123, 212343, 432123, 123432, 321234, 432123, 343212, 234321, 123432, 123432]
T = 15
ans = 0
for i in range(T):
    cnt = N // T + (i < N % T)
    c1 = (pow(m, cnt, mod) - 1) * inv1e6 % mod
    c2 = (c1 - cnt + mod) * inv1e6 % mod
    ans = (ans + a[i] * c1 + b[i] * c2) % mod
print(ans)

```

Q511

```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1234567898765,M=4321,O=64;
ll mod=1e9;
ll cnt[M];
ll a[M],b[O][M];
void getd(ll N){
    for(ll i=1;i*i<=N;i++)
    if(N%i==0){
        ++cnt[(i+1)%M];
        if(i*i!=N) ++cnt[(N/i+1)%M];
    }
}
void cal(ll a[M],ll b[M],ll ans[M]){
    ll c[M]={0};
    for(int i=0;i<M;i++)
        for(int j=0;j<M;j++)
            c[(i+j)%M]=(c[(i+j)%M]+a[i]*b[j])%mod;
    memcpy(ans,c,sizeof(c));
}
int main(){
    getd(N);
    a[0]=1;
    memcpy(b[0],cnt,sizeof(b[0]));
    for(int i=1;i<O;i++)
        cal(b[i-1],b[i-1],b[i]);
    for(int i=0;i<O;i++)
        if(N>>i&1)
            cal(a,b[i],a);
    printf("%lld\n",a[0]);
}
```

Q523

```Python
# A279683

N = 30
fac = [1]
a = [0]
for i in range(1, N + 1):
    fac.append(fac[-1] * i)
    a.append(a[i - 1] * i + fac[i - 1] * (2 ** (i - 1) - 1))

ans = a[N] / fac[N]
print("{:.2f}".format(ans))

```

Q531

```C++
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int L=1000000,R=1005000;
int phi[R+4];
ll ex_gcd(ll a,ll b,ll &x,ll &y){
    if(b==0){
        x=1;y=0;return a;
    }
    ll g=ex_gcd(b,a%b,x,y);
    ll z=x-(a/b)*y;
    x=y;y=z;return g;
}
//解不定方程ax+my=c。
ll congruence(ll a,ll c,ll m){
    ll x,y,g;
    g=ex_gcd(a,m,x,y);
    if(c%g!=0) return -1;
    x*=c/g;
    ll t=m/g;
    return (x%t+t)%t;
}
ll CRT(ll b,ll m,ll c,ll n){
    ll y=congruence(m,c-b,n);
    if(y==-1) return -1;
    ll x=m*y+b;
    ll t=m*n;
    return (x%t+t)%t;
}
int main(){
    for(int i=1;i<R;i++)
        phi[i]=i;
    for(int i=2;i<R;i++){
        if(phi[i]!=i) continue;
        phi[i]=i-1;
        for(int j=i+i;j<R;j+=i)
            phi[j]=phi[j]/i*(i-1);
    }
    ll ans=0;
    for(int i=L;i<R;i++){
        for(int j=i+1;j<R;j++){
            ll x=CRT(phi[i],i,phi[j],j);
            if(x!=-1) ans+=x;
        }
    }
    printf("%lld\n",ans);
}
```

Q549

```C++
#include <bits/stdc++.h>
# define X first
# define Y second
using namespace std;
typedef long long ll;
const int N=1e8;
int s[N+4];
int solve(int p,int e){
    ll k;
    for(k=p;;k+=p){
        ll t=k;
        for(;t%p==0&&e>0;--e,t/=p);
        if(e==0) break;
    }
    return k;
}
int main(){
    for(int i=2;i<=N;i++){
        if(s[i]!=0) continue;
        for(ll j=i,c=1;j<=N;j*=i,++c){
            int mx=solve(i,c);
            for(ll k=j;k<=N;k+=j)
                s[k]=max(s[k],mx);
        }
    }
    ll ans=0;
    for(int i=2;i<=N;i++){
        ans+=s[i];
    }
    printf("%lld\n",ans);
}
```

Q561

```Python
# E(m,n)=((n+1)(n+2)/2)^m-(n+1)^m，对式子提公因式(n+1)^m，然后进行判定。

Q = 10 ** 12
M = 904961


def cal(n: int):
    cnt = 0
    M = len(bin(n)[2:])
    for i in range(1, M + 1):
        cnt += (n + 2 ** (i - 1)) // (2 ** i) * i
    return cnt


c0 = Q // 4
c3 = (Q + 1) // 4
ans = cal(c3) * M
if M % 2 == 0:
    tp = cal(c3 >> 1) + cal((c3 + 1) >> 1)
    v = bin(M)[::-1].find('1')
    tp += c0 * (v + 1)
    ans += tp
else:
    ans += cal(c0)
print(ans)
```

Q577

```Python
N = 12345
ans = 0
for n in range(N-2):
    ans += Fraction(1, 216) * n ** 4 + Fraction(1, 12) * n ** 3 + Fraction(37, 72) * n ** 2 + [Fraction(5, 4), Fraction(139, 108), Fraction(131, 108)][n % 3] * n + [1, Fraction(10, 9), Fraction(7, 9)][n % 3]
print(ans)
# A011779
```

Q581

```C++
# include <bits/stdc++.h>
using namespace std;
const int M=47;
int pr[M+4],m=0,b[M+4];
typedef long long ll;
int main(){
    ll N=2e12;
    for(int i=2;i<=M;i++){
        if(b[i]) continue;
        pr[++m]=i;
        for(int j=i+i;j<=M;j+=i)
            b[j]=1;
    }
    priority_queue<ll,vector<ll>,greater<ll>>q;
    q.push(1);
    ll ans=0,pre=1;
    while(!q.empty()){
        ll u=q.top();q.pop();
        if(u==pre+1){
            ans+=pre;
        }
        pre=u;
        for(int i=1;i<=m;i++){
            ll v=u*pr[i];
            if(v>N) break;
            q.push(v);
            if(u%pr[i]==0) break;
        }
    }
    printf("%lld\n",ans);
}

```

Q622

```Python
Q = 60
R = 2 ** Q - 1
ls = Get_Divisors(R)
ans = 0
for d in ls:
    p = 1
    while p <= Q:
        if quick_power(2, p, d) == 1:
            break
        p += 1
    if p == Q:
        ans += d+1
print(ans)
'''
原问题等价于求2模n-1的阶数r。其中有多少个r的值为60。
'''
```

Q630

```C++
# include <bits/stdc++.h>
# define pi pair<int,int>
using namespace std;
typedef long long ll;
const int N=2500;
int S[N*2+4],T[N*2+4];
ll solve(vector<pi>&v){
    map<pi,unordered_set<double>>mp;
    sort(v.begin(),v.end());
    v.resize(unique(v.begin(),v.end())-v.begin());
    int x1,y1,x2,y2;
    for(int i=0;i<v.size();i++)
    for(int j=0;j<i;j++){
        tie(x1,y1)=v[i];
        tie(x2,y2)=v[j];
        int x=x2-x1,y=y1-y2;
        double z=x1*y2-x2*y1;
        int g=__gcd(x,y);
        x/=g;y/=g;z/=g;
        if(x<0||x==0&&y<0){
            x=-x;y=-y;z=-z;
        }
        mp[pi(x,y)].insert(z);
    }
    int m=0;
    for(auto &[k,st]:mp)
        m+=st.size();
    ll ans=0;
    for(auto &[k,st]:mp)
        ans+=1ll*st.size()*(m-st.size());
    return ans;
}
int main(){
    S[0]=290797;
    for(int i=1;i<=N*2;i++){
        S[i]=1ll*S[i-1]*S[i-1]%50515093;
        T[i]=S[i]%2000-1000;
    }
    vector<pi>v;
    for(int i=2;i<=N*2;i+=2)
        v.push_back(pi(T[i-1],T[i]));
    printf("%lld\n",solve(v));
}

```

Q686

```Python
i, c = 1, 0
lg = log10(2)

lt = [196, 289, 485]
l, r = log10(1.23), log10(1.24)
pre = 0
i = 90
c = 2
s = lg * i
while c < 678910:
    j = 0
    while j < 3:
        ns = s + lg * lt[j]
        if l <= ns - int(ns) < r:
            break
        j += 1
    if j == 4:
        print("FAIL")
        exit()
    s += lg * lt[j]
    i += lt[j]
    c += 1
print(i)
```

Q688

```C++
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const ll Q=1e16;
ll mod=1e9+7;
ll inv2=(mod+1)>>1;
int main(){
    ll ans=0;
    for(ll k=1;;k++){
        ll w=k*(k+1)/2;
        if(w>Q) break;
        ll t=Q-w;
        ll block=(t+1)/k%mod,res=(t+1)%k%mod;
        ans=(ans+k*block%mod*(block+1)%mod*inv2%mod+(block+1)*res%mod)%mod;
    }
    printf("%lld\n",ans);
}
```

Q692

```Python
import bisect
# Zeckendorf's theorem
f = [1, 2]
for i in range(100):
    f.append(f[-1] + f[-2])
G = {1: 1, 2: 3}


def getG(n: int):
    if n in G.keys():
        return G[n]
    p = bisect.bisect_right(f, n) - 1
    if f[p] == n:
        G[n] = getG(f[p - 2]) + getG(f[p - 1]) + f[p] - f[p - 2]
    else:
        G[n] = getG(f[p]) + getG(n - f[p])
    return G[n]


print(getG(23416728348467685))
```

Q694

```C++
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const ll Q=1e18;
const int M=pow(Q,1.0/3);
bool b[M+4];
int pr[M/3+100],m=0;
int main(){
    for(int i=2;i<=M;i++){
        if(b[i]) continue;
        pr[++m]=i;
        for(ll j=1ll*i*i;j<=M;j+=i)
            b[j]=1;
    }
    set<ll>st;
    unordered_set<ll>st2;
    st.insert(1);
    for(int i=1;i<=m;i++){
        st2.clear();
        for(ll x:st){
            int cnt=0;
            while(x<=Q/pr[i]){
                x*=pr[i];
                if(++cnt>=3)
                    st2.insert(x);
            }
            if(cnt<3) break;
        }
        for(ll x:st2)
            st.insert(x);
    }
    vector<ll>v(st.begin(),st.end());
    sort(v.begin(),v.end());
    ll ans=0;
    for(ll x:st)
        ans+=Q/x;
    //printf("%lld\n",st.size());
    printf("%lld\n",ans);
}
```

Q700

```Python
mod = 4503599627370517
a = 1504170715041707
l = r = ans = a
while l > 0:
    nxt = (l + r) % mod
    if nxt < l:
        l = nxt
        ans += l
    else:
        r = nxt
print(ans)
```

Q704

```Python
# A119387
N = 10**16
# 1~N中所有数加起来一共有cnt位
cnt = 0
l = 1
while l <= N:
    r = min(l * 2 - 1, N)
    cnt += (r - l + 1) * len(bin(l)[2:])
    l = r + 1

# cnt1: 1~N中所有数，如果最后x位是以01...1结尾，那么cnt1+=x。
cnt1 = 0
M = len(bin(N)[2:])
for i in range(1, M + 1):
    cnt1 += (N + 2 ** (i - 1) + 1) // (2 ** i) * i - 1
ans = cnt - cnt1
print(ans)
```

Q706

```C++
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=100000;
ll f[N+4][3][3][3][3],mod=1e9+7;
/*
数字串的前缀和为s[0]~s[n]
f[m][i][j][k][l]表示前m+1个值s[0]~s[m]中，有
 s[?]%3==1的个数 % 3 = i
 s[?]%3==2的个数 % 3 = j
 s[m]%3==k
 已经有的非空子串数目 % 3 = l.
 */
void add(ll &x,ll y){
    x=(x+y)%mod;
}

int main(){
    f[1][0][0][0][1] = 3;
    f[1][1][0][1][0] = 3;
    f[1][0][1][2][0] = 3;
    for(int m=1;m<N;m++)
        for(int i=0;i<3;i++)
            for(int j=0;j<3;j++)
                for(int k=0;k<3;k++)
                    for(int l=0;l<3;l++){
                        //0~m中一共有m+1个值。
                        int c0=(m+1-i-j+6)%3;
                        ll &now = f[m][i][j][k][l];
                        if(now == 0)
                            continue;
                        if(k==0){
                            add(f[m+1][i][j][k][(l+c0)%3],now*4); //0,3,6,9
                            add(f[m+1][(i+1)%3][j][(k+1)%3][(l+i)%3],now*3);//1,4,7
                            add(f[m+1][i][(j+1)%3][(k+2)%3][(l+j)%3],now*3);//2,5,8
                        }
                        else if(k==1){
                            add(f[m+1][(i+1)%3][j][k][(l+i)%3],now*4);//0,3,6,9
                            add(f[m+1][i][(j+1)%3][(k+1)%3][(l+j)%3],now*3);// 1,4,7
                            add(f[m+1][i][j][(k+2)%3][(l+c0)%3],now*3);//2,5,8
                        }
                        else{
                            add(f[m+1][i][(j+1)%3][k][(l+j)%3],now*4);//0,3,6,9
                            add(f[m+1][i][j][(k+1)%3][(l+c0)%3],now*3);//1,4,7
                            add(f[m+1][(i+1)%3][j][(k+2)%3][(l+i)%3],now*3);//2,5,8
                        }
                    }
    ll ans=0;
    for(int i=0;i<3;i++)
        for(int j=0;j<3;j++)
            for(int k=0;k<3;k++)
                add(ans,f[N][i][j][k][0]);
    printf("%lld\n",ans);
}

```

Q710

```C++
# include <bits/stdc++.h>
using namespace std;
const int N = 2000004;
int s[N][2],f[N][2],mod=1000000;
int main(){
    f[0][0]=s[0][0]=1;
    f[1][0]=1;s[1][0]=2;
    for(int n=2;n<N;n++){
        f[n][0]=(s[n-1][0]-f[n-2][0]+mod)%mod;
        f[n][1]=(s[n-1][1]+f[n-2][0])%mod;
        s[n][0]=(s[n-1][0]+f[n][0])%mod;
        s[n][1]=(s[n-1][1]+f[n][1])%mod;
        int a=s[n/2][1];
        if(n%2==0) a=(a+f[n/2-1][0])%mod;
        if(n>42&&a%mod==0) {printf("%d\n",n);break;}
    }
}
```

Q713

```Python
# A134546
for N in range(2, 11):
    ans = 0
    for r in range(1, N):
        q, s = divmod(N, r)
        ans += r * q * (q - 1) // 2 + s * q
        print(N, r, r * q * (q - 1) // 2 + s * q)

for n in range(2, 11):
    for k in range(2, n):
        m = n // k
        print(n, k, (n - m) * (n - m - 1) // 2 + (k - 1) * (m + 1) * m // 2)

'''
Fleshing out the explanation - thinking of the N fuses as nodes, after some number of tries we can construct the graph G
 in which two nodes (fuses) are adjacent if and only if they have not been tested together. A strategy is guaranteed to
  succeed if and only if G contains no clique of size m. The optimal strategy minimizes the number of tries, or
  equivalently maximizes the number of edges in G. So we are looking for the graph with the maximum number of edges that
  contains no clique of size m. By Turan's Theorem, this is the Turan graph T(n,m-1). The optimal strategy is then defined
  by partitioning the N nodes into m-1 subsets of as equal size as possible, and testing each pair within each subset.
'''

```

Q719

```C++
# include <bits/stdc++.h>
typedef long long ll;
using namespace std;
ll n=1000000,m;
int a[15],p=0;
bool dfs(int f,ll s,ll w){
    if(s>m||w>m) return 0;
    if(f==p){
        return s+w==m;
    }
    if(dfs(f+1,s+w,a[f])) return 1;
    if(dfs(f+1,s,w*10+a[f])) return 1;
    return 0;
}
int main(){
    ll ans=n*n;
    for(m=4;m<n;m++){
        ll v=m*m;
        p=0;
        for(;v;v/=10) a[p++]=v%10;
        reverse(a,a+p);
        if(dfs(0,0,0)) ans+=m*m;
    }
    printf("%lld\n",ans);
}
```

Q725

```Python
n = 2020
mod = int(1e16)
c = [0 for _ in range(10)]
f = [1]
for _ in range(n):
    f.append((f[-1] * 10 + 1) % mod)
fac = [1]
for i in range(1, 11):
    fac.append(fac[-1] * i)

ans = 0


def cal(d: list, bt: int):
    s = 0
    for j in range(10):
        if d[j] == 0:
            continue
        d[j] -= 1
        val = 1
        for k in range(bt - 1 - d[0]):
            val *= bt - k - 1
        for k in range(1, 10):
            val //= fac[d[k]]
        s += j * val
        d[j] += 1
    return s


def solve(s: int):
    global ans
    d = list(c)
    d[s] += 1
    cnt = sum(d)
    d[0] = n - cnt
    value = cal(d, n)
    ans = (ans + f[n - 1] * value) % mod


def dfs(s: int, nw: int):
    if s > 9:
        return
    c[nw] += 1
    solve(s)
    for j in range(nw, 10):
        dfs(s + j, j)
    c[nw] -= 1


for i in range(1, 10):
    dfs(i, i)
print(ans)
```

Q731

```Python
N = 10 ** 16
'''
模拟除法。
如果需要计算1/k的后面第n位小数，那么就是计算10^(n-1)/k后面的第1位小数。
根据题目要求，这题并不关心除k之后的整数部分。
另外(10^(n-1)%k)/k和10^(n-1)/k的小数部分相同。
'''
f = 0
i = 0
while True:
    if N < 3 ** i + 1:
        break
    f += pow(10, N - 3 ** i - 1, 3 ** i) / 3 ** i
    f -= int(f)
    i += 1
ans = str(f)[2:][:10]
print(ans)

```

Q739

```C++
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const int N = 1e8;
const int M = N*2;
const int n=N-1;
ll mod=1e9+7;
ll inv(ll n,ll p){
    ll ans=1,m=p-2;
    for(;m;m>>=1){
        if(m&1) ans=ans*n%mod;
        n=n*n%mod;
    }
    return ans;
}

int *fac,*finv;
int l[N+4],invn=inv(n,mod);
int C(int n,int m){
    return 1ll*fac[n]*finv[m]%mod*finv[n-m]%mod;
}
int T(int n,int k){
    //A106566
    if(n==0) return 0;
    else return 1ll*C(2*n-k-1,n-k)*k%mod*invn%mod;
}
int main(){
    fac = new int[M+4];
    finv = new int[M+4];
    fac[0]=fac[1]=1;
    finv[0]=1;
    for(int i=2;i<=M;i++)
        fac[i]=1ll*fac[i-1]*i%mod;
    finv[M]=inv(fac[M],mod);
    for(int i=M-1;i>0;i--)
        finv[i]=1ll*finv[i+1]*(i+1)%mod;
    int x=1,y=3;
    int ans=0;
    for(int i=0;i<=n;i++){
        ans=(ans+1ll*T(n,i)*x)%mod;
        int t=(x+y)%mod;
        x=y;y=t;
    }
    delete fac;
    delete finv;
    printf("%d\n",ans);
}
```

Q745

```C++
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=10000004;
int f[N],mod=1e9+7;// Jordan function J_2(n)
int pr[N/4],v[N],m=0;
int main(){
    f[1]=1;
    ll k=1e14;
    ll ans=k;
    int n=sqrt(k);
    for(int i=2;i<=n;i++){
        if(v[i]==0){
            v[i]=i;f[i]=(1ll*i*i-1)%mod;
            pr[++m]=i;
        }
        for(int j=1;j<=m;j++){
            if(pr[j]>v[i]||pr[j]>n/i) break;
            v[i*pr[j]]=pr[j];
            if(pr[j]==v[i]) f[i*pr[j]]=1ll*f[i]*pr[j]*pr[j]%mod;
            else f[i*pr[j]]=1ll*f[i]*(1ll*pr[j]*pr[j]-1)%mod;
        }
        ans=(ans+1ll*f[i]*(k/(1ll*i*i)%mod))%mod;
    }
    printf("%lld\n",ans);
}
```

Q749

```C++
#include <bits/stdc++.h>
# define mem(a,b) memset(a,b,sizeof(a))
typedef long long ll;
using namespace std;
const int N=16;
const ll M=1e16;
const int O=64;
ll pw[14][66];
int c0[10],c1[10];
int n;
vector<ll>a;
bool ok(ll x){
    memcpy(c1,c0,sizeof(c1));
    for(int i=0;i<N;i++,x/=10)
        if(--c1[x%10]<0) return 0;
    return x==0;
}
void dfs(int k,int n,int p,ll s){
    if(p==0){
        c0[0]=n;
        if(ok(s-1))
            a.push_back(s-1);
        if(ok(s+1)) a.push_back(s+1);
        return;
    }
    for(int i=0;i<=n;i++){
        if(pw[p][k]==-1) break;
        c0[p]=i;
        dfs(k,n-i,p-1,s+pw[p][k]*i);
    }
}

int main(){
    mem(pw,-1);
    pw[0][0]=1;
    for(int j=1;j<O;j++)
        pw[0][j]=0;
    for(int i=0;i<10;i++){
        pw[i][0]=1;
        for(int j=1;j<O;j++){
            pw[i][j]=pw[i][j-1]*i;
            if(i>0&&pw[i][j]>M/i) break;
        }
    }
    for(int k=2;k<=N;k++)
        dfs(k,N,9,0);
    ll ans=0;
    sort(a.begin(),a.end());
    for(ll x:a)
        ans+=x;
    printf("%lld\n",ans);
}

```

Q751

```Python
l, r, n = 2, 3, 30
for _ in range(100):
    theta = 0.5 * (l + r)
    b = [theta]
    a = [int(theta)]
    for i in range(n):
        b.append(int(b[-1]) * (b[-1] - int(b[-1]) + 1))
        a.append(int(b[-1]))
    tau = str(a[0]) + "."
    for i in range(1, n):
        tau += str(a[i])
    tau = float(tau)
    if tau < theta:
        r = theta
    else:
        l = theta
print("{}.".format(a[0]) + "".join(str(x) for x in a[1:])[:24])
```

Q754

```C++
# include <bits/stdc++.h>
using namespace std;
const int N=10002,M=100000000;
bool b[N];
int a[2004],p=0;
int pr[N],q=0;
int mod=1000000007;
int qpow(int n,int m){
    int ans=1;
    for(;m;m>>=1){
        if(m&1) ans=1ll*ans*n%mod;
        n=1ll*n*n%mod;
    }
    return ans;
}
void fact(int x){
    p=0;
    for(int i=1;i<=q&&pr[i]*pr[i]<=x;++i){
        if(x%pr[i]==0){
            a[p++]=pr[i];
            for(;x%pr[i]==0;x/=pr[i]);
        }
    }
    if(x!=1) a[p++]=x;
}
int main(){
    for(int i=2;i<N;++i){
        if(b[i]) continue;
        pr[++q]=i;
        for(int j=i*i;j<N;j+=i)
            b[j]=1;
    }
    int ans=1;
    for(int i=2;i<=M;i++){
         fact(i);
         int s=0;
         for(int st=0;st<(1<<p);st++){
             int m=1,c=0;
             for(int i=0;i<p;i++)
                if(st>>i&1) m*=a[i],++c;
             if(c&1) s-=(M-i)/m;
             else s+=(M-i)/m;
         }
         ans=1ll*ans*qpow(i,s)%mod;
    }
    printf("%d\n",ans);
}

```

Q755

```Python
f = [1, 2]
s = [1, 3]
N = 10 ** 13
for i in range(100):
    w = f[-1] + f[-2]
    if w > N:
        break
    f.append(w)
    s.append(s[-1] + w)


def dfs(fl: int, now: int):
    if now < 0:
        return 0
    if fl == -1:
        return 1
    elif s[fl] <= now:
        return 1 << (fl + 1)
    else:
        return dfs(fl - 1, now) + dfs(fl - 1, now - f[fl])


print(dfs(len(f) - 1, N))
```

Q757

```Python
N = 10**14
lm2 = int(N ** 0.5 + 2)
lm4 = int(N ** 0.25 + 2)
st = set()
for dis in range(1, lm4):
    for mid in range(dis, lm2):
        u = mid * dis
        if u > lm2:
            break
        v, a, b = u - dis, mid + u - dis - 1, mid + u
        n = a * u
        if n > N:
            break
        if n == b * v:
            st.add(n)
print(len(st)-1)
```

Q788

```Python
N = 2022
mod = 10 ** 9 + 7
C = [[0 for i in range(j + 1)] for j in range(N + 1)]
for i in range(N + 1):
    C[i][0] = C[i][i] = 1
    for j in range(1, i):
        C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod
ans = 0
for n in range(1, N + 1):
    ans += 9
    for i in range(n // 2 + 1, n):
        ans = (ans + 9 * C[n - 1][i - 1] * pow(9, n - i, mod) + 9 * C[n - 1][i] * pow(9, n - i, mod)) % mod
print(ans)
```

Q793

```C++
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const int N=1000003;
ll S[N+4],m=(1ll*N*(N-1)/2+1)>>1;
bool ok(ll x){
    ll ans=0;
    for(int i=0;i<N;i++){
        ll w=x/S[i];
        int p=upper_bound(S,S+N,w)-S;
        if(p<=i) break;
        ans+=p-i-1;
    }
    return ans>=m;
}
int main(){
    S[0]=290797;
    for(int i=1;i<N;i++)
        S[i]=S[i-1]*S[i-1]%50515093;
    sort(S,S+N);
    ll l=1,r=1e17;
    while(l<r){
        ll mid=(l+r)>>1;
        if(ok(mid)) r=mid;
        else l=mid+1;
    }
    printf("%lld\n",l);
}

```
