Q202

```Python
# 原问题可化为求满足以下条件的(a,b)有多少对。
# 1.a+b=(n+3)/2
# 2.gcd(a,b)=1
N = 12017639147
N = (N + 3) >> 1
i = 1
div = []
while i * i <= N:
    if N % i == 0:
        div.append(i)
        if i * i != N:
            div.append(N // i)
    i += 1
div.sort()
ans = {}
for r in div:
    val = r // 3 + r % 3 + 1  # 1~r中与3-3%r同余的数的个数。
    for l in div:
        if l >= r:
            break
        if r % l == 0:
            val -= ans[l]
    ans[r] = val
print(ans[N])
```

Q208

```Python
M = 70
N = M // 5
st = {1}
ans = 0
C = [[0 for x in range(N + 1)] for y in range(N + 1)]
for i in range(N + 1):
    C[i][0] = C[i][i] = 1
    for j in range(i):
        C[i][j] = C[i - 1][j - 1] + C[i - 1][j]
for r in range(N + 1):
    ans += (C[N][r] ** 5) * (N ** 4 + r ** 4 - 3 * r * (N ** 3) + 4 * r * r * N * N - 2 * N * (r ** 3)) // (N ** 4)
print(ans)
```

Q210

```Python
R = 10**9
cr = (2 ** 0.5) / 8 * R
cx = cy = R / 8
eps = 1e-9
ans = 0
for x in range(ceil(cx - cr - eps), floor(cx + cr + eps) + 1):
    d = (cr ** 2 - (cx - x) ** 2) ** 0.5
    up = ceil((cy + d - eps))
    down = floor(cy - d + eps)
    ans += up - down - 1
    if down < x < up:
        ans -= 1
row = int(R // 2 * 1.5)
ans -= row
ans += row * (2 * R + 1)
print(ans)
```

Q212

```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int M = 10004;
const int N = 50000;
int k = 0, n, m;
struct B
{
    int x, y1, y2,k;
    bool operator < (B t) const { return x < t.x; }
}b[M*10];
struct ST
{
    int cnt,len;
}t[M << 3];
int raw[M << 1];
int c[M << 1];
void pushdown(int l, int r, int p){
    if (t[p].cnt) t[p].len = raw[r + 1] - raw[l];
    else if (l == r) t[p].len = 0;
    else t[p].len = t[p << 1].len + t[p << 1 | 1].len;
}
void update(int L, int R, int l, int r, int p, int v){
    if (L <= l && R >= r){
        t[p].cnt += v;
        pushdown(l, r, p);
        return;
    }
    int mid = (l + r) >> 1;
    if (L <= mid) update(L, R, l, mid, p << 1, v);
    if (R > mid) update(L, R, mid + 1, r, p << 1 | 1, v);
    pushdown(l, r, p);
}
int S[N*6+4],xa[N+4],ya[N+4],za[N+4],xb[N+4],yb[N+4],zb[N+4];
int Z=10400;
int main() {
    for (int i = 1; i <= N * 6; i++) {
        if (i <= 55) S[i] = (300007ll * i * i * i - 200003ll * i + 100003ll) % 1000000;
        else S[i] = (S[i - 24] + S[i - 55]) % 1000000;
    }
    for (int i = 1; i <= N; i++) {
        xa[i] = S[6 * i - 5] % 10000;
        ya[i] = S[6 * i - 4] % 10000;
        za[i] = S[6 * i - 3] % 10000;
        xb[i] = xa[i] + S[6 * i - 2] % 399 + 1;
        yb[i] = ya[i] + S[6 * i - 1] % 399 + 1;
        zb[i] = za[i] + S[6 * i] % 399 + 1;
    }
    ll ans = 0;
    for (int h = 0; h < Z; h++) {
        if (h % 1000 == 0) printf("%d\n", h);
        k = m = 0;
        memset(t, 0, sizeof(t));
        for (int i = 1; i <= N; i++) {
            if (!(za[i] <= h && h < zb[i])) continue;
            b[k++] = {xa[i], ya[i], yb[i], 1};
            b[k++] = {xb[i], ya[i], yb[i], -1};
            raw[++m] = ya[i];
            raw[++m] = yb[i];
        }
        sort(raw + 1, raw + m + 1);
        m = unique(raw + 1, raw + 1 + m) - (raw + 1);
        sort(b, b + k);
        for (int i = 0; i < k - 1; i++) {
            int l = lower_bound(raw, raw + k, b[i].y1) - raw;
            int r = lower_bound(raw, raw + k, b[i].y2) - raw - 1;
            update(l, r, 1, k, 1, b[i].k);
            ans += t[1].len * (b[i + 1].x - b[i].x);
        }
    }
    printf("%lld", ans);
}
```

Q215

```C++
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const int N=4004,Q=32,C=10;
vector<int>g[N];
int a[N],m=0;
ll f[C+1][N];
void dfs(int f,ll s){
    if(f>Q) return;
    else if(f==Q){
        a[++m]=s^1ll<<Q;
        return;
    }
    else{
        dfs(f+2,s|1ll<<(f+2));
        dfs(f+3,s|1ll<<(f+3));
    }
}
int main(){
    dfs(0,0);
    for(int i=1;i<=m;i++)
        for(int j=i+1;j<=m;j++)
            if((a[i]&a[j])==0){
                g[i].push_back(j);
                g[j].push_back(i);
            }
    for(int j=1;j<=m;j++)
        f[1][j]=1;
    for(int i=2;i<=C;i++)
        for(int u=1;u<=m;u++)
            for(int v:g[u])
                f[i][v]+=f[i-1][u];
    ll ans=0;
    for(int j=1;j<=m;j++)
        ans+=f[C][j];
    printf("%lld\n",ans);
}
```

Q217

```Python
def solve(n: int):
    if n == 1:
        return 45
    m = n >> 1
    lf = [[0 for j in range(9 * m + 1)] for i in range(m + 1)]
    lc = [[0 for j in range(9 * m + 1)] for i in range(m + 1)]
    for j in range(1, 10):
        lf[1][j] = j
        lc[1][j] = 1
    for i in range(1, m):
        for j in range(9 * i + 1):
            if lf[i][j] == 0 and lc[i][j] == 0:
                continue
            for k in range(10):
                lc[i + 1][j + k] = (lc[i + 1][j + k] + lc[i][j]) % mod
                lf[i + 1][j + k] = (lf[i + 1][j + k] + lf[i][j] * 10 + lc[i][j] * k) % mod
    rf = [[0 for j in range(9 * m + 1)] for i in range(m + 1)]
    rc = [[0 for j in range(9 * m + 1)] for i in range(m + 1)]
    for j in range(10):
        rf[1][j] = j
        rc[1][j] = 1
    for i in range(1, m):
        for j in range(9 * i + 1):
            if rf[i][j] == 0 and rc[i][j] == 0:
                continue
            for k in range(10):
                rc[i + 1][j + k] = (rc[i + 1][j + k] + rc[i][j]) % mod
                rf[i + 1][j + k] = (rf[i + 1][j + k] + rf[i][j] * 10 + rc[i][j] * k) % mod
    ans = 0
    for j in range(9 * m + 1):
        if n % 2 == 0:
            ans += lf[m][j] * (10 ** m) * rc[m][j] + rf[m][j] * lc[m][j]
        else:
            ans += lf[m][j] * (10 ** (m + 1)) * rc[m][j] * 10 + rf[m][j] * lc[m][j] * 10 + 45 * (10 ** m) * lc[m][j] * \
                   rc[m][j]
        ans %= mod
    return ans


ans = 0
for i in range(1, M + 1):
    ans = (ans + solve(i)) % mod
print(ans)
```

Q219

```Python
N = 10 ** 9
N -= 1
M = 100
ans = 0
b = [0, 0, 0, 0, 0, 1, 1, 1]
for i in range(M):
    b.append(b[-1] + b[-4])
for i in range(M):
    cnt = min(N, b[i])
    ans += cnt * i
    N -= cnt
print(ans)
# OEIS A003269
```

Q220

```Python
N = 50
M = 10 ** 12
a = [(0, 0, 0) for _ in range(N + 1)]
b = [(0, 0, 0) for _ in range(N + 1)]
M -= 1


def fun(now: tuple, dif: tuple):
    dir = (now[2] + dif[2] + 4) % 4
    if now[2] == 0:
        x, y = now[0] + dif[0], now[1] + dif[1]
    elif now[2] == 1:
        x, y = now[0] - dif[1], now[1] + dif[0]
    elif now[2] == 2:
        x, y = now[0] - dif[0], now[1] - dif[1]
    else:
        x, y = now[0] + dif[1], now[1] - dif[0]
    return x, y, dir


def dfs(x: int, y: int, d: int, f: int, M: int, flag: int):
    if M == 0:
        return x, y
    # a->aRbFR
    val = (1 << (f - 1)) - 1
    if flag == 0:
        if M < val:
            return dfs(x, y, d, f - 1, M, 0)
        x, y, d = fun((x, y, d), a[f - 1])
        x, y, d = fun((x, y, d), (0, 0, -1))
        M -= val
        if M < val:
            return dfs(x, y, d, f - 1, M, 1)
        else:
            x, y, d = fun((x, y, d), b[f - 1])
            x, y, d = fun((x, y, d), (0, 1, 0))
            return x, y
    else:
        x, y, d = fun((x, y, d), (0, 0, 1))
        x, y, d = fun((x, y, d), (0, 1, 0))
        M -= 1
        if M < val:
            return dfs(x, y, d, f - 1, M, 0)
        M -= val
        x, y, d = fun((x, y, d), a[f - 1])
        x, y, d = fun((x, y, d), (0, 0, 1))
        return dfs(x, y, d, f - 1, M, 1)


for i in range(1, N + 1):
    a[i] = fun(a[i], a[i - 1])  # a->aRbFR
    a[i] = fun(a[i], (0, 0, -1))
    a[i] = fun(a[i], b[i - 1])
    a[i] = fun(a[i], (0, 1, 0))
    a[i] = fun(a[i], (0, 0, -1))
    b[i] = fun(b[i], (0, 0, 1))  # b->LFaLb
    b[i] = fun(b[i], (0, 1, 0))
    b[i] = fun(b[i], a[i - 1])
    b[i] = fun(b[i], (0, 0, 1))
    b[i] = fun(b[i], b[i - 1])
x, y, d = 0, 1, 0
ax, ay = dfs(x, y, d, N, M, 0)
print("{},{}".format(ax, ay))
```

Q221

```C++
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const int M=80000;
int P=150000;
const ll MX=1e18;
vector<int>pr;
vector<ll>divs;
bool vis[M+1];
ll p[14];
int e[14],m=0;
void fact(ll n){
    m=0;
    for(ll x:pr){
        if(x*x>n) break;
        if(n%x==0){
            p[++m]=x;
            e[m]=0;
            for(;n%x==0;n/=x,++e[m]);
        }
    }
    if(n!=1){
        p[++m]=n;e[m]=1;
    }
}
void dfs(int f,ll s){
    if(f==m+1){
        divs.push_back(s);
        return;
    }
    for(int i=0;i<=e[f];i++){
        dfs(f+1,s);
        s*=p[f];
    }
}
int main(){
    set<ll>st;
    for(int i=2;i<=M;i++){
        if(vis[i]) continue;
        pr.push_back(i);
        for(int j=i+i;j<=M;j+=i)
            vis[j]=1;
    }
    int cnt=0;
    for(ll p=1;p<=M;p++){
        fact(p*p+1);
        divs.clear();
        dfs(1,1);
        sort(divs.begin(),divs.end());
        for(ll d:divs){
            if(d>p) break;
            if(p*(p+d)>MX/(p+(p*p+1)/d)) continue;
            st.insert(p*(p+d)*(p+(p*p+1)/d));
            ++cnt;
        }
    }
    ll ans=0;
    for(ll x:st){
        if(--P==0){
            ans=x;break;
        };
    }
    printf("%lld\n",ans);
}
```

Q223

```C++
# include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const int N=25000000;
const int M=N/3.4;//2+sqrt(2)
ll ccmbb=0,a;
int pr[M/5],v[M+1],m=0;
int p[24],e[24],tot;
void fact(int n){
    for(int i=1;i<=m&&pr[i]*pr[i]<=n;i++){
        if(n%pr[i]==0){
            p[++tot]=pr[i];
            e[tot]=0;
            for(;n%pr[i]==0;n/=pr[i],++e[tot]);
        }
    }
    if(n!=1){
        p[++tot]=n;e[tot]=1;
    }
}
int ans=(N-1)>>1;
void dfs(int f,ll cmb){
    if(cmb>a) return;
    if(f==tot+1){
        ll cpb=ccmbb/cmb;
        if(((cpb+cmb)&1)==0){
            ll c=(cpb+cmb)>>1,b=(cpb-cmb)>>1;
            if(a<=b&&a+b+c<=N) ++ans;
        }
        return;
    }
    for(int i=0;i<=e[f];i++){
        dfs(f+1,cmb);
        cmb*=p[f];
    }
}
int main(){
    for(int i=2;i<=M;i++){
        if(v[i]==0){
            pr[++m]=i;v[i]=i;
        }
        for(int j=1;j<=m;j++){
            if(pr[j]>v[i]||pr[j]>M/i) break;
            v[i*pr[j]]=pr[j];
        }
    }
    for(a=2;a<=M;a++){
        tot=0;
        ccmbb=(a+1)*(a-1);
        int e2=0,x,y;
        for(x=a-1;(x&1)==0;x>>=1,++e2);
        for(y=a+1;(y&1)==0;y>>=1,++e2);
        fact(x);fact(y);
        if(e2) p[++tot]=2,e[tot]=e2;
        dfs(1,1);
    }
    printf("%lld\n",ans);
}
```

Q224

```C++
# include <bits/stdc++.h>
# define pi pair<int,int>
# define X first
# define Y second
using namespace std;
typedef long long ll;
const int N=75000000;
const int M=N/2;
bool pk[M+4];
int pr[M+4],v[M+4],m=0;
int a[104],tot=0;
vector<pi>ps[M+4];
pi merge(pi pa,pi pb){
    return pi(pa.X*pb.X+pa.Y*pb.Y,pb.Y*pa.X-pb.X*pa.Y);
}
int ans=0;
void dfs(int f,int c,pi pa){
    if(f==tot+1){
        if(0<pa.X&&pa.X<=pa.Y){
            int s=c+2*pa.X+2*pa.Y;
            if(s<=N) ++ans;
        }
        return;
    }
    for(pi &pb:ps[a[f]])
        dfs(f+1,c,merge(pa,pb));
}
int fact(int n){
    int ans=1;
    while (n!=1){
        int p=v[n],val=1,e=0;
        for(;v[n]==p;n/=p,++e,val*=p);
        if(p%4==3){
            if(e%2==1) return 0;
            for(;e;e-=2) ans*=p;
        } else a[++tot]=val;
    }
    return ans;
}

int main(){
    for(int i=2;i<=M;i++){
        if(v[i]==0){
            v[i]=i;pr[++m]=i;
        }
        for(int j=1;j<=m;j++){
            if(pr[j]>v[i]||pr[j]>M/i) break;
            v[i*pr[j]]=pr[j];
        }
    }
    for(int i=1;i<=m;i++){
        ll p=pr[i];
        for(;p<=M;p*=pr[i])
            pk[p]=1;
    }
    for(int a=0;a*a<M;a++)
        for(int b=1;;b++){
            int s=a*a+b*b;
            if(s>M) break;
            if(pk[s]) ps[s].push_back(pi(a,b));
        }
    for(int c=1;c*2+1<=M;c++){
        tot=0;
        int w=fact(c+1);
        w*=fact(c);
        if(w==0) continue;
        dfs(1,c*2+1,pi(-w,0));
        dfs(1,c*2+1,pi(w,0));
        dfs(1,c*2+1,pi(0,w));
        dfs(1,c*2+1,pi(0,-w));
    }
    printf("%d\n",ans);
}
// 若a^2+b^2=c^2-1
// 则令a=2u,b=2v,c=2*w+1
// 故有u^2+v^2=w(w+1)，通过公式(u^2+v^2)(A^2+B^2)=(uA+vB)^2+(vA-uB)^2进行变化，合并。
```

Q227

```C++
# include <bits/stdc++.h>
using namespace std;
const int N=54;
double a[N][N];
void gauss(int n){
    for(int i=0;i<n;i++){
        for(int j=i;j<n;j++)
            if(abs(a[j][i])>1e-8){
                swap(a[j],a[i]);
                break;
            }
        if(abs(a[i][i])<1e-8) continue;
        for(int j=0;j<n;j++){
            if(j==i) continue;
            double r=a[j][i]/a[i][i];
            for(int k=i;k<=n;k++)
                a[j][k]-=a[i][k]*r;
        }
    }
}
int main(){
    int n=100;
    int m=n>>1;
    for(int i=0;i<m;i++){
        for(int j=1;j<=6;j++)
            for(int k=1;k<=6;k++){
                int x=1,y=i+1;
                if(j==1) ++x;
                else if(j==6) --x;
                if(k==1) ++y;
                else if(k==6) --y;
                int w=abs(x-y);
                ++a[i][min(w,n-w)];
            }
        a[i][i]-=36;
        a[i][m+1]=-36;
    }
    a[m][m]=1;
    gauss(m+1);
    printf("%f\n",a[0][m+1]/a[0][0]);
}
```

Q228

```Python
st = set()
l, r = 1864, 1909
for n in range(l, r + 1):
    for i in range(n):
        st.add(Fraction(i, n))
print(len(st))

```

Q230

```Python
N = 17
A = "1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679"
B = "8214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196"
D = [len(A), len(B)]
for i in range(100):
    D.append(D[-1] + D[-2])


def getdigit(f: int, pos: int):
    if f == 0:
        return A[pos - 1]
    elif f == 1:
        return B[pos - 1]
    else:
        if pos <= D[f - 2]:
            return getdigit(f - 2, pos)
        else:
            return getdigit(f - 1, pos - D[f - 2])


ans = ""
for n in range(N + 1):
    p = (127 + 19 * n) * (7 ** n)
    for i in range(100):
        if D[i] >= p:
            ans += getdigit(i, p)
            break
ans = ans[::-1]
print(ans)
```

Q232

```Python
N = 100
win1 = lose1 = 0.5
f = [[0 for j in range(N + 1)] for i in range(N + 1)]
for p1 in range(N + 1):
    for p2 in range(N + 1):
        if p2 == 0:
            f[p1][p2] = 1
        elif p1 == 0:
            f[p1][p2] = 0
        else:
            mul = 1
            while True:
                win2 = 0.5 / mul
                lose2 = 1.0 - win2
                next2 = max(p2 - mul, 0)
                nw = win1 * win2 * f[p1 - 1][next2] + lose1 * win2 * f[p1][next2] + win1 * lose2 * f[p1 - 1][p2]
                nw /= 1 - lose1 * lose2
                f[p1][p2] = max(f[p1][p2], nw)
                if next2 == 0:
                    break
                mul <<= 1
ans = lose1 * f[N][N] + win1 * f[N - 1][N]
print("{:.8f}".format(ans))
```

Q233

```C++
# include <bits/stdc++.h>
# define pl pair<ll,int>
# define X first
# define Y second
using namespace std;
typedef long long ll;
const ll N=1e11;
const int M=5000000,O=600000;
priority_queue<pl,vector<pl>,greater<pl>>q;
ll v1[O],p1=0,v3[O],p3=0;
ll a[O],n=0,b[O],m=0;
bool vis[M+4];
ll qpow(ll n,int m){
    ll ans=1;
    for(;m;m>>=1){
        if(m&1) ans=ans*n;
        n=n*n;
    }
    return ans;
}
int main(){
    for(int i=2;i<=M;i++){
        if(vis[i]) continue;
        if(i%4==1) v1[++p1]=i;
        else v3[++p3]=i;
        for(int j=i+i;j<=M;j+=i)
            vis[j]=1;
    }
    for(int i=1;i<=p1;i++){
        ll x=v1[i]*v1[i]*v1[i];
        if(x>N) break;
        for(int j=1;j<=p1;j++){
            if(j==i) continue;
            ll y=x*v1[j]*v1[j];
            if(y>N) break;
            for(int k=1;k<=p1;k++){
                if(k==i||k==j) continue;
                ll z=y*v1[k];
                if(z>N) break;
                a[++n]=z;
            }
        }
    }
    for(int i=1;i<=p1;i++){
        ll x=qpow(v1[i],7);
        if(x>N) break;
        for(int j=1;j<=p1;j++){
            if(j==i) continue;
            ll y=x*v1[j]*v1[j]*v1[j];
            if(y>N) break;
            a[++n]=y;
        }
    }
    for(int i=1;i<=p1;i++){
        ll x=qpow(v1[i],10);
        if(x>N) break;
        for(int j=1;j<=p1;j++){
            if(j==i) continue;
            ll y=x*v1[j]*v1[j];
            if(y>N) break;
            a[++n]=y;
        }
    }
    sort(a+1,a+n+1);
    ll MX=N/a[1];
    b[++m]=1;
    for(int i=1;i<=p3&&v3[i]<=MX;i++)
        q.push(pl(v3[i],i));
    while(!q.empty()){
        pl pa=q.top();q.pop();
        b[++m]=pa.X;
        for(int i=pa.Y;i<=p3;i++){
            ll x=pa.X*v3[i];
            if(x>MX) break;
            q.push(pl(x,i));
        }
    }
    ll ans=0;
    for(int l=1,r=m;l<=n;l++){
        for(;r>0&&a[l]*b[r]>N;--r);
        for(int i=1;i<=r;i++)
            ans+=a[l]*b[i];
    }
    printf("%lld\n",ans);
    //A046109
}
```

Q236

```C++
# include <bits/stdc++.h>
# define pi pair<int,int>
# define X first
# define Y second
using namespace std;
typedef long long ll;
const ll N=1e11;
const int M=5000000,O=600000;
int gcd(int a,int b){
    return b?gcd(b,a%b):a;
}
struct F{
    int x,y;
    F(int xx=0):x(xx),y(1){};
    F(int xx=0,int yy=1){
        int g=gcd(xx,yy);
        xx/=g;yy/=g;
        x=xx;y=yy;
    };
    F operator + (F f){
        int xx=x*f.y+y*f.x,yy=y*f.y;
        int g=gcd(xx,yy);
        xx/=g;yy/=g;
        return F(xx,yy);
    }
    F operator * (F f){
        int xx=x*f.x,yy=y*f.y;
        int g=gcd(xx,yy);
        xx/=g;yy/=g;
        return F(xx,yy);
    }
    F reverse(){
        return F(y,x);
    }
    bool operator < (F f) const{
        return x*f.y<y*f.x;
    }
    void print(){
        printf("%d/%d\n",x,y);
    }
};
map<F,unordered_map<int,vector<pi>>>mp;
int la[5]={1312,5248,5760};
int lb[5]={1888,640,3776};
int sa=la[0]*6+la[1]+la[2];
int sb=lb[0]*6+lb[1]+lb[2];
F rs=F(sb,sa);
// a0x+b0y=c0
// a1x+b1y=c1
pi cal(ll a0,ll b0,ll c0,ll a1,ll b1,ll c1){
    ll c=a0*b1-a1*b0;
    if(c==0) return pi(-1,-1);
    ll x=c0*b1-c1*b0,y=a0*c1-a1*c0;
    if(x%c||y%c) return pi(-1,-1);
    return pi(x/c,y/c);
}
bool solve(F r,vector<pi>&v0,vector<pi>&v1,vector<pi>&v2){
    r=r.reverse();
    set<pi>s0(v0.begin(),v0.end());
    F f(v0[0].X,v0[0].Y);
    for(pi &p1:v1)
        for(pi &p2:v2){
            pi pa=cal(f.y,-f.x,0,r.y*sb,-r.x*sa,1ll*(p1.Y+p2.Y)*r.x*sa-1ll*(p1.X+p2.X)*r.y*sb);
            if(s0.count(pa)) return 1;
        }
    return 0;
}
int main(){
    for(int k=0;k<3;k++){
        int x=la[k],y=lb[k];
        int st=1,ed=1;
        if(k==0) st=3,ed=6;
        for(int j=1;j<=y;j++){
            for(int i=1;i<=x&&i*y<j*x;i++){
                if(gcd(i,j)!=1) continue;
                F f=F(i*y,j*x);
                if(k&&!mp.count(f)) continue;
                for(int m=st;j*m<=y*ed;m++){
                    mp[f][k].push_back(pi(m*i,m*j));
                }
            }
        }
    }
    for(auto it=mp.begin();it!=mp.end();it++){
        if(it->Y.size()==3){
            auto &v=it->Y;
            if(solve(it->X,v[0],v[1],v[2])){
                F f=it->X;
                f.reverse().print();
                break;
            }
        }
    }
}
```

Q238

```Python
Q = int(2e15)
s, mod = 14025256, 20300713


def get_BlumBlumShub(s: int, mod: int):
    ls = [s]
    st = set(ls)
    while True:
        s = s * s % mod
        if s in st:
            break
        st.add(s)
        ls.append(s)
    return ls


a = [0]
for v in get_BlumBlumShub(s, mod):
    a += [int(x) for x in str(v)]
presum = [0]
n = len(a) - 1
for i in range(1, n + 1):
    presum.append(presum[-1] + a[i])
m = presum[-1]
for i in range(1, 101):
    presum.append(presum[-1] + a[i])
st = set(presum)
f = [0 for i in range(m + 1)]
for k in range(1, m + 1):
    for p in range(1, len(presum) + 1):
        if k + presum[p - 1] in st:
            f[k] = p
            break
q, r = divmod(Q, m)
ans = sum(f) * q + sum(f[:r + 1])
print(ans)
```

Q239

```Python
N = 100
n = 25  # 一共25个质数
m = 22
C = [[0 for x in range(y + 1)] for y in range(N + 1)]
for i in range(N + 1):
    C[i][0] = C[i][i] = 1
    for j in range(1, i):
        C[i][j] = C[i - 1][j - 1] + C[i - 1][j]
fac = [1]
for i in range(1, N + 1):
    fac.append(fac[-1] * i)
f = [[0 for x in range(y + 1)] for y in range(m + 1)]  # A047920
for i in range(m + 1):
    f[i][0] = fac[i]
    for j in range(1, i + 1):
        f[i][j] = f[i][j - 1] - f[i - 1][j - 1]
mul = C[n][n - m]
ans = 0
for i in range(m + 1):
    ans += C[m][i] * C[N - n][m - i] * fac[N - n] * f[m][i] * mul
print("{:.12f}".format(ans / fac[N]))
```

Q240

```Python
from collections import Counter

N = 20
M = 12
C = 10
S = 70
MX = S // C
al = [0 for i in range(N - C)]
ar = [0 for i in range(C)]
ls = [[] for i in range(M + 1)]
fac = [1]
for i in range(1, N + 1):
    fac.append(fac[-1] * i)
ans = 0


def cal(a: list):
    s = fac[N]
    mp = Counter(a)
    for x in mp.values():
        s //= fac[x]
    return s


def dfs1(f: int, pre: int):
    if f == N - C:
        ls[al[-1]].append(al.copy())
        return
    for i in range(pre, MX + 1):
        al[f] = i
        dfs1(f + 1, i)


def dfs2(f: int, pre: int, now: int):
    if now < C - f or now > M * (C - f):
        return
    if f == C:
        global ans
        for i in range(1, ar[0] + 1):
            for v in ls[i]:
                ans += cal(v + ar)
        return
    for i in range(pre, M + 1):
        ar[f] = i
        dfs2(f + 1, i, now - i)


dfs1(0, 1)
dfs2(0, 1, S)
print(ans)
```

Q241

```Python
N = 10 ** 18
ans = 0


def dfs(n: int, fz: int, fm: int):
    if n * fz > N or gcd(n, fm) != 1 or fz < fm:
        return
    if fm == 1:
        if fz == 1:
            global ans
            ans += n
        return
    p = naive_factorization(fm)[0][0]
    e = 1
    while fm % p ** (e + 1) == 0:
        e += 1
    for i in range(e, 100):
        nw = n * p ** i
        if nw > N:
            break
        newfz = fz * p ** i
        newfm = fm * (p ** (i + 1) - 1) // (p - 1)
        g = gcd(newfz, newfm)
        dfs(nw, newfz // g, newfm // g)


for i in range(3, 19, 2):
    dfs(1, i, 2)
print(ans)
```

Q242

```Python
# 观察f[i][j]三角形易得出答案。
N = 10 ** 12
N = (N - 1) // 4 + 1
s = bin(N)[2:]
s = s[::-1]
l = len(s)
C = [[0 for x in range(y + 1)] for y in range(l + 1)]
for i in range(l + 1):
    C[i][0] = C[i][i] = 1
    for j in range(1, i):
        C[i][j] = C[i - 1][j - 1] + C[i - 1][j]
cnt = [0 for i in range(l + 1)]
now = 0
for i in range(l - 1, -1, -1):
    if s[i] == '1':
        for j in range(i + 1):
            cnt[now + j] += C[i][j]
        now += 1
ans = 0
for i in range(l+1):
    ans += cnt[i]*2**i
print(ans)
```

Q243

```Python
pr = []
N = 30
fz, fm = 15499, 94744
flag = [0 for _ in range(N + 1)]
for i in range(2, N + 1):
    if flag[i] == 0:
        pr.append(i)
        for j in range(i * i, N + 1, i):
            flag[j] = 1

ans = 10 ** 50
for i in range(1, 30):
    ph = 2 ** (i - 1)
    v = 2 ** i
    for j in range(1, len(pr)):
        v *= pr[j]
        ph *= pr[j] - 1
        if v >= ans:
            break
        if ph * fm < fz * (v - 1):
            ans = v
            break
print(ans)
```

Q244

```Python
from queue import Queue


def encode(a: list):
    ans = 0
    for i in range(4):
        for j in range(4):
            ans = ans * 3 + a[i][j]
    return ans


dis = {}
val = {}
mod = 100000007
dx = [0, 0, -1, 1]
dy = [-1, 1, 0, 0]
code = [82, 76, 68, 85]
st = [[0, 1, 2, 2], [1, 1, 2, 2], [1, 1, 2, 2], [1, 1, 2, 2]]
ed = [[0, 2, 1, 2], [2, 1, 2, 1], [1, 2, 1, 2], [2, 1, 2, 1]]
dis[encode(st)] = 0
val[encode(st)] = [0]
q = Queue()
q.put(st)
while not q.empty():
    u = q.get()
    pre = encode(u)
    for i in range(16):
        if u[i >> 2][i & 3] == 0:
            x, y = i >> 2, i & 3
            break
    for k in range(4):
        nx, ny = x + dx[k], y + dy[k]
        if nx < 0 or ny < 0 or nx >= 4 or ny >= 4:
            continue
        v = [a.copy() for a in u]
        v[nx][ny], v[x][y] = v[x][y], v[nx][ny]
        now = encode(v)
        if now not in dis.keys():
            dis[now] = dis[pre] + 1
            val[now] = []
            q.put(v)
        if dis[now] == dis[pre] + 1:
            for w in val[pre]:
                val[now].append((w * 243 + code[k]) % mod)
print(sum(val[encode(ed)]))
```

Q245

```Python
# semiprimes
N = 2 * 10 ** 11
ls = []
M = int(N ** 0.5)
ans = 0
flag = [0 for _ in range(M + 1)]
pr = []
for i in range(2, M + 1):
    if flag[i] == 0:
        pr.append(i)
        for j in range(i * i, M + 1, i):
            flag[j] = 1
a = [p * (p - 1) + 1 for p in range(M + 1)]
fact = [{} for _ in range(M + 1)]
for i in range(1, len(pr)):
    p = pr[i]
    q = (p - 1) ** 2 + 1
    if p * q > N:
        break
    if Miller_Rabin(q):
        ans += p * q
        ls.append(p * q)
for i in range(2, M + 1, 3):
    a[i] //= 3
for i in range(3, M + 1):
    d = a[i]
    if d <= 1:
        continue
    for k in range(M // d + 1):
        j = i + k * d
        for p in [j, j + d - 2 * i + 1]:
            if p > M:
                break
            fact[p][d] = 0
            while a[p] % d == 0:
                a[p] //= d
                fact[p][d] += 1
for x in pr:
    if len(fact[x].keys()) == 0:
        continue
    n = x * (x - 1) + 1
    p = sorted(fact[x].keys())
    e = [fact[x][w] for w in p]
    c = [0 for i in range(len(fact[x]))]
    d = 1
    while True:
        for i in range(len(p)):
            c[i] += 1
            d *= p[i]
            if d * d <= n and c[i] <= e[i]:
                break
            d //= p[i] ** c[i]
            c[i] = 0
        else:
            break
        q = ((x - d) * (x - 1) + 1) // d
        if q < x or x * q > N or not Miller_Rabin(q):
            continue
        ans += x * q
        ls.append(x * q)


# multiprime
def isp(n: int):
    if n <= M:
        return not flag[n]
    else:
        for x in pr:
            if x * x > n:
                break
            if n % x == 0:
                return 0
        return 1


def dfs(pt: int, n: int, ph: int, q: int):
    fz = n - ph
    k = (q * n - 1) // (ph + q * fz) + 1
    if k & 1:
        k += 1
    num = k * ph + 1
    fm = n - k * fz
    ph2 = ph << 1
    fz2 = fz << 1
    while fm > 0:
        d = num // fm
        if n * d > N:
            break
        if isp(d) and num - d * fm == 0:
            ls.append(n * d)
        fm -= fz2
        num += ph2
    for i in range(pt, len(pr)):
        if n * pr[i] ** 2 > N:
            break
        dfs(i + 1, n * pr[i], ph * (pr[i] - 1), pr[i])


for i in range(1, len(pr)):
    # print(pr[i])
    if pr[i] ** 3 > N:
        break
    for j in range(i + 1, len(pr)):
        if pr[i] * pr[j] ** 2 > N:
            break
        dfs(j + 1, pr[i] * pr[j], (pr[i] - 1) * (pr[j] - 1), pr[j])
ls.sort()
print(sum(ls))
```

Q246

```Python
from math import sqrt, floor, ceil
import sys

a = 7500
c = 5000
b = sqrt(a * a - c * c)
a2 = a * a
c2 = c * c
b2 = a2 - c2
eps = 1e-10
cnt2 = cnt4 = 0
x0 = 0
prer = (a + 4) * (a + 4)
while True:
    if x0 != a:
        if x0 < a:
            y0 = ceil(sqrt(b2 * (1 - x0 * x0 / a2)))
        else:
            y0 = 0
        l = y0
        r = prer
        while l < r:
            mid = (l + r + 1) >> 1
            A = x0 * x0 - a2
            B = -2 * x0 * mid
            C = mid * mid - b2
            D = B * B - 4 * A * C
            k = [(-B - sqrt(D)) / (2 * A), (-B + sqrt(D)) / (2 * A)]
            tg = (k[1] - k[0]) / (1 + k[0] * k[1])
            if 0 < tg <= 1:
                r = mid - 1
            else:
                l = mid
        if l == 0:
            break
        if x0 == 0:
            cnt2 += l - y0 + 1
        elif y0 > 0:
            cnt4 += l - y0 + 1
        else:
            cnt4 += l
            cnt2 += 1
        prer = l
    else:
        y0 = 1
        while True:
            k = (y0 * y0 - b2) / (2 * x0 * y0)
            if k >= 1:
                break
            cnt4 += 1
            y0 += 1
    x0 += 1
ans = cnt2 * 2 + cnt4 * 4
print(ans)
# 联立x^2/a^2+y^2/b^2=1和y-y0=k(x-x0)，得出一个关于x的一元二次方程。
# 由于是切线，令这个方程的delta为0后，得出一个关于k的一元二次方程。
# k的解即为两条切线斜率。
```

Q247

```Python
from queue import PriorityQueue
from math import sqrt


def get(sx: int, sy: int, vx: int, vy: int):
    A = 1
    B = sy - sx
    C = -1
    D = B * B - 4 * A * C
    x = (-B + sqrt(D)) / (2 * A)
    r = x - sx
    return -r, sx, sy, vx, vy


ax, ay = 3, 3
q = PriorityQueue()
r = (1 + sqrt(5)) / 2 - 1
q.put((-r, 1, 0, 0, 0))
i = 1
ans = 0
while True:
    r, sx, sy, x, y = q.get()
    r = -r
    if r < 5e-4:
        break
    if x == ax and y == ay:
        ans = i
        # break
    i += 1
    q.put(get(sx + r, sy, x + 1, y))
    q.put(get(sx, sy + r, x, y + 1))
print(ans)
```

Q248

```Python
I = 13
Q = 150000
a = 1
for i in range(1, I + 1):
    a *= i
lt = []
ls = []
fact = naive_factorization(a)
p = [v[0] for v in fact]
e = [v[1] for v in fact]
m = len(p)
for i in range(1, int(a ** 0.5) + 1):
    if a % i == 0:
        lt.append(i)
        if i * i != a:
            lt.append(a // i)
for d in lt:
    if Miller_Rabin(d + 1):
        fact = naive_factorization(d)
        mp = {}
        for v in fact:
            mp[v[0]] = v[1]
        v = []
        for x in p:
            if x in mp.keys():
                v.append(mp[x])
            else:
                v.append(0)
        ls.append((d, tuple(v)))
ls.sort()
ans = []


def dfs(pos: int, n: int, st: set, now: list, res: int):
    ok = 1
    for i in range(m):
        if now[i] and p[i] not in st:
            ok = 0
            break
    if ok:
        ans.append(n * res)
    for i in range(pos, len(ls)):
        if res % ls[i][0] == 0:
            for j in range(m):
                now[j] -= ls[i][1][j]
            st.add(ls[i][0] + 1)
            dfs(i + 1, n * (ls[i][0] + 1), st, now, res // ls[i][0])
            for j in range(m):
                now[j] += ls[i][1][j]
            st.remove(ls[i][0] + 1)


dfs(0, 1, set(), e, a)
ans.sort()
print(ans[Q-1])
```

Q252

```Python
N = 500


class V:
    def __init__(self, x: int, y: int):
        self.x, self.y = x, y

    def __add__(self, other):
        return V(self.x + other.x, self.y + other.y)

    def __sub__(self, other):
        return V(self.x - other.x, self.y - other.y)

    def __mul__(self, other):
        return self.x * other.y - self.y * other.x

    def __str__(self):
        return "({}, {})".format(self.x, self.y)

    def __lt__(self, other):
        return atan2(self.y, self.x) < atan2(other.y, other.x)


S = [290797]
T = []
ans = 0


def solve(p: list):
    m = len(p)
    p.sort()
    global ans
    dp = [[0 for j in range(m)] for i in range(m)]
    for i in range(m):
        j = i - 1
        while j >= 0 and p[i] * p[j] == 0:
            j -= 1
        flag = (j == i - 1)
        while j >= 0:
            k = j - 1
            while k >= 0 and (p[i] - p[k]) * (p[j] - p[k]) > 0:
                k -= 1
            s = abs(p[i] * p[j])
            if k >= 0:
                s += dp[j][k]
            if flag:
                dp[i][j] = s
            ans = max(ans, s)
            j = k
        if flag:
            for j in range(1, i):
                dp[i][j] = max(dp[i][j], dp[i][j - 1])


for i in range(N + N):
    S.append(S[-1] * S[-1] % 50515093)
for x in S:
    T.append(x % 2000 - 1000)
pts = []
for i in range(2, N + N + 1, 2):
    pts.append(V(T[i - 1], T[i]))
for p in pts:
    ls = []
    for q in pts:
        if q.y > p.y or q.y == p.y and q.x > p.x:
            ls.append(q - p)
    solve(ls)
print(ans / 2)
'''
枚举每个点，作为原点O。把在点O下面或在O点的正左向的所有点抛弃。
dp[i][j]表示最后一个三角形为Oij
(i>j)的点。那么满足dp[i][j]=\max(dp[j][k]+三角形Oij的面积)，其中k只能在向量ij的右侧以保证这个多边形是凸的。
对于j0=i-1，三角形Oij0一定是个合法的三角形，如果O,i,j0三点共线，那么顺时针找j0，找到第一个与Oi不共线为止。
然后找最大的j1，使得j1在向量ij0右侧，此时经排序后三角形ij0j1中不包含任何点。故有转移dp[i][j0]=max(dp[i][j0],dp[i][j1]+三角形Oij1的面积)。这将可以进行快速转移。并且，不合法的Oij的值最终为0。并且，j1之前的点都可以由此转移而来。
设g[i][j]=max(dp[i][k],1<=k<=j), 因此dp[i][j0]=g[j0][j1]+三角形Oij0的面积。
'''
```

Q253

```Python
N = 40
M = (N + 1) >> 1
mp = [[{} for j in range(M + 1)] for i in range(N + 1)]


def insert(i: int, j: int, mq: dict, suf: list, val: int):
    if suf[0] > suf[1]:
        suf[0], suf[1] = suf[1], suf[0]
    ls = []
    for u, v in mq.items():
        if v > 0:
            ls.append((u, v))
    ls.sort()
    ls = tuple(ls)
    lt = (ls, tuple(suf))
    if lt not in mp[i][j].keys():
        mp[i][j][lt] = 0
    mp[i][j][lt] += val


for i in range(1, N + 1):
    insert(1, 1, {}, [i - 1, N - i], 1)
for i in range(1, N):
    for j in range(1, M + 1):
        for tup, val in mp[i][j].items():
            tp = {}
            for x, y in tup[0]:
                tp[x] = y
            for x, y in tup[0]:
                for k in range(1, x + 1):
                    tq = tp.copy()
                    if k > 1:
                        if k - 1 not in tq.keys():
                            tq[k - 1] = 0
                        tq[k - 1] += 1
                    if k < x:
                        if x - k not in tq.keys():
                            tq[x - k] = 0
                        tq[x - k] += 1
                    tq[x] -= 1
                    s = max(j, sum(tq.values()) + 1)
                    insert(i + 1, s, tq, [tup[1][0], tup[1][1]], val * y)
            suf = tup[1]
            for r in range(2):
                for k in range(1, suf[r] + 1):
                    tq = tp.copy()
                    if k > 1:
                        if k - 1 not in tq.keys():
                            tq[k - 1] = 0
                        tq[k - 1] += 1
                    s = max(j, sum(tq.values()) + 1)
                    if r == 0:
                        insert(i + 1, s, tq, [suf[0] - k, suf[1]], val)
                    else:
                        insert(i + 1, s, tq, [suf[0], suf[1] - k], val)
s0 = s1 = 0
for i in range(1, M + 1):
    v = mp[N][i][((), (0, 0))]
    s0 += i * v
    s1 += v
print("{:.6f}".format(s0 / s1))
```

Q254

```C++
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int Q=150,B=19,S=9,MX=1e7;
const int W=362880,N=63;
ll pw[B],fac[B];
int dcnt[W][S],sd[W],cd[W];
int lq[N],pq[N][S];
bool ok(int a[],int b[]) {
    for (int i = 0; i < S; i++)
        if (a[i] != b[i]) return a[i] < b[i];
    return 0;
}
int main() {
    pw[0] = fac[0] = 1;
    for (int i = 1; i < B; i++)
        pw[i] = pw[i - 1] * 10, fac[i] = fac[i - 1] * i;
    // 每个数i，贪心取最大的值，尽量取完，然后再取最小的。dcnt[i][j]表示从i中分出dcnt[i][j]个fac[j]。
    // sd[i]= sum j=1^9 dcnt[i][j]*j, cd[i]表示i分出来的最少份数。
    for (int i = 0; i < W; i++) {
        for (int j = 8, t = i; j > 0; j--) {
            dcnt[i][j] = t / fac[j];
            sd[i] += dcnt[i][j] * j;
            cd[i] += dcnt[i][j];
            t %= fac[j];
        }
    }
    //1~62时直接暴力枚举。枚举范围是10^7。
    for (int r = 0; r <= MX; r++) {
        int a = r / W, b = r % W;
        int s = 0;
        for (int x = r; x; x /= 10)
            s += x % 10;
        if (s >= N) continue;
        if (lq[s] == 0 || lq[s] > cd[b] + a || lq[s] == cd[b] + a && ok(pq[s], dcnt[b])) {
            lq[s] = cd[b] + a;
            for (int i = 0; i < S; i++)
                pq[s][i] = dcnt[b][i];

        }
    }
    ll ans = 0;
    for (int i = 1; i <= Q && i < N; i++) {
        ans += lq[i] * 9;
        for (int j = 1; j < S; j++)
            ans -= pq[i][j] * (9 - j);
    }
    //63以后全部贪心取9。
    for (int i = N; i <= Q; i++) {
        long long t = (i % 9 + 1) * pw[i / 9] - 1;
        ans += (t / W) * 9 + sd[t % W];
    }
    printf("%lld\n", ans);
}
```

Q260

```C++
#include <bits/stdc++.h>
const int N = 1000;

bool P1[N+1][N+1];
bool P2[N+1][N+1];
bool P3[N+1][N+1];
/*
当前是必败态，那么后继的都是必胜态。假设在每一堆中取的是s个石头。
用P1[y-x][z-y]表示后继状态{x-s,y-s,z-s}
P2[x][y-x]表示{x,y-s,z-s}
P2[y][z-x]表示{x-s,y,z-s}
P2[z][y-x]表示{x-s,y-s,z}
P3[x][y]表示{x,y,z-s}
P3[x][z]表示{x,y-s,z}
P3[y][z]表示{x-s,y,z}
 */
int main() {

    long long int ct = 0;
    for (int x = 0; x <= N; x++)
        for (int y = x; y <= N; y++)
            for (int z = y; z <= N; z++) {
                if (!(P1[y - x][z - y] || P2[z][y - x] || P2[y][z - x] || P2[x][z - y] || P3[y][z] || P3[x][z] ||
                      P3[x][y])) {
                    P1[y - x][z - y] = 1;
                    P2[z][y - x] = 1;
                    P2[y][z - x] = 1;
                    P2[x][z - y] = 1;
                    P3[x][y] = 1;
                    P3[x][z] = 1;
                    P3[y][z] = 1;
                    //printf("%d %d %d\n",x,y,z);
                    ct += x + y + z;
                }

            }
    printf("%lld\n", ct);
}
```

Q265

```Python
N = 5
M = 1 << N
g = [[] for i in range(M)]
vis = [0 for i in range(M)]
a = [0 for i in range(M)]
vis[0] = 1
ans = 0


def dfs(f: int):
    if f == M - 1:
        if a[-1] == (M >> 1):
            s = 0
            for i in range(M - N + 1):
                s = s << 1 | (a[i] & 1)
            global ans
            ans += s
        return
    for v in g[a[f]]:
        if vis[v]:
            continue
        vis[v] = 1
        a[f + 1] = v
        dfs(f + 1)
        vis[v] = 0


for i in range(M):
    for j in range(M):
        if i == j:
            continue
        x = bin(i)[2:]
        y = bin(j)[2:]
        x = '0' * (N - len(x)) + x
        y = '0' * (N - len(y)) + y
        if x[1:] == y[:-1]:
            g[i].append(j)
dfs(0)
print(ans)
```

Q267

```Python
d = 10 ** -5
M = 10 ** 9
M = log2(M)
f = d
N = 1000
mn = N
while f <= 1:
    l, r = 0, N
    while l < r:
        mid = (l + r) >> 1
        if mid * log2(1 + 2 * f) + (N - mid) * log2(1 - f) >= M:
            r = mid
        else:
            l = mid + 1
    mn = min(mn, l)
    f += d
C = [[0 for x in range(y + 1)] for y in range(N + 1)]
for i in range(N + 1):
    C[i][0] = C[i][i] = 1
    for j in range(1, i):
        C[i][j] = C[i - 1][j - 1] + C[i - 1][j]
s0, s1 = 0, 1 << N
for i in range(mn, N + 1):
    s0 += C[N][i]
ans = s0 / s1
print("{:.12f}".format(ans))
```

Q268

```Python
N = 10 ** 16 - 1
lp, ln = [], []
pr = Get_Primes(100)
cnt = [0 for i in range(len(pr) + 1)]


def dfs(f: int, n: int, v: int):
    if n > N:
        return
    if f == len(pr):
        cnt[v] += N // n
        return
    dfs(f + 1, n, v)
    dfs(f + 1, n * pr[f], v + 1)


dfs(0, 1, 0)
ans = 0
flag = True
for i in range(4, len(cnt)):
    if flag:
        ans += cnt[i] * (i - 1) * (i - 2) * (i - 3) // 6
    else:
        ans -= cnt[i] * (i - 1) * (i - 2) * (i - 3) // 6
    flag = not flag
print(ans)
```

Q271

```Python
pr = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]  # 13082761331670030=2*3*5*7*11*13*17*19*23*29*31*37*41*43


def ex_gcd(a: int, b: int):
    if b == 0:
        return 1, 0, a
    else:
        x, y, g = ex_gcd(b, a % b)
        return y, x - (a // b) * y, g


def solve_ax_plus_by_is_c(a: int, b: int, c: int):
    if a < 0:
        a, b, c = -a, -b, -c
    x, y, g = ex_gcd(a, b)
    if c % g != 0:
        return None
    ma = abs(a // g)
    mc = c // g
    x *= mc
    y *= mc
    y = (y % ma + ma) % ma
    x = (c - b * y) // a
    return x, y, abs(g)


def CRT(a1: int, m1: int, a2: int, m2: int):  # 中国剩余定理
    # m1*t==a2-a1(mod m2)
    t = solve_ax_plus_by_is_c(m1, m2, a2 - a1)[0]
    x = (a1 + t * m1) % (m1 * m2)
    return x


solpr = {}
for x in pr:
    solpr[x] = []
    for i in range(x):
        if i ** 3 % x == 1:
            solpr[x].append(i)
sol = solpr[pr[0]]
mul = pr[0]
for i in range(1, len(pr)):
    tmp = []
    for n in sol:
        for m in solpr[pr[i]]:
            tmp.append(CRT(n, mul, m, pr[i]))
    mul *= pr[i]
    sol = tmp
if 1 in sol:
    sol.remove(1)
print(sum(sol))
```

Q273

```C++
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 150;
vector<int> a, u, v;
int main() {
    for (int i = 5; i < N; i += 4) {
        bool isp = true;
        for (int j = 2; j * j <= i; j++)
            if (i % j == 0) isp = false;
        if (isp) {
            a.push_back(i);
            for (int j = 1; j <= i; j++)
                for (int k = j; k <= i; k++)
                    if (j * j + k * k == i) {
                        u.push_back(j);
                        v.push_back(k);
                        break;
                    }
        }
    }
    ll ans = 0;
    int m = a.size();
    int msk = pow(3, m);
    for (int s = 1; s < msk; s++) {
        int t = s;
        ll a = 0, b = 1;
        for (int i = 0; i < m; i++) {
            int d = t % 3;
            t /= 3;
            if (d == 1) {
                ll p = u[i], q = v[i];
                ll y = a * p + b * q, z = abs(a * q - b * p);
                a = y;
                b = z;
            } else if (d == 2) {
                ll p = v[i], q = u[i];
                ll y = a * p + b * q, z = abs(a * q - b * p);
                a = y;
                b = z;
            }
        }
        if (a > b) swap(a, b);
        ans += a;
    }
    printf("%lld\n", ans >> 1);
}
```

Q277

```Python
def ex_gcd(a: int, b: int):
    if b == 0:
        return 1, 0, a
    else:
        x, y, g = ex_gcd(b, a % b)
        return y, x - (a // b) * y, g


N = 10 ** 15
s = "UDDDUdddDDUDDddDdDddDDUDDdUUDd"
k = Fraction(1)
b = Fraction(0)
for ch in s:
    if ch == 'U':
        k = k * 4 / 3
        b = (b * 4 + 2) / 3
    elif ch == 'D':
        k /= 3
        b /= 3
    else:
        k = k * 2 / 3
        b = (b * 2 - 1) / 3
a, n, c = k.numerator, k.denominator, -b.numerator
x, y, g = ex_gcd(a, n)
x = x * c % n
d = (N - x + n - 1) // n
ans = x + d * n
print(ans)
```

Q286

```Python
N = 50
M = 20
Q = 0.02
l = N
r = N << 1
for _ in range(100):
    q = 0.5 * (l + r)
    f = [[0 for i in range(M + 1)] for j in range(N + 1)]
    f[0][0] = 1
    for i in range(N):
        rt = 1 - (i + 1) / q
        for j in range(M + 1):
            if f[i][j] == 0:
                continue
            if j < M:
                f[i + 1][j + 1] += f[i][j] * rt
            f[i + 1][j] += f[i][j] * (1 - rt)
    if f[N][M] > Q:
        l = q
    else:
        r = q
    print(f[N][M])
print("{:.10f}".format(l))
```

Q288

```Python
Q = 10 ** 7
P = 61
mod = 61 ** 10
S = [290797]
for i in range(1, Q + 1):
    S.append(S[-1] ** 2 % 50515093)
T = []
for x in S:
    T.append(x % P)
ans = 0
s = 0
for i in range(Q, 0, -1):
    s = (s * P + T[i]) % mod
    ans = (ans + s) % mod
print(ans)
```

Q293

```Python
pr = [2, 3, 5, 7, 11, 13, 17, 19, 23]
N = 10 ** 9
st = set()


def solve(n: int):
    m = 2
    while m <= 100000:
        if Miller_Rabin(n + m):
            return m
        m += 1
    return -1


def dfs(f: int, n: int):
    if f == len(pr):
        return
    for k in range(100):
        n *= pr[f]
        if n >= N:
            break
        st.add(solve(n))
        dfs(f + 1, n)


dfs(0, 1)
ans = sum(st)
print(ans)
```

Q294

```C++
# include <bits/stdc++.h>
# define mem(a,b) memset(a,b,sizeof(a))
using namespace std;
typedef long long ll;
const ll N=3138428376721;
const int M=23*24;
ll a[M],b[M][M],mod=1e9;
ll c[M][M]={0};
void mul_self(ll b[M][M]){
    mem(c,0);
    for(int i=0;i<M;i++)
        for(int k=0;k<M;k++)
            for(int j=0;j<M;j++)
                c[i][j]=(c[i][j]+b[i][k]*b[k][j])%mod;
    memcpy(b,c,sizeof(c));
}
void mul(ll a[M],ll b[M][M]){
    ll c[M]={0};
    for(int i=0;i<M;i++)
        for(int k=0;k<M;k++)
            c[i]=(c[i]+a[k]*b[k][i])%mod;
    memcpy(a,c,sizeof(c));

}
int enc[23][24],m=0;
int main(){
    for(int i=0;i<23;i++)
        for(int j=0;j<24;j++)
            enc[i][j]=m++;
    for(int i=0;i<10;i++)
        a[enc[i][i]]=1;
    for(int i=0;i<23;i++)
        for(int j=0;j<24;j++)
            for(int k=0;k<10&&j+k<24;k++){
                b[enc[i][j]][enc[(i*10+k)%23][j+k]]=1;
            }
    for(ll m=N-1;m;m>>=1){
        if(m&1) mul(a,b);
        mul_self(b);
    }
    ll ans=a[enc[0][23]];
    printf("%lld\n",ans);
}
//todo Thread

```

Q297

```Python
N = 10 ** 17 - 1
f = [1, 2]
mp = {0: 0, 1: 1, 2: 2, 3: 3}
while True:
    f.append(f[-1] + f[-2])
    if f[-1] > N:
        break


def dfs(n: int):
    if n in mp.keys():
        return mp[n]
    p = 0
    while p + 1 < len(f) and f[p + 1] <= n:
        p += 1
    ans = dfs(f[p] - 1) + dfs(n - f[p]) + n - f[p] + 1
    mp[n] = ans
    return ans


print(dfs(N))
```

Q300

```C++
# include <bits/stdc++.h>
# define pi pair<int,int>
# define X first
# define Y second
# define lb(x) ((x) & -(x))
using namespace std;
typedef long long ll;
const int N=15;
int f[N+N+4][N+N+4];
int dx[4]={-1,1,0,0},dy[4]={0,0,-1,1};
int ans[1<<N];
//将每个接触面进行编码。z[i][j]表示第i个格子和第j个格子相邻。
//显而易见的是，如果第i个格子和第j个相邻，那么i和j不同奇偶性。
ll z[N][N];
int x[N*N],y[N*N];
unordered_set<ll>st;
void dfs(int fl,int px,int py,ll s){
    for(int i=0;i<4;i++){
        int nx=px+dx[i],ny=py+dy[i];
        if(f[nx][ny]!=-1){
            s|=1ll<<z[fl-1][f[nx][ny]];
        }
    }
    if(fl==N){
        st.insert(s);
        return;
    }
    for(int i=0;i<4;i++){
        int nx=px+dx[i],ny=py+dy[i];
        if(f[nx][ny]==-1){
            f[nx][ny]=fl;
            dfs(fl+1,nx,ny,s);
            f[nx][ny]=-1;
        }
    }

}
const int B=16,M=(1<<16)-1;
int bits[1<<B];
int calbits(ll x){
    int ans=0;
    for(;x;x>>=B)
        ans+=bits[x&M];
    return ans;
}
//计算出对应的分子。
int solve(){
    memset(f,-1,sizeof(f));
    if(N==1) return 1;
    int m=0;
    for(int i=0;i<N;i+=2)
        for(int j=1;j<N;j+=2){
            x[m]=i;y[m]=j;
            z[i][j]=z[j][i]=m++;
        }
    f[N][N]=0;f[N][N+1]=1;
    dfs(2,N,N+1,z[0][1]);
    int sum=0;
    for(int s=0;s<(1<<N);s++){
        int mx=0;
        ll y=0;
        for(int i=0;i<N;i+=2)
            for(int j=1;j<N;j+=2)
                if((s>>i&1)&&(s>>j&1))
                    y|=1ll<<z[i][j];
        for(ll x:st)
            mx=max(mx,calbits(x&y));
        sum+=mx;
    }
    return sum;
}
int main(){
    for(int i=0;i<(1<<B);i++)
        for(int j=0;j<B;j++)
            bits[i]+=i>>j&1;
    int fz=solve(),fm=1<<N;
    int g=__gcd(fz,fm);
    fz/=g;fm/=g;
    int pw2=log2(fm+1e-6);
    double ans=1.0*fz/fm;
    printf("%.*f\n",pw2,ans);
}

```

Q301

```Python
k = 30
f = [1, 2]
for i in range(k):
    f.append(f[-1] + f[-2])
print(f[k])
```

Q303

```Python
N = 10 ** 4
O = 10
M = 3 ** O
Euler_sieve(int(10 ** (O / 2)))
f = [0 for i in range(N + 1)]
st = {i for i in range(1, N + 1)}


def dfs(fl: int, v: int, n: int, ls: list):
    if v > N:
        return
    if fl == len(ls):
        if f[v] == 0:
            f[v] = n // v
            st.remove(v)
        return
    p, e = ls[fl]
    for i in range(e + 1):
        dfs(fl + 1, v, n, ls)
        v *= p


a = []
for i in range(1, M):
    x, y, pw = 0, i, 1
    while y:
        x += y % 3 * pw
        pw *= 10
        y //= 3
    a.append(x)
    print(x, len(st))
    dfs(0, 1, x, factorization(x))
    ls = []
    for v in st:
        if x % v == 0:
            f[v] = x // v
            ls.append(v)
        for v in ls:
            st.remove(v)
for x in st:
    ml, mr = {}, {}
    mr[0] = 0
    con = 10 ** O % x
    for v in a:
        l = con * v % x
        r = v % x
        if l not in ml.keys():
            ml[l] = v
        if r not in mr.keys():
            mr[r] = v
    flag = 1
    ans = 10 ** 30
    for modl, l in ml.items():
        modr = (x - modl) % x
        if modr in mr.keys():
            ans = min(ans, l * 10 ** O + mr[modr])
    f[x] = ans // x
print(sum(f))
```

Q306

```Python
N = 10 ** 6
a = [0, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 0, 5, 2, 2, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 2, 7, 4, 0, 1, 1, 2,
     0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 2, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4]
z = [8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4]
ans = 0
for i in range(min(N, len(a))):
    if a[i] > 0:
        ans += 1
if N > len(a):
    N -= len(a)
    block, res = divmod(N, len(z))
    ans += block * (len(z) - z.count(0)) + res - z[:res].count(0)
print(ans)
```

Q307

```C++
# include <bits/stdc++.h>
typedef long double ld;
using namespace std;
const int K=20000,N=1000000;
ld fac[N+K+2];
ld A(int n,int m){
    return fac[n]-fac[n-m];
}
ld C(int n,int m){
    return fac[n]-fac[n-m]-fac[m];
}
int main(){
    for(int i=1;i<=N+K;i++)
        fac[i]=fac[i-1]+log(i);
    ld ans=0;
    for(int i=0;i<=K/2;i++){
        if(i>N||K-2*i>N-i) continue;
        ld val=C(N,i)+A(K,i*2)-log((ld)2)*i+A(N-i,K-i*2)-K*log(N);
        ans+=exp(val);
    }
    ans=(ld)1-ans;
    printf("%.10Lf\n",ans);
}
```

Q310

```C++
# include <bits/stdc++.h>
# define mem(a,b) memset(a,b,sizeof(a))
using namespace std;
typedef long long ll;
const int N=100000;
const int M=sqrt(N)/4+10;
int sg[N+4];
bool mex[M+4];
int cnt[M+4];
int main(){
    for(int i=1;i<=N;i++){
        mem(mex,0);
        for(int j=1;j*j<=i;j++)
            mex[sg[i-j*j]]=1;
        int j=0;
        for(;mex[j];++j);
        sg[i]=j;
        ++cnt[sg[i]];
    }
    ++cnt[0];
    int mx=*max_element(sg+1,sg+N+1);
    ll ans=0;
    for(int i=0;i<=mx;i++)
        for(int j=i+1;j<=mx;j++){
            int k=i^j;
            if(mx>=k&&k>j)
                ans+=1ll*cnt[i]*cnt[j]*cnt[k];
        }
    for(int i=1;i<=mx;i++)
        ans+=1ll*cnt[i]*(cnt[i]+1)/2*cnt[0];
    ans+=1ll*cnt[0]*(cnt[0]+1)*(cnt[0]+2)/6;
    printf("%lld\n",ans);
}

```

Q313

```Python
ans = 0
n = 1000000
pr = Get_Primes(n)
for p in pr:
    ans += ceil((p * p + 11) / 6) - floor((p * p + 13) / 8) - 1
ans <<= 1
print(ans)
```

Q315

```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2e7,M=1e7;
const int O=10,P=7;
int f1[N+4],f2[N+4];
int v[N+4],pr[N+4],m=0;
int b[O]={119, 36, 93, 109, 46, 107, 123, 39, 127, 111};
int g[O][O],c[1<<P];
int getnext(int n){
    int a=0;
    for(;n;n/=10)
        a+=n%10;
    return a;
}
int cal(int n){
    int a=0;
    for(;n;n/=10)
        a+=c[b[n%10]];
    return a;
}
int main(){
    for(int i=1;i<(1<<P);i++)
        for(int j=0;j<P;j++)
            if(i>>j&1) ++c[i];
    for(int i=2;i<=N;i++){
        if(v[i]==0) v[i]=i,pr[++m]=i;
        for(int j=1;j<=m;j++){
            if(pr[j]>v[i]||pr[j]>N/i) break;
            v[i*pr[j]]=pr[j];
        }
    }
    for(int i=0;i<O;i++)
        for(int j=0;j<O;j++)
            g[i][j]=c[b[i]&b[j]];
    for(int i=0;i<O;i++){
        f2[i]=f1[i]=c[b[i]]*2;
    }
    for(int i=O;i<=N;i++){
        int x=getnext(i);
        f1[i]=f1[x]+cal(i)*2;
        int d=0;
        for(int y=x,z=i;y;y/=10,z/=10)
            d+=g[y%10][z%10];
        f2[i]=f2[x]+cal(i)*2-d*2;

    }
    int ans=0;
    for(int i=1;i<=m;i++)
        if(pr[i]>=M)
            ans+=f1[pr[i]]-f2[pr[i]];
    printf("%d\n",ans);
}
```

Q329

```Python
s = "PPPPNNPPPNPPNPN"
N = 500
l = len(s)
f1 = Fraction(1, 3)
f2 = Fraction(2, 3)
f = [[Fraction(0, 1) for x in range(N + 1)] for y in range(l)]
pr = []
flag = [0 for _ in range(N + 1)]
flag[0] = flag[1] = 1
for i in range(2, N + 1):
    if flag[i] == 0:
        pr.append(i)
        for j in range(i * i, N + 1, i):
            flag[j] = 1
for j in range(1, N + 1):
    f[0][j] = Fraction(1, N)
    if (s[0] == 'P') ^ (not flag[j]):
        f[0][j] *= f1
    else:
        f[0][j] *= f2
for i in range(l - 1):
    for j in range(1, N + 1):
        if j == 1 or j == N:
            con = Fraction(1)
        else:
            con = Fraction(1, 2)
        if j > 1:
            if (s[i + 1] == 'P') ^ (not flag[j - 1]):
                f[i + 1][j - 1] += f[i][j] * f1 * con
            else:
                f[i + 1][j - 1] += f[i][j] * f2 * con
        if j < N:
            if (s[i + 1] == 'P') ^ (not flag[j + 1]):
                f[i + 1][j + 1] += f[i][j] * f1 * con
            else:
                f[i + 1][j + 1] += f[i][j] * f2 * con
print(sum(f[l - 1]))
```

Q336

```C++
#include <bits/stdc++.h>
using namespace std;
const int N=11,Q=2011;
int a[N],b[N];
int main(){
    a[0]=2;a[1]=0;a[2]=1;
    for(int i=3;i<N;i++)
        a[i]=i;
    int v=2*N-3,cnt=0;
    do{
        int c=0;
        memcpy(b,a,sizeof(a));
        for(int i=0,p=0;i<N;i++){
            if(b[i]==i) continue;
            if(b[N-1]!=i){
                for(p=i+1;b[p]!=i;p++);
                reverse(b+p,b+N);
                ++c;
            }
            reverse(b+i,b+N);
            ++c;
        }
        if(c==v&&++cnt==Q) break;
    }while(next_permutation(a,a+N));
    for(int i=0;i<N;i++)
        putchar('A'+a[i]);
    puts("");
}
```

Q343

```C++
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2e6;
//f(n)=n+1的最大质因数-1。
//n^3+1=(n+1)(n^2-n+1)
ll v1[N+4],b[N+4],v2[N+4];
int main(){
    for(int i=2;i<=N+1;i++){
        if(v1[i]==0){
            for(int j=i;j<=N+1;j+=i)
                v1[j]=i;
        }
    }
    for(int i=1;i<=N;i++)
        v1[i]=v1[i+1];
    for(int i=1;i<=N;i++)
        b[i]=1ll*i*i-i+1;
    for(int i=2;i<=N;i++){
        ll p=b[i];
        if(p==1) continue;
        for(ll j=i;j<=N;j+=p)
            while(b[j]%p==0)
                b[j]/=p,v2[j]=max(v2[j],p);
    }
    ll ans=0;
    for(int i=1;i<=N;i++)
        ans+=max(v1[i],v2[i])-1;
    printf("%lld\n",ans);
}

```

Q345

```C++
#include <bits/stdc++.h>
using namespace std;
const int N=16;
vector<int>g[N+1];
int f[1<<N];
int a[N][N];
int main(){
    freopen("r.txt","r",stdin);
    int n=15;
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            scanf("%d",&a[i][j]);
    for(int s=0;s<(1<<n);s++){
        int c=0;
        for(int i=0;i<n;i++)
            c+=s>>i&1;
        for(int i=0;i<n;i++){
            if(s>>i&1) continue;
            f[s|1<<i]=max(f[s|1<<i],f[s]+a[c][i]);
        }
    }
    printf("%d\n",f[(1<<n)-1]);
}
```

Q346

```Python
N = 10 ** 12
st = {1}
b = 1
while (1 << b) <= N:
    b += 1
for cnt in range(2, b + 1):
    base = 2
    while True:
        val = 1
        for i in range(cnt):
            val = val * base + 1
        if val > N:
            break
        st.add(val)
        base += 1
ans = sum(st)
print(ans)
```

Q347

```Python
pr = []
N = 10 ** 7
flag = [0 for _ in range(N + 1)]
for i in range(2, N + 1):
    if flag[i] == 0:
        pr.append(i)
        for j in range(i * i, N + 1, i):
            flag[j] = 1
ans = 0
for i in range(len(pr) - 1):
    if pr[i] * pr[i + 1] > N:
        break
    j = i + 1
    while j < len(pr):
        if pr[i] * pr[j] > N:
            break
        mx = 0
        x = pr[i]
        while x * pr[j] <= N:
            y = pr[j]
            while x * y <= N:
                mx = max(mx, x * y)
                y *= pr[j]
            x *= pr[i]
        j += 1
        ans += mx
print(ans)
```

Q348

```C++
#include <bits/stdc++.h>
# define X first
# define Y second
using namespace std;
int N=8e8,Q=5;
map<int,int>mp;
bool ok(int n){
    string s=to_string(n);
    int l=0,r=s.size()-1;
    for(;l<r&&s[l]==s[r];++l,--r);
    return l>=r;
}
int main(){
    for(int i=1;i*i*i<=N;i++){
        cout<<i<<endl;
        for(int j=1;i*i*i+j*j<=N;j++)
            ++mp[i*i*i+j*j];
    }
    int cnt=0;
    int s=0;
    for(auto it=mp.begin();it!=mp.end();it++)
        if(it->Y==4&&ok(it->X)){
            s+=it->X;
            if(++cnt==Q) break;
        }
    printf("%d\n",s);
}
```

Q349

```C++
#include <bits/stdc++.h>
# define pi pair<int,int>
# define X first
# define Y second
# define lb(x) ((x)&-(x))
using namespace std;
typedef long long ll;
const ll Q=1e18;
map<pi,int>mp;
int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};
const int N=100000;
int a[N+4],nxt[N+4];
int main(){
    int x=0,y=0;
    for(int i=1,k=0;i<=N;i++){
        pi pa(x,y);
        if(mp[pa]==0)
            k=(k-1)&3,a[i]=1;
        else
            k=(k+1)&3,a[i]=0;
        mp[pa]^=1;
        x+=dx[k];
        y+=dy[k];
    }
    map<int,int>mq;
    reverse(a+1,a+N+1);
    for(int i=2,j=0;i<=N;i++){
        while(j&&a[j+1]!=a[i]) j=nxt[j];
        if(a[j+1]==a[i]) ++j;
        nxt[i]=j;
        if(i%(i-nxt[i])==0)
            ++mq[i-nxt[i]];
    }
    int T=0,mx=0;
    ll ans=0;
    for(pi pa:mq)
        if(pa.Y>mx)
            tie(T,mx)=pa;
    reverse(a+1,a+N+1);
    if(Q<=N){
        for(int i=1;i<=Q;i++)
            if(a[i]) ++ans;
            else --ans;
    }
    else{
        ll nw=0;
        for(int i=1;i<=N;i++)
            if(a[i]) ++ans;
            else --ans;
        for(int i=0;i<T;i++)
            if(a[N-i]) ++nw;
            else --nw;
        ll g=(Q-N)/T,res=(Q-N)%T;
        ans+=g*nw;
        for(int i=1;i<=res;i++)
            if(a[N-T+i]) ++ans;
            else --ans;
    }
    printf("%lld\n",ans);
}
```

Q353

```C++
# include <bits/stdc++.h>
using namespace std;
const int N=100000,M=15;
typedef long long ll;
double pi=acos(-1.0);
bool vis[N+4];
ll x[N+4],y[N+4],z[N+4],r,m;
double d[N+4];
void add(int i,int j,int k){
    x[++m]=i;y[m]=j;z[m]=k;
    if(i>0){
        x[++m]=-i;y[m]=j;z[m]=k;
    }
}
double dis(int i,int j){
    ll v=x[i]*x[j]+max(y[i]*y[j]+z[i]*z[j],y[i]*z[j]+z[i]*y[j]);
    return pow(acos(1.0*v/r/r),2);
}
double solve(ll r){
    m=0;::r=r;
    for(ll i=0;i*i<=r*r;i++)
    for(ll j=i;i*i+j*j<=r*r;j++){
        ll k=sqrt(r*r-i*i-j*j+1e-10);
        if(i*i+j*j+k*k!=r*r) continue;
        if(k<j) break;
        add(i,j,k);
        if(i!=j) add(j,i,k);
        if(j!=k) add(k,i,j);
    }
    memset(vis,0,sizeof(vis));
    for(int i=1;i<=m;i++)
        d[i]=(x[i]==-r?0:1e100);
    int p;
    for(;;){
        p=0;
        for(int i=1;i<=m;i++){
            if(vis[i]) continue;
            if(p==0||d[i]<d[p]) p=i;
        }
        if(x[p]==r) break;
        vis[p]=1;
        for(int j=1;j<=m;j++)
            if(!vis[j])
                d[j]=min(d[j],d[p]+dis(p,j));
    }
    return d[p]/pi/pi;
}
int main(){
    double ans=0;
    for(int i=1;i<=M;i++){
        ans+=solve((1<<i)-1);
    }
    printf("%.10f\n",ans);
}

```

Q358

```Python
def is_primitive_root(a: int, p: int):
    pr = [v[0] for v in naive_factorization(p - 1)]
    for d in pr:
        if quick_power(a, (p - 1) // d, p) == 1:
            return False
    return True


left = "00000000137"
right = "56789"
val = float("0." + left)
ed = floor(1 / val)
val += 10 ** -len(left)
st = ceil(1 / val)
mod = 10 ** len(right)
ph = phi(mod)
modv = int(right)
for x in range(st // 2 * 2 + 1, ed + 1, 2):
    k = (quick_power(10, x - 1, mod) - 1) * quick_power(x, ph - 1, mod) % mod
    if k == modv and Miller_Rabin(x) and is_primitive_root(10, x):
        ans = (x - 1) // 2 * 9
        break
print(ans)
```

Q359

```Python
N = 71328803586048
mod = 10 ** 8


def cal(n: int, f: int):
    k = n >> 1
    if f == 0:
        return k * (k + 1) * (2 * k + 1) // 6 * 4
    else:
        return n * (n + 1) * (2 * n + 1) // 6 - k * (k + 1) * (2 * k + 1) // 6 * 4


def fun(n: int, k: int):
    if n == 0:
        return (k + 1) * (k + 2) // 2
    else:
        v = 2 * int((n + 1) // 2) + k
        if k % 2 == 0:
            f = 1
        else:
            f = -1
        return (cal(v, v & 1) - cal(v - k, v & 1)) - (cal(v - 1, (v & 1) ^ 1) - cal(v - k, (v & 1) ^ 1)) + f * (
                (n + 1) ** 2 // 2)


ans = 0
for x in Get_Divisors(N):
    ans = (ans + fun(x - 1, N // x - 1)) % mod
print("{:08}".format(ans))
# A083362
```

Q364

```C++
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int Q=1000000;
const int N=Q*2+4;
ll fac[N],inv[N],finv[N],pw2[N],mod=1e8+7;
ll C(int n,int m){
    return fac[n]*finv[n-m]%mod*finv[m]%mod;
}
ll cal(int Q){
    ll ans=0;
    for(int s=0;s<4;s++){
        int v1=s&1,v2=s>>1&1;
        for(int k=0;3*k<=Q-1-v1-v2;k++){
            int m=Q-1-v1-v2-3*k;
            if(m&1) continue;
            m>>=1;
            ans=(ans+fac[m+k+1]*C(m+k,m)%mod*pw2[k]%mod*fac[k+v1+v2]%mod*fac[m+k])%mod;
        }
    }
    return ans;
}
int main(){
    //A192008
    fac[0]=fac[1]=inv[1]=finv[0]=finv[1]=pw2[0]=1;
    pw2[1]=2%mod;
    for(int i=2;i<N;i++){
        fac[i]=fac[i-1]*i%mod;
        inv[i]=(mod-mod/i)*inv[mod%i]%mod;
        finv[i]=finv[i-1]*inv[i]%mod;
        pw2[i]=pw2[i-1]*2%mod;
    }
    printf("%lld\n",cal(Q));
}

```

Q365

```C++
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1e18,M=1e9;
const int L=1000,R=5000;
bool vis[R+4];
vector<int>pr,res;
int fac[R+4];
ll inv(ll n,ll p){
    ll a=1,m=p-2;
    for(;m;m>>=1){
        if(m&1) a=a*n%p;
        n=n*n%p;
    }
    return a;
}
ll ex_gcd(ll a,ll b,ll &x,ll &y){
    if(b==0){
        x=1;y=0;return a;
    }
    ll g=ex_gcd(b,a%b,x,y);
    ll z=x-(a/b)*y;
    x=y;y=z;return g;
}
//解不定方程ax+my=c。
ll congruence(ll a,ll c,ll m){
    ll x,y,g;
    g=ex_gcd(a,m,x,y);
    if(c%g!=0) return -1;
    x*=c/g;
    ll t=m/g;
    return (x%t+t)%t;
}
ll CRT(ll b,ll m,ll c,ll n){
    ll y=congruence(m,c-b,n);
    ll x=m*y+b;
    ll t=m*n;
    return (x%t+t)%t;
}
int C(int n,int m,int p){
    if(m>n) return 0;
    return fac[n]*inv(fac[m],p)%p*inv(fac[n-m],p)%p;
}
ll lucas(ll n,ll m,ll p){
    return n==0?1:C(n%p,m%p,p)*lucas(n/p,m/p,p)%p;
}
int main(){
    for(int i=2;i<R;i++){
        if(vis[i]) continue;
        if(i>L) pr.push_back(i);
        for(int j=i+i;j<R;j+=i)
            vis[j]=1;
    }
    for(int p:pr){
        fac[0]=1;
        for(int i=1;i<p;i++)
            fac[i]=fac[i-1]*i%p;
        res.push_back(lucas(N,M,p));
    }
    ll ans=0;
    for(int i=0;i<pr.size();i++)
        for(int j=0;j<i;j++){
            ll x=CRT(res[i],pr[i],res[j],pr[j]);
            for(int k=0;k<j;k++){
                ll y=CRT(x,pr[i]*pr[j],res[k],pr[k]);
                ans+=y;
            }
        }
    printf("%lld\n",ans);
}


```

Q371

```Python
k = 499
f = [[0, 0] for i in range(k + 2)]
for i in range(k, -1, -1):
    f[i][1] = (2 * (499 - i) * f[i + 1][1] + 1000) / (999 - i)
    f[i][0] = (2 * (499 - i) * f[i + 1][0] + f[i][1] + 1000) / (999 - i)
ans = f[0][0]
print("{:.8f}".format(ans))
```

Q375

```C++
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
int Q=2e9,T;
const int A=290797,M=50515093;
//容易知道，S1到后面为一个循环数组，其中周期为T。
int S[M*3];
int l[M*3],r[M*3];
void gen(int m){
    stack<int>st;
    for(int i=0;i<m;i++){
        while(!st.empty() && S[i] < S[st.top()])
            st.pop();
        if(st.empty()) l[i]=0;
        else l[i]=st.top()+1;
        st.push(i);
    }
    while(!st.empty())
        st.pop();
    for(int i=m-1;i>=0;i--){
        while(!st.empty() && S[i] < S[st.top()])
            st.pop();
        if(st.empty()) r[i]=m-1;
        else r[i]=st.top()-1;
        st.push(i);
    }
}
ll solve(){
    //由于S数组是一个循环数组，故分类处理。
    int mn=*min_element(S, S + T);
    ll res=1ll*Q*(Q+1)/2,ans=0;
    if(Q<=T*2){
        for(int i=T;i<Q;i++)
            S[i]=S[i-T];
        gen(Q);
        for(int i=0;i<Q;i++){
            ll tp=1ll*(i-l[i]+1)*(r[i]-i+1);
            ans+=tp*S[i];
            res-=tp;
        }
        ans+=res*mn;
    }
    else{
        for(int i=0;i<T;i++)
            S[i+T]=S[i+T+T]=S[i];
        int block=Q/T,rest=Q%T;
        gen(2*T+rest);
        for(int i=0;i<T;i++){
            ll tp=1ll*(i-l[i]+1)*(r[i]-i+1);
            ans+=tp*S[i];
            res-=tp;
            int j=2*T+rest-1-i;
            tp=1ll*(j-l[j]+1)*(r[j]-j+1);
            ans+=tp*S[j];
            res-=tp;
            tp=1ll*(i+T-l[i+T]+1)*(r[i]-i+1);
            ll c=block-2+(i<rest);
            ans+=tp*S[i]*c;
            res-=tp*c;
        }
        ans+=res*mn;
    }
    return ans;
}
int main(){
    S[0]=1ll*A*A%M;
    for(int i=1;i<M;i++){
        S[i]=1ll*S[i-1]*S[i-1]%M;
        if(S[i]==S[0]){
            T=i;break;
        }
    }
    printf("%lld\n",solve());
}
```

Q381

```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e8-1;
int pr[N+1],v[N+1],m=0;
int main(){
    ll inv2,inv3,inv4,inv6,inv24;
    ll ans=0;
    for(int i=2;i<=N;i++){
        if(v[i]==0){
            v[i]=i;pr[++m]=i;
            if(i>=5){
                inv2=(i+1)>>1;
                if(i%3==1) inv3=(i+i+1)/3;
                else inv3=(i+1)/3;
                inv4=inv2*inv2%i;
                inv6=inv2*inv3%i;
                inv24=inv4*inv2%i*inv3%i;
                ll s=(i+i-inv2-inv24+inv6)%i;
                ans+=s;
            }
        }
        for(int j=1;j<=m;j++){
            if(pr[j]>v[i]||pr[j]>N/i) break;
            v[i*pr[j]]=pr[j];
        }
    }
    printf("%lld\n",ans);
}
```

Q387

```Python
from Miller_Rabin import Miller_Rabin

ls = [[1, 2, 3, 4, 5, 6, 7, 8, 9]]
tp = [1, 3, 7, 9]


def is_Harshad(n: int):
    return n % sum(int(x) for x in str(n)) == 0


for i in range(12):
    ls.append([])
    for x in ls[i]:
        for j in range(10):
            t = x * 10 + j
            if is_Harshad(t):
                ls[i + 1].append(t)

ans = 0
for v in ls:
    for n in v:
        if not Miller_Rabin(n // sum(int(x) for x in str(n))):
            continue
        for y in tp:
            w = n * 10 + y
            if Miller_Rabin(w):
                ans += w
print(ans)
```

Q389

```C++
# include <bits/stdc++.h>
using namespace std;
vector<int>d={4,6,8,12,20};
int main(){
    int m=1;
    vector<double>fp1(2);
    fp1[1]=1;
    for(int x:d){
        vector<double>fp2(1,1);
        vector<double>fn1(m*x+1,0);
        for(int i=1;i<=m;i++){
            vector<double>fn2(x*i+1);
            for(int j=0;j<=x*(i-1);j++)
                for(int k=1;k<=x;k++)
                    fn2[j+k]+=fp2[j]/x;
            fp2=fn2;
            for(int j=1;j<=x*i;j++)
                fn1[j]+=fp1[i]*fp2[j];
        }
        fp1=fn1;
        m*=x;
    }
    double ex1=0,ex2=0;
    for(int i=1;i<=m;i++){
        ex1+=fp1[i]*i;
        ex2+=fp1[i]*i*i;
    }
    double ans=ex2-ex1*ex1;
    printf("%.4f\n",ans);
}
```

Q395

```C++
# include <bits/stdc++.h>
using namespace std;
const double eps = 1e-15;
double minx = 0, miny = 0, maxx = 1, maxy = 1;
double leftRotate = acos(0.8);
//直接将正方形的下边旋转约180-53度。
double rightRotate = -acos(0.6);
double tag = 5;
struct Square {
    double len, x, y, rad;
};

int main() {

    queue<Square> q;
    q.push({1, 0, 0, 0});
    while (!q.empty()) {
        Square prm = q.front();q.pop();
        //正方形左下角的点。
        double len = prm.len, ldx = prm.x, ldy = prm.y, rad = prm.rad;

        minx = min(minx, ldx);
        maxx = max(maxx, ldx);
        miny = min(miny, ldy);
        maxy = max(maxy, ldy);

        double cosrad = cos(rad);
        double sinrad = sin(rad);
        double dx = len * cosrad;
        double dy = len * sinrad;
        //正方形左上角的点。
        double lux = ldx - dy, luy = ldy + dx;
        //正方形位于上边上面的新点。
        double tx = lux + ((dx * 0.8) - (dy * 0.6)) * 0.8,ty = luy + ((dx * 0.6) + (dy * 0.8)) * 0.8;

        if (len * 0.8 > eps) {
            double pl = len * tag * 0.8;
            if (lux > maxx - pl || lux < minx + pl || luy > maxy - pl || luy < miny + pl) {
                q.push({len * 0.8, lux, luy, rad + leftRotate});
            }

            if (len * 0.6 > eps) {
                pl = len * tag * 0.6;
                if (tx > maxx - pl || tx < minx + pl || ty > maxy - pl || ty < miny + pl) {
                    q.push({len * 0.6, tx, ty, rad + rightRotate});
                }
            }
        }
    }
    double ans = (maxx - minx) * (maxy - miny);
    printf("%.10f\n", ans);
}
```

Q407

```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e7;
int mxp[N+4];
int main(){
    for(int p=2;p<=N;p++)
        if(!mxp[p])
            for(int i=p;i<=N;i+=p) mxp[i]=p;
    ll ans=0;
    for(int n=1;n<=N;n++){
        int m=1;
        for(int tp=n;tp>1;){
            int t=1;
            for(int p=mxp[tp];tp%p==0;tp/=p,t*=p);
            m=max(m,t);
        }
        int a=n-1;
        for(a=a-a%m;a>=0;a-=m){
            if(a+1<n&&1ll*a*(a+1)%n==0){
                ++a;break;
            }
            if(1ll*a*(a-1)%n==0) break;
        }
        ans+=a;
    }
    printf("%lld\n",ans);
}
```

Q425

```C++
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e7;
int pr[N+4],v[N+4],m=0;
int fa[N+4];
int now[1004],p=0;
int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
void merge(int x,int y){fa[find(x)]=find(y);}
int main(){
    for(int i=1;i<=N;i++)
        fa[i]=i;
    for(int i=2;i<=N;i++){
        if(v[i]==0){
            v[i]=i;pr[++m]=i;
        }
        for(int j=1;j<=m;j++){
            if(pr[j]>v[i]||pr[j]>N/i) break;
            v[i*pr[j]]=pr[j];
        }
    }
    ll ans=0;
    for(int i=1;i<=m;i++){
        int u=pr[i];
        string s=to_string(u);
        string t=s;
        p=0;
        for(int i=0;i<s.size();i++){
            char ch=s[i];
            for(int j=(i==0?1:0);j<10;j++){
                t[i]='0'+j;
                now[++p]=atoi(t.c_str());
            }
            t[i]=ch;
        }
        if(t.size()>=2&&t[1]!='0'){
            t=t.substr(1);
            now[++p]=atoi(t.c_str());
        }
        for(int i=1;i<=p;i++){
            int k=now[i];
            if(k>=u||v[k]!=k) continue;
            merge(k,u);
        }
        if(find(2)!=find(u)) ans+=u;
    }
    printf("%lld\n",ans);
}

```

Q443

```C++
# include <bits/stdc++.h>
# define X first
# define Y second
# define lb(x) ((x) & (-x))
# define mem(a,b) memset(a,b,sizeof(a))
# define debug freopen("r.txt","r",stdin)
# define pi pair<int,int>
using namespace std;
typedef long long ll;
const ll Q = 1e15;
const int N=sqrt(Q)*2;
int v[N],pr[N],p=0;
ll px[34],q=0;
void fact(ll x){
    q=0;
    for(int i=1;i<=p&&1ll*pr[i]*pr[i]<=x;i++)
    if(x%pr[i]==0){
        px[++q]=pr[i];
        for(;x%pr[i]==0;x/=pr[i]);
    }
    if(x!=1) px[++q]=x;
}
int main(){
    for (int i = 2; i < N; i++) {
        if (v[i] == 0) {
            pr[++p] = i;
            v[i] = i;
        }
        for (int j = 1; j <= p; j++) {
            if (pr[j] > v[i] || pr[j] > N / i) break;
            v[i * pr[j]] = pr[j];
        }
    }
    ll n=4,g=13;
    //找最小的k使得gcd(n+k+1,g+k)!=1，等价于gcd(g-n-1,n+k+1)!=1;
    for(;;){
        fact(g-n-1);
        ll nxt=1e18;
        //找到下一个最小的n'>n，使得gcd(n',g(n'-1))>1，
        //tn则是一个新的g(n'-1)，使得此时的gcd(n',g(n'-1))>1。
        for(int i=1;i<=q;i++){
            ll tn=(g+px[i]-1)/px[i]*px[i];
            nxt=min(nxt,tn);
        }
        ll k=nxt-g;
        ll np=n+1+k;
        if(np>Q){
            g+=Q-n;
            break;
        }
        g=nxt+__gcd(np,nxt);
        n=np;
        if(n>=Q) break;
    }
    printf("%lld\n",g);
}

```

Q461

```C++
#include <bits/stdc++.h>
# define mem(a,b) memset(a,b,sizeof(a))
# define pdi pair<double,int>
# define X first
# define Y second
using namespace std;
const int N=10000;
double e=exp(1),pi=acos(-1.0);
pdi pa[N*N];
double f[N+N];
int m=0,n=0;
int main(){
    double pi=acos(-1);
    double mx=log(pi+1);
    for(int i=0;i<N+N;i++){
        double e=1.0*i/N;
        f[m++]=exp(e)-1;
        if(e>mx) break;
    }
    for(int i=0;i<m;i++)
        for(int j=0;j<=i;j++){
            double w=f[i]+f[j];
            pa[n++]=pdi(w,i*i+j*j);
            if(w>pi) break;
        }
    sort(pa,pa+n);
    double eps=1e9;
    int ans=0;
    for(int l=0,r=n-1;l<n;l++){
        for(;r>=0&&pa[l].X+pa[r].X>pi;--r);
        if(r>0){
            double w=abs(pi-pa[l].X-pa[r].X);
            if(w<eps){
                eps=w;ans=pa[l].Y+pa[r].Y;
            }
        }
        if(r+1<n){
            double w=abs(pi-pa[l].X-pa[r+1].X);
            if(w<eps){
                eps=w;ans=pa[l].Y+pa[r+1].Y;
            }
        }
    }
    printf("%d\n",ans);
}

```

Q485

```C++
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const int N=100000000,K=100000;
int f[N+4];
int main(){
    for(int i=1;i<=N;i++)
        f[i]=1;
    for(int i=2;i<=N;i++){
        if(f[i]!=1) continue;
        for(ll w=i,c=1;w<=N;w*=i,++c){
            for(int j=w;j<=N;j+=w){
                if(j/w%i==0) continue;
                f[j]*=(c+1);
            }
        }
    }
    ll ans=0;
    deque<int>q;
    for(int i=K,j=1;i<=N;i++){
        while(!q.empty()&&i-q.front()>=K) q.pop_front();
        for(;j<=i;j++){
            while(!q.empty()&&f[j]>=f[q.back()]) q.pop_back();
            q.push_back(j);
        }
        ans+=f[q.front()];
    }
    printf("%lld\n",ans);
}
```

Q491

```Python
B = 2
B += 1
f = [{} for i in range(B ** 10)]
for i in range(1, 10):
    f[B ** i][i] = 1
for st in range(len(f)):
    ls = []
    for i in range(10):
        ls.append(st // (B ** i) % B)
    cnt = sum(ls)
    for s, val in f[st].items():
        for i in range(10):
            if ls[i] == B - 1:
                continue
            if cnt % 2 == 0:
                now = s + i
            else:
                now = s - i
            newst = st + B ** i
            if now not in f[newst].keys():
                f[newst][now] = 0
            f[newst][now] += val
ans = sum(val for s, val in f[-1].items() if s % 11 == 0)
print(ans)
```

Q501

```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll Q = 1000000000000;
const ll M = pow(Q,2.0/3) + 2;


char vis[M + 1];
int sum[M + 1],pr[M + 1],m;

unordered_map<ll,ll> mp,mq;
ll g(ll x, ll a) {
    if (a == 1 || x == 0)return (x + 1) / 2;
    ll &v = mp[(x << 10) + a];
    if (v)return v;
    return v = g(x, a - 1) - g(x / pr[a], a - 1);
}
ll cal(ll n) {
    if (n <= M)return sum[n];
    ll &v = mq[n];
    if (v) return v;
    ll a = cal(pow(n, 1.0 / 4));
    ll b = cal(sqrt(n));
    ll c = cal(pow(n, 1.0 / 3));
    ll s = g(n, a) + (b + a - 2) * (b - a + 1) / 2;
    for (ll i = a + 1; i <= b; i++) {
        ll w = n / pr[i];
        s -= cal(w);
        ll csqw = cal(sqrt(w));
        if (i <= c) {
            for (ll j = i; j <= csqw; j++)
                s += j - 1 - cal(w / pr[j]);
        }
    }
    return v = s;
}
int main() {
    ll ans = 0;
    for (ll i = 2; i <= M; i++) {
        if (!vis[i]) {
            for (ll j = i * i; j <= M; j += i) vis[j] = 1;
            pr[++m] = i;
        }
        sum[i] = m;
    }
    for (ll i = 1; i <= m && pr[i] <= pow(Q, 1.0 / 7); i++)
        ans++;
    ll tmp;
    for (int i = 1; i <= m && (tmp = Q / (1ll * pr[i] * pr[i] * pr[i])) >= 2; i++) {
        ans += cal(tmp) - (tmp >= pr[i]);
    }
    for (ll i = 1; 1ll * pr[i] * pr[i] * pr[i] <= Q; i++)
        for (ll j = i + 1; j <= m && pr[j + 1] <= (tmp = Q / (1ll * pr[i] * pr[j])); j++)
            ans += cal(tmp) - cal(pr[j]);
    printf("%lld\n", ans);
    return 0;
}
```

Q506

```Python
from gmpy2 import is_prime

# A028355
# 发现，该序列的周期为15，第i个鼠是第i-15个数后面拼接一个固定的6位数。
# 将每个n分解成n=x*15+y再进行计算。

N = 10**14
mod = 123454321
inv1e6 = 96007682
m = 10 ** 6
a = [1, 2, 3, 4, 32, 123, 43, 2123, 432, 1234, 32123, 43212, 34321, 23432, 123432]
b = [234321, 343212, 432123, 321234, 123432, 432123, 212343, 432123, 123432, 321234, 432123, 343212, 234321, 123432, 123432]
T = 15
ans = 0
for i in range(T):
    cnt = N // T + (i < N % T)
    c1 = (pow(m, cnt, mod) - 1) * inv1e6 % mod
    c2 = (c1 - cnt + mod) * inv1e6 % mod
    ans = (ans + a[i] * c1 + b[i] * c2) % mod
print(ans)

```

Q510

```C++
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const int Q=1e9;
//三个圆的半径满足1/sqrt(ra)+1/sqrt(rb)=1/sqrt(rc)
//rc=rarb/(ra+rb+2sqrt(rarb))，因此rarb必须是平方数。
//令ra=p^2(p+q)^2,rb=q^2(p+q)^2,rc=p^2q^2，其中p<=q，那么此时ra,rb,rc满足原方程。
//当gcd(p,q)=1时，这是一个本源三元组，可以知道，每个数乘以d仍然满足原方程。
int main(){
    ll ans=0;
    for(ll p=1;p*p*p*p<=Q;p++){
        for(ll q=p;q*q*(p+q)*(p+q)<=Q;q++){
            if(__gcd(p,q)!=1) continue;
            ll d=Q/(q*q*(p+q)*(p+q));
            ans+=(d+1)*d/2*(p*p*(p+q)*(p+q)+q*q*(p+q)*(p+q)+p*p*q*q);
        }
    }
    printf("%lld\n",ans);
}

```

Q511

```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1234567898765,M=4321,O=64;
ll mod=1e9;
ll cnt[M];
ll a[M],b[O][M];
void getd(ll N){
    for(ll i=1;i*i<=N;i++)
    if(N%i==0){
        ++cnt[(i+1)%M];
        if(i*i!=N) ++cnt[(N/i+1)%M];
    }
}
void cal(ll a[M],ll b[M],ll ans[M]){
    ll c[M]={0};
    for(int i=0;i<M;i++)
        for(int j=0;j<M;j++)
            c[(i+j)%M]=(c[(i+j)%M]+a[i]*b[j])%mod;
    memcpy(ans,c,sizeof(c));
}
int main(){
    getd(N);
    a[0]=1;
    memcpy(b[0],cnt,sizeof(b[0]));
    for(int i=1;i<O;i++)
        cal(b[i-1],b[i-1],b[i]);
    for(int i=0;i<O;i++)
        if(N>>i&1)
            cal(a,b[i],a);
    printf("%lld\n",a[0]);
}
```

Q516

```Python
N = 10 ** 12
ls = []
pr = []
for i in range(64):
    if 2 ** i > N:
        break
    for j in range(64):
        if 2 ** i * 3 ** j > N:
            break
        for k in range(64):
            v = 2 ** i * 3 ** j * 5 ** k
            if v > N:
                break
            ls.append(v)
            if Miller_Rabin(v + 1) and v + 1 > 5:
                pr.append(v + 1)
ls.sort()
pr.sort()
q = Queue()
q.put((1, 1))
ans = 0
while not q.empty():
    x, mxp = q.get()
    for v in ls:
        if x * v > N:
            break
        ans += x * v
    for i in range(bisect_right(pr, mxp), len(pr)):
        if x * pr[i] > N:
            break
        q.put((x * pr[i], pr[i]))

ans &= 0xffffffff
print(ans)
```

Q518

```C++
# include <bits/stdc++.h>
# define pi pair<int,int>
# define X first
# define Y second
using namespace std;
typedef long long ll;
const int N=1e8;
int pr[N+4],f[N+4],v[N+4],m=0;
int main(){
     for(int i=2;i<=N;i++){
        if(v[i]==0){
            f[i]=i;v[i]=i;pr[++m]=i;
        }
        for(int j=1;j<=m;j++){
            if(pr[j]>v[i]||pr[j]>N/i) break;
            v[i*pr[j]]=pr[j];
            f[i*pr[j]]=(f[i]%pr[j]==0?f[i]/pr[j]:f[i]*pr[j]);
        }
    }
    unordered_map<int,vector<int>>mp;
    for(int i=1;i<=m;i++){
        int p=pr[i];
        mp[f[p+1]].push_back(p+1);
    }
    ll ans=0;
    for(auto it=mp.begin();it!=mp.end();it++){
        vector<int>&a=it->Y;
        for(int i=0;i<a.size();i++)
            for(int j=i+1;j<a.size();j++){
                ll w=sqrt(1ll*a[i]*a[j])+1e-8;
                if(v[w-1]==w-1) ans+=w+a[i]+a[j]-3;
            }
    }
    printf("%lld\n",ans);
}
```

Q523

```Python
# A279683

N = 30
fac = [1]
a = [0]
for i in range(1, N + 1):
    fac.append(fac[-1] * i)
    a.append(a[i - 1] * i + fac[i - 1] * (2 ** (i - 1) - 1))

ans = a[N] / fac[N]
print("{:.2f}".format(ans))

```

Q531

```C++
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int L=1000000,R=1005000;
int phi[R+4];
ll ex_gcd(ll a,ll b,ll &x,ll &y){
    if(b==0){
        x=1;y=0;return a;
    }
    ll g=ex_gcd(b,a%b,x,y);
    ll z=x-(a/b)*y;
    x=y;y=z;return g;
}
//解不定方程ax+my=c。
ll congruence(ll a,ll c,ll m){
    ll x,y,g;
    g=ex_gcd(a,m,x,y);
    if(c%g!=0) return -1;
    x*=c/g;
    ll t=m/g;
    return (x%t+t)%t;
}
ll CRT(ll b,ll m,ll c,ll n){
    ll y=congruence(m,c-b,n);
    if(y==-1) return -1;
    ll x=m*y+b;
    ll t=m*n;
    return (x%t+t)%t;
}
int main(){
    for(int i=1;i<R;i++)
        phi[i]=i;
    for(int i=2;i<R;i++){
        if(phi[i]!=i) continue;
        phi[i]=i-1;
        for(int j=i+i;j<R;j+=i)
            phi[j]=phi[j]/i*(i-1);
    }
    ll ans=0;
    for(int i=L;i<R;i++){
        for(int j=i+1;j<R;j++){
            ll x=CRT(phi[i],i,phi[j],j);
            if(x!=-1) ans+=x;
        }
    }
    printf("%lld\n",ans);
}
```

Q549

```C++
#include <bits/stdc++.h>
# define X first
# define Y second
using namespace std;
typedef long long ll;
const int N=1e8;
int s[N+4];
int solve(int p,int e){
    ll k;
    for(k=p;;k+=p){
        ll t=k;
        for(;t%p==0&&e>0;--e,t/=p);
        if(e==0) break;
    }
    return k;
}
int main(){
    for(int i=2;i<=N;i++){
        if(s[i]!=0) continue;
        for(ll j=i,c=1;j<=N;j*=i,++c){
            int mx=solve(i,c);
            for(ll k=j;k<=N;k+=j)
                s[k]=max(s[k],mx);
        }
    }
    ll ans=0;
    for(int i=2;i<=N;i++){
        ans+=s[i];
    }
    printf("%lld\n",ans);
}
```

Q561

```Python
# E(m,n)=((n+1)(n+2)/2)^m-(n+1)^m，对式子提公因式(n+1)^m，然后进行判定。

Q = 10 ** 12
M = 904961


def cal(n: int):
    cnt = 0
    M = len(bin(n)[2:])
    for i in range(1, M + 1):
        cnt += (n + 2 ** (i - 1)) // (2 ** i) * i
    return cnt


c0 = Q // 4
c3 = (Q + 1) // 4
ans = cal(c3) * M
if M % 2 == 0:
    tp = cal(c3 >> 1) + cal((c3 + 1) >> 1)
    v = bin(M)[::-1].find('1')
    tp += c0 * (v + 1)
    ans += tp
else:
    ans += cal(c0)
print(ans)
```

Q577

```Python
N = 12345
ans = 0
for n in range(N-2):
    ans += Fraction(1, 216) * n ** 4 + Fraction(1, 12) * n ** 3 + Fraction(37, 72) * n ** 2 + [Fraction(5, 4), Fraction(139, 108), Fraction(131, 108)][n % 3] * n + [1, Fraction(10, 9), Fraction(7, 9)][n % 3]
print(ans)
# A011779
```

Q581

```C++
# include <bits/stdc++.h>
using namespace std;
const int M=47;
int pr[M+4],m=0,b[M+4];
typedef long long ll;
int main(){
    ll N=2e12;
    for(int i=2;i<=M;i++){
        if(b[i]) continue;
        pr[++m]=i;
        for(int j=i+i;j<=M;j+=i)
            b[j]=1;
    }
    priority_queue<ll,vector<ll>,greater<ll>>q;
    q.push(1);
    ll ans=0,pre=1;
    while(!q.empty()){
        ll u=q.top();q.pop();
        if(u==pre+1){
            ans+=pre;
        }
        pre=u;
        for(int i=1;i<=m;i++){
            ll v=u*pr[i];
            if(v>N) break;
            q.push(v);
            if(u%pr[i]==0) break;
        }
    }
    printf("%lld\n",ans);
}

```

Q587

```Python
rate = 0.001
S0 = 1 - pi / 4
k = 1
l, r = 1, 10 ** 9
while l < r:
    k = (l + r) >> 1
    a = 1 + k * k
    b = -k * k * 2 - k * 2
    c = k * k
    d = b * b - 4 * a * c
    x = (-b - d ** 0.5) / (a * 2)
    s0 = x * x / k / 2
    x -= 1
    s1 = x / 2 * (1 - x * x) ** 0.5 + asin(x) / 2 - x
    # 此处为对下限为x，上限为0中1-sqrt(1-x^2)的积分。
    S1 = s0 + s1
    if S1 / S0 < rate:
        r = k
    else:
        l = k + 1
print(l)
```

Q601

```Python
L, R = 1, 31


def P(s: int, N: int):
    N -= 1
    m = 1
    for i in range(1, s + 1):
        m = lcm(m, i)
    c1 = N // m
    if m == 1:
        c1 -= 1
    m = lcm(m, s + 1)
    c2 = N // m
    return c1 - c2


ans = 0
for i in range(L, R + 1):
    ans += P(i, 4 ** i)
print(ans)
```

Q609

```C++
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const int N=100000000;
int s[N+4];
int v[N+4],pr[N+4],m=0;
int cnt[N+4];
ll mod=1e9+7;
int main(){
    for(int i=2;i<=N;i++){
        if(v[i]==0) v[i]=i,pr[++m]=i;
        for(int j=1;j<=m;j++){
            if(pr[j]>v[i]||pr[j]>N/i) break;
            v[i*pr[j]]=pr[j];
        }
        s[i]=s[i-1]+(v[i]==i);
    }
    v[0]=-1;
    for(int i=1;i<=N;i++){
        for(int j=i,cs=0,cp=0;j;j=s[j]){
            ++cs;
            if(v[j]!=j) ++cp;
            if(cs>=2) ++cnt[cp];
            if(j==1) break;
        }
    }
    ll ans=1;
    for(int j=0;j<=N;j++)
        if(cnt[j]>0) ans=ans*cnt[j]%mod;
    printf("%lld\n",ans);
}

```

Q622

```Python
Q = 60
R = 2 ** Q - 1
ls = Get_Divisors(R)
ans = 0
for d in ls:
    p = 1
    while p <= Q:
        if quick_power(2, p, d) == 1:
            break
        p += 1
    if p == Q:
        ans += d+1
print(ans)
'''
原问题等价于求2模n-1的阶数r。其中有多少个r的值为60。
'''
```

Q630

```C++
# include <bits/stdc++.h>
# define pi pair<int,int>
using namespace std;
typedef long long ll;
const int N=2500;
int S[N*2+4],T[N*2+4];
ll solve(vector<pi>&v){
    map<pi,unordered_set<double>>mp;
    sort(v.begin(),v.end());
    v.resize(unique(v.begin(),v.end())-v.begin());
    int x1,y1,x2,y2;
    for(int i=0;i<v.size();i++)
    for(int j=0;j<i;j++){
        tie(x1,y1)=v[i];
        tie(x2,y2)=v[j];
        int x=x2-x1,y=y1-y2;
        double z=x1*y2-x2*y1;
        int g=__gcd(x,y);
        x/=g;y/=g;z/=g;
        if(x<0||x==0&&y<0){
            x=-x;y=-y;z=-z;
        }
        mp[pi(x,y)].insert(z);
    }
    int m=0;
    for(auto &[k,st]:mp)
        m+=st.size();
    ll ans=0;
    for(auto &[k,st]:mp)
        ans+=1ll*st.size()*(m-st.size());
    return ans;
}
int main(){
    S[0]=290797;
    for(int i=1;i<=N*2;i++){
        S[i]=1ll*S[i-1]*S[i-1]%50515093;
        T[i]=S[i]%2000-1000;
    }
    vector<pi>v;
    for(int i=2;i<=N*2;i+=2)
        v.push_back(pi(T[i-1],T[i]));
    printf("%lld\n",solve(v));
}

```

Q643

```C++
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const ll Q=1e11;
const ll mod=1000000007;
const int M = (int) sqrt(Q) * 2;
int phi[M+4],sphi[M+4];
unordered_map<ll,ll>mp;
ll inv(ll x,ll p){
    ll ans=1;
    for(int m=p-2;m;m>>=1){
        if(m&1) ans=ans*x%p;
        x=x*x%p;
    }
    return ans;
}
ll inv2= inv(2,mod);
ll sum_phi(ll x)
{
    if(x<=M)
        return sphi[x];
    if(mp.count(x))
        return mp[x];
    ll ans= ((x+1)%mod*(x%mod)%mod) * inv2 % mod;
    for(ll l=2,r;l<=x;l=r+1)
    {
        r= x / (x / l);
        ans= (ans - (r - l + 1) % mod * sum_phi(x / l) % mod + mod) % mod;
    }
    ans=(ans+mod)%mod;
    mp[x]=ans;
    return ans;
}
int main() {
    for (int i = 1; i <= M; i++)
        phi[i] = i;
    sphi[1] = 1;
    for (int i = 2; i <= M; i++) {
        if (phi[i] == i) {
            phi[i] = i - 1;
            for (int j = i + i; j <= M; j += i)
                phi[j] = phi[j] / i * (i - 1);
        }
        sphi[i] = (sphi[i - 1] + phi[i]) % mod;
    }
    ll ans=0;
    for(ll d=2;d<=Q;d<<=1)
        ans=(ans+sum_phi(Q/d)-1)%mod;
    printf("%lld\n",ans);

}
```

Q650

```Python
mp, mq = {}, {}
m = 20000
mod = 1000000007
ans = 0
fp = [[1] for _ in range(m + 1)]


def getfp(n: int, m: int):
    while m >= len(fp[n]):
        fp[n].append(fp[n][-1] * n % mod + 1)
    return fp[n][m]


for n in range(1, m + 1):
    mul = 1
    ls = naive_factorization(n)
    for x, y in ls:
        if x not in mp.keys():
            mp[x] = mq[x] = 0
        mp[x] += y
    for x, y in mp.items():
        mq[x] += y
    for p in mp.keys():
        e = mp[p] * (n + 1) - mq[p] * 2
        mul = mul * getfp(p, e) % mod
    ans = (ans + mul) % mod
    print(n, mul)
print(ans)
```

Q662

```C++
#include <bits/stdc++.h>
# define mem(a,b) memset(a,b,sizeof(a))
# define pi pair<int,int>
# define X first
# define Y second
using namespace std;
const int N=10000,M=10000;
vector<pi>v;
vector<int>fib;
int f[N+1][M+1],mod=1e9+7;
int main(){
    int a=1,b=2;
    for(;a<=max(N,M)*2;){
        int c=a+b;
        fib.push_back(a);
        a=b;b=c;
    }
    for(int d:fib){
        for(int x=0;x<=N&&x*x<=d*d;x++){
            int y=int(sqrt(d*d-x*x)+1e-9);
            if(y<=M&&x*x+y*y==d*d){
                v.push_back(pi(x,y));
            }
        }
    }
    f[0][0]=1;
    for(int i=0;i<=N;i++)
        for(int j=0;j<=M;j++){
            if(i==0&&j==0) continue;
            for(auto &[dx,dy]:v)
                if(dx<=i&&dy<=j){
                    f[i][j]+=f[i-dx][j-dy];
                    if(f[i][j]>=mod) f[i][j]-=mod;
                }
        }
    printf("%d\n",f[N][M]);
}

```

Q684

```Python
N = 90
mod = 10 ** 9 + 7
f = [0, 1]
for i in range(2, N + 1):
    f.append(f[-1] + f[-2])
inv9 = pow(9, mod - 2, mod)
ans = 0
for i in range(2, N + 1):
    w = f[i]
    c, r = divmod(w, 9)
    pw = pow(10, c, mod)
    if c > 1:
        d = 1
    ans = (ans + (pw - 1) + pw * r) % mod
print(ans)
```

Q686

```Python
i, c = 1, 0
lg = log10(2)

lt = [196, 289, 485]
l, r = log10(1.23), log10(1.24)
pre = 0
i = 90
c = 2
s = lg * i
while c < 678910:
    j = 0
    while j < 3:
        ns = s + lg * lt[j]
        if l <= ns - int(ns) < r:
            break
        j += 1
    if j == 4:
        print("FAIL")
        exit()
    s += lg * lt[j]
    i += lt[j]
    c += 1
print(i)
```

Q688

```C++
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const ll Q=1e16;
ll mod=1e9+7;
ll inv2=(mod+1)>>1;
int main(){
    ll ans=0;
    for(ll k=1;;k++){
        ll w=k*(k+1)/2;
        if(w>Q) break;
        ll t=Q-w;
        ll block=(t+1)/k%mod,res=(t+1)%k%mod;
        ans=(ans+k*block%mod*(block+1)%mod*inv2%mod+(block+1)*res%mod)%mod;
    }
    printf("%lld\n",ans);
}
```

Q692

```Python
import bisect
# Zeckendorf's theorem
f = [1, 2]
for i in range(100):
    f.append(f[-1] + f[-2])
G = {1: 1, 2: 3}


def getG(n: int):
    if n in G.keys():
        return G[n]
    p = bisect.bisect_right(f, n) - 1
    if f[p] == n:
        G[n] = getG(f[p - 2]) + getG(f[p - 1]) + f[p] - f[p - 2]
    else:
        G[n] = getG(f[p]) + getG(n - f[p])
    return G[n]


print(getG(23416728348467685))
```

Q694

```C++
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const ll Q=1e18;
const int M=pow(Q,1.0/3);
bool b[M+4];
int pr[M/3+100],m=0;
int main(){
    for(int i=2;i<=M;i++){
        if(b[i]) continue;
        pr[++m]=i;
        for(ll j=1ll*i*i;j<=M;j+=i)
            b[j]=1;
    }
    set<ll>st;
    unordered_set<ll>st2;
    st.insert(1);
    for(int i=1;i<=m;i++){
        st2.clear();
        for(ll x:st){
            int cnt=0;
            while(x<=Q/pr[i]){
                x*=pr[i];
                if(++cnt>=3)
                    st2.insert(x);
            }
            if(cnt<3) break;
        }
        for(ll x:st2)
            st.insert(x);
    }
    vector<ll>v(st.begin(),st.end());
    sort(v.begin(),v.end());
    ll ans=0;
    for(ll x:st)
        ans+=Q/x;
    //printf("%lld\n",st.size());
    printf("%lld\n",ans);
}
```

Q700

```Python
mod = 4503599627370517
a = 1504170715041707
l = r = ans = a
while l > 0:
    nxt = (l + r) % mod
    if nxt < l:
        l = nxt
        ans += l
    else:
        r = nxt
print(ans)
```

Q704

```Python
# A119387
N = 10**16
# 1~N中所有数加起来一共有cnt位
cnt = 0
l = 1
while l <= N:
    r = min(l * 2 - 1, N)
    cnt += (r - l + 1) * len(bin(l)[2:])
    l = r + 1

# cnt1: 1~N中所有数，如果最后x位是以01...1结尾，那么cnt1+=x。
cnt1 = 0
M = len(bin(N)[2:])
for i in range(1, M + 1):
    cnt1 += (N + 2 ** (i - 1) + 1) // (2 ** i) * i - 1
ans = cnt - cnt1
print(ans)
```

Q706

```C++
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=100000;
ll f[N+4][3][3][3][3],mod=1e9+7;
/*
数字串的前缀和为s[0]~s[n]
f[m][i][j][k][l]表示前m+1个值s[0]~s[m]中，有
 s[?]%3==1的个数 % 3 = i
 s[?]%3==2的个数 % 3 = j
 s[m]%3==k
 已经有的非空子串数目 % 3 = l.
 */
void add(ll &x,ll y){
    x=(x+y)%mod;
}

int main(){
    f[1][0][0][0][1] = 3;
    f[1][1][0][1][0] = 3;
    f[1][0][1][2][0] = 3;
    for(int m=1;m<N;m++)
        for(int i=0;i<3;i++)
            for(int j=0;j<3;j++)
                for(int k=0;k<3;k++)
                    for(int l=0;l<3;l++){
                        //0~m中一共有m+1个值。
                        int c0=(m+1-i-j+6)%3;
                        ll &now = f[m][i][j][k][l];
                        if(now == 0)
                            continue;
                        if(k==0){
                            add(f[m+1][i][j][k][(l+c0)%3],now*4); //0,3,6,9
                            add(f[m+1][(i+1)%3][j][(k+1)%3][(l+i)%3],now*3);//1,4,7
                            add(f[m+1][i][(j+1)%3][(k+2)%3][(l+j)%3],now*3);//2,5,8
                        }
                        else if(k==1){
                            add(f[m+1][(i+1)%3][j][k][(l+i)%3],now*4);//0,3,6,9
                            add(f[m+1][i][(j+1)%3][(k+1)%3][(l+j)%3],now*3);// 1,4,7
                            add(f[m+1][i][j][(k+2)%3][(l+c0)%3],now*3);//2,5,8
                        }
                        else{
                            add(f[m+1][i][(j+1)%3][k][(l+j)%3],now*4);//0,3,6,9
                            add(f[m+1][i][j][(k+1)%3][(l+c0)%3],now*3);//1,4,7
                            add(f[m+1][(i+1)%3][j][(k+2)%3][(l+i)%3],now*3);//2,5,8
                        }
                    }
    ll ans=0;
    for(int i=0;i<3;i++)
        for(int j=0;j<3;j++)
            for(int k=0;k<3;k++)
                add(ans,f[N][i][j][k][0]);
    printf("%lld\n",ans);
}

```

Q709

```C++
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
// A000111
const int N=24680;
int mod=1020202009;
ll fac[N+4],finv[N+4],inv[N+4];
ll C(int n,int m){
    return 1ll*fac[n]*finv[m]%mod*finv[n-m]%mod;
}
ll f[N+4];
int main(){
    fac[0]=fac[1]=inv[0]=inv[1]=finv[0]=finv[1]=1;
    for(int i=2;i<=N;i++){
        fac[i]=fac[i-1]*i%mod;
        inv[i]=(mod-mod/i)*inv[mod%i]%mod;
        finv[i]=finv[i-1]*inv[i]%mod;
    }
    f[0]=f[1]=1;
    for(int n=1;n<N;n++){
        for(int k=0;k<=n;k+=2)
            f[n+1]=(f[n+1]+1ll*C(n,k)*f[k]%mod*f[n-k])%mod;
    }
    printf("%lld\n",f[N]);
}
```

Q710

```C++
# include <bits/stdc++.h>
using namespace std;
const int N = 2000004;
int s[N][2],f[N][2],mod=1000000;
int main(){
    f[0][0]=s[0][0]=1;
    f[1][0]=1;s[1][0]=2;
    for(int n=2;n<N;n++){
        f[n][0]=(s[n-1][0]-f[n-2][0]+mod)%mod;
        f[n][1]=(s[n-1][1]+f[n-2][0])%mod;
        s[n][0]=(s[n-1][0]+f[n][0])%mod;
        s[n][1]=(s[n-1][1]+f[n][1])%mod;
        int a=s[n/2][1];
        if(n%2==0) a=(a+f[n/2-1][0])%mod;
        if(n>42&&a%mod==0) {printf("%d\n",n);break;}
    }
}
```

Q713

```Python
# A134546
for N in range(2, 11):
    ans = 0
    for r in range(1, N):
        q, s = divmod(N, r)
        ans += r * q * (q - 1) // 2 + s * q
        print(N, r, r * q * (q - 1) // 2 + s * q)

for n in range(2, 11):
    for k in range(2, n):
        m = n // k
        print(n, k, (n - m) * (n - m - 1) // 2 + (k - 1) * (m + 1) * m // 2)

'''
Fleshing out the explanation - thinking of the N fuses as nodes, after some number of tries we can construct the graph G
 in which two nodes (fuses) are adjacent if and only if they have not been tested together. A strategy is guaranteed to
  succeed if and only if G contains no clique of size m. The optimal strategy minimizes the number of tries, or
  equivalently maximizes the number of edges in G. So we are looking for the graph with the maximum number of edges that
  contains no clique of size m. By Turan's Theorem, this is the Turan graph T(n,m-1). The optimal strategy is then defined
  by partitioning the N nodes into m-1 subsets of as equal size as possible, and testing each pair within each subset.
'''

```

Q719

```C++
# include <bits/stdc++.h>
typedef long long ll;
using namespace std;
ll n=1000000,m;
int a[15],p=0;
bool dfs(int f,ll s,ll w){
    if(s>m||w>m) return 0;
    if(f==p){
        return s+w==m;
    }
    if(dfs(f+1,s+w,a[f])) return 1;
    if(dfs(f+1,s,w*10+a[f])) return 1;
    return 0;
}
int main(){
    ll ans=n*n;
    for(m=4;m<n;m++){
        ll v=m*m;
        p=0;
        for(;v;v/=10) a[p++]=v%10;
        reverse(a,a+p);
        if(dfs(0,0,0)) ans+=m*m;
    }
    printf("%lld\n",ans);
}
```

Q725

```Python
n = 2020
mod = int(1e16)
c = [0 for _ in range(10)]
f = [1]
for _ in range(n):
    f.append((f[-1] * 10 + 1) % mod)
fac = [1]
for i in range(1, 11):
    fac.append(fac[-1] * i)

ans = 0


def cal(d: list, bt: int):
    s = 0
    for j in range(10):
        if d[j] == 0:
            continue
        d[j] -= 1
        val = 1
        for k in range(bt - 1 - d[0]):
            val *= bt - k - 1
        for k in range(1, 10):
            val //= fac[d[k]]
        s += j * val
        d[j] += 1
    return s


def solve(s: int):
    global ans
    d = list(c)
    d[s] += 1
    cnt = sum(d)
    d[0] = n - cnt
    value = cal(d, n)
    ans = (ans + f[n - 1] * value) % mod


def dfs(s: int, nw: int):
    if s > 9:
        return
    c[nw] += 1
    solve(s)
    for j in range(nw, 10):
        dfs(s + j, j)
    c[nw] -= 1


for i in range(1, 10):
    dfs(i, i)
print(ans)
```

Q731

```Python
N = 10 ** 16
'''
模拟除法。
如果需要计算1/k的后面第n位小数，那么就是计算10^(n-1)/k后面的第1位小数。
根据题目要求，这题并不关心除k之后的整数部分。
另外(10^(n-1)%k)/k和10^(n-1)/k的小数部分相同。
'''
f = 0
i = 0
while True:
    if N < 3 ** i + 1:
        break
    f += pow(10, N - 3 ** i - 1, 3 ** i) / 3 ** i
    f -= int(f)
    i += 1
ans = str(f)[2:][:10]
print(ans)

```

Q739

```C++
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const int N = 1e8;
const int M = N*2;
const int n=N-1;
ll mod=1e9+7;
ll inv(ll n,ll p){
    ll ans=1,m=p-2;
    for(;m;m>>=1){
        if(m&1) ans=ans*n%mod;
        n=n*n%mod;
    }
    return ans;
}

int *fac,*finv;
int l[N+4],invn=inv(n,mod);
int C(int n,int m){
    return 1ll*fac[n]*finv[m]%mod*finv[n-m]%mod;
}
int T(int n,int k){
    //A106566
    if(n==0) return 0;
    else return 1ll*C(2*n-k-1,n-k)*k%mod*invn%mod;
}
int main(){
    fac = new int[M+4];
    finv = new int[M+4];
    fac[0]=fac[1]=1;
    finv[0]=1;
    for(int i=2;i<=M;i++)
        fac[i]=1ll*fac[i-1]*i%mod;
    finv[M]=inv(fac[M],mod);
    for(int i=M-1;i>0;i--)
        finv[i]=1ll*finv[i+1]*(i+1)%mod;
    int x=1,y=3;
    int ans=0;
    for(int i=0;i<=n;i++){
        ans=(ans+1ll*T(n,i)*x)%mod;
        int t=(x+y)%mod;
        x=y;y=t;
    }
    delete fac;
    delete finv;
    printf("%d\n",ans);
}
```

Q743

```C++
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const ll N = 1e16;
const ll K = 1e8;
const ll B = N/K;
ll mod=1e9+7;
ll qpow(ll n,ll m,ll mod){
    ll ans=1;
    for(;m;m>>=1){
        if(m&1) ans=ans*n%mod;
        n=n*n%mod;
    }
    return ans;
}
ll inv(ll n,ll p){
    return qpow(n,p-2,p);
}
int fac[K + 4],finv[K + 4];
int C(int n,int m){
    return 1ll*fac[n]*finv[m]%mod*finv[n-m]%mod;
}
int main(){
    fac[0]=fac[1]=1;
    finv[0]=1;
    for(int i=2; i <= K; i++)
        fac[i]=1ll*fac[i-1]*i%mod;
    finv[K]=inv(fac[K], mod);
    for(int i= K - 1; i > 0; i--)
        finv[i]=1ll*finv[i+1]*(i+1)%mod;
    ll pw2B=qpow(2,B,mod);
    ll invpw4B=inv(pw2B*pw2B%mod,mod);
    ll now=qpow(2,N,mod);
    ll ans=0;
    for(int i=0;i<=K/2;i++){
        ans=(ans+1ll*C(K,i)*C(K-i,i)%mod*now)%mod;
        now=now*invpw4B%mod;
    }
    printf("%lld\n",ans);
}
//$d=\frac{n}{k},val=\sum_{k=0}^{\lfloor\frac{n}{2}\rfloor}\frac{n!}{(n-2k)!(k!)^2}2^{d(n-2k)}$

```

Q745

```C++
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=10000004;
int f[N],mod=1e9+7;// Jordan function J_2(n)
int pr[N/4],v[N],m=0;
int main(){
    f[1]=1;
    ll k=1e14;
    ll ans=k;
    int n=sqrt(k);
    for(int i=2;i<=n;i++){
        if(v[i]==0){
            v[i]=i;f[i]=(1ll*i*i-1)%mod;
            pr[++m]=i;
        }
        for(int j=1;j<=m;j++){
            if(pr[j]>v[i]||pr[j]>n/i) break;
            v[i*pr[j]]=pr[j];
            if(pr[j]==v[i]) f[i*pr[j]]=1ll*f[i]*pr[j]*pr[j]%mod;
            else f[i*pr[j]]=1ll*f[i]*(1ll*pr[j]*pr[j]-1)%mod;
        }
        ans=(ans+1ll*f[i]*(k/(1ll*i*i)%mod))%mod;
    }
    printf("%lld\n",ans);
}
```

Q749

```C++
#include <bits/stdc++.h>
# define mem(a,b) memset(a,b,sizeof(a))
typedef long long ll;
using namespace std;
const int N=16;
const ll M=1e16;
const int O=64;
ll pw[14][66];
int c0[10],c1[10];
int n;
vector<ll>a;
bool ok(ll x){
    memcpy(c1,c0,sizeof(c1));
    for(int i=0;i<N;i++,x/=10)
        if(--c1[x%10]<0) return 0;
    return x==0;
}
void dfs(int k,int n,int p,ll s){
    if(p==0){
        c0[0]=n;
        if(ok(s-1))
            a.push_back(s-1);
        if(ok(s+1)) a.push_back(s+1);
        return;
    }
    for(int i=0;i<=n;i++){
        if(pw[p][k]==-1) break;
        c0[p]=i;
        dfs(k,n-i,p-1,s+pw[p][k]*i);
    }
}

int main(){
    mem(pw,-1);
    pw[0][0]=1;
    for(int j=1;j<O;j++)
        pw[0][j]=0;
    for(int i=0;i<10;i++){
        pw[i][0]=1;
        for(int j=1;j<O;j++){
            pw[i][j]=pw[i][j-1]*i;
            if(i>0&&pw[i][j]>M/i) break;
        }
    }
    for(int k=2;k<=N;k++)
        dfs(k,N,9,0);
    ll ans=0;
    sort(a.begin(),a.end());
    for(ll x:a)
        ans+=x;
    printf("%lld\n",ans);
}

```

Q751

```Python
l, r, n = 2, 3, 30
for _ in range(100):
    theta = 0.5 * (l + r)
    b = [theta]
    a = [int(theta)]
    for i in range(n):
        b.append(int(b[-1]) * (b[-1] - int(b[-1]) + 1))
        a.append(int(b[-1]))
    tau = str(a[0]) + "."
    for i in range(1, n):
        tau += str(a[i])
    tau = float(tau)
    if tau < theta:
        r = theta
    else:
        l = theta
print("{}.".format(a[0]) + "".join(str(x) for x in a[1:])[:24])
```

Q754

```C++
# include <bits/stdc++.h>
using namespace std;
const int N=10002,M=100000000;
bool b[N];
int a[2004],p=0;
int pr[N],q=0;
int mod=1000000007;
int qpow(int n,int m){
    int ans=1;
    for(;m;m>>=1){
        if(m&1) ans=1ll*ans*n%mod;
        n=1ll*n*n%mod;
    }
    return ans;
}
void fact(int x){
    p=0;
    for(int i=1;i<=q&&pr[i]*pr[i]<=x;++i){
        if(x%pr[i]==0){
            a[p++]=pr[i];
            for(;x%pr[i]==0;x/=pr[i]);
        }
    }
    if(x!=1) a[p++]=x;
}
int main(){
    for(int i=2;i<N;++i){
        if(b[i]) continue;
        pr[++q]=i;
        for(int j=i*i;j<N;j+=i)
            b[j]=1;
    }
    int ans=1;
    for(int i=2;i<=M;i++){
         fact(i);
         int s=0;
         for(int st=0;st<(1<<p);st++){
             int m=1,c=0;
             for(int i=0;i<p;i++)
                if(st>>i&1) m*=a[i],++c;
             if(c&1) s-=(M-i)/m;
             else s+=(M-i)/m;
         }
         ans=1ll*ans*qpow(i,s)%mod;
    }
    printf("%d\n",ans);
}

```

Q755

```Python
f = [1, 2]
s = [1, 3]
N = 10 ** 13
for i in range(100):
    w = f[-1] + f[-2]
    if w > N:
        break
    f.append(w)
    s.append(s[-1] + w)


def dfs(fl: int, now: int):
    if now < 0:
        return 0
    if fl == -1:
        return 1
    elif s[fl] <= now:
        return 1 << (fl + 1)
    else:
        return dfs(fl - 1, now) + dfs(fl - 1, now - f[fl])


print(dfs(len(f) - 1, N))
```

Q757

```Python
N = 10**14
lm2 = int(N ** 0.5 + 2)
lm4 = int(N ** 0.25 + 2)
st = set()
for dis in range(1, lm4):
    for mid in range(dis, lm2):
        u = mid * dis
        if u > lm2:
            break
        v, a, b = u - dis, mid + u - dis - 1, mid + u
        n = a * u
        if n > N:
            break
        if n == b * v:
            st.add(n)
print(len(st)-1)
```

Q788

```Python
N = 2022
mod = 10 ** 9 + 7
C = [[0 for i in range(j + 1)] for j in range(N + 1)]
for i in range(N + 1):
    C[i][0] = C[i][i] = 1
    for j in range(1, i):
        C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod
ans = 0
for n in range(1, N + 1):
    ans += 9
    for i in range(n // 2 + 1, n):
        ans = (ans + 9 * C[n - 1][i - 1] * pow(9, n - i, mod) + 9 * C[n - 1][i] * pow(9, n - i, mod)) % mod
print(ans)
```

Q793

```C++
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const int N=1000003;
ll S[N+4],m=(1ll*N*(N-1)/2+1)>>1;
bool ok(ll x){
    ll ans=0;
    for(int i=0;i<N;i++){
        ll w=x/S[i];
        int p=upper_bound(S,S+N,w)-S;
        if(p<=i) break;
        ans+=p-i-1;
    }
    return ans>=m;
}
int main(){
    S[0]=290797;
    for(int i=1;i<N;i++)
        S[i]=S[i-1]*S[i-1]%50515093;
    sort(S,S+N);
    ll l=1,r=1e17;
    while(l<r){
        ll mid=(l+r)>>1;
        if(ok(mid)) r=mid;
        else l=mid+1;
    }
    printf("%lld\n",l);
}

```
