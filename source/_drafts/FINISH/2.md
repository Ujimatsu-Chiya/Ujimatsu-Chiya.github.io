
Q259
```
f = [[set() for i in range(10)] for i in range(10)]
for i in range(1, 10):
    a = 0
    for j in range(i, 10):
        a = a * 10 + j
        f[i][j].add(a)
for x in range(2, 10):
    for l in range(1, 11 - x):
        r = l + x - 1
        for k in range(l, r):
            for vl in f[l][k]:
                for vr in f[k + 1][r]:
                    f[l][r].add(vl + vr)
                    f[l][r].add(vl - vr)
                    f[l][r].add(vl * vr)
                    if vr:
                        if isinstance(vl, int) and isinstance(vr, int) and vl % vr == 0:
                            f[l][r].add(vl // vr)
                        else:
                            f[l][r].add(Fraction(vl, vr))

ans = 0
for v in f[1][9]:
    if v > 0 and Fraction(v).denominator == 1:
        ans += v
print(ans)
```

Q260

```
#include <bits/stdc++.h>
const int N = 1000;

bool P1[N+1][N+1];
bool P2[N+1][N+1];
bool P3[N+1][N+1];
/*
当前是必败态，那么后继的都是必胜态。假设在每一堆中取的是s个石头。
用P1[y-x][z-y]表示后继状态{x-s,y-s,z-s}
P2[x][y-x]表示{x,y-s,z-s}
P2[y][z-x]表示{x-s,y,z-s}
P2[z][y-x]表示{x-s,y-s,z}
P3[x][y]表示{x,y,z-s}
P3[x][z]表示{x,y-s,z}
P3[y][z]表示{x-s,y,z}
 */
int main() {
    
    long long int ct = 0;
    for (int x = 0; x <= N; x++)
        for (int y = x; y <= N; y++)
            for (int z = y; z <= N; z++) {
                if (!(P1[y - x][z - y] || P2[z][y - x] || P2[y][z - x] || P2[x][z - y] || P3[y][z] || P3[x][z] ||
                      P3[x][y])) {
                    P1[y - x][z - y] = 1;
                    P2[z][y - x] = 1;
                    P2[y][z - x] = 1;
                    P2[x][z - y] = 1;
                    P3[x][y] = 1;
                    P3[x][z] = 1;
                    P3[y][z] = 1;
                    //printf("%d %d %d\n",x,y,z);
                    ct += x + y + z;
                }

            }
    printf("%lld\n", ct);
}
```

Q265
```
N = 5
M = 1 << N
g = [[] for i in range(M)]
vis = [0 for i in range(M)]
a = [0 for i in range(M)]
vis[0] = 1
ans = 0


def dfs(f: int):
    if f == M - 1:
        if a[-1] == (M >> 1):
            s = 0
            for i in range(M - N + 1):
                s = s << 1 | (a[i] & 1)
            global ans
            ans += s
        return
    for v in g[a[f]]:
        if vis[v]:
            continue
        vis[v] = 1
        a[f + 1] = v
        dfs(f + 1)
        vis[v] = 0


for i in range(M):
    for j in range(M):
        if i == j:
            continue
        x = bin(i)[2:]
        y = bin(j)[2:]
        x = '0' * (N - len(x)) + x
        y = '0' * (N - len(y)) + y
        if x[1:] == y[:-1]:
            g[i].append(j)
dfs(0)
print(ans)
```
Q266
```
def gen(ls: list):
    ans = []
    for i in range(1 << len(ls)):
        m = 1
        for j in range(len(ls)):
            if i >> j & 1:
                m *= ls[j]
        ans.append(m)
    ans.sort()
    return ans


N = 190
mod = 10 ** 16
pr = []
flag = [0 for _ in range(N + 1)]
for i in range(2, N + 1):
    if flag[i] == 0:
        pr.append(i)
        for j in range(i * i, N + 1, i):
            flag[j] = 1
v = 1
for x in pr:
    v *= x
l, r = 1, v
while l < r:
    mid = (l + r + 1) >> 1
    if mid ** 2 <= v:
        l = mid
    else:
        r = mid - 1
sq = l
lm = gen(pr[:len(pr) >> 1])
rm = gen(pr[len(pr) >> 1:])
k = len(rm) - 1
ans = 0
for i in range(len(lm)):
    while k >= 0 and lm[i] * rm[k] > sq:
        k -= 1
    if k < 0:
        break
    ans = max(ans, lm[i] * rm[k])
print(ans % mod)
```
Q267
```
d = 10 ** -5
M = 10 ** 9
M = log2(M)
f = d
N = 1000
mn = N
while f <= 1:
    l, r = 0, N
    while l < r:
        mid = (l + r) >> 1
        if mid * log2(1 + 2 * f) + (N - mid) * log2(1 - f) >= M:
            r = mid
        else:
            l = mid + 1
    mn = min(mn, l)
    f += d
C = [[0 for x in range(y + 1)] for y in range(N + 1)]
for i in range(N + 1):
    C[i][0] = C[i][i] = 1
    for j in range(1, i):
        C[i][j] = C[i - 1][j - 1] + C[i - 1][j]
s0, s1 = 0, 1 << N
for i in range(mn, N + 1):
    s0 += C[N][i]
ans = s0 / s1
print("{:.12f}".format(ans))
```
Q268
```
N = 10 ** 16 - 1
lp, ln = [], []
pr = Get_Primes(100)
cnt = [0 for i in range(len(pr) + 1)]


def dfs(f: int, n: int, v: int):
    if n > N:
        return
    if f == len(pr):
        cnt[v] += N // n
        return
    dfs(f + 1, n, v)
    dfs(f + 1, n * pr[f], v + 1)


dfs(0, 1, 0)
ans = 0
flag = True
for i in range(4, len(cnt)):
    if flag:
        ans += cnt[i] * (i - 1) * (i - 2) * (i - 3) // 6
    else:
        ans -= cnt[i] * (i - 1) * (i - 2) * (i - 3) // 6
    flag = not flag
print(ans)
```

Q271
```
pr = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]  # 13082761331670030=2*3*5*7*11*13*17*19*23*29*31*37*41*43


def ex_gcd(a: int, b: int):
    if b == 0:
        return 1, 0, a
    else:
        x, y, g = ex_gcd(b, a % b)
        return y, x - (a // b) * y, g


def solve_ax_plus_by_is_c(a: int, b: int, c: int):
    if a < 0:
        a, b, c = -a, -b, -c
    x, y, g = ex_gcd(a, b)
    if c % g != 0:
        return None
    ma = abs(a // g)
    mc = c // g
    x *= mc
    y *= mc
    y = (y % ma + ma) % ma
    x = (c - b * y) // a
    return x, y, abs(g)


def CRT(a1: int, m1: int, a2: int, m2: int):  # 中国剩余定理
    # m1*t==a2-a1(mod m2)
    t = solve_ax_plus_by_is_c(m1, m2, a2 - a1)[0]
    x = (a1 + t * m1) % (m1 * m2)
    return x


solpr = {}
for x in pr:
    solpr[x] = []
    for i in range(x):
        if i ** 3 % x == 1:
            solpr[x].append(i)
sol = solpr[pr[0]]
mul = pr[0]
for i in range(1, len(pr)):
    tmp = []
    for n in sol:
        for m in solpr[pr[i]]:
            tmp.append(CRT(n, mul, m, pr[i]))
    mul *= pr[i]
    sol = tmp
if 1 in sol:
    sol.remove(1)
print(sum(sol))
```
Q273

```
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 150;
vector<int> a, u, v;
int main() {
    for (int i = 5; i < N; i += 4) {
        bool isp = true;
        for (int j = 2; j * j <= i; j++)
            if (i % j == 0) isp = false;
        if (isp) {
            a.push_back(i);
            for (int j = 1; j <= i; j++)
                for (int k = j; k <= i; k++)
                    if (j * j + k * k == i) {
                        u.push_back(j);
                        v.push_back(k);
                        break;
                    }
        }
    }
    ll ans = 0;
    int m = a.size();
    int msk = pow(3, m);
    for (int s = 1; s < msk; s++) {
        int t = s;
        ll a = 0, b = 1;
        for (int i = 0; i < m; i++) {
            int d = t % 3;
            t /= 3;
            if (d == 1) {
                ll p = u[i], q = v[i];
                ll y = a * p + b * q, z = abs(a * q - b * p);
                a = y;
                b = z;
            } else if (d == 2) {
                ll p = v[i], q = u[i];
                ll y = a * p + b * q, z = abs(a * q - b * p);
                a = y;
                b = z;
            }
        }
        if (a > b) swap(a, b);
        ans += a;
    }
    printf("%lld\n", ans >> 1);
}
```

Q274

```
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e7;
int pr[N + 4], v[N + 4], p = 0;
ll qpow(ll n, ll m, ll mod) {
    ll a = 1;
    for (; m; m >>= 1) {
        if (m & 1) a = a * n % mod;
        n = n * n % mod;
    }
    return a;
}
int main() {
    for (int i = 2; i < N; i++) {
        if (v[i] == 0) {
            pr[++p] = i;
            v[i] = i;
        }
        for (int j = 1; j <= p; j++) {
            if (pr[j] > v[i] || pr[j] > N / i) break;
            v[i * pr[j]] = pr[j];
        }
    }
    ll ans = qpow(10, 3 - 2, 3);
    for (int i = 4; i <= p; i++)
        ans += qpow(10, pr[i] - 2, pr[i]);
    printf("%lld\n", ans);
}
```

Q277
```
def ex_gcd(a: int, b: int):
    if b == 0:
        return 1, 0, a
    else:
        x, y, g = ex_gcd(b, a % b)
        return y, x - (a // b) * y, g


N = 10 ** 15
s = "UDDDUdddDDUDDddDdDddDDUDDdUUDd"
k = Fraction(1)
b = Fraction(0)
for ch in s:
    if ch == 'U':
        k = k * 4 / 3
        b = (b * 4 + 2) / 3
    elif ch == 'D':
        k /= 3
        b /= 3
    else:
        k = k * 2 / 3
        b = (b * 2 - 1) / 3
a, n, c = k.numerator, k.denominator, -b.numerator
x, y, g = ex_gcd(a, n)
x = x * c % n
d = (N - x + n - 1) // n
ans = x + d * n
print(ans)
```
Q286
```
N = 50
M = 20
Q = 0.02
l = N
r = N << 1
for _ in range(100):
    q = 0.5 * (l + r)
    f = [[0 for i in range(M + 1)] for j in range(N + 1)]
    f[0][0] = 1
    for i in range(N):
        rt = 1 - (i + 1) / q
        for j in range(M + 1):
            if f[i][j] == 0:
                continue
            if j < M:
                f[i + 1][j + 1] += f[i][j] * rt
            f[i + 1][j] += f[i][j] * (1 - rt)
    if f[N][M] > Q:
        l = q
    else:
        r = q
    print(f[N][M])
print("{:.10f}".format(l))
```
Q288
```
Q = 10 ** 7
P = 61
mod = 61 ** 10
S = [290797]
for i in range(1, Q + 1):
    S.append(S[-1] ** 2 % 50515093)
T = []
for x in S:
    T.append(x % P)
ans = 0
s = 0
for i in range(Q, 0, -1):
    s = (s * P + T[i]) % mod
    ans = (ans + s) % mod
print(ans)
```
Q293
```
pr = [2, 3, 5, 7, 11, 13, 17, 19, 23]
N = 10 ** 9
st = set()


def solve(n: int):
    m = 2
    while m <= 100000:
        if Miller_Rabin(n + m):
            return m
        m += 1
    return -1


def dfs(f: int, n: int):
    if f == len(pr):
        return
    for k in range(100):
        n *= pr[f]
        if n >= N:
            break
        st.add(solve(n))
        dfs(f + 1, n)


dfs(0, 1)
ans = sum(st)
print(ans)
```
Q297
```
N = 10 ** 17 - 1
f = [1, 2]
mp = {0: 0, 1: 1, 2: 2, 3: 3}
while True:
    f.append(f[-1] + f[-2])
    if f[-1] > N:
        break


def dfs(n: int):
    if n in mp.keys():
        return mp[n]
    p = 0
    while p + 1 < len(f) and f[p + 1] <= n:
        p += 1
    ans = dfs(f[p] - 1) + dfs(n - f[p]) + n - f[p] + 1
    mp[n] = ans
    return ans


print(dfs(N))
```
Q301
```
k = 30
f = [1, 2]
for i in range(k):
    f.append(f[-1] + f[-2])
print(f[k])
```
Q303
```
N = 10 ** 4
O = 10
M = 3 ** O
Euler_sieve(int(10 ** (O / 2)))
f = [0 for i in range(N + 1)]
st = {i for i in range(1, N + 1)}


def dfs(fl: int, v: int, n: int, ls: list):
    if v > N:
        return
    if fl == len(ls):
        if f[v] == 0:
            f[v] = n // v
            st.remove(v)
        return
    p, e = ls[fl]
    for i in range(e + 1):
        dfs(fl + 1, v, n, ls)
        v *= p


a = []
for i in range(1, M):
    x, y, pw = 0, i, 1
    while y:
        x += y % 3 * pw
        pw *= 10
        y //= 3
    a.append(x)
    print(x, len(st))
    dfs(0, 1, x, factorization(x))
    ls = []
    for v in st:
        if x % v == 0:
            f[v] = x // v
            ls.append(v)
        for v in ls:
            st.remove(v)
for x in st:
    ml, mr = {}, {}
    mr[0] = 0
    con = 10 ** O % x
    for v in a:
        l = con * v % x
        r = v % x
        if l not in ml.keys():
            ml[l] = v
        if r not in mr.keys():
            mr[r] = v
    flag = 1
    ans = 10 ** 30
    for modl, l in ml.items():
        modr = (x - modl) % x
        if modr in mr.keys():
            ans = min(ans, l * 10 ** O + mr[modr])
    f[x] = ans // x
print(sum(f))
```
Q304
```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll L=1e14;
const int M=sqrt(L);
const ll R=L+M;
const int Q=1e5;
ll mod=1234567891011;
inline ll add(ll a,ll b){
    ll x=a+b;
    if(x>=mod) x-=mod;
    return x;
}
inline ll mul(ll a,ll b){
    ll ans=0;
    for(;b;b>>=1){
        if(b&1) ans=add(ans,a);
        a<<=1;
        if(a>=mod) a-=mod;
    }
    return ans;
}
ll a[2],b[2][2];
void mul(ll a[2],ll b[2][2]){
    ll c[2]={0};
    for(int i=0;i<2;i++)
        for(int k=0;k<2;k++)
            c[i]=add(c[i],mul(a[k],b[k][i]));
    memcpy(a,c,sizeof(c));
}
void mulself(ll b[2][2]){
    ll c[2][2]={0};
    for(int i=0;i<2;i++)
        for(int k=0;k<2;k++)
            if(b[i][k])
                for(int j=0;j<2;j++)
                    c[i][j]=add(c[i][j],mul(b[i][k],b[k][j]));
    memcpy(b,c,sizeof(c));
}
ll que(ll x){
    b[0][0]=a[0]=0;
    a[1]=b[0][1]=b[1][0]=b[1][1]=1;
    for(;x;x>>=1){
        if(x&1) mul(a,b);
        mulself(b);
    }
    return a[0];
}
bool vis[M*2+4];
ll pr[M*2],m=0;
void sieve(){
    for(int i=2;i<=M*2;i++){
        if(vis[i]) continue;
        pr[++m]=i;
        for(ll j=1ll*i*i;j<=M*2;j+=i)
            vis[j]=1;
    }
    memset(vis,0,sizeof(vis));
    for(int k=1;k<=m;k++){
        int x=pr[k];
        for(ll k=(L+x-1)/x*x;k<=R;k+=x){
            vis[k-L]=1;
        }
    }
    m=0;
    for(ll i=L;i<=R;i++)
        if(!vis[i-L]) pr[++m]=i;
}
int main(){
    sieve();
    ll ans=0;
    for(int i=1;i<=Q;i++)
        ans=(ans+que(pr[i]))%mod;
    printf("%lld\n",ans);
}
```
Q306
```
N = 10 ** 6
a = [0, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 0, 5, 2, 2, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 2, 7, 4, 0, 1, 1, 2,
     0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 2, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4]
z = [8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4]
ans = 0
for i in range(min(N, len(a))):
    if a[i] > 0:
        ans += 1
if N > len(a):
    N -= len(a)
    block, res = divmod(N, len(z))
    ans += block * (len(z) - z.count(0)) + res - z[:res].count(0)
print(ans)
```

Q307
```
# include <bits/stdc++.h>
typedef long double ld;
using namespace std;
const int K=20000,N=1000000;
ld fac[N+K+2];
ld A(int n,int m){
    return fac[n]-fac[n-m];
}
ld C(int n,int m){
    return fac[n]-fac[n-m]-fac[m];
}
int main(){
    for(int i=1;i<=N+K;i++)
        fac[i]=fac[i-1]+log(i);
    ld ans=0;
    for(int i=0;i<=K/2;i++){
        if(i>N||K-2*i>N-i) continue;
        ld val=C(N,i)+A(K,i*2)-log((ld)2)*i+A(N-i,K-i*2)-K*log(N);
        ans+=exp(val);
    }
    ans=(ld)1-ans;
    printf("%.10Lf\n",ans);
}
```
Q310
```
# include <bits/stdc++.h>
# define mem(a,b) memset(a,b,sizeof(a))
using namespace std;
typedef long long ll;
const int N=100000;
const int M=sqrt(N)/4+10;
int sg[N+4];
bool mex[M+4];
int cnt[M+4];
int main(){
    for(int i=1;i<=N;i++){
        mem(mex,0);
        for(int j=1;j*j<=i;j++)
            mex[sg[i-j*j]]=1;
        int j=0;
        for(;mex[j];++j);
        sg[i]=j;
        ++cnt[sg[i]];
    }
    ++cnt[0];
    int mx=*max_element(sg+1,sg+N+1);
    ll ans=0;
    for(int i=0;i<=mx;i++)
        for(int j=i+1;j<=mx;j++){
            int k=i^j;
            if(mx>=k&&k>j)
                ans+=1ll*cnt[i]*cnt[j]*cnt[k];
        }
    for(int i=1;i<=mx;i++)
        ans+=1ll*cnt[i]*(cnt[i]+1)/2*cnt[0];
    ans+=1ll*cnt[0]*(cnt[0]+1)*(cnt[0]+2)/6;
    printf("%lld\n",ans);
}

```

Q313
```
ans = 0
n = 1000000
pr = Get_Primes(n)
for p in pr:
    ans += ceil((p * p + 11) / 6) - floor((p * p + 13) / 8) - 1
ans <<= 1
print(ans)
```
Q315
```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2e7,M=1e7;
const int O=10,P=7;
int f1[N+4],f2[N+4];
int v[N+4],pr[N+4],m=0;
int b[O]={119, 36, 93, 109, 46, 107, 123, 39, 127, 111};
int g[O][O],c[1<<P];
int getnext(int n){
    int a=0;
    for(;n;n/=10)
        a+=n%10;
    return a;
}
int cal(int n){
    int a=0;
    for(;n;n/=10)
        a+=c[b[n%10]];
    return a;
}
int main(){
    for(int i=1;i<(1<<P);i++)
        for(int j=0;j<P;j++)
            if(i>>j&1) ++c[i];
    for(int i=2;i<=N;i++){
        if(v[i]==0) v[i]=i,pr[++m]=i;
        for(int j=1;j<=m;j++){
            if(pr[j]>v[i]||pr[j]>N/i) break;
            v[i*pr[j]]=pr[j];
        }
    }
    for(int i=0;i<O;i++)
        for(int j=0;j<O;j++)
            g[i][j]=c[b[i]&b[j]];
    for(int i=0;i<O;i++){
        f2[i]=f1[i]=c[b[i]]*2;
    }
    for(int i=O;i<=N;i++){
        int x=getnext(i);
        f1[i]=f1[x]+cal(i)*2;
        int d=0;
        for(int y=x,z=i;y;y/=10,z/=10)
            d+=g[y%10][z%10];
        f2[i]=f2[x]+cal(i)*2-d*2;

    }
    int ans=0;
    for(int i=1;i<=m;i++)
        if(pr[i]>=M)
            ans+=f1[pr[i]]-f2[pr[i]];
    printf("%d\n",ans);
}
```
Q329
```
s = "PPPPNNPPPNPPNPN"
N = 500
l = len(s)
f1 = Fraction(1, 3)
f2 = Fraction(2, 3)
f = [[Fraction(0, 1) for x in range(N + 1)] for y in range(l)]
pr = []
flag = [0 for _ in range(N + 1)]
flag[0] = flag[1] = 1
for i in range(2, N + 1):
    if flag[i] == 0:
        pr.append(i)
        for j in range(i * i, N + 1, i):
            flag[j] = 1
for j in range(1, N + 1):
    f[0][j] = Fraction(1, N)
    if (s[0] == 'P') ^ (not flag[j]):
        f[0][j] *= f1
    else:
        f[0][j] *= f2
for i in range(l - 1):
    for j in range(1, N + 1):
        if j == 1 or j == N:
            con = Fraction(1)
        else:
            con = Fraction(1, 2)
        if j > 1:
            if (s[i + 1] == 'P') ^ (not flag[j - 1]):
                f[i + 1][j - 1] += f[i][j] * f1 * con
            else:
                f[i + 1][j - 1] += f[i][j] * f2 * con
        if j < N:
            if (s[i + 1] == 'P') ^ (not flag[j + 1]):
                f[i + 1][j + 1] += f[i][j] * f1 * con
            else:
                f[i + 1][j + 1] += f[i][j] * f2 * con
print(sum(f[l - 1]))
```
Q336
```
#include <bits/stdc++.h>
using namespace std;
const int N=11,Q=2011;
int a[N],b[N];
int main(){
    a[0]=2;a[1]=0;a[2]=1;
    for(int i=3;i<N;i++)
        a[i]=i;
    int v=2*N-3,cnt=0;
    do{
        int c=0;
        memcpy(b,a,sizeof(a));
        for(int i=0,p=0;i<N;i++){
            if(b[i]==i) continue;
            if(b[N-1]!=i){
                for(p=i+1;b[p]!=i;p++);
                reverse(b+p,b+N);
                ++c;
            }
            reverse(b+i,b+N);
            ++c;
        }
        if(c==v&&++cnt==Q) break;
    }while(next_permutation(a,a+N));
    for(int i=0;i<N;i++)
        putchar('A'+a[i]);
    puts("");
}
```
Q337
```
#include <bits/stdc++.h>
# define pi pair<int,int>
# define X first
# define Y second
# define lb(x) ((x)&-(x))
using namespace std;
typedef long long ll;
const int N=20000000;
int phi[N+4];
int s[N+4],mod=1e8;
int a[N+4],m=0;
int pos[N+4];
void add(int p,int x){
    for(int i=p;i<=m;i+=lb(i))
        s[i]=(s[i]+x)%mod;
}
int que(int p){
    int ans=0;
    for(int i=p;i;i-=lb(i))
        ans=(ans+s[i])%mod;
    return ans;
}
bool cmp(int &x,int &y){
    return phi[x]<phi[y]||phi[x]==phi[y]&&x<y;
}
int main(){
    for(int i=1;i<=N;i++)
        phi[i]=i;
    for(int i=2;i<=N;i++){
        if(i>=6) a[++m]=i;
        if(phi[i]==i){
            phi[i]=i-1;
            for(int j=i+i;j<=N;j+=i)
                phi[j]=phi[j]/i*(i-1);
        }
    }
    sort(a+1,a+m+1,cmp);
    map<int,pi>mp;
    for(int i=1,j;i<=N;i=j){
        for(j=i;phi[a[i]]==phi[a[j]];pos[a[j]]=j,j++);
        mp[phi[a[i]]]=pi(i,j-1);
    }
    add(pos[6],1);add(pos[6]+1,mod-1);
    int ans=0;
    for(int i=6;i<=N;i++){
        int w=que(pos[i]);
        ans=(ans+w)%mod;
        int l=mp[phi[i]].Y+1;
        auto it=mp.lower_bound(i);
        int r=it->Y.X-1;
        add(l,w);add(r+1,mod-w);
    }
    printf("%d\n",ans);
}
```
Q345
```
#include <bits/stdc++.h>
using namespace std;
const int N=16;
vector<int>g[N+1];
int f[1<<N];
int a[N][N];
int main(){
    freopen("r.txt","r",stdin);
    int n=15;
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            scanf("%d",&a[i][j]);
    for(int s=0;s<(1<<n);s++){
        int c=0;
        for(int i=0;i<n;i++)
            c+=s>>i&1;
        for(int i=0;i<n;i++){
            if(s>>i&1) continue;
            f[s|1<<i]=max(f[s|1<<i],f[s]+a[c][i]);
        }
    }
    printf("%d\n",f[(1<<n)-1]);
}
```
Q346
```
N = 10 ** 12
st = {1}
b = 1
while (1 << b) <= N:
    b += 1
for cnt in range(2, b + 1):
    base = 2
    while True:
        val = 1
        for i in range(cnt):
            val = val * base + 1
        if val > N:
            break
        st.add(val)
        base += 1
ans = sum(st)
print(ans)
```
Q347
```
pr = []
N = 10 ** 7
flag = [0 for _ in range(N + 1)]
for i in range(2, N + 1):
    if flag[i] == 0:
        pr.append(i)
        for j in range(i * i, N + 1, i):
            flag[j] = 1
ans = 0
for i in range(len(pr) - 1):
    if pr[i] * pr[i + 1] > N:
        break
    j = i + 1
    while j < len(pr):
        if pr[i] * pr[j] > N:
            break
        mx = 0
        x = pr[i]
        while x * pr[j] <= N:
            y = pr[j]
            while x * y <= N:
                mx = max(mx, x * y)
                y *= pr[j]
            x *= pr[i]
        j += 1
        ans += mx
print(ans)
```
Q348
```
#include <bits/stdc++.h>
# define X first
# define Y second
using namespace std;
int N=8e8,Q=5;
map<int,int>mp;
bool ok(int n){
    string s=to_string(n);
    int l=0,r=s.size()-1;
    for(;l<r&&s[l]==s[r];++l,--r);
    return l>=r;
}
int main(){
    for(int i=1;i*i*i<=N;i++){
        cout<<i<<endl;
        for(int j=1;i*i*i+j*j<=N;j++)
            ++mp[i*i*i+j*j];
    }
    int cnt=0;
    int s=0;
    for(auto it=mp.begin();it!=mp.end();it++)
        if(it->Y==4&&ok(it->X)){
            s+=it->X;
            if(++cnt==Q) break;
        }
    printf("%d\n",s);
}
```
Q349
```
#include <bits/stdc++.h>
# define pi pair<int,int>
# define X first
# define Y second
# define lb(x) ((x)&-(x))
using namespace std;
typedef long long ll;
const ll Q=1e18;
map<pi,int>mp;
int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};
const int N=100000;
int a[N+4],nxt[N+4];
int main(){
    int x=0,y=0;
    for(int i=1,k=0;i<=N;i++){
        pi pa(x,y);
        if(mp[pa]==0)
            k=(k-1)&3,a[i]=1;
        else
            k=(k+1)&3,a[i]=0;
        mp[pa]^=1;
        x+=dx[k];
        y+=dy[k];
    }
    map<int,int>mq;
    reverse(a+1,a+N+1);
    for(int i=2,j=0;i<=N;i++){
        while(j&&a[j+1]!=a[i]) j=nxt[j];
        if(a[j+1]==a[i]) ++j;
        nxt[i]=j;
        if(i%(i-nxt[i])==0)
            ++mq[i-nxt[i]];
    }
    int T=0,mx=0;
    ll ans=0;
    for(pi pa:mq)
        if(pa.Y>mx)
            tie(T,mx)=pa;
    reverse(a+1,a+N+1);
    if(Q<=N){
        for(int i=1;i<=Q;i++)
            if(a[i]) ++ans;
            else --ans;
    }
    else{
        ll nw=0;
        for(int i=1;i<=N;i++)
            if(a[i]) ++ans;
            else --ans;
        for(int i=0;i<T;i++)
            if(a[N-i]) ++nw;
            else --nw;
        ll g=(Q-N)/T,res=(Q-N)%T;
        ans+=g*nw;
        for(int i=1;i<=res;i++)
            if(a[N-T+i]) ++ans;
            else --ans;
    }
    printf("%lld\n",ans);
}
```
Q351
```
#include <bits/stdc++.h>
# define X first
# define Y second
using namespace std;
typedef long long ll;
const int N=1e8;
int pr[N+4],v[N+4],m=0;
int phi[N+4];
int main(){
    phi[1]=1;
    for(int i=2;i<=N;i++){
        if(v[i]==0){
            v[i]=i;phi[i]=i-1;pr[++m]=i;
        }
        for(int j=1;j<=m;j++){
            if(pr[j]>v[i]||pr[j]>N/i) break;
            v[i*pr[j]]=pr[j];
            phi[i*pr[j]]=phi[i]*(v[i]==pr[j]?pr[j]:pr[j]-1);
        }
    }
    ll sum=0;
    for(int i=1;i<=N;i++)
        sum+=phi[i];
    ll tot=2ll*N*N+1ll*(N+1)*(N+2)-2;
    ll ans=tot-sum*6;
    printf("%lld\n",ans);
}
```
Q358
```
def is_primitive_root(a: int, p: int):
    pr = [v[0] for v in naive_factorization(p - 1)]
    for d in pr:
        if quick_power(a, (p - 1) // d, p) == 1:
            return False
    return True


left = "00000000137"
right = "56789"
val = float("0." + left)
ed = floor(1 / val)
val += 10 ** -len(left)
st = ceil(1 / val)
mod = 10 ** len(right)
ph = phi(mod)
modv = int(right)
for x in range(st // 2 * 2 + 1, ed + 1, 2):
    k = (quick_power(10, x - 1, mod) - 1) * quick_power(x, ph - 1, mod) % mod
    if k == modv and Miller_Rabin(x) and is_primitive_root(10, x):
        ans = (x - 1) // 2 * 9
        break
print(ans)
```
Q359
```
N = 71328803586048
mod = 10 ** 8


def cal(n: int, f: int):
    k = n >> 1
    if f == 0:
        return k * (k + 1) * (2 * k + 1) // 6 * 4
    else:
        return n * (n + 1) * (2 * n + 1) // 6 - k * (k + 1) * (2 * k + 1) // 6 * 4


def fun(n: int, k: int):
    if n == 0:
        return (k + 1) * (k + 2) // 2
    else:
        v = 2 * int((n + 1) // 2) + k
        if k % 2 == 0:
            f = 1
        else:
            f = -1
        return (cal(v, v & 1) - cal(v - k, v & 1)) - (cal(v - 1, (v & 1) ^ 1) - cal(v - k, (v & 1) ^ 1)) + f * (
                (n + 1) ** 2 // 2)


ans = 0
for x in Get_Divisors(N):
    ans = (ans + fun(x - 1, N // x - 1)) % mod
print("{:08}".format(ans))
# A083362
```
Q364

```
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int Q=1000000;
const int N=Q*2+4;
ll fac[N],inv[N],finv[N],pw2[N],mod=1e8+7;
ll C(int n,int m){
    return fac[n]*finv[n-m]%mod*finv[m]%mod;
}
ll cal(int Q){
    ll ans=0;
    for(int s=0;s<4;s++){
        int v1=s&1,v2=s>>1&1;
        for(int k=0;3*k<=Q-1-v1-v2;k++){
            int m=Q-1-v1-v2-3*k;
            if(m&1) continue;
            m>>=1;
            ans=(ans+fac[m+k+1]*C(m+k,m)%mod*pw2[k]%mod*fac[k+v1+v2]%mod*fac[m+k])%mod;
        }
    }
    return ans;
}
int main(){
    //A192008
    fac[0]=fac[1]=inv[1]=finv[0]=finv[1]=pw2[0]=1;
    pw2[1]=2%mod;
    for(int i=2;i<N;i++){
        fac[i]=fac[i-1]*i%mod;
        inv[i]=(mod-mod/i)*inv[mod%i]%mod;
        finv[i]=finv[i-1]*inv[i]%mod;
        pw2[i]=pw2[i-1]*2%mod;
    }
    printf("%lld\n",cal(Q));
}

```

Q365
```
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1e18,M=1e9;
const int L=1000,R=5000;
bool vis[R+4];
vector<int>pr,res;
int fac[R+4];
ll inv(ll n,ll p){
    ll a=1,m=p-2;
    for(;m;m>>=1){
        if(m&1) a=a*n%p;
        n=n*n%p;
    }
    return a;
}
ll ex_gcd(ll a,ll b,ll &x,ll &y){
    if(b==0){
        x=1;y=0;return a;
    }
    ll g=ex_gcd(b,a%b,x,y);
    ll z=x-(a/b)*y;
    x=y;y=z;return g;
}
//解不定方程ax+my=c。
ll congruence(ll a,ll c,ll m){
    ll x,y,g;
    g=ex_gcd(a,m,x,y);
    if(c%g!=0) return -1;
    x*=c/g;
    ll t=m/g;
    return (x%t+t)%t;
}
ll CRT(ll b,ll m,ll c,ll n){
    ll y=congruence(m,c-b,n);
    ll x=m*y+b;
    ll t=m*n;
    return (x%t+t)%t;
}
int C(int n,int m,int p){
    if(m>n) return 0;
    return fac[n]*inv(fac[m],p)%p*inv(fac[n-m],p)%p;
}
ll lucas(ll n,ll m,ll p){
    return n==0?1:C(n%p,m%p,p)*lucas(n/p,m/p,p)%p;
}
int main(){
    for(int i=2;i<R;i++){
        if(vis[i]) continue;
        if(i>L) pr.push_back(i);
        for(int j=i+i;j<R;j+=i)
            vis[j]=1;
    }
    for(int p:pr){
        fac[0]=1;
        for(int i=1;i<p;i++)
            fac[i]=fac[i-1]*i%p;
        res.push_back(lucas(N,M,p));
    }
    ll ans=0;
    for(int i=0;i<pr.size();i++)
        for(int j=0;j<i;j++){
            ll x=CRT(res[i],pr[i],res[j],pr[j]);
            for(int k=0;k<j;k++){
                ll y=CRT(x,pr[i]*pr[j],res[k],pr[k]);
                ans+=y;
            }
        }
    printf("%lld\n",ans);
}


```

Q371
```
k = 499
f = [[0, 0] for i in range(k + 2)]
for i in range(k, -1, -1):
    f[i][1] = (2 * (499 - i) * f[i + 1][1] + 1000) / (999 - i)
    f[i][0] = (2 * (499 - i) * f[i + 1][0] + f[i][1] + 1000) / (999 - i)
ans = f[0][0]
print("{:.8f}".format(ans))
```
Q381
```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e8-1;
int pr[N+1],v[N+1],m=0;
int main(){
    ll inv2,inv3,inv4,inv6,inv24;
    ll ans=0;
    for(int i=2;i<=N;i++){
        if(v[i]==0){
            v[i]=i;pr[++m]=i;
            if(i>=5){
                inv2=(i+1)>>1;
                if(i%3==1) inv3=(i+i+1)/3;
                else inv3=(i+1)/3;
                inv4=inv2*inv2%i;
                inv6=inv2*inv3%i;
                inv24=inv4*inv2%i*inv3%i;
                ll s=(i+i-inv2-inv24+inv6)%i;
                ans+=s;
            }
        }
        for(int j=1;j<=m;j++){
            if(pr[j]>v[i]||pr[j]>N/i) break;
            v[i*pr[j]]=pr[j];
        }
    }
    printf("%lld\n",ans);
}
```
Q387
```
from Miller_Rabin import Miller_Rabin

ls = [[1, 2, 3, 4, 5, 6, 7, 8, 9]]
tp = [1, 3, 7, 9]


def is_Harshad(n: int):
    return n % sum(int(x) for x in str(n)) == 0


for i in range(12):
    ls.append([])
    for x in ls[i]:
        for j in range(10):
            t = x * 10 + j
            if is_Harshad(t):
                ls[i + 1].append(t)

ans = 0
for v in ls:
    for n in v:
        if not Miller_Rabin(n // sum(int(x) for x in str(n))):
            continue
        for y in tp:
            w = n * 10 + y
            if Miller_Rabin(w):
                ans += w
print(ans)
```
Q389
```
# include <bits/stdc++.h>
using namespace std;
vector<int>d={4,6,8,12,20};
int main(){
    int m=1;
    vector<double>fp1(2);
    fp1[1]=1;
    for(int x:d){
        vector<double>fp2(1,1);
        vector<double>fn1(m*x+1,0);
        for(int i=1;i<=m;i++){
            vector<double>fn2(x*i+1);
            for(int j=0;j<=x*(i-1);j++)
                for(int k=1;k<=x;k++)
                    fn2[j+k]+=fp2[j]/x;
            fp2=fn2;
            for(int j=1;j<=x*i;j++)
                fn1[j]+=fp1[i]*fp2[j];
        }
        fp1=fn1;
        m*=x;
    }
    double ex1=0,ex2=0;
    for(int i=1;i<=m;i++){
        ex1+=fp1[i]*i;
        ex2+=fp1[i]*i*i;
    }
    double ans=ex2-ex1*ex1;
    printf("%.4f\n",ans);
}
```
Q401
```
#include <bits/stdc++.h>
# define X first
# define Y second
using namespace std;
typedef long long ll;
const ll N=1e15;
ll mod=1e9;
ll f(ll n){
    ll x=n,y=n+1,z=n*2+1;
    if(x%2==0) x>>=1;
    else y>>=1;
    if(x%3==0) x/=3;
    else if(y%3==0) y/=3;
    else z/=3;
    x%=mod,y%=mod,z%=mod;
    return x*y%mod*z%mod;
}
int main(){
    ll ans=0;
    for(ll x=1,gx;x<=N;x=gx+1){
        gx=N/(N/x);
        ll c=(N/x)%mod;
        ans=(ans+(f(gx)-f(x-1)+mod)*c)%mod;
    }
    printf("%lld\n",ans);
}
```
Q407
```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e7;
int mxp[N+4];
int main(){
    for(int p=2;p<=N;p++)
        if(!mxp[p])
            for(int i=p;i<=N;i+=p) mxp[i]=p;
    ll ans=0;
    for(int n=1;n<=N;n++){
        int m=1;
        for(int tp=n;tp>1;){
            int t=1;
            for(int p=mxp[tp];tp%p==0;tp/=p,t*=p);
            m=max(m,t);
        }
        int a=n-1;
        for(a=a-a%m;a>=0;a-=m){
            if(a+1<n&&1ll*a*(a+1)%n==0){
                ++a;break;
            }
            if(1ll*a*(a-1)%n==0) break;
        }
        ans+=a;
    }
    printf("%lld\n",ans);
}
```
Q425
```
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e7;
int pr[N+4],v[N+4],m=0;
int fa[N+4];
int now[1004],p=0;
int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
void merge(int x,int y){fa[find(x)]=find(y);}
int main(){
    for(int i=1;i<=N;i++)
        fa[i]=i;
    for(int i=2;i<=N;i++){
        if(v[i]==0){
            v[i]=i;pr[++m]=i;
        }
        for(int j=1;j<=m;j++){
            if(pr[j]>v[i]||pr[j]>N/i) break;
            v[i*pr[j]]=pr[j];
        }
    }
    ll ans=0;
    for(int i=1;i<=m;i++){
        int u=pr[i];
        string s=to_string(u);
        string t=s;
        p=0;
        for(int i=0;i<s.size();i++){
            char ch=s[i];
            for(int j=(i==0?1:0);j<10;j++){
                t[i]='0'+j;
                now[++p]=atoi(t.c_str());
            }
            t[i]=ch;
        }
        if(t.size()>=2&&t[1]!='0'){
            t=t.substr(1);
            now[++p]=atoi(t.c_str());
        }
        for(int i=1;i<=p;i++){
            int k=now[i];
            if(k>=u||v[k]!=k) continue;
            merge(k,u);
        }
        if(find(2)!=find(u)) ans+=u;
    }
    printf("%lld\n",ans);
}

```

Q429
```
#include <bits/stdc++.h>
# define X first
# define Y second
using namespace std;
typedef long long ll;
const int N=1e8;
ll mod=1e9+9;
ll qpow(ll n,ll m){
    ll ans=1;
    for(;m;m>>=1){
        if(m&1) ans=ans*n%mod;
        n=n*n%mod;
    }
    return ans;
}
int cal(int n,int p){
    int ans=0;
    for(;n;n/=p)
        ans+=n/p;
    return ans;
}
int pr[N+4],v[N+4],m=0;
int main(){
    for(int i=2;i<=N;i++){
        if(v[i]==0){
            v[i]=i;pr[++m]=i;
        }
        for(int j=1;j<=m;j++){
            if(pr[j]>v[i]||pr[j]>N/i) break;
            v[i*pr[j]]=pr[j];
        }
    }
    ll ans=1;
    for(int i=1;i<=m;i++){
        ll cnt=cal(N,pr[i]);
        ans=ans*(qpow(pr[i],cnt*2)+1)%mod;
    }
    printf("%lld\n",ans);
}
```
Q443

```
# include <bits/stdc++.h>
# define X first
# define Y second
# define lb(x) ((x) & (-x))
# define mem(a,b) memset(a,b,sizeof(a))
# define debug freopen("r.txt","r",stdin)
# define pi pair<int,int>
using namespace std;
typedef long long ll;
const ll Q = 1e15;
const int N=sqrt(Q)*2;
int v[N],pr[N],p=0;
ll px[34],q=0;
void fact(ll x){
    q=0;
    for(int i=1;i<=p&&1ll*pr[i]*pr[i]<=x;i++)
    if(x%pr[i]==0){
        px[++q]=pr[i];
        for(;x%pr[i]==0;x/=pr[i]);
    }
    if(x!=1) px[++q]=x;
}
int main(){
    for (int i = 2; i < N; i++) {
        if (v[i] == 0) {
            pr[++p] = i;
            v[i] = i;
        }
        for (int j = 1; j <= p; j++) {
            if (pr[j] > v[i] || pr[j] > N / i) break;
            v[i * pr[j]] = pr[j];
        }
    }
    ll n=4,g=13;
    //找最小的k使得gcd(n+k+1,g+k)!=1，等价于gcd(g-n-1,n+k+1)!=1;
    for(;;){
        fact(g-n-1);
        ll nxt=1e18;
        //找到下一个最小的n'>n，使得gcd(n',g(n'-1))>1，
        //tn则是一个新的g(n'-1)，使得此时的gcd(n',g(n'-1))>1。
        for(int i=1;i<=q;i++){
            ll tn=(g+px[i]-1)/px[i]*px[i];
            nxt=min(nxt,tn);
        }
        ll k=nxt-g;
        ll np=n+1+k;
        if(np>Q){
            g+=Q-n;
            break;
        }
        g=nxt+__gcd(np,nxt);
        n=np;
        if(n>=Q) break;
    }
    printf("%lld\n",g);
}

```

Q458
```
m = 7
n = 10**12
mod = 10 ** 9


def mul(a: list, b: list):
    n = len(a)
    c = [0 for i in range(n)]
    for k in range(n):
        for i in range(n):
            c[i] = (c[i] + a[k] * b[k][i]) % mod
    return c


def mul_self(b: list):
    n = len(b)
    c = [[0 for i in range(n)] for i in range(n)]
    for k in range(n):
        for i in range(n):
            for j in range(n):
                c[i][j] = (c[i][j] + b[i][k] * b[k][j]) % mod
    return c


a = [1] + [0 for i in range(m-1)]
b = [[0 for i in range(m)] for i in range(m)]
for i in range(m - 1):
    b[i][i + 1] = m - i
for i in range(m):
    for j in range(1, i + 1):
        b[i][j] = 1
while n:
    if n & 1:
        a = mul(a, b)
    b = mul_self(b)
    n >>= 1
ans = sum(a) % mod
print(ans)
```
Q491
```
B = 2
B += 1
f = [{} for i in range(B ** 10)]
for i in range(1, 10):
    f[B ** i][i] = 1
for st in range(len(f)):
    ls = []
    for i in range(10):
        ls.append(st // (B ** i) % B)
    cnt = sum(ls)
    for s, val in f[st].items():
        for i in range(10):
            if ls[i] == B - 1:
                continue
            if cnt % 2 == 0:
                now = s + i
            else:
                now = s - i
            newst = st + B ** i
            if now not in f[newst].keys():
                f[newst][now] = 0
            f[newst][now] += val
ans = sum(val for s, val in f[-1].items() if s % 11 == 0)
print(ans)
```
Q493
```
C = []
for i in range(80):
    C.append([0 for _ in range(i + 1)])
    C[i][0] = C[i][i] = 1
    for j in range(1, i):
        C[i][j] = C[i - 1][j - 1] + C[i - 1][j]

print("{:.9f}".format(7 * (1 - C[60][20] / C[70][20])))
```
Q500
```
M = 500500
mod = 500500507
pr = []
N = M * int(len(bin(M)) - 2)
flag = [0 for _ in range(N + 1)]
for i in range(2, N + 1):
    if flag[i] == 0:
        pr.append(i)
        for j in range(i * i, N + 1, i):
            flag[j] = 1
q = PriorityQueue()
for i in range(M):
    q.put(pr[i])
ans = 1
for i in range(M):
    x = q.get()
    ans = ans * x % mod
    q.put(x * x)
print(ans)
```
Q504
```
#include <bits/stdc++.h>
# define X first
# define Y second
using namespace std;
const int N=100;
int g[N+1][N+1];
bool isq[N*N*4+1];
int gcd(int a,int b){
    return b?gcd(b,a%b):a;
}
int main(){
    for(int i=1;i*i<=4*N*N;i++)
        isq[i*i]=1;
    for(int i=1;i<=N;i++)
        for(int j=1;j<=N;j++)
            g[i][j]=gcd(i,j);
    int ans=0;
    for(int a=1;a<=N;a++)
        for(int b=1;b<=N;b++)
            for(int c=1;c<=N;c++)
                for(int d=1;d<=N;d++){
                    int v=(a*b+b*c+c*d+d*a-(g[a][b]+g[b][c]+g[c][d]+g[d][a])+2)>>1;
                    if(isq[v]) ++ans;
                }
    printf("%d\n",ans);
}
```
Q511
```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1234567898765,M=4321,O=64;
ll mod=1e9;
ll cnt[M];
ll a[M],b[O][M];
void getd(ll N){
    for(ll i=1;i*i<=N;i++)
    if(N%i==0){
        ++cnt[(i+1)%M];
        if(i*i!=N) ++cnt[(N/i+1)%M];
    }
}
void cal(ll a[M],ll b[M],ll ans[M]){
    ll c[M]={0};
    for(int i=0;i<M;i++)
        for(int j=0;j<M;j++)
            c[(i+j)%M]=(c[(i+j)%M]+a[i]*b[j])%mod;
    memcpy(ans,c,sizeof(c));
}
int main(){
    getd(N);
    a[0]=1;
    memcpy(b[0],cnt,sizeof(b[0]));
    for(int i=1;i<O;i++)
        cal(b[i-1],b[i-1],b[i]);
    for(int i=0;i<O;i++)
        if(N>>i&1)
            cal(a,b[i],a);
    printf("%lld\n",a[0]);
}
```
Q512
```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=5e8;
const int M=(N+1)>>1;
int phi[M+2];
int main(){
    for(int i=1;i<=M;i++)
        phi[i]=2*i-1;
    for(int i=2;i<=M;i++){
        int v=2*i-1;
        if(phi[i]==v){
            for(int j=i;j<=M;j+=v)
                phi[j]=phi[j]/v*(v-1);
        }
    }
    ll ans=0;
    for(int i=1;i<=M;i++)
        ans+=phi[i];
    printf("%lld\n",ans);
}
```
Q516
```
N = 10 ** 12
ls = []
pr = []
for i in range(64):
    if 2 ** i > N:
        break
    for j in range(64):
        if 2 ** i * 3 ** j > N:
            break
        for k in range(64):
            v = 2 ** i * 3 ** j * 5 ** k
            if v > N:
                break
            ls.append(v)
            if Miller_Rabin(v + 1) and v + 1 > 5:
                pr.append(v + 1)
ls.sort()
pr.sort()
q = Queue()
q.put((1, 1))
ans = 0
while not q.empty():
    x, mxp = q.get()
    for v in ls:
        if x * v > N:
            break
        ans += x * v
    for i in range(bisect_right(pr, mxp), len(pr)):
        if x * pr[i] > N:
            break
        q.put((x * pr[i], pr[i]))

ans &= 0xffffffff
print(ans)
```

Q518
```
# include <bits/stdc++.h>
# define pi pair<int,int>
# define X first
# define Y second
using namespace std;
typedef long long ll;
const int N=1e8;
int pr[N+4],f[N+4],v[N+4],m=0;
int main(){
     for(int i=2;i<=N;i++){
        if(v[i]==0){
            f[i]=i;v[i]=i;pr[++m]=i;
        }
        for(int j=1;j<=m;j++){
            if(pr[j]>v[i]||pr[j]>N/i) break;
            v[i*pr[j]]=pr[j];
            f[i*pr[j]]=(f[i]%pr[j]==0?f[i]/pr[j]:f[i]*pr[j]);
        }
    }
    unordered_map<int,vector<int>>mp;
    for(int i=1;i<=m;i++){
        int p=pr[i];
        mp[f[p+1]].push_back(p+1);
    }
    ll ans=0;
    for(auto it=mp.begin();it!=mp.end();it++){
        vector<int>&a=it->Y;
        for(int i=0;i<a.size();i++)
            for(int j=i+1;j<a.size();j++){
                ll w=sqrt(1ll*a[i]*a[j])+1e-8;
                if(v[w-1]==w-1) ans+=w+a[i]+a[j]-3;
            }
    }
    printf("%lld\n",ans);
}
```
Q549
```
#include <bits/stdc++.h>
# define X first
# define Y second
using namespace std;
typedef long long ll;
const int N=1e8;
int s[N+4];
int solve(int p,int e){
    ll k;
    for(k=p;;k+=p){
        ll t=k;
        for(;t%p==0&&e>0;--e,t/=p);
        if(e==0) break;
    }
    return k;
}
int main(){
    for(int i=2;i<=N;i++){
        if(s[i]!=0) continue;
        for(ll j=i,c=1;j<=N;j*=i,++c){
            int mx=solve(i,c);
            for(ll k=j;k<=N;k+=j)
                s[k]=max(s[k],mx);
        }
    }
    ll ans=0;
    for(int i=2;i<=N;i++){
        ans+=s[i];
    }
    printf("%lld\n",ans);
}
```
Q577
```
N = 12345
ans = 0
for n in range(N-2):
    ans += Fraction(1, 216) * n ** 4 + Fraction(1, 12) * n ** 3 + Fraction(37, 72) * n ** 2 + [Fraction(5, 4), Fraction(139, 108), Fraction(131, 108)][n % 3] * n + [1, Fraction(10, 9), Fraction(7, 9)][n % 3]
print(ans)
# A011779
```

Q587
```
rate = 0.001
S0 = 1 - pi / 4
k = 1
l, r = 1, 10 ** 9
while l < r:
    k = (l + r) >> 1
    a = 1 + k * k
    b = -k * k * 2 - k * 2
    c = k * k
    d = b * b - 4 * a * c
    x = (-b - d ** 0.5) / (a * 2)
    s0 = x * x / k / 2
    x -= 1
    s1 = x / 2 * (1 - x * x) ** 0.5 + asin(x) / 2 - x
    # 此处为对下限为x，上限为0中1-sqrt(1-x^2)的积分。
    S1 = s0 + s1
    if S1 / S0 < rate:
        r = k
    else:
        l = k + 1
print(l)
```
Q601
```
L, R = 1, 31


def P(s: int, N: int):
    N -= 1
    m = 1
    for i in range(1, s + 1):
        m = lcm(m, i)
    c1 = N // m
    if m == 1:
        c1 -= 1
    m = lcm(m, s + 1)
    c2 = N // m
    return c1 - c2


ans = 0
for i in range(L, R + 1):
    ans += P(i, 4 ** i)
print(ans)
```
Q607
```
from math import sin, pi

s = d = 100 / 2 ** 0.5
v = [10, 9, 8, 7, 6, 5, 10]
dis = [(d - 50) / 2, 10, 10, 10, 10, 10, (d - 50) / 2]
l, r = 0, pi / 2
ans = 0
for _ in range(100):
    mid = 0.5 * (l + r)
    sinv = [sin(mid)]
    for i in range(1, len(v)):
        sinv.append(sinv[0] / v[0] * v[i])
    tm = 0
    len_x = 0
    for i in range(len(v)):
        sin_val = sinv[i]
        cos_val = (1 - sin_val ** 2) ** 0.5
        tan_val = sin_val / cos_val
        d = dis[i] / cos_val
        tm += d / v[i]
        len_x += dis[i] * tan_val
    if len_x < s:
        l = mid
    else:
        r = mid
    ans = tm
print("{:.10f}".format(ans))
'''
费马原理：光传播的路径是光程取极值的路径。这个极值可能是极大值、极小值，甚至是函数的拐点。 
斯涅尔定律：
1.折射光线在入射面内。
2.设界面A1的折射率为n1，入射角为A1，界面A2的折射率为n2，折射角为A2。那么满足:
sinA1*n1=sinA2*n2.
其中n=c/v. 
c为真空中的光速，v为光在特定介质中的传播速度。
'''
```
Q613
```
from math import acos, pi
from scipy.integrate import dblquad

x0 = 30
y0 = 40

ans, err = dblquad(
    lambda y, x: acos(
        (x * x + y * y - x * x0 - y * y0) / ((x0 - x) ** 2 + y ** 2) ** 0.5 / ((y0 - y) ** 2 + x ** 2) ** 0.5) / (
                             2 * pi),
    0,
    x0,
    0,
    lambda x: y0 - y0 / x0 * x)
ans /= x0 * y0 / 2
print("{:.10f}".format(ans))
'''
答案是1/2-(a/4pib)*log((a^2+b^2)/a^2)-(b/4pia)*log((a^2+b^2)/b^2)
'''
```
Q622
```
Q = 60
R = 2 ** Q - 1
ls = Get_Divisors(R)
ans = 0
for d in ls:
    p = 1
    while p <= Q:
        if quick_power(2, p, d) == 1:
            break
        p += 1
    if p == Q:
        ans += d+1
print(ans)
'''
原问题等价于求2模n-1的阶数r。其中有多少个r的值为60。
'''
```
Q630
```
# include <bits/stdc++.h>
# define pi pair<int,int>
using namespace std;
typedef long long ll;
const int N=2500;
int S[N*2+4],T[N*2+4];
ll solve(vector<pi>&v){
    map<pi,unordered_set<double>>mp;
    sort(v.begin(),v.end());
    v.resize(unique(v.begin(),v.end())-v.begin());
    int x1,y1,x2,y2;
    for(int i=0;i<v.size();i++)
    for(int j=0;j<i;j++){
        tie(x1,y1)=v[i];
        tie(x2,y2)=v[j];
        int x=x2-x1,y=y1-y2;
        double z=x1*y2-x2*y1;
        int g=__gcd(x,y);
        x/=g;y/=g;z/=g;
        if(x<0||x==0&&y<0){
            x=-x;y=-y;z=-z;
        }
        mp[pi(x,y)].insert(z);
    }
    int m=0;
    for(auto &[k,st]:mp)
        m+=st.size();
    ll ans=0;
    for(auto &[k,st]:mp)
        ans+=1ll*st.size()*(m-st.size());
    return ans;
}
int main(){
    S[0]=290797;
    for(int i=1;i<=N*2;i++){
        S[i]=1ll*S[i-1]*S[i-1]%50515093;
        T[i]=S[i]%2000-1000;
    }
    vector<pi>v;
    for(int i=2;i<=N*2;i+=2)
        v.push_back(pi(T[i-1],T[i]));
    printf("%lld\n",solve(v));
}

```

Q650
```
mp, mq = {}, {}
m = 20000
mod = 1000000007
ans = 0
fp = [[1] for _ in range(m + 1)]


def getfp(n: int, m: int):
    while m >= len(fp[n]):
        fp[n].append(fp[n][-1] * n % mod + 1)
    return fp[n][m]


for n in range(1, m + 1):
    mul = 1
    ls = naive_factorization(n)
    for x, y in ls:
        if x not in mp.keys():
            mp[x] = mq[x] = 0
        mp[x] += y
    for x, y in mp.items():
        mq[x] += y
    for p in mp.keys():
        e = mp[p] * (n + 1) - mq[p] * 2
        mul = mul * getfp(p, e) % mod
    ans = (ans + mul) % mod
    print(n, mul)
print(ans)
```
Q684
```Python
N = 90
mod = 10 ** 9 + 7
f = [0, 1]
for i in range(2, N + 1):
    f.append(f[-1] + f[-2])
inv9 = pow(9, mod - 2, mod)
ans = 0
for i in range(2, N + 1):
    w = f[i]
    c, r = divmod(w, 9)
    pw = pow(10, c, mod)
    if c > 1:
        d = 1
    ans = (ans + (pw - 1) + pw * r) % mod
print(ans)
```
Q686
```Python
i, c = 1, 0
lg = log10(2)

lt = [196, 289, 485]
l, r = log10(1.23), log10(1.24)
pre = 0
i = 90
c = 2
s = lg * i
while c < 678910:
    j = 0
    while j < 3:
        ns = s + lg * lt[j]
        if l <= ns - int(ns) < r:
            break
        j += 1
    if j == 4:
        print("FAIL")
        exit()
    s += lg * lt[j]
    i += lt[j]
    c += 1
print(i)
```
Q688
```
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const ll Q=1e16;
ll mod=1e9+7;
ll inv2=(mod+1)>>1;
int main(){
    ll ans=0;
    for(ll k=1;;k++){
        ll w=k*(k+1)/2;
        if(w>Q) break;
        ll t=Q-w;
        ll block=(t+1)/k%mod,res=(t+1)%k%mod;
        ans=(ans+k*block%mod*(block+1)%mod*inv2%mod+(block+1)*res%mod)%mod;
    }
    printf("%lld\n",ans);
}
```

Q692
```Python
import bisect
# Zeckendorf's theorem
f = [1, 2]
for i in range(100):
    f.append(f[-1] + f[-2])
G = {1: 1, 2: 3}


def getG(n: int):
    if n in G.keys():
        return G[n]
    p = bisect.bisect_right(f, n) - 1
    if f[p] == n:
        G[n] = getG(f[p - 2]) + getG(f[p - 1]) + f[p] - f[p - 2]
    else:
        G[n] = getG(f[p]) + getG(n - f[p])
    return G[n]


print(getG(23416728348467685))
```
Q694
```
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const ll Q=1e18;
const int M=pow(Q,1.0/3);
bool b[M+4];
int pr[M/3+100],m=0;
int main(){
    for(int i=2;i<=M;i++){
        if(b[i]) continue;
        pr[++m]=i;
        for(ll j=1ll*i*i;j<=M;j+=i)
            b[j]=1;
    }
    set<ll>st;
    unordered_set<ll>st2;
    st.insert(1);
    for(int i=1;i<=m;i++){
        st2.clear();
        for(ll x:st){
            int cnt=0;
            while(x<=Q/pr[i]){
                x*=pr[i];
                if(++cnt>=3)
                    st2.insert(x);
            }
            if(cnt<3) break;
        }
        for(ll x:st2)
            st.insert(x);
    }
    vector<ll>v(st.begin(),st.end());
    sort(v.begin(),v.end());
    ll ans=0;
    for(ll x:st)
        ans+=Q/x;
    //printf("%lld\n",st.size());
    printf("%lld\n",ans);
}
```

Q700
```Python
mod = 4503599627370517
a = 1504170715041707
l = r = ans = a
while l > 0:
    nxt = (l + r) % mod
    if nxt < l:
        l = nxt
        ans += l
    else:
        r = nxt
print(ans)
```
Q704
```
# A119387
N = 10**16
# 1~N中所有数加起来一共有cnt位
cnt = 0
l = 1
while l <= N:
    r = min(l * 2 - 1, N)
    cnt += (r - l + 1) * len(bin(l)[2:])
    l = r + 1

# cnt1: 1~N中所有数，如果最后x位是以01...1结尾，那么cnt1+=x。
cnt1 = 0
M = len(bin(N)[2:])
for i in range(1, M + 1):
    cnt1 += (N + 2 ** (i - 1) + 1) // (2 ** i) * i - 1
ans = cnt - cnt1
print(ans)
```

Q710
```
# include <bits/stdc++.h>
using namespace std;
const int N = 2000004;
int s[N][2],f[N][2],mod=1000000;
int main(){
    f[0][0]=s[0][0]=1;
    f[1][0]=1;s[1][0]=2;
    for(int n=2;n<N;n++){
        f[n][0]=(s[n-1][0]-f[n-2][0]+mod)%mod;
        f[n][1]=(s[n-1][1]+f[n-2][0])%mod;
        s[n][0]=(s[n-1][0]+f[n][0])%mod;
        s[n][1]=(s[n-1][1]+f[n][1])%mod;
        int a=s[n/2][1];
        if(n%2==0) a=(a+f[n/2-1][0])%mod;
        if(n>42&&a%mod==0) {printf("%d\n",n);break;}
    }
}
```
Q719
```C++
# include <bits/stdc++.h>
typedef long long ll;
using namespace std;
ll n=1000000,m;
int a[15],p=0;
bool dfs(int f,ll s,ll w){
    if(s>m||w>m) return 0;
    if(f==p){
        return s+w==m;
    }
    if(dfs(f+1,s+w,a[f])) return 1;
    if(dfs(f+1,s,w*10+a[f])) return 1;
    return 0;
}
int main(){
    ll ans=n*n;
    for(m=4;m<n;m++){
        ll v=m*m;
        p=0;
        for(;v;v/=10) a[p++]=v%10;
        reverse(a,a+p);
        if(dfs(0,0,0)) ans+=m*m;
    }
    printf("%lld\n",ans);
}
```
Q725
```
n = 2020
mod = int(1e16)
c = [0 for _ in range(10)]
f = [1]
for _ in range(n):
    f.append((f[-1] * 10 + 1) % mod)
fac = [1]
for i in range(1, 11):
    fac.append(fac[-1] * i)

ans = 0


def cal(d: list, bt: int):
    s = 0
    for j in range(10):
        if d[j] == 0:
            continue
        d[j] -= 1
        val = 1
        for k in range(bt - 1 - d[0]):
            val *= bt - k - 1
        for k in range(1, 10):
            val //= fac[d[k]]
        s += j * val
        d[j] += 1
    return s


def solve(s: int):
    global ans
    d = list(c)
    d[s] += 1
    cnt = sum(d)
    d[0] = n - cnt
    value = cal(d, n)
    ans = (ans + f[n - 1] * value) % mod


def dfs(s: int, nw: int):
    if s > 9:
        return
    c[nw] += 1
    solve(s)
    for j in range(nw, 10):
        dfs(s + j, j)
    c[nw] -= 1


for i in range(1, 10):
    dfs(i, i)
print(ans)
```
Q739

```
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const int N = 1e8;
const int M = N*2;
const int n=N-1;
ll mod=1e9+7;
ll inv(ll n,ll p){
    ll ans=1,m=p-2;
    for(;m;m>>=1){
        if(m&1) ans=ans*n%mod;
        n=n*n%mod;
    }
    return ans;
}

int *fac,*finv;
int l[N+4],invn=inv(n,mod);
int C(int n,int m){
    return 1ll*fac[n]*finv[m]%mod*finv[n-m]%mod;
}
int T(int n,int k){
    //A106566
    if(n==0) return 0;
    else return 1ll*C(2*n-k-1,n-k)*k%mod*invn%mod;
}
int main(){
    fac = new int[M+4];
    finv = new int[M+4];
    fac[0]=fac[1]=1;
    finv[0]=1;
    for(int i=2;i<=M;i++)
        fac[i]=1ll*fac[i-1]*i%mod;
    finv[M]=inv(fac[M],mod);
    for(int i=M-1;i>0;i--)
        finv[i]=1ll*finv[i+1]*(i+1)%mod;
    int x=1,y=3;
    int ans=0;
    for(int i=0;i<=n;i++){
        ans=(ans+1ll*T(n,i)*x)%mod;
        int t=(x+y)%mod;
        x=y;y=t;
    }
    delete fac;
    delete finv;
    printf("%d\n",ans);
}
```

Q743
```
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const ll N = 1e16;
const ll K = 1e8;
const ll B = N/K;
ll mod=1e9+7;
ll qpow(ll n,ll m,ll mod){
    ll ans=1;
    for(;m;m>>=1){
        if(m&1) ans=ans*n%mod;
        n=n*n%mod;
    }
    return ans;
}
ll inv(ll n,ll p){
    return qpow(n,p-2,p);
}
int fac[K + 4],finv[K + 4];
int C(int n,int m){
    return 1ll*fac[n]*finv[m]%mod*finv[n-m]%mod;
}
int main(){
    fac[0]=fac[1]=1;
    finv[0]=1;
    for(int i=2; i <= K; i++)
        fac[i]=1ll*fac[i-1]*i%mod;
    finv[K]=inv(fac[K], mod);
    for(int i= K - 1; i > 0; i--)
        finv[i]=1ll*finv[i+1]*(i+1)%mod;
    ll pw2B=qpow(2,B,mod);
    ll invpw4B=inv(pw2B*pw2B%mod,mod);
    ll now=qpow(2,N,mod);
    ll ans=0;
    for(int i=0;i<=K/2;i++){
        ans=(ans+1ll*C(K,i)*C(K-i,i)%mod*now)%mod;
        now=now*invpw4B%mod;
    }
    printf("%lld\n",ans);
}
//$d=\frac{n}{k},val=\sum_{k=0}^{\lfloor\frac{n}{2}\rfloor}\frac{n!}{(n-2k)!(k!)^2}2^{d(n-2k)}$

```
Q745
```C++
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=10000004;
int f[N],mod=1e9+7;// Jordan function J_2(n)
int pr[N/4],v[N],m=0;
int main(){
    f[1]=1;
    ll k=1e14;
    ll ans=k;
    int n=sqrt(k);
    for(int i=2;i<=n;i++){
        if(v[i]==0){
            v[i]=i;f[i]=(1ll*i*i-1)%mod;
            pr[++m]=i;
        }
        for(int j=1;j<=m;j++){
            if(pr[j]>v[i]||pr[j]>n/i) break;
            v[i*pr[j]]=pr[j];
            if(pr[j]==v[i]) f[i*pr[j]]=1ll*f[i]*pr[j]*pr[j]%mod;
            else f[i*pr[j]]=1ll*f[i]*(1ll*pr[j]*pr[j]-1)%mod;
        }
        ans=(ans+1ll*f[i]*(k/(1ll*i*i)%mod))%mod;
    }
    printf("%lld\n",ans);
}
```
Q749
```
#include <bits/stdc++.h>
# define mem(a,b) memset(a,b,sizeof(a))
typedef long long ll;
using namespace std;
const int N=16;
const ll M=1e16;
const int O=64;
ll pw[14][66];
int c0[10],c1[10];
int n;
vector<ll>a;
bool ok(ll x){
    memcpy(c1,c0,sizeof(c1));
    for(int i=0;i<N;i++,x/=10)
        if(--c1[x%10]<0) return 0;
    return x==0;
}
void dfs(int k,int n,int p,ll s){
    if(p==0){
        c0[0]=n;
        if(ok(s-1))
            a.push_back(s-1);
        if(ok(s+1)) a.push_back(s+1);
        return;
    }
    for(int i=0;i<=n;i++){
        if(pw[p][k]==-1) break;
        c0[p]=i;
        dfs(k,n-i,p-1,s+pw[p][k]*i);
    }
}

int main(){
    mem(pw,-1);
    pw[0][0]=1;
    for(int j=1;j<O;j++)
        pw[0][j]=0;
    for(int i=0;i<10;i++){
        pw[i][0]=1;
        for(int j=1;j<O;j++){
            pw[i][j]=pw[i][j-1]*i;
            if(i>0&&pw[i][j]>M/i) break;
        }
    }
    for(int k=2;k<=N;k++)
        dfs(k,N,9,0);
    ll ans=0;
    sort(a.begin(),a.end());
    for(ll x:a)
        ans+=x;
    printf("%lld\n",ans);
}

```

Q751
```
l, r, n = 2, 3, 30
for _ in range(100):
    theta = 0.5 * (l + r)
    b = [theta]
    a = [int(theta)]
    for i in range(n):
        b.append(int(b[-1]) * (b[-1] - int(b[-1]) + 1))
        a.append(int(b[-1]))
    tau = str(a[0]) + "."
    for i in range(1, n):
        tau += str(a[i])
    tau = float(tau)
    if tau < theta:
        r = theta
    else:
        l = theta
print("{}.".format(a[0]) + "".join(str(x) for x in a[1:])[:24])
```
Q754
```C++
# include <bits/stdc++.h>
using namespace std;
const int N=10002,M=100000000;
bool b[N];
int a[2004],p=0;
int pr[N],q=0;
int mod=1000000007;
int qpow(int n,int m){
    int ans=1;
    for(;m;m>>=1){
        if(m&1) ans=1ll*ans*n%mod;
        n=1ll*n*n%mod;
    }
    return ans;
}
void fact(int x){
    p=0;
    for(int i=1;i<=q&&pr[i]*pr[i]<=x;++i){
        if(x%pr[i]==0){
            a[p++]=pr[i];
            for(;x%pr[i]==0;x/=pr[i]);
        }
    }
    if(x!=1) a[p++]=x;
}
int main(){
    for(int i=2;i<N;++i){
        if(b[i]) continue;
        pr[++q]=i;
        for(int j=i*i;j<N;j+=i)
            b[j]=1;
    }
    int ans=1;
    for(int i=2;i<=M;i++){
         fact(i);
         int s=0;
         for(int st=0;st<(1<<p);st++){
             int m=1,c=0;
             for(int i=0;i<p;i++)
                if(st>>i&1) m*=a[i],++c;
             if(c&1) s-=(M-i)/m;
             else s+=(M-i)/m;
         }
         ans=1ll*ans*qpow(i,s)%mod;
    }
    printf("%d\n",ans);
}

```
Q755
```Python
f = [1, 2]
s = [1, 3]
N = 10 ** 13
for i in range(100):
    w = f[-1] + f[-2]
    if w > N:
        break
    f.append(w)
    s.append(s[-1] + w)


def dfs(fl: int, now: int):
    if now < 0:
        return 0
    if fl == -1:
        return 1
    elif s[fl] <= now:
        return 1 << (fl + 1)
    else:
        return dfs(fl - 1, now) + dfs(fl - 1, now - f[fl])


print(dfs(len(f) - 1, N))
```
Q757
```Python
N = 10**14
lm2 = int(N ** 0.5 + 2)
lm4 = int(N ** 0.25 + 2)
st = set()
for dis in range(1, lm4):
    for mid in range(dis, lm2):
        u = mid * dis
        if u > lm2:
            break
        v, a, b = u - dis, mid + u - dis - 1, mid + u
        n = a * u
        if n > N:
            break
        if n == b * v:
            st.add(n)
print(len(st)-1)
```
Q788

```
N = 2022
mod = 10 ** 9 + 7
C = [[0 for i in range(j + 1)] for j in range(N + 1)]
for i in range(N + 1):
    C[i][0] = C[i][i] = 1
    for j in range(1, i):
        C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod
ans = 0
for n in range(1, N + 1):
    ans += 9
    for i in range(n // 2 + 1, n):
        ans = (ans + 9 * C[n - 1][i - 1] * pow(9, n - i, mod) + 9 * C[n - 1][i] * pow(9, n - i, mod)) % mod
print(ans)
```

Q793
```
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const int N=1000003;
ll S[N+4],m=(1ll*N*(N-1)/2+1)>>1;
bool ok(ll x){
    ll ans=0;
    for(int i=0;i<N;i++){
        ll w=x/S[i];
        int p=upper_bound(S,S+N,w)-S;
        if(p<=i) break;
        ans+=p-i-1;
    }
    return ans>=m;
}
int main(){
    S[0]=290797;
    for(int i=1;i<N;i++)
        S[i]=S[i-1]*S[i-1]%50515093;
    sort(S,S+N);
    ll l=1,r=1e17;
    while(l<r){
        ll mid=(l+r)>>1;
        if(ok(mid)) r=mid;
        else l=mid+1;
    }
    printf("%lld\n",l);
}

```
Q461
```
#include <bits/stdc++.h>
# define mem(a,b) memset(a,b,sizeof(a))
# define pdi pair<double,int>
# define X first
# define Y second
using namespace std;
const int N=10000;
double e=exp(1),pi=acos(-1.0);
pdi pa[N*N];
double f[N+N];
int m=0,n=0;
int main(){
    double pi=acos(-1);
    double mx=log(pi+1);
    for(int i=0;i<N+N;i++){
        double e=1.0*i/N;
        f[m++]=exp(e)-1;
        if(e>mx) break;
    }
    for(int i=0;i<m;i++)
        for(int j=0;j<=i;j++){
            double w=f[i]+f[j];
            pa[n++]=pdi(w,i*i+j*j);
            if(w>pi) break;
        }
    sort(pa,pa+n);
    double eps=1e9;
    int ans=0;
    for(int l=0,r=n-1;l<n;l++){
        for(;r>=0&&pa[l].X+pa[r].X>pi;--r);
        if(r>0){
            double w=abs(pi-pa[l].X-pa[r].X);
            if(w<eps){
                eps=w;ans=pa[l].Y+pa[r].Y;
            }
        }
        if(r+1<n){
            double w=abs(pi-pa[l].X-pa[r+1].X);
            if(w<eps){
                eps=w;ans=pa[l].Y+pa[r+1].Y;
            }
        }
    }
    printf("%d\n",ans);
}

```

Q662

```
#include <bits/stdc++.h>
# define mem(a,b) memset(a,b,sizeof(a))
# define pi pair<int,int>
# define X first
# define Y second
using namespace std;
const int N=10000,M=10000;
vector<pi>v;
vector<int>fib;
int f[N+1][M+1],mod=1e9+7;
int main(){
    int a=1,b=2;
    for(;a<=max(N,M)*2;){
        int c=a+b;
        fib.push_back(a);
        a=b;b=c;
    }
    for(int d:fib){
        for(int x=0;x<=N&&x*x<=d*d;x++){
            int y=int(sqrt(d*d-x*x)+1e-9);
            if(y<=M&&x*x+y*y==d*d){
                v.push_back(pi(x,y));
            }
        }
    }
    f[0][0]=1;
    for(int i=0;i<=N;i++)
        for(int j=0;j<=M;j++){
            if(i==0&&j==0) continue;
            for(auto &[dx,dy]:v)
                if(dx<=i&&dy<=j){
                    f[i][j]+=f[i-dx][j-dy];
                    if(f[i][j]>=mod) f[i][j]-=mod;
                }
        }
    printf("%d\n",f[N][M]);
}

```

Q523

```
# A279683

N = 30
fac = [1]
a = [0]
for i in range(1, N + 1):
    fac.append(fac[-1] * i)
    a.append(a[i - 1] * i + fac[i - 1] * (2 ** (i - 1) - 1))

ans = a[N] / fac[N]
print("{:.2f}".format(ans))

```

Q561
```
# E(m,n)=((n+1)(n+2)/2)^m-(n+1)^m，对式子提公因式(n+1)^m，然后进行判定。

Q = 10 ** 12
M = 904961


def cal(n: int):
    cnt = 0
    M = len(bin(n)[2:])
    for i in range(1, M + 1):
        cnt += (n + 2 ** (i - 1)) // (2 ** i) * i
    return cnt


c0 = Q // 4
c3 = (Q + 1) // 4
ans = cal(c3) * M
if M % 2 == 0:
    tp = cal(c3 >> 1) + cal((c3 + 1) >> 1)
    v = bin(M)[::-1].find('1')
    tp += c0 * (v + 1)
    ans += tp
else:
    ans += cal(c0)
print(ans)
```

Q531

```
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int L=1000000,R=1005000;
int phi[R+4];
ll ex_gcd(ll a,ll b,ll &x,ll &y){
    if(b==0){
        x=1;y=0;return a;
    }
    ll g=ex_gcd(b,a%b,x,y);
    ll z=x-(a/b)*y;
    x=y;y=z;return g;
}
//解不定方程ax+my=c。
ll congruence(ll a,ll c,ll m){
    ll x,y,g;
    g=ex_gcd(a,m,x,y);
    if(c%g!=0) return -1;
    x*=c/g;
    ll t=m/g;
    return (x%t+t)%t;
}
ll CRT(ll b,ll m,ll c,ll n){
    ll y=congruence(m,c-b,n);
    if(y==-1) return -1;
    ll x=m*y+b;
    ll t=m*n;
    return (x%t+t)%t;
}
int main(){
    for(int i=1;i<R;i++)
        phi[i]=i;
    for(int i=2;i<R;i++){
        if(phi[i]!=i) continue;
        phi[i]=i-1;
        for(int j=i+i;j<R;j+=i)
            phi[j]=phi[j]/i*(i-1);
    }
    ll ans=0;
    for(int i=L;i<R;i++){
        for(int j=i+1;j<R;j++){
            ll x=CRT(phi[i],i,phi[j],j);
            if(x!=-1) ans+=x;
        }
    }
    printf("%lld\n",ans);
}
```