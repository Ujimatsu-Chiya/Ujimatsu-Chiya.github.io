## Q161
```Python
n, m = 9, 12
triomino_ls = [
    [(0, 0), (1, 0), (0, 1)],
    [(0, 0), (1, 0), (1, 1)],
    [(0, 0), (0, 1), (1, 1)],
    [(0, 0), (1, 0), (1, -1)],
    [(0, 0), (0, 1), (0, 2)],
    [(0, 0), (1, 0), (2, 0)],
]
if m > n:
    n, m = m, n


def get_empty(grid: tuple):
    for i in range(n):
        if grid[i] != (1 << m) - 1:
            for j in range(m):
                if (grid[i] >> j & 1) == 0:
                    return i, j
    return None


def place_triomino(grid: tuple, x: int, y: int, id: int):
    tp = list(grid)
    for dx, dy in triomino_ls[id]:
        nx, ny = x + dx, y + dy
        if nx < 0 or ny < 0 or nx >= n or ny >= m or tp[nx] >> ny & 1:
            return None
        tp[nx] |= 1 << ny
    return tuple(tp)


cnt = m * n // 3
st = tuple(0 for i in range(n))
ed = tuple((1 << m) - 1 for i in range(n))
f = [{} for i in range(cnt + 1)]
f[0][st] = 1
for i in range(cnt):
    for grid, val in f[i].items():
        x, y = get_empty(grid)
        for k in range(6):
            next = place_triomino(grid, x, y, k)
            if next is None:
                continue
            if next not in f[i + 1].keys():
                f[i + 1][next] = 0
            f[i + 1][next] += val

print(f[cnt][ed])
```
## Q163
```C++
# include <bits/stdc++.h>
# define X first
# define Y second
# define pi pair<int,int>
# define pd pair<double,double>
using namespace std;
typedef long long ll;
map<pi,int>mp;
int b[4004][4004];
int fa[6][4004],m=0;
int get(int x,int y){
    pi pa(x,y);
    if(mp.count(pa)) return mp[pa];
    mp[pa]=++m;
    for(int j=0;j<6;j++)
        fa[j][m]=m;
    return m;
}
int find(int *fa,int x){
    return x==fa[x]?x:fa[x]=find(fa,fa[x]);
}
void merge(int id,int x,int y){
    fa[id][x]=find(fa[id],y);
}
int param[9][7]={
    0,2,6,3,3,4,0,
    1,1,3,2,2,4,0,
    2,0,0,2,0,4,0,
    3,0,0,2,2,3,3,
    4,0,0,1,3,2,6,
    5,2,0,2,2,2,6,
    1,2,6,4,4,5,3,
    3,3,3,4,4,6,6,
    5,4,0,4,4,4,6
};
int main(){
    int n=36;
    for(int i=0;i<n;i++)
        for(int j=0;j<n-i;j++){
            int x=j*4+i*2,y=6*i;
            for(int k=0;k<9;k++){
                if(j==n-i-1&&k==6) break;
                merge(param[k][0],get(x+param[k][1],y+param[k][2]),get(x+param[k][3],y+param[k][4]));
                merge(param[k][0],get(x+param[k][3],y+param[k][4]),get(x+param[k][5],y+param[k][6]));
            }
        }
    for(int i=1;i<=m;i++)
    for(int j=i+1;j<=m;j++){
        for(int k=0;k<6;k++)
            if(find(fa[k],i)==find(fa[k],j)){
                b[i][j]=b[j][i]=k+1;
                break;
            }
    }
    int ans=0;
    for(int i=1;i<=m;i++){
        for(int j=i+1;j<=m;j++){
            if(!b[i][j]) continue;
            for(int k=j+1;k<=m;k++)
                if(b[j][k]&&b[i][k]&&b[i][j]!=b[i][k]) ++ans;
        }
    }
    printf("%d\n",ans);
    //printf("%d\n",(1678*n*n*n+3117*n*n+88*n-n%2*345-n%3*320-n%4*90-(n*n*n-n*n+n)%5*288)/240);
}
```
## Q165
```Python
from fractions import Fraction


class L:
    def __init__(self, xa: int, ya: int, xb: int, yb: int):
        self.xa, self.ya, self.xb, self.yb = xa, ya, xb, yb
        self.a = ya - yb
        self.b = xb - xa
        self.c = xa * (ya - yb) - ya * (xa - xb)


def cross(va: tuple, vb: tuple):
    return va[0] * vb[1] - va[1] * vb[0]


def ok(la: L, lb: L):
    vb1 = (lb.xa - la.xa, lb.ya - la.ya)
    vb2 = (lb.xb - la.xa, lb.yb - la.ya)
    va = (la.xb - la.xa, la.yb - la.ya)
    if cross(va, vb1) * cross(va, vb2) >= 0:
        return False
    vb1 = (la.xa - lb.xa, la.ya - lb.ya)
    vb2 = (la.xb - lb.xa, la.yb - lb.ya)
    va = (lb.xb - lb.xa, lb.yb - lb.ya)
    if cross(va, vb1) * cross(va, vb2) >= 0:
        return False
    return True


def solve(la: L, lb: L):
    fm = la.a * lb.b - la.b * lb.a
    if fm == 0:
        return None
    fx = la.c * lb.b - la.b * lb.c
    fy = la.a * lb.c - la.c * lb.a
    return Fraction(fx, fm), Fraction(fy, fm)


s, t = [290797], [0]
n = 5000
for i in range(n * 4):
    s.append(s[-1] * s[-1] % 50515093)
    t.append(s[-1] % 500)
line = []
for i in range(4, n * 4 + 1, 4):
    line.append(L(t[i - 3], t[i - 2], t[i - 1], t[i]))
ans = 0
point_set = set()
for i in range(n):
    for j in range(i + 1, n):
        if ok(line[i], line[j]):
            point_set.add(solve(line[i], line[j]))
print(len(point_set))
```
## Q167
```C++
# include <bits/stdc++.h>
# define X first
# define Y second
using namespace std;
typedef long long ll;
int main(){
    ll n=1e11;
    ll sum=0;
    map<int,int>mp;
    for(int i=2;i<=10;i++){
        int even=0,even_pos=0;
        mp.clear();
        vector<int>U;U.push_back(2*i+1);
        do{
            ++mp[U.back()+2];
            if(even) ++mp[U.back()+even];
            else{
                for(int j=0;j+1<U.size();j++)
                    mp[U.back()+U[j]]++;
            }
            if(U.back()%2==0){
                even=U.back();even_pos=U.size()-1;
                for(auto & it : mp)
                    if(it.X%2==0) ++it.Y;
            }
            for(auto it=mp.begin();it!=mp.end();it++)
                if(it->Y==1){
                    U.push_back(it->X);
                    mp.erase(mp.begin(),++it);
                    break;
                }
        }while(U.back()-U[U.size()-2]!=even);
        int period=U.size()-2,diff=U.back()-U.front();
        int s=(n-3)%period;
        if(s>=even_pos) ++s;
        ll ans=(n-3)/period*diff+U[s];
        sum+=ans;
    }
    printf("%lld\n",sum);
}
/*
Schmerl和Spiegel在1994年证明：
满足n>=2的Ulam序列U(2,2n+1)有且只有两个偶数，其中一个是2，设另外一个为even.
设U'(2,2n+1)为U(2,2n+1)去掉两个偶数项后剩下的数，那么U'(2n+1)的差分序列是一个循环数组，其中最小的循环节中有且仅有一个even，并且这个even在整个循环节中的最后一个数、
*/
```
## Q170
```C++
# include <bits/stdc++.h>
using namespace std;
const int N=100004;
int a[14];
vector<int>d[N];
int gcd(int a,int b) {
    return b ? gcd(b, a % b) : a;
}
int main(){
    for(int i=3;i<N;i+=3){
        for(int j=i;j<N;j+=i)
            d[j].push_back(i);
    }
    string tp="0123456789";
    for(int i=0;i<10;i++)
        a[i]=9-i;
    bool ok=0;
    do{
        for(int p=1;p<10&&!ok;p++){
            if(a[p]==0) continue;
            int l=0,r=0;
            for(int i=0;i<10;i++) {
                if (i < p) l = l * 10 + a[i];
                else r = r * 10 + a[i];
            }
            for(int x:d[gcd(l,r)]) {
                string s = to_string(x) + to_string(l / x) + to_string(r / x);
                sort(s.begin(), s.end());
                if (s == tp) {
                    ok = 1;
                    break;
                }
            }
        }
    } while (!ok&&prev_permutation(a,a+10));
    for(int i=0;i<10;i++)
        printf("%d",a[i]);
}
```
## Q174
```Python
N = 10 ** 6
mp = {}
i = 1
while 4 * (i - 1) <= N:
    j = i - 2
    cnt = 0
    while j > 0 and i * i - j * j <= N:
        w = i * i - j * j
        if w not in mp.keys():
            mp[w] = 0
        mp[w] += 1
        j -= 2
    i += 1
ans = 0
for x in mp.values():
    if 1 <= x <= 10:
        ans += 1
print(ans)
```
## Q177
```C++
#include <bits/stdc++.h>
# define pi pair<int,int>
# define X first
# define Y second
using namespace std;
double sina[184],cosa[184];
double eps=1e-9;
double Pi=acos(-1.0);
bool is_integer(double v) {
    return abs(v - round(v)) <= eps;
}
int ans=0;
set<vector<pi>>st;
vector<pi> getmin(vector<pi>v){
    vector<pi>ans=v;
    for(int p=1;p<4;p++){
        vector<pi>tp;
        for(int i=p;i<4;i++) tp.push_back(v[i]);
        for(int i=0;i<p;i++) tp.push_back(v[i]);
        ans=min(ans,tp);
    }
    return ans;
}
void insert(vector<pi> a){
    a=getmin(a);
    if(!st.count(a)){
        ++ans;
        st.insert(a);
        reverse(a.begin(),a.end());
        for(pi&pa:a)
            swap(pa.X,pa.Y);
        a=getmin(a);
        st.insert(a);
    }
}
int main(){
    for(int i=1;i<=180;i++){
        sina[i]=sin(Pi*i/180);
        cosa[i]=cos(Pi*i/180);
    }
    for(int BAD=1;BAD<180;BAD++){
        for(int ABD=1;ABD<=180-BAD-ABD;ABD++){
            int ADB=180-BAD-ABD;
            for(int CDB=1;CDB<180-ADB;CDB++){
                for(int CBD=1;CBD<min(180-ABD,180-CDB);CBD++) {
                    int BCD = 180 - CDB - CBD;
                    double BD = 1;
                    double AD=BD/sina[BAD]*sina[ABD];
                    double CD=BD/sina[BCD]*sina[CBD];
                    double AC= sqrt(AD*AD+CD*CD-2.0*AD*CD*cosa[ADB+CDB]);
                    double DAC= asin(sina[ADB+CDB]/AC*CD)/Pi*180;
                    if(!is_integer(DAC)) continue;
                    DAC=round(DAC);
                    if(AC*AC+AD*AD<CD*CD) DAC=180-DAC;
                    int DCA=180-(ADB+CDB+DAC);
                    insert({pi(BAD-DAC,DAC),pi(ADB,CDB),pi(DCA,BCD-DCA),pi(CBD,ABD)});
                }
            }
        }
    }
    printf("%d\n",ans);
}
```
## Q178
```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=40;
ll f[N+1][10][1<<10];
int main() {
    for (int j = 1; j < 10; j++)
        f[1][j][1 << j] = 1;
    for (int i = 1; i < N; i++)
        for (int j = 0; j < 10; j++)
            for (int s = 0; s < (1 << 10); s++) {
                if (f[i][j][s] == 0) continue;
                if (j > 0) f[i + 1][j - 1][s | 1 << (j - 1)] += f[i][j][s];
                if (j < 9)f[i + 1][j + 1][s | 1 << (j + 1)] += f[i][j][s];
            }
    ll ans = 0;
    for (int i = 1; i <= N; i++)
        for (int j = 0; j < 10; j++)
            ans += f[i][j][1023];
    printf("%lld\n", ans);
}
```
## Q179
```C++
#include <bits/stdc++.h>
using namespace std;
const int N=1e7;
int pr[N/4],v[N+1],e[N+1],f[N+1],m=0;
int main(){
    f[1]=1;
    for(int i=2;i<=N;i++){
        if(v[i]==0){
            v[i]=i;e[i]=1;f[i]=2;
            pr[++m]=i;
        }
        for(int j=1;j<=m;j++){
            if(pr[j]>v[i]||pr[j]>N/i) break;
            v[i*pr[j]]=pr[j];
            if(pr[j]==v[i]){
                e[i*pr[j]]=e[i]+1;
                f[i*pr[j]]=f[i]/(e[i]+1)*(e[i]+2);
            } else{
                e[i*pr[j]]=1;
                f[i*pr[j]]=f[i]<<1;
            }
        }
    }
    int ans=0;
    for(int i=1;i<N;i++)
        if(f[i]==f[i+1]) ++ans;
    printf("%d\n",ans);
}
```
## Q180
```Python
def isq(n: int):
    m = int(n ** 0.5)
    return m * m == n


k = 35
one = Fraction(1)
fraction_set = set()
for b in range(1, k + 1):
    for a in range(1, b):
        fraction_set.add(Fraction(a, b))
fraction_list = list(fraction_set)
l = len(fraction_list)
st = set()
for i in range(l):
    x = fraction_list[i]
    for j in range(i, l):
        y = fraction_list[j]
        z = x + y
        if z in fraction_set:
            st.add(x + y + z)
        z2 = x * x + y * y
        if isq(z2.numerator) and isq(z2.denominator):
            z = Fraction(int(z2.numerator ** 0.5), int(z2.denominator ** 0.5))
            if z in fraction_list:
                st.add(x + y + z)
        z = one / (one / x + one / y)
        if z in fraction_set:
            st.add(x + y + z)
        tp = one / (one / x / x + one / y / y)
        if isq(tp.numerator) and isq(tp.denominator):
            z = Fraction(int(tp.numerator ** 0.5), int(tp.denominator ** 0.5))
            if z in fraction_set:
                st.add(x + y + z)

s = sum(st)
print(s.numerator + s.denominator)
# f_n(x,y,z)=(x+y+z)*(x^n+y^n-z^n)
# 此时变为求方程x^n+y^n=z^n是否有有理数解。
# 根据费马大定理，可以证明，n>=3时，没有有理数解。
# 说明：设x=a/b,y=c/d,z=e/f.
# 代入式子后，通分，即可化成(adf)^n+(bcf)^n=(bde)^n，成为一个整式，根据费马大定理，n>=3时无整数解，故原命题成立，只本题只需验证n=-2,-1,1和2的情况即可。
```
## Q181
```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=60,M=40;
const int O=(N+1)*(M+1)+1;
ll f[N+1][M+1][O];
int id[N+1][M+1],x[O],y[O];
int p=0;
int main(){
    for(int i=0;i<=N;i++)
    for(int j=0;j<=M;j++,p++){
        x[p]=i;y[p]=j;
        id[i][j]=p;
    }
    --p;
    for(int i=0;i<=N;i++)
    for(int j=0;j<=M;j++) {
        if(i==0&&j==0) continue;
        for (int k = 1; k <= p; k++) {
            if(k<id[i][j]){
                f[i][j][k]=f[i][j][k-1];
                if(x[k]<=i&&y[k]<=j) f[i][j][k]+=f[i-x[k]][j-y[k]][k];
            }
            else if(k==id[i][j]) f[i][j][k]=f[i][j][k-1]+1;
            else f[i][j][k]=f[i][j][id[i][j]];
        }
    }
    printf("%lld\n",f[N][M][p]);
}
```
## Q182
```Python
from Q7_7 import *
from Q5_2 import gcd
from fractions import Fraction

p, q = 1009, 3643
n, phi = p * q, (p - 1) * (q - 1)
ans = 0
mn = 1 << 100
for e in range(2, phi):
    if gcd(e, phi) == 1:
        cnt = (1 + gcd(e - 1, p - 1)) * (1 + gcd(e - 1, q - 1))
        if cnt < mn:
            ans = e
            mn = cnt
        elif cnt == mn:
            ans += e
print(ans)
# m^e==m(mod n)意味着m^e==m(mod p)和m^e==m(mod q)
# 接下来求方程m^e==m(mod p)的解数。
# 当m=0时，为一个解，当m不等于0是，即为求方程m^{e-1}==1(mod p)的解数。
# 令c=e-1，此处证明x^c==1(mod p)有d=gcd(c,p-1)个解。
# 对素数p，设其其中一个原根为g。
# 那么对于1,2,...,p-1，存在i=0,1,...,p-2，使得x==g^i(mod p)。
# 因此x^c==1(mod p)当且仅当g^{ci}==1(mod p)，并且(p-1)|ci。因此当且仅当(p-1)/d|i，即i是(p-1)/d的倍数。
# 在0,1,...,p-2中，(p-1)/d的倍数恰好有d个，分别是0,(p-1)/d,2(p-1)/d,...,(d-1)(p-1)/d。
```
## Q184
```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=105;
struct V{
    int x,y;
    bool operator < (const V v) const{
        return x*v.y-y*v.x>0;
    }
}p[N*N*4];
int gcd(int a,int b) {
    return b ? gcd(b, a % b) : a;
}
map<V,int>mp;
int m=0;
ll c[N*N*4],s[N*N*4],s1[N*N*4],s2[N*N*4];
int main(){
    for(int i=-N;i<=N;i++)
        for(int j=-N;j<=N;j++)
            if(!(i==0&&j==0)&&i*i+j*j<N*N){
                int k= gcd(abs(i),abs(j));
                ++mp[V{i/k,j/k}];
            }
    for(auto it=mp.begin();it!=mp.end();it++){
        ++m;
        tie(p[m],c[m])=*it;
        s[m]=s[m-1]+c[m];
        s1[m]=s1[m-1]+c[m]*s[m-1];
        s2[m]=s2[m-1]+c[m]*s[m];
    }
    ll ans=0;
    for(int i=1;i<=m;i++){
        int r=min(i+m/2-1,m);
        ans+=c[i]*(s1[r]-s1[i])-c[i]*s[i]*(s[r]-s[i]);
        int l=i+m/2+1;
        if(l<=m){
            ans+=c[i]*(s[m]+s[i-1])*(s[m]-s[l-1])-c[i]*(s2[m]-s2[l-1]);
        }
    }
    printf("%lld\n",ans/3);
}
```
## Q185
```Python
from random import randint

lt = [("5616185650518293", 2), ("3847439647293047", 1), ("5855462940810587", 3), ("9742855507068353", 3),
      ("4296849643607543", 3), ("3174248439465858", 1), ("4513559094146117", 2), ("7890971548908067", 3),
      ("8157356344118483", 1), ("2615250744386899", 2), ("8690095851526254", 3), ("6375711915077050", 1),
      ("6913859173121360", 1), ("6442889055042768", 2), ("2321386104303845", 0), ("2326509471271448", 2),
      ("5251583379644322", 2), ("1748270476758276", 3), ("4895722652190306", 1), ("3041631117224635", 3),
      ("1841236454324589", 3), ("2659862637316867", 2)]
ls = []
for x, y in lt:
    ls.append(([int(w) for w in x], y))
n, m = len(ls), len(ls[0][0])


def shuffle(ls: list, id: int):
    while True:
        w = randint(0, 9)
        if ls[id] != w:
            break
    ls[id] = w


def distance(val: list):
    error = 0
    for v, cnt in ls:
        c = 0
        for i in range(m):
            if v[i] == val[i]:
                c += 1
        error += abs(cnt - c)
    return error


ans = [0 for i in range(m)]
for i in range(m):
    shuffle(ans, i)

MAX_ROUNDS = 20
STUCK_ROUNDS = 0
dis = pre_dis = distance(ans)
while dis != 0:
    for i in range(m):
        pre = ans[i]
        shuffle(ans, i)
        now_dis = distance(ans)
        if now_dis <= dis:
            dis = now_dis
        else:
            ans[i] = pre
    if dis == pre_dis:
        STUCK_ROUNDS += 1
        if STUCK_ROUNDS == MAX_ROUNDS:
            shuffle(ans, randint(0, m - 1))
            dis = distance(ans)
            STUCK_ROUNDS = 0
    else:
        STUCK_ROUNDS = 0
        pre_dis = dis
print("".join(str(x) for x in ans))
# 伪模拟退火算法，distance函数计算当前与推测的误差，误差值为sum(提示项的预估正确数和实际正确数之差的绝对值。)
# shuffle为对列表的某一位进行随机化，但随机后的数字必须与原来的不同。
# STUCK_ROUNDS和MAX_ROUNDS用于防止程序陷入局部最优解中，如果陷入了，那么就随机改变一位数字，尽管这会让误差值变大。

# 另有一种做法是，把所有解的前8位数字和22组提示的正确值前8位数字存入哈希表中，然后将后8位数字的正确值所有情况计算出来，分别在哈希表中查找之前的结果。这使用了meet in the middle的想法。
```
## Q186
```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1000000;
const int M=N*5,P=524287,A=N/100*99;
int fa[N],sz[N];
int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}
void merge(int x,int y){
    int u=find(x),v=find(y);
    if(u!=v){
        fa[u]=v;
        sz[v]+=sz[u];
    }
}
int f[M];
int main(){
    int cnt=0,ans=0;
    for(int i=0;i<N;i++)
        fa[i]=i,sz[i]=1;
    for(int i=1;i<=55;i++)
        f[i]=(1ll*300007*i*i*i+100003-200003*i)%N;
    for(int i=56;i<M;i++)
        f[i]=(f[i-24]+f[i-55])%N;
    for(int i=2;i<M;i+=2){
        if(f[i]==f[i-1]) ++cnt;
        else{
            merge(f[i],f[i-1]);
            if(sz[find(P)]>=A){
                ans=i/2-cnt;
                break;
            }
        }
    }
    printf("%d\n",ans);
}
```
## Q187
```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int O=1e8;
const int N=O/2;
int v[N],pr[N],m=0;
int main(){
    for(int i=2;i<N;i++){
        if(v[i]==0){
            pr[++m]=i;v[i]=i;
        }
        for(int j=1;j<=m;j++){
            if(pr[j]>v[i]||pr[j]>N/i) break;
            v[i*pr[j]]=pr[j];
        }
    }
    ll ans=0;
    for(int l=1,r=m;l<=r;l++){
        for(;pr[l]*pr[r]>=O;r--);
        ans+=r-l+1;
    }
    printf("%lld\n",ans);
}
```
## Q189
```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=8;
ll f[N+1][7004];
int pw3[N+1],c[8];
vector<int>g[7004];
int main(){
    for(int i=0;i<8;i++){
        for(int j=0;j<3;j++)
            c[i]+=(i>>j&1);
        c[i]=3-c[i];
    }
    pw3[0]=1;
    for(int i=1;i<=N;i++)
        pw3[i]=pw3[i-1]*3;
    f[1][0]=f[1][1]=f[1][2]=1;
    for(int j=0;j<pw3[N];j++){
        int x=j;
        for(int k=0;k<N;k++,x/=3)
            g[j].push_back(x%3);
    }
    for(int i=1;i<N;i++){
        for(int j=0;j<pw3[i];j++){
            for(int k=0;k<pw3[i+1];k++){
                int v=1;
                for(int l=0;l<i;l++)
                    v*=c[1<<g[j][l]|1<<g[k][l]|1<<g[k][l+1]];
                f[i+1][k]+=f[i][j]*v;
            }
        }
    }
    ll ans=0;
    for(int i=0;i<pw3[N];i++)
        ans+=f[N][i];
    printf("%lld\n",ans);
}
```
## Q190
```Python
from random import randint

MAX_ROUNDS = 100


def solve(n: int):
    a = [1 for _ in range(n)]
    ans = 1
    for i in range(1, 7):
        STUCK_ROUND = 0
        d = 10 ** (-i)
        while STUCK_ROUND < MAX_ROUNDS:
            x = randint(0, n - 1)
            y = randint(0, n - 1)
            if x == y or a[x] <= d:
                continue
            a[x] -= d
            a[y] += d
            mul = 1
            for j in range(n):
                mul *= a[j] ** (j + 1)
            if mul > ans:
                ans = mul
                STUCK_ROUND = 0
            else:
                STUCK_ROUND += 1
                a[x] += d
                a[y] -= d
    return ans


N = 15
ans = 0
for n in range(2, N + 1):
    ans += int(solve(n))
print(ans)
```
## Q191
```Python
from random import randint

N = 30
f = [0 for _ in range(N + 1)]
f[0], f[1], f[2], f[3] = 1, 2, 4, 7
for n in range(4, N + 1):
    f[n] = f[n - 1] * 2 - f[n - 4]
ans = f[N]
for i in range(1, N + 1):
    ans += f[i - 1] * f[N - i]
print(ans)
```
## Q192
```Python
# https://en.wikipedia.org/wiki/Continued_fraction#Best_rational_approximations
def get_fraction_list(n: int, l: int):
    m = 0
    d = 1
    a = a0 = int(n ** 0.5)
    ls = [a]
    while len(ls) < l:
        m = d * a - m
        d = (n - m * m) / d
        a = int((a0 + m) / d)
        ls.append(a)
    return ls


def allow_half(a: list, k: int):
    i = k
    s = 1
    while i > 0:
        difference = s * (a[i] - a[2 * k - i])
        if difference > 0:
            return True
        if difference < 0:
            return False
        s *= -1
        i -= 1
    return (k & 1) == 0


def solve(m: int, lim: int):
    a = get_fraction_list(m, 128)
    n2, d2 = 1, 0
    n1, d1 = a[0], 1
    i = 1
    while True:
        n = d = 0
        val = (a[i] + 1) >> 1
        if (a[i] & 1) == 0 and not allow_half(a, i):
            val += 1
        for q in range(val, a[i] + 1):
            n, d = n2 + q * n1, d2 + q * d1
            if d > lim:
                if q > val:
                    return d2 + (q - 1) * d1
                else:
                    return d1
        i += 1
        print(n2, n1, n)
        print(d2, d1, d, end="\n\n")
        n2, n1 = n1, n
        d2, d1 = d1, d


N = 10 ** 5
M = 10 ** 12
ans = 0
for S in range(13, 14):
    n = int(S ** 0.5)
    if n * n == S:
        continue
    ans += solve(S, M)
print(ans)
```
## Q193
```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1ll<<50;
const ll M=1ll<<25;
int miu[M+1],m=0;
bool vis[M+1];
int main(){
    miu[1]=1;
    for(int i=1;i<=M;i++) miu[i]=1;
    for(int i=2;i<=M;i++){
        if(vis[i]) continue;
        miu[i]=-1;
        for(int j=i+i;j<=M;j+=i){
            vis[j]=1;
            if((j/i)%i==0) miu[j]=0;
            else miu[j]*=-1;
        }
    }
    ll ans=0;
    for(int i=1;i<=M;i++)
        ans+=1ll*miu[i]*(N/(1ll*i*i));
    printf("%lld\n",ans);
}
```
## Q194
```Python
na = 25
nb = 75
c = 1984
mod = 10 ** 8
n = 7
edges = [(2, 3), (3, 0), (0, 1), (1, 2), (0, 4), (1, 4), (2, 5), (3, 5), (4, 6), (5, 6)]
cth_row = [1]
fa = [0 for i in range(n + 1)]
fb = [0 for i in range(n + 1)]
g = [[] for i in range(n)]
a = [0 for i in range(n)]
dp = [[0 for j in range(nb + 1)] for i in range(na + 1)]
for i in range(1, n + 1):
    cth_row.append(cth_row[-1] * (c - i + 1) // i)


def add_edge(v: tuple):
    x, y = v[0], v[1]
    g[x].append(y)
    g[y].append(x)


def dfs(u: int, f: list):
    if u == n:
        tp = a.copy()
        tp.sort()
        if tp[0] != 1:
            return
        for i in range(1, n):
            if tp[i] - tp[i - 1] > 1:
                return
        f[tp[n - 1]] += 1
        return
    for k in range(1, n + 1):
        ok = True
        for v in g[u]:
            if k == a[v]:
                ok = False
                break
        if ok:
            a[u] = k
            dfs(u + 1, f)
    a[u] = 0


for i in range(1, len(edges)):
    add_edge(edges[i])
dfs(0, fb)
add_edge(edges[0])
dfs(0, fa)
va = sum(fa[i] * cth_row[i] // (c * (c - 1)) for i in range(n + 1)) % mod
vb = sum(fb[i] * cth_row[i] // (c * (c - 1)) for i in range(n + 1))
dp[0][0] = c * (c - 1)
for i in range(na + 1):
    for j in range(nb + 1):
        if i > 0:
            dp[i][j] += dp[i - 1][j] * va
        if j > 0:
            dp[i][j] += dp[i][j - 1] * vb
        dp[i][j] %= mod
print("{:0>8}".format(dp[na][nb]))
```
## Q195
```C++
//http://www.geocities.ws/fredlb37/node9.html
#include <bits/stdc++.h>
using namespace std;
double eps=1e-6;
int gcd(int a,int b){
    return b?gcd(b,a%b):a;
}
double sq3=sqrt(3);
int main(){
    int N=1053779;
    int ans=0;
    for(int m=1,n,n2;m<=N*4;m++){
        for(n=1;n<m;n++){
            if((m-n)%3==0||gcd(n,m)!=1) continue;
            double r=0.5*sq3*m*n;
            if(r>N) break;
            ans+=int(1.0*N/r+eps);
        }
        for(n=m-1;n>0;n--){
            if((m-n)%3==0||gcd(n,m)!=1) continue;
            double r=0.5*(m-n)*(2*n+m)/sq3;
            if(r>N) break;
            ans+=int(1.0*N/r+eps);
        }
        n2=n;
        for(int n=1;n<n2;n++){
            if((m-n)%3==0||gcd(n,m)!=1) continue;
            double r=0.5*(m-n)*(2*n+m)/sq3;
            if(r>N) break;
            ans+=int(1.0*N/r+eps);
        }
    }
    printf("%d\n",ans);
}

```
## Q196
```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int Q1=5678027,Q2=7208785;
bool b[Q2*5+2];
int sz[Q2],fa[Q2];
ll pr1[Q2],pr2[Q2];
int p1=0,p2=0;
int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}
void merge(int x,int y){
    int u=find(x),v=find(y);
    if(u!=v){
        fa[u]=v;
        sz[v]+=sz[u];
    }
}
ll ed(int n){
    return 1ll*n*(n+1)/2;
}
ll st(int n){
    return ed(n-1)+1;
}
ll getv(int x,int y){
    if(x<0||y<1||y>x) return -1;
    return 1ll*(x-1)*x/2+y;
}
int dx[8]={-1,-1,-1,0,0,1,1,1},dy[8]={-1,0,1,-1,1,-1,0,1};
ll solve(int row){
    ll l=st(row-2),r=ed(row+2);
    ll sq=sqrt(r);
    p1=p2=0;
    memset(b,0,sizeof(b));
    for(int i=2;i<=sq;i++){
        if(b[i]) continue;
        pr1[++p1]=i;
        for(int j=i;1ll*i*j<=sq;j++)
            b[i*j]=1;
    }
    memset(b,0,sizeof(b));
    for(int i=1;i<=p1;i++)
        for(ll j=(l+pr1[i]-1)/pr1[i];j*pr1[i]<=r;j++)
            b[j*pr1[i]-l]=1;
    unordered_map<ll,int>pos;
    for(ll i=l;i<=r;i++)
        if(!b[i-l]&&i>1) {
            pr2[++p2]=i;
            pos[i]=p2;
        }
    for(int i=1;i<=p2;i++)
        fa[i]=i,sz[i]=1;
    for(int i=row-1;i<=row+1;i++){
        for(int j=1;j<=i;j++){
            ll v=getv(i,j);
            if(!pos.count(v)) continue;
            int p=pos[v];
            for(int k=0;k<8;k++){
                int x=i+dx[k],y=j+dy[k];
                ll w=getv(x,y);
                if(w==0||!pos.count(w)) continue;
                merge(p,pos[w]);
            }
        }
    }
    l=st(row);r=ed(row);
    ll ans=0;
    for(ll i=l;i<=r;i++)
        if(pos.count(i)){
            int p=pos[i];
            if(sz[find(p)]>=3) ans+=i;
        }
    return ans;
}
int main(){
    printf("%lld\n",solve(Q1)+ solve(Q2));
}
```
## Q198
```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
struct TP{
    ll lu,ld,ru,rd,midd;
};
int main(){
    ll r=100,n=1e8;
    vector<TP>v;
    v.push_back(TP{0,1,1,1,2});
    ll ans=0;
    while(!v.empty()){
        TP t=v.back();v.pop_back();
        ll midd=t.midd,midu=t.lu*t.rd+t.ld*t.ru;
        if(r*midu<midd) ++ans;
        ll gend=t.ld+t.rd,genu=t.lu+t.ru;
        ll lmidd=2ll*t.ld*gend,rmidd=2ll*t.rd*gend;
        if(lmidd<=n)
            v.push_back(TP{t.lu,t.ld,genu,gend,lmidd});
        if(rmidd<=n)
            v.push_back(TP{genu,gend,t.ru,t.rd,rmidd});
    }
    printf("%lld\n",ans);
}
//# 非递归前序遍历Stern-Brocot树以获得F(n)的Farey序列。
// 可以知道，如果分数a和b在某个Farey序列F(n)中相邻，那么(a+b)/2就是其中一个解。
```