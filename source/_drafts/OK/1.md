Q202
```
# 原问题可化为求满足以下条件的(a,b)有多少对。
# 1.a+b=(n+3)/2
# 2.gcd(a,b)=1
N = 12017639147
N = (N + 3) >> 1
i = 1
div = []
while i * i <= N:
    if N % i == 0:
        div.append(i)
        if i * i != N:
            div.append(N // i)
    i += 1
div.sort()
ans = {}
for r in div:
    val = r // 3 + r % 3 + 1  # 1~r中与3-3%r同余的数的个数。
    for l in div:
        if l >= r:
            break
        if r % l == 0:
            val -= ans[l]
    ans[r] = val
print(ans[N])
```
Q205
```
def get_distribution(c: int, n: int):
    f = [[0 for j in range(c * n + 1)] for i in range(c + 1)]
    f[0][0] = 1
    for i in range(c):
        for j in range(c * n):
            if f[i][j] == 0:
                continue
            for k in range(1, n + 1):
                f[i + 1][j + k] += f[i][j]
    for i in range(c * n + 1):
        f[c][i] /= n ** c
    return f[c]


dp = get_distribution(9, 4)
dc = get_distribution(6, 6)
m = 36
ans = s = 0
for i in range(m):
    s += dc[i]
    ans += dp[i + 1] * s
print("{:.7f}".format(ans))
```
Q206
```Python
ls = []
for i in range(100000):
    x = i * i % 100000
    if x % 10 == 9 and x // 100 % 10 == 8 and x // 10000 % 10 == 7:
        ls.append(i)
for l in range(415):
    for r in ls:
        x = 100000000 + l * 100000 + r
        s = str(x * x)
        t = ""
        for i in range(9):
            t += s[i * 2]
        if t == "123456789":
            print(x * 10)

```
Q208
```
M = 70
N = M // 5
st = {1}
ans = 0
C = [[0 for x in range(N + 1)] for y in range(N + 1)]
for i in range(N + 1):
    C[i][0] = C[i][i] = 1
    for j in range(i):
        C[i][j] = C[i - 1][j - 1] + C[i - 1][j]
for r in range(N + 1):
    ans += (C[N][r] ** 5) * (N ** 4 + r ** 4 - 3 * r * (N ** 3) + 4 * r * r * N * N - 2 * N * (r ** 3)) // (N ** 4)
print(ans)
```
Q209
```
n = 64
fa = [i for i in range(n)]
sz = [1 for i in range(n)]


def find(x: int):
    if x == fa[x]:
        return x
    fa[x] = find(fa[x])
    return fa[x]


def merge(x: int, y: int):
    u, v = find(x), find(y)
    if u != v:
        fa[u] = v
        sz[v] += sz[u]


def solve(n: int):
    f = [[0, 0] for i in range(n + 1)]
    f[1][0] = 1
    for i in range(2, n + 1):
        f[i][0] = f[i - 1][1] + f[i - 1][0]
        f[i][1] = f[i - 1][0]
    ans = f[n][0] + f[n][1]
    f = [[0, 0] for i in range(n + 1)]
    f[1][1] = 1
    for i in range(2, n + 1):
        f[i][0] = f[i - 1][1] + f[i - 1][0]
        f[i][1] = f[i - 1][0]
    ans += f[n][0]
    return ans


ans = 1
for i in range(n):
    v = (i << 1 & 63)
    a, b, c = i >> 5 & 1, i >> 4 & 1, i >> 3 & 1
    v += a ^ (b & c)
    merge(i, v)
for i in range(n):
    if i == find(i):
        ans *= solve(sz[i])
print(ans)
# 64个节点连起来的每个连通子图都是环。
```
Q 210
```
R = 10**9
cr = (2 ** 0.5) / 8 * R
cx = cy = R / 8
eps = 1e-9
ans = 0
for x in range(ceil(cx - cr - eps), floor(cx + cr + eps) + 1):
    d = (cr ** 2 - (cx - x) ** 2) ** 0.5
    up = ceil((cy + d - eps))
    down = floor(cy - d + eps)
    ans += up - down - 1
    if down < x < up:
        ans -= 1
row = int(R // 2 * 1.5)
ans -= row
ans += row * (2 * R + 1)
print(ans)
```
Q211
```
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const int N=64000000;
ll f[N+2],g[N+2],pr[N/10],v[N+2];
int m=0;
int main(){
    f[1]=1;
    for(int i=2;i<=N;i++){
        if(v[i]==0){
            v[i]=i;f[i]=g[i]=1ll*i*i+1;
            pr[++m]=i;
        }
        for(int j=1;j<=m;j++){
            if(pr[j]>v[i]||pr[j]>N/i) break;
            v[i*pr[j]]=pr[j];
            if(pr[j]==v[i]){
                g[i*pr[j]]=g[i]*pr[j]*pr[j]+1;
                f[i*pr[j]]=f[i]/g[i]*g[i*pr[j]];
            }
            else{
                f[i*pr[j]]=f[i]*(pr[j]*pr[j]+1);
                g[i*pr[j]]=pr[j]*pr[j]+1;
            }
        }
    }
    ll ans=0;
    for(int i=1;i<=N;i++){
        ll sq=sqrt(f[i]);
        if(sq*sq==f[i]) ans+=i;
    }
    printf("%lld\n",ans);
}
```
Q212
```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int M = 10004;
const int N = 50000;
int k = 0, n, m;
struct B
{
    int x, y1, y2,k;
    bool operator < (B t) const { return x < t.x; }
}b[M*10];
struct ST
{
    int cnt,len;
}t[M << 3];
int raw[M << 1];
int c[M << 1];
void pushdown(int l, int r, int p){
    if (t[p].cnt) t[p].len = raw[r + 1] - raw[l];
    else if (l == r) t[p].len = 0;
    else t[p].len = t[p << 1].len + t[p << 1 | 1].len;
}
void update(int L, int R, int l, int r, int p, int v){
    if (L <= l && R >= r){
        t[p].cnt += v;
        pushdown(l, r, p);
        return;
    }
    int mid = (l + r) >> 1;
    if (L <= mid) update(L, R, l, mid, p << 1, v);
    if (R > mid) update(L, R, mid + 1, r, p << 1 | 1, v);
    pushdown(l, r, p);
}
int S[N*6+4],xa[N+4],ya[N+4],za[N+4],xb[N+4],yb[N+4],zb[N+4];
int Z=10400;
int main() {
    for (int i = 1; i <= N * 6; i++) {
        if (i <= 55) S[i] = (300007ll * i * i * i - 200003ll * i + 100003ll) % 1000000;
        else S[i] = (S[i - 24] + S[i - 55]) % 1000000;
    }
    for (int i = 1; i <= N; i++) {
        xa[i] = S[6 * i - 5] % 10000;
        ya[i] = S[6 * i - 4] % 10000;
        za[i] = S[6 * i - 3] % 10000;
        xb[i] = xa[i] + S[6 * i - 2] % 399 + 1;
        yb[i] = ya[i] + S[6 * i - 1] % 399 + 1;
        zb[i] = za[i] + S[6 * i] % 399 + 1;
    }
    ll ans = 0;
    for (int h = 0; h < Z; h++) {
        if (h % 1000 == 0) printf("%d\n", h);
        k = m = 0;
        memset(t, 0, sizeof(t));
        for (int i = 1; i <= N; i++) {
            if (!(za[i] <= h && h < zb[i])) continue;
            b[k++] = {xa[i], ya[i], yb[i], 1};
            b[k++] = {xb[i], ya[i], yb[i], -1};
            raw[++m] = ya[i];
            raw[++m] = yb[i];
        }
        sort(raw + 1, raw + m + 1);
        m = unique(raw + 1, raw + 1 + m) - (raw + 1);
        sort(b, b + k);
        for (int i = 0; i < k - 1; i++) {
            int l = lower_bound(raw, raw + k, b[i].y1) - raw;
            int r = lower_bound(raw, raw + k, b[i].y2) - raw - 1;
            update(l, r, 1, k, 1, b[i].k);
            ans += t[1].len * (b[i + 1].x - b[i].x);
        }
    }
    printf("%lld", ans);
}
```
Q213
```
#include <bits/stdc++.h>
using namespace std;
const int N=30,M=50;
int dx[4]={-1,1,0,0},dy[4]={0,0,-1,1};
double f[M+1][N][N],g[N][N];
void solve(int x,int y){
    memset(f,0,sizeof(f));
    f[0][x][y]=1;
    for(int i=0;i<M;i++)
        for(int j=0;j<N;j++)
            for(int k=0;k<N;k++){
                if(f[i][j][k]==0) continue;
                int c=0;
                for(int r=0;r<4;r++){
                    int x=j+dx[r],y=k+dy[r];
                    if(x>=0&&y>=0&&x<N&&y<N) ++c;
                }
                for(int r=0;r<4;r++){
                    int x=j+dx[r],y=k+dy[r];
                    if(x>=0&&y>=0&&x<N&&y<N) f[i+1][x][y]+=f[i][j][k]/c;
                }
            }
    for(int i=0;i<N;i++)
        for(int j=0;j<N;j++)
            g[i][j]*=1.0-f[M][i][j];
}
int main(){
    for(int i=0;i<N;i++)
        for(int j=0;j<N;j++)
            g[i][j]=1;
    for(int i=0;i<N;i++)
        for(int j=0;j<N;j++)
            solve(i,j);
    double ans=0;
    for(int i=0;i<N;i++)
        for(int j=0;j<N;j++)
            ans+=g[i][j];
    printf("%.6f\n",ans);
}

```
Q215
```
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const int N=4004,Q=32,C=10;
vector<int>g[N];
int a[N],m=0;
ll f[C+1][N];
void dfs(int f,ll s){
    if(f>Q) return;
    else if(f==Q){
        a[++m]=s^1ll<<Q;
        return;
    }
    else{
        dfs(f+2,s|1ll<<(f+2));
        dfs(f+3,s|1ll<<(f+3));
    }
}
int main(){
    dfs(0,0);
    for(int i=1;i<=m;i++)
        for(int j=i+1;j<=m;j++)
            if((a[i]&a[j])==0){
                g[i].push_back(j);
                g[j].push_back(i);
            }
    for(int j=1;j<=m;j++)
        f[1][j]=1;
    for(int i=2;i<=C;i++)
        for(int u=1;u<=m;u++)
            for(int v:g[u])
                f[i][v]+=f[i-1][u];
    ll ans=0;
    for(int j=1;j<=m;j++)
        ans+=f[C][j];
    printf("%lld\n",ans);
}
```
Q216
```
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const int N=50000000;
ll T[N+4];
int main(){
    int ans=0;
    for(int n=2;n<=N;n++)
        T[n]=2ll*n*n-1;
    //如果p|2n^2-1，那么p|2m^2-1，其中n==m(mod p)或者m==-n(mod p)
    for(int n=2;n<=N;n++){
        if(T[n]==2ll*n*n-1) ++ans;
        ll p=T[n];
        if(p==1) continue;
        for(ll j=n;j<=N;j+=p)
            while(T[j]%p==0) T[j]/=p;
        for(ll j=(p-n%p)%p;j<=N;j+=p)
            while(T[j]%p==0) T[j]/=p;
    }
    printf("%d\n",ans);
}
```
Q217
```
def solve(n: int):
    if n == 1:
        return 45
    m = n >> 1
    lf = [[0 for j in range(9 * m + 1)] for i in range(m + 1)]
    lc = [[0 for j in range(9 * m + 1)] for i in range(m + 1)]
    for j in range(1, 10):
        lf[1][j] = j
        lc[1][j] = 1
    for i in range(1, m):
        for j in range(9 * i + 1):
            if lf[i][j] == 0 and lc[i][j] == 0:
                continue
            for k in range(10):
                lc[i + 1][j + k] = (lc[i + 1][j + k] + lc[i][j]) % mod
                lf[i + 1][j + k] = (lf[i + 1][j + k] + lf[i][j] * 10 + lc[i][j] * k) % mod
    rf = [[0 for j in range(9 * m + 1)] for i in range(m + 1)]
    rc = [[0 for j in range(9 * m + 1)] for i in range(m + 1)]
    for j in range(10):
        rf[1][j] = j
        rc[1][j] = 1
    for i in range(1, m):
        for j in range(9 * i + 1):
            if rf[i][j] == 0 and rc[i][j] == 0:
                continue
            for k in range(10):
                rc[i + 1][j + k] = (rc[i + 1][j + k] + rc[i][j]) % mod
                rf[i + 1][j + k] = (rf[i + 1][j + k] + rf[i][j] * 10 + rc[i][j] * k) % mod
    ans = 0
    for j in range(9 * m + 1):
        if n % 2 == 0:
            ans += lf[m][j] * (10 ** m) * rc[m][j] + rf[m][j] * lc[m][j]
        else:
            ans += lf[m][j] * (10 ** (m + 1)) * rc[m][j] * 10 + rf[m][j] * lc[m][j] * 10 + 45 * (10 ** m) * lc[m][j] * \
                   rc[m][j]
        ans %= mod
    return ans


ans = 0
for i in range(1, M + 1):
    ans = (ans + solve(i)) % mod
print(ans)
```
Q218
```
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
ll lm=1e16,N=14500;
ll gcd(ll a,ll b){
    return b?gcd(b,a%b):a;
}
int main(){
    int ans=0;
    for(ll s0=1;s0<=N;s0+=2){
        for(ll t0=1;t0<s0;t0+=2){
            if(gcd(s0,t0)!=1) continue;
            ll u=s0*t0,v=(s0*s0-t0*t0)>>1;
            ll s1=u+v,t1=abs(u-v);
            ll a=s1*t1,b=(s1*s1-t1*t1)>>1,c=(s1*s1+t1*t1)>>1;
            if(c>lm) break;
            ll g=168;
            g/=gcd(g,a);
            g/=gcd(g,b);
            if(g>1) ++ans;
        }
    }
    printf("%d\n",ans);
}
// 已知u^2+v^2=w^2，如何迅速表出a^2+b^2=2c^2?
// 令a=u+v,b=|u-v|,c=w即可
```
Q219
```
N = 10 ** 9
N -= 1
M = 100
ans = 0
b = [0, 0, 0, 0, 0, 1, 1, 1]
for i in range(M):
    b.append(b[-1] + b[-4])
for i in range(M):
    cnt = min(N, b[i])
    ans += cnt * i
    N -= cnt
print(ans)
# OEIS A003269
```
Q220
```
N = 50
M = 10 ** 12
a = [(0, 0, 0) for _ in range(N + 1)]
b = [(0, 0, 0) for _ in range(N + 1)]
M -= 1


def fun(now: tuple, dif: tuple):
    dir = (now[2] + dif[2] + 4) % 4
    if now[2] == 0:
        x, y = now[0] + dif[0], now[1] + dif[1]
    elif now[2] == 1:
        x, y = now[0] - dif[1], now[1] + dif[0]
    elif now[2] == 2:
        x, y = now[0] - dif[0], now[1] - dif[1]
    else:
        x, y = now[0] + dif[1], now[1] - dif[0]
    return x, y, dir


def dfs(x: int, y: int, d: int, f: int, M: int, flag: int):
    if M == 0:
        return x, y
    # a->aRbFR
    val = (1 << (f - 1)) - 1
    if flag == 0:
        if M < val:
            return dfs(x, y, d, f - 1, M, 0)
        x, y, d = fun((x, y, d), a[f - 1])
        x, y, d = fun((x, y, d), (0, 0, -1))
        M -= val
        if M < val:
            return dfs(x, y, d, f - 1, M, 1)
        else:
            x, y, d = fun((x, y, d), b[f - 1])
            x, y, d = fun((x, y, d), (0, 1, 0))
            return x, y
    else:
        x, y, d = fun((x, y, d), (0, 0, 1))
        x, y, d = fun((x, y, d), (0, 1, 0))
        M -= 1
        if M < val:
            return dfs(x, y, d, f - 1, M, 0)
        M -= val
        x, y, d = fun((x, y, d), a[f - 1])
        x, y, d = fun((x, y, d), (0, 0, 1))
        return dfs(x, y, d, f - 1, M, 1)


for i in range(1, N + 1):
    a[i] = fun(a[i], a[i - 1])  # a->aRbFR
    a[i] = fun(a[i], (0, 0, -1))
    a[i] = fun(a[i], b[i - 1])
    a[i] = fun(a[i], (0, 1, 0))
    a[i] = fun(a[i], (0, 0, -1))
    b[i] = fun(b[i], (0, 0, 1))  # b->LFaLb
    b[i] = fun(b[i], (0, 1, 0))
    b[i] = fun(b[i], a[i - 1])
    b[i] = fun(b[i], (0, 0, 1))
    b[i] = fun(b[i], b[i - 1])
x, y, d = 0, 1, 0
ax, ay = dfs(x, y, d, N, M, 0)
print("{},{}".format(ax, ay))
```
Q221
```
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const int M=80000;
int P=150000;
const ll MX=1e18;
vector<int>pr;
vector<ll>divs;
bool vis[M+1];
ll p[14];
int e[14],m=0;
void fact(ll n){
    m=0;
    for(ll x:pr){
        if(x*x>n) break;
        if(n%x==0){
            p[++m]=x;
            e[m]=0;
            for(;n%x==0;n/=x,++e[m]);
        }
    }
    if(n!=1){
        p[++m]=n;e[m]=1;
    }
}
void dfs(int f,ll s){
    if(f==m+1){
        divs.push_back(s);
        return;
    }
    for(int i=0;i<=e[f];i++){
        dfs(f+1,s);
        s*=p[f];
    }
}
int main(){
    set<ll>st;
    for(int i=2;i<=M;i++){
        if(vis[i]) continue;
        pr.push_back(i);
        for(int j=i+i;j<=M;j+=i)
            vis[j]=1;
    }
    int cnt=0;
    for(ll p=1;p<=M;p++){
        fact(p*p+1);
        divs.clear();
        dfs(1,1);
        sort(divs.begin(),divs.end());
        for(ll d:divs){
            if(d>p) break;
            if(p*(p+d)>MX/(p+(p*p+1)/d)) continue;
            st.insert(p*(p+d)*(p+(p*p+1)/d));
            ++cnt;
        }
    }
    ll ans=0;
    for(ll x:st){
        if(--P==0){
            ans=x;break;
        };
    }
    printf("%lld\n",ans);
}
```
Q222
```
#include <bits/stdc++.h>
using namespace std;
const int M=21;
double f[1<<M][M],g[M][M];
int r[M];
double d=50*2;
int main(){
    for(int i=0;i<M;i++)
        r[i]=30+i;
    memset(f,0x4f,sizeof(f));
    for(int i=0;i<M;i++)
        f[1<<i][i]=r[i];
    for(int i=0;i<M;i++)
        for(int j=i+1;j<M;j++){
            double d0=r[i]+r[j],d1=r[j]+r[i]-d;
            g[i][j]=g[j][i]=sqrt(d0*d0-d1*d1);
        }
    for(int s=1;s<(1<<M);s++){
        for(int i=0;i<M;i++){
            for(int j=0;j<M;j++){
                if((s>>j&1)==0)
                    f[s|1<<j][j]=min(f[s|1<<j][j],f[s][i]+g[i][j]);
            }
        }
    }
    double ans=1e10;
    for(int i=0;i<M;i++)
        ans=min(ans,f[(1<<M)-1][i]+r[i]);
    printf("%.6f\n",ans*1000);
}
```
Q223
```
# include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const int N=25000000;
const int M=N/3.4;//2+sqrt(2)
ll ccmbb=0,a;
int pr[M/5],v[M+1],m=0;
int p[24],e[24],tot;
void fact(int n){
    for(int i=1;i<=m&&pr[i]*pr[i]<=n;i++){
        if(n%pr[i]==0){
            p[++tot]=pr[i];
            e[tot]=0;
            for(;n%pr[i]==0;n/=pr[i],++e[tot]);
        }
    }
    if(n!=1){
        p[++tot]=n;e[tot]=1;
    }
}
int ans=(N-1)>>1;
void dfs(int f,ll cmb){
    if(cmb>a) return;
    if(f==tot+1){
        ll cpb=ccmbb/cmb;
        if(((cpb+cmb)&1)==0){
            ll c=(cpb+cmb)>>1,b=(cpb-cmb)>>1;
            if(a<=b&&a+b+c<=N) ++ans;
        }
        return;
    }
    for(int i=0;i<=e[f];i++){
        dfs(f+1,cmb);
        cmb*=p[f];
    }
}
int main(){
    for(int i=2;i<=M;i++){
        if(v[i]==0){
            pr[++m]=i;v[i]=i;
        }
        for(int j=1;j<=m;j++){
            if(pr[j]>v[i]||pr[j]>M/i) break;
            v[i*pr[j]]=pr[j];
        }
    }
    for(a=2;a<=M;a++){
        tot=0;
        ccmbb=(a+1)*(a-1);
        int e2=0,x,y;
        for(x=a-1;(x&1)==0;x>>=1,++e2);
        for(y=a+1;(y&1)==0;y>>=1,++e2);
        fact(x);fact(y);
        if(e2) p[++tot]=2,e[tot]=e2;
        dfs(1,1);
    }
    printf("%lld\n",ans);
}
```
Q224
```
# include <bits/stdc++.h>
# define pi pair<int,int>
# define X first
# define Y second
using namespace std;
typedef long long ll;
const int N=75000000;
const int M=N/2;
bool pk[M+4];
int pr[M+4],v[M+4],m=0;
int a[104],tot=0;
vector<pi>ps[M+4];
pi merge(pi pa,pi pb){
    return pi(pa.X*pb.X+pa.Y*pb.Y,pb.Y*pa.X-pb.X*pa.Y);
}
int ans=0;
void dfs(int f,int c,pi pa){
    if(f==tot+1){
        if(0<pa.X&&pa.X<=pa.Y){
            int s=c+2*pa.X+2*pa.Y;
            if(s<=N) ++ans;
        }
        return;
    }
    for(pi &pb:ps[a[f]])
        dfs(f+1,c,merge(pa,pb));
}
int fact(int n){
    int ans=1;
    while (n!=1){
        int p=v[n],val=1,e=0;
        for(;v[n]==p;n/=p,++e,val*=p);
        if(p%4==3){
            if(e%2==1) return 0;
            for(;e;e-=2) ans*=p;
        } else a[++tot]=val;
    }
    return ans;
}

int main(){
    for(int i=2;i<=M;i++){
        if(v[i]==0){
            v[i]=i;pr[++m]=i;
        }
        for(int j=1;j<=m;j++){
            if(pr[j]>v[i]||pr[j]>M/i) break;
            v[i*pr[j]]=pr[j];
        }
    }
    for(int i=1;i<=m;i++){
        ll p=pr[i];
        for(;p<=M;p*=pr[i])
            pk[p]=1;
    }
    for(int a=0;a*a<M;a++)
        for(int b=1;;b++){
            int s=a*a+b*b;
            if(s>M) break;
            if(pk[s]) ps[s].push_back(pi(a,b));
        }
    for(int c=1;c*2+1<=M;c++){
        tot=0;
        int w=fact(c+1);
        w*=fact(c);
        if(w==0) continue;
        dfs(1,c*2+1,pi(-w,0));
        dfs(1,c*2+1,pi(w,0));
        dfs(1,c*2+1,pi(0,w));
        dfs(1,c*2+1,pi(0,-w));
    }
    printf("%d\n",ans);
}
// 若a^2+b^2=c^2-1
// 则令a=2u,b=2v,c=2*w+1
// 故有u^2+v^2=w(w+1)，通过公式(u^2+v^2)(A^2+B^2)=(uA+vB)^2+(vA-uB)^2进行变化，合并。
```
Q225
```
Q = 124
cnt = 0
for m in range(27, 27 * Q + 1, 2):
    st = set()
    ok = 1
    a = b = c = 1
    while (a, b, c) not in st:
        st.add((a, b, c))
        a, b, c = b, c, (a + b + c) % m
        if c == 0:
            ok = 0
            break
    if ok:
        cnt += 1
        if cnt == Q:
            break
print(m)
```
Q226
```
def f(x: float):
    n = 0
    ans = 0
    while n <= 40:
        ans += abs(x * (1 << n) - round(x * (1 << n))) / (1 << n)
        n += 1
    return ans


def g(x: float):
    return 0.5 - (x / 2 - x * x) ** 0.5


ans = 0
stp = 2e-6
x = 0
while x <= 0.5:
    fx, gx = f(x), g(x)
    if fx > gx:
        ans += (fx - gx) * stp
    x += stp
print("{:.8f}".format(ans))
```
Q227
```
# include <bits/stdc++.h>
using namespace std;
const int N=54;
double a[N][N];
void gauss(int n){
    for(int i=0;i<n;i++){
        for(int j=i;j<n;j++)
            if(abs(a[j][i])>1e-8){
                swap(a[j],a[i]);
                break;
            }
        if(abs(a[i][i])<1e-8) continue;
        for(int j=0;j<n;j++){
            if(j==i) continue;
            double r=a[j][i]/a[i][i];
            for(int k=i;k<=n;k++)
                a[j][k]-=a[i][k]*r;
        }
    }
}
int main(){
    int n=100;
    int m=n>>1;
    for(int i=0;i<m;i++){
        for(int j=1;j<=6;j++)
            for(int k=1;k<=6;k++){
                int x=1,y=i+1;
                if(j==1) ++x;
                else if(j==6) --x;
                if(k==1) ++y;
                else if(k==6) --y;
                int w=abs(x-y);
                ++a[i][min(w,n-w)];
            }
        a[i][i]-=36;
        a[i][m+1]=-36;
    }
    a[m][m]=1;
    gauss(m+1);
    printf("%f\n",a[0][m+1]/a[0][0]);
}
```
Q228
```
st = set()
l, r = 1864, 1909
for n in range(l, r + 1):
    for i in range(n):
        st.add(Fraction(i, n))
print(len(st))

```
Q229
```
# include <bits/stdc++.h>
using namespace std;
const unsigned N=2000000000;
const int M=2000000;
const unsigned SQN=sqrt(N);
unsigned l1[SQN+2],l2[SQN+2],l3[SQN+2],l7[SQN+2];
unsigned char used[M];
int main(){
    for(int i=1;i<=SQN;i++)
        l1[i]=l2[i]=l3[i]=l7[i]=1;
    unsigned ans=0;
    for(unsigned l=0;l<=N;l+=M){
        unsigned r=l+M;
        if(r>N) r=N+1;
        for(unsigned a=1;a*a+l1[a]*l1[a]<r;a++){
            unsigned b=l1[a];
            for(;a*a+b*b<r;b++)
                used[a*a+b*b-l]|=1;
            l1[a]=b;
            b=l2[a];
            for(;a*a+b*b*2<r;b++)
                used[a*a+b*b*2-l]|=2;
            l2[a]=b;
            b=l3[a];
            for(;a*a+b*b*3<r;b++)
                used[a*a+b*b*3-l]|=4;
            l3[a]=b;
            b=l7[a];
            for(;a*a+b*b*7<r;b++)
                used[a*a+b*b*7-l]|=8;
            l7[a]=b;
        }
        for(unsigned i=l;i<r;i++){
            if(used[i-l]==15) ++ans;
            used[i-l]=0;
        }
    }
    printf("%u\n",ans);
}//直接分段筛，减少空间使用。
```
Q230
```
N = 17
A = "1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679"
B = "8214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196"
D = [len(A), len(B)]
for i in range(100):
    D.append(D[-1] + D[-2])


def getdigit(f: int, pos: int):
    if f == 0:
        return A[pos - 1]
    elif f == 1:
        return B[pos - 1]
    else:
        if pos <= D[f - 2]:
            return getdigit(f - 2, pos)
        else:
            return getdigit(f - 1, pos - D[f - 2])


ans = ""
for n in range(N + 1):
    p = (127 + 19 * n) * (7 ** n)
    for i in range(100):
        if D[i] >= p:
            ans += getdigit(i, p)
            break
ans = ans[::-1]
print(ans)
```
Q231
```
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=20000000,M=15000000;
int v[N+4],pr[N/10],m=0;
ll cal(ll n,ll p){
    ll ans=0;
    for(;n;n/=p)
        ans+=n/p;
    return ans;
}
int main(){
    for(int i=2;i<=N;i++){
        if(v[i]==0){
            v[i]=i;pr[++m]=i;
        }
        for(int j=1;j<=m;j++){
            if(pr[j]>v[i]||pr[j]>N/i) break;
            v[i*pr[j]]=pr[j];
        }
    }
    ll ans=0;
    for(int i=1;i<=m;i++){
        int p=pr[i];
        ans+=(cal(N,p)-cal(M,p)-cal(N-M,p))*p;
    }
    printf("%lld\n",ans);
}
```
Q232
```
N = 100
win1 = lose1 = 0.5
f = [[0 for j in range(N + 1)] for i in range(N + 1)]
for p1 in range(N + 1):
    for p2 in range(N + 1):
        if p2 == 0:
            f[p1][p2] = 1
        elif p1 == 0:
            f[p1][p2] = 0
        else:
            mul = 1
            while True:
                win2 = 0.5 / mul
                lose2 = 1.0 - win2
                next2 = max(p2 - mul, 0)
                nw = win1 * win2 * f[p1 - 1][next2] + lose1 * win2 * f[p1][next2] + win1 * lose2 * f[p1 - 1][p2]
                nw /= 1 - lose1 * lose2
                f[p1][p2] = max(f[p1][p2], nw)
                if next2 == 0:
                    break
                mul <<= 1
ans = lose1 * f[N][N] + win1 * f[N - 1][N]
print("{:.8f}".format(ans))
```
Q233
```
# include <bits/stdc++.h>
# define pl pair<ll,int>
# define X first
# define Y second
using namespace std;
typedef long long ll;
const ll N=1e11;
const int M=5000000,O=600000;
priority_queue<pl,vector<pl>,greater<pl>>q;
ll v1[O],p1=0,v3[O],p3=0;
ll a[O],n=0,b[O],m=0;
bool vis[M+4];
ll qpow(ll n,int m){
    ll ans=1;
    for(;m;m>>=1){
        if(m&1) ans=ans*n;
        n=n*n;
    }
    return ans;
}
int main(){
    for(int i=2;i<=M;i++){
        if(vis[i]) continue;
        if(i%4==1) v1[++p1]=i;
        else v3[++p3]=i;
        for(int j=i+i;j<=M;j+=i)
            vis[j]=1;
    }
    for(int i=1;i<=p1;i++){
        ll x=v1[i]*v1[i]*v1[i];
        if(x>N) break;
        for(int j=1;j<=p1;j++){
            if(j==i) continue;
            ll y=x*v1[j]*v1[j];
            if(y>N) break;
            for(int k=1;k<=p1;k++){
                if(k==i||k==j) continue;
                ll z=y*v1[k];
                if(z>N) break;
                a[++n]=z;
            }
        }
    }
    for(int i=1;i<=p1;i++){
        ll x=qpow(v1[i],7);
        if(x>N) break;
        for(int j=1;j<=p1;j++){
            if(j==i) continue;
            ll y=x*v1[j]*v1[j]*v1[j];
            if(y>N) break;
            a[++n]=y;
        }
    }
    for(int i=1;i<=p1;i++){
        ll x=qpow(v1[i],10);
        if(x>N) break;
        for(int j=1;j<=p1;j++){
            if(j==i) continue;
            ll y=x*v1[j]*v1[j];
            if(y>N) break;
            a[++n]=y;
        }
    }
    sort(a+1,a+n+1);
    ll MX=N/a[1];
    b[++m]=1;
    for(int i=1;i<=p3&&v3[i]<=MX;i++)
        q.push(pl(v3[i],i));
    while(!q.empty()){
        pl pa=q.top();q.pop();
        b[++m]=pa.X;
        for(int i=pa.Y;i<=p3;i++){
            ll x=pa.X*v3[i];
            if(x>MX) break;
            q.push(pl(x,i));
        }
    }
    ll ans=0;
    for(int l=1,r=m;l<=n;l++){
        for(;r>0&&a[l]*b[r]>N;--r);
        for(int i=1;i<=r;i++)
            ans+=a[l]*b[i];
    }
    printf("%lld\n",ans);
    //A046109
}
```
Q234
```
N = 999966663333
M = int(N ** 0.5 + 10 * (N ** 0.1))
pr = []
flag = [0 for _ in range(M + 1)]
for i in range(2, M + 1):
    if flag[i] == 0:
        pr.append(i)
        for j in range(i * i, M + 1, i):
            flag[j] = 1
ans = 0
for i in range(1, len(pr)):
    vl, vr = pr[i - 1], pr[i]
    for v in range((vl * vl + vr - 1) // vr * vr, min(N + 1, vr * vr), vr):
        if v % vl:
            ans += v
    for v in range(vl * (vl + 1), min(N + 1, vr * vr), vl):
        if v % vr:
            ans += v
print(ans)
```
Q235
```
N = -600000000000
n = 5000
l = 1.00
r = 1.01
for _ in range(100):
    q = 0.5 * (l + r)
    s = 0
    for k in range(1, n + 1):
        s += (900 - 3 * k) * (q ** (k - 1))
    if s < N:
        r = q
    else:
        l = q
print("{:.12f}".format(l))
```
Q236
```
# include <bits/stdc++.h>
# define pi pair<int,int>
# define X first
# define Y second
using namespace std;
typedef long long ll;
const ll N=1e11;
const int M=5000000,O=600000;
int gcd(int a,int b){
    return b?gcd(b,a%b):a;
}
struct F{
    int x,y;
    F(int xx=0):x(xx),y(1){};
    F(int xx=0,int yy=1){
        int g=gcd(xx,yy);
        xx/=g;yy/=g;
        x=xx;y=yy;
    };
    F operator + (F f){
        int xx=x*f.y+y*f.x,yy=y*f.y;
        int g=gcd(xx,yy);
        xx/=g;yy/=g;
        return F(xx,yy);
    }
    F operator * (F f){
        int xx=x*f.x,yy=y*f.y;
        int g=gcd(xx,yy);
        xx/=g;yy/=g;
        return F(xx,yy);
    }
    F reverse(){
        return F(y,x);
    }
    bool operator < (F f) const{
        return x*f.y<y*f.x;
    }
    void print(){
        printf("%d/%d\n",x,y);
    }
};
map<F,unordered_map<int,vector<pi>>>mp;
int la[5]={1312,5248,5760};
int lb[5]={1888,640,3776};
int sa=la[0]*6+la[1]+la[2];
int sb=lb[0]*6+lb[1]+lb[2];
F rs=F(sb,sa);
// a0x+b0y=c0
// a1x+b1y=c1
pi cal(ll a0,ll b0,ll c0,ll a1,ll b1,ll c1){
    ll c=a0*b1-a1*b0;
    if(c==0) return pi(-1,-1);
    ll x=c0*b1-c1*b0,y=a0*c1-a1*c0;
    if(x%c||y%c) return pi(-1,-1);
    return pi(x/c,y/c);
}
bool solve(F r,vector<pi>&v0,vector<pi>&v1,vector<pi>&v2){
    r=r.reverse();
    set<pi>s0(v0.begin(),v0.end());
    F f(v0[0].X,v0[0].Y);
    for(pi &p1:v1)
        for(pi &p2:v2){
            pi pa=cal(f.y,-f.x,0,r.y*sb,-r.x*sa,1ll*(p1.Y+p2.Y)*r.x*sa-1ll*(p1.X+p2.X)*r.y*sb);
            if(s0.count(pa)) return 1;
        }
    return 0;
}
int main(){
    for(int k=0;k<3;k++){
        int x=la[k],y=lb[k];
        int st=1,ed=1;
        if(k==0) st=3,ed=6;
        for(int j=1;j<=y;j++){
            for(int i=1;i<=x&&i*y<j*x;i++){
                if(gcd(i,j)!=1) continue;
                F f=F(i*y,j*x);
                if(k&&!mp.count(f)) continue;
                for(int m=st;j*m<=y*ed;m++){
                    mp[f][k].push_back(pi(m*i,m*j));
                }
            }
        }
    }
    for(auto it=mp.begin();it!=mp.end();it++){
        if(it->Y.size()==3){
            auto &v=it->Y;
            if(solve(it->X,v[0],v[1],v[2])){
                F f=it->X;
                f.reverse().print();
                break;
            }
        }
    }
}
```
Q237
```
n = 10 ** 12
mod = 10 ** 8
a = [1, 1, 4, 8]
b = [[0, 0, 0, 1], [1, 0, 0, -2], [0, 1, 0, 2], [0, 0, 1, 2]]
N = 4


# A181688

def mul_self(b: list, N: int):
    c = [[0 for i in range(N)] for j in range(N)]
    for i in range(N):
        for k in range(N):
            if b[i][k]:
                for j in range(N):
                    c[i][j] = (c[i][j] + b[i][k] * b[k][j]) % mod
    return c


def mul(a: list, b: list, N: int):
    c = [0 for i in range(N)]
    for i in range(N):
        for k in range(N):
            c[i] = (c[i] + a[k] * b[k][i]) % mod
    return c


n -= 1
while n:
    if n & 1:
        a = mul(a, b, N)
    b = mul_self(b, N)
    n >>= 1
print(a[0])
```
Q238
```
Q = int(2e15)
s, mod = 14025256, 20300713


def get_BlumBlumShub(s: int, mod: int):
    ls = [s]
    st = set(ls)
    while True:
        s = s * s % mod
        if s in st:
            break
        st.add(s)
        ls.append(s)
    return ls


a = [0]
for v in get_BlumBlumShub(s, mod):
    a += [int(x) for x in str(v)]
presum = [0]
n = len(a) - 1
for i in range(1, n + 1):
    presum.append(presum[-1] + a[i])
m = presum[-1]
for i in range(1, 101):
    presum.append(presum[-1] + a[i])
st = set(presum)
f = [0 for i in range(m + 1)]
for k in range(1, m + 1):
    for p in range(1, len(presum) + 1):
        if k + presum[p - 1] in st:
            f[k] = p
            break
q, r = divmod(Q, m)
ans = sum(f) * q + sum(f[:r + 1])
print(ans)
```
Q239
```
N = 100
n = 25  # 一共25个质数
m = 22
C = [[0 for x in range(y + 1)] for y in range(N + 1)]
for i in range(N + 1):
    C[i][0] = C[i][i] = 1
    for j in range(1, i):
        C[i][j] = C[i - 1][j - 1] + C[i - 1][j]
fac = [1]
for i in range(1, N + 1):
    fac.append(fac[-1] * i)
f = [[0 for x in range(y + 1)] for y in range(m + 1)]  # A047920
for i in range(m + 1):
    f[i][0] = fac[i]
    for j in range(1, i + 1):
        f[i][j] = f[i][j - 1] - f[i - 1][j - 1]
mul = C[n][n - m]
ans = 0
for i in range(m + 1):
    ans += C[m][i] * C[N - n][m - i] * fac[N - n] * f[m][i] * mul
print("{:.12f}".format(ans / fac[N]))
```
Q240
```
from collections import Counter

N = 20
M = 12
C = 10
S = 70
MX = S // C
al = [0 for i in range(N - C)]
ar = [0 for i in range(C)]
ls = [[] for i in range(M + 1)]
fac = [1]
for i in range(1, N + 1):
    fac.append(fac[-1] * i)
ans = 0


def cal(a: list):
    s = fac[N]
    mp = Counter(a)
    for x in mp.values():
        s //= fac[x]
    return s


def dfs1(f: int, pre: int):
    if f == N - C:
        ls[al[-1]].append(al.copy())
        return
    for i in range(pre, MX + 1):
        al[f] = i
        dfs1(f + 1, i)


def dfs2(f: int, pre: int, now: int):
    if now < C - f or now > M * (C - f):
        return
    if f == C:
        global ans
        for i in range(1, ar[0] + 1):
            for v in ls[i]:
                ans += cal(v + ar)
        return
    for i in range(pre, M + 1):
        ar[f] = i
        dfs2(f + 1, i, now - i)


dfs1(0, 1)
dfs2(0, 1, S)
print(ans)
```
Q241
```
N = 10 ** 18
ans = 0


def dfs(n: int, fz: int, fm: int):
    if n * fz > N or gcd(n, fm) != 1 or fz < fm:
        return
    if fm == 1:
        if fz == 1:
            global ans
            ans += n
        return
    p = naive_factorization(fm)[0][0]
    e = 1
    while fm % p ** (e + 1) == 0:
        e += 1
    for i in range(e, 100):
        nw = n * p ** i
        if nw > N:
            break
        newfz = fz * p ** i
        newfm = fm * (p ** (i + 1) - 1) // (p - 1)
        g = gcd(newfz, newfm)
        dfs(nw, newfz // g, newfm // g)


for i in range(3, 19, 2):
    dfs(1, i, 2)
print(ans)
```
Q242
```
# 观察f[i][j]三角形易得出答案。
N = 10 ** 12
N = (N - 1) // 4 + 1
s = bin(N)[2:]
s = s[::-1]
l = len(s)
C = [[0 for x in range(y + 1)] for y in range(l + 1)]
for i in range(l + 1):
    C[i][0] = C[i][i] = 1
    for j in range(1, i):
        C[i][j] = C[i - 1][j - 1] + C[i - 1][j]
cnt = [0 for i in range(l + 1)]
now = 0
for i in range(l - 1, -1, -1):
    if s[i] == '1':
        for j in range(i + 1):
            cnt[now + j] += C[i][j]
        now += 1
ans = 0
for i in range(l+1):
    ans += cnt[i]*2**i
print(ans)
```
Q243
```
pr = []
N = 30
fz, fm = 15499, 94744
flag = [0 for _ in range(N + 1)]
for i in range(2, N + 1):
    if flag[i] == 0:
        pr.append(i)
        for j in range(i * i, N + 1, i):
            flag[j] = 1

ans = 10 ** 50
for i in range(1, 30):
    ph = 2 ** (i - 1)
    v = 2 ** i
    for j in range(1, len(pr)):
        v *= pr[j]
        ph *= pr[j] - 1
        if v >= ans:
            break
        if ph * fm < fz * (v - 1):
            ans = v
            break
print(ans)
```
Q244
```
from queue import Queue


def encode(a: list):
    ans = 0
    for i in range(4):
        for j in range(4):
            ans = ans * 3 + a[i][j]
    return ans


dis = {}
val = {}
mod = 100000007
dx = [0, 0, -1, 1]
dy = [-1, 1, 0, 0]
code = [82, 76, 68, 85]
st = [[0, 1, 2, 2], [1, 1, 2, 2], [1, 1, 2, 2], [1, 1, 2, 2]]
ed = [[0, 2, 1, 2], [2, 1, 2, 1], [1, 2, 1, 2], [2, 1, 2, 1]]
dis[encode(st)] = 0
val[encode(st)] = [0]
q = Queue()
q.put(st)
while not q.empty():
    u = q.get()
    pre = encode(u)
    for i in range(16):
        if u[i >> 2][i & 3] == 0:
            x, y = i >> 2, i & 3
            break
    for k in range(4):
        nx, ny = x + dx[k], y + dy[k]
        if nx < 0 or ny < 0 or nx >= 4 or ny >= 4:
            continue
        v = [a.copy() for a in u]
        v[nx][ny], v[x][y] = v[x][y], v[nx][ny]
        now = encode(v)
        if now not in dis.keys():
            dis[now] = dis[pre] + 1
            val[now] = []
            q.put(v)
        if dis[now] == dis[pre] + 1:
            for w in val[pre]:
                val[now].append((w * 243 + code[k]) % mod)
print(sum(val[encode(ed)]))
```
Q245
```
# semiprimes
N = 2 * 10 ** 11
ls = []
M = int(N ** 0.5)
ans = 0
flag = [0 for _ in range(M + 1)]
pr = []
for i in range(2, M + 1):
    if flag[i] == 0:
        pr.append(i)
        for j in range(i * i, M + 1, i):
            flag[j] = 1
a = [p * (p - 1) + 1 for p in range(M + 1)]
fact = [{} for _ in range(M + 1)]
for i in range(1, len(pr)):
    p = pr[i]
    q = (p - 1) ** 2 + 1
    if p * q > N:
        break
    if Miller_Rabin(q):
        ans += p * q
        ls.append(p * q)
for i in range(2, M + 1, 3):
    a[i] //= 3
for i in range(3, M + 1):
    d = a[i]
    if d <= 1:
        continue
    for k in range(M // d + 1):
        j = i + k * d
        for p in [j, j + d - 2 * i + 1]:
            if p > M:
                break
            fact[p][d] = 0
            while a[p] % d == 0:
                a[p] //= d
                fact[p][d] += 1
for x in pr:
    if len(fact[x].keys()) == 0:
        continue
    n = x * (x - 1) + 1
    p = sorted(fact[x].keys())
    e = [fact[x][w] for w in p]
    c = [0 for i in range(len(fact[x]))]
    d = 1
    while True:
        for i in range(len(p)):
            c[i] += 1
            d *= p[i]
            if d * d <= n and c[i] <= e[i]:
                break
            d //= p[i] ** c[i]
            c[i] = 0
        else:
            break
        q = ((x - d) * (x - 1) + 1) // d
        if q < x or x * q > N or not Miller_Rabin(q):
            continue
        ans += x * q
        ls.append(x * q)


# multiprime
def isp(n: int):
    if n <= M:
        return not flag[n]
    else:
        for x in pr:
            if x * x > n:
                break
            if n % x == 0:
                return 0
        return 1


def dfs(pt: int, n: int, ph: int, q: int):
    fz = n - ph
    k = (q * n - 1) // (ph + q * fz) + 1
    if k & 1:
        k += 1
    num = k * ph + 1
    fm = n - k * fz
    ph2 = ph << 1
    fz2 = fz << 1
    while fm > 0:
        d = num // fm
        if n * d > N:
            break
        if isp(d) and num - d * fm == 0:
            ls.append(n * d)
        fm -= fz2
        num += ph2
    for i in range(pt, len(pr)):
        if n * pr[i] ** 2 > N:
            break
        dfs(i + 1, n * pr[i], ph * (pr[i] - 1), pr[i])


for i in range(1, len(pr)):
    # print(pr[i])
    if pr[i] ** 3 > N:
        break
    for j in range(i + 1, len(pr)):
        if pr[i] * pr[j] ** 2 > N:
            break
        dfs(j + 1, pr[i] * pr[j], (pr[i] - 1) * (pr[j] - 1), pr[j])
ls.sort()
print(sum(ls))
```
Q246
```
from math import sqrt, floor, ceil
import sys

a = 7500
c = 5000
b = sqrt(a * a - c * c)
a2 = a * a
c2 = c * c
b2 = a2 - c2
eps = 1e-10
cnt2 = cnt4 = 0
x0 = 0
prer = (a + 4) * (a + 4)
while True:
    if x0 != a:
        if x0 < a:
            y0 = ceil(sqrt(b2 * (1 - x0 * x0 / a2)))
        else:
            y0 = 0
        l = y0
        r = prer
        while l < r:
            mid = (l + r + 1) >> 1
            A = x0 * x0 - a2
            B = -2 * x0 * mid
            C = mid * mid - b2
            D = B * B - 4 * A * C
            k = [(-B - sqrt(D)) / (2 * A), (-B + sqrt(D)) / (2 * A)]
            tg = (k[1] - k[0]) / (1 + k[0] * k[1])
            if 0 < tg <= 1:
                r = mid - 1
            else:
                l = mid
        if l == 0:
            break
        if x0 == 0:
            cnt2 += l - y0 + 1
        elif y0 > 0:
            cnt4 += l - y0 + 1
        else:
            cnt4 += l
            cnt2 += 1
        prer = l
    else:
        y0 = 1
        while True:
            k = (y0 * y0 - b2) / (2 * x0 * y0)
            if k >= 1:
                break
            cnt4 += 1
            y0 += 1
    x0 += 1
ans = cnt2 * 2 + cnt4 * 4
print(ans)
# 联立x^2/a^2+y^2/b^2=1和y-y0=k(x-x0)，得出一个关于x的一元二次方程。
# 由于是切线，令这个方程的delta为0后，得出一个关于k的一元二次方程。
# k的解即为两条切线斜率。
```
Q247
```
from queue import PriorityQueue
from math import sqrt


def get(sx: int, sy: int, vx: int, vy: int):
    A = 1
    B = sy - sx
    C = -1
    D = B * B - 4 * A * C
    x = (-B + sqrt(D)) / (2 * A)
    r = x - sx
    return -r, sx, sy, vx, vy


ax, ay = 3, 3
q = PriorityQueue()
r = (1 + sqrt(5)) / 2 - 1
q.put((-r, 1, 0, 0, 0))
i = 1
ans = 0
while True:
    r, sx, sy, x, y = q.get()
    r = -r
    if r < 5e-4:
        break
    if x == ax and y == ay:
        ans = i
        # break
    i += 1
    q.put(get(sx + r, sy, x + 1, y))
    q.put(get(sx, sy + r, x, y + 1))
print(ans)
```
Q248
```
I = 13
Q = 150000
a = 1
for i in range(1, I + 1):
    a *= i
lt = []
ls = []
fact = naive_factorization(a)
p = [v[0] for v in fact]
e = [v[1] for v in fact]
m = len(p)
for i in range(1, int(a ** 0.5) + 1):
    if a % i == 0:
        lt.append(i)
        if i * i != a:
            lt.append(a // i)
for d in lt:
    if Miller_Rabin(d + 1):
        fact = naive_factorization(d)
        mp = {}
        for v in fact:
            mp[v[0]] = v[1]
        v = []
        for x in p:
            if x in mp.keys():
                v.append(mp[x])
            else:
                v.append(0)
        ls.append((d, tuple(v)))
ls.sort()
ans = []


def dfs(pos: int, n: int, st: set, now: list, res: int):
    ok = 1
    for i in range(m):
        if now[i] and p[i] not in st:
            ok = 0
            break
    if ok:
        ans.append(n * res)
    for i in range(pos, len(ls)):
        if res % ls[i][0] == 0:
            for j in range(m):
                now[j] -= ls[i][1][j]
            st.add(ls[i][0] + 1)
            dfs(i + 1, n * (ls[i][0] + 1), st, now, res // ls[i][0])
            for j in range(m):
                now[j] += ls[i][1][j]
            st.remove(ls[i][0] + 1)


dfs(0, 1, set(), e, a)
ans.sort()
print(ans[Q-1])
```
Q251
```
N = 110000000
M = (N + 1) // 3
MXR = int((((M * 8) - 3) / 5) ** 0.5)
MXQ = int(((N + 1) / 5) ** 0.5)


def ex_gcd(a: int, b: int):
    if b == 0:
        return 1, 0, a
    else:
        x, y, g = ex_gcd(b, a % b)
        return y, x - (a // b) * y, g


def solve_ax_plus_by_is_c(a: int, b: int, c: int):
    if a < 0:
        a, b, c = -a, -b, -c
    x, y, g = ex_gcd(a, b)
    if c % g != 0:
        return None
    ma = abs(a // g)
    mc = c // g
    x *= mc
    y *= mc
    y = (y % ma + ma) % ma
    x = (c - b * y) // a
    return x, y, abs(g)


ans = 0
for r in range(1, MXR + 1, 2):
    for q in range(1, MXQ + 1):
        v = solve_ax_plus_by_is_c(8 * q, -r * r, 3)
        if v is None or v[2] != 1:
            continue
        p, s, g = v
        low = p * r + s * q * q + p * 3 * q
        # print(q, r, 8 * r, q * q, p, s, low)
        d = r * r * (r + (3 * q)) + 8 * q ** 3
        if low > N + 1:
            continue
        elif low + d > N + 1:
            ans += 1
        else:
            ans += 1 + (N + 1 - low) // d
print(ans)
'''
原式等价于求8*a^3+15*a^2+6a-1=27b^2c的解。
令F(a)=8*a^3+15*a^2+6a-1。
可知，当a%3==2时，F(a)%27==0。
F(a)分解因式后为(a+1)^2(8a-1)。
令a=3k+2，k>=0，则G(k)=F(3k+2)=27(k+1)^2(8k+5)。
即求(k+1)^2(8k+5)=b^2c[A]的所有解，且3k+2+b+c<=M
设p=gcd(b,k+1)，那么就可以写成b=pr和k+1=pq，其中gcd(r,q)=1。
代入[A]，则有cr^2=q^2(8k+5)[B]。
由于r和q互质，因此存在s使得c=sq^2且8k+5=sr^2。
联立b=pr,c=sq^2,k+1=pq和8k+5=sr^2。
问题转化成三元组(a=3pq-1, b=pr, c=sq^2)中，满足下面条件的个数：
1. gcd(r,q)=1.
2. 8pq=sr^2+3.
3. 3pq+pr+sq^2<=M+1.
枚举每对互质的(q,r)后开始计算。
也可以知道，如果存在最小的P和S满足方程8Pq=Sr^2+3，那么p'=P+r^2，s'=S+8q也是方程的解。
所以问题则转化为计算有多少个k使得k>=0且3pq+pr+sq^2<=M+1。代入后，即P(3q+r)+Sq^2+k(r^2(3q+r)+8q^3)<=M+1。
P和S的值可以通过扩展欧几里德算法计算。
'''
```
Q252
```
N = 500


class V:
    def __init__(self, x: int, y: int):
        self.x, self.y = x, y

    def __add__(self, other):
        return V(self.x + other.x, self.y + other.y)

    def __sub__(self, other):
        return V(self.x - other.x, self.y - other.y)

    def __mul__(self, other):
        return self.x * other.y - self.y * other.x

    def __str__(self):
        return "({}, {})".format(self.x, self.y)

    def __lt__(self, other):
        return atan2(self.y, self.x) < atan2(other.y, other.x)


S = [290797]
T = []
ans = 0


def solve(p: list):
    m = len(p)
    p.sort()
    global ans
    dp = [[0 for j in range(m)] for i in range(m)]
    for i in range(m):
        j = i - 1
        while j >= 0 and p[i] * p[j] == 0:
            j -= 1
        flag = (j == i - 1)
        while j >= 0:
            k = j - 1
            while k >= 0 and (p[i] - p[k]) * (p[j] - p[k]) > 0:
                k -= 1
            s = abs(p[i] * p[j])
            if k >= 0:
                s += dp[j][k]
            if flag:
                dp[i][j] = s
            ans = max(ans, s)
            j = k
        if flag:
            for j in range(1, i):
                dp[i][j] = max(dp[i][j], dp[i][j - 1])


for i in range(N + N):
    S.append(S[-1] * S[-1] % 50515093)
for x in S:
    T.append(x % 2000 - 1000)
pts = []
for i in range(2, N + N + 1, 2):
    pts.append(V(T[i - 1], T[i]))
for p in pts:
    ls = []
    for q in pts:
        if q.y > p.y or q.y == p.y and q.x > p.x:
            ls.append(q - p)
    solve(ls)
print(ans / 2)
'''
枚举每个点，作为原点O。把在点O下面或在O点的正左向的所有点抛弃。
dp[i][j]表示最后一个三角形为Oij
(i>j)的点。那么满足dp[i][j]=\max(dp[j][k]+三角形Oij的面积)，其中k只能在向量ij的右侧以保证这个多边形是凸的。
对于j0=i-1，三角形Oij0一定是个合法的三角形，如果O,i,j0三点共线，那么顺时针找j0，找到第一个与Oi不共线为止。
然后找最大的j1，使得j1在向量ij0右侧，此时经排序后三角形ij0j1中不包含任何点。故有转移dp[i][j0]=max(dp[i][j0],dp[i][j1]+三角形Oij1的面积)。这将可以进行快速转移。并且，不合法的Oij的值最终为0。并且，j1之前的点都可以由此转移而来。
设g[i][j]=max(dp[i][k],1<=k<=j), 因此dp[i][j0]=g[j0][j1]+三角形Oij0的面积。
'''
```
Q253
```
N = 40
M = (N + 1) >> 1
mp = [[{} for j in range(M + 1)] for i in range(N + 1)]


def insert(i: int, j: int, mq: dict, suf: list, val: int):
    if suf[0] > suf[1]:
        suf[0], suf[1] = suf[1], suf[0]
    ls = []
    for u, v in mq.items():
        if v > 0:
            ls.append((u, v))
    ls.sort()
    ls = tuple(ls)
    lt = (ls, tuple(suf))
    if lt not in mp[i][j].keys():
        mp[i][j][lt] = 0
    mp[i][j][lt] += val


for i in range(1, N + 1):
    insert(1, 1, {}, [i - 1, N - i], 1)
for i in range(1, N):
    for j in range(1, M + 1):
        for tup, val in mp[i][j].items():
            tp = {}
            for x, y in tup[0]:
                tp[x] = y
            for x, y in tup[0]:
                for k in range(1, x + 1):
                    tq = tp.copy()
                    if k > 1:
                        if k - 1 not in tq.keys():
                            tq[k - 1] = 0
                        tq[k - 1] += 1
                    if k < x:
                        if x - k not in tq.keys():
                            tq[x - k] = 0
                        tq[x - k] += 1
                    tq[x] -= 1
                    s = max(j, sum(tq.values()) + 1)
                    insert(i + 1, s, tq, [tup[1][0], tup[1][1]], val * y)
            suf = tup[1]
            for r in range(2):
                for k in range(1, suf[r] + 1):
                    tq = tp.copy()
                    if k > 1:
                        if k - 1 not in tq.keys():
                            tq[k - 1] = 0
                        tq[k - 1] += 1
                    s = max(j, sum(tq.values()) + 1)
                    if r == 0:
                        insert(i + 1, s, tq, [suf[0] - k, suf[1]], val)
                    else:
                        insert(i + 1, s, tq, [suf[0], suf[1] - k], val)
s0 = s1 = 0
for i in range(1, M + 1):
    v = mp[N][i][((), (0, 0))]
    s0 += i * v
    s1 += v
print("{:.6f}".format(s0 / s1))
```
Q254
```
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int Q=150,B=19,S=9,MX=1e7;
const int W=362880,N=63;
ll pw[B],fac[B];
int dcnt[W][S],sd[W],cd[W];
int lq[N],pq[N][S];
bool ok(int a[],int b[]) {
    for (int i = 0; i < S; i++)
        if (a[i] != b[i]) return a[i] < b[i];
    return 0;
}
int main() {
    pw[0] = fac[0] = 1;
    for (int i = 1; i < B; i++)
        pw[i] = pw[i - 1] * 10, fac[i] = fac[i - 1] * i;
    // 每个数i，贪心取最大的值，尽量取完，然后再取最小的。dcnt[i][j]表示从i中分出dcnt[i][j]个fac[j]。
    // sd[i]= sum j=1^9 dcnt[i][j]*j, cd[i]表示i分出来的最少份数。
    for (int i = 0; i < W; i++) {
        for (int j = 8, t = i; j > 0; j--) {
            dcnt[i][j] = t / fac[j];
            sd[i] += dcnt[i][j] * j;
            cd[i] += dcnt[i][j];
            t %= fac[j];
        }
    }
    //1~62时直接暴力枚举。枚举范围是10^7。
    for (int r = 0; r <= MX; r++) {
        int a = r / W, b = r % W;
        int s = 0;
        for (int x = r; x; x /= 10)
            s += x % 10;
        if (s >= N) continue;
        if (lq[s] == 0 || lq[s] > cd[b] + a || lq[s] == cd[b] + a && ok(pq[s], dcnt[b])) {
            lq[s] = cd[b] + a;
            for (int i = 0; i < S; i++)
                pq[s][i] = dcnt[b][i];

        }
    }
    ll ans = 0;
    for (int i = 1; i <= Q && i < N; i++) {
        ans += lq[i] * 9;
        for (int j = 1; j < S; j++)
            ans -= pq[i][j] * (9 - j);
    }
    //63以后全部贪心取9。
    for (int i = N; i <= Q; i++) {
        long long t = (i % 9 + 1) * pw[i / 9] - 1;
        ans += (t / W) * 9 + sd[t % W];
    }
    printf("%lld\n", ans);
}
```
