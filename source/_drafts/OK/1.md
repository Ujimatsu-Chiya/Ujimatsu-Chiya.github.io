## Q167
```C++
# include <bits/stdc++.h>
# define X first
# define Y second
using namespace std;
typedef long long ll;
int main(){
    ll n=1e11;
    ll sum=0;
    map<int,int>mp;
    for(int i=2;i<=10;i++){
        int even=0,even_pos=0;
        mp.clear();
        vector<int>U;U.push_back(2*i+1);
        do{
            ++mp[U.back()+2];
            if(even) ++mp[U.back()+even];
            else{
                for(int j=0;j+1<U.size();j++)
                    mp[U.back()+U[j]]++;
            }
            if(U.back()%2==0){
                even=U.back();even_pos=U.size()-1;
                for(auto & it : mp)
                    if(it.X%2==0) ++it.Y;
            }
            for(auto it=mp.begin();it!=mp.end();it++)
                if(it->Y==1){
                    U.push_back(it->X);
                    mp.erase(mp.begin(),++it);
                    break;
                }
        }while(U.back()-U[U.size()-2]!=even);
        int period=U.size()-2,diff=U.back()-U.front();
        int s=(n-3)%period;
        if(s>=even_pos) ++s;
        ll ans=(n-3)/period*diff+U[s];
        sum+=ans;
    }
    printf("%lld\n",sum);
}
/*
Schmerl和Spiegel在1994年证明：
满足n>=2的Ulam序列U(2,2n+1)有且只有两个偶数，其中一个是2，设另外一个为even.
设U'(2,2n+1)为U(2,2n+1)去掉两个偶数项后剩下的数，那么U'(2n+1)的差分序列是一个循环数组，其中最小的循环节中有且仅有一个even，并且这个even在整个循环节中的最后一个数、
*/
```
## Q180
```Python
def isq(n: int):
    m = int(n ** 0.5)
    return m * m == n


k = 35
one = Fraction(1)
fraction_set = set()
for b in range(1, k + 1):
    for a in range(1, b):
        fraction_set.add(Fraction(a, b))
fraction_list = list(fraction_set)
l = len(fraction_list)
st = set()
for i in range(l):
    x = fraction_list[i]
    for j in range(i, l):
        y = fraction_list[j]
        z = x + y
        if z in fraction_set:
            st.add(x + y + z)
        z2 = x * x + y * y
        if isq(z2.numerator) and isq(z2.denominator):
            z = Fraction(int(z2.numerator ** 0.5), int(z2.denominator ** 0.5))
            if z in fraction_list:
                st.add(x + y + z)
        z = one / (one / x + one / y)
        if z in fraction_set:
            st.add(x + y + z)
        tp = one / (one / x / x + one / y / y)
        if isq(tp.numerator) and isq(tp.denominator):
            z = Fraction(int(tp.numerator ** 0.5), int(tp.denominator ** 0.5))
            if z in fraction_set:
                st.add(x + y + z)

s = sum(st)
print(s.numerator + s.denominator)
# f_n(x,y,z)=(x+y+z)*(x^n+y^n-z^n)
# 此时变为求方程x^n+y^n=z^n是否有有理数解。
# 根据费马大定理，可以证明，n>=3时，没有有理数解。
# 说明：设x=a/b,y=c/d,z=e/f.
# 代入式子后，通分，即可化成(adf)^n+(bcf)^n=(bde)^n，成为一个整式，根据费马大定理，n>=3时无整数解，故原命题成立，只本题只需验证n=-2,-1,1和2的情况即可。
```
## Q185
```Python
from random import randint

lt = [("5616185650518293", 2), ("3847439647293047", 1), ("5855462940810587", 3), ("9742855507068353", 3),
      ("4296849643607543", 3), ("3174248439465858", 1), ("4513559094146117", 2), ("7890971548908067", 3),
      ("8157356344118483", 1), ("2615250744386899", 2), ("8690095851526254", 3), ("6375711915077050", 1),
      ("6913859173121360", 1), ("6442889055042768", 2), ("2321386104303845", 0), ("2326509471271448", 2),
      ("5251583379644322", 2), ("1748270476758276", 3), ("4895722652190306", 1), ("3041631117224635", 3),
      ("1841236454324589", 3), ("2659862637316867", 2)]
ls = []
for x, y in lt:
    ls.append(([int(w) for w in x], y))
n, m = len(ls), len(ls[0][0])


def shuffle(ls: list, id: int):
    while True:
        w = randint(0, 9)
        if ls[id] != w:
            break
    ls[id] = w


def distance(val: list):
    error = 0
    for v, cnt in ls:
        c = 0
        for i in range(m):
            if v[i] == val[i]:
                c += 1
        error += abs(cnt - c)
    return error


ans = [0 for i in range(m)]
for i in range(m):
    shuffle(ans, i)

MAX_ROUNDS = 20
STUCK_ROUNDS = 0
dis = pre_dis = distance(ans)
while dis != 0:
    for i in range(m):
        pre = ans[i]
        shuffle(ans, i)
        now_dis = distance(ans)
        if now_dis <= dis:
            dis = now_dis
        else:
            ans[i] = pre
    if dis == pre_dis:
        STUCK_ROUNDS += 1
        if STUCK_ROUNDS == MAX_ROUNDS:
            shuffle(ans, randint(0, m - 1))
            dis = distance(ans)
            STUCK_ROUNDS = 0
    else:
        STUCK_ROUNDS = 0
        pre_dis = dis
print("".join(str(x) for x in ans))
# 伪模拟退火算法，distance函数计算当前与推测的误差，误差值为sum(提示项的预估正确数和实际正确数之差的绝对值。)
# shuffle为对列表的某一位进行随机化，但随机后的数字必须与原来的不同。
# STUCK_ROUNDS和MAX_ROUNDS用于防止程序陷入局部最优解中，如果陷入了，那么就随机改变一位数字，尽管这会让误差值变大。

# 另有一种做法是，把所有解的前8位数字和22组提示的正确值前8位数字存入哈希表中，然后将后8位数字的正确值所有情况计算出来，分别在哈希表中查找之前的结果。这使用了meet in the middle的想法。
```
## Q189
```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=8;
ll f[N+1][7004];
int pw3[N+1],c[8];
vector<int>g[7004];
int main(){
    for(int i=0;i<8;i++){
        for(int j=0;j<3;j++)
            c[i]+=(i>>j&1);
        c[i]=3-c[i];
    }
    pw3[0]=1;
    for(int i=1;i<=N;i++)
        pw3[i]=pw3[i-1]*3;
    f[1][0]=f[1][1]=f[1][2]=1;
    for(int j=0;j<pw3[N];j++){
        int x=j;
        for(int k=0;k<N;k++,x/=3)
            g[j].push_back(x%3);
    }
    for(int i=1;i<N;i++){
        for(int j=0;j<pw3[i];j++){
            for(int k=0;k<pw3[i+1];k++){
                int v=1;
                for(int l=0;l<i;l++)
                    v*=c[1<<g[j][l]|1<<g[k][l]|1<<g[k][l+1]];
                f[i+1][k]+=f[i][j]*v;
            }
        }
    }
    ll ans=0;
    for(int i=0;i<pw3[N];i++)
        ans+=f[N][i];
    printf("%lld\n",ans);
}
```
## Q192
```Python
# https://en.wikipedia.org/wiki/Continued_fraction#Best_rational_approximations
def get_fraction_list(n: int, l: int):
    m = 0
    d = 1
    a = a0 = int(n ** 0.5)
    ls = [a]
    while len(ls) < l:
        m = d * a - m
        d = (n - m * m) / d
        a = int((a0 + m) / d)
        ls.append(a)
    return ls


def allow_half(a: list, k: int):
    i = k
    s = 1
    while i > 0:
        difference = s * (a[i] - a[2 * k - i])
        if difference > 0:
            return True
        if difference < 0:
            return False
        s *= -1
        i -= 1
    return (k & 1) == 0


def solve(m: int, lim: int):
    a = get_fraction_list(m, 128)
    n2, d2 = 1, 0
    n1, d1 = a[0], 1
    i = 1
    while True:
        n = d = 0
        val = (a[i] + 1) >> 1
        if (a[i] & 1) == 0 and not allow_half(a, i):
            val += 1
        for q in range(val, a[i] + 1):
            n, d = n2 + q * n1, d2 + q * d1
            if d > lim:
                if q > val:
                    return d2 + (q - 1) * d1
                else:
                    return d1
        i += 1
        print(n2, n1, n)
        print(d2, d1, d, end="\n\n")
        n2, n1 = n1, n
        d2, d1 = d1, d


N = 10 ** 5
M = 10 ** 12
ans = 0
for S in range(13, 14):
    n = int(S ** 0.5)
    if n * n == S:
        continue
    ans += solve(S, M)
print(ans)
```
## Q198
```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
struct TP{
    ll lu,ld,ru,rd,midd;
};
int main(){
    ll r=100,n=1e8;
    vector<TP>v;
    v.push_back(TP{0,1,1,1,2});
    ll ans=0;
    while(!v.empty()){
        TP t=v.back();v.pop_back();
        ll midd=t.midd,midu=t.lu*t.rd+t.ld*t.ru;
        if(r*midu<midd) ++ans;
        ll gend=t.ld+t.rd,genu=t.lu+t.ru;
        ll lmidd=2ll*t.ld*gend,rmidd=2ll*t.rd*gend;
        if(lmidd<=n)
            v.push_back(TP{t.lu,t.ld,genu,gend,lmidd});
        if(rmidd<=n)
            v.push_back(TP{genu,gend,t.ru,t.rd,rmidd});
    }
    printf("%lld\n",ans);
}
//# 非递归前序遍历Stern-Brocot树以获得F(n)的Farey序列。
// 可以知道，如果分数a和b在某个Farey序列F(n)中相邻，那么(a+b)/2就是其中一个解。
```