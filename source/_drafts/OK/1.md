## Q107
```Python
ls = open('r.txt', 'r').readlines()
n = len(ls)
fa = [i for i in range(n)]


def find(x: int):
    if x == fa[x]:
        return x
    else:
        fa[x] = find(fa[x])
        return fa[x]


def merge(x: int, y: int):
    fa[find(x)] = find(y)


e = []
ans = 0
for i in range(n):
    lt = ls[i].split(',')
    for j in range(i):
        if lt[j][0] == '-':
            continue
        w = int(lt[j])
        e.append((w, i, j))
        ans += w
e.sort()
for z, x, y in e:
    if find(x) != find(y):
        merge(x, y)
        ans -= z
print(ans)
```
## Q108
```Python
pr = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59]

ans = 10 ** 1000
N = 1000


def dfs(n: int, m: int, f: int, lm: int):
    global ans
    if (m + 1) >> 1 >= N:
        ans = n
        return
    for i in range(1, lm + 1):
        n *= pr[f]
        if n > ans:
            break
        dfs(n, m * (2 * i + 1), f + 1, i)


dfs(1, 1, 0, 1000)
print(ans)
```
## Q109
```Python
a = []
N = 100
for i in range(1, 21):
    a.append(2 * i)
a.append(50)
m = len(a)
a.append(25)
for i in range(1, 21):
    a.append(i)
    a.append(i * 3)
n = len(a)
ans = 0
for i in range(m):
    if a[i] < N:
        ans += 1
for i in range(n):
    for j in range(m):
        if a[i] + a[j] < N:
            ans += 1
for i in range(n):
    for j in range(i, n):
        for k in range(m):
            if a[i] + a[j] + a[k] < N:
                ans += 1
print(ans)
```
## Q110
```Python
pr = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59]

ans = 10 ** 1000
N = 4000000


def dfs(n: int, m: int, f: int, lm: int):
    global ans
    if (m + 1) >> 1 >= N:
        ans = n
        return
    for i in range(1, lm + 1):
        n *= pr[f]
        if n > ans:
            break
        dfs(n, m * (2 * i + 1), f + 1, i)


dfs(1, 1, 0, 1000)
print(ans)
```
## Q111
```Python
a = []
n = 10
ls = [[] for i in range(n)]
for s in range(1, (1 << n) - 1):
    ls[bin(s).count('1')].append(s)


def gen(msk: int, f: int, dg: int, num: int):
    if f == -1:
        if Miller_Rabin(num):
            a.append(num)
        return
    if f == n - 1:
        if msk >> f & 1:
            if dg == 0:
                return
            else:
                gen(msk, f - 1, dg, num * 10 + dg)
        else:
            for k in range(1, 10):
                if k != dg:
                    gen(msk, f - 1, dg, num * 10 + k)
    else:
        if msk >> f & 1:
            gen(msk, f - 1, dg, num * 10 + dg)
        else:
            for k in range(10):
                if k != dg:
                    gen(msk, f - 1, dg, num * 10 + k)


ans = 0
for d in range(10):
    for u in range(n - 1, 0, -1):
        s, a = 0, []
        for v in ls[u]:
            gen(v, n - 1, d, 0)
        for x in a:
            s += x
        if s:
            ans += s
            break
print(ans)
```
## Q112
```Python
cnt = 0
n = 1600000
m = 99
for i in range(1, n + 1):
    s = str(i)
    t = "".join((lambda x: (x.sort(), x)[1])(list(s)))
    if s == t:
        continue
    t = t[::-1]
    if s == t:
        continue
    cnt += 1
    if cnt * 100 == m * i:
        print(i)
        break
```
## Q113
```Python
n = 100
f = [1 for _ in range(10)]
f[0] = 0
g = list(f)
ans = 9
for i in range(n - 1):
    a, s = [], 0
    for j in range(10):
        s += f[j]
        a.append(s)
    f = a
    a, s = [], 0
    for j in range(9, -1, -1):
        s += g[j]
        a.append(s)
    a.reverse()
    g = a
    ans += sum(f) + sum(g) - 9
print(ans)
```
## Q114
```Python
n = 50
m = 3
f = [[0, 0] for _ in range(n + 1)]
s = [0 for _ in range(n + 1)]
f[0][0] = f[1][0] = s[0] = 1
for i in range(1, n + 1):
    f[i][0] = f[i - 1][0] + f[i - 1][1]
    if i >= m:
        f[i][1] = s[i - m]
    s[i] = s[i - 1] + f[i][0]
print(f[n][0] + f[n][1])
```
## Q115
```Python
n = 200
m = 50
f = [[1, 0]]
s = [1]
for i in range(1, n + 1):
    f.append([0, 0])
    f[i][0] = f[i - 1][0] + f[i - 1][1]
    if i >= m:
        f[i][1] = s[i - m]
    s.append(s[i - 1] + f[i][0])
    w = f[i][0] + f[i][1]
    if w > 1000000:
        print(i)
        break
```
## Q116
```Python
f = [1, 1]
g = [1, 1, 1]
h = [1, 1, 1, 1]
n = 50
for i in range(2, n + 1):
    if i >= 2:
        f.append(f[-1] + f[-2])
    if i >= 3:
        g.append(g[-1] + g[-3])
    if i >= 4:
        h.append(h[-1] + h[-4])

print(f[n] + g[n] + h[n] - 3)
```
## Q117
```Python
f = [1, 1]
n = 50
for i in range(2, n + 1):
    s = f[-1] + f[-2]
    if i >= 3:
        s += f[-3]
    if i >= 4:
        s += f[-4]
    f.append(s)
print(f[n])
```
## Q118
```Python
pr = []
N = 100000
flag = [0 for _ in range(N + 1)]
ans=0
for i in range(2, N + 1):
    if flag[i] == 0:
        pr.append(i)
        for j in range(i * i, N + 1, i):
            flag[j] = 1


def judge(n: int):
    if n == 1:
        return False
    for x in pr:
        if x * x > n:
            break
        if n % x == 0:
            return False
    return True


def dfs(f: int, pre: int, now: int, a: list):
    global ans
    if f == 9:
        if now == 0:
            ans += 1
        return
    now = now * 10 + a[f]
    if now > pre and judge(now):
        dfs(f + 1, now, 0, a)
    dfs(f + 1, pre, now, a)


for per in permutations([1, 2, 3, 4, 5, 6, 7, 8, 9]):
    if per[8] in {2, 4, 5, 6, 8}:
        continue
    dfs(0, 0, 0, per)
print(ans)
```
## Q119
```Python
ls = []
m = 30
for p in range(2, 1000):
    for e in range(2, 30):
        y = sum(int(w) for w in str(p ** e))
        if y == p:
            ls.append(p ** e)
ls.sort()
print(ls[m - 1])
```
## Q120
```Python
N = 1000
ans = 0
for a in range(3, N + 1):
    if a & 1:
        ans += a * (a - 1)
    else:
        ans += a * (a - 2)
print(ans)
```
## Q121
```Python
f = [[1]]
n = 15
for i in range(1, n + 1):
    ls = [0 for j in range(i + 1)]
    f.append(ls)
    for j in range(i + 1):
        if j > 0:
            f[i][j] += f[i - 1][j - 1] * 1 / (i + 1)
        if j < i:
            f[i][j] += f[i - 1][j] * i / (i + 1)
ans = 0
for j in range(n + 1):
    if j > n - j:
        ans += f[n][j]
print(int(1/ans))
```
## Q122
```Python
n = 200
ans = 0
INF = 0x3f3f3f3f3f
f = [INF for _ in range(n + 1)]
a = [0 for _ in range(n + 1)]


# Addition-chain exponentiation

def dfs(u: int, d: int):
    if u > n or d > f[u]:
        return
    f[u] = d
    a[d] = u
    for i in range(d, -1, -1):
        dfs(u + a[i], d + 1)


dfs(1, 0)
print(sum(f[1:]))
```
## Q123
```Python
pr = []
N = 250000
m=int(1e10)
flag = [0 for _ in range(N + 1)]
for i in range(2, N + 1):
    if flag[i] == 0:
        pr.append(i)
        for j in range(i * i, N + 1, i):
            flag[j] = 1
for i in range(0, len(pr), 2):
    w=2 * (i + 1) * pr[i] % (pr[i] * pr[i])
    if w >= m:
        print(i+1)
        break
```
## Q124
```Python
N, m = 10 ** 5, 10 ** 4
mul = [1 for _ in range(N + 1)]
ls = [(1, 1)]
for i in range(2, N + 1):
    if mul[i] == 1:
        for j in range(i, N + 1, i):
            mul[j] *= i
    ls.append((mul[i], i))
ls.sort()
print(ls[m - 1][1])
```
## Q125
```Python
s = [0]
m = 10 ** 8
for x in range(1, 100000):
    if x * x > m:
        break
    s.append(s[-1] + x * x)
st = set()
for r in range(2, len(s)):
    p = bisect.bisect_left(s, s[r] - m)
    for l in range(p, r - 1):
        w = s[r] - s[l]
        t = str(w)
        if t == t[::-1]:
            st.add(w)

print(sum(st))
```
## Q126
```Python
def cal(x: int, y: int, z: int, n: int):
    return 2 * (x * y + y * z + x * z) + 4 * (x + y + z + n - 2) * (n - 1)


m, q = 20000, 1000
f = [0 for _ in range(m + 1)]
x = 1
while cal(x, x, x, 1) <= m:
    y = x
    while cal(x, y, y, 1) <= m:
        z = y
        while cal(x, y, z, 1) <= m:
            c = 1
            while cal(x, y, z, c) <= m:
                f[cal(x, y, z, c)] += 1
                c += 1
            z += 1
        y += 1
    x += 1
for i in range(m + 1):
    if f[i] == q:
        print(i)
        break
```
## Q127
```Python
N = 120000 - 1
ls = []
mul = [1 for _ in range(N + 1)]
for i in range(2, N + 1):
    if mul[i] == 1:
        for j in range(i, N + 1, i):
            mul[j] *= i
    ls.append((mul[i], i))
ls.sort()
ans = 0
for i in range(1, N):
    if mul[i] * mul[i + 1] < i + 1:
        ans += i + 1
for c in range(1, N + 1):
    if mul[c] * 6 > c:
        continue
    for t, a in ls:
        if mul[a] * mul[c] >= c:
            break
        b = c - a
        if a < b and mul[a] * mul[b] * mul[c] < c and gcd(a, c) == 1:
            ans += c
print(ans)
```
## Q128
```Python
def floor(x: int, y: int):
    if x == 0 or y == 0 or x * y > 0:
        return max(abs(x), abs(y))
    else:
        return abs(x) + abs(y)


def fun(n: int):
    return 3 * n * n - 3 * n + 2


def getval(x: int, y: int):
    f = floor(x, y)
    if f == 0:
        return 1
    s = fun(f)
    if y >= 0:
        if x == f:
            return s + y
        else:
            return s + f + f - x
    else:
        if x == -f:
            return s + f * 3 - y
        else:
            return s + f * 5 + x


N = 1000000
M = 75000
q = 2000
flag = [0 for _ in range(N + 1)]
flag[0] = flag[1] = 1
for i in range(2, N + 1):
    if flag[i] == 0:
        for j in range(i * i, N + 1, i):
            flag[j] = 1
dx = [1, 1, 0, -1, -1, 0]
dy = [0, 1, 1, -1, 0, -1]

ans = []
for x in range(M):
    for y in range(-1, 1):
        cnt = 0
        w = getval(x, y)
        for i in range(6):
            nx, ny = x + dx[i], y + dy[i]
            v = getval(nx, ny)
            if not flag[abs(w - v)]:
                cnt += 1
        if cnt == 3:
            ans.append(w)
ans.sort()
print(ans[q-1])
```
## Q129
```Python
m = 1000000

for n in range(m+1, m+100, 2):
    if n % 5 == 0:
        continue
    ph = phi(n * 9)
    if ph <= m:
        continue
    ls = []
    i = 1
    while i * i <= ph:
        if ph % i == 0:
            ls.append(i)
            if i * i != ph:
                ls.append(ph // i)
        i += 1
    ls.sort()
    mn = 1
    for k in ls:
        if quick_power(10, k, 9 * n) == 1:
            mn = k
            break
    if mn >= m:
        print(n,mn)
        break
```
## Q130
```Python
m = 20000
flag = [0 for _ in range(m + 1)]
ans,cnt=0,0

for i in range(2, m + 1):
     if flag[i] == 0:
        for j in range(i * i, m + 1, i):
            flag[j] = 1


for n in range(91, m + 1, 2):
    if n % 5 == 0 or not flag[n]:
        continue
    ph = phi(n * 9)
    ls = []
    i = 1
    while i * i <= ph:
        if ph % i == 0:
            ls.append(i)
            if i * i != ph:
                ls.append(ph // i)
        i += 1
    ls.sort()
    mn = 1
    for k in ls:
        if quick_power(10, k, 9 * n) == 1:
            mn = k
            break
    if (n - 1) % mn == 0:
        ans+=n
        cnt+=1
        if cnt >= 25:
            break
print(ans)
```
## Q131*
```Python
m = 1000000
ans = 0
for i in range(1, m):
    w = (i + 1) ** 3 - i ** 3
    if w > m:
        break
    if Miller_Rabin(w):
        ans += 1
print(ans)
```
## Q132
```Python
pr = []
N = 200000
flag = [0 for _ in range(N + 1)]
m = int(1e9)

ans = 0
cnt = 0
q = 40
for i in range(2, N + 1):

    if flag[i] == 0:
        if i >= 5:
            pr.append(i)
        for j in range(i * i, N + 1, i):
            flag[j] = 1

for p in pr:
    if quick_power(10, m, p*9) == 1:
        cnt += 1
        ans += p
        if cnt == q:
            break
print(ans)
```
## Q133
```Python
pr = []
N = 100000
flag = [0 for _ in range(N + 1)]
for i in range(2, N + 1):
    if flag[i] == 0:
        pr.append(i)
        for j in range(i * i, N + 1, i):
            flag[j] = 1

ans = 10
for x in pr:
    if x <= 5:
        continue
    ph = 6 * (x - 1)
    mn, k = -1, 1
    ls = []
    while k * k <= ph:
        if ph % k == 0:
            ls.append(k)
            if k * k != ph:
                ls.append(ph // k)
        k += 1
    ls.sort()
    for k in ls:
        if quick_power(10, k, 9 * x) == 1:
            mn = k
            break
    while mn % 5 == 0:
        mn //= 5
    while mn & 1 == 0:
        mn >>= 1
    if mn != 1:
        ans += x
print(ans)
```
## Q134
```Python
pr = []
N = 1000010
flag = [0 for _ in range(N + 1)]
for i in range(2, N + 1):
    if flag[i] == 0:
        pr.append(i)
        for j in range(i * i, N + 1, i):
            flag[j] = 1

ans = 0
for i in range(len(pr)):
    v = pr[i]
    if v <= 5:
        continue
    u = pr[i - 1]
    pw = 10 ** len(str(u))
    x = (v - u) * quick_power(pw, v - 2, v) % v
    w = pw * x + u
    ans += w
print(ans)
```
## Q135
```Python
def f(x: int, k: int):
    return (k - x) * (x - k * 5)


N = 10 ** 6
c = [0 for _ in range(N + 1)]
n = (N + 1) >> 2
for k in range(1, n + 1):
    x = 5 * k - 1
    while x >= k * 3:
        w = f(x, k)
        if w > N:
            break
        c[w] += 1
        if x != k * 3 and k * 6 - x >= k * 2 + 1:
            c[w] += 1
        x -= 1
print(c.count(10))
```
## Q136
```C++
# include <bits/stdc++.h>
# define mem(a,b) memset(a,b,sizeof(a))
using namespace std;
typedef long long ll;
const int N=5e7;
int c[N+2];
int fun(int x,int k){
    return (k-x)*(x-k*5);
}
int main(){
    int n=(N+1)>>1;
    for(int k=1;k<=n;k++){
        for(int x=5*k-1;x>=k*3;x--){
            int w=fun(x,k);
            if(w>N) break;
            c[w]+=1;
            if(x!=k*3&&k*6-x>=k*2+1) c[w]+=1;
        }
    }
    int q=1,ans=0;
    for(int i=1;i<=N;i++)
        if(c[i]==q) ++ans;
    printf("%d\n",ans);
}
```
## Q137
```Python
from math import sqrt, log2

n = 1
c = 0
q = 15
f = [1, 1]
for _ in range(q * 3):
    f.append(f[-1] + f[-2])
p = 1
while c < 15 and p < len(f):
    n = f[p] * f[p - 1]
    m = (n + 1) ** 2 + 4 * (n ** 2)
    tp = int(sqrt(m))
    if tp * tp == m:
        c += 1
        if c == q:
            print(n)
            break
    p += 1

# $\sum_{i=1}^{\infin}fib(i)x^i=\frac{x}{1-x-x^2}$
# ans=fib(q*2)*fib(q*2-1)
```
## Q138
```Python
q = 12
f = [1, 1]
for _ in range(q * 7):
    f.append(f[-1] + f[-2])
s = 0
for i in range(1, q + 1):
    s += (f[6 * i + 2] >> 1)
print(s)
```
## Q139
```Python
s = 3
m = int(1e8)
ans = 0
while s * s + s <= m:
    t = 1
    while t < s and s * s + s * t <= m:
        if gcd(s, t) == 1:
            a, b, c = s * t, (s * s - t * t) >> 1, (s * s + t * t) >> 1
            if c % (b - a) == 0:
                ans += m // (a + b + c)
        t += 2
    s += 2
print(ans)
```
## Q140
```Python
q = 30
ls = [(0, -1), (0, 1), (-3, -2), (-3, 2), (-4, -5), (-4, 5)]
st = set()
for tp in ls:
    k, b = tp
    for i in range(q):
        nk, nb = -9 * k + -4 * b + -14, -20 * k + -9 * b + -28
        k, b = nk, nb
        if k > 0:
            st.add(k)
ls = list(st)
ls.sort()
print(sum(ls[:q]))
```
## Q141
```Python
from math import sqrt, log2

lm = int(1e12)
N = int(sqrt(lm))
st, isq = set(), set()
for i in range(1, N + 1):
    isq.add(i * i)

for a in range(2, int(lm ** (1 / 3) + 1)):
    a3 = a ** 3
    b = 1
    while b < a and b * (a3 + b) < lm:
        if gcd(a, b) == 1:
            c = 1
            while True:
                w = b * c * (b + a3 * c)
                if w >= lm:
                    break
                if w in isq:
                    st.add(w)
                c += 1
        b += 1
# d=a/b*r,q=(a/b)^2*r
# a>b>=1,gcd(a,b)==1
# b^2|r,c>=1,r=c*b^2
# d=a*b*c,q=a^2*c
# n=dq+r=a^3*b*c^2<lm
print(sum(st))
```
## Q142
```Python
from math import sqrt, log2


def isq(n: int):
    tp = sqrt(n)
    return abs(tp - int(tp)) < 1e-7


s = 3
m = int(1e6)
mp, mq = {}, {}
while s * s + s <= m:
    t = 1
    while t < s and s * s + s * t <= m:
        if gcd(s, t) == 1:
            a, b, c = s * t, (s * s - t * t) >> 1, (s * s + t * t) >> 1
            if c not in mp.keys():
                mp[c] = []
            mp[c].append(b)
        t += 2
    s += 2

for x, v in mp.items():
    i = 1
    while x * i * i <= m:
        if x * i * i not in mq.keys():
            mq[x * i * i] = []
        mq[x * i * i] += [w * i * i for w in v]
        i += 2

for x, v in mq.items():
    if len(v) >= 2:
        v.sort()
        for i in range(len(v)):
            for j in range(i + 1, len(v)):
                if isq(v[j] + v[i]) and isq(v[j] - v[i]):
                    print(v[i] + v[j] + x)
                    a, b, c = v[i], v[j], x
                    exit(0)
```
## Q143
```Python
from math import sqrt, log2

lm = 120000
# http://www.geocities.ws/fredlb37/node9.html
lmsq = int(sqrt(lm) + 1)
g = [[] for _ in range(lm + 1)]
st, st2 = set(), set()
for u in range(1, lmsq):
    for v in range(1, u):
        if (u - v) % 3 == 0 or gcd(u, v) != 1:
            continue
        p, q = 2 * u * v + v * v, u * u - v * v
        if p > q:
            p, q = q, p
        k = 1
        while k * (p + q) < lm:
            st.add((k * p, k * q))
            g[k * p].append(k * q)
            k += 1
ans = 0
for x in range(1, lm + 1):
    if len(g[x]) >= 2:
        g[x].sort()
        gl = len(g[x])
        for i in range(gl):
            for j in range(i + 1, gl):
                s = g[x][i] + g[x][j] + x
                if s >= lm:
                    break
                if (g[x][i], g[x][j]) in st:
                    st2.add(s)
print(sum(st2))
```
## Q144
```Python
import sympy

eps = sympy.core.numbers.Float(1e-10)


def same(p1: tuple, p2: tuple):
    return abs(p1[0] - p2[0]) < eps and abs(p1[1] - p2[1]) < eps


x = sympy.Symbol('x')
y = sympy.Symbol('y')
cnt = 1
f1 = 4 * x * x + y * y - 100
xa, ya = sympy.core.numbers.Float(0.0), sympy.core.numbers.Float(10.1)
xb, yb = sympy.core.numbers.Float(1.4), sympy.core.numbers.Float(-9.6)

while True:
    k1 = (ya - yb) / (xa - xb)
    b1 = ya - k1 * xa
    xa, ya = xb, yb
    k2 = ya / (4 * xa)
    b2 = ya - k2 * xa
    tp = (2 * k1 * k2 + 2) / (k2 * k2 + 1)
    k3 = (k1 - tp * k2) / (1 - tp)
    b3 = ya - k3 * xa
    f2 = k3 * x + b3 - y
    ls = sympy.solve([f1, f2], [x, y])
    if same((xa, ya), ls[0]):
        xb, yb = ls[1]
    else:
        xb, yb = ls[0]
    cnt += 1
    if -0.01 <= xb <= 0.01 and yb > 0:
        break
print(cnt-1)
```
## Q145
```C++
# include <bits/stdc++.h>
# define mem(a,b) memset(a,b,sizeof(a))
using namespace std;
typedef long long ll;
const int N=54;
int ans=0,a[N],n,m=(n+1)/2;
bool ok(){
    int x=0;
    for(int i=1;i<=n;i++)
        x=x*10+a[i]+a[n-i+1];
    for(;x;x/=10)
        if((x&1)==0) return 0;
    return 1;
}
void dfs(int f,int c){
    if(f==n/2+1){
        if(n&1){
            if(a[1]>a[n]) return;
            for(a[m]=0;a[m]<=9;a[m]++)
                if(ok()) ++ans;
        }
        else if(ok()) ++ans;
        return;
    }
    for(a[f]=(f==1);a[f]<=9;a[f]++)
        for(a[n-f+1]=(f==1);a[n-f+1]<=9;a[n-f+1]++)
            if((a[f]+a[n-f+1]+c)&1) dfs(f+1,(a[f]+a[n-f+1]+c)/10);
}
int main(){
    for(n=2;n<=9;n++)
        dfs(1,0);
    printf("%d\n",ans);
}
```
## Q146
```Python
M = 100000
pr = []
flag = [0 for _ in range(M + 1)]
for i in range(2, M + 1):
    if flag[i] == 0:
        pr.append(i)
        for j in range(i * i, M + 1, i):
            flag[j] = 1
s = [1, 3, 7, 9, 13, 27]
N = 150000000
n = d = 10
ans = 0
candidate = [10]
while n <= N:
    if n % 3 and (n + 2) % 7 >= 5:
        flag = True
        for q in pr:
            for x in s:
                if (n * n + x) % q == 0:
                    flag = False
                    break
            if not flag:
                break
        if flag:
            candidate.append(n)
    n += d
# q is prime
# n=qx+r,n^2+s=q^2*x+2qrx+(r^2+s)
# if q|n^2+s,then q|r^2+s while s in [1,3,7,9,13,27]
for n in candidate:
    flag = True
    for x in s:
        if not Miller_Rabin(n * n + x):
            flag = False
            break
    if flag:
        cnt = 0
        for i in range(1, 28):
            if Miller_Rabin(n * n + i):
                cnt += 1
        if cnt != len(s):
            flag = False
    if flag:
        ans += n
print(ans)
```
## Q147
```C++
# include <bits/stdc++.h>
# define mem(a,b) memset(a,b,sizeof(a))
using namespace std;
typedef long long ll;
const int N=54;
int solve(int n,int m){
    int o=max(n,m)*2;
    int ans=n*(n+1)/2*m*(m+1)/2;
    n<<=1;m<<=1;
    for(int i=0;i<=n;i++)
    for(int j=0;j<=m;j++){
        if((i+j)&1) continue;
        for(int d=1;d<=o;d++){
            int x=i-d,y=j+d;
            if(x<0||y>m) break;
            int l=0,r=o;
            while(l<r){
                int mid=(l+r+1)>>1;
                int xa=i+mid,ya=j+mid,xb=x+mid,yb=y+mid;
                if(max(xa,xb)<=n&&max(ya,yb)<=m) l=mid;
                else r=mid-1;
            }
            ans+=l;
        }
    }
    return ans;
}
int main(){
    int n=47,m=43;
    ll ans=0;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            ans+=solve(i,j);
    printf("%lld\n",ans);
}
```
## Q148
```Python
def fun(n: int):
    return n * (n + 1) // 2


x, m = int(1e9), 7
pw = [1]
ls = []
while x:
    ls.append(x % m)
    x //= m

ans, mul = 0, 1
for k in range(len(ls) - 1, -1, -1):
    ans += mul * (fun(m) ** k) * fun(ls[k])
    mul *= (ls[k]+1)
print(ans)
```
## Q149
```C++
# include <bits/stdc++.h>
# define mem(a,b) memset(a,b,sizeof(a))
using namespace std;
typedef long long ll;
const int N=2000,m=500000;
int a[N+4][N+4],s[N*N+4],INF=0x3f3f3f3f;
int ans=-INF;
vector<int>v;
void solve(){
    int s=0,mn=0;
    for(int x:v){
        s+=x;
        ans=max(ans,s-mn);
        mn=min(mn,s);
    }
}
int main(){
    for(int k=1;k<=N*N;k++){
        if(k<=55) s[k]=(300007ll*k*k*k-200003*k+100003)%(m*2)-m;
        else s[k]=(s[k-24]+s[k-55]+m*2)%(m*2)-m;
    }
    for(int i=1,p=0;i<=N;i++)
        for(int j=1;j<=N;j++)
            a[i][j]=s[++p];
    for(int i=1;i<=N;i++){
        v.clear();
        for(int j=1;j<=N;j++)
            v.push_back(a[i][j]);
        solve();
        v.clear();
        for(int j=1;j<=N;j++)
            v.push_back(a[j][i]);
        solve();
    }
    for(int _=0;_<2;_++){
        for(int i=1;i<=N;i++){
            v.clear();
            for(int j=0;j<N;j++){
                if(i+j>N) break;
                v.push_back(a[i+j][1+j]);
            }
            solve();
            v.clear();
            for(int j=0;j<N;j++){
                if(i+j>N) break;
                v.push_back(a[1+j][i+j]);
            }
            solve();
        }
        for(int l=1,r=N;l<r;++l,--r)
            for(int j=1;j<=N;j++)
                swap(a[l][j],a[r][j]);
    }
    printf("%d\n",ans);
}

```
## Q150
```C++
# include <bits/stdc++.h>
# define mem(a,b) memset(a,b,sizeof(a))
using namespace std;
typedef long long ll;
const int N=1000;
int a[N+4][N+4];
ll s[N+4][N+4],ans=0;
int main(){
    ll b=1<<19,t=0;
    for(int i=1;i<=N;i++)
    for(int j=1;j<=i;j++){
        t=(615949ll*t+797807)%(b*2);
        a[i][j]=t-b;
        s[i][j]=s[i-1][j]+a[i][j];
    }
    for(int i=1;i<=N;i++){
        for(int j=1;j<=i;j++){
            ll sum=0;
            for(int k=0;k<j;k++){
                sum+=s[i][j-k]-s[i-k-1][j-k];
                ans=min(ans,sum);
            }
        }
    }
    printf("%lld\n",ans);
}
```
## Q151
```Python
mp = {(0, 0, 0, 0, 0): 0}


def dfs(tp: tuple):
    if tp in mp.keys():
        return mp[tp]
    s = sum(tp)
    ans = (s == 1)
    for i in range(5):
        if tp[i] == 0:
            continue
        ls = list(tp)
        ls[i] -= 1
        for j in range(i + 1, 5):
            ls[j] += 1
        ans += dfs(tuple(ls)) * tp[i] / s
    mp[tp] = ans
    return ans


print("{:.6f}".format(dfs((1, 0, 0, 0, 0))-2))
```
## Q152
```python
from fractions import Fraction

pr = []
N = 80
ans = 0
flag = [0 for _ in range(N + 1)]
for i in range(2, N + 1):
    if flag[i] == 0:
        pr.append(i)
        for j in range(i * i, N + 1, i):
            flag[j] = 1
st = set(i for i in range(2, N + 1))
for x in pr:
    if x <= 3:
        continue
    ls, flag = [], []
    for i in range(1, 20):
        if i * x >= N:
            break
        t = i * x
        if t in st:
            ls.append(Fraction(1, t * t))
            flag.append(0)
    l = len(ls)
    for b in range(1, 1 << l):
        s = Fraction(0)
        for i in range(l):
            if b >> i & 1:
                s += ls[i]
        if s.denominator % x:
            for i in range(l):
                if b >> i & 1:
                    flag[i] = 1
    for i in range(l):
        if not flag[i]:
            st.remove(int(ls[i].denominator ** 0.5))
# a/b+1/x^2=(ax^2+b)/(bx^2) 若gcd(x^2,b)=1，那么x需要被约掉时，满足x|b。
# 因此，对于质数p，若存在k，$1/(k^2p^2)$与所有1/(n^2p^2)的组合相加后不能约去分母p，那么整数kp可以排除。
ls = list(st)
n = len(ls)
half = Fraction(1, 2)
l, r = ls[:n // 2], ls[n // 2:]
print(l, r)
mp = {}
for i in range(1 << len(l)):
    s = Fraction(0)
    for j in range(len(l)):
        if i >> j & 1:
            s += Fraction(1, l[j] * l[j])
    if s <= half:
        if s not in mp.keys():
            mp[s] = 0
        mp[s] += 1
for i in range(1 << len(r)):
    s = Fraction(0)
    for j in range(len(r)):
        if i >> j & 1:
            s += Fraction(1, r[j] * r[j])
    t = half - s
    if t in mp.keys():
        ans += mp[t]
print(ans)
```
## Q153
```C++
# include <bits/stdc++.h>
# define mem(a,b) memset(a,b,sizeof(a))
using namespace std;
typedef long long ll;
ll gcd(ll a,ll b){
    return b?gcd(b,a%b):a;
}
ll fun(ll l,ll r,ll d){
    return (d+r)*(r/d)/2-(d+l)*(l/d)/2;
}
ll f(ll n){
    ll ans=0;
    for(ll i=1;i<=n;){
        ll q=n/i;
        ll l=n/(q+1),r=n/q;
        ans+=fun(l,r,1)*q;
        i+=r-l;
    }
    return ans;
}
ll g(ll n){
    ll ans=0;
    for(ll i=1;i+i<=n;){
        ll q=n/(i+i);
        ll l=n/(q+1)/2*2,r=n/q/2*2;
        ans+=fun(l,r,2)*q;
        i+=(r-l)/2;
    }
    for(ll a=1;a*a<=n;a++){
        for(ll b=a+1;b<=n;b++){
            ll c=a*a+b*b;
            if(c>n) break;
            if(gcd(a,b)!=1) continue;
            for(ll i=1;c*i<=n;){
                ll q=n/(c*i);
                ll l=n/(q+1)/c*c,r=n/q/c*c;
                ans+=fun(l/c,r/c,1)*q*2*(a+b);
                i+=(r-l)/c;
            }
        }
    }
    return ans;
}
int main(){
    ll n=1e8;
    printf("%lld\n",f(n)+g(n));
}
```
## Q154
```C++
# include <bits/stdc++.h>
# define mem(a,b) memset(a,b,sizeof(a))
using namespace std;
typedef long long ll;
const int N=200000;
int f2[N+4],f5[N+4];
int c2,c5;
void solve(int w){
    c2=c5=0;
    for(;w%2==0;w/=2,++c2);
    for(;w%5==0;w/=5,++c5);
}
int main(){
    for(int i=2;i<=N;i++){
        solve(i);
        f2[i]=f2[i-1]+c2;
        f5[i]=f5[i-1]+c5;
    }
    c2=c5=12;//mod=1e12;
    ll ans=0;
    for(int i=0;i<=N;i++){
        int cnt2=f2[N]-f2[i]-f2[N-i],cnt5=f5[N]-f5[i]-f5[N-i];
        for(int j=0;j<=((N-i)>>1);j++){
            int ncnt2=f2[N-i]-f2[j]-f2[N-i-j],ncnt5=f5[N-i]-f5[j]-f5[N-i-j];
            if(ncnt2+cnt2>=c2&&ncnt5+cnt5>=c5){
                ++ans;
                if(j+j!=N-i) ++ans;
            }
        }
    }
    printf("%lld\n",ans);
}
```
## Q155
```Python
ls = [1, 3, 7, 15, 35, 77, 179, 429, 1039, 2525, 6235, 15463, 38513, 96231, 241519, 607339, 1529533, 3857447, 9743247,
      24634043, 62335495, 157885967, 400211085, 1015080877, 2576308943]
N = 18
print(ls[N - 1])
```
## Q156
```Python
def count(n: int, x: int):
    ans = 0
    i = 1
    while n // i:
        j = n // i
        high = j // 10
        if x == 0:
            if high:
                high -= 1
            else:
                break
        ans += high * i
        tp = j % 10
        if tp > x:
            ans += i
        elif tp == x:
            ans += n - j * i + 1
        i *= 10
    return ans

N = 14
pw = [0, 1]
for i in range(N):
    pw.append(pw[-1] * 10)
ans = 0
for j in range(1, 9 + 1):
    i = q = 1
    while i <= pw[-2]:
        t = count(i, j)
        if t == i:
            ans += i
            i += 1
        else:
            v = abs(i - t)
            i += (v + q - 1) // q
            if i >= pw[q + 1]:
                q += 1
                i = pw[q]

print(ans)
```
## Q157
```Python
from fractions import Fraction


def fun(x: int):
    c2 = c5 = 0
    while x % 2 == 0:
        x >>= 1
        c2 += 1
    while x % 5 == 0:
        x //= 5
        c5 += 1
    return c2, c5


def get_divisor(n: int):
    ls = []
    i = 1
    while i * i <= n:
        if n % i == 0:
            ls.append(i)
            if i * i != n:
                ls.append(n // i)
        i += 1
    return ls


N = 9
ls = []
lst = [set() for _ in range(N + 1)]
for i in range(N + 4):
    for j in range(N + 4):
        ls.append((1 << i) * (5 ** j))
ls.sort()
ans = 0
for i in range(len(ls)):
    for j in range(i, len(ls)):
        f = Fraction(1, ls[i]) + Fraction(1, ls[j])
        k = f.denominator
        c2, c5 = fun(k)
        val = max(c2, c5)
        if val <= N:
            w = f.numerator
            times = (10 ** max(c2, c5)) // k
            divisor_list = get_divisor(w * times)
        for x in divisor_list:
            l, r = ls[i] * x, ls[j] * x
            x, y = l, r
            for m in range(val, N + 1):
                lst[m].add((l, r))
                lst[m].add((x, y))
                l *= 10
                r *= 10

ans=sum(len(st) for st in lst[1:])
print(ans)
```
## Q158
```Python
N = 27
C = [[0 for x in range(N)] for y in range(N)]
for i in range(N):
    C[i][0] = C[i][i] = 1
    for j in range(i):
        C[i][j] = C[i - 1][j - 1] + C[i - 1][j]
a = [0 for i in range(N)]
ans = 0
for i in range(1, N):
    a[i] = a[i - 1] * 2 + i - 1
    ans = max(ans, a[i] * C[N - 1][i])
print(ans)
```
## Q159
```C++
# include <bits/stdc++.h>
using namespace std;
const int N=1e6;
vector<int>g[N+4];
int f[N+4];
int fun(int x){
    return x%9?x%9:9;
}
int main(){
    for(int i=2;i<N;i++){
        for(int j=i+i;j<=N;j+=i)
            g[j].push_back(i);
    }
    int ans=0;
    for(int i=2;i<N;i++){
        f[i]=fun(i);
        for(int x:g[i])
            f[i]=max(f[i],f[x]+f[i/x]);
        ans+=f[i];
    }
    printf("%d\n",ans);
}
```
## Q160
```Python
def count0(n: int):
    ans = 0
    while n:
        ans += n // 5
        n //= 5
    return ans


A5 = [1]
N = 10 ** 120
Q = 5
cnt0 = count0(N)
mx = 5 ** Q


def getA(n: int):
    if n < mx:
        return A5[n]
    else:
        c = n // 5
        n %= mx
        if c & 1:
            return mx - A5[n]
        else:
            return A5[n]


for i in range(1, mx):
    if i % 5 == 0:
        A5.append(A5[-1])
    else:
        A5.append(A5[-1] * i % mx)

inv2 = (mx + 1) >> 1
ans = quick_power(inv2, cnt0, mx)
tp = N
while tp:
    ans = ans * getA(tp) % mx
    tp //= 5
for i in range(1 << Q):
    if (ans + i * mx) % (1 << Q) == 0:
        ans += i * mx
        break
print(ans)

# 计算n!/10^m % 10^Q
# 令n=5q+r，A(n)=\prod_{x<n,5 \nmid x} x
# 则 n!=5^q*q!*A(n) % 5^Q
# 又X^2 \equ 1 (mod 5) 只有解+1和-1，故A(n)=(-1)^(n/5)A(n%(5^5))%(5^5)
# 对q进行递归变换，因此最终 n! \equ 5^m*A(n)A(n/5)A(n/25)... (mod 5^5)
# 将n!/2^m \equ 0 (mod 2^5)与之结合，用中国剩余定理，即可得解。
```
## Q161
```Python
n, m = 9, 12
triomino_ls = [
    [(0, 0), (1, 0), (0, 1)],
    [(0, 0), (1, 0), (1, 1)],
    [(0, 0), (0, 1), (1, 1)],
    [(0, 0), (1, 0), (1, -1)],
    [(0, 0), (0, 1), (0, 2)],
    [(0, 0), (1, 0), (2, 0)],
]
if m > n:
    n, m = m, n


def get_empty(grid: tuple):
    for i in range(n):
        if grid[i] != (1 << m) - 1:
            for j in range(m):
                if (grid[i] >> j & 1) == 0:
                    return i, j
    return None


def place_triomino(grid: tuple, x: int, y: int, id: int):
    tp = list(grid)
    for dx, dy in triomino_ls[id]:
        nx, ny = x + dx, y + dy
        if nx < 0 or ny < 0 or nx >= n or ny >= m or tp[nx] >> ny & 1:
            return None
        tp[nx] |= 1 << ny
    return tuple(tp)


cnt = m * n // 3
st = tuple(0 for i in range(n))
ed = tuple((1 << m) - 1 for i in range(n))
f = [{} for i in range(cnt + 1)]
f[0][st] = 1
for i in range(cnt):
    for grid, val in f[i].items():
        x, y = get_empty(grid)
        for k in range(6):
            next = place_triomino(grid, x, y, k)
            if next is None:
                continue
            if next not in f[i + 1].keys():
                f[i + 1][next] = 0
            f[i + 1][next] += val

print(f[cnt][ed])
```
## Q162
```Python
N = 16
C = [[0 for x in range(N)] for y in range(N)]
for i in range(N):
    C[i][0] = C[i][i] = 1
    for j in range(i):
        C[i][j] = C[i - 1][j - 1] + C[i - 1][j]
ans = 0
for l in range(3, N + 1):
    for d in range(1, 16):
        for i in range(1, l):
            for j in range(0, l - i):
                for k in range(0, l - i - j):
                    if (j == 0 and d != 1) or (k == 0 and d != 2):
                        continue
                    ans += C[l - 1][i] * C[l - 1 - i][j] * C[l - 1 - i - j][k] * (13 ** (l - 1 - i - j - k))
print('{:X}'.format(ans))
```
## Q163
```C++
# include <bits/stdc++.h>
# define X first
# define Y second
# define pi pair<int,int>
# define pd pair<double,double>
using namespace std;
typedef long long ll;
map<pi,int>mp;
int b[4004][4004];
int fa[6][4004],m=0;
int get(int x,int y){
    pi pa(x,y);
    if(mp.count(pa)) return mp[pa];
    mp[pa]=++m;
    for(int j=0;j<6;j++)
        fa[j][m]=m;
    return m;
}
int find(int *fa,int x){
    return x==fa[x]?x:fa[x]=find(fa,fa[x]);
}
void merge(int id,int x,int y){
    fa[id][x]=find(fa[id],y);
}
int param[9][7]={
    0,2,6,3,3,4,0,
    1,1,3,2,2,4,0,
    2,0,0,2,0,4,0,
    3,0,0,2,2,3,3,
    4,0,0,1,3,2,6,
    5,2,0,2,2,2,6,
    1,2,6,4,4,5,3,
    3,3,3,4,4,6,6,
    5,4,0,4,4,4,6
};
int main(){
    int n=36;
    for(int i=0;i<n;i++)
        for(int j=0;j<n-i;j++){
            int x=j*4+i*2,y=6*i;
            for(int k=0;k<9;k++){
                if(j==n-i-1&&k==6) break;
                merge(param[k][0],get(x+param[k][1],y+param[k][2]),get(x+param[k][3],y+param[k][4]));
                merge(param[k][0],get(x+param[k][3],y+param[k][4]),get(x+param[k][5],y+param[k][6]));
            }
        }
    for(int i=1;i<=m;i++)
    for(int j=i+1;j<=m;j++){
        for(int k=0;k<6;k++)
            if(find(fa[k],i)==find(fa[k],j)){
                b[i][j]=b[j][i]=k+1;
                break;
            }
    }
    int ans=0;
    for(int i=1;i<=m;i++){
        for(int j=i+1;j<=m;j++){
            if(!b[i][j]) continue;
            for(int k=j+1;k<=m;k++)
                if(b[j][k]&&b[i][k]&&b[i][j]!=b[i][k]) ++ans;
        }
    }
    printf("%d\n",ans);
    //printf("%d\n",(1678*n*n*n+3117*n*n+88*n-n%2*345-n%3*320-n%4*90-(n*n*n-n*n+n)%5*288)/240);
}
```
## Q164
```C++
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int n=20;
ll f[n+2][10][10][10];
int main(){
    for(int i=1;i<=9;i++)
    for(int j=0;j<=9-i;j++)
    for(int k=0;k<=9-i-j;k++)
        f[3][i][j][k]=1;
    for(int m=3;m<n;m++){
        for(int i=0;i<=9;i++)
        for(int j=0;j<=9-i;j++){
            ll s=0;
            for(int k=0;k<=9-i-j;k++)
                s+=f[m][k][i][j];
            for(int k=0;k<=9-i-j;k++)
                f[m+1][i][j][k]=s;
        }
    }
    ll s=0;
    for(int i=0;i<=9;i++)
    for(int j=0;j<=9-i;j++)
    for(int k=0;k<=9-i-j;k++)
        s+=f[n][i][j][k];
    printf("%lld\n",s);
}
```
## Q165
```Python
from fractions import Fraction


class L:
    def __init__(self, xa: int, ya: int, xb: int, yb: int):
        self.xa, self.ya, self.xb, self.yb = xa, ya, xb, yb
        self.a = ya - yb
        self.b = xb - xa
        self.c = xa * (ya - yb) - ya * (xa - xb)


def cross(va: tuple, vb: tuple):
    return va[0] * vb[1] - va[1] * vb[0]


def ok(la: L, lb: L):
    vb1 = (lb.xa - la.xa, lb.ya - la.ya)
    vb2 = (lb.xb - la.xa, lb.yb - la.ya)
    va = (la.xb - la.xa, la.yb - la.ya)
    if cross(va, vb1) * cross(va, vb2) >= 0:
        return False
    vb1 = (la.xa - lb.xa, la.ya - lb.ya)
    vb2 = (la.xb - lb.xa, la.yb - lb.ya)
    va = (lb.xb - lb.xa, lb.yb - lb.ya)
    if cross(va, vb1) * cross(va, vb2) >= 0:
        return False
    return True


def solve(la: L, lb: L):
    fm = la.a * lb.b - la.b * lb.a
    if fm == 0:
        return None
    fx = la.c * lb.b - la.b * lb.c
    fy = la.a * lb.c - la.c * lb.a
    return Fraction(fx, fm), Fraction(fy, fm)


s, t = [290797], [0]
n = 5000
for i in range(n * 4):
    s.append(s[-1] * s[-1] % 50515093)
    t.append(s[-1] % 500)
line = []
for i in range(4, n * 4 + 1, 4):
    line.append(L(t[i - 3], t[i - 2], t[i - 1], t[i]))
ans = 0
point_set = set()
for i in range(n):
    for j in range(i + 1, n):
        if ok(line[i], line[j]):
            point_set.add(solve(line[i], line[j]))
print(len(point_set))
```
## Q166
```Python
mp = {}
ans = 0
for i in range(10):
    for j in range(10):
        for k in range(10):
            for l in range(10):
                w = i + j + k + l
                if w not in mp.keys():
                    mp[w] = []
                mp[w].append((i, j, k, l))
for s, vec in mp.items():
    mq = {}
    for u in vec:
        for v in vec:
            t = (u[0] + v[0], u[1] + v[1], u[2] + v[2], u[3] + v[3], u[0] + v[1], u[3] + v[2])
            if t not in mq:
                mq[t] = 0
            mq[t] += 1
    for u in vec:
        for v in vec:
            t = (s - u[0] - v[0], s - u[1] - v[1], s - u[2] - v[2], s - u[3] - v[3], s - u[2] - v[3], s - u[1] - v[0])
            if t in mq:
                ans += mq[t]
print(ans)
```
## Q167
```C++
# include <bits/stdc++.h>
# define X first
# define Y second
using namespace std;
typedef long long ll;
int main(){
    ll n=1e11;
    ll sum=0;
    map<int,int>mp;
    for(int i=2;i<=10;i++){
        int even=0,even_pos=0;
        mp.clear();
        vector<int>U;U.push_back(2*i+1);
        do{
            ++mp[U.back()+2];
            if(even) ++mp[U.back()+even];
            else{
                for(int j=0;j+1<U.size();j++)
                    mp[U.back()+U[j]]++;
            }
            if(U.back()%2==0){
                even=U.back();even_pos=U.size()-1;
                for(auto & it : mp)
                    if(it.X%2==0) ++it.Y;
            }
            for(auto it=mp.begin();it!=mp.end();it++)
                if(it->Y==1){
                    U.push_back(it->X);
                    mp.erase(mp.begin(),++it);
                    break;
                }
        }while(U.back()-U[U.size()-2]!=even);
        int period=U.size()-2,diff=U.back()-U.front();
        int s=(n-3)%period;
        if(s>=even_pos) ++s;
        ll ans=(n-3)/period*diff+U[s];
        sum+=ans;
    }
    printf("%lld\n",sum);
}
/*
Schmerl和Spiegel在1994年证明：
满足n>=2的Ulam序列U(2,2n+1)有且只有两个偶数，其中一个是2，设另外一个为even.
设U'(2,2n+1)为U(2,2n+1)去掉两个偶数项后剩下的数，那么U'(2n+1)的差分序列是一个循环数组，其中最小的循环节中有且仅有一个even，并且这个even在整个循环节中的最后一个数、
*/
```
## Q168
```Python
def div(x: int, y: int):
    s = ""
    vis = [0 for _ in range(y)]
    while True:
        x *= 10
        if vis[x % y]:
            break
        vis[x % y] = 1
        s += str(x // y)
        x %= y
    return s


def ok(s: str):
    x = int(s)
    y = int(s[-1] + s[:-1])
    return y % x == 0


N = 100
st = set()
for i in range(2, N + 1):
    st.add(10 ** i - 1)
for k in range(1, 9 + 1):
    for i in range(k, 9 + 1):
        s = div(i, 10 * k - 1)
        t = s
        while len(t) <= N:
            if ok(t) and len(t) > 1:
                st.add(int(t))
            t += s

print(sum(st) % (10 ** 5))
```
## Q169
```Python
mp = {}


def dfs(n: int):
    if n <= 1:
        return 1
    if n in mp.keys():
        return mp[n]
    m = n >> 1
    if n & 1:
        mp[n] = dfs(m)
    else:
        mp[n] = dfs(m) + dfs(m - 1)
    return mp[n]


N = 10 ** 25
print(dfs(N))
```
## Q170
```C++
# include <bits/stdc++.h>
using namespace std;
const int N=100004;
int a[14];
vector<int>d[N];
int gcd(int a,int b) {
    return b ? gcd(b, a % b) : a;
}
int main(){
    for(int i=3;i<N;i+=3){
        for(int j=i;j<N;j+=i)
            d[j].push_back(i);
    }
    string tp="0123456789";
    for(int i=0;i<10;i++)
        a[i]=9-i;
    bool ok=0;
    do{
        for(int p=1;p<10&&!ok;p++){
            if(a[p]==0) continue;
            int l=0,r=0;
            for(int i=0;i<10;i++) {
                if (i < p) l = l * 10 + a[i];
                else r = r * 10 + a[i];
            }
            for(int x:d[gcd(l,r)]) {
                string s = to_string(x) + to_string(l / x) + to_string(r / x);
                sort(s.begin(), s.end());
                if (s == tp) {
                    ok = 1;
                    break;
                }
            }
        }
    } while (!ok&&prev_permutation(a,a+10));
    for(int i=0;i<10;i++)
        printf("%d",a[i]);
}
```
## Q171
```Python
n = 20
fc = [[0 for _ in range(n * 9 * 9 + 1)] for _ in range(n + 1)]
fs = [[0 for _ in range(n * 9 * 9 + 1)] for _ in range(n + 1)]
fc[0][0] = 1
squ = set()
for i in range(1, int(9 * sqrt(n)) + 2):
    squ.add(i * i)
for i in range(n):
    for j in range(n * 9 * 9 + 1):
        if fc[i][j] == 0:
            continue
        for k in range(10):
            fc[i + 1][j + k * k] += fc[i][j]
            fs[i + 1][j + k * k] += fs[i][j] + k * (10 ** i) * fc[i][j]
ans = 0
for i in range(1, n * 9 * 9 + 1):
    if i in squ:
        ans += fs[n][i]
print(ans)
```
## Q172
```Python
from Q5_2 import *
from math import sqrt

N = 18
M = 4
fac = [1]
for i in range(1, N + 1):
    fac.append(fac[-1] * i)


def getval(a: tuple):
    s, mul = 0, 1
    for x in a:
        s += x
        mul *= fac[x]
    return fac[s] // mul


ans = 0
for i in range(M, M ** 10):
    ls = []
    tmp = i
    for i in range(10):
        ls.append(tmp % M)
        tmp //= M
    if sum(ls) != N:
        continue
    for i in range(1, 10):
        if ls[i] > 0:
            ls[i] -= 1
            ans += getval(tuple(ls))
            ls[i] += 1
print(ans)
```
## Q173
```Python
N = 10 ** 6
ans = 0
i = 1
while 4 * (i - 1) <= N:
    j = i - 2
    while j > 0 and i * i - j * j <= N:
        ans += 1
        j -= 2
    i += 1
print(ans)
```
## Q174
```Python
N = 10 ** 6
mp = {}
i = 1
while 4 * (i - 1) <= N:
    j = i - 2
    cnt = 0
    while j > 0 and i * i - j * j <= N:
        w = i * i - j * j
        if w not in mp.keys():
            mp[w] = 0
        mp[w] += 1
        j -= 2
    i += 1
ans = 0
for x in mp.values():
    if 1 <= x <= 10:
        ans += 1
print(ans)
```
## Q175
```Python
a, b = 123456789, 987654321
ls = []
while a and b:
    if b >= a:
        ls.append((b // a, 1))
        b %= a
    else:
        ls.append((a // b, 0))
        a %= b
if ls[-1][1] == 0:
    x, y = ls[-1]
    ls.pop()
    ls.append((x - 1, 0))
    ls.append((1, 1))
ls = ls[::-1]
print(",".join([str(v[0]) for v in ls]))
```
## Q176
```Python
pr = [3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79]
ans = 10 ** 100
Q = 47547


def dfs(val: int, f: int, lim: int, w: int):
    global ans
    if val > ans or (w - 1) // 2 > Q:
        return
    if (w - 1) // 2 == Q:
        ans = val
        return
    for i in range(1, lim):
        val *= pr[f]
        dfs(val, f + 1, i, w * (i * 2 + 1))


for k in range(100):
    if (1 << k) >= ans:
        break
    if k == 0:
        w = 1
    else:
        w = 2 * k - 1
    dfs(1 << k, 0, 66, w)
print(ans)
```
## Q177
```C++
#include <bits/stdc++.h>
# define pi pair<int,int>
# define X first
# define Y second
using namespace std;
double sina[184],cosa[184];
double eps=1e-9;
double Pi=acos(-1.0);
bool is_integer(double v) {
    return abs(v - round(v)) <= eps;
}
int ans=0;
set<vector<pi>>st;
vector<pi> getmin(vector<pi>v){
    vector<pi>ans=v;
    for(int p=1;p<4;p++){
        vector<pi>tp;
        for(int i=p;i<4;i++) tp.push_back(v[i]);
        for(int i=0;i<p;i++) tp.push_back(v[i]);
        ans=min(ans,tp);
    }
    return ans;
}
void insert(vector<pi> a){
    a=getmin(a);
    if(!st.count(a)){
        ++ans;
        st.insert(a);
        reverse(a.begin(),a.end());
        for(pi&pa:a)
            swap(pa.X,pa.Y);
        a=getmin(a);
        st.insert(a);
    }
}
int main(){
    for(int i=1;i<=180;i++){
        sina[i]=sin(Pi*i/180);
        cosa[i]=cos(Pi*i/180);
    }
    for(int BAD=1;BAD<180;BAD++){
        for(int ABD=1;ABD<=180-BAD-ABD;ABD++){
            int ADB=180-BAD-ABD;
            for(int CDB=1;CDB<180-ADB;CDB++){
                for(int CBD=1;CBD<min(180-ABD,180-CDB);CBD++) {
                    int BCD = 180 - CDB - CBD;
                    double BD = 1;
                    double AD=BD/sina[BAD]*sina[ABD];
                    double CD=BD/sina[BCD]*sina[CBD];
                    double AC= sqrt(AD*AD+CD*CD-2.0*AD*CD*cosa[ADB+CDB]);
                    double DAC= asin(sina[ADB+CDB]/AC*CD)/Pi*180;
                    if(!is_integer(DAC)) continue;
                    DAC=round(DAC);
                    if(AC*AC+AD*AD<CD*CD) DAC=180-DAC;
                    int DCA=180-(ADB+CDB+DAC);
                    insert({pi(BAD-DAC,DAC),pi(ADB,CDB),pi(DCA,BCD-DCA),pi(CBD,ABD)});
                }
            }
        }
    }
    printf("%d\n",ans);
}
```
## Q178
```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=40;
ll f[N+1][10][1<<10];
int main() {
    for (int j = 1; j < 10; j++)
        f[1][j][1 << j] = 1;
    for (int i = 1; i < N; i++)
        for (int j = 0; j < 10; j++)
            for (int s = 0; s < (1 << 10); s++) {
                if (f[i][j][s] == 0) continue;
                if (j > 0) f[i + 1][j - 1][s | 1 << (j - 1)] += f[i][j][s];
                if (j < 9)f[i + 1][j + 1][s | 1 << (j + 1)] += f[i][j][s];
            }
    ll ans = 0;
    for (int i = 1; i <= N; i++)
        for (int j = 0; j < 10; j++)
            ans += f[i][j][1023];
    printf("%lld\n", ans);
}
```
## Q179
```C++
#include <bits/stdc++.h>
using namespace std;
const int N=1e7;
int pr[N/4],v[N+1],e[N+1],f[N+1],m=0;
int main(){
    f[1]=1;
    for(int i=2;i<=N;i++){
        if(v[i]==0){
            v[i]=i;e[i]=1;f[i]=2;
            pr[++m]=i;
        }
        for(int j=1;j<=m;j++){
            if(pr[j]>v[i]||pr[j]>N/i) break;
            v[i*pr[j]]=pr[j];
            if(pr[j]==v[i]){
                e[i*pr[j]]=e[i]+1;
                f[i*pr[j]]=f[i]/(e[i]+1)*(e[i]+2);
            } else{
                e[i*pr[j]]=1;
                f[i*pr[j]]=f[i]<<1;
            }
        }
    }
    int ans=0;
    for(int i=1;i<N;i++)
        if(f[i]==f[i+1]) ++ans;
    printf("%d\n",ans);
}
```
## Q180
```Python
def isq(n: int):
    m = int(n ** 0.5)
    return m * m == n


k = 35
one = Fraction(1)
fraction_set = set()
for b in range(1, k + 1):
    for a in range(1, b):
        fraction_set.add(Fraction(a, b))
fraction_list = list(fraction_set)
l = len(fraction_list)
st = set()
for i in range(l):
    x = fraction_list[i]
    for j in range(i, l):
        y = fraction_list[j]
        z = x + y
        if z in fraction_set:
            st.add(x + y + z)
        z2 = x * x + y * y
        if isq(z2.numerator) and isq(z2.denominator):
            z = Fraction(int(z2.numerator ** 0.5), int(z2.denominator ** 0.5))
            if z in fraction_list:
                st.add(x + y + z)
        z = one / (one / x + one / y)
        if z in fraction_set:
            st.add(x + y + z)
        tp = one / (one / x / x + one / y / y)
        if isq(tp.numerator) and isq(tp.denominator):
            z = Fraction(int(tp.numerator ** 0.5), int(tp.denominator ** 0.5))
            if z in fraction_set:
                st.add(x + y + z)

s = sum(st)
print(s.numerator + s.denominator)
# f_n(x,y,z)=(x+y+z)*(x^n+y^n-z^n)
# 此时变为求方程x^n+y^n=z^n是否有有理数解。
# 根据费马大定理，可以证明，n>=3时，没有有理数解。
# 说明：设x=a/b,y=c/d,z=e/f.
# 代入式子后，通分，即可化成(adf)^n+(bcf)^n=(bde)^n，成为一个整式，根据费马大定理，n>=3时无整数解，故原命题成立，只本题只需验证n=-2,-1,1和2的情况即可。
```
## Q181
```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=60,M=40;
const int O=(N+1)*(M+1)+1;
ll f[N+1][M+1][O];
int id[N+1][M+1],x[O],y[O];
int p=0;
int main(){
    for(int i=0;i<=N;i++)
    for(int j=0;j<=M;j++,p++){
        x[p]=i;y[p]=j;
        id[i][j]=p;
    }
    --p;
    for(int i=0;i<=N;i++)
    for(int j=0;j<=M;j++) {
        if(i==0&&j==0) continue;
        for (int k = 1; k <= p; k++) {
            if(k<id[i][j]){
                f[i][j][k]=f[i][j][k-1];
                if(x[k]<=i&&y[k]<=j) f[i][j][k]+=f[i-x[k]][j-y[k]][k];
            }
            else if(k==id[i][j]) f[i][j][k]=f[i][j][k-1]+1;
            else f[i][j][k]=f[i][j][id[i][j]];
        }
    }
    printf("%lld\n",f[N][M][p]);
}
```
## Q182
```Python
from Q7_7 import *
from Q5_2 import gcd
from fractions import Fraction

p, q = 1009, 3643
n, phi = p * q, (p - 1) * (q - 1)
ans = 0
mn = 1 << 100
for e in range(2, phi):
    if gcd(e, phi) == 1:
        cnt = (1 + gcd(e - 1, p - 1)) * (1 + gcd(e - 1, q - 1))
        if cnt < mn:
            ans = e
            mn = cnt
        elif cnt == mn:
            ans += e
print(ans)
# m^e==m(mod n)意味着m^e==m(mod p)和m^e==m(mod q)
# 接下来求方程m^e==m(mod p)的解数。
# 当m=0时，为一个解，当m不等于0是，即为求方程m^{e-1}==1(mod p)的解数。
# 令c=e-1，此处证明x^c==1(mod p)有d=gcd(c,p-1)个解。
# 对素数p，设其其中一个原根为g。
# 那么对于1,2,...,p-1，存在i=0,1,...,p-2，使得x==g^i(mod p)。
# 因此x^c==1(mod p)当且仅当g^{ci}==1(mod p)，并且(p-1)|ci。因此当且仅当(p-1)/d|i，即i是(p-1)/d的倍数。
# 在0,1,...,p-2中，(p-1)/d的倍数恰好有d个，分别是0,(p-1)/d,2(p-1)/d,...,(d-1)(p-1)/d。
```
## Q183
```Python
from math import e, ceil, floor, log

N = 10000
ans = 0
for n in range(5, N + 1):
    val = n / e
    l, r = floor(val), ceil(val)
    logfl, logfr = l * log(n / l), r * log(n / r)
    if logfl > logfr:
        x = l
    else:
        x = r
    x //= gcd(x, n)
    while x % 5 == 0:
        x //= 5
    while (x & 1) == 0:
        x >>= 1
    if x == 1:
        ans -= n
    else:
        ans += n
print(ans)
# y=(n/x)^x，那么y'=y(lnn-1-lnx)
# 那么要取到最值，y'=0，那么x=n/e，为最大值。
```
## Q184
```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=105;
struct V{
    int x,y;
    bool operator < (const V v) const{
        return x*v.y-y*v.x>0;
    }
}p[N*N*4];
int gcd(int a,int b) {
    return b ? gcd(b, a % b) : a;
}
map<V,int>mp;
int m=0;
ll c[N*N*4],s[N*N*4],s1[N*N*4],s2[N*N*4];
int main(){
    for(int i=-N;i<=N;i++)
        for(int j=-N;j<=N;j++)
            if(!(i==0&&j==0)&&i*i+j*j<N*N){
                int k= gcd(abs(i),abs(j));
                ++mp[V{i/k,j/k}];
            }
    for(auto it=mp.begin();it!=mp.end();it++){
        ++m;
        tie(p[m],c[m])=*it;
        s[m]=s[m-1]+c[m];
        s1[m]=s1[m-1]+c[m]*s[m-1];
        s2[m]=s2[m-1]+c[m]*s[m];
    }
    ll ans=0;
    for(int i=1;i<=m;i++){
        int r=min(i+m/2-1,m);
        ans+=c[i]*(s1[r]-s1[i])-c[i]*s[i]*(s[r]-s[i]);
        int l=i+m/2+1;
        if(l<=m){
            ans+=c[i]*(s[m]+s[i-1])*(s[m]-s[l-1])-c[i]*(s2[m]-s2[l-1]);
        }
    }
    printf("%lld\n",ans/3);
}
```
## Q185
```Python
from random import randint

lt = [("5616185650518293", 2), ("3847439647293047", 1), ("5855462940810587", 3), ("9742855507068353", 3),
      ("4296849643607543", 3), ("3174248439465858", 1), ("4513559094146117", 2), ("7890971548908067", 3),
      ("8157356344118483", 1), ("2615250744386899", 2), ("8690095851526254", 3), ("6375711915077050", 1),
      ("6913859173121360", 1), ("6442889055042768", 2), ("2321386104303845", 0), ("2326509471271448", 2),
      ("5251583379644322", 2), ("1748270476758276", 3), ("4895722652190306", 1), ("3041631117224635", 3),
      ("1841236454324589", 3), ("2659862637316867", 2)]
ls = []
for x, y in lt:
    ls.append(([int(w) for w in x], y))
n, m = len(ls), len(ls[0][0])


def shuffle(ls: list, id: int):
    while True:
        w = randint(0, 9)
        if ls[id] != w:
            break
    ls[id] = w


def distance(val: list):
    error = 0
    for v, cnt in ls:
        c = 0
        for i in range(m):
            if v[i] == val[i]:
                c += 1
        error += abs(cnt - c)
    return error


ans = [0 for i in range(m)]
for i in range(m):
    shuffle(ans, i)

MAX_ROUNDS = 20
STUCK_ROUNDS = 0
dis = pre_dis = distance(ans)
while dis != 0:
    for i in range(m):
        pre = ans[i]
        shuffle(ans, i)
        now_dis = distance(ans)
        if now_dis <= dis:
            dis = now_dis
        else:
            ans[i] = pre
    if dis == pre_dis:
        STUCK_ROUNDS += 1
        if STUCK_ROUNDS == MAX_ROUNDS:
            shuffle(ans, randint(0, m - 1))
            dis = distance(ans)
            STUCK_ROUNDS = 0
    else:
        STUCK_ROUNDS = 0
        pre_dis = dis
print("".join(str(x) for x in ans))
# 伪模拟退火算法，distance函数计算当前与推测的误差，误差值为sum(提示项的预估正确数和实际正确数之差的绝对值。)
# shuffle为对列表的某一位进行随机化，但随机后的数字必须与原来的不同。
# STUCK_ROUNDS和MAX_ROUNDS用于防止程序陷入局部最优解中，如果陷入了，那么就随机改变一位数字，尽管这会让误差值变大。

# 另有一种做法是，把所有解的前8位数字和22组提示的正确值前8位数字存入哈希表中，然后将后8位数字的正确值所有情况计算出来，分别在哈希表中查找之前的结果。这使用了meet in the middle的想法。
```
## Q186
```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1000000;
const int M=N*5,P=524287,A=N/100*99;
int fa[N],sz[N];
int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}
void merge(int x,int y){
    int u=find(x),v=find(y);
    if(u!=v){
        fa[u]=v;
        sz[v]+=sz[u];
    }
}
int f[M];
int main(){
    int cnt=0,ans=0;
    for(int i=0;i<N;i++)
        fa[i]=i,sz[i]=1;
    for(int i=1;i<=55;i++)
        f[i]=(1ll*300007*i*i*i+100003-200003*i)%N;
    for(int i=56;i<M;i++)
        f[i]=(f[i-24]+f[i-55])%N;
    for(int i=2;i<M;i+=2){
        if(f[i]==f[i-1]) ++cnt;
        else{
            merge(f[i],f[i-1]);
            if(sz[find(P)]>=A){
                ans=i/2-cnt;
                break;
            }
        }
    }
    printf("%d\n",ans);
}
```
## Q187
```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int O=1e8;
const int N=O/2;
int v[N],pr[N],m=0;
int main(){
    for(int i=2;i<N;i++){
        if(v[i]==0){
            pr[++m]=i;v[i]=i;
        }
        for(int j=1;j<=m;j++){
            if(pr[j]>v[i]||pr[j]>N/i) break;
            v[i*pr[j]]=pr[j];
        }
    }
    ll ans=0;
    for(int l=1,r=m;l<=r;l++){
        for(;pr[l]*pr[r]>=O;r--);
        ans+=r-l+1;
    }
    printf("%lld\n",ans);
}
```
## Q188
```Python
from Q11_4 import phi


def dfs(a: int, f: int, mod: int):
    if f <= 1:
        return (a ** f) % mod
    elif mod == 1:
        return 0
    else:
        ph = phi(mod)
        return quick_power(a, dfs(a, f - 1, ph) % ph, mod)


n = 1777
m = 1855
mod = 10 ** 8
print("{:0>8}".format(dfs(n, m, mod)))
```
## Q189
```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=8;
ll f[N+1][7004];
int pw3[N+1],c[8];
vector<int>g[7004];
int main(){
    for(int i=0;i<8;i++){
        for(int j=0;j<3;j++)
            c[i]+=(i>>j&1);
        c[i]=3-c[i];
    }
    pw3[0]=1;
    for(int i=1;i<=N;i++)
        pw3[i]=pw3[i-1]*3;
    f[1][0]=f[1][1]=f[1][2]=1;
    for(int j=0;j<pw3[N];j++){
        int x=j;
        for(int k=0;k<N;k++,x/=3)
            g[j].push_back(x%3);
    }
    for(int i=1;i<N;i++){
        for(int j=0;j<pw3[i];j++){
            for(int k=0;k<pw3[i+1];k++){
                int v=1;
                for(int l=0;l<i;l++)
                    v*=c[1<<g[j][l]|1<<g[k][l]|1<<g[k][l+1]];
                f[i+1][k]+=f[i][j]*v;
            }
        }
    }
    ll ans=0;
    for(int i=0;i<pw3[N];i++)
        ans+=f[N][i];
    printf("%lld\n",ans);
}
```
## Q190
```Python
from random import randint

MAX_ROUNDS = 100


def solve(n: int):
    a = [1 for _ in range(n)]
    ans = 1
    for i in range(1, 7):
        STUCK_ROUND = 0
        d = 10 ** (-i)
        while STUCK_ROUND < MAX_ROUNDS:
            x = randint(0, n - 1)
            y = randint(0, n - 1)
            if x == y or a[x] <= d:
                continue
            a[x] -= d
            a[y] += d
            mul = 1
            for j in range(n):
                mul *= a[j] ** (j + 1)
            if mul > ans:
                ans = mul
                STUCK_ROUND = 0
            else:
                STUCK_ROUND += 1
                a[x] += d
                a[y] -= d
    return ans


N = 15
ans = 0
for n in range(2, N + 1):
    ans += int(solve(n))
print(ans)
```
## Q191
```Python
from random import randint

N = 30
f = [0 for _ in range(N + 1)]
f[0], f[1], f[2], f[3] = 1, 2, 4, 7
for n in range(4, N + 1):
    f[n] = f[n - 1] * 2 - f[n - 4]
ans = f[N]
for i in range(1, N + 1):
    ans += f[i - 1] * f[N - i]
print(ans)
```
## Q192
```Python
# https://en.wikipedia.org/wiki/Continued_fraction#Best_rational_approximations
def get_fraction_list(n: int, l: int):
    m = 0
    d = 1
    a = a0 = int(n ** 0.5)
    ls = [a]
    while len(ls) < l:
        m = d * a - m
        d = (n - m * m) / d
        a = int((a0 + m) / d)
        ls.append(a)
    return ls


def allow_half(a: list, k: int):
    i = k
    s = 1
    while i > 0:
        difference = s * (a[i] - a[2 * k - i])
        if difference > 0:
            return True
        if difference < 0:
            return False
        s *= -1
        i -= 1
    return (k & 1) == 0


def solve(m: int, lim: int):
    a = get_fraction_list(m, 128)
    n2, d2 = 1, 0
    n1, d1 = a[0], 1
    i = 1
    while True:
        n = d = 0
        val = (a[i] + 1) >> 1
        if (a[i] & 1) == 0 and not allow_half(a, i):
            val += 1
        for q in range(val, a[i] + 1):
            n, d = n2 + q * n1, d2 + q * d1
            if d > lim:
                if q > val:
                    return d2 + (q - 1) * d1
                else:
                    return d1
        i += 1
        print(n2, n1, n)
        print(d2, d1, d, end="\n\n")
        n2, n1 = n1, n
        d2, d1 = d1, d


N = 10 ** 5
M = 10 ** 12
ans = 0
for S in range(13, 14):
    n = int(S ** 0.5)
    if n * n == S:
        continue
    ans += solve(S, M)
print(ans)
```
## Q193
```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1ll<<50;
const ll M=1ll<<25;
int miu[M+1],m=0;
bool vis[M+1];
int main(){
    miu[1]=1;
    for(int i=1;i<=M;i++) miu[i]=1;
    for(int i=2;i<=M;i++){
        if(vis[i]) continue;
        miu[i]=-1;
        for(int j=i+i;j<=M;j+=i){
            vis[j]=1;
            if((j/i)%i==0) miu[j]=0;
            else miu[j]*=-1;
        }
    }
    ll ans=0;
    for(int i=1;i<=M;i++)
        ans+=1ll*miu[i]*(N/(1ll*i*i));
    printf("%lld\n",ans);
}
```
## Q194
```Python
na = 25
nb = 75
c = 1984
mod = 10 ** 8
n = 7
edges = [(2, 3), (3, 0), (0, 1), (1, 2), (0, 4), (1, 4), (2, 5), (3, 5), (4, 6), (5, 6)]
cth_row = [1]
fa = [0 for i in range(n + 1)]
fb = [0 for i in range(n + 1)]
g = [[] for i in range(n)]
a = [0 for i in range(n)]
dp = [[0 for j in range(nb + 1)] for i in range(na + 1)]
for i in range(1, n + 1):
    cth_row.append(cth_row[-1] * (c - i + 1) // i)


def add_edge(v: tuple):
    x, y = v[0], v[1]
    g[x].append(y)
    g[y].append(x)


def dfs(u: int, f: list):
    if u == n:
        tp = a.copy()
        tp.sort()
        if tp[0] != 1:
            return
        for i in range(1, n):
            if tp[i] - tp[i - 1] > 1:
                return
        f[tp[n - 1]] += 1
        return
    for k in range(1, n + 1):
        ok = True
        for v in g[u]:
            if k == a[v]:
                ok = False
                break
        if ok:
            a[u] = k
            dfs(u + 1, f)
    a[u] = 0


for i in range(1, len(edges)):
    add_edge(edges[i])
dfs(0, fb)
add_edge(edges[0])
dfs(0, fa)
va = sum(fa[i] * cth_row[i] // (c * (c - 1)) for i in range(n + 1)) % mod
vb = sum(fb[i] * cth_row[i] // (c * (c - 1)) for i in range(n + 1))
dp[0][0] = c * (c - 1)
for i in range(na + 1):
    for j in range(nb + 1):
        if i > 0:
            dp[i][j] += dp[i - 1][j] * va
        if j > 0:
            dp[i][j] += dp[i][j - 1] * vb
        dp[i][j] %= mod
print("{:0>8}".format(dp[na][nb]))
```
## Q195
```Python
//http://www.geocities.ws/fredlb37/node9.html
#include <bits/stdc++.h>
using namespace std;
double eps=1e-6;
int gcd(int a,int b){
    return b?gcd(b,a%b):a;
}
double sq3=sqrt(3);
int main(){
    int N=1053779;
    int ans=0;
    for(int m=1,n,n2;m<=N*4;m++){
        for(n=1;n<m;n++){
            if((m-n)%3==0||gcd(n,m)!=1) continue;
            double r=0.5*sq3*m*n;
            if(r>N) break;
            ans+=int(1.0*N/r+eps);
        }
        for(n=m-1;n>0;n--){
            if((m-n)%3==0||gcd(n,m)!=1) continue;
            double r=0.5*(m-n)*(2*n+m)/sq3;
            if(r>N) break;
            ans+=int(1.0*N/r+eps);
        }
        n2=n;
        for(int n=1;n<n2;n++){
            if((m-n)%3==0||gcd(n,m)!=1) continue;
            double r=0.5*(m-n)*(2*n+m)/sq3;
            if(r>N) break;
            ans+=int(1.0*N/r+eps);
        }
    }
    printf("%d\n",ans);
}

```
## Q196
```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int Q1=5678027,Q2=7208785;
bool b[Q2*5+2];
int sz[Q2],fa[Q2];
ll pr1[Q2],pr2[Q2];
int p1=0,p2=0;
int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}
void merge(int x,int y){
    int u=find(x),v=find(y);
    if(u!=v){
        fa[u]=v;
        sz[v]+=sz[u];
    }
}
ll ed(int n){
    return 1ll*n*(n+1)/2;
}
ll st(int n){
    return ed(n-1)+1;
}
ll getv(int x,int y){
    if(x<0||y<1||y>x) return -1;
    return 1ll*(x-1)*x/2+y;
}
int dx[8]={-1,-1,-1,0,0,1,1,1},dy[8]={-1,0,1,-1,1,-1,0,1};
ll solve(int row){
    ll l=st(row-2),r=ed(row+2);
    ll sq=sqrt(r);
    p1=p2=0;
    memset(b,0,sizeof(b));
    for(int i=2;i<=sq;i++){
        if(b[i]) continue;
        pr1[++p1]=i;
        for(int j=i;1ll*i*j<=sq;j++)
            b[i*j]=1;
    }
    memset(b,0,sizeof(b));
    for(int i=1;i<=p1;i++)
        for(ll j=(l+pr1[i]-1)/pr1[i];j*pr1[i]<=r;j++)
            b[j*pr1[i]-l]=1;
    unordered_map<ll,int>pos;
    for(ll i=l;i<=r;i++)
        if(!b[i-l]&&i>1) {
            pr2[++p2]=i;
            pos[i]=p2;
        }
    for(int i=1;i<=p2;i++)
        fa[i]=i,sz[i]=1;
    for(int i=row-1;i<=row+1;i++){
        for(int j=1;j<=i;j++){
            ll v=getv(i,j);
            if(!pos.count(v)) continue;
            int p=pos[v];
            for(int k=0;k<8;k++){
                int x=i+dx[k],y=j+dy[k];
                ll w=getv(x,y);
                if(w==0||!pos.count(w)) continue;
                merge(p,pos[w]);
            }
        }
    }
    l=st(row);r=ed(row);
    ll ans=0;
    for(ll i=l;i<=r;i++)
        if(pos.count(i)){
            int p=pos[i];
            if(sz[find(p)]>=3) ans+=i;
        }
    return ans;
}
int main(){
    printf("%lld\n",solve(Q1)+ solve(Q2));
}
```
## Q197
```Python
def f(x: float):
    return int(2 ** (30.403243784 - x * x)) * 1e-9


a = [-1]
for i in range(10000):
    a.append(f(a[-1]))
print(a[-1] + a[-2])
```
## Q198
```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
struct TP{
    ll lu,ld,ru,rd,midd;
};
int main(){
    ll r=100,n=1e8;
    vector<TP>v;
    v.push_back(TP{0,1,1,1,2});
    ll ans=0;
    while(!v.empty()){
        TP t=v.back();v.pop_back();
        ll midd=t.midd,midu=t.lu*t.rd+t.ld*t.ru;
        if(r*midu<midd) ++ans;
        ll gend=t.ld+t.rd,genu=t.lu+t.ru;
        ll lmidd=2ll*t.ld*gend,rmidd=2ll*t.rd*gend;
        if(lmidd<=n)
            v.push_back(TP{t.lu,t.ld,genu,gend,lmidd});
        if(rmidd<=n)
            v.push_back(TP{genu,gend,t.ru,t.rd,rmidd});
    }
    printf("%lld\n",ans);
}
//# 非递归前序遍历Stern-Brocot树以获得F(n)的Farey序列。
// 可以知道，如果分数a和b在某个Farey序列F(n)中相邻，那么(a+b)/2就是其中一个解。
```
## Q199
```Python
from Q5_2 import gcd
from random import randint
from fractions import Fraction
from math import pi, sqrt


def getS(r: float):
    return pi * r * r


def dfs(k1: float, k2: float, k3: float, d: int):
    k4 = k1 + k2 + k3 + 2 * sqrt(k1 * k2 + k2 * k3 + k3 * k1)
    ans = getS(1 / k4)
    if d == 1:
        return ans
    return ans + dfs(k4, k2, k3, d - 1) + dfs(k1, k4, k3, d - 1) + dfs(k1, k2, k4, d - 1)


n = 10
inK = inR = 1
outK = 3 - 2 * sqrt(3)
outR = -1 / outK
ans = getS(inR) * 3 + dfs(inK, inK, outK, n) * 3 + dfs(inK, inK, inK, n)
ans = 1 - ans / getS(outR)
print("{:.8f}".format(ans))
# 笛卡尔定理：设4个两两相切的圆前三个半径r1,r2,r3，其倒数分别为k1,k2,k3，且这四个圆两两相切的切点均不同，第四个圆为r4和k4。
# 若已知r1，r2，r3，则k4满足：(k1+k2+k3+k4)^2=2(k1^2+k2^2+k3^3+k4^2)
# 故k4有两个解。若k4>0，那么另外三个圆外切于这个圆，k<0则说明另外三个圆内切于这个圆，r4=|1/k4|。
```
## Q200
```Python
from Miller_Rabin import Miller_Rabin
from queue import PriorityQueue


def judge(n: int):
    s = str(n)
    l = len(s)
    for i in range(l):
        d = int(s[i])
        for j in range(10):
            if i + j == 0 or d == j:
                continue
            x = int(s[:i] + str(j) + s[i + 1:])
            if Miller_Rabin(x):
                return False
    return True


Q = 200
q = PriorityQueue()
M = 200000
flag = [0 for _ in range(M + 1)]
pr = []
for i in range(2, M + 1):
    if flag[i] == 0:
        pr.append(i)
        for j in range(i * i, M + 1, i):
            flag[j] = 1

q.put(((pr[0] ** 2) * (pr[1] ** 3), 0, 1))
q.put(((pr[1] ** 2) * (pr[0] ** 3), 1, 0))
l = len(pr)
cnt = 0
while True:
    w, x, y = q.get()
    if x == l - 1 or y == l - 1:
        break
    if "200" in str(w) and judge(w):
        cnt += 1
        if cnt == Q:
            ans = w
            break
    if x + 1 != y and not (x > y and y != 0):
        q.put(((pr[x + 1] ** 2) * (pr[y] ** 3), x + 1, y))
    if x != y + 1 and not (x < y and x != 0):
        q.put(((pr[x] ** 2) * (pr[y + 1] ** 3), x, y + 1))

print(ans)
```