## Q161
```Python
n, m = 9, 12
triomino_ls = [
    [(0, 0), (1, 0), (0, 1)],
    [(0, 0), (1, 0), (1, 1)],
    [(0, 0), (0, 1), (1, 1)],
    [(0, 0), (1, 0), (1, -1)],
    [(0, 0), (0, 1), (0, 2)],
    [(0, 0), (1, 0), (2, 0)],
]
if m > n:
    n, m = m, n


def get_empty(grid: tuple):
    for i in range(n):
        if grid[i] != (1 << m) - 1:
            for j in range(m):
                if (grid[i] >> j & 1) == 0:
                    return i, j
    return None


def place_triomino(grid: tuple, x: int, y: int, id: int):
    tp = list(grid)
    for dx, dy in triomino_ls[id]:
        nx, ny = x + dx, y + dy
        if nx < 0 or ny < 0 or nx >= n or ny >= m or tp[nx] >> ny & 1:
            return None
        tp[nx] |= 1 << ny
    return tuple(tp)


cnt = m * n // 3
st = tuple(0 for i in range(n))
ed = tuple((1 << m) - 1 for i in range(n))
f = [{} for i in range(cnt + 1)]
f[0][st] = 1
for i in range(cnt):
    for grid, val in f[i].items():
        x, y = get_empty(grid)
        for k in range(6):
            next = place_triomino(grid, x, y, k)
            if next is None:
                continue
            if next not in f[i + 1].keys():
                f[i + 1][next] = 0
            f[i + 1][next] += val

print(f[cnt][ed])
```
## Q163
```C++
# include <bits/stdc++.h>
# define X first
# define Y second
# define pi pair<int,int>
# define pd pair<double,double>
using namespace std;
typedef long long ll;
map<pi,int>mp;
int b[4004][4004];
int fa[6][4004],m=0;
int get(int x,int y){
    pi pa(x,y);
    if(mp.count(pa)) return mp[pa];
    mp[pa]=++m;
    for(int j=0;j<6;j++)
        fa[j][m]=m;
    return m;
}
int find(int *fa,int x){
    return x==fa[x]?x:fa[x]=find(fa,fa[x]);
}
void merge(int id,int x,int y){
    fa[id][x]=find(fa[id],y);
}
int param[9][7]={
    0,2,6,3,3,4,0,
    1,1,3,2,2,4,0,
    2,0,0,2,0,4,0,
    3,0,0,2,2,3,3,
    4,0,0,1,3,2,6,
    5,2,0,2,2,2,6,
    1,2,6,4,4,5,3,
    3,3,3,4,4,6,6,
    5,4,0,4,4,4,6
};
int main(){
    int n=36;
    for(int i=0;i<n;i++)
        for(int j=0;j<n-i;j++){
            int x=j*4+i*2,y=6*i;
            for(int k=0;k<9;k++){
                if(j==n-i-1&&k==6) break;
                merge(param[k][0],get(x+param[k][1],y+param[k][2]),get(x+param[k][3],y+param[k][4]));
                merge(param[k][0],get(x+param[k][3],y+param[k][4]),get(x+param[k][5],y+param[k][6]));
            }
        }
    for(int i=1;i<=m;i++)
    for(int j=i+1;j<=m;j++){
        for(int k=0;k<6;k++)
            if(find(fa[k],i)==find(fa[k],j)){
                b[i][j]=b[j][i]=k+1;
                break;
            }
    }
    int ans=0;
    for(int i=1;i<=m;i++){
        for(int j=i+1;j<=m;j++){
            if(!b[i][j]) continue;
            for(int k=j+1;k<=m;k++)
                if(b[j][k]&&b[i][k]&&b[i][j]!=b[i][k]) ++ans;
        }
    }
    printf("%d\n",ans);
    //printf("%d\n",(1678*n*n*n+3117*n*n+88*n-n%2*345-n%3*320-n%4*90-(n*n*n-n*n+n)%5*288)/240);
}
```
## Q167
```C++
# include <bits/stdc++.h>
# define X first
# define Y second
using namespace std;
typedef long long ll;
int main(){
    ll n=1e11;
    ll sum=0;
    map<int,int>mp;
    for(int i=2;i<=10;i++){
        int even=0,even_pos=0;
        mp.clear();
        vector<int>U;U.push_back(2*i+1);
        do{
            ++mp[U.back()+2];
            if(even) ++mp[U.back()+even];
            else{
                for(int j=0;j+1<U.size();j++)
                    mp[U.back()+U[j]]++;
            }
            if(U.back()%2==0){
                even=U.back();even_pos=U.size()-1;
                for(auto & it : mp)
                    if(it.X%2==0) ++it.Y;
            }
            for(auto it=mp.begin();it!=mp.end();it++)
                if(it->Y==1){
                    U.push_back(it->X);
                    mp.erase(mp.begin(),++it);
                    break;
                }
        }while(U.back()-U[U.size()-2]!=even);
        int period=U.size()-2,diff=U.back()-U.front();
        int s=(n-3)%period;
        if(s>=even_pos) ++s;
        ll ans=(n-3)/period*diff+U[s];
        sum+=ans;
    }
    printf("%lld\n",sum);
}
/*
Schmerl和Spiegel在1994年证明：
满足n>=2的Ulam序列U(2,2n+1)有且只有两个偶数，其中一个是2，设另外一个为even.
设U'(2,2n+1)为U(2,2n+1)去掉两个偶数项后剩下的数，那么U'(2n+1)的差分序列是一个循环数组，其中最小的循环节中有且仅有一个even，并且这个even在整个循环节中的最后一个数、
*/
```
## Q177
```C++
#include <bits/stdc++.h>
# define pi pair<int,int>
# define X first
# define Y second
using namespace std;
double sina[184],cosa[184];
double eps=1e-9;
double Pi=acos(-1.0);
bool is_integer(double v) {
    return abs(v - round(v)) <= eps;
}
int ans=0;
set<vector<pi>>st;
vector<pi> getmin(vector<pi>v){
    vector<pi>ans=v;
    for(int p=1;p<4;p++){
        vector<pi>tp;
        for(int i=p;i<4;i++) tp.push_back(v[i]);
        for(int i=0;i<p;i++) tp.push_back(v[i]);
        ans=min(ans,tp);
    }
    return ans;
}
void insert(vector<pi> a){
    a=getmin(a);
    if(!st.count(a)){
        ++ans;
        st.insert(a);
        reverse(a.begin(),a.end());
        for(pi&pa:a)
            swap(pa.X,pa.Y);
        a=getmin(a);
        st.insert(a);
    }
}
int main(){
    for(int i=1;i<=180;i++){
        sina[i]=sin(Pi*i/180);
        cosa[i]=cos(Pi*i/180);
    }
    for(int BAD=1;BAD<180;BAD++){
        for(int ABD=1;ABD<=180-BAD-ABD;ABD++){
            int ADB=180-BAD-ABD;
            for(int CDB=1;CDB<180-ADB;CDB++){
                for(int CBD=1;CBD<min(180-ABD,180-CDB);CBD++) {
                    int BCD = 180 - CDB - CBD;
                    double BD = 1;
                    double AD=BD/sina[BAD]*sina[ABD];
                    double CD=BD/sina[BCD]*sina[CBD];
                    double AC= sqrt(AD*AD+CD*CD-2.0*AD*CD*cosa[ADB+CDB]);
                    double DAC= asin(sina[ADB+CDB]/AC*CD)/Pi*180;
                    if(!is_integer(DAC)) continue;
                    DAC=round(DAC);
                    if(AC*AC+AD*AD<CD*CD) DAC=180-DAC;
                    int DCA=180-(ADB+CDB+DAC);
                    insert({pi(BAD-DAC,DAC),pi(ADB,CDB),pi(DCA,BCD-DCA),pi(CBD,ABD)});
                }
            }
        }
    }
    printf("%d\n",ans);
}
```
## Q180
```Python
def isq(n: int):
    m = int(n ** 0.5)
    return m * m == n


k = 35
one = Fraction(1)
fraction_set = set()
for b in range(1, k + 1):
    for a in range(1, b):
        fraction_set.add(Fraction(a, b))
fraction_list = list(fraction_set)
l = len(fraction_list)
st = set()
for i in range(l):
    x = fraction_list[i]
    for j in range(i, l):
        y = fraction_list[j]
        z = x + y
        if z in fraction_set:
            st.add(x + y + z)
        z2 = x * x + y * y
        if isq(z2.numerator) and isq(z2.denominator):
            z = Fraction(int(z2.numerator ** 0.5), int(z2.denominator ** 0.5))
            if z in fraction_list:
                st.add(x + y + z)
        z = one / (one / x + one / y)
        if z in fraction_set:
            st.add(x + y + z)
        tp = one / (one / x / x + one / y / y)
        if isq(tp.numerator) and isq(tp.denominator):
            z = Fraction(int(tp.numerator ** 0.5), int(tp.denominator ** 0.5))
            if z in fraction_set:
                st.add(x + y + z)

s = sum(st)
print(s.numerator + s.denominator)
# f_n(x,y,z)=(x+y+z)*(x^n+y^n-z^n)
# 此时变为求方程x^n+y^n=z^n是否有有理数解。
# 根据费马大定理，可以证明，n>=3时，没有有理数解。
# 说明：设x=a/b,y=c/d,z=e/f.
# 代入式子后，通分，即可化成(adf)^n+(bcf)^n=(bde)^n，成为一个整式，根据费马大定理，n>=3时无整数解，故原命题成立，只本题只需验证n=-2,-1,1和2的情况即可。
```
## Q181
```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=60,M=40;
const int O=(N+1)*(M+1)+1;
ll f[N+1][M+1][O];
int id[N+1][M+1],x[O],y[O];
int p=0;
int main(){
    for(int i=0;i<=N;i++)
    for(int j=0;j<=M;j++,p++){
        x[p]=i;y[p]=j;
        id[i][j]=p;
    }
    --p;
    for(int i=0;i<=N;i++)
    for(int j=0;j<=M;j++) {
        if(i==0&&j==0) continue;
        for (int k = 1; k <= p; k++) {
            if(k<id[i][j]){
                f[i][j][k]=f[i][j][k-1];
                if(x[k]<=i&&y[k]<=j) f[i][j][k]+=f[i-x[k]][j-y[k]][k];
            }
            else if(k==id[i][j]) f[i][j][k]=f[i][j][k-1]+1;
            else f[i][j][k]=f[i][j][id[i][j]];
        }
    }
    printf("%lld\n",f[N][M][p]);
}
```
## Q182
```Python
from Q7_7 import *
from Q5_2 import gcd
from fractions import Fraction

p, q = 1009, 3643
n, phi = p * q, (p - 1) * (q - 1)
ans = 0
mn = 1 << 100
for e in range(2, phi):
    if gcd(e, phi) == 1:
        cnt = (1 + gcd(e - 1, p - 1)) * (1 + gcd(e - 1, q - 1))
        if cnt < mn:
            ans = e
            mn = cnt
        elif cnt == mn:
            ans += e
print(ans)
# m^e==m(mod n)意味着m^e==m(mod p)和m^e==m(mod q)
# 接下来求方程m^e==m(mod p)的解数。
# 当m=0时，为一个解，当m不等于0是，即为求方程m^{e-1}==1(mod p)的解数。
# 令c=e-1，此处证明x^c==1(mod p)有d=gcd(c,p-1)个解。
# 对素数p，设其其中一个原根为g。
# 那么对于1,2,...,p-1，存在i=0,1,...,p-2，使得x==g^i(mod p)。
# 因此x^c==1(mod p)当且仅当g^{ci}==1(mod p)，并且(p-1)|ci。因此当且仅当(p-1)/d|i，即i是(p-1)/d的倍数。
# 在0,1,...,p-2中，(p-1)/d的倍数恰好有d个，分别是0,(p-1)/d,2(p-1)/d,...,(d-1)(p-1)/d。
```
## Q185
```Python
from random import randint

lt = [("5616185650518293", 2), ("3847439647293047", 1), ("5855462940810587", 3), ("9742855507068353", 3),
      ("4296849643607543", 3), ("3174248439465858", 1), ("4513559094146117", 2), ("7890971548908067", 3),
      ("8157356344118483", 1), ("2615250744386899", 2), ("8690095851526254", 3), ("6375711915077050", 1),
      ("6913859173121360", 1), ("6442889055042768", 2), ("2321386104303845", 0), ("2326509471271448", 2),
      ("5251583379644322", 2), ("1748270476758276", 3), ("4895722652190306", 1), ("3041631117224635", 3),
      ("1841236454324589", 3), ("2659862637316867", 2)]
ls = []
for x, y in lt:
    ls.append(([int(w) for w in x], y))
n, m = len(ls), len(ls[0][0])


def shuffle(ls: list, id: int):
    while True:
        w = randint(0, 9)
        if ls[id] != w:
            break
    ls[id] = w


def distance(val: list):
    error = 0
    for v, cnt in ls:
        c = 0
        for i in range(m):
            if v[i] == val[i]:
                c += 1
        error += abs(cnt - c)
    return error


ans = [0 for i in range(m)]
for i in range(m):
    shuffle(ans, i)

MAX_ROUNDS = 20
STUCK_ROUNDS = 0
dis = pre_dis = distance(ans)
while dis != 0:
    for i in range(m):
        pre = ans[i]
        shuffle(ans, i)
        now_dis = distance(ans)
        if now_dis <= dis:
            dis = now_dis
        else:
            ans[i] = pre
    if dis == pre_dis:
        STUCK_ROUNDS += 1
        if STUCK_ROUNDS == MAX_ROUNDS:
            shuffle(ans, randint(0, m - 1))
            dis = distance(ans)
            STUCK_ROUNDS = 0
    else:
        STUCK_ROUNDS = 0
        pre_dis = dis
print("".join(str(x) for x in ans))
# 伪模拟退火算法，distance函数计算当前与推测的误差，误差值为sum(提示项的预估正确数和实际正确数之差的绝对值。)
# shuffle为对列表的某一位进行随机化，但随机后的数字必须与原来的不同。
# STUCK_ROUNDS和MAX_ROUNDS用于防止程序陷入局部最优解中，如果陷入了，那么就随机改变一位数字，尽管这会让误差值变大。

# 另有一种做法是，把所有解的前8位数字和22组提示的正确值前8位数字存入哈希表中，然后将后8位数字的正确值所有情况计算出来，分别在哈希表中查找之前的结果。这使用了meet in the middle的想法。
```
## Q189
```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=8;
ll f[N+1][7004];
int pw3[N+1],c[8];
vector<int>g[7004];
int main(){
    for(int i=0;i<8;i++){
        for(int j=0;j<3;j++)
            c[i]+=(i>>j&1);
        c[i]=3-c[i];
    }
    pw3[0]=1;
    for(int i=1;i<=N;i++)
        pw3[i]=pw3[i-1]*3;
    f[1][0]=f[1][1]=f[1][2]=1;
    for(int j=0;j<pw3[N];j++){
        int x=j;
        for(int k=0;k<N;k++,x/=3)
            g[j].push_back(x%3);
    }
    for(int i=1;i<N;i++){
        for(int j=0;j<pw3[i];j++){
            for(int k=0;k<pw3[i+1];k++){
                int v=1;
                for(int l=0;l<i;l++)
                    v*=c[1<<g[j][l]|1<<g[k][l]|1<<g[k][l+1]];
                f[i+1][k]+=f[i][j]*v;
            }
        }
    }
    ll ans=0;
    for(int i=0;i<pw3[N];i++)
        ans+=f[N][i];
    printf("%lld\n",ans);
}
```
## Q192
```Python
# https://en.wikipedia.org/wiki/Continued_fraction#Best_rational_approximations
def get_fraction_list(n: int, l: int):
    m = 0
    d = 1
    a = a0 = int(n ** 0.5)
    ls = [a]
    while len(ls) < l:
        m = d * a - m
        d = (n - m * m) / d
        a = int((a0 + m) / d)
        ls.append(a)
    return ls


def allow_half(a: list, k: int):
    i = k
    s = 1
    while i > 0:
        difference = s * (a[i] - a[2 * k - i])
        if difference > 0:
            return True
        if difference < 0:
            return False
        s *= -1
        i -= 1
    return (k & 1) == 0


def solve(m: int, lim: int):
    a = get_fraction_list(m, 128)
    n2, d2 = 1, 0
    n1, d1 = a[0], 1
    i = 1
    while True:
        n = d = 0
        val = (a[i] + 1) >> 1
        if (a[i] & 1) == 0 and not allow_half(a, i):
            val += 1
        for q in range(val, a[i] + 1):
            n, d = n2 + q * n1, d2 + q * d1
            if d > lim:
                if q > val:
                    return d2 + (q - 1) * d1
                else:
                    return d1
        i += 1
        print(n2, n1, n)
        print(d2, d1, d, end="\n\n")
        n2, n1 = n1, n
        d2, d1 = d1, d


N = 10 ** 5
M = 10 ** 12
ans = 0
for S in range(13, 14):
    n = int(S ** 0.5)
    if n * n == S:
        continue
    ans += solve(S, M)
print(ans)
```
## Q198
```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
struct TP{
    ll lu,ld,ru,rd,midd;
};
int main(){
    ll r=100,n=1e8;
    vector<TP>v;
    v.push_back(TP{0,1,1,1,2});
    ll ans=0;
    while(!v.empty()){
        TP t=v.back();v.pop_back();
        ll midd=t.midd,midu=t.lu*t.rd+t.ld*t.ru;
        if(r*midu<midd) ++ans;
        ll gend=t.ld+t.rd,genu=t.lu+t.ru;
        ll lmidd=2ll*t.ld*gend,rmidd=2ll*t.rd*gend;
        if(lmidd<=n)
            v.push_back(TP{t.lu,t.ld,genu,gend,lmidd});
        if(rmidd<=n)
            v.push_back(TP{genu,gend,t.ru,t.rd,rmidd});
    }
    printf("%lld\n",ans);
}
//# 非递归前序遍历Stern-Brocot树以获得F(n)的Farey序列。
// 可以知道，如果分数a和b在某个Farey序列F(n)中相邻，那么(a+b)/2就是其中一个解。
```