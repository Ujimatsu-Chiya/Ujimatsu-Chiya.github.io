# 静态库

本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。库有两种：静态库（.a、.lib）和动态库（.so、.dll）。

所谓静态、动态是指链接的方式。

![](https://www.runoob.com/wp-content/uploads/2015/05/16201601-66b55a2f0ec74c5b8a773a0e1904e812.png)

其实一个静态库可以简单看成是一组目标文件（.o/.obj文件）的集合，即很多目标文件经过压缩打包后形成的一个文件。

特点：

- 静态库对函数库的链接是放在编译时期完成的。
- 程序在运行时与函数库再无瓜葛，移植方便。
- 浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。

![](https://www.runoob.com/wp-content/uploads/2015/05/16201602-e0b2900a915d4dce8b4af5153c8b2d72.png)

2.1.1.Linux静态库命名规则
Linux静态库命名规范，必须是"lib[your_library_name].a"：lib为前缀，中间是静态库名，扩展名为.a。

2.1.2.创建静态库（.a）
通过上面的流程可以知道，Linux创建静态库过程如下：

- 首先，将代码文件编译成目标文件.o（StaticMath.o）

`g++ -c StaticMath.cpp`
注意带参数-c，否则直接编译为可执行文件

- 然后，通过ar工具将目标文件打包成.a静态库文件

`ar -crv libstaticmath.a StaticMath.o`
生成静态库libstaticmath.a。

Linux下使用静态库，只需要在编译的时候，指定静态库的搜索路径（-L选项）、指定静态库名（不需要lib前缀和.a后缀，-l选项）。

`g++ TestStaticLibrary.cpp -L../StaticLibrary -lstaticmath`

- -L：表示要连接的库所在目录

- -l：指定链接时需要的动态库，编译器查找动态连接库时有隐含的命名规则，即在给出的名字前面加上lib，后面加上.a或.so来确定库的名称。

# 动态库

动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，增量更新。
动态库特点总结：

- 动态库把对一些库函数的链接载入推迟到程序运行的时期。

- 可以实现进程之间的资源共享。（因此动态库也称为共享库）

- 将一些程序升级变得简单。

- 甚至可以真正做到链接载入完全由程序员在程序代码中控制（显示调用）。

3.2.1.linux动态库的命名规则
动态链接库的名字形式为 libxxx.so，前缀是lib，后缀名为".so"。

- 针对于实际库文件，每个共享库都有个特殊的名字"soname"。在程序启动后，程序通过这个名字来告诉动态加载器该载入哪个共享库。

- 在文件系统中，soname仅是一个链接到实际动态库的链接。对于动态库而言，每个库实际上都有另一个名字给编译器来用。它是一个指向实际库镜像文件的链接文件（lib+soname+.so）。

3.2.2.创建动态库（.so）

- 首先，生成目标文件，此时要加编译器选项-fpic

`g++ -fPIC -c DynamicMath.cpp`
-fPIC 创建与地址无关的编译程序（pic，position independent code），是为了能够在多个应用程序间共享。

- 然后，生成动态库，此时要加链接器选项-shared

`g++ -shared -o libdynmath.so DynamicMath.o`

其实上面两个步骤可以合并为一个命令：

`g++ -fPIC -shared -o libdynmath.so DynamicMath.cpp`

发现还是报错！！！那么，在执行的时候是如何定位共享库文件的呢？

1) 当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统动态载入器(dynamic linker/loader)。

2) 对于elf格式的可执行程序，是由ld-linux.so*来完成的，它先后搜索elf文件的 DT_RPATH段—环境变量LD_LIBRARY_PATH—/etc/ld.so.cache文件列表—/lib/,/usr/lib 目录找到库文件后将其载入内存。

如何让系统能够找到它：

- 如果安装在/lib或者/usr/lib下，那么ld默认能够找到，无需其他操作。

- 如果安装在其他目录，需要将其添加到/etc/ld.so.cache文件中，步骤如下：

--  编辑/etc/ld.so.conf文件，加入库文件所在目录的路径

--  运行ldconfig ，该命令会重建/etc/ld.so.cache文件

5.1.g++(gcc)编译选项
-  -shared ：指定生成动态链接库。

-  -static ：指定生成静态链接库。

-  -fPIC ：表示编译为位置独立的代码，用于编译共享库。目标文件需要创建成位置无关码， 念上就是在可执行程序装载它们的时候，它们可以放在可执行程序的内存里的任何地方。

-  -L. ：表示要连接的库所在的目录。

-  -l：指定链接时需要的动态库。编译器查找动态连接库时有隐含的命名规则，即在给出的名字前面加上lib，后面加上.a/.so来确定库的名称。

-  -Wall ：生成所有警告信息。

-  -ggdb ：此选项将尽可能的生成gdb 的可以使用的调试信息。

-  -g ：编译器在编译的时候产生调试信息。

-  -c ：只激活预处理、编译和汇编,也就是把程序做成目标文件(.o文件) 。

-  -Wl,options ：把参数(options)传递给链接器ld 。如果options 中间有逗号,就将options分成多个选项,然后传递给链接程序。